/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/event -Ipanda/src/event -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3event_igate.cxx -od built/pandac/input/libp3event.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/event -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3event asyncFuture.h asyncFuture_ext.h asyncTask.h asyncTaskChain.h asyncTaskCollection.h asyncTaskManager.h asyncTaskPause.h asyncTaskSequence.h buttonEvent.h buttonEventList.h config_event.h event.h eventHandler.h eventParameter.h eventQueue.h eventReceiver.h genericAsyncTask.h p3event_composite1.cxx p3event_composite2.cxx pointerEvent.h pointerEventList.h pt_Event.h pythonTask.h throw_event.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "asyncFuture.h"
#include "asyncFuture_ext.h"
#include "asyncTask.h"
#include "asyncTaskChain.h"
#include "asyncTaskCollection.h"
#include "asyncTaskManager.h"
#include "asyncTaskPause.h"
#include "asyncTaskSequence.h"
#include "atomicAdjust.h"
#include "buttonEvent.h"
#include "buttonEventList.h"
#include "buttonHandle.h"
#include "clockObject.h"
#include "conditionVar.h"
#include "config_event.h"
#include "event.h"
#include "eventHandler.h"
#include "eventParameter.h"
#include "eventQueue.h"
#include "eventReceiver.h"
#include "extension.h"
#include "genericAsyncTask.h"
#include "indirectCompareNames.h"
#include "lightMutex.h"
#include "modifierButtons.h"
#include "mutexHolder.h"
#include "namable.h"
#include "notifyCategoryProxy.h"
#include "ordered_vector.h"
#include "pStatCollector.h"
#include "pandabase.h"
#include "pdeque.h"
#include "pmap.h"
#include "pmutex.h"
#include "pointerEvent.h"
#include "pointerEventList.h"
#include "pset.h"
#include "pt_Event.h"
#include "pvector.h"
#include "py_panda.h"
#include "pythonTask.h"
#include "thread.h"
#include "throw_event.h"
#include "typedObject.h"
#include "typedReferenceCount.h"
#include "typedWritableReferenceCount.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class EventParameter
 */
typedef EventParameter EventParameter_localtype;
Define_Module_Class(panda3d.core, EventParameter, EventParameter_localtype, EventParameter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EventParameter = &Dtool_EventParameter;
static void Dtool_PyModuleClassInit_EventParameter(PyObject *module);
EventParameter *Dtool_Coerce_EventParameter(PyObject *args, EventParameter &coerced);

/**
 * Forward declarations for top-level class AsyncFuture
 */
typedef AsyncFuture AsyncFuture_localtype;
Define_Module_ClassRef(panda3d.core, AsyncFuture, AsyncFuture_localtype, AsyncFuture);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncFuture = &Dtool_AsyncFuture;
static void Dtool_PyModuleClassInit_AsyncFuture(PyObject *module);

/**
 * Forward declarations for top-level class AsyncTask
 */
typedef AsyncTask AsyncTask_localtype;
Define_Module_ClassRef(panda3d.core, AsyncTask, AsyncTask_localtype, AsyncTask);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTask = &Dtool_AsyncTask;
static void Dtool_PyModuleClassInit_AsyncTask(PyObject *module);

/**
 * Forward declarations for top-level class AsyncTaskManager
 */
typedef AsyncTaskManager AsyncTaskManager_localtype;
Define_Module_ClassRef(panda3d.core, AsyncTaskManager, AsyncTaskManager_localtype, AsyncTaskManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTaskManager = &Dtool_AsyncTaskManager;
static void Dtool_PyModuleClassInit_AsyncTaskManager(PyObject *module);

/**
 * Forward declarations for top-level class AsyncTaskCollection
 */
typedef AsyncTaskCollection AsyncTaskCollection_localtype;
Define_Module_Class(panda3d.core, AsyncTaskCollection, AsyncTaskCollection_localtype, AsyncTaskCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTaskCollection = &Dtool_AsyncTaskCollection;
static void Dtool_PyModuleClassInit_AsyncTaskCollection(PyObject *module);

/**
 * Forward declarations for top-level class AsyncTaskChain
 */
typedef AsyncTaskChain AsyncTaskChain_localtype;
Define_Module_ClassRef(panda3d.core, AsyncTaskChain, AsyncTaskChain_localtype, AsyncTaskChain);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTaskChain = &Dtool_AsyncTaskChain;
static void Dtool_PyModuleClassInit_AsyncTaskChain(PyObject *module);

/**
 * Forward declarations for top-level class AsyncTaskPause
 */
typedef AsyncTaskPause AsyncTaskPause_localtype;
Define_Module_ClassRef(panda3d.core, AsyncTaskPause, AsyncTaskPause_localtype, AsyncTaskPause);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTaskPause = &Dtool_AsyncTaskPause;
static void Dtool_PyModuleClassInit_AsyncTaskPause(PyObject *module);
bool Dtool_ConstCoerce_AsyncTaskPause(PyObject *args, CPT(AsyncTaskPause) &coerced);
bool Dtool_Coerce_AsyncTaskPause(PyObject *args, PT(AsyncTaskPause) &coerced);

/**
 * Forward declarations for top-level class AsyncTaskSequence
 */
typedef AsyncTaskSequence AsyncTaskSequence_localtype;
Define_Module_ClassRef(panda3d.core, AsyncTaskSequence, AsyncTaskSequence_localtype, AsyncTaskSequence);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTaskSequence = &Dtool_AsyncTaskSequence;
static void Dtool_PyModuleClassInit_AsyncTaskSequence(PyObject *module);

/**
 * Forward declarations for top-level class ButtonEventList
 */
typedef ButtonEventList ButtonEventList_localtype;
Define_Module_ClassRef(panda3d.core, ButtonEventList, ButtonEventList_localtype, ButtonEventList);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ButtonEventList = &Dtool_ButtonEventList;
static void Dtool_PyModuleClassInit_ButtonEventList(PyObject *module);

/**
 * Forward declarations for top-level class Event
 */
typedef Event Event_localtype;
Define_Module_ClassRef(panda3d.core, Event, Event_localtype, Event);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Event = &Dtool_Event;
static void Dtool_PyModuleClassInit_Event(PyObject *module);
bool Dtool_ConstCoerce_Event(PyObject *args, CPT(Event) &coerced);
bool Dtool_Coerce_Event(PyObject *args, PT(Event) &coerced);

/**
 * Forward declarations for top-level class EventHandler
 */
typedef EventHandler EventHandler_localtype;
Define_Module_Class(panda3d.core, EventHandler, EventHandler_localtype, EventHandler);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EventHandler = &Dtool_EventHandler;
static void Dtool_PyModuleClassInit_EventHandler(PyObject *module);

/**
 * Forward declarations for top-level class EventQueue
 */
typedef EventQueue EventQueue_localtype;
Define_Module_Class(panda3d.core, EventQueue, EventQueue_localtype, EventQueue);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EventQueue = &Dtool_EventQueue;
static void Dtool_PyModuleClassInit_EventQueue(PyObject *module);

/**
 * Forward declarations for top-level class PointerEventList
 */
typedef PointerEventList PointerEventList_localtype;
Define_Module_ClassRef(panda3d.core, PointerEventList, PointerEventList_localtype, PointerEventList);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerEventList = &Dtool_PointerEventList;
static void Dtool_PyModuleClassInit_PointerEventList(PyObject *module);

/**
 * Forward declarations for top-level class PythonTask
 */
typedef PythonTask PythonTask_localtype;
Define_Module_ClassRef(panda3d.core, PythonTask, PythonTask_localtype, PythonTask);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PythonTask = &Dtool_PythonTask;
static void Dtool_PyModuleClassInit_PythonTask(PyObject *module);
bool Dtool_ConstCoerce_PythonTask(PyObject *args, CPT(PythonTask) &coerced);
bool Dtool_Coerce_PythonTask(PyObject *args, PT(PythonTask) &coerced);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"EventParameter", &Dtool_EventParameter},
  {"AsyncFuture", &Dtool_AsyncFuture},
  {"AsyncTask", &Dtool_AsyncTask},
  {"AsyncTaskManager", &Dtool_AsyncTaskManager},
  {"AsyncTaskCollection", &Dtool_AsyncTaskCollection},
  {"AsyncTaskChain", &Dtool_AsyncTaskChain},
  {"AsyncTaskPause", &Dtool_AsyncTaskPause},
  {"AsyncTaskSequence", &Dtool_AsyncTaskSequence},
  {"ButtonEventList", &Dtool_ButtonEventList},
  {"Event", &Dtool_Event},
  {"EventHandler", &Dtool_EventHandler},
  {"EventQueue", &Dtool_EventQueue},
  {"PointerEventList", &Dtool_PointerEventList},
  {"PythonTask", &Dtool_PythonTask},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[1].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[2].type)
  {"GlobPattern", nullptr},
#define Dtool_Ptr_GlobPattern (imports[3].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[4].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[5].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[6].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[7].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[8].type)
  {"ParamValueBase", nullptr},
#define Dtool_Ptr_ParamValueBase (imports[9].type)
  {"ClockObject", nullptr},
#define Dtool_Ptr_ClockObject (imports[10].type)
  {"ModifierButtons", nullptr},
#define Dtool_Ptr_ModifierButtons (imports[11].type)
  {"PointerData", nullptr},
#define Dtool_Ptr_PointerData (imports[12].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// GlobPattern
#ifndef LINK_ALL_STATIC
inline static GlobPattern *Dtool_Coerce_GlobPattern(PyObject *args, GlobPattern &coerced) {
  nassertr(Dtool_Ptr_GlobPattern != nullptr, nullptr);
  nassertr(Dtool_Ptr_GlobPattern->_Dtool_Coerce != nullptr, nullptr);
  return ((GlobPattern *(*)(PyObject *, GlobPattern &))Dtool_Ptr_GlobPattern->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_GlobPattern;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GlobPattern = &Dtool_GlobPattern;
extern GlobPattern *Dtool_Coerce_GlobPattern(PyObject *args, GlobPattern &coerced);
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// ParamValueBase
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ParamValueBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValueBase = &Dtool_ParamValueBase;
#endif
// ClockObject
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_ClockObject(PyObject *args, CPT(ClockObject) &coerced) {
  nassertr(Dtool_Ptr_ClockObject != nullptr, false);
  nassertr(Dtool_Ptr_ClockObject->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(ClockObject) &))Dtool_Ptr_ClockObject->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_ClockObject(PyObject *args, PT(ClockObject) &coerced) {
  nassertr(Dtool_Ptr_ClockObject != nullptr, false);
  nassertr(Dtool_Ptr_ClockObject->_Dtool_Coerce != nullptr, false);
  return ((bool (*)(PyObject *, PT(ClockObject) &))Dtool_Ptr_ClockObject->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_ClockObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ClockObject = &Dtool_ClockObject;
extern bool Dtool_ConstCoerce_ClockObject(PyObject *args, CPT(ClockObject) &coerced);
extern bool Dtool_Coerce_ClockObject(PyObject *args, PT(ClockObject) &coerced);
#endif
// ModifierButtons
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ModifierButtons;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ModifierButtons = &Dtool_ModifierButtons;
#endif
// PointerData
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PointerData;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerData = &Dtool_PointerData;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class EventParameter
 */
/**
 * Python function wrapper for:
 * inline void EventParameter::operator =(EventParameter const &copy)
 */
static PyObject *Dtool_EventParameter_operator_3(PyObject *self, PyObject *arg) {
  EventParameter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EventParameter, (void **)&local_this, "EventParameter.assign")) {
    return nullptr;
  }
  // 1-inline void EventParameter::operator =(EventParameter const &copy)
  EventParameter arg_local;
  EventParameter const *arg_this = Dtool_Coerce_EventParameter(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EventParameter.assign", "EventParameter");
  }
  ((*local_this).operator =)(*arg_this);
  EventParameter *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EventParameter, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const EventParameter self, const EventParameter copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_operator_3_comment =
  "C++ Interface:\n"
  "assign(const EventParameter self, const EventParameter copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EventParameter_operator_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EventParameter::is_empty(void) const
 */
static PyObject *Dtool_EventParameter_is_empty_5(PyObject *self, PyObject *) {
  EventParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EventParameter)) {
    return nullptr;
  }
  // 1-inline bool EventParameter::is_empty(void) const
  bool return_value = ((*(const EventParameter*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_is_empty_5_comment =
  "C++ Interface:\n"
  "is_empty(EventParameter self)\n"
  "\n"
  "// These functions are conveniences to easily determine if the\n"
  "// EventParameter is one of the predefined parameter types, and retrieve the\n"
  "// corresponding value.  Of course, it is possible that the EventParameter\n"
  "// is some user-defined type, and is none of these.\n"
  "\n"
  "/**\n"
  " * Returns true if the EventParameter is the empty parameter, storing nothing,\n"
  " * or false otherwise.\n"
  " */";
#else
static const char *Dtool_EventParameter_is_empty_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EventParameter::is_int(void) const
 */
static PyObject *Dtool_EventParameter_is_int_6(PyObject *self, PyObject *) {
  EventParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EventParameter)) {
    return nullptr;
  }
  // 1-inline bool EventParameter::is_int(void) const
  bool return_value = ((*(const EventParameter*)local_this).is_int)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_is_int_6_comment =
  "C++ Interface:\n"
  "is_int(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the EventParameter stores an integer value, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_EventParameter_is_int_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int EventParameter::get_int_value(void) const
 */
static PyObject *Dtool_EventParameter_get_int_value_7(PyObject *self, PyObject *) {
  EventParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EventParameter)) {
    return nullptr;
  }
  // 1-inline int EventParameter::get_int_value(void) const
  int return_value = ((*(const EventParameter*)local_this).get_int_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_get_int_value_7_comment =
  "C++ Interface:\n"
  "get_int_value(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Retrieves the value stored in the EventParameter.  It is only valid to call\n"
  " * this if is_int() has already returned true.\n"
  " */";
#else
static const char *Dtool_EventParameter_get_int_value_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EventParameter::is_double(void) const
 */
static PyObject *Dtool_EventParameter_is_double_8(PyObject *self, PyObject *) {
  EventParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EventParameter)) {
    return nullptr;
  }
  // 1-inline bool EventParameter::is_double(void) const
  bool return_value = ((*(const EventParameter*)local_this).is_double)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_is_double_8_comment =
  "C++ Interface:\n"
  "is_double(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the EventParameter stores a double floating-point value,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_EventParameter_is_double_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double EventParameter::get_double_value(void) const
 */
static PyObject *Dtool_EventParameter_get_double_value_9(PyObject *self, PyObject *) {
  EventParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EventParameter)) {
    return nullptr;
  }
  // 1-inline double EventParameter::get_double_value(void) const
  double return_value = ((*(const EventParameter*)local_this).get_double_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_get_double_value_9_comment =
  "C++ Interface:\n"
  "get_double_value(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Retrieves the value stored in the EventParameter.  It is only valid to call\n"
  " * this if is_double() has already returned true.\n"
  " */";
#else
static const char *Dtool_EventParameter_get_double_value_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EventParameter::is_string(void) const
 */
static PyObject *Dtool_EventParameter_is_string_10(PyObject *self, PyObject *) {
  EventParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EventParameter)) {
    return nullptr;
  }
  // 1-inline bool EventParameter::is_string(void) const
  bool return_value = ((*(const EventParameter*)local_this).is_string)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_is_string_10_comment =
  "C++ Interface:\n"
  "is_string(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the EventParameter stores a string value, false otherwise.\n"
  " */";
#else
static const char *Dtool_EventParameter_is_string_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string EventParameter::get_string_value(void) const
 */
static PyObject *Dtool_EventParameter_get_string_value_11(PyObject *self, PyObject *) {
  EventParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EventParameter)) {
    return nullptr;
  }
  // 1-inline std::string EventParameter::get_string_value(void) const
  std::string return_value = ((*(const EventParameter*)local_this).get_string_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_get_string_value_11_comment =
  "C++ Interface:\n"
  "get_string_value(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Retrieves the value stored in the EventParameter.  It is only valid to call\n"
  " * this if is_string() has already returned true.\n"
  " */";
#else
static const char *Dtool_EventParameter_get_string_value_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EventParameter::is_wstring(void) const
 */
static PyObject *Dtool_EventParameter_is_wstring_12(PyObject *self, PyObject *) {
  EventParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EventParameter)) {
    return nullptr;
  }
  // 1-inline bool EventParameter::is_wstring(void) const
  bool return_value = ((*(const EventParameter*)local_this).is_wstring)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_is_wstring_12_comment =
  "C++ Interface:\n"
  "is_wstring(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the EventParameter stores a wstring value, false otherwise.\n"
  " */";
#else
static const char *Dtool_EventParameter_is_wstring_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::wstring EventParameter::get_wstring_value(void) const
 */
static PyObject *Dtool_EventParameter_get_wstring_value_13(PyObject *self, PyObject *) {
  EventParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EventParameter)) {
    return nullptr;
  }
  // 1-inline std::wstring EventParameter::get_wstring_value(void) const
  std::wstring return_value = ((*(const EventParameter*)local_this).get_wstring_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_get_wstring_value_13_comment =
  "C++ Interface:\n"
  "get_wstring_value(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Retrieves the value stored in the EventParameter.  It is only valid to call\n"
  " * this if is_wstring() has already returned true.\n"
  " */";
#else
static const char *Dtool_EventParameter_get_wstring_value_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool EventParameter::is_typed_ref_count(void) const
 */
static PyObject *Dtool_EventParameter_is_typed_ref_count_14(PyObject *self, PyObject *) {
  EventParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EventParameter)) {
    return nullptr;
  }
  // 1-inline bool EventParameter::is_typed_ref_count(void) const
  bool return_value = ((*(const EventParameter*)local_this).is_typed_ref_count)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_is_typed_ref_count_14_comment =
  "C++ Interface:\n"
  "is_typed_ref_count(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the EventParameter stores a TypedReferenceCount pointer,\n"
  " * false otherwise.  Note that a TypedReferenceCount is not exactly the same\n"
  " * kind of pointer as a TypedWritableReferenceCount, hence the need for this\n"
  " * separate call.\n"
  " */";
#else
static const char *Dtool_EventParameter_is_typed_ref_count_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TypedReferenceCount *EventParameter::get_typed_ref_count_value(void) const
 */
static PyObject *Dtool_EventParameter_get_typed_ref_count_value_15(PyObject *self, PyObject *) {
  EventParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EventParameter)) {
    return nullptr;
  }
  // 1-inline TypedReferenceCount *EventParameter::get_typed_ref_count_value(void) const
  TypedReferenceCount *return_value = ((*(const EventParameter*)local_this).get_typed_ref_count_value)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_get_typed_ref_count_value_15_comment =
  "C++ Interface:\n"
  "get_typed_ref_count_value(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Retrieves the value stored in the EventParameter.  It is only valid to call\n"
  " * this if is_typed_ref_count() has already returned true.\n"
  " */";
#else
static const char *Dtool_EventParameter_get_typed_ref_count_value_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TypedWritableReferenceCount *EventParameter::get_ptr(void) const
 */
static PyObject *Dtool_EventParameter_get_ptr_16(PyObject *self, PyObject *) {
  EventParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EventParameter)) {
    return nullptr;
  }
  // 1-inline TypedWritableReferenceCount *EventParameter::get_ptr(void) const
  TypedWritableReferenceCount *return_value = ((*(const EventParameter*)local_this).get_ptr)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_get_ptr_16_comment =
  "C++ Interface:\n"
  "get_ptr(EventParameter self)\n"
  "\n"
  "/**\n"
  " * Retrieves a pointer to the actual value stored in the parameter.  The\n"
  " * TypeHandle of this pointer may be examined to determine the actual type of\n"
  " * parameter it contains.  This is the only way to retrieve the value when it\n"
  " * is not one of the above predefined types.\n"
  " */";
#else
static const char *Dtool_EventParameter_get_ptr_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EventParameter::output(std::ostream &out) const
 */
static PyObject *Dtool_EventParameter_output_17(PyObject *self, PyObject *arg) {
  EventParameter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EventParameter)) {
    return nullptr;
  }
  // 1-void EventParameter::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "EventParameter.output", false, true);
  if (arg_this != nullptr) {
    ((*(const EventParameter*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(EventParameter self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EventParameter_output_17_comment =
  "C++ Interface:\n"
  "output(EventParameter self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EventParameter_output_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EventParameter::EventParameter(void) = default
 * inline EventParameter::EventParameter(EventParameter const &copy)
 * inline EventParameter::EventParameter(TypedReferenceCount const *ptr)
 * inline EventParameter::EventParameter(TypedWritableReferenceCount const *ptr)
 * inline EventParameter::EventParameter(double value)
 * inline EventParameter::EventParameter(int value)
 * inline EventParameter::EventParameter(std::nullptr_t )
 * inline EventParameter::EventParameter(std::string const &value)
 * inline EventParameter::EventParameter(std::wstring const &value)
 */
static int Dtool_Init_EventParameter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline EventParameter::EventParameter(void) = default
      EventParameter *return_value = new EventParameter();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline EventParameter::EventParameter(EventParameter const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EventParameter const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_EventParameter);
          if (param0_this != nullptr) {
            EventParameter *return_value = new EventParameter(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
          }
        }
      }

      {
        // -2 inline EventParameter::EventParameter(TypedReferenceCount const *ptr)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "ptr")) {
          TypedReferenceCount const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypedReferenceCount);
          if (param0_this != nullptr) {
            EventParameter *return_value = new EventParameter(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
          }
        }
      }

      {
        // -2 inline EventParameter::EventParameter(TypedWritableReferenceCount const *ptr)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "ptr")) {
          TypedWritableReferenceCount const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypedWritableReferenceCount);
          if (param0_this != nullptr) {
            EventParameter *return_value = new EventParameter(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
          }
        }
      }

      {
        // -2 inline EventParameter::EventParameter(std::nullptr_t )
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          if (param0 == Py_None) {
            EventParameter *return_value = new EventParameter(nullptr);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
          }
        }
      }

      {
        // -2 inline EventParameter::EventParameter(std::wstring const &value)
#if PY_VERSION_HEX >= 0x03020000
        PyObject *param0;
#else
        PyUnicodeObject *param0;
#endif
        static const char *keyword_list[] = {"value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "U:EventParameter", (char **)keyword_list, &param0)) {
#if PY_VERSION_HEX >= 0x03030000
          Py_ssize_t param0_len;
          wchar_t *param0_str = PyUnicode_AsWideCharString(param0, &param0_len);
#else
          Py_ssize_t param0_len = PyUnicode_GET_SIZE(param0);
          wchar_t *param0_str = (wchar_t *)alloca(sizeof(wchar_t) * (param0_len + 1));
          PyUnicode_AsWideChar(param0, param0_str, param0_len);
#endif
          EventParameter *return_value = new EventParameter(std::wstring(param0_str, param0_len));
#if PY_VERSION_HEX >= 0x03030000
          PyMem_Free(param0_str);
#endif
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline EventParameter::EventParameter(std::string const &value)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:EventParameter", (char **)keyword_list, &param0_str, &param0_len)) {
          EventParameter *return_value = new EventParameter(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline EventParameter::EventParameter(int value)
        int param0;
        static const char *keyword_list[] = {"value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:EventParameter", (char **)keyword_list, &param0)) {
          EventParameter *return_value = new EventParameter((int)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline EventParameter::EventParameter(double value)
        double param0;
        static const char *keyword_list[] = {"value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "d:EventParameter", (char **)keyword_list, &param0)) {
          EventParameter *return_value = new EventParameter((double)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline EventParameter::EventParameter(EventParameter const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          EventParameter param0_local;
          EventParameter const *param0_this = Dtool_Coerce_EventParameter(param0, param0_local);
          if ((param0_this != nullptr)) {
            EventParameter *return_value = new EventParameter(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventParameter, true, false);
          }
        }
      }

      // No coercion possible: inline EventParameter::EventParameter(TypedReferenceCount const *ptr)
      // No coercion possible: inline EventParameter::EventParameter(TypedWritableReferenceCount const *ptr)
      // No coercion possible: inline EventParameter::EventParameter(std::nullptr_t )
      // No coercion possible: inline EventParameter::EventParameter(std::wstring const &value)
      // No coercion possible: inline EventParameter::EventParameter(std::string const &value)
      // No coercion possible: inline EventParameter::EventParameter(int value)
      // No coercion possible: inline EventParameter::EventParameter(double value)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "EventParameter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EventParameter()\n"
      "EventParameter(const EventParameter copy)\n"
      "EventParameter(const TypedReferenceCount ptr)\n"
      "EventParameter(const TypedWritableReferenceCount ptr)\n"
      "EventParameter(NoneType param0)\n"
      "EventParameter(unicode value)\n"
      "EventParameter(str value)\n"
      "EventParameter(int value)\n"
      "EventParameter(double value)\n");
  }
  return -1;
}

EventParameter *Dtool_Coerce_EventParameter(PyObject *args, EventParameter &coerced) {
  EventParameter *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_EventParameter)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const EventParameter *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline EventParameter::EventParameter(TypedReferenceCount const *ptr)
      TypedReferenceCount const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypedReferenceCount);
      if (arg_this != nullptr) {
        coerced = EventParameter(arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline EventParameter::EventParameter(TypedWritableReferenceCount const *ptr)
      TypedWritableReferenceCount const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypedWritableReferenceCount);
      if (arg_this != nullptr) {
        coerced = EventParameter(arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline EventParameter::EventParameter(std::nullptr_t )
      if (arg == Py_None) {
        coerced = EventParameter(nullptr);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline EventParameter::EventParameter(std::wstring const &value)
#if PY_VERSION_HEX >= 0x03020000
      PyObject *param0;
#else
      PyUnicodeObject *param0;
#endif
      if (PyArg_Parse(arg, "U:EventParameter", &param0)) {
#if PY_VERSION_HEX >= 0x03030000
        Py_ssize_t param0_len;
        wchar_t *param0_str = PyUnicode_AsWideCharString(param0, &param0_len);
#else
        Py_ssize_t param0_len = PyUnicode_GET_SIZE(param0);
        wchar_t *param0_str = (wchar_t *)alloca(sizeof(wchar_t) * (param0_len + 1));
        PyUnicode_AsWideChar(param0, param0_str, param0_len);
#endif
        coerced = EventParameter(std::wstring(param0_str, param0_len));
#if PY_VERSION_HEX >= 0x03030000
        PyMem_Free(param0_str);
#endif
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 inline EventParameter::EventParameter(std::string const &value)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
        param0_str = nullptr;
      }
#endif
      if (param0_str != nullptr) {
        coerced = EventParameter(std::string(param0_str, param0_len));
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 inline EventParameter::EventParameter(int value)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return nullptr;
        }
#endif
        coerced = EventParameter((int)arg_val);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline EventParameter::EventParameter(double value)
      if (PyNumber_Check(arg)) {
        coerced = EventParameter(PyFloat_AsDouble(arg));
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_EventParameter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EventParameter) {
    printf("EventParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EventParameter *local_this = (EventParameter *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EventParameter) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EventParameter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EventParameter) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AsyncFuture
 */
/**
 * Python function wrapper for:
 * inline bool AsyncFuture::done(void) const
 */
static PyObject *Dtool_AsyncFuture_done_23(PyObject *self, PyObject *) {
  AsyncFuture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncFuture)) {
    return nullptr;
  }
  // 1-inline bool AsyncFuture::done(void) const
  bool return_value = ((*(const AsyncFuture*)local_this).done)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncFuture_done_23_comment =
  "C++ Interface:\n"
  "done(AsyncFuture self)\n"
  "\n"
  "/**\n"
  " * Returns true if the future is done or has been cancelled.  It is always\n"
  " * safe to call this.\n"
  " */";
#else
static const char *Dtool_AsyncFuture_done_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AsyncFuture::cancelled(void) const
 */
static PyObject *Dtool_AsyncFuture_cancelled_24(PyObject *self, PyObject *) {
  AsyncFuture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncFuture)) {
    return nullptr;
  }
  // 1-inline bool AsyncFuture::cancelled(void) const
  bool return_value = ((*(const AsyncFuture*)local_this).cancelled)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncFuture_cancelled_24_comment =
  "C++ Interface:\n"
  "cancelled(AsyncFuture self)\n"
  "\n"
  "/**\n"
  " * Returns true if the future was cancelled.  It is always safe to call this.\n"
  " */";
#else
static const char *Dtool_AsyncFuture_cancelled_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *AsyncFuture::result(PyObject *timeout = (& ::_Py_NoneStruct)) const
 */
static PyObject *Dtool_AsyncFuture_result_25(PyObject *self, PyObject *args, PyObject *kwds) {
  AsyncFuture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncFuture)) {
    return nullptr;
  }
  // 1-PyObject *AsyncFuture::result(PyObject *timeout = (& ::_Py_NoneStruct)) const
  PyObject *param1 = (& ::_Py_NoneStruct);
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "timeout")) {
    PyObject *return_value = invoke_extension((const AsyncFuture*)local_this).result(param1);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "result(AsyncFuture self, object timeout)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncFuture_result_25_comment =
  "C++ Interface:\n"
  "result(AsyncFuture self, object timeout)\n";
#else
static const char *Dtool_AsyncFuture_result_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool AsyncFuture::cancel(void)
 */
static PyObject *Dtool_AsyncFuture_cancel_26(PyObject *self, PyObject *) {
  AsyncFuture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncFuture, (void **)&local_this, "AsyncFuture.cancel")) {
    return nullptr;
  }
  // 1-virtual bool AsyncFuture::cancel(void)
  bool return_value = ((*local_this).cancel)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncFuture_cancel_26_comment =
  "C++ Interface:\n"
  "cancel(const AsyncFuture self)\n"
  "\n"
  "/**\n"
  " * Cancels the future.  Returns true if it was cancelled, or false if the\n"
  " * future was already done.  Either way, done() will return true after this\n"
  " * call returns.\n"
  " *\n"
  " * In the case of a task, this is equivalent to remove().\n"
  " */";
#else
static const char *Dtool_AsyncFuture_cancel_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AsyncFuture::set_done_event(std::string const &done_event)
 */
static PyObject *Dtool_AsyncFuture_set_done_event_27(PyObject *self, PyObject *arg) {
  AsyncFuture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncFuture, (void **)&local_this, "AsyncFuture.set_done_event")) {
    return nullptr;
  }
  // 1-inline void AsyncFuture::set_done_event(std::string const &done_event)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_done_event)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_done_event(const AsyncFuture self, str done_event)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncFuture_set_done_event_27_comment =
  "C++ Interface:\n"
  "set_done_event(const AsyncFuture self, str done_event)\n"
  "\n"
  "/**\n"
  " * Sets the event name that will be triggered when the future finishes.  Will\n"
  " * not be triggered if the future is cancelled, but it will be triggered for\n"
  " * a coroutine task that exits with an exception.\n"
  " */";
#else
static const char *Dtool_AsyncFuture_set_done_event_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &AsyncFuture::get_done_event(void) const
 */
static PyObject *Dtool_AsyncFuture_get_done_event_28(PyObject *self, PyObject *) {
  AsyncFuture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncFuture)) {
    return nullptr;
  }
  // 1-inline std::string const &AsyncFuture::get_done_event(void) const
  std::string const &return_value = ((*(const AsyncFuture*)local_this).get_done_event)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncFuture_get_done_event_28_comment =
  "C++ Interface:\n"
  "get_done_event(AsyncFuture self)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be triggered when the future finishes.\n"
  " * See set_done_event().\n"
  " */";
#else
static const char *Dtool_AsyncFuture_get_done_event_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *AsyncFuture::add_done_callback(PyObject *self, PyObject *fn)
 */
static PyObject *Dtool_AsyncFuture_add_done_callback_33(PyObject *self, PyObject *arg) {
  AsyncFuture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncFuture, (void **)&local_this, "AsyncFuture.add_done_callback")) {
    return nullptr;
  }
  // 1-PyObject *AsyncFuture::add_done_callback(PyObject *self, PyObject *fn)
  PyObject *return_value = invoke_extension(local_this).add_done_callback(self, arg);
  return Dtool_Return(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_done_callback(const AsyncFuture self, object fn)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncFuture_add_done_callback_33_comment =
  "C++ Interface:\n"
  "add_done_callback(const AsyncFuture self, object fn)\n";
#else
static const char *Dtool_AsyncFuture_add_done_callback_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PyObject *AsyncFuture::gather(PyObject *args)
 */
static PyObject *Dtool_AsyncFuture_gather_34(PyObject *, PyObject *args) {
  PyObject *return_value = Extension<AsyncFuture>::gather(args);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncFuture_gather_34_comment =
  "/**\n"
  " * Creates a new future that returns `done()` when all of the contained\n"
  " * futures are done.\n"
  " *\n"
  " * Calling `cancel()` on the returned future will result in all contained\n"
  " * futures that have not yet finished to be cancelled.\n"
  " */";
#else
static const char *Dtool_AsyncFuture_gather_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AsyncFuture::output(std::ostream &out) const
 */
static PyObject *Dtool_AsyncFuture_output_35(PyObject *self, PyObject *arg) {
  AsyncFuture *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncFuture)) {
    return nullptr;
  }
  // 1-virtual void AsyncFuture::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AsyncFuture.output", false, true);
  if (arg_this != nullptr) {
    ((*(const AsyncFuture*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AsyncFuture self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncFuture_output_35_comment =
  "C++ Interface:\n"
  "output(AsyncFuture self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AsyncFuture_output_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncFuture::wait(void)
 * void AsyncFuture::wait(double timeout)
 */
static PyObject *Dtool_AsyncFuture_wait_36(PyObject *self, PyObject *args) {
  AsyncFuture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncFuture, (void **)&local_this, "AsyncFuture.wait")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-void AsyncFuture::wait(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*local_this).wait)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void AsyncFuture::wait(double timeout)
      if (PyNumber_Check(arg)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        ((*local_this).wait)(PyFloat_AsDouble(arg));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "wait() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "wait(const AsyncFuture self)\n"
      "wait(const AsyncFuture self, double timeout)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncFuture_wait_36_comment =
  "C++ Interface:\n"
  "wait(const AsyncFuture self)\n"
  "wait(const AsyncFuture self, double timeout)\n"
  "\n"
  "/**\n"
  " * Waits until the future is done.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Waits until the future is done, or until the timeout is reached.\n"
  " */";
#else
static const char *Dtool_AsyncFuture_wait_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AsyncFuture::set_result(EventParameter const &result)
 * inline void AsyncFuture::set_result(TypedObject *result)
 * inline void AsyncFuture::set_result(TypedReferenceCount *result)
 * inline void AsyncFuture::set_result(TypedWritableReferenceCount *result)
 * inline void AsyncFuture::set_result(std::nullptr_t )
 */
static PyObject *Dtool_AsyncFuture_set_result_37(PyObject *self, PyObject *arg) {
  AsyncFuture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncFuture, (void **)&local_this, "AsyncFuture.set_result")) {
    return nullptr;
  }
  {
    // -2 inline void AsyncFuture::set_result(TypedWritableReferenceCount *result)
    TypedWritableReferenceCount *arg_this = (TypedWritableReferenceCount *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritableReferenceCount, 1, "AsyncFuture.set_result", false, false);
    if (arg_this != nullptr) {
      ((*local_this).set_result)(arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void AsyncFuture::set_result(EventParameter const &result)
    EventParameter const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_EventParameter);
    if (arg_this != nullptr) {
      ((*local_this).set_result)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void AsyncFuture::set_result(TypedObject *result)
    TypedObject *arg_this = (TypedObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedObject, 1, "AsyncFuture.set_result", false, false);
    if (arg_this != nullptr) {
      ((*local_this).set_result)(arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void AsyncFuture::set_result(TypedReferenceCount *result)
    TypedReferenceCount *arg_this = (TypedReferenceCount *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedReferenceCount, 1, "AsyncFuture.set_result", false, false);
    if (arg_this != nullptr) {
      ((*local_this).set_result)(arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void AsyncFuture::set_result(std::nullptr_t )
    if (arg == Py_None) {
      ((*local_this).set_result)(nullptr);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: inline void AsyncFuture::set_result(TypedWritableReferenceCount *result)
  {
    // -2 inline void AsyncFuture::set_result(EventParameter const &result)
    EventParameter arg_local;
    EventParameter const *arg_this = Dtool_Coerce_EventParameter(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_result)(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: inline void AsyncFuture::set_result(TypedObject *result)
  // No coercion possible: inline void AsyncFuture::set_result(TypedReferenceCount *result)
  // No coercion possible: inline void AsyncFuture::set_result(std::nullptr_t )
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_result(const AsyncFuture self, TypedWritableReferenceCount result)\n"
      "set_result(const AsyncFuture self, const EventParameter result)\n"
      "set_result(const AsyncFuture self, TypedObject result)\n"
      "set_result(const AsyncFuture self, TypedReferenceCount result)\n"
      "set_result(const AsyncFuture self, NoneType param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncFuture_set_result_37_comment =
  "C++ Interface:\n"
  "set_result(const AsyncFuture self, TypedWritableReferenceCount result)\n"
  "set_result(const AsyncFuture self, const EventParameter result)\n"
  "set_result(const AsyncFuture self, TypedObject result)\n"
  "set_result(const AsyncFuture self, TypedReferenceCount result)\n"
  "set_result(const AsyncFuture self, NoneType param0)\n"
  "\n"
  "/**\n"
  " * Sets this future's result.  Can only be called if done() returns false.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Sets this future's result.  Can only be done while the future is not done.\n"
  " * Calling this marks the future as done and schedules the done callbacks.\n"
  " *\n"
  " * This variant takes two pointers; the second one is only set if this object\n"
  " * inherits from ReferenceCount, so that a reference can be held.\n"
  " *\n"
  " * Assumes the manager's lock is *not* held.\n"
  " */";
#else
static const char *Dtool_AsyncFuture_set_result_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AsyncFuture::get_class_type(void)
 */
static PyObject *Dtool_AsyncFuture_get_class_type_38(PyObject *, PyObject *) {
  // 1-static TypeHandle AsyncFuture::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AsyncFuture::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncFuture_get_class_type_38_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AsyncFuture_get_class_type_38_comment = nullptr;
#endif

static PyObject *Dtool_AsyncFuture_done_event_Getter(PyObject *self, void *) {
  const AsyncFuture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncFuture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &AsyncFuture::get_done_event(void) const
  std::string const &return_value = ((*(const AsyncFuture*)local_this).get_done_event)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_AsyncFuture_done_event_Setter(PyObject *self, PyObject *arg, void *) {
  AsyncFuture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncFuture, (void **)&local_this, "AsyncFuture.done_event")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete done_event attribute");
    return -1;
  }
  // 1-inline void AsyncFuture::set_done_event(std::string const &done_event)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_done_event)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_done_event(const AsyncFuture self, str done_event)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline AsyncFuture::AsyncFuture(void)
 * inline AsyncFuture::AsyncFuture(AsyncFuture const &) = default
 */
static int Dtool_Init_AsyncFuture(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("AsyncFuture() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline AsyncFuture::AsyncFuture(void)
      AsyncFuture *return_value = new AsyncFuture();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncFuture, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline AsyncFuture::AsyncFuture(AsyncFuture const &) = default
      AsyncFuture const *arg_this = (AsyncFuture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncFuture, 0, "AsyncFuture.AsyncFuture", true, true);
      if (arg_this != nullptr) {
        AsyncFuture *return_value = new AsyncFuture(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncFuture, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AsyncFuture() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AsyncFuture()\n"
      "AsyncFuture(const AsyncFuture param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AsyncFuture(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AsyncFuture) {
    printf("AsyncFuture ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AsyncFuture *local_this = (AsyncFuture *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AsyncFuture) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AsyncFuture(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AsyncFuture) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AsyncFuture*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AsyncFuture*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AsyncFuture*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AsyncTask
 */
/**
 * Python function wrapper for:
 * inline AsyncTask::State AsyncTask::get_state(void) const
 */
static PyObject *Dtool_AsyncTask_get_state_48(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-inline AsyncTask::State AsyncTask::get_state(void) const
  AsyncTask::State return_value = ((*(const AsyncTask*)local_this).get_state)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_state_48_comment =
  "C++ Interface:\n"
  "get_state(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the current state of the task.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_state_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AsyncTask::is_alive(void) const
 */
static PyObject *Dtool_AsyncTask_is_alive_49(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-inline bool AsyncTask::is_alive(void) const
  bool return_value = ((*(const AsyncTask*)local_this).is_alive)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_is_alive_49_comment =
  "C++ Interface:\n"
  "is_alive(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns true if the task is currently active or sleeping on some task\n"
  " * chain, meaning that it will be executed in its turn, or false if it is not\n"
  " * active.  If the task has recently been removed while it is in the middle of\n"
  " * execution, this will return false, because the task will not run again once\n"
  " * it finishes.\n"
  " */";
#else
static const char *Dtool_AsyncTask_is_alive_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AsyncTaskManager *AsyncTask::get_manager(void) const
 */
static PyObject *Dtool_AsyncTask_get_manager_50(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-inline AsyncTaskManager *AsyncTask::get_manager(void) const
  AsyncTaskManager *return_value = ((*(const AsyncTask*)local_this).get_manager)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTaskManager, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_manager_50_comment =
  "C++ Interface:\n"
  "get_manager(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the AsyncTaskManager that this task is active on.  This will be\n"
  " * NULL if the state is S_inactive.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_manager_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTask::remove(void)
 */
static PyObject *Dtool_AsyncTask_remove_51(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.remove")) {
    return nullptr;
  }
  // 1-bool AsyncTask::remove(void)
  bool return_value = ((*local_this).remove)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_remove_51_comment =
  "C++ Interface:\n"
  "remove(const AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Removes the task from its active manager, if any, and makes the state\n"
  " * S_inactive (or possible S_servicing_removed).  This is a no-op if the state\n"
  " * is already S_inactive.\n"
  " */";
#else
static const char *Dtool_AsyncTask_remove_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AsyncTask::set_delay(double delay)
 */
static PyObject *Dtool_AsyncTask_set_delay_52(PyObject *self, PyObject *arg) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.set_delay")) {
    return nullptr;
  }
  // 1-inline void AsyncTask::set_delay(double delay)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_delay)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_delay(const AsyncTask self, double delay)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_set_delay_52_comment =
  "C++ Interface:\n"
  "set_delay(const AsyncTask self, double delay)\n"
  "\n"
  "/**\n"
  " * Specifies the amount of time, in seconds, by which this task will be\n"
  " * delayed after it has been added to the AsyncTaskManager.  At least the\n"
  " * specified amount of time (and possibly more) will elapse before the task\n"
  " * begins.\n"
  " *\n"
  " * You may specify a delay of 0.0 to guarantee that the task will run in the\n"
  " * next epoch following the one in which it is added.\n"
  " *\n"
  " * Setting this value after the task has already been added will not affect\n"
  " * the task's wake time; it will only affect the task if it is re-added to the\n"
  " * queue in the future, for instance if the task returns DS_again.  However,\n"
  " * see recalc_wake_time() if you wish to apply the delay effect immediately.\n"
  " */";
#else
static const char *Dtool_AsyncTask_set_delay_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AsyncTask::clear_delay(void)
 */
static PyObject *Dtool_AsyncTask_clear_delay_53(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.clear_delay")) {
    return nullptr;
  }
  // 1-inline void AsyncTask::clear_delay(void)
  ((*local_this).clear_delay)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_clear_delay_53_comment =
  "C++ Interface:\n"
  "clear_delay(const AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Removes any delay specified for the task.  The next time the task is added\n"
  " * to the queue, it will run immediately.  This does not affect the task's\n"
  " * wake time if it has already been added to the queue.\n"
  " */";
#else
static const char *Dtool_AsyncTask_clear_delay_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AsyncTask::has_delay(void) const
 */
static PyObject *Dtool_AsyncTask_has_delay_54(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-inline bool AsyncTask::has_delay(void) const
  bool return_value = ((*(const AsyncTask*)local_this).has_delay)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_has_delay_54_comment =
  "C++ Interface:\n"
  "has_delay(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns true if a delay has been set for this task via set_delay(), or\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_AsyncTask_has_delay_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double AsyncTask::get_delay(void) const
 */
static PyObject *Dtool_AsyncTask_get_delay_55(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-inline double AsyncTask::get_delay(void) const
  double return_value = ((*(const AsyncTask*)local_this).get_delay)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_delay_55_comment =
  "C++ Interface:\n"
  "get_delay(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the delay value that has been set via set_delay, if any.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_delay_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double AsyncTask::get_wake_time(void) const
 */
static PyObject *Dtool_AsyncTask_get_wake_time_56(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-double AsyncTask::get_wake_time(void) const
  double return_value = ((*(const AsyncTask*)local_this).get_wake_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_wake_time_56_comment =
  "C++ Interface:\n"
  "get_wake_time(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * If this task has been added to an AsyncTaskManager with a delay in effect,\n"
  " * this returns the time at which the task is expected to awaken.  It has no\n"
  " * meaning if the task has not yet been added to a queue, or if there was no\n"
  " * delay in effect at the time the task was added.\n"
  " *\n"
  " * If the task's status is not S_sleeping, this returns 0.0.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_wake_time_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTask::recalc_wake_time(void)
 */
static PyObject *Dtool_AsyncTask_recalc_wake_time_57(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.recalc_wake_time")) {
    return nullptr;
  }
  // 1-void AsyncTask::recalc_wake_time(void)
  ((*local_this).recalc_wake_time)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_recalc_wake_time_57_comment =
  "C++ Interface:\n"
  "recalc_wake_time(const AsyncTask self)\n"
  "\n"
  "/**\n"
  " * If the task is currently sleeping on a task chain, this resets its wake\n"
  " * time to the current time + get_delay().  It is as if the task had suddenly\n"
  " * returned DS_again.  The task will sleep for its current delay seconds\n"
  " * before running again.  This method may therefore be used to make the task\n"
  " * wake up sooner or later than it would have otherwise.\n"
  " *\n"
  " * If the task is not already sleeping, this method has no effect.\n"
  " */";
#else
static const char *Dtool_AsyncTask_recalc_wake_time_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double AsyncTask::get_start_time(void) const
 */
static PyObject *Dtool_AsyncTask_get_start_time_58(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-inline double AsyncTask::get_start_time(void) const
  double return_value = ((*(const AsyncTask*)local_this).get_start_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_start_time_58_comment =
  "C++ Interface:\n"
  "get_start_time(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the time at which the task was started, according to the task\n"
  " * manager's clock.\n"
  " *\n"
  " * It is only valid to call this if the task's status is not S_inactive.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_start_time_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double AsyncTask::get_elapsed_time(void) const
 */
static PyObject *Dtool_AsyncTask_get_elapsed_time_59(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-double AsyncTask::get_elapsed_time(void) const
  double return_value = ((*(const AsyncTask*)local_this).get_elapsed_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_elapsed_time_59_comment =
  "C++ Interface:\n"
  "get_elapsed_time(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the amount of time that has elapsed since the task was started,\n"
  " * according to the task manager's clock.\n"
  " *\n"
  " * It is only valid to call this if the task's status is not S_inactive.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_elapsed_time_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int AsyncTask::get_start_frame(void) const
 */
static PyObject *Dtool_AsyncTask_get_start_frame_60(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-inline int AsyncTask::get_start_frame(void) const
  int return_value = ((*(const AsyncTask*)local_this).get_start_frame)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_start_frame_60_comment =
  "C++ Interface:\n"
  "get_start_frame(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the frame number at which the task was started, according to the\n"
  " * task manager's clock.\n"
  " *\n"
  " * It is only valid to call this if the task's status is not S_inactive.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_start_frame_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int AsyncTask::get_elapsed_frames(void) const
 */
static PyObject *Dtool_AsyncTask_get_elapsed_frames_61(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-int AsyncTask::get_elapsed_frames(void) const
  int return_value = ((*(const AsyncTask*)local_this).get_elapsed_frames)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_elapsed_frames_61_comment =
  "C++ Interface:\n"
  "get_elapsed_frames(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the number of frames that have elapsed since the task was started,\n"
  " * according to the task manager's clock.\n"
  " *\n"
  " * It is only valid to call this if the task's status is not S_inactive.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_elapsed_frames_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTask::set_name(std::string const &name)
 */
static PyObject *Dtool_AsyncTask_set_name_62(PyObject *self, PyObject *arg) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.set_name")) {
    return nullptr;
  }
  // 1-void AsyncTask::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const AsyncTask self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_set_name_62_comment =
  "C++ Interface:\n"
  "set_name(const AsyncTask self, str name)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AsyncTask_set_name_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AsyncTask::clear_name(void)
 */
static PyObject *Dtool_AsyncTask_clear_name_63(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.clear_name")) {
    return nullptr;
  }
  // 1-inline void AsyncTask::clear_name(void)
  ((*local_this).clear_name)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_clear_name_63_comment =
  "C++ Interface:\n"
  "clear_name(const AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Resets the task's name to empty.\n"
  " */";
#else
static const char *Dtool_AsyncTask_clear_name_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string AsyncTask::get_name_prefix(void) const
 */
static PyObject *Dtool_AsyncTask_get_name_prefix_64(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-std::string AsyncTask::get_name_prefix(void) const
  std::string return_value = ((*(const AsyncTask*)local_this).get_name_prefix)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_name_prefix_64_comment =
  "C++ Interface:\n"
  "get_name_prefix(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the initial part of the name, up to but not including any trailing\n"
  " * digits following a hyphen or underscore.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_name_prefix_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AtomicAdjust::Integer AsyncTask::get_task_id(void) const
 */
static PyObject *Dtool_AsyncTask_get_task_id_65(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-inline AtomicAdjust::Integer AsyncTask::get_task_id(void) const
  AtomicAdjust::Integer return_value = ((*(const AsyncTask*)local_this).get_task_id)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_task_id_65_comment =
  "C++ Interface:\n"
  "get_task_id(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns a number guaranteed to be unique for each different AsyncTask\n"
  " * object in the universe.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_task_id_65_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTask::set_task_chain(std::string const &chain_name)
 */
static PyObject *Dtool_AsyncTask_set_task_chain_66(PyObject *self, PyObject *arg) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.set_task_chain")) {
    return nullptr;
  }
  // 1-void AsyncTask::set_task_chain(std::string const &chain_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_task_chain)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_task_chain(const AsyncTask self, str chain_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_set_task_chain_66_comment =
  "C++ Interface:\n"
  "set_task_chain(const AsyncTask self, str chain_name)\n"
  "\n"
  "/**\n"
  " * Specifies the AsyncTaskChain on which this task will be running.  Each task\n"
  " * chain runs tasks independently of the others.\n"
  " */";
#else
static const char *Dtool_AsyncTask_set_task_chain_66_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &AsyncTask::get_task_chain(void) const
 */
static PyObject *Dtool_AsyncTask_get_task_chain_67(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-inline std::string const &AsyncTask::get_task_chain(void) const
  std::string const &return_value = ((*(const AsyncTask*)local_this).get_task_chain)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_task_chain_67_comment =
  "C++ Interface:\n"
  "get_task_chain(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the AsyncTaskChain on which this task will be running.  Each task\n"
  " * chain runs tasks independently of the others.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_task_chain_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTask::set_sort(int sort)
 */
static PyObject *Dtool_AsyncTask_set_sort_68(PyObject *self, PyObject *arg) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.set_sort")) {
    return nullptr;
  }
  // 1-void AsyncTask::set_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_sort)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sort(const AsyncTask self, int sort)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_set_sort_68_comment =
  "C++ Interface:\n"
  "set_sort(const AsyncTask self, int sort)\n"
  "\n"
  "/**\n"
  " * Specifies a sort value for this task.  Within a given AsyncTaskManager, all\n"
  " * of the tasks with a given sort value are guaranteed to be completed before\n"
  " * any tasks with a higher sort value are begun.\n"
  " *\n"
  " * To put it another way, two tasks might execute in parallel with each other\n"
  " * only if they both have the same sort value.  Tasks with a lower sort value\n"
  " * are executed first.\n"
  " *\n"
  " * This is different from the priority, which makes no such exclusion\n"
  " * guarantees.\n"
  " */";
#else
static const char *Dtool_AsyncTask_set_sort_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int AsyncTask::get_sort(void) const
 */
static PyObject *Dtool_AsyncTask_get_sort_69(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-inline int AsyncTask::get_sort(void) const
  int return_value = ((*(const AsyncTask*)local_this).get_sort)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_sort_69_comment =
  "C++ Interface:\n"
  "get_sort(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the task's current sort value.  See set_sort().\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_sort_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTask::set_priority(int priority)
 */
static PyObject *Dtool_AsyncTask_set_priority_70(PyObject *self, PyObject *arg) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.set_priority")) {
    return nullptr;
  }
  // 1-void AsyncTask::set_priority(int priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_priority)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_priority(const AsyncTask self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_set_priority_70_comment =
  "C++ Interface:\n"
  "set_priority(const AsyncTask self, int priority)\n"
  "\n"
  "/**\n"
  " * Specifies a priority value for this task.  In general, tasks with a higher\n"
  " * priority value are executed before tasks with a lower priority value (but\n"
  " * only for tasks with the same sort value).\n"
  " *\n"
  " * Unlike the sort value, tasks with different priorities may execute at the\n"
  " * same time, if the AsyncTaskManager has more than one thread servicing\n"
  " * tasks.\n"
  " *\n"
  " * Also see AsyncTaskChain::set_timeslice_priority(), which changes the\n"
  " * meaning of this value.  In the default mode, when the timeslice_priority\n"
  " * flag is false, all tasks always run once per epoch, regardless of their\n"
  " * priority values (that is, the priority controls the order of the task\n"
  " * execution only, not the number of times it runs).  On the other hand, if\n"
  " * you set the timeslice_priority flag to true, then changing a task's\n"
  " * priority has an effect on the number of times it runs.\n"
  " */";
#else
static const char *Dtool_AsyncTask_set_priority_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int AsyncTask::get_priority(void) const
 */
static PyObject *Dtool_AsyncTask_get_priority_71(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-inline int AsyncTask::get_priority(void) const
  int return_value = ((*(const AsyncTask*)local_this).get_priority)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_priority_71_comment =
  "C++ Interface:\n"
  "get_priority(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the task's current priority value.  See set_priority().\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_priority_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AsyncTask::set_done_event(std::string const &done_event)
 */
static PyObject *Dtool_AsyncTask_set_done_event_72(PyObject *self, PyObject *arg) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.set_done_event")) {
    return nullptr;
  }
  // 1-inline void AsyncTask::set_done_event(std::string const &done_event)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_done_event)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_done_event(const AsyncTask self, str done_event)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_set_done_event_72_comment =
  "C++ Interface:\n"
  "set_done_event(const AsyncTask self, str done_event)\n"
  "\n"
  "/**\n"
  " * Sets the event name that will be triggered when the task finishes.  This\n"
  " * should only be called before the task has been started, or after it has\n"
  " * finished and before it is about to be restarted (i.e.  when get_state()\n"
  " * returns S_inactive).\n"
  " */";
#else
static const char *Dtool_AsyncTask_set_done_event_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double AsyncTask::get_dt(void) const
 */
static PyObject *Dtool_AsyncTask_get_dt_73(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-inline double AsyncTask::get_dt(void) const
  double return_value = ((*(const AsyncTask*)local_this).get_dt)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_dt_73_comment =
  "C++ Interface:\n"
  "get_dt(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the amount of time elapsed during the task's previous run cycle, in\n"
  " * seconds.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_dt_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double AsyncTask::get_max_dt(void) const
 */
static PyObject *Dtool_AsyncTask_get_max_dt_74(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-inline double AsyncTask::get_max_dt(void) const
  double return_value = ((*(const AsyncTask*)local_this).get_max_dt)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_max_dt_74_comment =
  "C++ Interface:\n"
  "get_max_dt(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum amount of time elapsed during any one of the task's\n"
  " * previous run cycles, in seconds.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_max_dt_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double AsyncTask::get_average_dt(void) const
 */
static PyObject *Dtool_AsyncTask_get_average_dt_75(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-inline double AsyncTask::get_average_dt(void) const
  double return_value = ((*(const AsyncTask*)local_this).get_average_dt)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_average_dt_75_comment =
  "C++ Interface:\n"
  "get_average_dt(AsyncTask self)\n"
  "\n"
  "/**\n"
  " * Returns the average amount of time elapsed during each of the task's\n"
  " * previous run cycles, in seconds.\n"
  " */";
#else
static const char *Dtool_AsyncTask_get_average_dt_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AsyncTask::output(std::ostream &out) const
 */
static PyObject *Dtool_AsyncTask_output_76(PyObject *self, PyObject *arg) {
  AsyncTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTask)) {
    return nullptr;
  }
  // 1-virtual void AsyncTask::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AsyncTask.output", false, true);
  if (arg_this != nullptr) {
    ((*(const AsyncTask*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AsyncTask self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_output_76_comment =
  "C++ Interface:\n"
  "output(AsyncTask self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AsyncTask_output_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AsyncTask::get_class_type(void)
 */
static PyObject *Dtool_AsyncTask_get_class_type_161(PyObject *, PyObject *) {
  // 1-static TypeHandle AsyncTask::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AsyncTask::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_get_class_type_161_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AsyncTask_get_class_type_161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncFuture *AsyncTask::upcast_to_AsyncFuture(void)
 */
static PyObject *Dtool_AsyncTask_upcast_to_AsyncFuture_40(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.upcast_to_AsyncFuture")) {
    return nullptr;
  }
  // 1-AsyncFuture *AsyncTask::upcast_to_AsyncFuture(void)
  AsyncFuture *return_value = (AsyncFuture *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncFuture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_upcast_to_AsyncFuture_40_comment =
  "C++ Interface:\n"
  "upcast_to_AsyncFuture(const AsyncTask self)\n"
  "\n"
  "upcast from AsyncTask to AsyncFuture";
#else
static const char *Dtool_AsyncTask_upcast_to_AsyncFuture_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *AsyncTask::upcast_to_Namable(void)
 */
static PyObject *Dtool_AsyncTask_upcast_to_Namable_43(PyObject *self, PyObject *) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *AsyncTask::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTask_upcast_to_Namable_43_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const AsyncTask self)\n"
  "\n"
  "upcast from AsyncTask to Namable";
#else
static const char *Dtool_AsyncTask_upcast_to_Namable_43_comment = nullptr;
#endif

static PyObject *Dtool_AsyncTask_state_Getter(PyObject *self, void *) {
  const AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline AsyncTask::State AsyncTask::get_state(void) const
  AsyncTask::State return_value = ((*(const AsyncTask*)local_this).get_state)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AsyncTask_alive_Getter(PyObject *self, void *) {
  const AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool AsyncTask::is_alive(void) const
  bool return_value = ((*(const AsyncTask*)local_this).is_alive)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AsyncTask_manager_Getter(PyObject *self, void *) {
  const AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline AsyncTaskManager *AsyncTask::get_manager(void) const
  AsyncTaskManager *return_value = ((*(const AsyncTask*)local_this).get_manager)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTaskManager, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_AsyncTask_name_Getter(PyObject *self, void *) {
  const AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &AsyncTask::get_name(void) const
  std::string const &return_value = ((*(const AsyncTask*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_AsyncTask_name_Setter(PyObject *self, PyObject *arg, void *) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.name")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete name attribute");
    return -1;
  }
  // 1-void AsyncTask::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_name(const AsyncTask self, str name)\n");
  }
  return -1;
}

static PyObject *Dtool_AsyncTask_id_Getter(PyObject *self, void *) {
  const AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline AtomicAdjust::Integer AsyncTask::get_task_id(void) const
  AtomicAdjust::Integer return_value = ((*(const AsyncTask*)local_this).get_task_id)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AsyncTask_task_chain_Getter(PyObject *self, void *) {
  const AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &AsyncTask::get_task_chain(void) const
  std::string const &return_value = ((*(const AsyncTask*)local_this).get_task_chain)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_AsyncTask_task_chain_Setter(PyObject *self, PyObject *arg, void *) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.task_chain")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete task_chain attribute");
    return -1;
  }
  // 1-void AsyncTask::set_task_chain(std::string const &chain_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_task_chain)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_task_chain(const AsyncTask self, str chain_name)\n");
  }
  return -1;
}

static PyObject *Dtool_AsyncTask_sort_Getter(PyObject *self, void *) {
  const AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int AsyncTask::get_sort(void) const
  int return_value = ((*(const AsyncTask*)local_this).get_sort)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_AsyncTask_sort_Setter(PyObject *self, PyObject *arg, void *) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.sort")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete sort attribute");
    return -1;
  }
  // 1-void AsyncTask::set_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_sort)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_sort(const AsyncTask self, int sort)\n");
  }
  return -1;
}

static PyObject *Dtool_AsyncTask_priority_Getter(PyObject *self, void *) {
  const AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int AsyncTask::get_priority(void) const
  int return_value = ((*(const AsyncTask*)local_this).get_priority)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_AsyncTask_priority_Setter(PyObject *self, PyObject *arg, void *) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.priority")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete priority attribute");
    return -1;
  }
  // 1-void AsyncTask::set_priority(int priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_priority)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_priority(const AsyncTask self, int priority)\n");
  }
  return -1;
}

static PyObject *Dtool_AsyncTask_done_event_Getter(PyObject *self, void *) {
  const AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &AsyncTask::get_done_event(void) const
  std::string const &return_value = ((*(const AsyncTask*)local_this).get_done_event)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_AsyncTask_done_event_Setter(PyObject *self, PyObject *arg, void *) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTask, (void **)&local_this, "AsyncTask.done_event")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete done_event attribute");
    return -1;
  }
  // 1-inline void AsyncTask::set_done_event(std::string const &done_event)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_done_event)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_done_event(const AsyncTask self, str done_event)\n");
  }
  return -1;
}

static PyObject *Dtool_AsyncTask_dt_Getter(PyObject *self, void *) {
  const AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double AsyncTask::get_dt(void) const
  double return_value = ((*(const AsyncTask*)local_this).get_dt)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AsyncTask_max_dt_Getter(PyObject *self, void *) {
  const AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double AsyncTask::get_max_dt(void) const
  double return_value = ((*(const AsyncTask*)local_this).get_max_dt)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AsyncTask_average_dt_Getter(PyObject *self, void *) {
  const AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double AsyncTask::get_average_dt(void) const
  double return_value = ((*(const AsyncTask*)local_this).get_average_dt)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline AsyncTask::AsyncTask(AsyncTask const &) = default
 */
static int Dtool_Init_AsyncTask(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("AsyncTask() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline AsyncTask::AsyncTask(AsyncTask const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    AsyncTask const *param0_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AsyncTask, 0, "AsyncTask.AsyncTask", true, true);
    if (param0_this != nullptr) {
      AsyncTask *return_value = new AsyncTask(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTask, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AsyncTask(const AsyncTask param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AsyncTask(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AsyncTask) {
    printf("AsyncTask ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AsyncTask *local_this = (AsyncTask *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AsyncTask) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncFuture) {
    return (AsyncFuture *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(AsyncFuture *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(AsyncFuture *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(AsyncFuture *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AsyncTask(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AsyncTask) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AsyncFuture) {
    AsyncFuture* other_this = (AsyncFuture*)from_this;
    return (AsyncTask*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AsyncTask*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AsyncTask*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AsyncTask*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AsyncTask*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AsyncTaskManager
 */
/**
 * Python function wrapper for:
 * void AsyncTaskManager::cleanup(void)
 */
static PyObject *Dtool_AsyncTaskManager_cleanup_89(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.cleanup")) {
    return nullptr;
  }
  // 1-void AsyncTaskManager::cleanup(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).cleanup)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_cleanup_89_comment =
  "C++ Interface:\n"
  "cleanup(const AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Stops all threads and messily empties the task list.  This is intended to\n"
  " * be called on destruction only.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_cleanup_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AsyncTaskManager::set_clock(ClockObject *clock)
 */
static PyObject *Dtool_AsyncTaskManager_set_clock_90(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.set_clock")) {
    return nullptr;
  }
  // 1-inline void AsyncTaskManager::set_clock(ClockObject *clock)
  PT(ClockObject) arg_this;
  if (!Dtool_Coerce_ClockObject(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "AsyncTaskManager.set_clock", "ClockObject");
  }
  ((*local_this).set_clock)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clock(const AsyncTaskManager self, ClockObject clock)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_set_clock_90_comment =
  "C++ Interface:\n"
  "set_clock(const AsyncTaskManager self, ClockObject clock)\n"
  "\n"
  "/**\n"
  " * Replaces the clock pointer used within the AsyncTaskManager.  This is used\n"
  " * to control when tasks with a set_delay() specified will be scheduled.  It\n"
  " * can also be ticked automatically each epoch, if set_tick_clock() is true.\n"
  " *\n"
  " * The default is the global clock pointer.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_set_clock_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ClockObject *AsyncTaskManager::get_clock(void)
 */
static PyObject *Dtool_AsyncTaskManager_get_clock_91(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.get_clock")) {
    return nullptr;
  }
  // 1-inline ClockObject *AsyncTaskManager::get_clock(void)
  ClockObject *return_value = ((*local_this).get_clock)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ClockObject, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_clock_91_comment =
  "C++ Interface:\n"
  "get_clock(const AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Returns the clock pointer used within the AsyncTaskManager.  See\n"
  " * set_clock().\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_clock_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int AsyncTaskManager::get_num_task_chains(void) const
 */
static PyObject *Dtool_AsyncTaskManager_get_num_task_chains_95(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskManager)) {
    return nullptr;
  }
  // 1-int AsyncTaskManager::get_num_task_chains(void) const
  int return_value = ((*(const AsyncTaskManager*)local_this).get_num_task_chains)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_num_task_chains_95_comment =
  "C++ Interface:\n"
  "get_num_task_chains(AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Returns the number of different task chains.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_num_task_chains_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskChain *AsyncTaskManager::get_task_chain(int n) const
 */
static PyObject *Dtool_AsyncTaskManager_get_task_chain_96(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskManager)) {
    return nullptr;
  }
  // 1-AsyncTaskChain *AsyncTaskManager::get_task_chain(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    AsyncTaskChain *return_value = ((*(const AsyncTaskManager*)local_this).get_task_chain)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTaskChain, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_task_chain(AsyncTaskManager self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_task_chain_96_comment =
  "C++ Interface:\n"
  "get_task_chain(AsyncTaskManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth task chain.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_task_chain_96_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskChain *AsyncTaskManager::make_task_chain(std::string const &name)
 */
static PyObject *Dtool_AsyncTaskManager_make_task_chain_98(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.make_task_chain")) {
    return nullptr;
  }
  // 1-AsyncTaskChain *AsyncTaskManager::make_task_chain(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    AsyncTaskChain *return_value = ((*local_this).make_task_chain)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTaskChain, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_task_chain(const AsyncTaskManager self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_make_task_chain_98_comment =
  "C++ Interface:\n"
  "make_task_chain(const AsyncTaskManager self, str name)\n"
  "\n"
  "/**\n"
  " * Creates a new AsyncTaskChain of the indicated name and stores it within the\n"
  " * AsyncTaskManager.  If a task chain with this name already exists, returns\n"
  " * it instead.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_make_task_chain_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskChain *AsyncTaskManager::find_task_chain(std::string const &name)
 */
static PyObject *Dtool_AsyncTaskManager_find_task_chain_99(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.find_task_chain")) {
    return nullptr;
  }
  // 1-AsyncTaskChain *AsyncTaskManager::find_task_chain(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    AsyncTaskChain *return_value = ((*local_this).find_task_chain)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTaskChain, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_task_chain(const AsyncTaskManager self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_find_task_chain_99_comment =
  "C++ Interface:\n"
  "find_task_chain(const AsyncTaskManager self, str name)\n"
  "\n"
  "/**\n"
  " * Searches a new AsyncTaskChain of the indicated name and returns it if it\n"
  " * exists, or NULL otherwise.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_find_task_chain_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskManager::remove_task_chain(std::string const &name)
 */
static PyObject *Dtool_AsyncTaskManager_remove_task_chain_100(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.remove_task_chain")) {
    return nullptr;
  }
  // 1-bool AsyncTaskManager::remove_task_chain(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = ((*local_this).remove_task_chain)(std::string(param1_str, param1_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_task_chain(const AsyncTaskManager self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_remove_task_chain_100_comment =
  "C++ Interface:\n"
  "remove_task_chain(const AsyncTaskManager self, str name)\n"
  "\n"
  "/**\n"
  " * Removes the AsyncTaskChain of the indicated name.  If the chain still has\n"
  " * tasks, this will block until all tasks are finished.\n"
  " *\n"
  " * Returns true if successful, or false if the chain did not exist.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_remove_task_chain_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskManager::add(AsyncTask *task)
 */
static PyObject *Dtool_AsyncTaskManager_add_101(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.add")) {
    return nullptr;
  }
  // 1-void AsyncTaskManager::add(AsyncTask *task)
  AsyncTask *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 1, "AsyncTaskManager.add", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add(const AsyncTaskManager self, AsyncTask task)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_add_101_comment =
  "C++ Interface:\n"
  "add(const AsyncTaskManager self, AsyncTask task)\n"
  "\n"
  "/**\n"
  " * Adds the indicated task to the active queue.  It is an error if the task is\n"
  " * already added to this or any other active queue.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_add_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskManager::has_task(AsyncTask *task) const
 */
static PyObject *Dtool_AsyncTaskManager_has_task_102(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskManager)) {
    return nullptr;
  }
  // 1-bool AsyncTaskManager::has_task(AsyncTask *task) const
  AsyncTask *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 1, "AsyncTaskManager.has_task", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const AsyncTaskManager*)local_this).has_task)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_task(AsyncTaskManager self, AsyncTask task)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_has_task_102_comment =
  "C++ Interface:\n"
  "has_task(AsyncTaskManager self, AsyncTask task)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated task has been added to this AsyncTaskManager,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_has_task_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncTask *AsyncTaskManager::find_task(std::string const &name) const
 */
static PyObject *Dtool_AsyncTaskManager_find_task_103(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskManager)) {
    return nullptr;
  }
  // 1-AsyncTask *AsyncTaskManager::find_task(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    AsyncTask *return_value = ((*(const AsyncTaskManager*)local_this).find_task)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTask, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_task(AsyncTaskManager self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_find_task_103_comment =
  "C++ Interface:\n"
  "find_task(AsyncTaskManager self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the first task found with the indicated name, or NULL if there is\n"
  " * no task with the indicated name.\n"
  " *\n"
  " * If there are multiple tasks with the same name, returns one of them\n"
  " * arbitrarily.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_find_task_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection AsyncTaskManager::find_tasks(std::string const &name) const
 */
static PyObject *Dtool_AsyncTaskManager_find_tasks_104(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskManager)) {
    return nullptr;
  }
  // 1-AsyncTaskCollection AsyncTaskManager::find_tasks(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    AsyncTaskCollection *return_value = new AsyncTaskCollection(((*(const AsyncTaskManager*)local_this).find_tasks)(std::string(param1_str, param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_tasks(AsyncTaskManager self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_find_tasks_104_comment =
  "C++ Interface:\n"
  "find_tasks(AsyncTaskManager self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the list of tasks found with the indicated name.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_find_tasks_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection AsyncTaskManager::find_tasks_matching(GlobPattern const &pattern) const
 */
static PyObject *Dtool_AsyncTaskManager_find_tasks_matching_105(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskManager)) {
    return nullptr;
  }
  // 1-AsyncTaskCollection AsyncTaskManager::find_tasks_matching(GlobPattern const &pattern) const
  GlobPattern arg_local;
  GlobPattern const *arg_this = Dtool_Coerce_GlobPattern(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "AsyncTaskManager.find_tasks_matching", "GlobPattern");
  }
  AsyncTaskCollection *return_value = new AsyncTaskCollection(((*(const AsyncTaskManager*)local_this).find_tasks_matching)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_tasks_matching(AsyncTaskManager self, const GlobPattern pattern)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_find_tasks_matching_105_comment =
  "C++ Interface:\n"
  "find_tasks_matching(AsyncTaskManager self, const GlobPattern pattern)\n"
  "\n"
  "/**\n"
  " * Returns the list of tasks found whose name matches the indicated glob\n"
  " * pattern, e.g.  \"my_task_*\".\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_find_tasks_matching_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskManager::remove(AsyncTask *task)
 * std::size_t AsyncTaskManager::remove(AsyncTaskCollection const &tasks)
 */
static PyObject *Dtool_AsyncTaskManager_remove_106(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.remove")) {
    return nullptr;
  }
  {
    // -2 bool AsyncTaskManager::remove(AsyncTask *task)
    AsyncTask *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 1, "AsyncTaskManager.remove", false, false);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).remove)(arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 std::size_t AsyncTaskManager::remove(AsyncTaskCollection const &tasks)
    AsyncTaskCollection const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_AsyncTaskCollection);
    if (arg_this != nullptr) {
      std::size_t return_value = ((*local_this).remove)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: bool AsyncTaskManager::remove(AsyncTask *task)
  // No coercion possible: std::size_t AsyncTaskManager::remove(AsyncTaskCollection const &tasks)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove(const AsyncTaskManager self, AsyncTask task)\n"
      "remove(const AsyncTaskManager self, const AsyncTaskCollection tasks)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_remove_106_comment =
  "C++ Interface:\n"
  "remove(const AsyncTaskManager self, AsyncTask task)\n"
  "remove(const AsyncTaskManager self, const AsyncTaskCollection tasks)\n"
  "\n"
  "/**\n"
  " * Removes the indicated task from the active queue.  Returns true if the task\n"
  " * is successfully removed, or false if it wasn't there.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes all of the tasks in the AsyncTaskCollection.  Returns the number of\n"
  " * tasks removed.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_remove_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskManager::wait_for_tasks(void)
 */
static PyObject *Dtool_AsyncTaskManager_wait_for_tasks_107(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.wait_for_tasks")) {
    return nullptr;
  }
  // 1-void AsyncTaskManager::wait_for_tasks(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).wait_for_tasks)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_wait_for_tasks_107_comment =
  "C++ Interface:\n"
  "wait_for_tasks(const AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Blocks until the task list is empty.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_wait_for_tasks_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskManager::stop_threads(void)
 */
static PyObject *Dtool_AsyncTaskManager_stop_threads_108(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.stop_threads")) {
    return nullptr;
  }
  // 1-void AsyncTaskManager::stop_threads(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).stop_threads)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_stop_threads_108_comment =
  "C++ Interface:\n"
  "stop_threads(const AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Stops any threads that are currently running.  If any tasks are still\n"
  " * pending and have not yet been picked up by a thread, they will not be\n"
  " * serviced unless poll() or start_threads() is later called.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_stop_threads_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskManager::start_threads(void)
 */
static PyObject *Dtool_AsyncTaskManager_start_threads_109(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.start_threads")) {
    return nullptr;
  }
  // 1-void AsyncTaskManager::start_threads(void)
  ((*local_this).start_threads)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_start_threads_109_comment =
  "C++ Interface:\n"
  "start_threads(const AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Starts any requested threads to service the tasks on the queue.  This is\n"
  " * normally not necessary, since adding a task will start the threads\n"
  " * automatically.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_start_threads_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t AsyncTaskManager::get_num_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskManager_get_num_tasks_110(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskManager)) {
    return nullptr;
  }
  // 1-inline std::size_t AsyncTaskManager::get_num_tasks(void) const
  std::size_t return_value = ((*(const AsyncTaskManager*)local_this).get_num_tasks)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_num_tasks_110_comment =
  "C++ Interface:\n"
  "get_num_tasks(AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Returns the number of tasks that are currently active or sleeping within\n"
  " * the task manager.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_num_tasks_110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection AsyncTaskManager::get_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskManager_get_tasks_111(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskManager)) {
    return nullptr;
  }
  // 1-AsyncTaskCollection AsyncTaskManager::get_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection(((*(const AsyncTaskManager*)local_this).get_tasks)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_tasks_111_comment =
  "C++ Interface:\n"
  "get_tasks(AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Returns the set of tasks that are active or sleeping on the task manager,\n"
  " * at the time of the call.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_tasks_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection AsyncTaskManager::get_active_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskManager_get_active_tasks_112(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskManager)) {
    return nullptr;
  }
  // 1-AsyncTaskCollection AsyncTaskManager::get_active_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection(((*(const AsyncTaskManager*)local_this).get_active_tasks)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_active_tasks_112_comment =
  "C++ Interface:\n"
  "get_active_tasks(AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Returns the set of tasks that are active (and not sleeping) on the task\n"
  " * manager, at the time of the call.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_active_tasks_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection AsyncTaskManager::get_sleeping_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskManager_get_sleeping_tasks_113(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskManager)) {
    return nullptr;
  }
  // 1-AsyncTaskCollection AsyncTaskManager::get_sleeping_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection(((*(const AsyncTaskManager*)local_this).get_sleeping_tasks)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_sleeping_tasks_113_comment =
  "C++ Interface:\n"
  "get_sleeping_tasks(AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Returns the set of tasks that are sleeping (and not active) on the task\n"
  " * manager, at the time of the call.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_sleeping_tasks_113_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskManager::poll(void)
 */
static PyObject *Dtool_AsyncTaskManager_poll_138(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.poll")) {
    return nullptr;
  }
  // 1-void AsyncTaskManager::poll(void)
  ((*local_this).poll)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_poll_138_comment =
  "C++ Interface:\n"
  "poll(const AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Runs through all the tasks in the task list, once, if the task manager is\n"
  " * running in single-threaded mode (no threads available).  This method does\n"
  " * nothing in threaded mode, so it may safely be called in either case.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_poll_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double AsyncTaskManager::get_next_wake_time(void) const
 */
static PyObject *Dtool_AsyncTaskManager_get_next_wake_time_139(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskManager)) {
    return nullptr;
  }
  // 1-double AsyncTaskManager::get_next_wake_time(void) const
  double return_value = ((*(const AsyncTaskManager*)local_this).get_next_wake_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_next_wake_time_139_comment =
  "C++ Interface:\n"
  "get_next_wake_time(AsyncTaskManager self)\n"
  "\n"
  "/**\n"
  " * Returns the scheduled time (on the manager's clock) of the next sleeping\n"
  " * task, on any task chain, to awaken.  Returns -1 if there are no sleeping\n"
  " * tasks.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_next_wake_time_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AsyncTaskManager::output(std::ostream &out) const
 */
static PyObject *Dtool_AsyncTaskManager_output_142(PyObject *self, PyObject *arg) {
  AsyncTaskManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskManager)) {
    return nullptr;
  }
  // 1-virtual void AsyncTaskManager::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AsyncTaskManager.output", false, true);
  if (arg_this != nullptr) {
    ((*(const AsyncTaskManager*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AsyncTaskManager self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_output_142_comment =
  "C++ Interface:\n"
  "output(AsyncTaskManager self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_output_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AsyncTaskManager::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_AsyncTaskManager_write_143(PyObject *self, PyObject *args, PyObject *kwds) {
  AsyncTaskManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskManager)) {
    return nullptr;
  }
  // 1-virtual void AsyncTaskManager::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "AsyncTaskManager.write", false, true);
    if (param1_this != nullptr) {
      ((*(const AsyncTaskManager*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AsyncTaskManager self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_write_143_comment =
  "C++ Interface:\n"
  "write(AsyncTaskManager self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_write_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline AsyncTaskManager *AsyncTaskManager::get_global_ptr(void)
 */
static PyObject *Dtool_AsyncTaskManager_get_global_ptr_144(PyObject *, PyObject *) {
  // 1-static inline AsyncTaskManager *AsyncTaskManager::get_global_ptr(void)
  AsyncTaskManager *return_value = (AsyncTaskManager::get_global_ptr)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTaskManager, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_global_ptr_144_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the global AsyncTaskManager.  This is the\n"
  " * AsyncTaskManager that most code should use for queueing tasks and suchlike.\n"
  " */";
#else
static const char *Dtool_AsyncTaskManager_get_global_ptr_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AsyncTaskManager::get_class_type(void)
 */
static PyObject *Dtool_AsyncTaskManager_get_class_type_145(PyObject *, PyObject *) {
  // 1-static TypeHandle AsyncTaskManager::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AsyncTaskManager::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_get_class_type_145_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AsyncTaskManager_get_class_type_145_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedReferenceCount *AsyncTaskManager::upcast_to_TypedReferenceCount(void)
 */
static PyObject *Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_83(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.upcast_to_TypedReferenceCount")) {
    return nullptr;
  }
  // 1-TypedReferenceCount *AsyncTaskManager::upcast_to_TypedReferenceCount(void)
  TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_83_comment =
  "C++ Interface:\n"
  "upcast_to_TypedReferenceCount(const AsyncTaskManager self)\n"
  "\n"
  "upcast from AsyncTaskManager to TypedReferenceCount";
#else
static const char *Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *AsyncTaskManager::upcast_to_Namable(void)
 */
static PyObject *Dtool_AsyncTaskManager_upcast_to_Namable_85(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *AsyncTaskManager::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskManager_upcast_to_Namable_85_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const AsyncTaskManager self)\n"
  "\n"
  "upcast from AsyncTaskManager to Namable";
#else
static const char *Dtool_AsyncTaskManager_upcast_to_Namable_85_comment = nullptr;
#endif

static PyObject *Dtool_AsyncTaskManager_clock_Getter(PyObject *self, void *) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.clock")) {
    return nullptr;
  }

  // 1-inline ClockObject *AsyncTaskManager::get_clock(void)
  ClockObject *return_value = ((*local_this).get_clock)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ClockObject, true, false);
}

static int Dtool_AsyncTaskManager_clock_Setter(PyObject *self, PyObject *arg, void *) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskManager, (void **)&local_this, "AsyncTaskManager.clock")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete clock attribute");
    return -1;
  }
  // 1-inline void AsyncTaskManager::set_clock(ClockObject *clock)
  PT(ClockObject) arg_this;
  if (!Dtool_Coerce_ClockObject(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "AsyncTaskManager.set_clock", "ClockObject");
    return -1;
  }
  ((*local_this).set_clock)(std::move(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_clock(const AsyncTaskManager self, ClockObject clock)\n");
  }
  return -1;
}

static PyObject *Dtool_AsyncTaskManager_tasks_Getter(PyObject *self, void *) {
  const AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return nullptr;
  }

  // 1-AsyncTaskCollection AsyncTaskManager::get_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection(((*(const AsyncTaskManager*)local_this).get_tasks)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

static PyObject *Dtool_AsyncTaskManager_active_tasks_Getter(PyObject *self, void *) {
  const AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return nullptr;
  }

  // 1-AsyncTaskCollection AsyncTaskManager::get_active_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection(((*(const AsyncTaskManager*)local_this).get_active_tasks)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

static PyObject *Dtool_AsyncTaskManager_sleeping_tasks_Getter(PyObject *self, void *) {
  const AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return nullptr;
  }

  // 1-AsyncTaskCollection AsyncTaskManager::get_sleeping_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection(((*(const AsyncTaskManager*)local_this).get_sleeping_tasks)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

static PyObject *Dtool_AsyncTaskManager_next_wake_time_Getter(PyObject *self, void *) {
  const AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return nullptr;
  }

  // 1-double AsyncTaskManager::get_next_wake_time(void) const
  double return_value = ((*(const AsyncTaskManager*)local_this).get_next_wake_time)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * explicit AsyncTaskManager::AsyncTaskManager(std::string const &name)
 */
static int Dtool_Init_AsyncTaskManager(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "AsyncTaskManager() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit AsyncTaskManager::AsyncTaskManager(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      AsyncTaskManager *return_value = new AsyncTaskManager(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskManager, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AsyncTaskManager(str name)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_AsyncTaskManager_get_task_chains(PyObject *self, PyObject *) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_task_chains)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_AsyncTaskManager_get_task_chain_96(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_AsyncTaskManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AsyncTaskManager) {
    printf("AsyncTaskManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AsyncTaskManager *local_this = (AsyncTaskManager *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AsyncTaskManager) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AsyncTaskManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AsyncTaskManager) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AsyncTaskManager*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AsyncTaskManager*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AsyncTaskManager*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AsyncTaskManager*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AsyncTaskCollection
 */
/**
 * Python function wrapper for:
 * void AsyncTaskCollection::operator =(AsyncTaskCollection const &copy)
 */
static PyObject *Dtool_AsyncTaskCollection_operator_117(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskCollection, (void **)&local_this, "AsyncTaskCollection.assign")) {
    return nullptr;
  }
  // 1-void AsyncTaskCollection::operator =(AsyncTaskCollection const &copy)
  AsyncTaskCollection const *arg_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTaskCollection, 1, "AsyncTaskCollection.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    AsyncTaskCollection *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const AsyncTaskCollection self, const AsyncTaskCollection copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_operator_117_comment =
  "C++ Interface:\n"
  "assign(const AsyncTaskCollection self, const AsyncTaskCollection copy)\n";
#else
static const char *Dtool_AsyncTaskCollection_operator_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskCollection::add_task(AsyncTask *task)
 */
static PyObject *Dtool_AsyncTaskCollection_add_task_119(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskCollection, (void **)&local_this, "AsyncTaskCollection.add_task")) {
    return nullptr;
  }
  // 1-void AsyncTaskCollection::add_task(AsyncTask *task)
  AsyncTask *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 1, "AsyncTaskCollection.add_task", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_task)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_task(const AsyncTaskCollection self, AsyncTask task)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_add_task_119_comment =
  "C++ Interface:\n"
  "add_task(const AsyncTaskCollection self, AsyncTask task)\n"
  "\n"
  "/**\n"
  " * Adds a new AsyncTask to the collection.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_add_task_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskCollection::remove_task(AsyncTask *task)
 * void AsyncTaskCollection::remove_task(std::size_t index)
 */
static PyObject *Dtool_AsyncTaskCollection_remove_task_120(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskCollection, (void **)&local_this, "AsyncTaskCollection.remove_task")) {
    return nullptr;
  }
  {
    // -2 bool AsyncTaskCollection::remove_task(AsyncTask *task)
    AsyncTask *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 1, "AsyncTaskCollection.remove_task", false, false);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).remove_task)(arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 void AsyncTaskCollection::remove_task(std::size_t index)
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return nullptr;
      }
#endif
      ((*local_this).remove_task)(arg_val);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: bool AsyncTaskCollection::remove_task(AsyncTask *task)
  // No coercion possible: void AsyncTaskCollection::remove_task(std::size_t index)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_task(const AsyncTaskCollection self, AsyncTask task)\n"
      "remove_task(const AsyncTaskCollection self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_remove_task_120_comment =
  "C++ Interface:\n"
  "remove_task(const AsyncTaskCollection self, AsyncTask task)\n"
  "remove_task(const AsyncTaskCollection self, int index)\n"
  "\n"
  "/**\n"
  " * Removes the indicated AsyncTask from the collection.  Returns true if the\n"
  " * task was removed, false if it was not a member of the collection.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the nth AsyncTask from the collection.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_remove_task_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskCollection::add_tasks_from(AsyncTaskCollection const &other)
 */
static PyObject *Dtool_AsyncTaskCollection_add_tasks_from_121(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskCollection, (void **)&local_this, "AsyncTaskCollection.add_tasks_from")) {
    return nullptr;
  }
  // 1-void AsyncTaskCollection::add_tasks_from(AsyncTaskCollection const &other)
  AsyncTaskCollection const *arg_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTaskCollection, 1, "AsyncTaskCollection.add_tasks_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_tasks_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_tasks_from(const AsyncTaskCollection self, const AsyncTaskCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_add_tasks_from_121_comment =
  "C++ Interface:\n"
  "add_tasks_from(const AsyncTaskCollection self, const AsyncTaskCollection other)\n"
  "\n"
  "/**\n"
  " * Adds all the AsyncTasks indicated in the other collection to this task.\n"
  " * The other tasks are simply appended to the end of the tasks in this list;\n"
  " * duplicates are not automatically removed.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_add_tasks_from_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskCollection::remove_tasks_from(AsyncTaskCollection const &other)
 */
static PyObject *Dtool_AsyncTaskCollection_remove_tasks_from_122(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskCollection, (void **)&local_this, "AsyncTaskCollection.remove_tasks_from")) {
    return nullptr;
  }
  // 1-void AsyncTaskCollection::remove_tasks_from(AsyncTaskCollection const &other)
  AsyncTaskCollection const *arg_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTaskCollection, 1, "AsyncTaskCollection.remove_tasks_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_tasks_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_tasks_from(const AsyncTaskCollection self, const AsyncTaskCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_remove_tasks_from_122_comment =
  "C++ Interface:\n"
  "remove_tasks_from(const AsyncTaskCollection self, const AsyncTaskCollection other)\n"
  "\n"
  "/**\n"
  " * Removes from this collection all of the AsyncTasks listed in the other\n"
  " * collection.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_remove_tasks_from_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskCollection::remove_duplicate_tasks(void)
 */
static PyObject *Dtool_AsyncTaskCollection_remove_duplicate_tasks_123(PyObject *self, PyObject *) {
  AsyncTaskCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskCollection, (void **)&local_this, "AsyncTaskCollection.remove_duplicate_tasks")) {
    return nullptr;
  }
  // 1-void AsyncTaskCollection::remove_duplicate_tasks(void)
  ((*local_this).remove_duplicate_tasks)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_remove_duplicate_tasks_123_comment =
  "C++ Interface:\n"
  "remove_duplicate_tasks(const AsyncTaskCollection self)\n"
  "\n"
  "/**\n"
  " * Removes any duplicate entries of the same AsyncTasks on this collection.\n"
  " * If a AsyncTask appears multiple times, the first appearance is retained;\n"
  " * subsequent appearances are removed.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_remove_duplicate_tasks_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskCollection::has_task(AsyncTask *task) const
 */
static PyObject *Dtool_AsyncTaskCollection_has_task_124(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskCollection)) {
    return nullptr;
  }
  // 1-bool AsyncTaskCollection::has_task(AsyncTask *task) const
  AsyncTask *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 1, "AsyncTaskCollection.has_task", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const AsyncTaskCollection*)local_this).has_task)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_task(AsyncTaskCollection self, AsyncTask task)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_has_task_124_comment =
  "C++ Interface:\n"
  "has_task(AsyncTaskCollection self, AsyncTask task)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated AsyncTask appears in this collection, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_has_task_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskCollection::clear(void)
 */
static PyObject *Dtool_AsyncTaskCollection_clear_125(PyObject *self, PyObject *) {
  AsyncTaskCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskCollection, (void **)&local_this, "AsyncTaskCollection.clear")) {
    return nullptr;
  }
  // 1-void AsyncTaskCollection::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_clear_125_comment =
  "C++ Interface:\n"
  "clear(const AsyncTaskCollection self)\n"
  "\n"
  "/**\n"
  " * Removes all AsyncTasks from the collection.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_clear_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncTask *AsyncTaskCollection::find_task(std::string const &name) const
 */
static PyObject *Dtool_AsyncTaskCollection_find_task_126(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskCollection)) {
    return nullptr;
  }
  // 1-AsyncTask *AsyncTaskCollection::find_task(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    AsyncTask *return_value = ((*(const AsyncTaskCollection*)local_this).find_task)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTask, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_task(AsyncTaskCollection self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_find_task_126_comment =
  "C++ Interface:\n"
  "find_task(AsyncTaskCollection self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the task in the collection with the indicated name, if any, or NULL\n"
  " * if no task has that name.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_find_task_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t AsyncTaskCollection::get_num_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskCollection_get_num_tasks_127(PyObject *self, PyObject *) {
  AsyncTaskCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskCollection)) {
    return nullptr;
  }
  // 1-std::size_t AsyncTaskCollection::get_num_tasks(void) const
  std::size_t return_value = ((*(const AsyncTaskCollection*)local_this).get_num_tasks)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_get_num_tasks_127_comment =
  "C++ Interface:\n"
  "get_num_tasks(AsyncTaskCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of AsyncTasks in the collection.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_get_num_tasks_127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncTask *AsyncTaskCollection::get_task(std::size_t index) const
 */
static PyObject *Dtool_AsyncTaskCollection_get_task_128(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskCollection)) {
    return nullptr;
  }
  // 1-AsyncTask *AsyncTaskCollection::get_task(std::size_t index) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    AsyncTask *return_value = ((*(const AsyncTaskCollection*)local_this).get_task)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTask, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_task(AsyncTaskCollection self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_get_task_128_comment =
  "C++ Interface:\n"
  "get_task(AsyncTaskCollection self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth AsyncTask in the collection.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_get_task_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskCollection::output(std::ostream &out) const
 */
static PyObject *Dtool_AsyncTaskCollection_output_134(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskCollection)) {
    return nullptr;
  }
  // 1-void AsyncTaskCollection::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AsyncTaskCollection.output", false, true);
  if (arg_this != nullptr) {
    ((*(const AsyncTaskCollection*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AsyncTaskCollection self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_output_134_comment =
  "C++ Interface:\n"
  "output(AsyncTaskCollection self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a brief one-line description of the AsyncTaskCollection to the\n"
  " * indicated output stream.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_output_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskCollection::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_AsyncTaskCollection_write_135(PyObject *self, PyObject *args, PyObject *kwds) {
  AsyncTaskCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskCollection)) {
    return nullptr;
  }
  // 1-void AsyncTaskCollection::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "AsyncTaskCollection.write", false, true);
    if (param1_this != nullptr) {
      ((*(const AsyncTaskCollection*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AsyncTaskCollection self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskCollection_write_135_comment =
  "C++ Interface:\n"
  "write(AsyncTaskCollection self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a complete multi-line description of the AsyncTaskCollection to the\n"
  " * indicated output stream.\n"
  " */";
#else
static const char *Dtool_AsyncTaskCollection_write_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection::AsyncTaskCollection(void)
 * AsyncTaskCollection::AsyncTaskCollection(AsyncTaskCollection const &copy)
 */
static int Dtool_Init_AsyncTaskCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-AsyncTaskCollection::AsyncTaskCollection(void)
      AsyncTaskCollection *return_value = new AsyncTaskCollection();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-AsyncTaskCollection::AsyncTaskCollection(AsyncTaskCollection const &copy)
        AsyncTaskCollection const *arg_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTaskCollection, 0, "AsyncTaskCollection.AsyncTaskCollection", true, true);
        if (arg_this != nullptr) {
          AsyncTaskCollection *return_value = new AsyncTaskCollection(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskCollection, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AsyncTaskCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AsyncTaskCollection()\n"
      "AsyncTaskCollection(const AsyncTaskCollection copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_AsyncTaskCollection_get_tasks(PyObject *self, PyObject *) {
  AsyncTaskCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskCollection, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_tasks)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_AsyncTaskCollection_get_task_128(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_AsyncTaskCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AsyncTaskCollection) {
    printf("AsyncTaskCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AsyncTaskCollection *local_this = (AsyncTaskCollection *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AsyncTaskCollection) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AsyncTaskCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AsyncTaskCollection) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AsyncTaskChain
 */
/**
 * Python function wrapper for:
 * void AsyncTaskChain::set_tick_clock(bool tick_clock)
 */
static PyObject *Dtool_AsyncTaskChain_set_tick_clock_169(PyObject *self, PyObject *arg) {
  AsyncTaskChain *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.set_tick_clock")) {
    return nullptr;
  }
  // 1-void AsyncTaskChain::set_tick_clock(bool tick_clock)
  ((*local_this).set_tick_clock)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tick_clock(const AsyncTaskChain self, bool tick_clock)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_set_tick_clock_169_comment =
  "C++ Interface:\n"
  "set_tick_clock(const AsyncTaskChain self, bool tick_clock)\n"
  "\n"
  "/**\n"
  " * Sets the tick_clock flag.  When this is true, get_clock()->tick() will be\n"
  " * called automatically at each task epoch.  This is false by default.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_set_tick_clock_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskChain::get_tick_clock(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_tick_clock_170(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskChain)) {
    return nullptr;
  }
  // 1-bool AsyncTaskChain::get_tick_clock(void) const
  bool return_value = ((*(const AsyncTaskChain*)local_this).get_tick_clock)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_tick_clock_170_comment =
  "C++ Interface:\n"
  "get_tick_clock(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the tick_clock flag.  See set_tick_clock().\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_tick_clock_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::set_num_threads(int num_threads)
 */
static PyObject *Dtool_AsyncTaskChain_set_num_threads_171(PyObject *self, PyObject *arg) {
  AsyncTaskChain *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.set_num_threads")) {
    return nullptr;
  }
  // 1-void AsyncTaskChain::set_num_threads(int num_threads)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).set_num_threads)((int)arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_threads(const AsyncTaskChain self, int num_threads)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_set_num_threads_171_comment =
  "C++ Interface:\n"
  "set_num_threads(const AsyncTaskChain self, int num_threads)\n"
  "\n"
  "/**\n"
  " * Changes the number of threads for this task chain.  This may require\n"
  " * stopping the threads if they are already running.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_set_num_threads_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int AsyncTaskChain::get_num_threads(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_num_threads_172(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskChain)) {
    return nullptr;
  }
  // 1-int AsyncTaskChain::get_num_threads(void) const
  int return_value = ((*(const AsyncTaskChain*)local_this).get_num_threads)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_num_threads_172_comment =
  "C++ Interface:\n"
  "get_num_threads(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the number of threads that will be servicing tasks for this chain.\n"
  " * Also see get_num_running_threads().\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_num_threads_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int AsyncTaskChain::get_num_running_threads(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_num_running_threads_173(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskChain)) {
    return nullptr;
  }
  // 1-int AsyncTaskChain::get_num_running_threads(void) const
  int return_value = ((*(const AsyncTaskChain*)local_this).get_num_running_threads)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_num_running_threads_173_comment =
  "C++ Interface:\n"
  "get_num_running_threads(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the number of threads that have been created and are actively\n"
  " * running.  This will return 0 before the threads have been started; it will\n"
  " * also return 0 if thread support is not available.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_num_running_threads_173_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::set_thread_priority(ThreadPriority priority)
 */
static PyObject *Dtool_AsyncTaskChain_set_thread_priority_174(PyObject *self, PyObject *arg) {
  AsyncTaskChain *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.set_thread_priority")) {
    return nullptr;
  }
  // 1-void AsyncTaskChain::set_thread_priority(ThreadPriority priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).set_thread_priority)((ThreadPriority)arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_thread_priority(const AsyncTaskChain self, int priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_set_thread_priority_174_comment =
  "C++ Interface:\n"
  "set_thread_priority(const AsyncTaskChain self, int priority)\n"
  "\n"
  "/**\n"
  " * Changes the priority associated with threads that serve this task chain.\n"
  " * This may require stopping the threads if they are already running.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_set_thread_priority_174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ThreadPriority AsyncTaskChain::get_thread_priority(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_thread_priority_175(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskChain)) {
    return nullptr;
  }
  // 1-ThreadPriority AsyncTaskChain::get_thread_priority(void) const
  ThreadPriority return_value = ((*(const AsyncTaskChain*)local_this).get_thread_priority)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_thread_priority_175_comment =
  "C++ Interface:\n"
  "get_thread_priority(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the priority associated with threads that serve this task chain.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_thread_priority_175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::set_frame_budget(double frame_budget)
 */
static PyObject *Dtool_AsyncTaskChain_set_frame_budget_176(PyObject *self, PyObject *arg) {
  AsyncTaskChain *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.set_frame_budget")) {
    return nullptr;
  }
  // 1-void AsyncTaskChain::set_frame_budget(double frame_budget)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_frame_budget)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_budget(const AsyncTaskChain self, double frame_budget)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_set_frame_budget_176_comment =
  "C++ Interface:\n"
  "set_frame_budget(const AsyncTaskChain self, double frame_budget)\n"
  "\n"
  "/**\n"
  " * Sets the maximum amount of time per frame the tasks on this chain are\n"
  " * granted for execution.  If this is less than zero, there is no limit; if it\n"
  " * is >= 0, it represents a maximum amount of time (in seconds) that will be\n"
  " * used to execute tasks.  If this time is exceeded in any one frame, the task\n"
  " * chain will stop executing tasks until the next frame, as defined by the\n"
  " * TaskManager's clock.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_set_frame_budget_176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double AsyncTaskChain::get_frame_budget(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_frame_budget_177(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskChain)) {
    return nullptr;
  }
  // 1-double AsyncTaskChain::get_frame_budget(void) const
  double return_value = ((*(const AsyncTaskChain*)local_this).get_frame_budget)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_frame_budget_177_comment =
  "C++ Interface:\n"
  "get_frame_budget(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum amount of time per frame the tasks on this chain are\n"
  " * granted for execution.  See set_frame_budget().\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_frame_budget_177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::set_frame_sync(bool frame_sync)
 */
static PyObject *Dtool_AsyncTaskChain_set_frame_sync_178(PyObject *self, PyObject *arg) {
  AsyncTaskChain *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.set_frame_sync")) {
    return nullptr;
  }
  // 1-void AsyncTaskChain::set_frame_sync(bool frame_sync)
  ((*local_this).set_frame_sync)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_sync(const AsyncTaskChain self, bool frame_sync)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_set_frame_sync_178_comment =
  "C++ Interface:\n"
  "set_frame_sync(const AsyncTaskChain self, bool frame_sync)\n"
  "\n"
  "/**\n"
  " * Sets the frame_sync flag.  When this flag is true, this task chain will be\n"
  " * forced to sync with the TaskManager's clock.  It will run no faster than\n"
  " * one epoch per clock frame.\n"
  " *\n"
  " * When this flag is false, the default, the task chain will finish all of its\n"
  " * tasks and then immediately start from the first task again, regardless of\n"
  " * the clock frame.  When it is true, the task chain will finish all of its\n"
  " * tasks and then wait for the clock to tick to the next frame before resuming\n"
  " * the first task.\n"
  " *\n"
  " * This only makes sense for threaded task chains.  Non-threaded task chains\n"
  " * are automatically synchronous.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_set_frame_sync_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskChain::get_frame_sync(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_frame_sync_179(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskChain)) {
    return nullptr;
  }
  // 1-bool AsyncTaskChain::get_frame_sync(void) const
  bool return_value = ((*(const AsyncTaskChain*)local_this).get_frame_sync)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_frame_sync_179_comment =
  "C++ Interface:\n"
  "get_frame_sync(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the frame_sync flag.  See set_frame_sync().\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_frame_sync_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::set_timeslice_priority(bool timeslice_priority)
 */
static PyObject *Dtool_AsyncTaskChain_set_timeslice_priority_180(PyObject *self, PyObject *arg) {
  AsyncTaskChain *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.set_timeslice_priority")) {
    return nullptr;
  }
  // 1-void AsyncTaskChain::set_timeslice_priority(bool timeslice_priority)
  ((*local_this).set_timeslice_priority)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_timeslice_priority(const AsyncTaskChain self, bool timeslice_priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_set_timeslice_priority_180_comment =
  "C++ Interface:\n"
  "set_timeslice_priority(const AsyncTaskChain self, bool timeslice_priority)\n"
  "\n"
  "/**\n"
  " * Sets the timeslice_priority flag.  This changes the interpretation of\n"
  " * priority, and the number of times per epoch each task will run.\n"
  " *\n"
  " * When this flag is true, some tasks might not run in any given epoch.\n"
  " * Instead, tasks with priority higher than 1 will be given precedence, in\n"
  " * proportion to the amount of time they have already used.  This gives\n"
  " * higher-priority tasks more runtime than lower-priority tasks.  Each task\n"
  " * gets the amount of time proportional to its priority value, so a task with\n"
  " * priority 100 will get five times as much processing time as a task with\n"
  " * priority 20.  For these purposes, priority values less than 1 are deemed to\n"
  " * be equal to 1.\n"
  " *\n"
  " * When this flag is false (the default), all tasks are run exactly once each\n"
  " * epoch, round-robin style.  Priority is only used to determine which task\n"
  " * runs first within tasks of the same sort value.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_set_timeslice_priority_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskChain::get_timeslice_priority(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_timeslice_priority_181(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskChain)) {
    return nullptr;
  }
  // 1-bool AsyncTaskChain::get_timeslice_priority(void) const
  bool return_value = ((*(const AsyncTaskChain*)local_this).get_timeslice_priority)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_timeslice_priority_181_comment =
  "C++ Interface:\n"
  "get_timeslice_priority(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the timeslice_priority flag.  This changes the interpretation of\n"
  " * priority, and the number of times per epoch each task will run.  See\n"
  " * set_timeslice_priority().\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_timeslice_priority_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::stop_threads(void)
 */
static PyObject *Dtool_AsyncTaskChain_stop_threads_182(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.stop_threads")) {
    return nullptr;
  }
  // 1-void AsyncTaskChain::stop_threads(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).stop_threads)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_stop_threads_182_comment =
  "C++ Interface:\n"
  "stop_threads(const AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Stops any threads that are currently running.  If any tasks are still\n"
  " * pending and have not yet been picked up by a thread, they will not be\n"
  " * serviced unless poll() or start_threads() is later called.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_stop_threads_182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::start_threads(void)
 */
static PyObject *Dtool_AsyncTaskChain_start_threads_183(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.start_threads")) {
    return nullptr;
  }
  // 1-void AsyncTaskChain::start_threads(void)
  ((*local_this).start_threads)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_start_threads_183_comment =
  "C++ Interface:\n"
  "start_threads(const AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Starts any requested threads to service the tasks on the queue.  This is\n"
  " * normally not necessary, since adding a task will start the threads\n"
  " * automatically.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_start_threads_183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AsyncTaskChain::is_started(void) const
 */
static PyObject *Dtool_AsyncTaskChain_is_started_184(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskChain)) {
    return nullptr;
  }
  // 1-inline bool AsyncTaskChain::is_started(void) const
  bool return_value = ((*(const AsyncTaskChain*)local_this).is_started)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_is_started_184_comment =
  "C++ Interface:\n"
  "is_started(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns true if the thread(s) have been started and are ready to service\n"
  " * requests, false otherwise.  If this is false, the next call to add() or\n"
  " * add_and_do() will automatically start the threads.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_is_started_184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool AsyncTaskChain::has_task(AsyncTask *task) const
 */
static PyObject *Dtool_AsyncTaskChain_has_task_185(PyObject *self, PyObject *arg) {
  AsyncTaskChain *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskChain)) {
    return nullptr;
  }
  // 1-bool AsyncTaskChain::has_task(AsyncTask *task) const
  AsyncTask *arg_this = (AsyncTask *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTask, 1, "AsyncTaskChain.has_task", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const AsyncTaskChain*)local_this).has_task)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_task(AsyncTaskChain self, AsyncTask task)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_has_task_185_comment =
  "C++ Interface:\n"
  "has_task(AsyncTaskChain self, AsyncTask task)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated task has been added to this AsyncTaskChain,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_has_task_185_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::wait_for_tasks(void)
 */
static PyObject *Dtool_AsyncTaskChain_wait_for_tasks_186(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.wait_for_tasks")) {
    return nullptr;
  }
  // 1-void AsyncTaskChain::wait_for_tasks(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).wait_for_tasks)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_wait_for_tasks_186_comment =
  "C++ Interface:\n"
  "wait_for_tasks(const AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Blocks until the task list is empty.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_wait_for_tasks_186_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int AsyncTaskChain::get_num_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_num_tasks_187(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskChain)) {
    return nullptr;
  }
  // 1-int AsyncTaskChain::get_num_tasks(void) const
  int return_value = ((*(const AsyncTaskChain*)local_this).get_num_tasks)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_num_tasks_187_comment =
  "C++ Interface:\n"
  "get_num_tasks(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the number of tasks that are currently active or sleeping within\n"
  " * the task chain.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_num_tasks_187_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection AsyncTaskChain::get_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_tasks_188(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskChain)) {
    return nullptr;
  }
  // 1-AsyncTaskCollection AsyncTaskChain::get_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection(((*(const AsyncTaskChain*)local_this).get_tasks)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_tasks_188_comment =
  "C++ Interface:\n"
  "get_tasks(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the set of tasks that are active or sleeping on the task chain, at\n"
  " * the time of the call.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_tasks_188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection AsyncTaskChain::get_active_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_active_tasks_189(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskChain)) {
    return nullptr;
  }
  // 1-AsyncTaskCollection AsyncTaskChain::get_active_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection(((*(const AsyncTaskChain*)local_this).get_active_tasks)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_active_tasks_189_comment =
  "C++ Interface:\n"
  "get_active_tasks(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the set of tasks that are active (and not sleeping) on the task\n"
  " * chain, at the time of the call.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_active_tasks_189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection AsyncTaskChain::get_sleeping_tasks(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_sleeping_tasks_190(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskChain)) {
    return nullptr;
  }
  // 1-AsyncTaskCollection AsyncTaskChain::get_sleeping_tasks(void) const
  AsyncTaskCollection *return_value = new AsyncTaskCollection(((*(const AsyncTaskChain*)local_this).get_sleeping_tasks)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_sleeping_tasks_190_comment =
  "C++ Interface:\n"
  "get_sleeping_tasks(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the set of tasks that are sleeping (and not active) on the task\n"
  " * chain, at the time of the call.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_sleeping_tasks_190_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AsyncTaskChain::poll(void)
 */
static PyObject *Dtool_AsyncTaskChain_poll_191(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.poll")) {
    return nullptr;
  }
  // 1-void AsyncTaskChain::poll(void)
  ((*local_this).poll)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_poll_191_comment =
  "C++ Interface:\n"
  "poll(const AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Runs through all the tasks in the task list, once, if the task chain is\n"
  " * running in single-threaded mode (no threads available).  This method does\n"
  " * nothing in threaded mode, so it may safely be called in either case.\n"
  " *\n"
  " * Normally, you would not call this function directly; instead, call\n"
  " * AsyncTaskManager::poll(), which polls all of the task chains in sequence.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_poll_191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double AsyncTaskChain::get_next_wake_time(void) const
 */
static PyObject *Dtool_AsyncTaskChain_get_next_wake_time_192(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskChain)) {
    return nullptr;
  }
  // 1-double AsyncTaskChain::get_next_wake_time(void) const
  double return_value = ((*(const AsyncTaskChain*)local_this).get_next_wake_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_next_wake_time_192_comment =
  "C++ Interface:\n"
  "get_next_wake_time(AsyncTaskChain self)\n"
  "\n"
  "/**\n"
  " * Returns the scheduled time (on the manager's clock) of the next sleeping\n"
  " * task, on any task chain, to awaken.  Returns -1 if there are no sleeping\n"
  " * tasks.\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_get_next_wake_time_192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AsyncTaskChain::output(std::ostream &out) const
 */
static PyObject *Dtool_AsyncTaskChain_output_193(PyObject *self, PyObject *arg) {
  AsyncTaskChain *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskChain)) {
    return nullptr;
  }
  // 1-virtual void AsyncTaskChain::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AsyncTaskChain.output", false, true);
  if (arg_this != nullptr) {
    ((*(const AsyncTaskChain*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AsyncTaskChain self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_output_193_comment =
  "C++ Interface:\n"
  "output(AsyncTaskChain self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_output_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AsyncTaskChain::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_AsyncTaskChain_write_194(PyObject *self, PyObject *args, PyObject *kwds) {
  AsyncTaskChain *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskChain)) {
    return nullptr;
  }
  // 1-virtual void AsyncTaskChain::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "AsyncTaskChain.write", false, true);
    if (param1_this != nullptr) {
      ((*(const AsyncTaskChain*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AsyncTaskChain self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_write_194_comment =
  "C++ Interface:\n"
  "write(AsyncTaskChain self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AsyncTaskChain_write_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AsyncTaskChain::get_class_type(void)
 */
static PyObject *Dtool_AsyncTaskChain_get_class_type_195(PyObject *, PyObject *) {
  // 1-static TypeHandle AsyncTaskChain::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AsyncTaskChain::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_get_class_type_195_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AsyncTaskChain_get_class_type_195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedReferenceCount *AsyncTaskChain::upcast_to_TypedReferenceCount(void)
 */
static PyObject *Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_164(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.upcast_to_TypedReferenceCount")) {
    return nullptr;
  }
  // 1-TypedReferenceCount *AsyncTaskChain::upcast_to_TypedReferenceCount(void)
  TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_164_comment =
  "C++ Interface:\n"
  "upcast_to_TypedReferenceCount(const AsyncTaskChain self)\n"
  "\n"
  "upcast from AsyncTaskChain to TypedReferenceCount";
#else
static const char *Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_164_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *AsyncTaskChain::upcast_to_Namable(void)
 */
static PyObject *Dtool_AsyncTaskChain_upcast_to_Namable_166(PyObject *self, PyObject *) {
  AsyncTaskChain *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskChain, (void **)&local_this, "AsyncTaskChain.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *AsyncTaskChain::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskChain_upcast_to_Namable_166_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const AsyncTaskChain self)\n"
  "\n"
  "upcast from AsyncTaskChain to Namable";
#else
static const char *Dtool_AsyncTaskChain_upcast_to_Namable_166_comment = nullptr;
#endif

static int Dtool_Init_AsyncTaskChain(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AsyncTaskChain(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AsyncTaskChain) {
    printf("AsyncTaskChain ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AsyncTaskChain *local_this = (AsyncTaskChain *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AsyncTaskChain) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AsyncTaskChain(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AsyncTaskChain) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AsyncTaskChain*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AsyncTaskChain*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AsyncTaskChain*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AsyncTaskChain*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AsyncTaskPause
 */
/**
 * Python function wrapper for:
 * static TypeHandle AsyncTaskPause::get_class_type(void)
 */
static PyObject *Dtool_AsyncTaskPause_get_class_type_201(PyObject *, PyObject *) {
  // 1-static TypeHandle AsyncTaskPause::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AsyncTaskPause::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskPause_get_class_type_201_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AsyncTaskPause_get_class_type_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AsyncTaskPause::AsyncTaskPause(AsyncTaskPause const &) = default
 * AsyncTaskPause::AsyncTaskPause(double delay)
 */
static int Dtool_Init_AsyncTaskPause(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "AsyncTaskPause() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline AsyncTaskPause::AsyncTaskPause(AsyncTaskPause const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      AsyncTaskPause const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_AsyncTaskPause);
      if (param0_this != nullptr) {
        AsyncTaskPause *return_value = new AsyncTaskPause(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskPause, true, false);
      }
    }
  }

  {
    // -2 AsyncTaskPause::AsyncTaskPause(double delay)
    double param0;
    static const char *keyword_list[] = {"delay", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "d:AsyncTaskPause", (char **)keyword_list, &param0)) {
      AsyncTaskPause *return_value = new AsyncTaskPause((double)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskPause, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline AsyncTaskPause::AsyncTaskPause(AsyncTaskPause const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(AsyncTaskPause) param0_this;
      if (Dtool_ConstCoerce_AsyncTaskPause(param0, param0_this)) {
        AsyncTaskPause *return_value = new AsyncTaskPause(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskPause, true, false);
      }
    }
  }

  // No coercion possible: AsyncTaskPause::AsyncTaskPause(double delay)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AsyncTaskPause(const AsyncTaskPause param0)\n"
      "AsyncTaskPause(double delay)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_AsyncTaskPause(PyObject *args, CPT(AsyncTaskPause) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_AsyncTaskPause)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-AsyncTaskPause::AsyncTaskPause(double delay)
    if (PyNumber_Check(arg)) {
      AsyncTaskPause *return_value = new AsyncTaskPause(PyFloat_AsDouble(arg));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_AsyncTaskPause(PyObject *args, PT(AsyncTaskPause) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_AsyncTaskPause)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-AsyncTaskPause::AsyncTaskPause(double delay)
    if (PyNumber_Check(arg)) {
      AsyncTaskPause *return_value = new AsyncTaskPause(PyFloat_AsDouble(arg));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_AsyncTaskPause(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AsyncTaskPause) {
    printf("AsyncTaskPause ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AsyncTaskPause *local_this = (AsyncTaskPause *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AsyncTaskPause) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncFuture) {
    return (AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTask) {
    return (AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AsyncTaskPause(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AsyncTaskPause) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AsyncFuture) {
    AsyncFuture* other_this = (AsyncFuture*)from_this;
    return (AsyncTaskPause*)other_this;
  }
  if (from_type == Dtool_Ptr_AsyncTask) {
    AsyncTask* other_this = (AsyncTask*)from_this;
    return (AsyncTaskPause*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AsyncTaskPause*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AsyncTaskPause*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AsyncTaskPause*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AsyncTaskPause*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AsyncTaskSequence
 */
/**
 * Python function wrapper for:
 * inline void AsyncTaskSequence::set_repeat_count(int repeat_count)
 */
static PyObject *Dtool_AsyncTaskSequence_set_repeat_count_213(PyObject *self, PyObject *arg) {
  AsyncTaskSequence *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskSequence, (void **)&local_this, "AsyncTaskSequence.set_repeat_count")) {
    return nullptr;
  }
  // 1-inline void AsyncTaskSequence::set_repeat_count(int repeat_count)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_repeat_count)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_repeat_count(const AsyncTaskSequence self, int repeat_count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskSequence_set_repeat_count_213_comment =
  "C++ Interface:\n"
  "set_repeat_count(const AsyncTaskSequence self, int repeat_count)\n"
  "\n"
  "/**\n"
  " * Sets the repeat count of the sequence.  If the count is 0 or 1, the\n"
  " * sequence will run exactly once.  If it is greater than 0, it will run that\n"
  " * number of times.  If it is negative, it will run forever until it is\n"
  " * explicitly removed.\n"
  " */";
#else
static const char *Dtool_AsyncTaskSequence_set_repeat_count_213_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int AsyncTaskSequence::get_repeat_count(void) const
 */
static PyObject *Dtool_AsyncTaskSequence_get_repeat_count_214(PyObject *self, PyObject *) {
  AsyncTaskSequence *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskSequence)) {
    return nullptr;
  }
  // 1-inline int AsyncTaskSequence::get_repeat_count(void) const
  int return_value = ((*(const AsyncTaskSequence*)local_this).get_repeat_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskSequence_get_repeat_count_214_comment =
  "C++ Interface:\n"
  "get_repeat_count(AsyncTaskSequence self)\n"
  "\n"
  "/**\n"
  " * Returns the repeat count of the sequence.  See set_repeat_count().\n"
  " */";
#else
static const char *Dtool_AsyncTaskSequence_get_repeat_count_214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t AsyncTaskSequence::get_current_task_index(void) const
 */
static PyObject *Dtool_AsyncTaskSequence_get_current_task_index_215(PyObject *self, PyObject *) {
  AsyncTaskSequence *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AsyncTaskSequence)) {
    return nullptr;
  }
  // 1-inline std::size_t AsyncTaskSequence::get_current_task_index(void) const
  std::size_t return_value = ((*(const AsyncTaskSequence*)local_this).get_current_task_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskSequence_get_current_task_index_215_comment =
  "C++ Interface:\n"
  "get_current_task_index(AsyncTaskSequence self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the task within the sequence that is currently being\n"
  " * executed (or that will be executed at the next epoch).\n"
  " */";
#else
static const char *Dtool_AsyncTaskSequence_get_current_task_index_215_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AsyncTaskSequence::get_class_type(void)
 */
static PyObject *Dtool_AsyncTaskSequence_get_class_type_216(PyObject *, PyObject *) {
  // 1-static TypeHandle AsyncTaskSequence::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AsyncTaskSequence::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskSequence_get_class_type_216_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AsyncTaskSequence_get_class_type_216_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncTask *AsyncTaskSequence::upcast_to_AsyncTask(void)
 */
static PyObject *Dtool_AsyncTaskSequence_upcast_to_AsyncTask_204(PyObject *self, PyObject *) {
  AsyncTaskSequence *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskSequence, (void **)&local_this, "AsyncTaskSequence.upcast_to_AsyncTask")) {
    return nullptr;
  }
  // 1-AsyncTask *AsyncTaskSequence::upcast_to_AsyncTask(void)
  AsyncTask *return_value = (AsyncTask *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTask, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskSequence_upcast_to_AsyncTask_204_comment =
  "C++ Interface:\n"
  "upcast_to_AsyncTask(const AsyncTaskSequence self)\n"
  "\n"
  "upcast from AsyncTaskSequence to AsyncTask";
#else
static const char *Dtool_AsyncTaskSequence_upcast_to_AsyncTask_204_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AsyncTaskCollection *AsyncTaskSequence::upcast_to_AsyncTaskCollection(void)
 */
static PyObject *Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_206(PyObject *self, PyObject *) {
  AsyncTaskSequence *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AsyncTaskSequence, (void **)&local_this, "AsyncTaskSequence.upcast_to_AsyncTaskCollection")) {
    return nullptr;
  }
  // 1-AsyncTaskCollection *AsyncTaskSequence::upcast_to_AsyncTaskCollection(void)
  AsyncTaskCollection *return_value = (AsyncTaskCollection *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_206_comment =
  "C++ Interface:\n"
  "upcast_to_AsyncTaskCollection(const AsyncTaskSequence self)\n"
  "\n"
  "upcast from AsyncTaskSequence to AsyncTaskCollection";
#else
static const char *Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AsyncTaskSequence::AsyncTaskSequence(AsyncTaskSequence const &) = default
 * explicit AsyncTaskSequence::AsyncTaskSequence(std::string const &name)
 */
static int Dtool_Init_AsyncTaskSequence(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "AsyncTaskSequence() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline AsyncTaskSequence::AsyncTaskSequence(AsyncTaskSequence const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      AsyncTaskSequence const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_AsyncTaskSequence);
      if (param0_this != nullptr) {
        AsyncTaskSequence *return_value = new AsyncTaskSequence(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskSequence, true, false);
      }
    }
  }

  {
    // -2 explicit AsyncTaskSequence::AsyncTaskSequence(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:AsyncTaskSequence", (char **)keyword_list, &param0_str, &param0_len)) {
      AsyncTaskSequence *return_value = new AsyncTaskSequence(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AsyncTaskSequence, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline AsyncTaskSequence::AsyncTaskSequence(AsyncTaskSequence const &) = default
  // No coercion possible: explicit AsyncTaskSequence::AsyncTaskSequence(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AsyncTaskSequence(const AsyncTaskSequence param0)\n"
      "AsyncTaskSequence(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AsyncTaskSequence(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AsyncTaskSequence) {
    printf("AsyncTaskSequence ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AsyncTaskSequence *local_this = (AsyncTaskSequence *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AsyncTaskSequence) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncFuture) {
    return (AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTask) {
    return (AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTaskCollection) {
    return (AsyncTaskCollection *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AsyncTaskSequence(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AsyncTaskSequence) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AsyncFuture) {
    AsyncFuture* other_this = (AsyncFuture*)from_this;
    return (AsyncTaskSequence*)other_this;
  }
  if (from_type == Dtool_Ptr_AsyncTask) {
    AsyncTask* other_this = (AsyncTask*)from_this;
    return (AsyncTaskSequence*)other_this;
  }
  if (from_type == Dtool_Ptr_AsyncTaskCollection) {
    AsyncTaskCollection* other_this = (AsyncTaskCollection*)from_this;
    return (AsyncTaskSequence*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AsyncTaskSequence*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AsyncTaskSequence*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AsyncTaskSequence*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AsyncTaskSequence*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ButtonEventList
 */
/**
 * Python function wrapper for:
 * inline void ButtonEventList::operator =(ButtonEventList const &copy)
 */
static PyObject *Dtool_ButtonEventList_operator_220(PyObject *self, PyObject *arg) {
  ButtonEventList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonEventList, (void **)&local_this, "ButtonEventList.assign")) {
    return nullptr;
  }
  // 1-inline void ButtonEventList::operator =(ButtonEventList const &copy)
  ButtonEventList const *arg_this = (ButtonEventList *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ButtonEventList, 1, "ButtonEventList.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    ButtonEventList *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ButtonEventList, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const ButtonEventList self, const ButtonEventList copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonEventList_operator_220_comment =
  "C++ Interface:\n"
  "assign(const ButtonEventList self, const ButtonEventList copy)\n";
#else
static const char *Dtool_ButtonEventList_operator_220_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ButtonEventList::get_num_events(void) const
 */
static PyObject *Dtool_ButtonEventList_get_num_events_222(PyObject *self, PyObject *) {
  ButtonEventList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonEventList)) {
    return nullptr;
  }
  // 1-inline int ButtonEventList::get_num_events(void) const
  int return_value = ((*(const ButtonEventList*)local_this).get_num_events)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonEventList_get_num_events_222_comment =
  "C++ Interface:\n"
  "get_num_events(ButtonEventList self)\n"
  "\n"
  "/**\n"
  " * Returns the number of events in the list.\n"
  " */";
#else
static const char *Dtool_ButtonEventList_get_num_events_222_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ButtonEventList::clear(void)
 */
static PyObject *Dtool_ButtonEventList_clear_224(PyObject *self, PyObject *) {
  ButtonEventList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonEventList, (void **)&local_this, "ButtonEventList.clear")) {
    return nullptr;
  }
  // 1-inline void ButtonEventList::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ButtonEventList_clear_224_comment =
  "C++ Interface:\n"
  "clear(const ButtonEventList self)\n"
  "\n"
  "/**\n"
  " * Empties all the events from the list.\n"
  " */";
#else
static const char *Dtool_ButtonEventList_clear_224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ButtonEventList::add_events(ButtonEventList const &other)
 */
static PyObject *Dtool_ButtonEventList_add_events_225(PyObject *self, PyObject *arg) {
  ButtonEventList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonEventList, (void **)&local_this, "ButtonEventList.add_events")) {
    return nullptr;
  }
  // 1-void ButtonEventList::add_events(ButtonEventList const &other)
  ButtonEventList const *arg_this = (ButtonEventList *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ButtonEventList, 1, "ButtonEventList.add_events", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_events)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_events(const ButtonEventList self, const ButtonEventList other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonEventList_add_events_225_comment =
  "C++ Interface:\n"
  "add_events(const ButtonEventList self, const ButtonEventList other)\n"
  "\n"
  "/**\n"
  " * Appends the events from the other list onto the end of this one.\n"
  " */";
#else
static const char *Dtool_ButtonEventList_add_events_225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ButtonEventList::update_mods(ModifierButtons &mods) const
 */
static PyObject *Dtool_ButtonEventList_update_mods_226(PyObject *self, PyObject *arg) {
  ButtonEventList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonEventList)) {
    return nullptr;
  }
  // 1-void ButtonEventList::update_mods(ModifierButtons &mods) const
  ModifierButtons *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "ButtonEventList.update_mods", false, true);
  if (arg_this != nullptr) {
    ((*(const ButtonEventList*)local_this).update_mods)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "update_mods(ButtonEventList self, ModifierButtons mods)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonEventList_update_mods_226_comment =
  "C++ Interface:\n"
  "update_mods(ButtonEventList self, ModifierButtons mods)\n"
  "\n"
  "/**\n"
  " * Updates the indicated ModifierButtons object with all of the button up/down\n"
  " * transitions indicated in the list.\n"
  " */";
#else
static const char *Dtool_ButtonEventList_update_mods_226_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ButtonEventList::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_ButtonEventList_write_227(PyObject *self, PyObject *args, PyObject *kwds) {
  ButtonEventList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonEventList)) {
    return nullptr;
  }
  // 1-void ButtonEventList::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "ButtonEventList.write", false, true);
    if (param1_this != nullptr) {
      ((*(const ButtonEventList*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ButtonEventList self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonEventList_write_227_comment =
  "C++ Interface:\n"
  "write(ButtonEventList self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ButtonEventList_write_227_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ButtonEventList::get_class_type(void)
 */
static PyObject *Dtool_ButtonEventList_get_class_type_228(PyObject *, PyObject *) {
  // 1-static TypeHandle ButtonEventList::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ButtonEventList::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ButtonEventList_get_class_type_228_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ButtonEventList_get_class_type_228_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ButtonEventList::ButtonEventList(void)
 * inline ButtonEventList::ButtonEventList(ButtonEventList const &copy)
 */
static int Dtool_Init_ButtonEventList(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline ButtonEventList::ButtonEventList(void)
      ButtonEventList *return_value = new ButtonEventList();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonEventList, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline ButtonEventList::ButtonEventList(ButtonEventList const &copy)
        ButtonEventList const *arg_this = (ButtonEventList *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ButtonEventList, 0, "ButtonEventList.ButtonEventList", true, true);
        if (arg_this != nullptr) {
          ButtonEventList *return_value = new ButtonEventList(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonEventList, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ButtonEventList() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ButtonEventList()\n"
      "ButtonEventList(const ButtonEventList copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ButtonEventList(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ButtonEventList) {
    printf("ButtonEventList ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ButtonEventList *local_this = (ButtonEventList *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ButtonEventList) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ButtonEventList(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ButtonEventList) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ButtonEventList*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ButtonEventList*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ButtonEventList*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ButtonEventList*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ButtonEventList*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Event
 */
/**
 * Python function wrapper for:
 * void Event::operator =(Event const &copy)
 */
static PyObject *Dtool_Event_operator_232(PyObject *self, PyObject *arg) {
  Event *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Event, (void **)&local_this, "Event.assign")) {
    return nullptr;
  }
  // 1-void Event::operator =(Event const &copy)
  CPT(Event) arg_this;
  if (!Dtool_ConstCoerce_Event(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Event.assign", "Event");
  }
  ((*local_this).operator =)(*std::move(arg_this));
  Event *return_value = local_this;
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Event, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const Event self, const Event copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Event_operator_232_comment =
  "C++ Interface:\n"
  "assign(const Event self, const Event copy)\n";
#else
static const char *Dtool_Event_operator_232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Event::set_name(std::string const &name)
 */
static PyObject *Dtool_Event_set_name_233(PyObject *self, PyObject *arg) {
  Event *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Event, (void **)&local_this, "Event.set_name")) {
    return nullptr;
  }
  // 1-inline void Event::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const Event self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Event_set_name_233_comment =
  "C++ Interface:\n"
  "set_name(const Event self, str name)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Event_set_name_233_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Event::clear_name(void)
 */
static PyObject *Dtool_Event_clear_name_234(PyObject *self, PyObject *) {
  Event *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Event, (void **)&local_this, "Event.clear_name")) {
    return nullptr;
  }
  // 1-inline void Event::clear_name(void)
  ((*local_this).clear_name)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Event_clear_name_234_comment =
  "C++ Interface:\n"
  "clear_name(const Event self)\n"
  "\n"
  "/**\n"
  " * Resets the Event's name to empty.\n"
  " */";
#else
static const char *Dtool_Event_clear_name_234_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Event::has_name(void) const
 */
static PyObject *Dtool_Event_has_name_235(PyObject *self, PyObject *) {
  Event *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Event)) {
    return nullptr;
  }
  // 1-inline bool Event::has_name(void) const
  bool return_value = ((*(const Event*)local_this).has_name)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Event_has_name_235_comment =
  "C++ Interface:\n"
  "has_name(Event self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Event has a nonempty name set, false if the name is\n"
  " * empty.\n"
  " */";
#else
static const char *Dtool_Event_has_name_235_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Event::get_name(void) const
 */
static PyObject *Dtool_Event_get_name_236(PyObject *self, PyObject *) {
  Event *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Event)) {
    return nullptr;
  }
  // 1-inline std::string const &Event::get_name(void) const
  std::string const &return_value = ((*(const Event*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Event_get_name_236_comment =
  "C++ Interface:\n"
  "get_name(Event self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Event_get_name_236_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Event::add_parameter(EventParameter const &obj)
 */
static PyObject *Dtool_Event_add_parameter_237(PyObject *self, PyObject *arg) {
  Event *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Event, (void **)&local_this, "Event.add_parameter")) {
    return nullptr;
  }
  // 1-void Event::add_parameter(EventParameter const &obj)
  EventParameter arg_local;
  EventParameter const *arg_this = Dtool_Coerce_EventParameter(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Event.add_parameter", "EventParameter");
  }
  ((*local_this).add_parameter)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_parameter(const Event self, const EventParameter obj)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Event_add_parameter_237_comment =
  "C++ Interface:\n"
  "add_parameter(const Event self, const EventParameter obj)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Event_add_parameter_237_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Event::get_num_parameters(void) const
 */
static PyObject *Dtool_Event_get_num_parameters_238(PyObject *self, PyObject *) {
  Event *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Event)) {
    return nullptr;
  }
  // 1-int Event::get_num_parameters(void) const
  int return_value = ((*(const Event*)local_this).get_num_parameters)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Event_get_num_parameters_238_comment =
  "C++ Interface:\n"
  "get_num_parameters(Event self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Event_get_num_parameters_238_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EventParameter Event::get_parameter(int n) const
 */
static PyObject *Dtool_Event_get_parameter_239(PyObject *self, PyObject *arg) {
  Event *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Event)) {
    return nullptr;
  }
  // 1-EventParameter Event::get_parameter(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    EventParameter *return_value = new EventParameter(((*(const Event*)local_this).get_parameter)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EventParameter, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parameter(Event self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Event_get_parameter_239_comment =
  "C++ Interface:\n"
  "get_parameter(Event self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Event_get_parameter_239_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Event::has_receiver(void) const
 */
static PyObject *Dtool_Event_has_receiver_241(PyObject *self, PyObject *) {
  Event *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Event)) {
    return nullptr;
  }
  // 1-bool Event::has_receiver(void) const
  bool return_value = ((*(const Event*)local_this).has_receiver)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Event_has_receiver_241_comment =
  "C++ Interface:\n"
  "has_receiver(Event self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Event_has_receiver_241_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Event::clear_receiver(void)
 */
static PyObject *Dtool_Event_clear_receiver_244(PyObject *self, PyObject *) {
  Event *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Event, (void **)&local_this, "Event.clear_receiver")) {
    return nullptr;
  }
  // 1-void Event::clear_receiver(void)
  ((*local_this).clear_receiver)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Event_clear_receiver_244_comment =
  "C++ Interface:\n"
  "clear_receiver(const Event self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Event_clear_receiver_244_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Event::output(std::ostream &out) const
 */
static PyObject *Dtool_Event_output_245(PyObject *self, PyObject *arg) {
  Event *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Event)) {
    return nullptr;
  }
  // 1-void Event::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Event.output", false, true);
  if (arg_this != nullptr) {
    ((*(const Event*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Event self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Event_output_245_comment =
  "C++ Interface:\n"
  "output(Event self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Event_output_245_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Event::get_class_type(void)
 */
static PyObject *Dtool_Event_get_class_type_251(PyObject *, PyObject *) {
  // 1-static TypeHandle Event::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Event::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Event_get_class_type_251_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Event_get_class_type_251_comment = nullptr;
#endif

static PyObject *Dtool_Event_name_Getter(PyObject *self, void *) {
  const Event *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Event, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &Event::get_name(void) const
  std::string const &return_value = ((*(const Event*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Event_name_Setter(PyObject *self, PyObject *arg, void *) {
  Event *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Event, (void **)&local_this, "Event.name")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete name attribute");
    return -1;
  }
  // 1-inline void Event::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_name(const Event self, str name)\n");
  }
  return -1;
}

/**
 * sequence length function for property Event::parameters
 */
static Py_ssize_t Dtool_Event_parameters_Len(PyObject *self) {
  Event *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Event, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_parameters)();
}

/**
 * sequence getter for property Event::parameters
 */
static PyObject *Dtool_Event_parameters_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  Event *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Event, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_parameters)()) {
    PyErr_SetString(PyExc_IndexError, "Event.parameters[] index out of range");
    return nullptr;
  }
  // 1-EventParameter Event::get_parameter(int n) const
  EventParameter *return_value = new EventParameter(((*(const Event*)local_this).get_parameter)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EventParameter, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_parameter(Event self, index)\n");
  }
}

static PyObject *Dtool_Event_parameters_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "Event.parameters");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_Event_parameters_Len;
    wrap->_getitem_func = &Dtool_Event_parameters_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * Event::Event(Event const &copy)
 * Event::Event(std::string const &event_name, EventReceiver *receiver = nullptr)
 */
static int Dtool_Init_Event(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 Event::Event(std::string const &event_name, EventReceiver *receiver = nullptr)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"event_name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:Event", (char **)keyword_list, &param0_str, &param0_len)) {
      Event *return_value = new Event(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Event, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: Event::Event(std::string const &event_name, EventReceiver *receiver = nullptr)
  {
    // -2 Event::Event(Event const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      CPT(Event) param0_this;
      if (Dtool_ConstCoerce_Event(param0, param0_this)) {
        Event *return_value = new Event(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Event, true, false);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Event(str event_name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_Event(PyObject *args, CPT(Event) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_Event)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Event::Event(std::string const &event_name, EventReceiver *receiver)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      Event *return_value = new Event(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-Event::Event(std::string const &event_name, EventReceiver *receiver)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      if (PyArg_ParseTuple(args, "s#:Event", &param0_str, &param0_len)) {
        Event *return_value = new Event(std::string(param0_str, param0_len));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_Event(PyObject *args, PT(Event) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_Event)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-Event::Event(std::string const &event_name, EventReceiver *receiver)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      Event *return_value = new Event(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-Event::Event(std::string const &event_name, EventReceiver *receiver)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      if (PyArg_ParseTuple(args, "s#:Event", &param0_str, &param0_len)) {
        Event *return_value = new Event(std::string(param0_str, param0_len));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_Event_get_parameters(PyObject *self, PyObject *) {
  Event *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Event, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_parameters)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_Event_get_parameter_239(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_Event(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Event) {
    printf("Event ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Event *local_this = (Event *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Event) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Event(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Event) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Event*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Event*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (Event*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EventHandler
 */
/**
 * Python function wrapper for:
 * AsyncFuture *EventHandler::get_future(std::string const &event_name)
 */
static PyObject *Dtool_EventHandler_get_future_255(PyObject *self, PyObject *arg) {
  EventHandler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EventHandler, (void **)&local_this, "EventHandler.get_future")) {
    return nullptr;
  }
  // 1-AsyncFuture *EventHandler::get_future(std::string const &event_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    AsyncFuture *return_value = ((*local_this).get_future)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncFuture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_future(const EventHandler self, str event_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EventHandler_get_future_255_comment =
  "C++ Interface:\n"
  "get_future(const EventHandler self, str event_name)\n"
  "\n"
  "/**\n"
  " * Returns a pending future that will be marked as done when the event is next\n"
  " * fired.\n"
  " */";
#else
static const char *Dtool_EventHandler_get_future_255_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EventHandler::process_events(void)
 */
static PyObject *Dtool_EventHandler_process_events_256(PyObject *self, PyObject *) {
  EventHandler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EventHandler, (void **)&local_this, "EventHandler.process_events")) {
    return nullptr;
  }
  // 1-void EventHandler::process_events(void)
  ((*local_this).process_events)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EventHandler_process_events_256_comment =
  "C++ Interface:\n"
  "process_events(const EventHandler self)\n"
  "\n"
  "/**\n"
  " * The main processing loop of the EventHandler.  This function must be called\n"
  " * periodically to service events.  Walks through each pending event and calls\n"
  " * its assigned hooks.\n"
  " */";
#else
static const char *Dtool_EventHandler_process_events_256_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void EventHandler::dispatch_event(Event const *event)
 */
static PyObject *Dtool_EventHandler_dispatch_event_257(PyObject *self, PyObject *arg) {
  EventHandler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EventHandler, (void **)&local_this, "EventHandler.dispatch_event")) {
    return nullptr;
  }
  // 1-virtual void EventHandler::dispatch_event(Event const *event)
  CPT(Event) arg_this;
  if (!Dtool_ConstCoerce_Event(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EventHandler.dispatch_event", "Event");
  }
  ((*local_this).dispatch_event)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dispatch_event(const EventHandler self, const Event event)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EventHandler_dispatch_event_257_comment =
  "C++ Interface:\n"
  "dispatch_event(const EventHandler self, const Event event)\n"
  "\n"
  "/**\n"
  " * Calls the hooks assigned to the indicated single event.\n"
  " */";
#else
static const char *Dtool_EventHandler_dispatch_event_257_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EventHandler::write(std::ostream &out) const
 */
static PyObject *Dtool_EventHandler_write_258(PyObject *self, PyObject *arg) {
  EventHandler *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EventHandler)) {
    return nullptr;
  }
  // 1-void EventHandler::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "EventHandler.write", false, true);
  if (arg_this != nullptr) {
    ((*(const EventHandler*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(EventHandler self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EventHandler_write_258_comment =
  "C++ Interface:\n"
  "write(EventHandler self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EventHandler_write_258_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline EventHandler *EventHandler::get_global_event_handler(EventQueue *queue = nullptr)
 */
static PyObject *Dtool_EventHandler_get_global_event_handler_259(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline EventHandler *EventHandler::get_global_event_handler(EventQueue *queue = nullptr)
  PyObject *param0 = nullptr;
  if (Dtool_ExtractOptionalArg(&param0, args, kwds, "queue")) {
    EventQueue *param0_this = nullptr;
    if (param0 != nullptr && param0 != Py_None) {
      param0_this = (EventQueue *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_EventQueue, 0, "EventHandler.get_global_event_handler", false, true);
    }
    if ((param0 == nullptr || param0 == Py_None || param0_this != nullptr)) {
      EventHandler *return_value = (EventHandler::get_global_event_handler)(param0_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_EventHandler, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_global_event_handler(EventQueue queue)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EventHandler_get_global_event_handler_259_comment =
  "C++ Interface:\n"
  "get_global_event_handler(EventQueue queue)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the one global EventHandler object.  If the global\n"
  " * object has not yet been created, this will create it.\n"
  " */";
#else
static const char *Dtool_EventHandler_get_global_event_handler_259_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle EventHandler::get_class_type(void)
 */
static PyObject *Dtool_EventHandler_get_class_type_260(PyObject *, PyObject *) {
  // 1-static TypeHandle EventHandler::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EventHandler::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EventHandler_get_class_type_260_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_EventHandler_get_class_type_260_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit EventHandler::EventHandler(EventQueue *ev_queue)
 */
static int Dtool_Init_EventHandler(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EventHandler() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "ev_queue")) {
    // 1-explicit EventHandler::EventHandler(EventQueue *ev_queue)
    EventQueue *arg_this = (EventQueue *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EventQueue, 0, "EventHandler.EventHandler", false, true);
    if (arg_this != nullptr) {
      EventHandler *return_value = new EventHandler(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventHandler, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EventHandler(EventQueue ev_queue)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EventHandler(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EventHandler) {
    printf("EventHandler ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EventHandler *local_this = (EventHandler *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EventHandler) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EventHandler(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EventHandler) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EventHandler*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EventQueue
 */
/**
 * Python function wrapper for:
 * void EventQueue::queue_event(CPT_Event event)
 */
static PyObject *Dtool_EventQueue_queue_event_264(PyObject *self, PyObject *arg) {
  EventQueue *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EventQueue, (void **)&local_this, "EventQueue.queue_event")) {
    return nullptr;
  }
  // 1-void EventQueue::queue_event(CPT_Event event)
  CPT(Event) arg_this;
  if (!Dtool_ConstCoerce_Event(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "EventQueue.queue_event", "Event");
  }
  ((*local_this).queue_event)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "queue_event(const EventQueue self, const Event event)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_EventQueue_queue_event_264_comment =
  "C++ Interface:\n"
  "queue_event(const EventQueue self, const Event event)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EventQueue_queue_event_264_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void EventQueue::clear(void)
 */
static PyObject *Dtool_EventQueue_clear_265(PyObject *self, PyObject *) {
  EventQueue *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EventQueue, (void **)&local_this, "EventQueue.clear")) {
    return nullptr;
  }
  // 1-void EventQueue::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_EventQueue_clear_265_comment =
  "C++ Interface:\n"
  "clear(const EventQueue self)\n"
  "\n"
  "/**\n"
  " * Empties all events on the queue, throwing them on the floor.\n"
  " */";
#else
static const char *Dtool_EventQueue_clear_265_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EventQueue::is_queue_empty(void) const
 */
static PyObject *Dtool_EventQueue_is_queue_empty_266(PyObject *self, PyObject *) {
  EventQueue *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EventQueue)) {
    return nullptr;
  }
  // 1-bool EventQueue::is_queue_empty(void) const
  bool return_value = ((*(const EventQueue*)local_this).is_queue_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventQueue_is_queue_empty_266_comment =
  "C++ Interface:\n"
  "is_queue_empty(EventQueue self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EventQueue_is_queue_empty_266_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool EventQueue::is_queue_full(void) const
 */
static PyObject *Dtool_EventQueue_is_queue_full_267(PyObject *self, PyObject *) {
  EventQueue *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_EventQueue)) {
    return nullptr;
  }
  // 1-bool EventQueue::is_queue_full(void) const
  bool return_value = ((*(const EventQueue*)local_this).is_queue_full)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_EventQueue_is_queue_full_267_comment =
  "C++ Interface:\n"
  "is_queue_full(EventQueue self)\n"
  "\n"
  "/**\n"
  " * @deprecated Always returns false; the queue can never be full.\n"
  " */";
#else
static const char *Dtool_EventQueue_is_queue_full_267_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CPT_Event EventQueue::dequeue_event(void)
 */
static PyObject *Dtool_EventQueue_dequeue_event_268(PyObject *self, PyObject *) {
  EventQueue *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_EventQueue, (void **)&local_this, "EventQueue.dequeue_event")) {
    return nullptr;
  }
  // 1-CPT_Event EventQueue::dequeue_event(void)
  ConstPointerTo< Event > return_value = ((*local_this).dequeue_event)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  Event const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Event, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_EventQueue_dequeue_event_268_comment =
  "C++ Interface:\n"
  "dequeue_event(const EventQueue self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_EventQueue_dequeue_event_268_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline EventQueue *EventQueue::get_global_event_queue(void)
 */
static PyObject *Dtool_EventQueue_get_global_event_queue_269(PyObject *, PyObject *) {
  // 1-static inline EventQueue *EventQueue::get_global_event_queue(void)
  EventQueue *return_value = (EventQueue::get_global_event_queue)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EventQueue, false, false);
}

#ifndef NDEBUG
static const char *Dtool_EventQueue_get_global_event_queue_269_comment =
  "C++ Interface:\n"
  "get_global_event_queue()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the one global EventQueue object.  If the global\n"
  " * object has not yet been created, this will create it.\n"
  " */";
#else
static const char *Dtool_EventQueue_get_global_event_queue_269_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EventQueue::EventQueue(void)
 */
static int Dtool_Init_EventQueue(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("EventQueue() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EventQueue() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-EventQueue::EventQueue(void)
  EventQueue *return_value = new EventQueue();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EventQueue, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EventQueue()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EventQueue(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EventQueue) {
    printf("EventQueue ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EventQueue *local_this = (EventQueue *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EventQueue) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EventQueue(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EventQueue) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerEventList
 */
/**
 * Python function wrapper for:
 * inline std::size_t PointerEventList::get_num_events(void) const
 */
static PyObject *Dtool_PointerEventList_get_num_events_272(PyObject *self, PyObject *) {
  PointerEventList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerEventList)) {
    return nullptr;
  }
  // 1-inline std::size_t PointerEventList::get_num_events(void) const
  std::size_t return_value = ((*(const PointerEventList*)local_this).get_num_events)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_num_events_272_comment =
  "C++ Interface:\n"
  "get_num_events(PointerEventList self)\n"
  "\n"
  "/**\n"
  " * Returns the number of events in the list.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_num_events_272_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PointerEventList::get_in_window(std::size_t n) const
 */
static PyObject *Dtool_PointerEventList_get_in_window_273(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerEventList)) {
    return nullptr;
  }
  // 1-inline bool PointerEventList::get_in_window(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    bool return_value = ((*(const PointerEventList*)local_this).get_in_window)(arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_in_window(PointerEventList self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_in_window_273_comment =
  "C++ Interface:\n"
  "get_in_window(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the in-window flag of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_in_window_273_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerEventList::get_xpos(std::size_t n) const
 */
static PyObject *Dtool_PointerEventList_get_xpos_274(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerEventList)) {
    return nullptr;
  }
  // 1-inline int PointerEventList::get_xpos(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    int return_value = ((*(const PointerEventList*)local_this).get_xpos)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_xpos(PointerEventList self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_xpos_274_comment =
  "C++ Interface:\n"
  "get_xpos(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the x-coordinate of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_xpos_274_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerEventList::get_ypos(std::size_t n) const
 */
static PyObject *Dtool_PointerEventList_get_ypos_275(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerEventList)) {
    return nullptr;
  }
  // 1-inline int PointerEventList::get_ypos(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    int return_value = ((*(const PointerEventList*)local_this).get_ypos)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ypos(PointerEventList self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_ypos_275_comment =
  "C++ Interface:\n"
  "get_ypos(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the y-coordinate of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_ypos_275_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double PointerEventList::get_dx(std::size_t n) const
 */
static PyObject *Dtool_PointerEventList_get_dx_276(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerEventList)) {
    return nullptr;
  }
  // 1-inline double PointerEventList::get_dx(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    double return_value = ((*(const PointerEventList*)local_this).get_dx)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_dx(PointerEventList self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_dx_276_comment =
  "C++ Interface:\n"
  "get_dx(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the x-delta of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_dx_276_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double PointerEventList::get_dy(std::size_t n) const
 */
static PyObject *Dtool_PointerEventList_get_dy_277(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerEventList)) {
    return nullptr;
  }
  // 1-inline double PointerEventList::get_dy(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    double return_value = ((*(const PointerEventList*)local_this).get_dy)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_dy(PointerEventList self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_dy_277_comment =
  "C++ Interface:\n"
  "get_dy(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the y-delta of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_dy_277_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerEventList::get_sequence(std::size_t n) const
 */
static PyObject *Dtool_PointerEventList_get_sequence_278(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerEventList)) {
    return nullptr;
  }
  // 1-inline int PointerEventList::get_sequence(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    int return_value = ((*(const PointerEventList*)local_this).get_sequence)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_sequence(PointerEventList self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_sequence_278_comment =
  "C++ Interface:\n"
  "get_sequence(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the sequence number of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_sequence_278_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double PointerEventList::get_length(std::size_t n) const
 */
static PyObject *Dtool_PointerEventList_get_length_279(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerEventList)) {
    return nullptr;
  }
  // 1-inline double PointerEventList::get_length(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    double return_value = ((*(const PointerEventList*)local_this).get_length)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_length(PointerEventList self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_length_279_comment =
  "C++ Interface:\n"
  "get_length(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the length of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_length_279_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double PointerEventList::get_direction(std::size_t n) const
 */
static PyObject *Dtool_PointerEventList_get_direction_280(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerEventList)) {
    return nullptr;
  }
  // 1-inline double PointerEventList::get_direction(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    double return_value = ((*(const PointerEventList*)local_this).get_direction)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_direction(PointerEventList self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_direction_280_comment =
  "C++ Interface:\n"
  "get_direction(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the direction of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_direction_280_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double PointerEventList::get_rotation(std::size_t n) const
 */
static PyObject *Dtool_PointerEventList_get_rotation_281(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerEventList)) {
    return nullptr;
  }
  // 1-inline double PointerEventList::get_rotation(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    double return_value = ((*(const PointerEventList*)local_this).get_rotation)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_rotation(PointerEventList self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_rotation_281_comment =
  "C++ Interface:\n"
  "get_rotation(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the rotation of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_rotation_281_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double PointerEventList::get_time(std::size_t n) const
 */
static PyObject *Dtool_PointerEventList_get_time_282(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerEventList)) {
    return nullptr;
  }
  // 1-inline double PointerEventList::get_time(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    double return_value = ((*(const PointerEventList*)local_this).get_time)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_time(PointerEventList self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_time_282_comment =
  "C++ Interface:\n"
  "get_time(PointerEventList self, int n)\n"
  "\n"
  "/**\n"
  " * Get the timestamp of the nth event.\n"
  " */";
#else
static const char *Dtool_PointerEventList_get_time_282_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerEventList::clear(void)
 */
static PyObject *Dtool_PointerEventList_clear_283(PyObject *self, PyObject *) {
  PointerEventList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerEventList, (void **)&local_this, "PointerEventList.clear")) {
    return nullptr;
  }
  // 1-inline void PointerEventList::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_clear_283_comment =
  "C++ Interface:\n"
  "clear(const PointerEventList self)\n"
  "\n"
  "/**\n"
  " * Empties all the events from the list.\n"
  " */";
#else
static const char *Dtool_PointerEventList_clear_283_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerEventList::pop_front(void)
 */
static PyObject *Dtool_PointerEventList_pop_front_284(PyObject *self, PyObject *) {
  PointerEventList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerEventList, (void **)&local_this, "PointerEventList.pop_front")) {
    return nullptr;
  }
  // 1-inline void PointerEventList::pop_front(void)
  ((*local_this).pop_front)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_pop_front_284_comment =
  "C++ Interface:\n"
  "pop_front(const PointerEventList self)\n"
  "\n"
  "/**\n"
  " * Discards the first event on the list.\n"
  " */";
#else
static const char *Dtool_PointerEventList_pop_front_284_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerEventList::add_event(PointerData const &data, int seq, double time)
 * void PointerEventList::add_event(bool in_win, int xpos, int ypos, double xdelta, double ydelta, int seq, double time)
 * void PointerEventList::add_event(bool in_win, int xpos, int ypos, int seq, double time)
 */
static PyObject *Dtool_PointerEventList_add_event_285(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerEventList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerEventList, (void **)&local_this, "PointerEventList.add_event")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-void PointerEventList::add_event(PointerData const &data, int seq, double time)
      PyObject *param1;
      int param2;
      double param3;
      static const char *keyword_list[] = {"data", "seq", "time", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oid:add_event", (char **)keyword_list, &param1, &param2, &param3)) {
        PointerData const *param1_this = (PointerData *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PointerData, 1, "PointerEventList.add_event", true, true);
        if (param1_this != nullptr) {
          ((*local_this).add_event)(*param1_this, (int)param2, (double)param3);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 5:
    {
      // 1-void PointerEventList::add_event(bool in_win, int xpos, int ypos, int seq, double time)
      PyObject *param1;
      int param2;
      int param3;
      int param4;
      double param5;
      static const char *keyword_list[] = {"in_win", "xpos", "ypos", "seq", "time", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oiiid:add_event", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        ((*local_this).add_event)((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3, (int)param4, (double)param5);
        return Dtool_Return_None();
      }
    }
    break;
  case 7:
    {
      // 1-void PointerEventList::add_event(bool in_win, int xpos, int ypos, double xdelta, double ydelta, int seq, double time)
      PyObject *param1;
      int param2;
      int param3;
      double param4;
      double param5;
      int param6;
      double param7;
      static const char *keyword_list[] = {"in_win", "xpos", "ypos", "xdelta", "ydelta", "seq", "time", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oiiddid:add_event", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7)) {
        ((*local_this).add_event)((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3, (double)param4, (double)param5, (int)param6, (double)param7);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_event() takes 4, 6 or 8 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_event(const PointerEventList self, const PointerData data, int seq, double time)\n"
      "add_event(const PointerEventList self, bool in_win, int xpos, int ypos, int seq, double time)\n"
      "add_event(const PointerEventList self, bool in_win, int xpos, int ypos, double xdelta, double ydelta, int seq, double time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_add_event_285_comment =
  "C++ Interface:\n"
  "add_event(const PointerEventList self, const PointerData data, int seq, double time)\n"
  "add_event(const PointerEventList self, bool in_win, int xpos, int ypos, int seq, double time)\n"
  "add_event(const PointerEventList self, bool in_win, int xpos, int ypos, double xdelta, double ydelta, int seq, double time)\n"
  "\n"
  "/**\n"
  " * Adds a new event from the given PointerData object.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new event to the end of the list.  Automatically calculates the dx,\n"
  " * dy, length, direction, and rotation for all but the first event.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new event to the end of the list based on the given mouse movement.\n"
  " */";
#else
static const char *Dtool_PointerEventList_add_event_285_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PointerEventList::encircles(int x, int y) const
 */
static PyObject *Dtool_PointerEventList_encircles_286(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerEventList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerEventList)) {
    return nullptr;
  }
  // 1-bool PointerEventList::encircles(int x, int y) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:encircles", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const PointerEventList*)local_this).encircles)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encircles(PointerEventList self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_encircles_286_comment =
  "C++ Interface:\n"
  "encircles(PointerEventList self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Returns true if the trail loops around the specified point.\n"
  " */";
#else
static const char *Dtool_PointerEventList_encircles_286_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double PointerEventList::total_turns(double sec) const
 */
static PyObject *Dtool_PointerEventList_total_turns_287(PyObject *self, PyObject *arg) {
  PointerEventList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerEventList)) {
    return nullptr;
  }
  // 1-double PointerEventList::total_turns(double sec) const
  if (PyNumber_Check(arg)) {
    double return_value = ((*(const PointerEventList*)local_this).total_turns)(PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "total_turns(PointerEventList self, double sec)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_total_turns_287_comment =
  "C++ Interface:\n"
  "total_turns(PointerEventList self, double sec)\n"
  "\n"
  "/**\n"
  " * returns the total angular deviation that the trail has made in the\n"
  " * specified time period.  A small number means that the trail is moving in a\n"
  " * relatively straight line, a large number means that the trail is zig-\n"
  " * zagging or spinning.  The result is in degrees.\n"
  " */";
#else
static const char *Dtool_PointerEventList_total_turns_287_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double PointerEventList::match_pattern(std::string const &pattern, double rot, double seglen)
 */
static PyObject *Dtool_PointerEventList_match_pattern_288(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerEventList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerEventList, (void **)&local_this, "PointerEventList.match_pattern")) {
    return nullptr;
  }
  // 1-double PointerEventList::match_pattern(std::string const &pattern, double rot, double seglen)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  double param2;
  double param3;
  static const char *keyword_list[] = {"pattern", "rot", "seglen", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#dd:match_pattern", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
    double return_value = ((*local_this).match_pattern)(std::string(param1_str, param1_len), (double)param2, (double)param3);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "match_pattern(const PointerEventList self, str pattern, double rot, double seglen)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_match_pattern_288_comment =
  "C++ Interface:\n"
  "match_pattern(const PointerEventList self, str pattern, double rot, double seglen)\n"
  "\n"
  "/**\n"
  " * This function is not implemented yet.  It is a work in progress.  The\n"
  " * intent is as follows:\n"
  " *\n"
  " * Returns a nonzero value if the mouse movements match the specified pattern.\n"
  " * The higher the value, the better the match.  The pattern is a sequence of\n"
  " * compass directions (ie, \"E\", \"NE\", etc) separated by spaces.  If rot is\n"
  " * nonzero, then the pattern is rotated counterclockwise by the specified\n"
  " * amount before testing.  Seglen is the minimum length a mouse movement needs\n"
  " * to be in order to be considered significant.\n"
  " */";
#else
static const char *Dtool_PointerEventList_match_pattern_288_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PointerEventList::get_class_type(void)
 */
static PyObject *Dtool_PointerEventList_get_class_type_289(PyObject *, PyObject *) {
  // 1-static TypeHandle PointerEventList::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PointerEventList::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PointerEventList_get_class_type_289_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PointerEventList_get_class_type_289_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerEventList::PointerEventList(void)
 */
static int Dtool_Init_PointerEventList(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("PointerEventList() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PointerEventList() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline PointerEventList::PointerEventList(void)
  PointerEventList *return_value = new PointerEventList();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerEventList, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerEventList()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PointerEventList(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerEventList) {
    printf("PointerEventList ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerEventList *local_this = (PointerEventList *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerEventList) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerEventList(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerEventList) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (PointerEventList*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PointerEventList*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PointerEventList*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PointerEventList*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PointerEventList*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PythonTask
 */
/**
 * Python function wrapper for:
 * void PythonTask::set_function(PyObject *function)
 */
static PyObject *Dtool_PythonTask_set_function_296(PyObject *self, PyObject *arg) {
  PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.set_function")) {
    return nullptr;
  }
  // 1-void PythonTask::set_function(PyObject *function)
  ((*local_this).set_function)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_function(const PythonTask self, object function)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_set_function_296_comment =
  "C++ Interface:\n"
  "set_function(const PythonTask self, object function)\n";
#else
static const char *Dtool_PythonTask_set_function_296_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *PythonTask::get_function(void)
 */
static PyObject *Dtool_PythonTask_get_function_297(PyObject *self, PyObject *) {
  PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.get_function")) {
    return nullptr;
  }
  // 1-inline PyObject *PythonTask::get_function(void)
  PyObject *return_value = ((*local_this).get_function)();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_get_function_297_comment =
  "C++ Interface:\n"
  "get_function(const PythonTask self)\n"
  "\n"
  "/**\n"
  " * Returns the function that is called when the task runs.\n"
  " */";
#else
static const char *Dtool_PythonTask_get_function_297_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PythonTask::set_args(PyObject *args, bool append_task)
 */
static PyObject *Dtool_PythonTask_set_args_298(PyObject *self, PyObject *args, PyObject *kwds) {
  PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.set_args")) {
    return nullptr;
  }
  // 1-void PythonTask::set_args(PyObject *args, bool append_task)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"args", "append_task", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_args", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_args)(param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_args(const PythonTask self, object args, bool append_task)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_set_args_298_comment =
  "C++ Interface:\n"
  "set_args(const PythonTask self, object args, bool append_task)\n";
#else
static const char *Dtool_PythonTask_set_args_298_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PythonTask::get_args(void)
 */
static PyObject *Dtool_PythonTask_get_args_299(PyObject *self, PyObject *) {
  PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.get_args")) {
    return nullptr;
  }
  // 1-PyObject *PythonTask::get_args(void)
  PyObject *return_value = ((*local_this).get_args)();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_get_args_299_comment =
  "C++ Interface:\n"
  "get_args(const PythonTask self)\n";
#else
static const char *Dtool_PythonTask_get_args_299_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PythonTask::set_upon_death(PyObject *upon_death)
 */
static PyObject *Dtool_PythonTask_set_upon_death_300(PyObject *self, PyObject *arg) {
  PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.set_upon_death")) {
    return nullptr;
  }
  // 1-void PythonTask::set_upon_death(PyObject *upon_death)
  ((*local_this).set_upon_death)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_upon_death(const PythonTask self, object upon_death)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_set_upon_death_300_comment =
  "C++ Interface:\n"
  "set_upon_death(const PythonTask self, object upon_death)\n";
#else
static const char *Dtool_PythonTask_set_upon_death_300_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *PythonTask::get_upon_death(void)
 */
static PyObject *Dtool_PythonTask_get_upon_death_301(PyObject *self, PyObject *) {
  PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.get_upon_death")) {
    return nullptr;
  }
  // 1-inline PyObject *PythonTask::get_upon_death(void)
  PyObject *return_value = ((*local_this).get_upon_death)();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_get_upon_death_301_comment =
  "C++ Interface:\n"
  "get_upon_death(const PythonTask self)\n"
  "\n"
  "/**\n"
  " * Returns the function that is called when the task finishes.\n"
  " */";
#else
static const char *Dtool_PythonTask_get_upon_death_301_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PythonTask::set_owner(PyObject *owner)
 */
static PyObject *Dtool_PythonTask_set_owner_302(PyObject *self, PyObject *arg) {
  PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.set_owner")) {
    return nullptr;
  }
  // 1-void PythonTask::set_owner(PyObject *owner)
  ((*local_this).set_owner)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_owner(const PythonTask self, object owner)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_set_owner_302_comment =
  "C++ Interface:\n"
  "set_owner(const PythonTask self, object owner)\n";
#else
static const char *Dtool_PythonTask_set_owner_302_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *PythonTask::get_owner(void) const
 */
static PyObject *Dtool_PythonTask_get_owner_303(PyObject *self, PyObject *) {
  PythonTask *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PythonTask)) {
    return nullptr;
  }
  // 1-inline PyObject *PythonTask::get_owner(void) const
  PyObject *return_value = ((*(const PythonTask*)local_this).get_owner)();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_get_owner_303_comment =
  "C++ Interface:\n"
  "get_owner(PythonTask self)\n"
  "\n"
  "/**\n"
  " * Returns the \"owner\" object.  See set_owner().\n"
  " */";
#else
static const char *Dtool_PythonTask_get_owner_303_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PythonTask::set_result(PyObject *result)
 */
static PyObject *Dtool_PythonTask_set_result_304(PyObject *self, PyObject *arg) {
  PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.set_result")) {
    return nullptr;
  }
  // 1-inline void PythonTask::set_result(PyObject *result)
  ((*local_this).set_result)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_result(const PythonTask self, object result)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_set_result_304_comment =
  "C++ Interface:\n"
  "set_result(const PythonTask self, object result)\n"
  "\n"
  "/**\n"
  " * Sets the \"result\" of this task.  This is the value returned from an \"await\"\n"
  " * expression on this task.\n"
  " * This can only be called while the task is still alive.\n"
  " */";
#else
static const char *Dtool_PythonTask_set_result_304_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PythonTask::get_class_type(void)
 */
static PyObject *Dtool_PythonTask_get_class_type_329(PyObject *, PyObject *) {
  // 1-static TypeHandle PythonTask::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PythonTask::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PythonTask_get_class_type_329_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PythonTask_get_class_type_329_comment = nullptr;
#endif

static PyObject *Dtool_PythonTask_time_Getter(PyObject *self, void *) {
  const PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return nullptr;
  }

  // 1-double PythonTask::get_elapsed_time(void) const
  double return_value = ((*(const PythonTask*)local_this).get_elapsed_time)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PythonTask_wake_time_Getter(PyObject *self, void *) {
  const PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return nullptr;
  }

  // 1-double PythonTask::get_wake_time(void) const
  double return_value = ((*(const PythonTask*)local_this).get_wake_time)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PythonTask_wakeTime_Getter(PyObject *self, void *) {
  const PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return nullptr;
  }

  // 1-double PythonTask::get_wake_time(void) const
  double return_value = ((*(const PythonTask*)local_this).get_wake_time)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PythonTask_delay_time_Getter(PyObject *self, void *) {
  const PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_delay()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline double PythonTask::get_delay(void) const
  double return_value = ((*(const PythonTask*)local_this).get_delay)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PythonTask_delay_time_Setter(PyObject *self, PyObject *arg, void *) {
  PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.delay_time")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete delay_time attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_delay();
    return 0;
  }
  // 1-inline void PythonTask::set_delay(double delay)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_delay)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_delay(const PythonTask self, double delay)\n");
  }
  return -1;
}

static PyObject *Dtool_PythonTask_delayTime_Getter(PyObject *self, void *) {
  const PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_delay()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline double PythonTask::get_delay(void) const
  double return_value = ((*(const PythonTask*)local_this).get_delay)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PythonTask_delayTime_Setter(PyObject *self, PyObject *arg, void *) {
  PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.delayTime")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete delayTime attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_delay();
    return 0;
  }
  // 1-inline void PythonTask::set_delay(double delay)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_delay)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_delay(const PythonTask self, double delay)\n");
  }
  return -1;
}

static PyObject *Dtool_PythonTask_frame_Getter(PyObject *self, void *) {
  const PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return nullptr;
  }

  // 1-int PythonTask::get_elapsed_frames(void) const
  int return_value = ((*(const PythonTask*)local_this).get_elapsed_frames)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PythonTask___dict___Getter(PyObject *self, void *) {
  const PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return nullptr;
  }

  // 1-PyObject *PythonTask::get_dict(void) const
  PyObject *return_value = ((const PythonTask*)local_this)->__dict__;
  Py_XINCREF(return_value);
  return Dtool_WrapValue(return_value);
}

static int Dtool_PythonTask___dict___Setter(PyObject *self, PyObject *arg, void *) {
  PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonTask, (void **)&local_this, "PythonTask.__dict__")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete __dict__ attribute");
    return -1;
  }
  // 1-void PythonTask::set_dict(PyObject *value)
  Dtool_Assign_PyObject((local_this)->__dict__, arg);
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_dict(const PythonTask self, object value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * PythonTask::PythonTask(PyObject *function = (& ::_Py_NoneStruct), std::string const &name = string())
 * inline PythonTask::PythonTask(PythonTask const &) = default
 */
static int Dtool_Init_PythonTask(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PythonTask::PythonTask(PyObject *function, std::string const &name)
      PythonTask *return_value = new PythonTask();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PythonTask, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 PythonTask::PythonTask(PyObject *function, std::string const &name = string())
        PyObject *param0;
        const char *param1_str = "";
        Py_ssize_t param1_len = 0;
        static const char *keyword_list[] = {"function", "name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:PythonTask", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
          PythonTask *return_value = new PythonTask(param0, std::string(param1_str, param1_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            unref_delete(return_value);
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              unref_delete(return_value);
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PythonTask, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PythonTask::PythonTask(PyObject *function, std::string const &name = string())
      {
        // -2 inline PythonTask::PythonTask(PythonTask const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          CPT(PythonTask) param0_this;
          if (Dtool_ConstCoerce_PythonTask(param0, param0_this)) {
            PythonTask *return_value = new PythonTask(*std::move(param0_this));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PythonTask, true, false);
          }
        }
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PythonTask() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PythonTask()\n"
      "PythonTask(object function, str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PythonTask(PyObject *args, CPT(PythonTask) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PythonTask)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PythonTask::PythonTask(PyObject *function, std::string const &name)
    PythonTask *return_value = new PythonTask(arg);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return false;
    }
    return_value->ref();
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != nullptr) {
      unref_delete(return_value);
      return false;
    } else {
      coerced = std::move(return_value);
      return true;
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-PythonTask::PythonTask(PyObject *function, std::string const &name)
      PyObject *param0;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:PythonTask", &param0, &param1_str, &param1_len)) {
        PythonTask *return_value = new PythonTask(param0, std::string(param1_str, param1_len));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        PyObject *exception = _PyErr_OCCURRED();
        if (exception == PyExc_TypeError) {
          // TypeError raised; continue to next overload type.
        } else if (exception != nullptr) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_PythonTask(PyObject *args, PT(PythonTask) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PythonTask)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PythonTask::PythonTask(PyObject *function, std::string const &name)
    PythonTask *return_value = new PythonTask(arg);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return false;
    }
    return_value->ref();
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != nullptr) {
      unref_delete(return_value);
      return false;
    } else {
      coerced = std::move(return_value);
      return true;
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-PythonTask::PythonTask(PyObject *function, std::string const &name)
      PyObject *param0;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:PythonTask", &param0, &param1_str, &param1_len)) {
        PythonTask *return_value = new PythonTask(param0, std::string(param1_str, param1_len));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        PyObject *exception = _PyErr_OCCURRED();
        if (exception == PyExc_TypeError) {
          // TypeError raised; continue to next overload type.
        } else if (exception != nullptr) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_PythonTask(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PythonTask) {
    printf("PythonTask ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PythonTask *local_this = (PythonTask *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PythonTask) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncFuture) {
    return (AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTask) {
    return (AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(AsyncFuture *)(AsyncTask *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PythonTask(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PythonTask) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AsyncFuture) {
    AsyncFuture* other_this = (AsyncFuture*)from_this;
    return (PythonTask*)other_this;
  }
  if (from_type == Dtool_Ptr_AsyncTask) {
    AsyncTask* other_this = (AsyncTask*)from_this;
    return (PythonTask*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PythonTask*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PythonTask*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PythonTask*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (PythonTask*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for EventParameter (EventParameter)
 */
static PyMethodDef Dtool_Methods_EventParameter[] = {
  {"assign", &Dtool_EventParameter_operator_3, METH_O, (const char *)Dtool_EventParameter_operator_3_comment},
  {"is_empty", &Dtool_EventParameter_is_empty_5, METH_NOARGS, (const char *)Dtool_EventParameter_is_empty_5_comment},
  {"isEmpty", &Dtool_EventParameter_is_empty_5, METH_NOARGS, (const char *)Dtool_EventParameter_is_empty_5_comment},
  {"is_int", &Dtool_EventParameter_is_int_6, METH_NOARGS, (const char *)Dtool_EventParameter_is_int_6_comment},
  {"isInt", &Dtool_EventParameter_is_int_6, METH_NOARGS, (const char *)Dtool_EventParameter_is_int_6_comment},
  {"get_int_value", &Dtool_EventParameter_get_int_value_7, METH_NOARGS, (const char *)Dtool_EventParameter_get_int_value_7_comment},
  {"getIntValue", &Dtool_EventParameter_get_int_value_7, METH_NOARGS, (const char *)Dtool_EventParameter_get_int_value_7_comment},
  {"is_double", &Dtool_EventParameter_is_double_8, METH_NOARGS, (const char *)Dtool_EventParameter_is_double_8_comment},
  {"isDouble", &Dtool_EventParameter_is_double_8, METH_NOARGS, (const char *)Dtool_EventParameter_is_double_8_comment},
  {"get_double_value", &Dtool_EventParameter_get_double_value_9, METH_NOARGS, (const char *)Dtool_EventParameter_get_double_value_9_comment},
  {"getDoubleValue", &Dtool_EventParameter_get_double_value_9, METH_NOARGS, (const char *)Dtool_EventParameter_get_double_value_9_comment},
  {"is_string", &Dtool_EventParameter_is_string_10, METH_NOARGS, (const char *)Dtool_EventParameter_is_string_10_comment},
  {"isString", &Dtool_EventParameter_is_string_10, METH_NOARGS, (const char *)Dtool_EventParameter_is_string_10_comment},
  {"get_string_value", &Dtool_EventParameter_get_string_value_11, METH_NOARGS, (const char *)Dtool_EventParameter_get_string_value_11_comment},
  {"getStringValue", &Dtool_EventParameter_get_string_value_11, METH_NOARGS, (const char *)Dtool_EventParameter_get_string_value_11_comment},
  {"is_wstring", &Dtool_EventParameter_is_wstring_12, METH_NOARGS, (const char *)Dtool_EventParameter_is_wstring_12_comment},
  {"isWstring", &Dtool_EventParameter_is_wstring_12, METH_NOARGS, (const char *)Dtool_EventParameter_is_wstring_12_comment},
  {"get_wstring_value", &Dtool_EventParameter_get_wstring_value_13, METH_NOARGS, (const char *)Dtool_EventParameter_get_wstring_value_13_comment},
  {"getWstringValue", &Dtool_EventParameter_get_wstring_value_13, METH_NOARGS, (const char *)Dtool_EventParameter_get_wstring_value_13_comment},
  {"is_typed_ref_count", &Dtool_EventParameter_is_typed_ref_count_14, METH_NOARGS, (const char *)Dtool_EventParameter_is_typed_ref_count_14_comment},
  {"isTypedRefCount", &Dtool_EventParameter_is_typed_ref_count_14, METH_NOARGS, (const char *)Dtool_EventParameter_is_typed_ref_count_14_comment},
  {"get_typed_ref_count_value", &Dtool_EventParameter_get_typed_ref_count_value_15, METH_NOARGS, (const char *)Dtool_EventParameter_get_typed_ref_count_value_15_comment},
  {"getTypedRefCountValue", &Dtool_EventParameter_get_typed_ref_count_value_15, METH_NOARGS, (const char *)Dtool_EventParameter_get_typed_ref_count_value_15_comment},
  {"get_ptr", &Dtool_EventParameter_get_ptr_16, METH_NOARGS, (const char *)Dtool_EventParameter_get_ptr_16_comment},
  {"getPtr", &Dtool_EventParameter_get_ptr_16, METH_NOARGS, (const char *)Dtool_EventParameter_get_ptr_16_comment},
  {"output", &Dtool_EventParameter_output_17, METH_O, (const char *)Dtool_EventParameter_output_17_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     EventParameter
//////////////////
static PyObject *Dtool_Repr_EventParameter(PyObject *self) {
  EventParameter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventParameter, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_EventParameter = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_EventParameter = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.EventParameter",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EventParameter,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_EventParameter,
    &Dtool_NumberMethods_EventParameter,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_EventParameter,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An optional parameter associated with an event.  Each event may have zero\n"
    " * or more of these.  Each parameter stores a pointer to a\n"
    " * TypedWritableReferenceCount object, which of course could be pretty much\n"
    " * anything.  To store a simple value like a double or a string, the\n"
    " * EventParameter constructors transparently use the ParamValue template class\n"
    " * from paramValue.h.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EventParameter,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EventParameter,
    PyType_GenericAlloc,
    Dtool_new_EventParameter,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EventParameter,
  Dtool_UpcastInterface_EventParameter,
  Dtool_DowncastInterface_EventParameter,
  nullptr,
  (CoerceFunction)Dtool_Coerce_EventParameter,
};

static void Dtool_PyModuleClassInit_EventParameter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_EventParameter._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EventParameter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EventParameter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EventParameter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EventParameter);
  }
}

/**
 * Python method tables for AsyncFuture (AsyncFuture)
 */
static PyMethodDef Dtool_Methods_AsyncFuture[] = {
  {"done", &Dtool_AsyncFuture_done_23, METH_NOARGS, (const char *)Dtool_AsyncFuture_done_23_comment},
  {"cancelled", &Dtool_AsyncFuture_cancelled_24, METH_NOARGS, (const char *)Dtool_AsyncFuture_cancelled_24_comment},
  {"result", (PyCFunction) &Dtool_AsyncFuture_result_25, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AsyncFuture_result_25_comment},
  {"cancel", &Dtool_AsyncFuture_cancel_26, METH_NOARGS, (const char *)Dtool_AsyncFuture_cancel_26_comment},
  {"set_done_event", &Dtool_AsyncFuture_set_done_event_27, METH_O, (const char *)Dtool_AsyncFuture_set_done_event_27_comment},
  {"setDoneEvent", &Dtool_AsyncFuture_set_done_event_27, METH_O, (const char *)Dtool_AsyncFuture_set_done_event_27_comment},
  {"get_done_event", &Dtool_AsyncFuture_get_done_event_28, METH_NOARGS, (const char *)Dtool_AsyncFuture_get_done_event_28_comment},
  {"getDoneEvent", &Dtool_AsyncFuture_get_done_event_28, METH_NOARGS, (const char *)Dtool_AsyncFuture_get_done_event_28_comment},
  {"add_done_callback", &Dtool_AsyncFuture_add_done_callback_33, METH_O, (const char *)Dtool_AsyncFuture_add_done_callback_33_comment},
  {"addDoneCallback", &Dtool_AsyncFuture_add_done_callback_33, METH_O, (const char *)Dtool_AsyncFuture_add_done_callback_33_comment},
  {"gather", &Dtool_AsyncFuture_gather_34, METH_VARARGS | METH_STATIC, (const char *)Dtool_AsyncFuture_gather_34_comment},
  {"output", &Dtool_AsyncFuture_output_35, METH_O, (const char *)Dtool_AsyncFuture_output_35_comment},
  {"wait", &Dtool_AsyncFuture_wait_36, METH_VARARGS, (const char *)Dtool_AsyncFuture_wait_36_comment},
  {"set_result", &Dtool_AsyncFuture_set_result_37, METH_O, (const char *)Dtool_AsyncFuture_set_result_37_comment},
  {"setResult", &Dtool_AsyncFuture_set_result_37, METH_O, (const char *)Dtool_AsyncFuture_set_result_37_comment},
  {"get_class_type", &Dtool_AsyncFuture_get_class_type_38, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncFuture_get_class_type_38_comment},
  {"getClassType", &Dtool_AsyncFuture_get_class_type_38, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncFuture_get_class_type_38_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// AsyncFuture slot am_await -> __await__
//////////////////
static PyObject *Dtool_AsyncFuture_await_21_am_await(PyObject *self) {
  AsyncFuture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncFuture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-static PyObject *AsyncFuture::__await__(PyObject *self)
  PyObject *return_value = Extension<AsyncFuture>::__await__(self);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__await__()\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// AsyncFuture slot tp_iter -> __iter__
//////////////////
static PyObject *Dtool_AsyncFuture_iter_22_tp_iter(PyObject *self) {
  AsyncFuture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncFuture, (void **)&local_this)) {
    return nullptr;
  }

  // 1-static PyObject *AsyncFuture::__iter__(PyObject *self)
  PyObject *return_value = Extension<AsyncFuture>::__iter__(self);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__iter__()\n");
  }
  return nullptr;
}

//////////////////
//  A __repr__ function
//     AsyncFuture
//////////////////
static PyObject *Dtool_Repr_AsyncFuture(PyObject *self) {
  AsyncFuture *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncFuture, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_AsyncFuture[] = {
  {(char *)"done_event", &Dtool_AsyncFuture_done_event_Getter, &Dtool_AsyncFuture_done_event_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_AsyncFuture = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AsyncFuture = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AsyncFuture = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AsyncFuture = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AsyncFuture = {
  &Dtool_AsyncFuture_await_21_am_await,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AsyncFuture = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AsyncFuture",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AsyncFuture,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AsyncFuture,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_AsyncFuture,
    &Dtool_NumberMethods_AsyncFuture,
    &Dtool_SequenceMethods_AsyncFuture,
    &Dtool_MappingMethods_AsyncFuture,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_AsyncFuture,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AsyncFuture,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class represents a thread-safe handle to a promised future result of\n"
    " * an asynchronous operation, providing methods to query its status and result\n"
    " * as well as register callbacks for this future's completion.\n"
    " *\n"
    " * An AsyncFuture can be awaited from within a coroutine or task.  It keeps\n"
    " * track of tasks waiting for this future and automatically reactivates them\n"
    " * upon this future's completion.\n"
    " *\n"
    " * A task itself is also a subclass of AsyncFuture.  Other subclasses are\n"
    " * not generally necessary, except to override the function of `cancel()`.\n"
    " *\n"
    " * Until the future is done, it is \"owned\" by the resolver thread, though it's\n"
    " * still legal for other threads to query its state.  When the resolver thread\n"
    " * resolves this future using `set_result()`, or any thread calls `cancel()`,\n"
    " * it instantly enters the \"done\" state, after which the result becomes a\n"
    " * read-only field that all threads can access.\n"
    " *\n"
    " * When the future returns true for done(), a thread can use cancelled() to\n"
    " * determine whether the future was cancelled or get_result() to access the\n"
    " * result of the operation.  Not all operations define a meaningful result\n"
    " * value, so some will always return nullptr.\n"
    " *\n"
    " * In Python, the `cancelled()`, `wait()` and `get_result()` methods are\n"
    " * wrapped up into a single `result()` method which waits for the future to\n"
    " * complete before either returning the result or throwing an exception if the\n"
    " * future was cancelled.\n"
    " * However, it is preferable to use the `await` keyword when running from a\n"
    " * coroutine, which only suspends the current task and not the entire thread.\n"
    " *\n"
    " * This API aims to mirror and be compatible with Python's Future class.\n"
    " *\n"
    " * @since 1.10.0\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    &Dtool_AsyncFuture_iter_22_tp_iter,
    nullptr,
    Dtool_Methods_AsyncFuture,
    nullptr, // tp_members
    Dtool_Properties_AsyncFuture,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AsyncFuture,
    PyType_GenericAlloc,
    Dtool_new_AsyncFuture,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AsyncFuture,
  Dtool_UpcastInterface_AsyncFuture,
  Dtool_DowncastInterface_AsyncFuture,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AsyncFuture(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_AsyncFuture._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_AsyncFuture._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AsyncFuture._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AsyncFuture) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AsyncFuture)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AsyncFuture);
  }
}

/**
 * Python method tables for AsyncTask (AsyncTask)
 */
static PyMethodDef Dtool_Methods_AsyncTask[] = {
  {"get_state", &Dtool_AsyncTask_get_state_48, METH_NOARGS, (const char *)Dtool_AsyncTask_get_state_48_comment},
  {"getState", &Dtool_AsyncTask_get_state_48, METH_NOARGS, (const char *)Dtool_AsyncTask_get_state_48_comment},
  {"is_alive", &Dtool_AsyncTask_is_alive_49, METH_NOARGS, (const char *)Dtool_AsyncTask_is_alive_49_comment},
  {"isAlive", &Dtool_AsyncTask_is_alive_49, METH_NOARGS, (const char *)Dtool_AsyncTask_is_alive_49_comment},
  {"get_manager", &Dtool_AsyncTask_get_manager_50, METH_NOARGS, (const char *)Dtool_AsyncTask_get_manager_50_comment},
  {"getManager", &Dtool_AsyncTask_get_manager_50, METH_NOARGS, (const char *)Dtool_AsyncTask_get_manager_50_comment},
  {"remove", &Dtool_AsyncTask_remove_51, METH_NOARGS, (const char *)Dtool_AsyncTask_remove_51_comment},
  {"set_delay", &Dtool_AsyncTask_set_delay_52, METH_O, (const char *)Dtool_AsyncTask_set_delay_52_comment},
  {"setDelay", &Dtool_AsyncTask_set_delay_52, METH_O, (const char *)Dtool_AsyncTask_set_delay_52_comment},
  {"clear_delay", &Dtool_AsyncTask_clear_delay_53, METH_NOARGS, (const char *)Dtool_AsyncTask_clear_delay_53_comment},
  {"clearDelay", &Dtool_AsyncTask_clear_delay_53, METH_NOARGS, (const char *)Dtool_AsyncTask_clear_delay_53_comment},
  {"has_delay", &Dtool_AsyncTask_has_delay_54, METH_NOARGS, (const char *)Dtool_AsyncTask_has_delay_54_comment},
  {"hasDelay", &Dtool_AsyncTask_has_delay_54, METH_NOARGS, (const char *)Dtool_AsyncTask_has_delay_54_comment},
  {"get_delay", &Dtool_AsyncTask_get_delay_55, METH_NOARGS, (const char *)Dtool_AsyncTask_get_delay_55_comment},
  {"getDelay", &Dtool_AsyncTask_get_delay_55, METH_NOARGS, (const char *)Dtool_AsyncTask_get_delay_55_comment},
  {"get_wake_time", &Dtool_AsyncTask_get_wake_time_56, METH_NOARGS, (const char *)Dtool_AsyncTask_get_wake_time_56_comment},
  {"getWakeTime", &Dtool_AsyncTask_get_wake_time_56, METH_NOARGS, (const char *)Dtool_AsyncTask_get_wake_time_56_comment},
  {"recalc_wake_time", &Dtool_AsyncTask_recalc_wake_time_57, METH_NOARGS, (const char *)Dtool_AsyncTask_recalc_wake_time_57_comment},
  {"recalcWakeTime", &Dtool_AsyncTask_recalc_wake_time_57, METH_NOARGS, (const char *)Dtool_AsyncTask_recalc_wake_time_57_comment},
  {"get_start_time", &Dtool_AsyncTask_get_start_time_58, METH_NOARGS, (const char *)Dtool_AsyncTask_get_start_time_58_comment},
  {"getStartTime", &Dtool_AsyncTask_get_start_time_58, METH_NOARGS, (const char *)Dtool_AsyncTask_get_start_time_58_comment},
  {"get_elapsed_time", &Dtool_AsyncTask_get_elapsed_time_59, METH_NOARGS, (const char *)Dtool_AsyncTask_get_elapsed_time_59_comment},
  {"getElapsedTime", &Dtool_AsyncTask_get_elapsed_time_59, METH_NOARGS, (const char *)Dtool_AsyncTask_get_elapsed_time_59_comment},
  {"get_start_frame", &Dtool_AsyncTask_get_start_frame_60, METH_NOARGS, (const char *)Dtool_AsyncTask_get_start_frame_60_comment},
  {"getStartFrame", &Dtool_AsyncTask_get_start_frame_60, METH_NOARGS, (const char *)Dtool_AsyncTask_get_start_frame_60_comment},
  {"get_elapsed_frames", &Dtool_AsyncTask_get_elapsed_frames_61, METH_NOARGS, (const char *)Dtool_AsyncTask_get_elapsed_frames_61_comment},
  {"getElapsedFrames", &Dtool_AsyncTask_get_elapsed_frames_61, METH_NOARGS, (const char *)Dtool_AsyncTask_get_elapsed_frames_61_comment},
  {"set_name", &Dtool_AsyncTask_set_name_62, METH_O, (const char *)Dtool_AsyncTask_set_name_62_comment},
  {"setName", &Dtool_AsyncTask_set_name_62, METH_O, (const char *)Dtool_AsyncTask_set_name_62_comment},
  {"clear_name", &Dtool_AsyncTask_clear_name_63, METH_NOARGS, (const char *)Dtool_AsyncTask_clear_name_63_comment},
  {"clearName", &Dtool_AsyncTask_clear_name_63, METH_NOARGS, (const char *)Dtool_AsyncTask_clear_name_63_comment},
  {"get_name_prefix", &Dtool_AsyncTask_get_name_prefix_64, METH_NOARGS, (const char *)Dtool_AsyncTask_get_name_prefix_64_comment},
  {"getNamePrefix", &Dtool_AsyncTask_get_name_prefix_64, METH_NOARGS, (const char *)Dtool_AsyncTask_get_name_prefix_64_comment},
  {"get_task_id", &Dtool_AsyncTask_get_task_id_65, METH_NOARGS, (const char *)Dtool_AsyncTask_get_task_id_65_comment},
  {"getTaskId", &Dtool_AsyncTask_get_task_id_65, METH_NOARGS, (const char *)Dtool_AsyncTask_get_task_id_65_comment},
  {"set_task_chain", &Dtool_AsyncTask_set_task_chain_66, METH_O, (const char *)Dtool_AsyncTask_set_task_chain_66_comment},
  {"setTaskChain", &Dtool_AsyncTask_set_task_chain_66, METH_O, (const char *)Dtool_AsyncTask_set_task_chain_66_comment},
  {"get_task_chain", &Dtool_AsyncTask_get_task_chain_67, METH_NOARGS, (const char *)Dtool_AsyncTask_get_task_chain_67_comment},
  {"getTaskChain", &Dtool_AsyncTask_get_task_chain_67, METH_NOARGS, (const char *)Dtool_AsyncTask_get_task_chain_67_comment},
  {"set_sort", &Dtool_AsyncTask_set_sort_68, METH_O, (const char *)Dtool_AsyncTask_set_sort_68_comment},
  {"setSort", &Dtool_AsyncTask_set_sort_68, METH_O, (const char *)Dtool_AsyncTask_set_sort_68_comment},
  {"get_sort", &Dtool_AsyncTask_get_sort_69, METH_NOARGS, (const char *)Dtool_AsyncTask_get_sort_69_comment},
  {"getSort", &Dtool_AsyncTask_get_sort_69, METH_NOARGS, (const char *)Dtool_AsyncTask_get_sort_69_comment},
  {"set_priority", &Dtool_AsyncTask_set_priority_70, METH_O, (const char *)Dtool_AsyncTask_set_priority_70_comment},
  {"setPriority", &Dtool_AsyncTask_set_priority_70, METH_O, (const char *)Dtool_AsyncTask_set_priority_70_comment},
  {"get_priority", &Dtool_AsyncTask_get_priority_71, METH_NOARGS, (const char *)Dtool_AsyncTask_get_priority_71_comment},
  {"getPriority", &Dtool_AsyncTask_get_priority_71, METH_NOARGS, (const char *)Dtool_AsyncTask_get_priority_71_comment},
  {"set_done_event", &Dtool_AsyncTask_set_done_event_72, METH_O, (const char *)Dtool_AsyncTask_set_done_event_72_comment},
  {"setDoneEvent", &Dtool_AsyncTask_set_done_event_72, METH_O, (const char *)Dtool_AsyncTask_set_done_event_72_comment},
  {"get_dt", &Dtool_AsyncTask_get_dt_73, METH_NOARGS, (const char *)Dtool_AsyncTask_get_dt_73_comment},
  {"getDt", &Dtool_AsyncTask_get_dt_73, METH_NOARGS, (const char *)Dtool_AsyncTask_get_dt_73_comment},
  {"get_max_dt", &Dtool_AsyncTask_get_max_dt_74, METH_NOARGS, (const char *)Dtool_AsyncTask_get_max_dt_74_comment},
  {"getMaxDt", &Dtool_AsyncTask_get_max_dt_74, METH_NOARGS, (const char *)Dtool_AsyncTask_get_max_dt_74_comment},
  {"get_average_dt", &Dtool_AsyncTask_get_average_dt_75, METH_NOARGS, (const char *)Dtool_AsyncTask_get_average_dt_75_comment},
  {"getAverageDt", &Dtool_AsyncTask_get_average_dt_75, METH_NOARGS, (const char *)Dtool_AsyncTask_get_average_dt_75_comment},
  {"output", &Dtool_AsyncTask_output_76, METH_O, (const char *)Dtool_AsyncTask_output_76_comment},
  {"get_class_type", &Dtool_AsyncTask_get_class_type_161, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTask_get_class_type_161_comment},
  {"getClassType", &Dtool_AsyncTask_get_class_type_161, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTask_get_class_type_161_comment},
  {"upcast_to_AsyncFuture", &Dtool_AsyncTask_upcast_to_AsyncFuture_40, METH_NOARGS, (const char *)Dtool_AsyncTask_upcast_to_AsyncFuture_40_comment},
  {"upcastToAsyncFuture", &Dtool_AsyncTask_upcast_to_AsyncFuture_40, METH_NOARGS, (const char *)Dtool_AsyncTask_upcast_to_AsyncFuture_40_comment},
  {"upcast_to_Namable", &Dtool_AsyncTask_upcast_to_Namable_43, METH_NOARGS, (const char *)Dtool_AsyncTask_upcast_to_Namable_43_comment},
  {"upcastToNamable", &Dtool_AsyncTask_upcast_to_Namable_43, METH_NOARGS, (const char *)Dtool_AsyncTask_upcast_to_Namable_43_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     AsyncTask
//////////////////
static PyObject *Dtool_Repr_AsyncTask(PyObject *self) {
  AsyncTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTask, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_AsyncTask[] = {
  {(char *)"state", &Dtool_AsyncTask_state_Getter, nullptr, nullptr, nullptr},
  {(char *)"alive", &Dtool_AsyncTask_alive_Getter, nullptr, nullptr, nullptr},
  {(char *)"manager", &Dtool_AsyncTask_manager_Getter, nullptr, nullptr, nullptr},
  {(char *)"name", &Dtool_AsyncTask_name_Getter, &Dtool_AsyncTask_name_Setter, (char *)
    "// The name of this task.",
    nullptr},
  {(char *)"id", &Dtool_AsyncTask_id_Getter, nullptr, (char *)
    "// This is a number guaranteed to be unique for each different AsyncTask\n"
    "// object in the universe.",
    nullptr},
  {(char *)"task_chain", &Dtool_AsyncTask_task_chain_Getter, &Dtool_AsyncTask_task_chain_Setter, nullptr, nullptr},
  {(char *)"sort", &Dtool_AsyncTask_sort_Getter, &Dtool_AsyncTask_sort_Setter, nullptr, nullptr},
  {(char *)"priority", &Dtool_AsyncTask_priority_Getter, &Dtool_AsyncTask_priority_Setter, nullptr, nullptr},
  {(char *)"done_event", &Dtool_AsyncTask_done_event_Getter, &Dtool_AsyncTask_done_event_Setter, (char *)
    "/**\n"
    " * Returns the event name that will be triggered when the future finishes.\n"
    " * See set_done_event().\n"
    " */",
    nullptr},
  {(char *)"dt", &Dtool_AsyncTask_dt_Getter, nullptr, nullptr, nullptr},
  {(char *)"max_dt", &Dtool_AsyncTask_max_dt_Getter, nullptr, nullptr, nullptr},
  {(char *)"average_dt", &Dtool_AsyncTask_average_dt_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_AsyncTask = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AsyncTask = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AsyncTask = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AsyncTask = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AsyncTask = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AsyncTask = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AsyncTask",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AsyncTask,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AsyncTask,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_AsyncTask,
    &Dtool_NumberMethods_AsyncTask,
    &Dtool_SequenceMethods_AsyncTask,
    &Dtool_MappingMethods_AsyncTask,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_AsyncTask,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AsyncTask,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class represents a concrete task performed by an AsyncManager.\n"
    " * Normally, you would subclass from this class, and override do_task(), to\n"
    " * define the functionality you wish to have the task perform.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AsyncTask,
    nullptr, // tp_members
    Dtool_Properties_AsyncTask,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AsyncTask,
    PyType_GenericAlloc,
    Dtool_new_AsyncTask,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AsyncTask,
  Dtool_UpcastInterface_AsyncTask,
  Dtool_DowncastInterface_AsyncTask,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AsyncTask(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AsyncFuture(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_AsyncTask._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_AsyncFuture, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_AsyncTask._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(31);
    Dtool_AsyncTask._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum AsyncTask::DoneStatus;
    PyDict_SetItemString(dict, "DS_done", Dtool_WrapValue(AsyncTask::DS_done));
    PyDict_SetItemString(dict, "DSDone", Dtool_WrapValue(AsyncTask::DS_done));
    PyDict_SetItemString(dict, "DS_cont", Dtool_WrapValue(AsyncTask::DS_cont));
    PyDict_SetItemString(dict, "DSCont", Dtool_WrapValue(AsyncTask::DS_cont));
    PyDict_SetItemString(dict, "DS_again", Dtool_WrapValue(AsyncTask::DS_again));
    PyDict_SetItemString(dict, "DSAgain", Dtool_WrapValue(AsyncTask::DS_again));
    PyDict_SetItemString(dict, "DS_pickup", Dtool_WrapValue(AsyncTask::DS_pickup));
    PyDict_SetItemString(dict, "DSPickup", Dtool_WrapValue(AsyncTask::DS_pickup));
    PyDict_SetItemString(dict, "DS_exit", Dtool_WrapValue(AsyncTask::DS_exit));
    PyDict_SetItemString(dict, "DSExit", Dtool_WrapValue(AsyncTask::DS_exit));
    PyDict_SetItemString(dict, "DS_pause", Dtool_WrapValue(AsyncTask::DS_pause));
    PyDict_SetItemString(dict, "DSPause", Dtool_WrapValue(AsyncTask::DS_pause));
    PyDict_SetItemString(dict, "DS_interrupt", Dtool_WrapValue(AsyncTask::DS_interrupt));
    PyDict_SetItemString(dict, "DSInterrupt", Dtool_WrapValue(AsyncTask::DS_interrupt));
    PyDict_SetItemString(dict, "DS_await", Dtool_WrapValue(AsyncTask::DS_await));
    PyDict_SetItemString(dict, "DSAwait", Dtool_WrapValue(AsyncTask::DS_await));
    // enum AsyncTask::State;
    PyDict_SetItemString(dict, "S_inactive", Dtool_WrapValue(AsyncTask::S_inactive));
    PyDict_SetItemString(dict, "SInactive", Dtool_WrapValue(AsyncTask::S_inactive));
    PyDict_SetItemString(dict, "S_active", Dtool_WrapValue(AsyncTask::S_active));
    PyDict_SetItemString(dict, "SActive", Dtool_WrapValue(AsyncTask::S_active));
    PyDict_SetItemString(dict, "S_servicing", Dtool_WrapValue(AsyncTask::S_servicing));
    PyDict_SetItemString(dict, "SServicing", Dtool_WrapValue(AsyncTask::S_servicing));
    PyDict_SetItemString(dict, "S_servicing_removed", Dtool_WrapValue(AsyncTask::S_servicing_removed));
    PyDict_SetItemString(dict, "SServicingRemoved", Dtool_WrapValue(AsyncTask::S_servicing_removed));
    PyDict_SetItemString(dict, "S_sleeping", Dtool_WrapValue(AsyncTask::S_sleeping));
    PyDict_SetItemString(dict, "SSleeping", Dtool_WrapValue(AsyncTask::S_sleeping));
    PyDict_SetItemString(dict, "S_active_nested", Dtool_WrapValue(AsyncTask::S_active_nested));
    PyDict_SetItemString(dict, "SActiveNested", Dtool_WrapValue(AsyncTask::S_active_nested));
    PyDict_SetItemString(dict, "S_awaiting", Dtool_WrapValue(AsyncTask::S_awaiting));
    PyDict_SetItemString(dict, "SAwaiting", Dtool_WrapValue(AsyncTask::S_awaiting));
    if (PyType_Ready((PyTypeObject *)&Dtool_AsyncTask) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AsyncTask)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AsyncTask);
  }
}

/**
 * Python method tables for AsyncTaskManager (AsyncTaskManager)
 */
static PyMethodDef Dtool_Methods_AsyncTaskManager[] = {
  {"cleanup", &Dtool_AsyncTaskManager_cleanup_89, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_cleanup_89_comment},
  {"set_clock", &Dtool_AsyncTaskManager_set_clock_90, METH_O, (const char *)Dtool_AsyncTaskManager_set_clock_90_comment},
  {"setClock", &Dtool_AsyncTaskManager_set_clock_90, METH_O, (const char *)Dtool_AsyncTaskManager_set_clock_90_comment},
  {"get_clock", &Dtool_AsyncTaskManager_get_clock_91, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_clock_91_comment},
  {"getClock", &Dtool_AsyncTaskManager_get_clock_91, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_clock_91_comment},
  {"get_num_task_chains", &Dtool_AsyncTaskManager_get_num_task_chains_95, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_num_task_chains_95_comment},
  {"getNumTaskChains", &Dtool_AsyncTaskManager_get_num_task_chains_95, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_num_task_chains_95_comment},
  {"get_task_chain", &Dtool_AsyncTaskManager_get_task_chain_96, METH_O, (const char *)Dtool_AsyncTaskManager_get_task_chain_96_comment},
  {"getTaskChain", &Dtool_AsyncTaskManager_get_task_chain_96, METH_O, (const char *)Dtool_AsyncTaskManager_get_task_chain_96_comment},
  {"make_task_chain", &Dtool_AsyncTaskManager_make_task_chain_98, METH_O, (const char *)Dtool_AsyncTaskManager_make_task_chain_98_comment},
  {"makeTaskChain", &Dtool_AsyncTaskManager_make_task_chain_98, METH_O, (const char *)Dtool_AsyncTaskManager_make_task_chain_98_comment},
  {"find_task_chain", &Dtool_AsyncTaskManager_find_task_chain_99, METH_O, (const char *)Dtool_AsyncTaskManager_find_task_chain_99_comment},
  {"findTaskChain", &Dtool_AsyncTaskManager_find_task_chain_99, METH_O, (const char *)Dtool_AsyncTaskManager_find_task_chain_99_comment},
  {"remove_task_chain", &Dtool_AsyncTaskManager_remove_task_chain_100, METH_O, (const char *)Dtool_AsyncTaskManager_remove_task_chain_100_comment},
  {"removeTaskChain", &Dtool_AsyncTaskManager_remove_task_chain_100, METH_O, (const char *)Dtool_AsyncTaskManager_remove_task_chain_100_comment},
  {"add", &Dtool_AsyncTaskManager_add_101, METH_O, (const char *)Dtool_AsyncTaskManager_add_101_comment},
  {"has_task", &Dtool_AsyncTaskManager_has_task_102, METH_O, (const char *)Dtool_AsyncTaskManager_has_task_102_comment},
  {"hasTask", &Dtool_AsyncTaskManager_has_task_102, METH_O, (const char *)Dtool_AsyncTaskManager_has_task_102_comment},
  {"find_task", &Dtool_AsyncTaskManager_find_task_103, METH_O, (const char *)Dtool_AsyncTaskManager_find_task_103_comment},
  {"findTask", &Dtool_AsyncTaskManager_find_task_103, METH_O, (const char *)Dtool_AsyncTaskManager_find_task_103_comment},
  {"find_tasks", &Dtool_AsyncTaskManager_find_tasks_104, METH_O, (const char *)Dtool_AsyncTaskManager_find_tasks_104_comment},
  {"findTasks", &Dtool_AsyncTaskManager_find_tasks_104, METH_O, (const char *)Dtool_AsyncTaskManager_find_tasks_104_comment},
  {"find_tasks_matching", &Dtool_AsyncTaskManager_find_tasks_matching_105, METH_O, (const char *)Dtool_AsyncTaskManager_find_tasks_matching_105_comment},
  {"findTasksMatching", &Dtool_AsyncTaskManager_find_tasks_matching_105, METH_O, (const char *)Dtool_AsyncTaskManager_find_tasks_matching_105_comment},
  {"remove", &Dtool_AsyncTaskManager_remove_106, METH_O, (const char *)Dtool_AsyncTaskManager_remove_106_comment},
  {"wait_for_tasks", &Dtool_AsyncTaskManager_wait_for_tasks_107, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_wait_for_tasks_107_comment},
  {"waitForTasks", &Dtool_AsyncTaskManager_wait_for_tasks_107, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_wait_for_tasks_107_comment},
  {"stop_threads", &Dtool_AsyncTaskManager_stop_threads_108, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_stop_threads_108_comment},
  {"stopThreads", &Dtool_AsyncTaskManager_stop_threads_108, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_stop_threads_108_comment},
  {"start_threads", &Dtool_AsyncTaskManager_start_threads_109, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_start_threads_109_comment},
  {"startThreads", &Dtool_AsyncTaskManager_start_threads_109, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_start_threads_109_comment},
  {"get_num_tasks", &Dtool_AsyncTaskManager_get_num_tasks_110, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_num_tasks_110_comment},
  {"getNumTasks", &Dtool_AsyncTaskManager_get_num_tasks_110, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_num_tasks_110_comment},
  {"get_tasks", &Dtool_AsyncTaskManager_get_tasks_111, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_tasks_111_comment},
  {"getTasks", &Dtool_AsyncTaskManager_get_tasks_111, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_tasks_111_comment},
  {"get_active_tasks", &Dtool_AsyncTaskManager_get_active_tasks_112, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_active_tasks_112_comment},
  {"getActiveTasks", &Dtool_AsyncTaskManager_get_active_tasks_112, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_active_tasks_112_comment},
  {"get_sleeping_tasks", &Dtool_AsyncTaskManager_get_sleeping_tasks_113, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_sleeping_tasks_113_comment},
  {"getSleepingTasks", &Dtool_AsyncTaskManager_get_sleeping_tasks_113, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_sleeping_tasks_113_comment},
  {"poll", &Dtool_AsyncTaskManager_poll_138, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_poll_138_comment},
  {"get_next_wake_time", &Dtool_AsyncTaskManager_get_next_wake_time_139, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_next_wake_time_139_comment},
  {"getNextWakeTime", &Dtool_AsyncTaskManager_get_next_wake_time_139, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_get_next_wake_time_139_comment},
  {"output", &Dtool_AsyncTaskManager_output_142, METH_O, (const char *)Dtool_AsyncTaskManager_output_142_comment},
  {"write", (PyCFunction) &Dtool_AsyncTaskManager_write_143, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AsyncTaskManager_write_143_comment},
  {"get_global_ptr", &Dtool_AsyncTaskManager_get_global_ptr_144, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskManager_get_global_ptr_144_comment},
  {"getGlobalPtr", &Dtool_AsyncTaskManager_get_global_ptr_144, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskManager_get_global_ptr_144_comment},
  {"get_class_type", &Dtool_AsyncTaskManager_get_class_type_145, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskManager_get_class_type_145_comment},
  {"getClassType", &Dtool_AsyncTaskManager_get_class_type_145, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskManager_get_class_type_145_comment},
  {"upcast_to_TypedReferenceCount", &Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_83, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_83_comment},
  {"upcastToTypedReferenceCount", &Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_83, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_upcast_to_TypedReferenceCount_83_comment},
  {"upcast_to_Namable", &Dtool_AsyncTaskManager_upcast_to_Namable_85, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_upcast_to_Namable_85_comment},
  {"upcastToNamable", &Dtool_AsyncTaskManager_upcast_to_Namable_85, METH_NOARGS, (const char *)Dtool_AsyncTaskManager_upcast_to_Namable_85_comment},
  {"get_task_chains", (PyCFunction) &MakeSeq_AsyncTaskManager_get_task_chains, METH_NOARGS, nullptr},
  { "getTaskChains", (PyCFunction) &MakeSeq_AsyncTaskManager_get_task_chains, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     AsyncTaskManager
//////////////////
static PyObject *Dtool_Repr_AsyncTaskManager(PyObject *self) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AsyncTaskManager
//////////////////
static PyObject *Dtool_Str_AsyncTaskManager(PyObject *self) {
  AsyncTaskManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskManager, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_AsyncTaskManager[] = {
  {(char *)"clock", &Dtool_AsyncTaskManager_clock_Getter, &Dtool_AsyncTaskManager_clock_Setter, nullptr, nullptr},
  {(char *)"tasks", &Dtool_AsyncTaskManager_tasks_Getter, nullptr, nullptr, nullptr},
  {(char *)"active_tasks", &Dtool_AsyncTaskManager_active_tasks_Getter, nullptr, nullptr, nullptr},
  {(char *)"sleeping_tasks", &Dtool_AsyncTaskManager_sleeping_tasks_Getter, nullptr, nullptr, nullptr},
  {(char *)"next_wake_time", &Dtool_AsyncTaskManager_next_wake_time_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_AsyncTaskManager = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AsyncTaskManager = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AsyncTaskManager = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AsyncTaskManager = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AsyncTaskManager = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AsyncTaskManager = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AsyncTaskManager",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AsyncTaskManager,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AsyncTaskManager,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_AsyncTaskManager,
    &Dtool_NumberMethods_AsyncTaskManager,
    &Dtool_SequenceMethods_AsyncTaskManager,
    &Dtool_MappingMethods_AsyncTaskManager,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_AsyncTaskManager,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AsyncTaskManager,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class to manage a loose queue of isolated tasks, which can be performed\n"
    " * either synchronously (in the foreground thread) or asynchronously (by a\n"
    " * background thread).\n"
    " *\n"
    " * The AsyncTaskManager is actually a collection of AsyncTaskChains, each of\n"
    " * which maintains a list of tasks.  Each chain can be either foreground or\n"
    " * background (it may run only in the main thread, or it may be serviced by\n"
    " * one or more background threads). See AsyncTaskChain for more information.\n"
    " *\n"
    " * If you do not require background processing, it is perfectly acceptable to\n"
    " * create only one AsyncTaskChain, which runs in the main thread.  This is a\n"
    " * common configuration.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AsyncTaskManager,
    nullptr, // tp_members
    Dtool_Properties_AsyncTaskManager,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AsyncTaskManager,
    PyType_GenericAlloc,
    Dtool_new_AsyncTaskManager,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AsyncTaskManager,
  Dtool_UpcastInterface_AsyncTaskManager,
  Dtool_DowncastInterface_AsyncTaskManager,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AsyncTaskManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_AsyncTaskManager._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_AsyncTaskManager._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AsyncTaskManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AsyncTaskManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AsyncTaskManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AsyncTaskManager);
  }
}

/**
 * Python method tables for AsyncTaskCollection (AsyncTaskCollection)
 */
static PyMethodDef Dtool_Methods_AsyncTaskCollection[] = {
  {"assign", &Dtool_AsyncTaskCollection_operator_117, METH_O, (const char *)Dtool_AsyncTaskCollection_operator_117_comment},
  {"add_task", &Dtool_AsyncTaskCollection_add_task_119, METH_O, (const char *)Dtool_AsyncTaskCollection_add_task_119_comment},
  {"addTask", &Dtool_AsyncTaskCollection_add_task_119, METH_O, (const char *)Dtool_AsyncTaskCollection_add_task_119_comment},
  {"remove_task", &Dtool_AsyncTaskCollection_remove_task_120, METH_O, (const char *)Dtool_AsyncTaskCollection_remove_task_120_comment},
  {"removeTask", &Dtool_AsyncTaskCollection_remove_task_120, METH_O, (const char *)Dtool_AsyncTaskCollection_remove_task_120_comment},
  {"add_tasks_from", &Dtool_AsyncTaskCollection_add_tasks_from_121, METH_O, (const char *)Dtool_AsyncTaskCollection_add_tasks_from_121_comment},
  {"addTasksFrom", &Dtool_AsyncTaskCollection_add_tasks_from_121, METH_O, (const char *)Dtool_AsyncTaskCollection_add_tasks_from_121_comment},
  {"remove_tasks_from", &Dtool_AsyncTaskCollection_remove_tasks_from_122, METH_O, (const char *)Dtool_AsyncTaskCollection_remove_tasks_from_122_comment},
  {"removeTasksFrom", &Dtool_AsyncTaskCollection_remove_tasks_from_122, METH_O, (const char *)Dtool_AsyncTaskCollection_remove_tasks_from_122_comment},
  {"remove_duplicate_tasks", &Dtool_AsyncTaskCollection_remove_duplicate_tasks_123, METH_NOARGS, (const char *)Dtool_AsyncTaskCollection_remove_duplicate_tasks_123_comment},
  {"removeDuplicateTasks", &Dtool_AsyncTaskCollection_remove_duplicate_tasks_123, METH_NOARGS, (const char *)Dtool_AsyncTaskCollection_remove_duplicate_tasks_123_comment},
  {"has_task", &Dtool_AsyncTaskCollection_has_task_124, METH_O, (const char *)Dtool_AsyncTaskCollection_has_task_124_comment},
  {"hasTask", &Dtool_AsyncTaskCollection_has_task_124, METH_O, (const char *)Dtool_AsyncTaskCollection_has_task_124_comment},
  {"clear", &Dtool_AsyncTaskCollection_clear_125, METH_NOARGS, (const char *)Dtool_AsyncTaskCollection_clear_125_comment},
  {"find_task", &Dtool_AsyncTaskCollection_find_task_126, METH_O, (const char *)Dtool_AsyncTaskCollection_find_task_126_comment},
  {"findTask", &Dtool_AsyncTaskCollection_find_task_126, METH_O, (const char *)Dtool_AsyncTaskCollection_find_task_126_comment},
  {"get_num_tasks", &Dtool_AsyncTaskCollection_get_num_tasks_127, METH_NOARGS, (const char *)Dtool_AsyncTaskCollection_get_num_tasks_127_comment},
  {"getNumTasks", &Dtool_AsyncTaskCollection_get_num_tasks_127, METH_NOARGS, (const char *)Dtool_AsyncTaskCollection_get_num_tasks_127_comment},
  {"get_task", &Dtool_AsyncTaskCollection_get_task_128, METH_O, (const char *)Dtool_AsyncTaskCollection_get_task_128_comment},
  {"getTask", &Dtool_AsyncTaskCollection_get_task_128, METH_O, (const char *)Dtool_AsyncTaskCollection_get_task_128_comment},
  {"output", &Dtool_AsyncTaskCollection_output_134, METH_O, (const char *)Dtool_AsyncTaskCollection_output_134_comment},
  {"write", (PyCFunction) &Dtool_AsyncTaskCollection_write_135, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AsyncTaskCollection_write_135_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_tasks", (PyCFunction) &MakeSeq_AsyncTaskCollection_get_tasks, METH_NOARGS, nullptr},
  { "getTasks", (PyCFunction) &MakeSeq_AsyncTaskCollection_get_tasks, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// AsyncTaskCollection slot nb_add -> operator +
//////////////////
static PyObject *Dtool_AsyncTaskCollection_operator_133_nb_add(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_AsyncTaskCollection, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline AsyncTaskCollection AsyncTaskCollection::operator +(AsyncTaskCollection const &other) const
  AsyncTaskCollection const *arg_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTaskCollection, 1, "AsyncTaskCollection.__add__", true, true);
  if (arg_this != nullptr) {
    AsyncTaskCollection *return_value = new AsyncTaskCollection(((*(const AsyncTaskCollection*)local_this).operator +)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AsyncTaskCollection, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// AsyncTaskCollection slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_AsyncTaskCollection_operator_132_nb_inplace_add(PyObject *self, PyObject *arg) {
  AsyncTaskCollection *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_AsyncTaskCollection, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void AsyncTaskCollection::operator +=(AsyncTaskCollection const &other)
  AsyncTaskCollection const *arg_this = (AsyncTaskCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AsyncTaskCollection, 1, "AsyncTaskCollection.__iadd__", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator +=)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// AsyncTaskCollection slot sq_item -> operator []
//////////////////
static PyObject *Dtool_AsyncTaskCollection_operator_130_sq_item(PyObject *self, Py_ssize_t index) {
  AsyncTaskCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskCollection, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "AsyncTaskCollection index out of range");
    return nullptr;
  }
  // 1-AsyncTask *AsyncTaskCollection::operator [](std::size_t index) const
  AsyncTask *return_value = ((*(const AsyncTaskCollection*)local_this).operator [])(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncTask, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(AsyncTaskCollection self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// AsyncTaskCollection slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_AsyncTaskCollection_size_131_sq_length(PyObject *self) {
  AsyncTaskCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskCollection, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
//  A __repr__ function
//     AsyncTaskCollection
//////////////////
static PyObject *Dtool_Repr_AsyncTaskCollection(PyObject *self) {
  AsyncTaskCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AsyncTaskCollection
//////////////////
static PyObject *Dtool_Str_AsyncTaskCollection(PyObject *self) {
  AsyncTaskCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AsyncTaskCollection = {
  &Dtool_AsyncTaskCollection_operator_133_nb_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  &Dtool_AsyncTaskCollection_operator_132_nb_inplace_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AsyncTaskCollection = {
  &Dtool_AsyncTaskCollection_size_131_sq_length,
  nullptr,
  nullptr,
  &Dtool_AsyncTaskCollection_operator_130_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_AsyncTaskCollection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AsyncTaskCollection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AsyncTaskCollection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_AsyncTaskCollection,
    &Dtool_NumberMethods_AsyncTaskCollection,
    &Dtool_SequenceMethods_AsyncTaskCollection,
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_AsyncTaskCollection,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A list of tasks, for instance as returned by some of the AsyncTaskManager\n"
    " * query functions.  This also serves to define an AsyncTaskSequence.\n"
    " *\n"
    " * TODO: None of this is thread-safe yet.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AsyncTaskCollection,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AsyncTaskCollection,
    PyType_GenericAlloc,
    Dtool_new_AsyncTaskCollection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AsyncTaskCollection,
  Dtool_UpcastInterface_AsyncTaskCollection,
  Dtool_DowncastInterface_AsyncTaskCollection,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AsyncTaskCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_AsyncTaskCollection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AsyncTaskCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AsyncTaskCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AsyncTaskCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AsyncTaskCollection);
  }
}

/**
 * Python method tables for AsyncTaskChain (AsyncTaskChain)
 */
static PyMethodDef Dtool_Methods_AsyncTaskChain[] = {
  {"set_tick_clock", &Dtool_AsyncTaskChain_set_tick_clock_169, METH_O, (const char *)Dtool_AsyncTaskChain_set_tick_clock_169_comment},
  {"setTickClock", &Dtool_AsyncTaskChain_set_tick_clock_169, METH_O, (const char *)Dtool_AsyncTaskChain_set_tick_clock_169_comment},
  {"get_tick_clock", &Dtool_AsyncTaskChain_get_tick_clock_170, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_tick_clock_170_comment},
  {"getTickClock", &Dtool_AsyncTaskChain_get_tick_clock_170, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_tick_clock_170_comment},
  {"set_num_threads", &Dtool_AsyncTaskChain_set_num_threads_171, METH_O, (const char *)Dtool_AsyncTaskChain_set_num_threads_171_comment},
  {"setNumThreads", &Dtool_AsyncTaskChain_set_num_threads_171, METH_O, (const char *)Dtool_AsyncTaskChain_set_num_threads_171_comment},
  {"get_num_threads", &Dtool_AsyncTaskChain_get_num_threads_172, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_num_threads_172_comment},
  {"getNumThreads", &Dtool_AsyncTaskChain_get_num_threads_172, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_num_threads_172_comment},
  {"get_num_running_threads", &Dtool_AsyncTaskChain_get_num_running_threads_173, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_num_running_threads_173_comment},
  {"getNumRunningThreads", &Dtool_AsyncTaskChain_get_num_running_threads_173, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_num_running_threads_173_comment},
  {"set_thread_priority", &Dtool_AsyncTaskChain_set_thread_priority_174, METH_O, (const char *)Dtool_AsyncTaskChain_set_thread_priority_174_comment},
  {"setThreadPriority", &Dtool_AsyncTaskChain_set_thread_priority_174, METH_O, (const char *)Dtool_AsyncTaskChain_set_thread_priority_174_comment},
  {"get_thread_priority", &Dtool_AsyncTaskChain_get_thread_priority_175, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_thread_priority_175_comment},
  {"getThreadPriority", &Dtool_AsyncTaskChain_get_thread_priority_175, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_thread_priority_175_comment},
  {"set_frame_budget", &Dtool_AsyncTaskChain_set_frame_budget_176, METH_O, (const char *)Dtool_AsyncTaskChain_set_frame_budget_176_comment},
  {"setFrameBudget", &Dtool_AsyncTaskChain_set_frame_budget_176, METH_O, (const char *)Dtool_AsyncTaskChain_set_frame_budget_176_comment},
  {"get_frame_budget", &Dtool_AsyncTaskChain_get_frame_budget_177, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_frame_budget_177_comment},
  {"getFrameBudget", &Dtool_AsyncTaskChain_get_frame_budget_177, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_frame_budget_177_comment},
  {"set_frame_sync", &Dtool_AsyncTaskChain_set_frame_sync_178, METH_O, (const char *)Dtool_AsyncTaskChain_set_frame_sync_178_comment},
  {"setFrameSync", &Dtool_AsyncTaskChain_set_frame_sync_178, METH_O, (const char *)Dtool_AsyncTaskChain_set_frame_sync_178_comment},
  {"get_frame_sync", &Dtool_AsyncTaskChain_get_frame_sync_179, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_frame_sync_179_comment},
  {"getFrameSync", &Dtool_AsyncTaskChain_get_frame_sync_179, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_frame_sync_179_comment},
  {"set_timeslice_priority", &Dtool_AsyncTaskChain_set_timeslice_priority_180, METH_O, (const char *)Dtool_AsyncTaskChain_set_timeslice_priority_180_comment},
  {"setTimeslicePriority", &Dtool_AsyncTaskChain_set_timeslice_priority_180, METH_O, (const char *)Dtool_AsyncTaskChain_set_timeslice_priority_180_comment},
  {"get_timeslice_priority", &Dtool_AsyncTaskChain_get_timeslice_priority_181, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_timeslice_priority_181_comment},
  {"getTimeslicePriority", &Dtool_AsyncTaskChain_get_timeslice_priority_181, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_timeslice_priority_181_comment},
  {"stop_threads", &Dtool_AsyncTaskChain_stop_threads_182, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_stop_threads_182_comment},
  {"stopThreads", &Dtool_AsyncTaskChain_stop_threads_182, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_stop_threads_182_comment},
  {"start_threads", &Dtool_AsyncTaskChain_start_threads_183, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_start_threads_183_comment},
  {"startThreads", &Dtool_AsyncTaskChain_start_threads_183, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_start_threads_183_comment},
  {"is_started", &Dtool_AsyncTaskChain_is_started_184, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_is_started_184_comment},
  {"isStarted", &Dtool_AsyncTaskChain_is_started_184, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_is_started_184_comment},
  {"has_task", &Dtool_AsyncTaskChain_has_task_185, METH_O, (const char *)Dtool_AsyncTaskChain_has_task_185_comment},
  {"hasTask", &Dtool_AsyncTaskChain_has_task_185, METH_O, (const char *)Dtool_AsyncTaskChain_has_task_185_comment},
  {"wait_for_tasks", &Dtool_AsyncTaskChain_wait_for_tasks_186, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_wait_for_tasks_186_comment},
  {"waitForTasks", &Dtool_AsyncTaskChain_wait_for_tasks_186, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_wait_for_tasks_186_comment},
  {"get_num_tasks", &Dtool_AsyncTaskChain_get_num_tasks_187, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_num_tasks_187_comment},
  {"getNumTasks", &Dtool_AsyncTaskChain_get_num_tasks_187, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_num_tasks_187_comment},
  {"get_tasks", &Dtool_AsyncTaskChain_get_tasks_188, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_tasks_188_comment},
  {"getTasks", &Dtool_AsyncTaskChain_get_tasks_188, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_tasks_188_comment},
  {"get_active_tasks", &Dtool_AsyncTaskChain_get_active_tasks_189, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_active_tasks_189_comment},
  {"getActiveTasks", &Dtool_AsyncTaskChain_get_active_tasks_189, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_active_tasks_189_comment},
  {"get_sleeping_tasks", &Dtool_AsyncTaskChain_get_sleeping_tasks_190, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_sleeping_tasks_190_comment},
  {"getSleepingTasks", &Dtool_AsyncTaskChain_get_sleeping_tasks_190, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_sleeping_tasks_190_comment},
  {"poll", &Dtool_AsyncTaskChain_poll_191, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_poll_191_comment},
  {"get_next_wake_time", &Dtool_AsyncTaskChain_get_next_wake_time_192, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_next_wake_time_192_comment},
  {"getNextWakeTime", &Dtool_AsyncTaskChain_get_next_wake_time_192, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_get_next_wake_time_192_comment},
  {"output", &Dtool_AsyncTaskChain_output_193, METH_O, (const char *)Dtool_AsyncTaskChain_output_193_comment},
  {"write", (PyCFunction) &Dtool_AsyncTaskChain_write_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AsyncTaskChain_write_194_comment},
  {"get_class_type", &Dtool_AsyncTaskChain_get_class_type_195, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskChain_get_class_type_195_comment},
  {"getClassType", &Dtool_AsyncTaskChain_get_class_type_195, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskChain_get_class_type_195_comment},
  {"upcast_to_TypedReferenceCount", &Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_164, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_164_comment},
  {"upcastToTypedReferenceCount", &Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_164, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_upcast_to_TypedReferenceCount_164_comment},
  {"upcast_to_Namable", &Dtool_AsyncTaskChain_upcast_to_Namable_166, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_upcast_to_Namable_166_comment},
  {"upcastToNamable", &Dtool_AsyncTaskChain_upcast_to_Namable_166, METH_NOARGS, (const char *)Dtool_AsyncTaskChain_upcast_to_Namable_166_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     AsyncTaskChain
//////////////////
static PyObject *Dtool_Repr_AsyncTaskChain(PyObject *self) {
  AsyncTaskChain *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AsyncTaskChain
//////////////////
static PyObject *Dtool_Str_AsyncTaskChain(PyObject *self) {
  AsyncTaskChain *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AsyncTaskChain, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AsyncTaskChain = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AsyncTaskChain = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AsyncTaskChain = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AsyncTaskChain = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AsyncTaskChain = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AsyncTaskChain = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AsyncTaskChain",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AsyncTaskChain,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AsyncTaskChain,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_AsyncTaskChain,
    &Dtool_NumberMethods_AsyncTaskChain,
    &Dtool_SequenceMethods_AsyncTaskChain,
    &Dtool_MappingMethods_AsyncTaskChain,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_AsyncTaskChain,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AsyncTaskChain,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The AsyncTaskChain is a subset of the AsyncTaskManager.  Each chain\n"
    " * maintains a separate list of tasks, and will execute them with its own set\n"
    " * of threads.  Each chain may thereby operate independently of the other\n"
    " * chains.\n"
    " *\n"
    " * The AsyncTaskChain will spawn a specified number of threads (possibly 0) to\n"
    " * serve the tasks.  If there are no threads, you must call poll() from time\n"
    " * to time to serve the tasks in the main thread.  Normally this is done by\n"
    " * calling AsyncTaskManager::poll().\n"
    " *\n"
    " * Each task will run exactly once each epoch.  Beyond that, the tasks' sort\n"
    " * and priority values control the order in which they are run: tasks are run\n"
    " * in increasing order by sort value, and within the same sort value, they are\n"
    " * run roughly in decreasing order by priority value, with some exceptions for\n"
    " * parallelism.  Tasks with different sort values are never run in parallel\n"
    " * together, but tasks with different priority values might be (if there is\n"
    " * more than one thread).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AsyncTaskChain,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AsyncTaskChain,
    PyType_GenericAlloc,
    Dtool_new_AsyncTaskChain,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AsyncTaskChain,
  Dtool_UpcastInterface_AsyncTaskChain,
  Dtool_DowncastInterface_AsyncTaskChain,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AsyncTaskChain(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_AsyncTaskChain._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_AsyncTaskChain._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AsyncTaskChain._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AsyncTaskChain) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AsyncTaskChain)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AsyncTaskChain);
  }
}

/**
 * Python method tables for AsyncTaskPause (AsyncTaskPause)
 */
static PyMethodDef Dtool_Methods_AsyncTaskPause[] = {
  {"get_class_type", &Dtool_AsyncTaskPause_get_class_type_201, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskPause_get_class_type_201_comment},
  {"getClassType", &Dtool_AsyncTaskPause_get_class_type_201, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskPause_get_class_type_201_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AsyncTaskPause = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AsyncTaskPause = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AsyncTaskPause = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AsyncTaskPause = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AsyncTaskPause = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AsyncTaskPause = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AsyncTaskPause",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AsyncTaskPause,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AsyncTaskPause,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AsyncTaskPause,
    &Dtool_SequenceMethods_AsyncTaskPause,
    &Dtool_MappingMethods_AsyncTaskPause,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AsyncTaskPause,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A special kind of task that simple returns DS_pause, to pause for a\n"
    " * specified number of seconds and then finish.  It's intended to be used\n"
    " * within an AsyncTaskSequence.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AsyncTaskPause,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AsyncTaskPause,
    PyType_GenericAlloc,
    Dtool_new_AsyncTaskPause,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AsyncTaskPause,
  Dtool_UpcastInterface_AsyncTaskPause,
  Dtool_DowncastInterface_AsyncTaskPause,
  (CoerceFunction)Dtool_ConstCoerce_AsyncTaskPause,
  (CoerceFunction)Dtool_Coerce_AsyncTaskPause,
};

static void Dtool_PyModuleClassInit_AsyncTaskPause(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AsyncTask(nullptr);
    Dtool_AsyncTaskPause._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AsyncTask);
    Dtool_AsyncTaskPause._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AsyncTaskPause._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AsyncTaskPause) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AsyncTaskPause)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AsyncTaskPause);
  }
}

/**
 * Python method tables for AsyncTaskSequence (AsyncTaskSequence)
 */
static PyMethodDef Dtool_Methods_AsyncTaskSequence[] = {
  {"set_repeat_count", &Dtool_AsyncTaskSequence_set_repeat_count_213, METH_O, (const char *)Dtool_AsyncTaskSequence_set_repeat_count_213_comment},
  {"setRepeatCount", &Dtool_AsyncTaskSequence_set_repeat_count_213, METH_O, (const char *)Dtool_AsyncTaskSequence_set_repeat_count_213_comment},
  {"get_repeat_count", &Dtool_AsyncTaskSequence_get_repeat_count_214, METH_NOARGS, (const char *)Dtool_AsyncTaskSequence_get_repeat_count_214_comment},
  {"getRepeatCount", &Dtool_AsyncTaskSequence_get_repeat_count_214, METH_NOARGS, (const char *)Dtool_AsyncTaskSequence_get_repeat_count_214_comment},
  {"get_current_task_index", &Dtool_AsyncTaskSequence_get_current_task_index_215, METH_NOARGS, (const char *)Dtool_AsyncTaskSequence_get_current_task_index_215_comment},
  {"getCurrentTaskIndex", &Dtool_AsyncTaskSequence_get_current_task_index_215, METH_NOARGS, (const char *)Dtool_AsyncTaskSequence_get_current_task_index_215_comment},
  {"get_class_type", &Dtool_AsyncTaskSequence_get_class_type_216, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskSequence_get_class_type_216_comment},
  {"getClassType", &Dtool_AsyncTaskSequence_get_class_type_216, METH_NOARGS | METH_STATIC, (const char *)Dtool_AsyncTaskSequence_get_class_type_216_comment},
  {"upcast_to_AsyncTask", &Dtool_AsyncTaskSequence_upcast_to_AsyncTask_204, METH_NOARGS, (const char *)Dtool_AsyncTaskSequence_upcast_to_AsyncTask_204_comment},
  {"upcastToAsyncTask", &Dtool_AsyncTaskSequence_upcast_to_AsyncTask_204, METH_NOARGS, (const char *)Dtool_AsyncTaskSequence_upcast_to_AsyncTask_204_comment},
  {"upcast_to_AsyncTaskCollection", &Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_206, METH_NOARGS, (const char *)Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_206_comment},
  {"upcastToAsyncTaskCollection", &Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_206, METH_NOARGS, (const char *)Dtool_AsyncTaskSequence_upcast_to_AsyncTaskCollection_206_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AsyncTaskSequence = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AsyncTaskSequence = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AsyncTaskSequence = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AsyncTaskSequence = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AsyncTaskSequence = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AsyncTaskSequence = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AsyncTaskSequence",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AsyncTaskSequence,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AsyncTaskSequence,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AsyncTaskSequence,
    &Dtool_SequenceMethods_AsyncTaskSequence,
    &Dtool_MappingMethods_AsyncTaskSequence,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AsyncTaskSequence,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A special kind of task that serves as a list of tasks internally.  Each\n"
    " * task on the list is executed in sequence, one per epoch.\n"
    " *\n"
    " * This is similar to a Sequence interval, though it has some slightly\n"
    " * different abilities.  For instance, although you can't start at any\n"
    " * arbitrary point in the sequence, you can construct a task sequence whose\n"
    " * duration changes during playback.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AsyncTaskSequence,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AsyncTaskSequence,
    PyType_GenericAlloc,
    Dtool_new_AsyncTaskSequence,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AsyncTaskSequence,
  Dtool_UpcastInterface_AsyncTaskSequence,
  Dtool_DowncastInterface_AsyncTaskSequence,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AsyncTaskSequence(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AsyncTask(nullptr);
    Dtool_PyModuleClassInit_AsyncTaskCollection(nullptr);
    Dtool_AsyncTaskSequence._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_AsyncTask, (PyTypeObject *)&Dtool_AsyncTaskCollection);
    Dtool_AsyncTaskSequence._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AsyncTaskSequence._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AsyncTaskSequence) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AsyncTaskSequence)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AsyncTaskSequence);
  }
}

/**
 * Python method tables for ButtonEventList (ButtonEventList)
 */
static PyMethodDef Dtool_Methods_ButtonEventList[] = {
  {"assign", &Dtool_ButtonEventList_operator_220, METH_O, (const char *)Dtool_ButtonEventList_operator_220_comment},
  {"get_num_events", &Dtool_ButtonEventList_get_num_events_222, METH_NOARGS, (const char *)Dtool_ButtonEventList_get_num_events_222_comment},
  {"getNumEvents", &Dtool_ButtonEventList_get_num_events_222, METH_NOARGS, (const char *)Dtool_ButtonEventList_get_num_events_222_comment},
  {"clear", &Dtool_ButtonEventList_clear_224, METH_NOARGS, (const char *)Dtool_ButtonEventList_clear_224_comment},
  {"add_events", &Dtool_ButtonEventList_add_events_225, METH_O, (const char *)Dtool_ButtonEventList_add_events_225_comment},
  {"addEvents", &Dtool_ButtonEventList_add_events_225, METH_O, (const char *)Dtool_ButtonEventList_add_events_225_comment},
  {"update_mods", &Dtool_ButtonEventList_update_mods_226, METH_O, (const char *)Dtool_ButtonEventList_update_mods_226_comment},
  {"updateMods", &Dtool_ButtonEventList_update_mods_226, METH_O, (const char *)Dtool_ButtonEventList_update_mods_226_comment},
  {"write", (PyCFunction) &Dtool_ButtonEventList_write_227, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ButtonEventList_write_227_comment},
  {"get_class_type", &Dtool_ButtonEventList_get_class_type_228, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonEventList_get_class_type_228_comment},
  {"getClassType", &Dtool_ButtonEventList_get_class_type_228, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonEventList_get_class_type_228_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     ButtonEventList
//////////////////
static PyObject *Dtool_Str_ButtonEventList(PyObject *self) {
  ButtonEventList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonEventList, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ButtonEventList = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ButtonEventList = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ButtonEventList = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ButtonEventList = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ButtonEventList = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ButtonEventList = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ButtonEventList",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ButtonEventList,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ButtonEventList,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ButtonEventList,
    &Dtool_SequenceMethods_ButtonEventList,
    &Dtool_MappingMethods_ButtonEventList,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_ButtonEventList,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ButtonEventList,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Records a set of button events that happened recently.  This class is\n"
    " * usually used only in the data graph, to transmit the recent button presses,\n"
    " * but it may be used anywhere a list of ButtonEvents is desired.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ButtonEventList,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ButtonEventList,
    PyType_GenericAlloc,
    Dtool_new_ButtonEventList,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ButtonEventList,
  Dtool_UpcastInterface_ButtonEventList,
  Dtool_DowncastInterface_ButtonEventList,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ButtonEventList(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ParamValueBase != nullptr);
    assert(Dtool_Ptr_ParamValueBase->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ParamValueBase->_Dtool_ModuleClassInit(nullptr);
    Dtool_ButtonEventList._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ParamValueBase);
    Dtool_ButtonEventList._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ButtonEventList._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ButtonEventList) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ButtonEventList)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ButtonEventList);
  }
}

/**
 * Python method tables for Event (Event)
 */
static PyMethodDef Dtool_Methods_Event[] = {
  {"assign", &Dtool_Event_operator_232, METH_O, (const char *)Dtool_Event_operator_232_comment},
  {"set_name", &Dtool_Event_set_name_233, METH_O, (const char *)Dtool_Event_set_name_233_comment},
  {"setName", &Dtool_Event_set_name_233, METH_O, (const char *)Dtool_Event_set_name_233_comment},
  {"clear_name", &Dtool_Event_clear_name_234, METH_NOARGS, (const char *)Dtool_Event_clear_name_234_comment},
  {"clearName", &Dtool_Event_clear_name_234, METH_NOARGS, (const char *)Dtool_Event_clear_name_234_comment},
  {"has_name", &Dtool_Event_has_name_235, METH_NOARGS, (const char *)Dtool_Event_has_name_235_comment},
  {"hasName", &Dtool_Event_has_name_235, METH_NOARGS, (const char *)Dtool_Event_has_name_235_comment},
  {"get_name", &Dtool_Event_get_name_236, METH_NOARGS, (const char *)Dtool_Event_get_name_236_comment},
  {"getName", &Dtool_Event_get_name_236, METH_NOARGS, (const char *)Dtool_Event_get_name_236_comment},
  {"add_parameter", &Dtool_Event_add_parameter_237, METH_O, (const char *)Dtool_Event_add_parameter_237_comment},
  {"addParameter", &Dtool_Event_add_parameter_237, METH_O, (const char *)Dtool_Event_add_parameter_237_comment},
  {"get_num_parameters", &Dtool_Event_get_num_parameters_238, METH_NOARGS, (const char *)Dtool_Event_get_num_parameters_238_comment},
  {"getNumParameters", &Dtool_Event_get_num_parameters_238, METH_NOARGS, (const char *)Dtool_Event_get_num_parameters_238_comment},
  {"get_parameter", &Dtool_Event_get_parameter_239, METH_O, (const char *)Dtool_Event_get_parameter_239_comment},
  {"getParameter", &Dtool_Event_get_parameter_239, METH_O, (const char *)Dtool_Event_get_parameter_239_comment},
  {"has_receiver", &Dtool_Event_has_receiver_241, METH_NOARGS, (const char *)Dtool_Event_has_receiver_241_comment},
  {"hasReceiver", &Dtool_Event_has_receiver_241, METH_NOARGS, (const char *)Dtool_Event_has_receiver_241_comment},
  {"clear_receiver", &Dtool_Event_clear_receiver_244, METH_NOARGS, (const char *)Dtool_Event_clear_receiver_244_comment},
  {"clearReceiver", &Dtool_Event_clear_receiver_244, METH_NOARGS, (const char *)Dtool_Event_clear_receiver_244_comment},
  {"output", &Dtool_Event_output_245, METH_O, (const char *)Dtool_Event_output_245_comment},
  {"get_class_type", &Dtool_Event_get_class_type_251, METH_NOARGS | METH_STATIC, (const char *)Dtool_Event_get_class_type_251_comment},
  {"getClassType", &Dtool_Event_get_class_type_251, METH_NOARGS | METH_STATIC, (const char *)Dtool_Event_get_class_type_251_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_parameters", (PyCFunction) &MakeSeq_Event_get_parameters, METH_NOARGS, nullptr},
  { "getParameters", (PyCFunction) &MakeSeq_Event_get_parameters, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     Event
//////////////////
static PyObject *Dtool_Repr_Event(PyObject *self) {
  Event *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Event, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_Event[] = {
  {(char *)"name", &Dtool_Event_name_Getter, &Dtool_Event_name_Setter, nullptr, nullptr},
  {(char *)"parameters", &Dtool_Event_parameters_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_Event = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Event = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Event = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Event = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Event = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Event = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Event",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Event,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Event,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_Event,
    &Dtool_NumberMethods_Event,
    &Dtool_SequenceMethods_Event,
    &Dtool_MappingMethods_Event,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_Event,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Event,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A named event, possibly with parameters.  Anyone in any thread may throw an\n"
    " * event at any time; there will be one process responsible for reading and\n"
    " * dispacting on the events (but not necessarily immediately).\n"
    " *\n"
    " * This function use to inherit from Namable, but that makes it too expensive\n"
    " * to get its name the Python code.  Now it just copies the Namable interface\n"
    " * in.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Event,
    nullptr, // tp_members
    Dtool_Properties_Event,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Event,
    PyType_GenericAlloc,
    Dtool_new_Event,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Event,
  Dtool_UpcastInterface_Event,
  Dtool_DowncastInterface_Event,
  (CoerceFunction)Dtool_ConstCoerce_Event,
  (CoerceFunction)Dtool_Coerce_Event,
};

static void Dtool_PyModuleClassInit_Event(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_Event._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_Event._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Event._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Event) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Event)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Event);
  }
}

/**
 * Python method tables for EventHandler (EventHandler)
 */
static PyMethodDef Dtool_Methods_EventHandler[] = {
  {"get_future", &Dtool_EventHandler_get_future_255, METH_O, (const char *)Dtool_EventHandler_get_future_255_comment},
  {"getFuture", &Dtool_EventHandler_get_future_255, METH_O, (const char *)Dtool_EventHandler_get_future_255_comment},
  {"process_events", &Dtool_EventHandler_process_events_256, METH_NOARGS, (const char *)Dtool_EventHandler_process_events_256_comment},
  {"processEvents", &Dtool_EventHandler_process_events_256, METH_NOARGS, (const char *)Dtool_EventHandler_process_events_256_comment},
  {"dispatch_event", &Dtool_EventHandler_dispatch_event_257, METH_O, (const char *)Dtool_EventHandler_dispatch_event_257_comment},
  {"dispatchEvent", &Dtool_EventHandler_dispatch_event_257, METH_O, (const char *)Dtool_EventHandler_dispatch_event_257_comment},
  {"write", &Dtool_EventHandler_write_258, METH_O, (const char *)Dtool_EventHandler_write_258_comment},
  {"get_global_event_handler", (PyCFunction) &Dtool_EventHandler_get_global_event_handler_259, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EventHandler_get_global_event_handler_259_comment},
  {"getGlobalEventHandler", (PyCFunction) &Dtool_EventHandler_get_global_event_handler_259, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_EventHandler_get_global_event_handler_259_comment},
  {"get_class_type", &Dtool_EventHandler_get_class_type_260, METH_NOARGS | METH_STATIC, (const char *)Dtool_EventHandler_get_class_type_260_comment},
  {"getClassType", &Dtool_EventHandler_get_class_type_260, METH_NOARGS | METH_STATIC, (const char *)Dtool_EventHandler_get_class_type_260_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     EventHandler
//////////////////
static PyObject *Dtool_Str_EventHandler(PyObject *self) {
  EventHandler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_EventHandler, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_EventHandler = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EventHandler = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EventHandler = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EventHandler = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EventHandler = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EventHandler = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.EventHandler",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EventHandler,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EventHandler,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EventHandler,
    &Dtool_SequenceMethods_EventHandler,
    &Dtool_MappingMethods_EventHandler,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_EventHandler,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EventHandler,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class to monitor events from the C++ side of things.  It maintains a set\n"
    " * of \"hooks\", function pointers assigned to event names, and calls the\n"
    " * appropriate hooks when the matching event is detected.\n"
    " *\n"
    " * This class is not necessary when the hooks are detected and processed\n"
    " * entirely by the scripting language, e.g.  via Scheme hooks or the messenger\n"
    " * in Python.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EventHandler,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EventHandler,
    PyType_GenericAlloc,
    Dtool_new_EventHandler,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EventHandler,
  Dtool_UpcastInterface_EventHandler,
  Dtool_DowncastInterface_EventHandler,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EventHandler(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != nullptr);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_EventHandler._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    Dtool_EventHandler._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EventHandler._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EventHandler) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EventHandler)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EventHandler);
  }
}

/**
 * Python method tables for EventQueue (EventQueue)
 */
static PyMethodDef Dtool_Methods_EventQueue[] = {
  {"queue_event", &Dtool_EventQueue_queue_event_264, METH_O, (const char *)Dtool_EventQueue_queue_event_264_comment},
  {"queueEvent", &Dtool_EventQueue_queue_event_264, METH_O, (const char *)Dtool_EventQueue_queue_event_264_comment},
  {"clear", &Dtool_EventQueue_clear_265, METH_NOARGS, (const char *)Dtool_EventQueue_clear_265_comment},
  {"is_queue_empty", &Dtool_EventQueue_is_queue_empty_266, METH_NOARGS, (const char *)Dtool_EventQueue_is_queue_empty_266_comment},
  {"isQueueEmpty", &Dtool_EventQueue_is_queue_empty_266, METH_NOARGS, (const char *)Dtool_EventQueue_is_queue_empty_266_comment},
  {"is_queue_full", &Dtool_EventQueue_is_queue_full_267, METH_NOARGS, (const char *)Dtool_EventQueue_is_queue_full_267_comment},
  {"isQueueFull", &Dtool_EventQueue_is_queue_full_267, METH_NOARGS, (const char *)Dtool_EventQueue_is_queue_full_267_comment},
  {"dequeue_event", &Dtool_EventQueue_dequeue_event_268, METH_NOARGS, (const char *)Dtool_EventQueue_dequeue_event_268_comment},
  {"dequeueEvent", &Dtool_EventQueue_dequeue_event_268, METH_NOARGS, (const char *)Dtool_EventQueue_dequeue_event_268_comment},
  {"get_global_event_queue", &Dtool_EventQueue_get_global_event_queue_269, METH_NOARGS | METH_STATIC, (const char *)Dtool_EventQueue_get_global_event_queue_269_comment},
  {"getGlobalEventQueue", &Dtool_EventQueue_get_global_event_queue_269, METH_NOARGS | METH_STATIC, (const char *)Dtool_EventQueue_get_global_event_queue_269_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EventQueue = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_EventQueue = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.EventQueue",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EventQueue,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EventQueue,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A queue of pending events.  As events are thrown, they are added to this\n"
    " * queue; eventually, they will be extracted out again by an EventHandler and\n"
    " * processed.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EventQueue,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EventQueue,
    PyType_GenericAlloc,
    Dtool_new_EventQueue,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EventQueue,
  Dtool_UpcastInterface_EventQueue,
  Dtool_DowncastInterface_EventQueue,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EventQueue(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_EventQueue._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EventQueue._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EventQueue) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EventQueue)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EventQueue);
  }
}

/**
 * Python method tables for PointerEventList (PointerEventList)
 */
static PyMethodDef Dtool_Methods_PointerEventList[] = {
  {"get_num_events", &Dtool_PointerEventList_get_num_events_272, METH_NOARGS, (const char *)Dtool_PointerEventList_get_num_events_272_comment},
  {"getNumEvents", &Dtool_PointerEventList_get_num_events_272, METH_NOARGS, (const char *)Dtool_PointerEventList_get_num_events_272_comment},
  {"get_in_window", &Dtool_PointerEventList_get_in_window_273, METH_O, (const char *)Dtool_PointerEventList_get_in_window_273_comment},
  {"getInWindow", &Dtool_PointerEventList_get_in_window_273, METH_O, (const char *)Dtool_PointerEventList_get_in_window_273_comment},
  {"get_xpos", &Dtool_PointerEventList_get_xpos_274, METH_O, (const char *)Dtool_PointerEventList_get_xpos_274_comment},
  {"getXpos", &Dtool_PointerEventList_get_xpos_274, METH_O, (const char *)Dtool_PointerEventList_get_xpos_274_comment},
  {"get_ypos", &Dtool_PointerEventList_get_ypos_275, METH_O, (const char *)Dtool_PointerEventList_get_ypos_275_comment},
  {"getYpos", &Dtool_PointerEventList_get_ypos_275, METH_O, (const char *)Dtool_PointerEventList_get_ypos_275_comment},
  {"get_dx", &Dtool_PointerEventList_get_dx_276, METH_O, (const char *)Dtool_PointerEventList_get_dx_276_comment},
  {"getDx", &Dtool_PointerEventList_get_dx_276, METH_O, (const char *)Dtool_PointerEventList_get_dx_276_comment},
  {"get_dy", &Dtool_PointerEventList_get_dy_277, METH_O, (const char *)Dtool_PointerEventList_get_dy_277_comment},
  {"getDy", &Dtool_PointerEventList_get_dy_277, METH_O, (const char *)Dtool_PointerEventList_get_dy_277_comment},
  {"get_sequence", &Dtool_PointerEventList_get_sequence_278, METH_O, (const char *)Dtool_PointerEventList_get_sequence_278_comment},
  {"getSequence", &Dtool_PointerEventList_get_sequence_278, METH_O, (const char *)Dtool_PointerEventList_get_sequence_278_comment},
  {"get_length", &Dtool_PointerEventList_get_length_279, METH_O, (const char *)Dtool_PointerEventList_get_length_279_comment},
  {"getLength", &Dtool_PointerEventList_get_length_279, METH_O, (const char *)Dtool_PointerEventList_get_length_279_comment},
  {"get_direction", &Dtool_PointerEventList_get_direction_280, METH_O, (const char *)Dtool_PointerEventList_get_direction_280_comment},
  {"getDirection", &Dtool_PointerEventList_get_direction_280, METH_O, (const char *)Dtool_PointerEventList_get_direction_280_comment},
  {"get_rotation", &Dtool_PointerEventList_get_rotation_281, METH_O, (const char *)Dtool_PointerEventList_get_rotation_281_comment},
  {"getRotation", &Dtool_PointerEventList_get_rotation_281, METH_O, (const char *)Dtool_PointerEventList_get_rotation_281_comment},
  {"get_time", &Dtool_PointerEventList_get_time_282, METH_O, (const char *)Dtool_PointerEventList_get_time_282_comment},
  {"getTime", &Dtool_PointerEventList_get_time_282, METH_O, (const char *)Dtool_PointerEventList_get_time_282_comment},
  {"clear", &Dtool_PointerEventList_clear_283, METH_NOARGS, (const char *)Dtool_PointerEventList_clear_283_comment},
  {"pop_front", &Dtool_PointerEventList_pop_front_284, METH_NOARGS, (const char *)Dtool_PointerEventList_pop_front_284_comment},
  {"popFront", &Dtool_PointerEventList_pop_front_284, METH_NOARGS, (const char *)Dtool_PointerEventList_pop_front_284_comment},
  {"add_event", (PyCFunction) &Dtool_PointerEventList_add_event_285, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerEventList_add_event_285_comment},
  {"addEvent", (PyCFunction) &Dtool_PointerEventList_add_event_285, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerEventList_add_event_285_comment},
  {"encircles", (PyCFunction) &Dtool_PointerEventList_encircles_286, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerEventList_encircles_286_comment},
  {"total_turns", &Dtool_PointerEventList_total_turns_287, METH_O, (const char *)Dtool_PointerEventList_total_turns_287_comment},
  {"totalTurns", &Dtool_PointerEventList_total_turns_287, METH_O, (const char *)Dtool_PointerEventList_total_turns_287_comment},
  {"match_pattern", (PyCFunction) &Dtool_PointerEventList_match_pattern_288, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerEventList_match_pattern_288_comment},
  {"matchPattern", (PyCFunction) &Dtool_PointerEventList_match_pattern_288, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerEventList_match_pattern_288_comment},
  {"get_class_type", &Dtool_PointerEventList_get_class_type_289, METH_NOARGS | METH_STATIC, (const char *)Dtool_PointerEventList_get_class_type_289_comment},
  {"getClassType", &Dtool_PointerEventList_get_class_type_289, METH_NOARGS | METH_STATIC, (const char *)Dtool_PointerEventList_get_class_type_289_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerEventList = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerEventList = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerEventList = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerEventList = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerEventList = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerEventList = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerEventList",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerEventList,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerEventList,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerEventList,
    &Dtool_SequenceMethods_PointerEventList,
    &Dtool_MappingMethods_PointerEventList,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerEventList,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Records a set of pointer events that happened recently.  This class is\n"
    " * usually used only in the data graph, to transmit the recent pointer\n"
    " * presses, but it may be used anywhere a list of PointerEvents is desired.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerEventList,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerEventList,
    PyType_GenericAlloc,
    Dtool_new_PointerEventList,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerEventList,
  Dtool_UpcastInterface_PointerEventList,
  Dtool_DowncastInterface_PointerEventList,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerEventList(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ParamValueBase != nullptr);
    assert(Dtool_Ptr_ParamValueBase->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ParamValueBase->_Dtool_ModuleClassInit(nullptr);
    Dtool_PointerEventList._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ParamValueBase);
    Dtool_PointerEventList._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerEventList._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerEventList) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerEventList)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerEventList);
  }
}

/**
 * Python method tables for PythonTask (PythonTask)
 */
static PyMethodDef Dtool_Methods_PythonTask[] = {
  {"set_function", &Dtool_PythonTask_set_function_296, METH_O, (const char *)Dtool_PythonTask_set_function_296_comment},
  {"setFunction", &Dtool_PythonTask_set_function_296, METH_O, (const char *)Dtool_PythonTask_set_function_296_comment},
  {"get_function", &Dtool_PythonTask_get_function_297, METH_NOARGS, (const char *)Dtool_PythonTask_get_function_297_comment},
  {"getFunction", &Dtool_PythonTask_get_function_297, METH_NOARGS, (const char *)Dtool_PythonTask_get_function_297_comment},
  {"set_args", (PyCFunction) &Dtool_PythonTask_set_args_298, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PythonTask_set_args_298_comment},
  {"setArgs", (PyCFunction) &Dtool_PythonTask_set_args_298, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PythonTask_set_args_298_comment},
  {"get_args", &Dtool_PythonTask_get_args_299, METH_NOARGS, (const char *)Dtool_PythonTask_get_args_299_comment},
  {"getArgs", &Dtool_PythonTask_get_args_299, METH_NOARGS, (const char *)Dtool_PythonTask_get_args_299_comment},
  {"set_upon_death", &Dtool_PythonTask_set_upon_death_300, METH_O, (const char *)Dtool_PythonTask_set_upon_death_300_comment},
  {"setUponDeath", &Dtool_PythonTask_set_upon_death_300, METH_O, (const char *)Dtool_PythonTask_set_upon_death_300_comment},
  {"get_upon_death", &Dtool_PythonTask_get_upon_death_301, METH_NOARGS, (const char *)Dtool_PythonTask_get_upon_death_301_comment},
  {"getUponDeath", &Dtool_PythonTask_get_upon_death_301, METH_NOARGS, (const char *)Dtool_PythonTask_get_upon_death_301_comment},
  {"set_owner", &Dtool_PythonTask_set_owner_302, METH_O, (const char *)Dtool_PythonTask_set_owner_302_comment},
  {"setOwner", &Dtool_PythonTask_set_owner_302, METH_O, (const char *)Dtool_PythonTask_set_owner_302_comment},
  {"get_owner", &Dtool_PythonTask_get_owner_303, METH_NOARGS, (const char *)Dtool_PythonTask_get_owner_303_comment},
  {"getOwner", &Dtool_PythonTask_get_owner_303, METH_NOARGS, (const char *)Dtool_PythonTask_get_owner_303_comment},
  {"set_result", &Dtool_PythonTask_set_result_304, METH_O, (const char *)Dtool_PythonTask_set_result_304_comment},
  {"setResult", &Dtool_PythonTask_set_result_304, METH_O, (const char *)Dtool_PythonTask_set_result_304_comment},
  {"get_class_type", &Dtool_PythonTask_get_class_type_329, METH_NOARGS | METH_STATIC, (const char *)Dtool_PythonTask_get_class_type_329_comment},
  {"getClassType", &Dtool_PythonTask_get_class_type_329, METH_NOARGS | METH_STATIC, (const char *)Dtool_PythonTask_get_class_type_329_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PythonTask slot tp_clear -> __clear__
//////////////////
static int Dtool_PythonTask_clear_309_tp_clear(PyObject *self) {
  PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return -1;
  }

  return (int) ((*local_this).__clear__)();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PythonTask slot tp_getattro -> __getattribute__
//////////////////
static PyObject *Dtool_PythonTask_getattribute_307_tp_getattro(PyObject *self, PyObject *arg) {
  PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return nullptr;
  }
  // 1-PyObject *PythonTask::__getattribute__(PyObject *self, PyObject *attr) const
  PyObject *return_value = ((*(const PythonTask*)local_this).__getattribute__)(self, arg);
  return Dtool_Return(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getattribute__(PythonTask self, object attr)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PythonTask slot tp_setattro -> __setattr__
//////////////////
static int Dtool_PythonTask_setattr_305_tp_setattro(PyObject *self, PyObject *arg, PyObject *arg2) {
  PythonTask *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PythonTask, (void **)&local_this)) {
    return -1;
  }

  // Determine whether to call __setattr__ or __delattr__.
  if (arg2 != nullptr) { // __setattr__
    PyObject *args = PyTuple_Pack(2, arg, arg2);
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-int PythonTask::__setattr__(PyObject *self, PyObject *attr, PyObject *v)
      PyObject *param1;
      PyObject *param2;
      if (PyArg_UnpackTuple(args, "__setattr__", 2, 2, &param1, &param2)) {
        int return_value = ((*local_this).__setattr__)(self, param1, param2);
        Py_DECREF(args);
        if (Dtool_CheckErrorOccurred()) {
          return -1;
        }
        return return_value;
      }
    } else {
#ifdef NDEBUG
      Py_DECREF(args);
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Py_DECREF(args);
      Dtool_Raise_TypeError("Cannot call PythonTask.__setattr__() on a const object.");
      return -1;
#endif
    }
    Py_DECREF(args);
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__setattr__(const PythonTask self, object attr, object v)\n");
    }
    return -1;

  } else { // __delattr__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-int PythonTask::__delattr__(PyObject *self, PyObject *attr)
      int return_value = ((*local_this).__delattr__)(self, arg);
      if (Dtool_CheckErrorOccurred()) {
        return -1;
      }
      return return_value;
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PythonTask.__delattr__() on a const object.");
      return -1;
#endif
    }
    if (!_PyErr_OCCURRED()) {
      Dtool_Raise_BadArgumentsError(
        "__delattr__(const PythonTask self, object attr)\n");
    }
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PythonTask slot tp_traverse -> __traverse__
//////////////////
static int Dtool_PythonTask_traverse_308_tp_traverse(PyObject *self, visitproc visit, void *arg) {
  PythonTask *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PythonTask, (void **) &local_this);
  if (local_this == nullptr) {
    return 0;
  }

  return ((*local_this).__traverse__)(visit, arg);
}

static PyGetSetDef Dtool_Properties_PythonTask[] = {
  {(char *)"time", &Dtool_PythonTask_time_Getter, nullptr, (char *)
    "// The amount of seconds that have elapsed since the task was started,\n"
    "// according to the task manager's clock.",
    nullptr},
  {(char *)"wake_time", &Dtool_PythonTask_wake_time_Getter, nullptr, (char *)
    "// If this task has been added to an AsyncTaskManager with a delay in\n"
    "// effect, this contains the time at which the task is expected to awaken.\n"
    "// It has no meaning of the task has not yet been added to a queue, or if\n"
    "// there was no delay in effect at the time the task was added.  If the\n"
    "// task's status is not S_sleeping, this contains 0.0.",
    nullptr},
  {(char *)"wakeTime", &Dtool_PythonTask_wakeTime_Getter, nullptr, (char *)
    "// Alias of wake_time.",
    nullptr},
  {(char *)"delay_time", &Dtool_PythonTask_delay_time_Getter, &Dtool_PythonTask_delay_time_Setter, (char *)
    "// The delay value that has been set on this task, if any, or None.",
    nullptr},
  {(char *)"delayTime", &Dtool_PythonTask_delayTime_Getter, &Dtool_PythonTask_delayTime_Setter, (char *)
    "// Alias of delay_time.",
    nullptr},
  {(char *)"frame", &Dtool_PythonTask_frame_Getter, nullptr, (char *)
    "// The number of frames that have elapsed since the task was started,\n"
    "// according to the task manager's clock.",
    nullptr},
  {(char *)"__dict__", &Dtool_PythonTask___dict___Getter, &Dtool_PythonTask___dict___Setter, (char *)
    "// This is a special variable to hold the instance dictionary in which\n"
    "// custom variables may be stored.",
    nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PythonTask = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PythonTask = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PythonTask = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PythonTask = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PythonTask = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PythonTask = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PythonTask",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PythonTask,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PythonTask,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PythonTask,
    &Dtool_SequenceMethods_PythonTask,
    &Dtool_MappingMethods_PythonTask,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    &Dtool_PythonTask_getattribute_307_tp_getattro,
    &Dtool_PythonTask_setattr_305_tp_setattro,
    &Dtool_BufferProcs_PythonTask,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class exists to allow association of a Python function or coroutine\n"
    " * with the AsyncTaskManager.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PythonTask,
    nullptr, // tp_members
    Dtool_Properties_PythonTask,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PythonTask,
    PyType_GenericAlloc,
    Dtool_new_PythonTask,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PythonTask,
  Dtool_UpcastInterface_PythonTask,
  Dtool_DowncastInterface_PythonTask,
  (CoerceFunction)Dtool_ConstCoerce_PythonTask,
  (CoerceFunction)Dtool_Coerce_PythonTask,
};

static void Dtool_PyModuleClassInit_PythonTask(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AsyncTask(nullptr);
    Dtool_PythonTask._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AsyncTask);
    Dtool_PythonTask._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PythonTask._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PythonTask) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PythonTask)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PythonTask);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3event_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    AsyncFuture::init_type();
    TypeHandle handle = AsyncFuture::get_class_type();
    Dtool_AsyncFuture._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AsyncFuture);
  }
  {
    AsyncTask::init_type();
    TypeHandle handle = AsyncTask::get_class_type();
    Dtool_AsyncTask._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AsyncTask);
  }
  {
    AsyncTaskManager::init_type();
    TypeHandle handle = AsyncTaskManager::get_class_type();
    Dtool_AsyncTaskManager._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AsyncTaskManager);
  }
  {
    AsyncTaskChain::init_type();
    TypeHandle handle = AsyncTaskChain::get_class_type();
    Dtool_AsyncTaskChain._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AsyncTaskChain);
  }
  {
    AsyncTaskPause::init_type();
    TypeHandle handle = AsyncTaskPause::get_class_type();
    Dtool_AsyncTaskPause._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AsyncTaskPause);
  }
  {
    AsyncTaskSequence::init_type();
    TypeHandle handle = AsyncTaskSequence::get_class_type();
    Dtool_AsyncTaskSequence._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AsyncTaskSequence);
  }
  {
    ButtonEventList::init_type();
    TypeHandle handle = ButtonEventList::get_class_type();
    Dtool_ButtonEventList._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ButtonEventList);
  }
  {
    Event::init_type();
    TypeHandle handle = Event::get_class_type();
    Dtool_Event._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Event);
  }
  {
    EventHandler::init_type();
    TypeHandle handle = EventHandler::get_class_type();
    Dtool_EventHandler._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EventHandler);
  }
  {
    PointerEventList::init_type();
    TypeHandle handle = PointerEventList::get_class_type();
    Dtool_PointerEventList._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PointerEventList);
  }
  {
    PythonTask::init_type();
    TypeHandle handle = PythonTask::get_class_type();
    Dtool_PythonTask._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PythonTask);
  }
}

void Dtool_libp3event_BuildInstants(PyObject *module) {
  (void) module;
  // EventParameter
  Dtool_PyModuleClassInit_EventParameter(module);
  PyModule_AddObject(module, "EventParameter", (PyObject *)&Dtool_EventParameter);
  // AsyncFuture
  Dtool_PyModuleClassInit_AsyncFuture(module);
  PyModule_AddObject(module, "AsyncFuture", (PyObject *)&Dtool_AsyncFuture);
  // AsyncTask
  Dtool_PyModuleClassInit_AsyncTask(module);
  PyModule_AddObject(module, "AsyncTask", (PyObject *)&Dtool_AsyncTask);
  // AsyncTaskManager
  Dtool_PyModuleClassInit_AsyncTaskManager(module);
  PyModule_AddObject(module, "AsyncTaskManager", (PyObject *)&Dtool_AsyncTaskManager);
  // AsyncTaskCollection
  Dtool_PyModuleClassInit_AsyncTaskCollection(module);
  PyModule_AddObject(module, "AsyncTaskCollection", (PyObject *)&Dtool_AsyncTaskCollection);
  // AsyncTaskChain
  Dtool_PyModuleClassInit_AsyncTaskChain(module);
  PyModule_AddObject(module, "AsyncTaskChain", (PyObject *)&Dtool_AsyncTaskChain);
  // AsyncTaskPause
  Dtool_PyModuleClassInit_AsyncTaskPause(module);
  PyModule_AddObject(module, "AsyncTaskPause", (PyObject *)&Dtool_AsyncTaskPause);
  // AsyncTaskSequence
  Dtool_PyModuleClassInit_AsyncTaskSequence(module);
  PyModule_AddObject(module, "AsyncTaskSequence", (PyObject *)&Dtool_AsyncTaskSequence);
  // ButtonEventList
  Dtool_PyModuleClassInit_ButtonEventList(module);
  PyModule_AddObject(module, "ButtonEventList", (PyObject *)&Dtool_ButtonEventList);
  // Event
  Dtool_PyModuleClassInit_Event(module);
  PyModule_AddObject(module, "Event", (PyObject *)&Dtool_Event);
  // EventHandler
  Dtool_PyModuleClassInit_EventHandler(module);
  PyModule_AddObject(module, "EventHandler", (PyObject *)&Dtool_EventHandler);
  // EventQueue
  Dtool_PyModuleClassInit_EventQueue(module);
  PyModule_AddObject(module, "EventQueue", (PyObject *)&Dtool_EventQueue);
  // PointerEventList
  Dtool_PyModuleClassInit_PointerEventList(module);
  PyModule_AddObject(module, "PointerEventList", (PyObject *)&Dtool_PointerEventList);
  // PythonTask
  Dtool_PyModuleClassInit_PythonTask(module);
  PyModule_AddObject(module, "PythonTask", (PyObject *)&Dtool_PythonTask);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3event_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3event_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583612648,  /* file_identifier */
  "libp3event",  /* library_name */
  "_0BP",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3event.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  657  /* next_index */
};

Configure(_in_configure_libp3event);
ConfigureFn(_in_configure_libp3event) {
  interrogate_request_module(&_in_module_def);
}

