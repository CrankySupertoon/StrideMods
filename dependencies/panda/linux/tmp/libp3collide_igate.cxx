/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/collide -Ipanda/src/collide -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3collide_igate.cxx -od built/pandac/input/libp3collide.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/collide -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3collide collisionBox.h collisionCapsule.h collisionEntry.h collisionFloorMesh.h collisionGeom.h collisionHandler.h collisionHandlerEvent.h collisionHandlerFloor.h collisionHandlerFluidPusher.h collisionHandlerGravity.h collisionHandlerHighestEvent.h collisionHandlerPhysical.h collisionHandlerPusher.h collisionHandlerQueue.h collisionInvSphere.h collisionLevelState.h collisionLevelStateBase.h collisionLine.h collisionNode.h collisionParabola.h collisionPlane.h collisionPolygon.h collisionRay.h collisionRecorder.h collisionSegment.h collisionSolid.h collisionSphere.h collisionTraverser.h collisionTube.h collisionVisualizer.h config_collide.h p3collide_composite1.cxx p3collide_composite2.cxx
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "clipPlaneAttrib.h"
#include "collisionBox.h"
#include "collisionCapsule.h"
#include "collisionEntry.h"
#include "collisionFloorMesh.h"
#include "collisionGeom.h"
#include "collisionHandler.h"
#include "collisionHandlerEvent.h"
#include "collisionHandlerFloor.h"
#include "collisionHandlerFluidPusher.h"
#include "collisionHandlerGravity.h"
#include "collisionHandlerHighestEvent.h"
#include "collisionHandlerPhysical.h"
#include "collisionHandlerPusher.h"
#include "collisionHandlerQueue.h"
#include "collisionInvSphere.h"
#include "collisionLevelState.h"
#include "collisionLevelStateBase.h"
#include "collisionLine.h"
#include "collisionNode.h"
#include "collisionParabola.h"
#include "collisionPlane.h"
#include "collisionPolygon.h"
#include "collisionRay.h"
#include "collisionRecorder.h"
#include "collisionSegment.h"
#include "collisionSolid.h"
#include "collisionSphere.h"
#include "collisionTraverser.h"
#include "collisionTube.h"
#include "collisionVisualizer.h"
#include "config_collide.h"
#include "lightMutex.h"
#include "look_at.h"
#include "luse.h"
#include "nodePath.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "parabola.h"
#include "plane.h"
#include "pmap.h"
#include "pointerTo.h"
#include "pvector.h"
#include "transformState.h"
#include "typedWritableReferenceCount.h"
#include "vector_string.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class CollisionSolid
 */
typedef CollisionSolid CollisionSolid_localtype;
Define_Module_ClassRef(panda3d.core, CollisionSolid, CollisionSolid_localtype, CollisionSolid);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionSolid = &Dtool_CollisionSolid;
static void Dtool_PyModuleClassInit_CollisionSolid(PyObject *module);

/**
 * Forward declarations for top-level class CollisionBox
 */
typedef CollisionBox CollisionBox_localtype;
Define_Module_ClassRef(panda3d.core, CollisionBox, CollisionBox_localtype, CollisionBox);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionBox = &Dtool_CollisionBox;
static void Dtool_PyModuleClassInit_CollisionBox(PyObject *module);

/**
 * Forward declarations for top-level class CollisionCapsule
 */
typedef CollisionCapsule CollisionCapsule_localtype;
Define_Module_ClassRef(panda3d.core, CollisionCapsule, CollisionCapsule_localtype, CollisionCapsule);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionCapsule = &Dtool_CollisionCapsule;
static void Dtool_PyModuleClassInit_CollisionCapsule(PyObject *module);

/**
 * Forward declarations for top-level class CollisionHandler
 */
typedef CollisionHandler CollisionHandler_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandler, CollisionHandler_localtype, CollisionHandler);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandler = &Dtool_CollisionHandler;
static void Dtool_PyModuleClassInit_CollisionHandler(PyObject *module);

/**
 * Forward declarations for top-level class CollisionNode
 */
typedef CollisionNode CollisionNode_localtype;
Define_Module_ClassRef(panda3d.core, CollisionNode, CollisionNode_localtype, CollisionNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionNode = &Dtool_CollisionNode;
static void Dtool_PyModuleClassInit_CollisionNode(PyObject *module);

/**
 * Forward declarations for top-level class CollisionTraverser
 */
typedef CollisionTraverser CollisionTraverser_localtype;
Define_Module_Class(panda3d.core, CollisionTraverser, CollisionTraverser_localtype, CollisionTraverser);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionTraverser = &Dtool_CollisionTraverser;
static void Dtool_PyModuleClassInit_CollisionTraverser(PyObject *module);

/**
 * Forward declarations for top-level class CollisionRecorder
 */
typedef CollisionRecorder CollisionRecorder_localtype;
Define_Module_Class(panda3d.core, CollisionRecorder, CollisionRecorder_localtype, CollisionRecorder);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionRecorder = &Dtool_CollisionRecorder;
static void Dtool_PyModuleClassInit_CollisionRecorder(PyObject *module);

/**
 * Forward declarations for top-level class CollisionEntry
 */
typedef CollisionEntry CollisionEntry_localtype;
Define_Module_ClassRef(panda3d.core, CollisionEntry, CollisionEntry_localtype, CollisionEntry);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionEntry = &Dtool_CollisionEntry;
static void Dtool_PyModuleClassInit_CollisionEntry(PyObject *module);

/**
 * Forward declarations for top-level class CollisionPlane
 */
typedef CollisionPlane CollisionPlane_localtype;
Define_Module_ClassRef(panda3d.core, CollisionPlane, CollisionPlane_localtype, CollisionPlane);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionPlane = &Dtool_CollisionPlane;
static void Dtool_PyModuleClassInit_CollisionPlane(PyObject *module);
bool Dtool_ConstCoerce_CollisionPlane(PyObject *args, CPT(CollisionPlane) &coerced);
bool Dtool_Coerce_CollisionPlane(PyObject *args, PT(CollisionPlane) &coerced);

/**
 * Forward declarations for top-level class CollisionFloorMesh
 */
typedef CollisionFloorMesh CollisionFloorMesh_localtype;
Define_Module_ClassRef(panda3d.core, CollisionFloorMesh, CollisionFloorMesh_localtype, CollisionFloorMesh);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionFloorMesh = &Dtool_CollisionFloorMesh;
static void Dtool_PyModuleClassInit_CollisionFloorMesh(PyObject *module);

/**
 * Forward declarations for top-level class CollisionPolygon
 */
typedef CollisionPolygon CollisionPolygon_localtype;
Define_Module_ClassRef(panda3d.core, CollisionPolygon, CollisionPolygon_localtype, CollisionPolygon);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionPolygon = &Dtool_CollisionPolygon;
static void Dtool_PyModuleClassInit_CollisionPolygon(PyObject *module);
bool Dtool_ConstCoerce_CollisionPolygon(PyObject *args, CPT(CollisionPolygon) &coerced);
bool Dtool_Coerce_CollisionPolygon(PyObject *args, PT(CollisionPolygon) &coerced);

/**
 * Forward declarations for top-level class CollisionHandlerEvent
 */
typedef CollisionHandlerEvent CollisionHandlerEvent_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandlerEvent, CollisionHandlerEvent_localtype, CollisionHandlerEvent);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerEvent = &Dtool_CollisionHandlerEvent;
static void Dtool_PyModuleClassInit_CollisionHandlerEvent(PyObject *module);

/**
 * Forward declarations for top-level class CollisionHandlerPhysical
 */
typedef CollisionHandlerPhysical CollisionHandlerPhysical_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandlerPhysical, CollisionHandlerPhysical_localtype, CollisionHandlerPhysical);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerPhysical = &Dtool_CollisionHandlerPhysical;
static void Dtool_PyModuleClassInit_CollisionHandlerPhysical(PyObject *module);

/**
 * Forward declarations for top-level class CollisionHandlerFloor
 */
typedef CollisionHandlerFloor CollisionHandlerFloor_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandlerFloor, CollisionHandlerFloor_localtype, CollisionHandlerFloor);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerFloor = &Dtool_CollisionHandlerFloor;
static void Dtool_PyModuleClassInit_CollisionHandlerFloor(PyObject *module);

/**
 * Forward declarations for top-level class CollisionHandlerPusher
 */
typedef CollisionHandlerPusher CollisionHandlerPusher_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandlerPusher, CollisionHandlerPusher_localtype, CollisionHandlerPusher);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerPusher = &Dtool_CollisionHandlerPusher;
static void Dtool_PyModuleClassInit_CollisionHandlerPusher(PyObject *module);

/**
 * Forward declarations for top-level class CollisionHandlerFluidPusher
 */
typedef CollisionHandlerFluidPusher CollisionHandlerFluidPusher_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandlerFluidPusher, CollisionHandlerFluidPusher_localtype, CollisionHandlerFluidPusher);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerFluidPusher = &Dtool_CollisionHandlerFluidPusher;
static void Dtool_PyModuleClassInit_CollisionHandlerFluidPusher(PyObject *module);

/**
 * Forward declarations for top-level class CollisionHandlerGravity
 */
typedef CollisionHandlerGravity CollisionHandlerGravity_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandlerGravity, CollisionHandlerGravity_localtype, CollisionHandlerGravity);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerGravity = &Dtool_CollisionHandlerGravity;
static void Dtool_PyModuleClassInit_CollisionHandlerGravity(PyObject *module);

/**
 * Forward declarations for top-level class CollisionHandlerHighestEvent
 */
typedef CollisionHandlerHighestEvent CollisionHandlerHighestEvent_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandlerHighestEvent, CollisionHandlerHighestEvent_localtype, CollisionHandlerHighestEvent);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerHighestEvent = &Dtool_CollisionHandlerHighestEvent;
static void Dtool_PyModuleClassInit_CollisionHandlerHighestEvent(PyObject *module);

/**
 * Forward declarations for top-level class CollisionHandlerQueue
 */
typedef CollisionHandlerQueue CollisionHandlerQueue_localtype;
Define_Module_ClassRef(panda3d.core, CollisionHandlerQueue, CollisionHandlerQueue_localtype, CollisionHandlerQueue);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerQueue = &Dtool_CollisionHandlerQueue;
static void Dtool_PyModuleClassInit_CollisionHandlerQueue(PyObject *module);

/**
 * Forward declarations for top-level class CollisionSphere
 */
typedef CollisionSphere CollisionSphere_localtype;
Define_Module_ClassRef(panda3d.core, CollisionSphere, CollisionSphere_localtype, CollisionSphere);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionSphere = &Dtool_CollisionSphere;
static void Dtool_PyModuleClassInit_CollisionSphere(PyObject *module);

/**
 * Forward declarations for top-level class CollisionInvSphere
 */
typedef CollisionInvSphere CollisionInvSphere_localtype;
Define_Module_ClassRef(panda3d.core, CollisionInvSphere, CollisionInvSphere_localtype, CollisionInvSphere);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionInvSphere = &Dtool_CollisionInvSphere;
static void Dtool_PyModuleClassInit_CollisionInvSphere(PyObject *module);

/**
 * Forward declarations for top-level class CollisionRay
 */
typedef CollisionRay CollisionRay_localtype;
Define_Module_ClassRef(panda3d.core, CollisionRay, CollisionRay_localtype, CollisionRay);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionRay = &Dtool_CollisionRay;
static void Dtool_PyModuleClassInit_CollisionRay(PyObject *module);

/**
 * Forward declarations for top-level class CollisionLine
 */
typedef CollisionLine CollisionLine_localtype;
Define_Module_ClassRef(panda3d.core, CollisionLine, CollisionLine_localtype, CollisionLine);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionLine = &Dtool_CollisionLine;
static void Dtool_PyModuleClassInit_CollisionLine(PyObject *module);

/**
 * Forward declarations for top-level class CollisionParabola
 */
typedef CollisionParabola CollisionParabola_localtype;
Define_Module_ClassRef(panda3d.core, CollisionParabola, CollisionParabola_localtype, CollisionParabola);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionParabola = &Dtool_CollisionParabola;
static void Dtool_PyModuleClassInit_CollisionParabola(PyObject *module);

/**
 * Forward declarations for top-level class CollisionSegment
 */
typedef CollisionSegment CollisionSegment_localtype;
Define_Module_ClassRef(panda3d.core, CollisionSegment, CollisionSegment_localtype, CollisionSegment);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionSegment = &Dtool_CollisionSegment;
static void Dtool_PyModuleClassInit_CollisionSegment(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"CollisionSolid", &Dtool_CollisionSolid},
  {"CollisionBox", &Dtool_CollisionBox},
  {"CollisionCapsule", &Dtool_CollisionCapsule},
  {"CollisionHandler", &Dtool_CollisionHandler},
  {"CollisionNode", &Dtool_CollisionNode},
  {"CollisionTraverser", &Dtool_CollisionTraverser},
  {"CollisionRecorder", &Dtool_CollisionRecorder},
  {"CollisionEntry", &Dtool_CollisionEntry},
  {"CollisionPlane", &Dtool_CollisionPlane},
  {"CollisionFloorMesh", &Dtool_CollisionFloorMesh},
  {"CollisionPolygon", &Dtool_CollisionPolygon},
  {"CollisionHandlerEvent", &Dtool_CollisionHandlerEvent},
  {"CollisionHandlerPhysical", &Dtool_CollisionHandlerPhysical},
  {"CollisionHandlerFloor", &Dtool_CollisionHandlerFloor},
  {"CollisionHandlerPusher", &Dtool_CollisionHandlerPusher},
  {"CollisionHandlerFluidPusher", &Dtool_CollisionHandlerFluidPusher},
  {"CollisionHandlerGravity", &Dtool_CollisionHandlerGravity},
  {"CollisionHandlerHighestEvent", &Dtool_CollisionHandlerHighestEvent},
  {"CollisionHandlerQueue", &Dtool_CollisionHandlerQueue},
  {"CollisionSphere", &Dtool_CollisionSphere},
  {"CollisionInvSphere", &Dtool_CollisionInvSphere},
  {"CollisionRay", &Dtool_CollisionRay},
  {"CollisionLine", &Dtool_CollisionLine},
  {"CollisionParabola", &Dtool_CollisionParabola},
  {"CollisionSegment", &Dtool_CollisionSegment},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[1].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[2].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[3].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[4].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[5].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[6].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[7].type)
  {"CachedTypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_CachedTypedWritableReferenceCount (imports[8].type)
  {"CopyOnWriteObject", nullptr},
#define Dtool_Ptr_CopyOnWriteObject (imports[9].type)
  {"LPoint2f", nullptr},
#define Dtool_Ptr_LPoint2f (imports[10].type)
  {"LVecBase3f", nullptr},
#define Dtool_Ptr_LVecBase3f (imports[11].type)
  {"LVector3f", nullptr},
#define Dtool_Ptr_LVector3f (imports[12].type)
  {"LPoint3f", nullptr},
#define Dtool_Ptr_LPoint3f (imports[13].type)
  {"LPoint3i", nullptr},
#define Dtool_Ptr_LPoint3i (imports[14].type)
  {"BitMask< uint32_t, 32 >", nullptr},
#define Dtool_Ptr_BitMask_uint32_t_32 (imports[15].type)
  {"BoundingVolume", nullptr},
#define Dtool_Ptr_BoundingVolume (imports[16].type)
  {"PandaNode", nullptr},
#define Dtool_Ptr_PandaNode (imports[17].type)
  {"LParabolaf", nullptr},
#define Dtool_Ptr_LParabolaf (imports[18].type)
  {"LPlanef", nullptr},
#define Dtool_Ptr_LPlanef (imports[19].type)
  {"NodePath", nullptr},
#define Dtool_Ptr_NodePath (imports[20].type)
  {"DriveInterface", nullptr},
#define Dtool_Ptr_DriveInterface (imports[21].type)
  {"LensNode", nullptr},
#define Dtool_Ptr_LensNode (imports[22].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// CachedTypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CachedTypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CachedTypedWritableReferenceCount = &Dtool_CachedTypedWritableReferenceCount;
#endif
// CopyOnWriteObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CopyOnWriteObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CopyOnWriteObject = &Dtool_CopyOnWriteObject;
#endif
// LPoint2f
#ifndef LINK_ALL_STATIC
inline static LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced) {
  nassertr(Dtool_Ptr_LPoint2f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint2f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint2f *(*)(PyObject *, LPoint2f &))Dtool_Ptr_LPoint2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2f = &Dtool_LPoint2f;
extern LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LPoint3i
#ifndef LINK_ALL_STATIC
inline static LPoint3i *Dtool_Coerce_LPoint3i(PyObject *args, LPoint3i &coerced) {
  nassertr(Dtool_Ptr_LPoint3i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3i->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3i *(*)(PyObject *, LPoint3i &))Dtool_Ptr_LPoint3i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3i = &Dtool_LPoint3i;
extern LPoint3i *Dtool_Coerce_LPoint3i(PyObject *args, LPoint3i &coerced);
#endif
// BitMask< uint32_t, 32 >
#ifndef LINK_ALL_STATIC
inline static BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced) {
  nassertr(Dtool_Ptr_BitMask_uint32_t_32 != nullptr, nullptr);
  nassertr(Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce != nullptr, nullptr);
  return ((BitMask< uint32_t, 32 > *(*)(PyObject *, BitMask< uint32_t, 32 > &))Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_BitMask_uint32_t_32;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint32_t_32 = &Dtool_BitMask_uint32_t_32;
extern BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced);
#endif
// BoundingVolume
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_BoundingVolume;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BoundingVolume = &Dtool_BoundingVolume;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// LParabolaf
#ifndef LINK_ALL_STATIC
inline static LParabolaf *Dtool_Coerce_LParabolaf(PyObject *args, LParabolaf &coerced) {
  nassertr(Dtool_Ptr_LParabolaf != nullptr, nullptr);
  nassertr(Dtool_Ptr_LParabolaf->_Dtool_Coerce != nullptr, nullptr);
  return ((LParabolaf *(*)(PyObject *, LParabolaf &))Dtool_Ptr_LParabolaf->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LParabolaf;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LParabolaf = &Dtool_LParabolaf;
extern LParabolaf *Dtool_Coerce_LParabolaf(PyObject *args, LParabolaf &coerced);
#endif
// LPlanef
#ifndef LINK_ALL_STATIC
inline static LPlanef *Dtool_Coerce_LPlanef(PyObject *args, LPlanef &coerced) {
  nassertr(Dtool_Ptr_LPlanef != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPlanef->_Dtool_Coerce != nullptr, nullptr);
  return ((LPlanef *(*)(PyObject *, LPlanef &))Dtool_Ptr_LPlanef->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPlanef;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPlanef = &Dtool_LPlanef;
extern LPlanef *Dtool_Coerce_LPlanef(PyObject *args, LPlanef &coerced);
#endif
// NodePath
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// DriveInterface
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DriveInterface;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DriveInterface = &Dtool_DriveInterface;
#endif
// LensNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_LensNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LensNode = &Dtool_LensNode;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class CollisionSolid
 */
/**
 * Python function wrapper for:
 * virtual LPoint3 CollisionSolid::get_collision_origin(void) const = 0
 */
static PyObject *Dtool_CollisionSolid_get_collision_origin_3(PyObject *self, PyObject *) {
  CollisionSolid *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionSolid)) {
    return nullptr;
  }
  // 1-virtual LPoint3 CollisionSolid::get_collision_origin(void) const = 0
  LPoint3 *return_value = new LPoint3(((*(const CollisionSolid*)local_this).get_collision_origin)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_get_collision_origin_3_comment =
  "C++ Interface:\n"
  "get_collision_origin(CollisionSolid self)\n";
#else
static const char *Dtool_CollisionSolid_get_collision_origin_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionSolid::set_tangible(bool tangible)
 */
static PyObject *Dtool_CollisionSolid_set_tangible_7(PyObject *self, PyObject *arg) {
  CollisionSolid *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSolid, (void **)&local_this, "CollisionSolid.set_tangible")) {
    return nullptr;
  }
  // 1-inline void CollisionSolid::set_tangible(bool tangible)
  ((*local_this).set_tangible)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tangible(const CollisionSolid self, bool tangible)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_set_tangible_7_comment =
  "C++ Interface:\n"
  "set_tangible(const CollisionSolid self, bool tangible)\n"
  "\n"
  "/**\n"
  " * Sets the current state of the 'tangible' flag.  Set this true to make the\n"
  " * solid tangible, so that a CollisionHandlerPusher will not allow another\n"
  " * object to intersect it, or false to make it intangible, so that a\n"
  " * CollisionHandlerPusher will ignore it except to throw an event.\n"
  " */";
#else
static const char *Dtool_CollisionSolid_set_tangible_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionSolid::is_tangible(void) const
 */
static PyObject *Dtool_CollisionSolid_is_tangible_8(PyObject *self, PyObject *) {
  CollisionSolid *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionSolid)) {
    return nullptr;
  }
  // 1-inline bool CollisionSolid::is_tangible(void) const
  bool return_value = ((*(const CollisionSolid*)local_this).is_tangible)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_is_tangible_8_comment =
  "C++ Interface:\n"
  "is_tangible(CollisionSolid self)\n"
  "\n"
  "/**\n"
  " * Returns whether the solid is considered 'tangible' or not.  An intangible\n"
  " * solid has no effect in a CollisionHandlerPusher (except to throw an event);\n"
  " * it's useful for defining 'trigger' planes and spheres, that cause an effect\n"
  " * when passed through.\n"
  " */";
#else
static const char *Dtool_CollisionSolid_is_tangible_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionSolid::set_effective_normal(LVector3 const &effective_normal)
 */
static PyObject *Dtool_CollisionSolid_set_effective_normal_11(PyObject *self, PyObject *arg) {
  CollisionSolid *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSolid, (void **)&local_this, "CollisionSolid.set_effective_normal")) {
    return nullptr;
  }
  // 1-inline void CollisionSolid::set_effective_normal(LVector3 const &effective_normal)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionSolid.set_effective_normal", "LVector3f");
  }
  ((*local_this).set_effective_normal)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_effective_normal(const CollisionSolid self, const LVector3f effective_normal)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_set_effective_normal_11_comment =
  "C++ Interface:\n"
  "set_effective_normal(const CollisionSolid self, const LVector3f effective_normal)\n"
  "\n"
  "/**\n"
  " * Records a false normal for this CollisionSolid that will be reported by the\n"
  " * collision system with all collisions into it, instead of its actual normal.\n"
  " * This is useful as a workaround for the problem of an avatar wanting to\n"
  " * stand on a sloping ground; by storing a false normal, the ground appears to\n"
  " * be perfectly level, and the avatar does not tend to slide down it.\n"
  " */";
#else
static const char *Dtool_CollisionSolid_set_effective_normal_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionSolid::clear_effective_normal(void)
 */
static PyObject *Dtool_CollisionSolid_clear_effective_normal_12(PyObject *self, PyObject *) {
  CollisionSolid *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSolid, (void **)&local_this, "CollisionSolid.clear_effective_normal")) {
    return nullptr;
  }
  // 1-inline void CollisionSolid::clear_effective_normal(void)
  ((*local_this).clear_effective_normal)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_clear_effective_normal_12_comment =
  "C++ Interface:\n"
  "clear_effective_normal(const CollisionSolid self)\n"
  "\n"
  "/**\n"
  " * Removes the normal previously set by set_effective_normal().\n"
  " */";
#else
static const char *Dtool_CollisionSolid_clear_effective_normal_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionSolid::has_effective_normal(void) const
 */
static PyObject *Dtool_CollisionSolid_has_effective_normal_13(PyObject *self, PyObject *) {
  CollisionSolid *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionSolid)) {
    return nullptr;
  }
  // 1-inline bool CollisionSolid::has_effective_normal(void) const
  bool return_value = ((*(const CollisionSolid*)local_this).has_effective_normal)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_has_effective_normal_13_comment =
  "C++ Interface:\n"
  "has_effective_normal(CollisionSolid self)\n"
  "\n"
  "/**\n"
  " * Returns true if a special normal was set by set_effective_normal(), false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_CollisionSolid_has_effective_normal_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 const &CollisionSolid::get_effective_normal(void) const
 */
static PyObject *Dtool_CollisionSolid_get_effective_normal_14(PyObject *self, PyObject *) {
  CollisionSolid *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionSolid)) {
    return nullptr;
  }
  // 1-inline LVector3 const &CollisionSolid::get_effective_normal(void) const
  LVector3 const *return_value = &(((*(const CollisionSolid*)local_this).get_effective_normal)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_get_effective_normal_14_comment =
  "C++ Interface:\n"
  "get_effective_normal(CollisionSolid self)\n"
  "\n"
  "/**\n"
  " * Returns the normal that was set by set_effective_normal().  It is an error\n"
  " * to call this unless has_effective_normal() returns true.\n"
  " */";
#else
static const char *Dtool_CollisionSolid_get_effective_normal_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionSolid::set_respect_effective_normal(bool respect_effective_normal)
 */
static PyObject *Dtool_CollisionSolid_set_respect_effective_normal_15(PyObject *self, PyObject *arg) {
  CollisionSolid *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSolid, (void **)&local_this, "CollisionSolid.set_respect_effective_normal")) {
    return nullptr;
  }
  // 1-inline void CollisionSolid::set_respect_effective_normal(bool respect_effective_normal)
  ((*local_this).set_respect_effective_normal)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_respect_effective_normal(const CollisionSolid self, bool respect_effective_normal)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_set_respect_effective_normal_15_comment =
  "C++ Interface:\n"
  "set_respect_effective_normal(const CollisionSolid self, bool respect_effective_normal)\n"
  "\n"
  "/**\n"
  " * This is only meaningful for CollisionSolids that will be added to a\n"
  " * traverser as colliders.  It is normally true, but if set false, it means\n"
  " * that this particular solid does not care about the \"effective\" normal of\n"
  " * other solids it meets, but rather always uses the true normal.\n"
  " */";
#else
static const char *Dtool_CollisionSolid_set_respect_effective_normal_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionSolid::get_respect_effective_normal(void) const
 */
static PyObject *Dtool_CollisionSolid_get_respect_effective_normal_16(PyObject *self, PyObject *) {
  CollisionSolid *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionSolid)) {
    return nullptr;
  }
  // 1-inline bool CollisionSolid::get_respect_effective_normal(void) const
  bool return_value = ((*(const CollisionSolid*)local_this).get_respect_effective_normal)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_get_respect_effective_normal_16_comment =
  "C++ Interface:\n"
  "get_respect_effective_normal(CollisionSolid self)\n"
  "\n"
  "/**\n"
  " * See set_respect_effective_normal().\n"
  " */";
#else
static const char *Dtool_CollisionSolid_get_respect_effective_normal_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConstPointerTo< BoundingVolume > CollisionSolid::get_bounds(void) const
 */
static PyObject *Dtool_CollisionSolid_get_bounds_18(PyObject *self, PyObject *) {
  CollisionSolid *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionSolid)) {
    return nullptr;
  }
  // 1-ConstPointerTo< BoundingVolume > CollisionSolid::get_bounds(void) const
  ConstPointerTo< BoundingVolume > return_value = ((*(const CollisionSolid*)local_this).get_bounds)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  BoundingVolume const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingVolume, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_get_bounds_18_comment =
  "C++ Interface:\n"
  "get_bounds(CollisionSolid self)\n"
  "\n"
  "/**\n"
  " * Returns the solid's bounding volume.\n"
  " */";
#else
static const char *Dtool_CollisionSolid_get_bounds_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionSolid::set_bounds(BoundingVolume const &bounding_volume)
 */
static PyObject *Dtool_CollisionSolid_set_bounds_19(PyObject *self, PyObject *arg) {
  CollisionSolid *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSolid, (void **)&local_this, "CollisionSolid.set_bounds")) {
    return nullptr;
  }
  // 1-void CollisionSolid::set_bounds(BoundingVolume const &bounding_volume)
  BoundingVolume const *arg_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BoundingVolume, 1, "CollisionSolid.set_bounds", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_bounds)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bounds(const CollisionSolid self, const BoundingVolume bounding_volume)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_set_bounds_19_comment =
  "C++ Interface:\n"
  "set_bounds(const CollisionSolid self, const BoundingVolume bounding_volume)\n"
  "\n"
  "/**\n"
  " * Returns the solid's bounding volume.\n"
  " */";
#else
static const char *Dtool_CollisionSolid_set_bounds_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void CollisionSolid::output(std::ostream &out) const
 */
static PyObject *Dtool_CollisionSolid_output_22(PyObject *self, PyObject *arg) {
  CollisionSolid *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionSolid)) {
    return nullptr;
  }
  // 1-virtual void CollisionSolid::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "CollisionSolid.output", false, true);
  if (arg_this != nullptr) {
    ((*(const CollisionSolid*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CollisionSolid self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_output_22_comment =
  "C++ Interface:\n"
  "output(CollisionSolid self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSolid_output_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void CollisionSolid::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_CollisionSolid_write_23(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionSolid *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionSolid)) {
    return nullptr;
  }
  // 1-virtual void CollisionSolid::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "CollisionSolid.write", false, true);
    if (param1_this != nullptr) {
      ((*(const CollisionSolid*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(CollisionSolid self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_write_23_comment =
  "C++ Interface:\n"
  "write(CollisionSolid self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSolid_write_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionSolid::get_class_type(void)
 */
static PyObject *Dtool_CollisionSolid_get_class_type_24(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionSolid::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionSolid::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSolid_get_class_type_24_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionSolid_get_class_type_24_comment = nullptr;
#endif

static PyObject *Dtool_CollisionSolid_collision_origin_Getter(PyObject *self, void *) {
  const CollisionSolid *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual LPoint3 CollisionSolid::get_collision_origin(void) const = 0
  LPoint3 *return_value = new LPoint3(((*(const CollisionSolid*)local_this).get_collision_origin)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

static PyObject *Dtool_CollisionSolid_tangible_Getter(PyObject *self, void *) {
  const CollisionSolid *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool CollisionSolid::is_tangible(void) const
  bool return_value = ((*(const CollisionSolid*)local_this).is_tangible)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionSolid_tangible_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionSolid *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSolid, (void **)&local_this, "CollisionSolid.tangible")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete tangible attribute");
    return -1;
  }
  // 1-inline void CollisionSolid::set_tangible(bool tangible)
  ((*local_this).set_tangible)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_tangible(const CollisionSolid self, bool tangible)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionSolid_respect_effective_normal_Getter(PyObject *self, void *) {
  const CollisionSolid *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool CollisionSolid::get_respect_effective_normal(void) const
  bool return_value = ((*(const CollisionSolid*)local_this).get_respect_effective_normal)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionSolid_respect_effective_normal_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionSolid *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSolid, (void **)&local_this, "CollisionSolid.respect_effective_normal")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete respect_effective_normal attribute");
    return -1;
  }
  // 1-inline void CollisionSolid::set_respect_effective_normal(bool respect_effective_normal)
  ((*local_this).set_respect_effective_normal)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_respect_effective_normal(const CollisionSolid self, bool respect_effective_normal)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionSolid_bounds_Getter(PyObject *self, void *) {
  const CollisionSolid *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return nullptr;
  }

  // 1-ConstPointerTo< BoundingVolume > CollisionSolid::get_bounds(void) const
  ConstPointerTo< BoundingVolume > return_value = ((*(const CollisionSolid*)local_this).get_bounds)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  BoundingVolume const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BoundingVolume, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

static int Dtool_CollisionSolid_bounds_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionSolid *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSolid, (void **)&local_this, "CollisionSolid.bounds")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete bounds attribute");
    return -1;
  }
  // 1-void CollisionSolid::set_bounds(BoundingVolume const &bounding_volume)
  BoundingVolume const *arg_this = (BoundingVolume *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BoundingVolume, 1, "CollisionSolid.set_bounds", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_bounds)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bounds(const CollisionSolid self, const BoundingVolume bounding_volume)\n");
  }
  return -1;
}

static int Dtool_Init_CollisionSolid(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CollisionSolid(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionSolid) {
    printf("CollisionSolid ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionSolid *local_this = (CollisionSolid *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionSolid) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionSolid(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionSolid*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionSolid*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionSolid*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionSolid*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionSolid*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionSolid*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionBox
 */
/**
 * Python function wrapper for:
 * inline int CollisionBox::get_num_points(void) const
 */
static PyObject *Dtool_CollisionBox_get_num_points_27(PyObject *self, PyObject *) {
  CollisionBox *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionBox)) {
    return nullptr;
  }
  // 1-inline int CollisionBox::get_num_points(void) const
  int return_value = ((*(const CollisionBox*)local_this).get_num_points)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_num_points_27_comment =
  "C++ Interface:\n"
  "get_num_points(CollisionBox self)\n"
  "\n"
  "/**\n"
  " * Returns 8: the number of vertices of a rectangular solid.\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_num_points_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 CollisionBox::get_point_aabb(int n) const
 */
static PyObject *Dtool_CollisionBox_get_point_aabb_28(PyObject *self, PyObject *arg) {
  CollisionBox *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionBox)) {
    return nullptr;
  }
  // 1-inline LPoint3 CollisionBox::get_point_aabb(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3 *return_value = new LPoint3(((*(const CollisionBox*)local_this).get_point_aabb)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point_aabb(CollisionBox self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_point_aabb_28_comment =
  "C++ Interface:\n"
  "get_point_aabb(CollisionBox self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth vertex of the Axis Aligned Bounding Box.\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_point_aabb_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 CollisionBox::get_point(int n) const
 */
static PyObject *Dtool_CollisionBox_get_point_29(PyObject *self, PyObject *arg) {
  CollisionBox *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionBox)) {
    return nullptr;
  }
  // 1-inline LPoint3 CollisionBox::get_point(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPoint3 *return_value = new LPoint3(((*(const CollisionBox*)local_this).get_point)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(CollisionBox self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_point_29_comment =
  "C++ Interface:\n"
  "get_point(CollisionBox self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth vertex of the OBB.\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_point_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int CollisionBox::get_num_planes(void) const
 */
static PyObject *Dtool_CollisionBox_get_num_planes_30(PyObject *self, PyObject *) {
  CollisionBox *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionBox)) {
    return nullptr;
  }
  // 1-inline int CollisionBox::get_num_planes(void) const
  int return_value = ((*(const CollisionBox*)local_this).get_num_planes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_num_planes_30_comment =
  "C++ Interface:\n"
  "get_num_planes(CollisionBox self)\n"
  "\n"
  "/**\n"
  " * Returns 6: the number of faces of a rectangular solid.\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_num_planes_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPlane CollisionBox::set_plane(int n) const
 */
static PyObject *Dtool_CollisionBox_set_plane_31(PyObject *self, PyObject *arg) {
  CollisionBox *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionBox)) {
    return nullptr;
  }
  // 1-inline LPlane CollisionBox::set_plane(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPlane *return_value = new LPlane(((*(const CollisionBox*)local_this).set_plane)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_plane(CollisionBox self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_set_plane_31_comment =
  "C++ Interface:\n"
  "set_plane(CollisionBox self, int n)\n"
  "\n"
  "/**\n"
  " * Creates the nth face of the rectangular solid.\n"
  " */";
#else
static const char *Dtool_CollisionBox_set_plane_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPlane CollisionBox::get_plane(int n) const
 */
static PyObject *Dtool_CollisionBox_get_plane_32(PyObject *self, PyObject *arg) {
  CollisionBox *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionBox)) {
    return nullptr;
  }
  // 1-inline LPlane CollisionBox::get_plane(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LPlane *return_value = new LPlane(((*(const CollisionBox*)local_this).get_plane)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_plane(CollisionBox self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_plane_32_comment =
  "C++ Interface:\n"
  "get_plane(CollisionBox self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth face of the rectangular solid.\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_plane_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionBox::set_center(LPoint3 const &center)
 * inline void CollisionBox::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_CollisionBox_set_center_33(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionBox *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionBox, (void **)&local_this, "CollisionBox.set_center")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "center")) {
        // 1-inline void CollisionBox::set_center(LPoint3 const &center)
        LPoint3f arg_local;
        LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "CollisionBox.set_center", "LPoint3f");
        }
        ((*local_this).set_center)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void CollisionBox::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_center", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_center)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_center() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_center(const CollisionBox self, const LPoint3f center)\n"
      "set_center(const CollisionBox self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_set_center_33_comment =
  "C++ Interface:\n"
  "set_center(const CollisionBox self, const LPoint3f center)\n"
  "set_center(const CollisionBox self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionBox_set_center_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionBox::get_center(void) const
 */
static PyObject *Dtool_CollisionBox_get_center_34(PyObject *self, PyObject *) {
  CollisionBox *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionBox)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &CollisionBox::get_center(void) const
  LPoint3 const *return_value = &(((*(const CollisionBox*)local_this).get_center)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_center_34_comment =
  "C++ Interface:\n"
  "get_center(CollisionBox self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_center_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionBox::get_min(void) const
 */
static PyObject *Dtool_CollisionBox_get_min_35(PyObject *self, PyObject *) {
  CollisionBox *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionBox)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &CollisionBox::get_min(void) const
  LPoint3 const *return_value = &(((*(const CollisionBox*)local_this).get_min)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_min_35_comment =
  "C++ Interface:\n"
  "get_min(CollisionBox self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_min_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionBox::get_max(void) const
 */
static PyObject *Dtool_CollisionBox_get_max_36(PyObject *self, PyObject *) {
  CollisionBox *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionBox)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &CollisionBox::get_max(void) const
  LPoint3 const *return_value = &(((*(const CollisionBox*)local_this).get_max)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_max_36_comment =
  "C++ Interface:\n"
  "get_max(CollisionBox self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_max_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 CollisionBox::get_dimensions(void) const
 */
static PyObject *Dtool_CollisionBox_get_dimensions_37(PyObject *self, PyObject *) {
  CollisionBox *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionBox)) {
    return nullptr;
  }
  // 1-inline LVector3 CollisionBox::get_dimensions(void) const
  LVector3 *return_value = new LVector3(((*(const CollisionBox*)local_this).get_dimensions)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_dimensions_37_comment =
  "C++ Interface:\n"
  "get_dimensions(CollisionBox self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionBox_get_dimensions_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionBox::get_class_type(void)
 */
static PyObject *Dtool_CollisionBox_get_class_type_45(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionBox::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionBox::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionBox_get_class_type_45_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionBox_get_class_type_45_comment = nullptr;
#endif

static PyObject *Dtool_CollisionBox_center_Getter(PyObject *self, void *) {
  const CollisionBox *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint3 const &CollisionBox::get_center(void) const
  LPoint3 const *return_value = &(((*(const CollisionBox*)local_this).get_center)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static PyObject *Dtool_CollisionBox_min_Getter(PyObject *self, void *) {
  const CollisionBox *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint3 const &CollisionBox::get_min(void) const
  LPoint3 const *return_value = &(((*(const CollisionBox*)local_this).get_min)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static PyObject *Dtool_CollisionBox_max_Getter(PyObject *self, void *) {
  const CollisionBox *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint3 const &CollisionBox::get_max(void) const
  LPoint3 const *return_value = &(((*(const CollisionBox*)local_this).get_max)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static PyObject *Dtool_CollisionBox_dimensions_Getter(PyObject *self, void *) {
  const CollisionBox *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionBox, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVector3 CollisionBox::get_dimensions(void) const
  LVector3 *return_value = new LVector3(((*(const CollisionBox*)local_this).get_dimensions)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

/**
 * Python function wrapper for:
 * inline explicit CollisionBox::CollisionBox(LPoint3 const &min, LPoint3 const &max)
 * inline explicit CollisionBox::CollisionBox(LPoint3 const &center, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static int Dtool_Init_CollisionBox(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline explicit CollisionBox::CollisionBox(LPoint3 const &min, LPoint3 const &max)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"min", "max", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:CollisionBox", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionBox.CollisionBox", "LPoint3f");
          return -1;
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "CollisionBox.CollisionBox", "LPoint3f");
          return -1;
        }
        CollisionBox *return_value = new CollisionBox(*param0_this, *param1_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionBox, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline explicit CollisionBox::CollisionBox(LPoint3 const &center, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      PyObject *param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"center", "x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:CollisionBox", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionBox.CollisionBox", "LPoint3f");
          return -1;
        }
        CollisionBox *return_value = new CollisionBox(*param0_this, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionBox, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionBox() takes 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionBox(const LPoint3f min, const LPoint3f max)\n"
      "CollisionBox(const LPoint3f center, float x, float y, float z)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionBox(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionBox) {
    printf("CollisionBox ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionBox *local_this = (CollisionBox *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionBox) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionBox(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionBox) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionBox*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionBox*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionBox*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionBox*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionBox*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionBox*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionBox*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionCapsule
 */
/**
 * Python function wrapper for:
 * inline void CollisionCapsule::set_point_a(LPoint3 const &a)
 * inline void CollisionCapsule::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_CollisionCapsule_set_point_a_49(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionCapsule *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionCapsule, (void **)&local_this, "CollisionCapsule.set_point_a")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "a")) {
        // 1-inline void CollisionCapsule::set_point_a(LPoint3 const &a)
        LPoint3f arg_local;
        LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "CollisionCapsule.set_point_a", "LPoint3f");
        }
        ((*local_this).set_point_a)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void CollisionCapsule::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_point_a", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_point_a)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_point_a() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point_a(const CollisionCapsule self, const LPoint3f a)\n"
      "set_point_a(const CollisionCapsule self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionCapsule_set_point_a_49_comment =
  "C++ Interface:\n"
  "set_point_a(const CollisionCapsule self, const LPoint3f a)\n"
  "set_point_a(const CollisionCapsule self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionCapsule_set_point_a_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionCapsule::get_point_a(void) const
 */
static PyObject *Dtool_CollisionCapsule_get_point_a_50(PyObject *self, PyObject *) {
  CollisionCapsule *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionCapsule)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &CollisionCapsule::get_point_a(void) const
  LPoint3 const *return_value = &(((*(const CollisionCapsule*)local_this).get_point_a)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionCapsule_get_point_a_50_comment =
  "C++ Interface:\n"
  "get_point_a(CollisionCapsule self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionCapsule_get_point_a_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionCapsule::set_point_b(LPoint3 const &b)
 * inline void CollisionCapsule::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_CollisionCapsule_set_point_b_51(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionCapsule *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionCapsule, (void **)&local_this, "CollisionCapsule.set_point_b")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "b")) {
        // 1-inline void CollisionCapsule::set_point_b(LPoint3 const &b)
        LPoint3f arg_local;
        LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "CollisionCapsule.set_point_b", "LPoint3f");
        }
        ((*local_this).set_point_b)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void CollisionCapsule::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_point_b", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_point_b)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_point_b() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point_b(const CollisionCapsule self, const LPoint3f b)\n"
      "set_point_b(const CollisionCapsule self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionCapsule_set_point_b_51_comment =
  "C++ Interface:\n"
  "set_point_b(const CollisionCapsule self, const LPoint3f b)\n"
  "set_point_b(const CollisionCapsule self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionCapsule_set_point_b_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionCapsule::get_point_b(void) const
 */
static PyObject *Dtool_CollisionCapsule_get_point_b_52(PyObject *self, PyObject *) {
  CollisionCapsule *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionCapsule)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &CollisionCapsule::get_point_b(void) const
  LPoint3 const *return_value = &(((*(const CollisionCapsule*)local_this).get_point_b)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionCapsule_get_point_b_52_comment =
  "C++ Interface:\n"
  "get_point_b(CollisionCapsule self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionCapsule_get_point_b_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionCapsule::set_radius(PN_stdfloat radius)
 */
static PyObject *Dtool_CollisionCapsule_set_radius_53(PyObject *self, PyObject *arg) {
  CollisionCapsule *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionCapsule, (void **)&local_this, "CollisionCapsule.set_radius")) {
    return nullptr;
  }
  // 1-inline void CollisionCapsule::set_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_radius)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const CollisionCapsule self, float radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionCapsule_set_radius_53_comment =
  "C++ Interface:\n"
  "set_radius(const CollisionCapsule self, float radius)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionCapsule_set_radius_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionCapsule::get_radius(void) const
 */
static PyObject *Dtool_CollisionCapsule_get_radius_54(PyObject *self, PyObject *) {
  CollisionCapsule *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionCapsule)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat CollisionCapsule::get_radius(void) const
  PN_stdfloat return_value = ((*(const CollisionCapsule*)local_this).get_radius)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionCapsule_get_radius_54_comment =
  "C++ Interface:\n"
  "get_radius(CollisionCapsule self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionCapsule_get_radius_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionCapsule::get_class_type(void)
 */
static PyObject *Dtool_CollisionCapsule_get_class_type_60(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionCapsule::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionCapsule::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionCapsule_get_class_type_60_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionCapsule_get_class_type_60_comment = nullptr;
#endif

static PyObject *Dtool_CollisionCapsule_point_a_Getter(PyObject *self, void *) {
  const CollisionCapsule *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionCapsule, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint3 const &CollisionCapsule::get_point_a(void) const
  LPoint3 const *return_value = &(((*(const CollisionCapsule*)local_this).get_point_a)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_CollisionCapsule_point_a_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionCapsule *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionCapsule, (void **)&local_this, "CollisionCapsule.point_a")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete point_a attribute");
    return -1;
  }
  // 1-inline void CollisionCapsule::set_point_a(LPoint3 const &a)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionCapsule.set_point_a", "LPoint3f");
    return -1;
  }
  ((*local_this).set_point_a)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_point_a(const CollisionCapsule self, const LPoint3f a)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionCapsule_point_b_Getter(PyObject *self, void *) {
  const CollisionCapsule *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionCapsule, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint3 const &CollisionCapsule::get_point_b(void) const
  LPoint3 const *return_value = &(((*(const CollisionCapsule*)local_this).get_point_b)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_CollisionCapsule_point_b_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionCapsule *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionCapsule, (void **)&local_this, "CollisionCapsule.point_b")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete point_b attribute");
    return -1;
  }
  // 1-inline void CollisionCapsule::set_point_b(LPoint3 const &b)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionCapsule.set_point_b", "LPoint3f");
    return -1;
  }
  ((*local_this).set_point_b)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_point_b(const CollisionCapsule self, const LPoint3f b)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionCapsule_radius_Getter(PyObject *self, void *) {
  const CollisionCapsule *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionCapsule, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat CollisionCapsule::get_radius(void) const
  PN_stdfloat return_value = ((*(const CollisionCapsule*)local_this).get_radius)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionCapsule_radius_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionCapsule *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionCapsule, (void **)&local_this, "CollisionCapsule.radius")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete radius attribute");
    return -1;
  }
  // 1-inline void CollisionCapsule::set_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_radius)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_radius(const CollisionCapsule self, float radius)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline explicit CollisionCapsule::CollisionCapsule(LPoint3 const &a, LPoint3 const &db, PN_stdfloat radius)
 * inline explicit CollisionCapsule::CollisionCapsule(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz, PN_stdfloat radius)
 */
static int Dtool_Init_CollisionCapsule(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-inline explicit CollisionCapsule::CollisionCapsule(LPoint3 const &a, LPoint3 const &db, PN_stdfloat radius)
      PyObject *param0;
      PyObject *param1;
      float param2;
      static const char *keyword_list[] = {"a", "db", "radius", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOf:CollisionCapsule", (char **)keyword_list, &param0, &param1, &param2)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionCapsule.CollisionCapsule", "LPoint3f");
          return -1;
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "CollisionCapsule.CollisionCapsule", "LPoint3f");
          return -1;
        }
        CollisionCapsule *return_value = new CollisionCapsule(*param0_this, *param1_this, (PN_stdfloat)param2);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionCapsule, true, false);
      }
    }
    break;
  case 7:
    {
      // 1-inline explicit CollisionCapsule::CollisionCapsule(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz, PN_stdfloat radius)
      float param0;
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"ax", "ay", "az", "bx", "by", "bz", "radius", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fffffff:CollisionCapsule", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
        CollisionCapsule *return_value = new CollisionCapsule((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5, (PN_stdfloat)param6);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionCapsule, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionCapsule() takes 3 or 7 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionCapsule(const LPoint3f a, const LPoint3f db, float radius)\n"
      "CollisionCapsule(float ax, float ay, float az, float bx, float by, float bz, float radius)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionCapsule(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionCapsule) {
    printf("CollisionCapsule ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionCapsule *local_this = (CollisionCapsule *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionCapsule) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionCapsule(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionCapsule) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionCapsule*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionCapsule*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionCapsule*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionCapsule*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionCapsule*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionCapsule*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionCapsule*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionHandler
 */
/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandler::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandler_get_class_type_64(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandler::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionHandler::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandler_get_class_type_64_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandler_get_class_type_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CollisionHandler::CollisionHandler(CollisionHandler const &) = default
 */
static int Dtool_Init_CollisionHandler(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CollisionHandler() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline CollisionHandler::CollisionHandler(CollisionHandler const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    CollisionHandler const *param0_this = (CollisionHandler *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_CollisionHandler, 0, "CollisionHandler.CollisionHandler", true, true);
    if (param0_this != nullptr) {
      CollisionHandler *return_value = new CollisionHandler(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandler, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionHandler(const CollisionHandler param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionHandler(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionHandler) {
    printf("CollisionHandler ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionHandler *local_this = (CollisionHandler *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionHandler) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionHandler(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandler*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionNode
 */
/**
 * Python function wrapper for:
 * inline void CollisionNode::set_collide_mask(CollideMask mask)
 */
static PyObject *Dtool_CollisionNode_set_collide_mask_70(PyObject *self, PyObject *arg) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.set_collide_mask")) {
    return nullptr;
  }
  // 1-inline void CollisionNode::set_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionNode.set_collide_mask", "BitMask");
  }
  ((*local_this).set_collide_mask)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collide_mask(const CollisionNode self, BitMask mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_set_collide_mask_70_comment =
  "C++ Interface:\n"
  "set_collide_mask(const CollisionNode self, BitMask mask)\n"
  "\n"
  "/**\n"
  " * Simultaneously sets both the \"from\" and \"into\" CollideMask values to the\n"
  " * same thing.\n"
  " */";
#else
static const char *Dtool_CollisionNode_set_collide_mask_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionNode::set_from_collide_mask(CollideMask mask)
 */
static PyObject *Dtool_CollisionNode_set_from_collide_mask_71(PyObject *self, PyObject *arg) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.set_from_collide_mask")) {
    return nullptr;
  }
  // 1-void CollisionNode::set_from_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionNode.set_from_collide_mask", "BitMask");
  }
  ((*local_this).set_from_collide_mask)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_collide_mask(const CollisionNode self, BitMask mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_set_from_collide_mask_71_comment =
  "C++ Interface:\n"
  "set_from_collide_mask(const CollisionNode self, BitMask mask)\n"
  "\n"
  "/**\n"
  " * Sets the \"from\" CollideMask.  In order for a collision to be detected from\n"
  " * this object into another object, the intersection of this object's \"from\"\n"
  " * mask and the other object's \"into\" mask must be nonzero.\n"
  " */";
#else
static const char *Dtool_CollisionNode_set_from_collide_mask_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionNode::set_into_collide_mask(CollideMask mask)
 */
static PyObject *Dtool_CollisionNode_set_into_collide_mask_72(PyObject *self, PyObject *arg) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.set_into_collide_mask")) {
    return nullptr;
  }
  // 1-inline void CollisionNode::set_into_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionNode.set_into_collide_mask", "BitMask");
  }
  ((*local_this).set_into_collide_mask)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_into_collide_mask(const CollisionNode self, BitMask mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_set_into_collide_mask_72_comment =
  "C++ Interface:\n"
  "set_into_collide_mask(const CollisionNode self, BitMask mask)\n"
  "\n"
  "/**\n"
  " * Sets the \"into\" CollideMask.  In order for a collision to be detected from\n"
  " * another object into this object, the intersection of the other object's\n"
  " * \"from\" mask and this object's \"into\" mask must be nonzero.\n"
  " */";
#else
static const char *Dtool_CollisionNode_set_into_collide_mask_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CollideMask CollisionNode::get_from_collide_mask(void) const
 */
static PyObject *Dtool_CollisionNode_get_from_collide_mask_73(PyObject *self, PyObject *) {
  CollisionNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionNode)) {
    return nullptr;
  }
  // 1-inline CollideMask CollisionNode::get_from_collide_mask(void) const
  CollideMask *return_value = new CollideMask(((*(const CollisionNode*)local_this).get_from_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_get_from_collide_mask_73_comment =
  "C++ Interface:\n"
  "get_from_collide_mask(CollisionNode self)\n"
  "\n"
  "/**\n"
  " * Returns the current \"from\" CollideMask.  In order for a collision to be\n"
  " * detected from this object into another object, the intersection of this\n"
  " * object's \"from\" mask and the other object's \"into\" mask must be nonzero.\n"
  " */";
#else
static const char *Dtool_CollisionNode_get_from_collide_mask_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CollideMask CollisionNode::get_into_collide_mask(void) const
 */
static PyObject *Dtool_CollisionNode_get_into_collide_mask_74(PyObject *self, PyObject *) {
  CollisionNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionNode)) {
    return nullptr;
  }
  // 1-inline CollideMask CollisionNode::get_into_collide_mask(void) const
  CollideMask *return_value = new CollideMask(((*(const CollisionNode*)local_this).get_into_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_get_into_collide_mask_74_comment =
  "C++ Interface:\n"
  "get_into_collide_mask(CollisionNode self)\n"
  "\n"
  "/**\n"
  " * Returns the current \"into\" CollideMask.  In order for a collision to be\n"
  " * detected from another object into this object, the intersection of the\n"
  " * other object's \"from\" mask and this object's \"into\" mask must be nonzero.\n"
  " */";
#else
static const char *Dtool_CollisionNode_get_into_collide_mask_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionNode::clear_solids(void)
 */
static PyObject *Dtool_CollisionNode_clear_solids_80(PyObject *self, PyObject *) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.clear_solids")) {
    return nullptr;
  }
  // 1-inline void CollisionNode::clear_solids(void)
  ((*local_this).clear_solids)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_clear_solids_80_comment =
  "C++ Interface:\n"
  "clear_solids(const CollisionNode self)\n"
  "\n"
  "/**\n"
  " * Removes all solids from the node.\n"
  " */";
#else
static const char *Dtool_CollisionNode_clear_solids_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t CollisionNode::get_num_solids(void) const
 */
static PyObject *Dtool_CollisionNode_get_num_solids_81(PyObject *self, PyObject *) {
  CollisionNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionNode)) {
    return nullptr;
  }
  // 1-inline std::size_t CollisionNode::get_num_solids(void) const
  std::size_t return_value = ((*(const CollisionNode*)local_this).get_num_solids)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_get_num_solids_81_comment =
  "C++ Interface:\n"
  "get_num_solids(CollisionNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionNode_get_num_solids_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< CollisionSolid > CollisionNode::get_solid(std::size_t n) const
 */
static PyObject *Dtool_CollisionNode_get_solid_82(PyObject *self, PyObject *arg) {
  CollisionNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionNode)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< CollisionSolid > CollisionNode::get_solid(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ConstPointerTo< CollisionSolid > return_value = ((*(const CollisionNode*)local_this).get_solid)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    CollisionSolid const *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_CollisionSolid, true, true, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_solid(CollisionNode self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_get_solid_82_comment =
  "C++ Interface:\n"
  "get_solid(CollisionNode self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionNode_get_solid_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< CollisionSolid > CollisionNode::modify_solid(std::size_t n)
 */
static PyObject *Dtool_CollisionNode_modify_solid_84(PyObject *self, PyObject *arg) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.modify_solid")) {
    return nullptr;
  }
  // 1-inline PointerTo< CollisionSolid > CollisionNode::modify_solid(std::size_t n)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    PointerTo< CollisionSolid > return_value = ((*local_this).modify_solid)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    CollisionSolid *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_CollisionSolid, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "modify_solid(const CollisionNode self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_modify_solid_84_comment =
  "C++ Interface:\n"
  "modify_solid(const CollisionNode self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionNode_modify_solid_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionNode::set_solid(std::size_t n, CollisionSolid *solid)
 */
static PyObject *Dtool_CollisionNode_set_solid_85(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.set_solid")) {
    return nullptr;
  }
  // 1-inline void CollisionNode::set_solid(std::size_t n, CollisionSolid *solid)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "solid", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_solid", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    CollisionSolid *param2_this = (CollisionSolid *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_CollisionSolid, 2, "CollisionNode.set_solid", false, true);
    if (param2_this != nullptr) {
      ((*local_this).set_solid)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_solid(const CollisionNode self, int n, CollisionSolid solid)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_set_solid_85_comment =
  "C++ Interface:\n"
  "set_solid(const CollisionNode self, int n, CollisionSolid solid)\n"
  "\n"
  "/**\n"
  " * Replaces the solid with the indicated index.\n"
  " */";
#else
static const char *Dtool_CollisionNode_set_solid_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionNode::insert_solid(std::size_t n, CollisionSolid const *solid)
 */
static PyObject *Dtool_CollisionNode_insert_solid_86(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.insert_solid")) {
    return nullptr;
  }
  // 1-inline void CollisionNode::insert_solid(std::size_t n, CollisionSolid const *solid)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "solid", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:insert_solid", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    CollisionSolid const *param2_this = (CollisionSolid *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_CollisionSolid, 2, "CollisionNode.insert_solid", true, true);
    if (param2_this != nullptr) {
      ((*local_this).insert_solid)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "insert_solid(const CollisionNode self, int n, const CollisionSolid solid)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_insert_solid_86_comment =
  "C++ Interface:\n"
  "insert_solid(const CollisionNode self, int n, const CollisionSolid solid)\n"
  "\n"
  "/**\n"
  " * Inserts the indicated solid to the node at the indicated position.\n"
  " */";
#else
static const char *Dtool_CollisionNode_insert_solid_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionNode::remove_solid(std::size_t n)
 */
static PyObject *Dtool_CollisionNode_remove_solid_87(PyObject *self, PyObject *arg) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.remove_solid")) {
    return nullptr;
  }
  // 1-inline void CollisionNode::remove_solid(std::size_t n)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).remove_solid)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_solid(const CollisionNode self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_remove_solid_87_comment =
  "C++ Interface:\n"
  "remove_solid(const CollisionNode self, int n)\n"
  "\n"
  "/**\n"
  " * Removes the solid with the indicated index.  This will shift all subsequent\n"
  " * indices down by one.\n"
  " */";
#else
static const char *Dtool_CollisionNode_remove_solid_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t CollisionNode::add_solid(CollisionSolid const *solid)
 */
static PyObject *Dtool_CollisionNode_add_solid_88(PyObject *self, PyObject *arg) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.add_solid")) {
    return nullptr;
  }
  // 1-inline std::size_t CollisionNode::add_solid(CollisionSolid const *solid)
  CollisionSolid const *arg_this = (CollisionSolid *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CollisionSolid, 1, "CollisionNode.add_solid", true, true);
  if (arg_this != nullptr) {
    std::size_t return_value = ((*local_this).add_solid)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_solid(const CollisionNode self, const CollisionSolid solid)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_add_solid_88_comment =
  "C++ Interface:\n"
  "add_solid(const CollisionNode self, const CollisionSolid solid)\n"
  "\n"
  "/**\n"
  " * Adds the indicated solid to the node.  Returns the index of the new solid\n"
  " * within the node's list of solids.\n"
  " */";
#else
static const char *Dtool_CollisionNode_add_solid_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int CollisionNode::get_collider_sort(void) const
 */
static PyObject *Dtool_CollisionNode_get_collider_sort_91(PyObject *self, PyObject *) {
  CollisionNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionNode)) {
    return nullptr;
  }
  // 1-inline int CollisionNode::get_collider_sort(void) const
  int return_value = ((*(const CollisionNode*)local_this).get_collider_sort)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_get_collider_sort_91_comment =
  "C++ Interface:\n"
  "get_collider_sort(CollisionNode self)\n"
  "\n"
  "/**\n"
  " * Returns the collider_sort value that has been set for this particular node.\n"
  " * See set_collider_sort().\n"
  " */";
#else
static const char *Dtool_CollisionNode_get_collider_sort_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionNode::set_collider_sort(int sort)
 */
static PyObject *Dtool_CollisionNode_set_collider_sort_92(PyObject *self, PyObject *arg) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.set_collider_sort")) {
    return nullptr;
  }
  // 1-inline void CollisionNode::set_collider_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_collider_sort)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collider_sort(const CollisionNode self, int sort)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_set_collider_sort_92_comment =
  "C++ Interface:\n"
  "set_collider_sort(const CollisionNode self, int sort)\n"
  "\n"
  "/**\n"
  " * Sets a particular collider_sort value on this node.  This controls the\n"
  " * order in which colliders (that is, \"from nodes\") are grouped together for\n"
  " * the collision traversal.\n"
  " *\n"
  " * If there are 32 or fewer colliders added to any particular\n"
  " * CollisionTraverser, then this value has no meaning.  It is only useful if\n"
  " * there are many colliders, which may force the CollisionTraverser to make\n"
  " * multiple passes through the data; in that case, it may be a useful\n"
  " * optimization to group colliders that have similar bounding volumes together\n"
  " * (by giving them similar sort values).\n"
  " */";
#else
static const char *Dtool_CollisionNode_set_collider_sort_92_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline CollideMask CollisionNode::get_default_collide_mask(void)
 */
static PyObject *Dtool_CollisionNode_get_default_collide_mask_95(PyObject *, PyObject *) {
  // 1-static inline CollideMask CollisionNode::get_default_collide_mask(void)
  CollideMask *return_value = new CollideMask((CollisionNode::get_default_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_get_default_collide_mask_95_comment =
  "C++ Interface:\n"
  "get_default_collide_mask()\n"
  "\n"
  "/**\n"
  " * Returns the default into_collide_mask assigned to new CollisionNodes.\n"
  " */";
#else
static const char *Dtool_CollisionNode_get_default_collide_mask_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionNode::get_class_type(void)
 */
static PyObject *Dtool_CollisionNode_get_class_type_97(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionNode_get_class_type_97_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionNode_get_class_type_97_comment = nullptr;
#endif

static PyObject *Dtool_CollisionNode_from_collide_mask_Getter(PyObject *self, void *) {
  const CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CollideMask CollisionNode::get_from_collide_mask(void) const
  CollideMask *return_value = new CollideMask(((*(const CollisionNode*)local_this).get_from_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static int Dtool_CollisionNode_from_collide_mask_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.from_collide_mask")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete from_collide_mask attribute");
    return -1;
  }
  // 1-void CollisionNode::set_from_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionNode.set_from_collide_mask", "BitMask");
    return -1;
  }
  ((*local_this).set_from_collide_mask)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_from_collide_mask(const CollisionNode self, BitMask mask)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionNode_into_collide_mask_Getter(PyObject *self, void *) {
  const CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CollideMask CollisionNode::get_into_collide_mask(void) const
  CollideMask *return_value = new CollideMask(((*(const CollisionNode*)local_this).get_into_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

static int Dtool_CollisionNode_into_collide_mask_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.into_collide_mask")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete into_collide_mask attribute");
    return -1;
  }
  // 1-inline void CollisionNode::set_into_collide_mask(CollideMask mask)
  BitMask< uint32_t, 32 > arg_local;
  CollideMask *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionNode.set_into_collide_mask", "BitMask");
    return -1;
  }
  ((*local_this).set_into_collide_mask)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_into_collide_mask(const CollisionNode self, BitMask mask)\n");
  }
  return -1;
}

/**
 * sequence length function for property CollisionNode::solids
 */
static Py_ssize_t Dtool_CollisionNode_solids_Len(PyObject *self) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_solids)();
}

/**
 * sequence getter for property CollisionNode::solids
 */
static PyObject *Dtool_CollisionNode_solids_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionNode, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_solids)()) {
    PyErr_SetString(PyExc_IndexError, "CollisionNode.solids[] index out of range");
    return nullptr;
  }
  // 1-inline ConstPointerTo< CollisionSolid > CollisionNode::get_solid(std::size_t n) const
  ConstPointerTo< CollisionSolid > return_value = ((*(const CollisionNode*)local_this).get_solid)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  CollisionSolid const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_CollisionSolid, true, true, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_solid(CollisionNode self, index)\n");
  }
}

static int Dtool_CollisionNode_solids_Sequence_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.solids")) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_solids)()) {
    PyErr_SetString(PyExc_IndexError, "CollisionNode.solids[] index out of range");
    return -1;
  }
  if (arg == nullptr) {
    local_this->remove_solid(index);
    return 0;
  }
  // 1-inline void CollisionNode::set_solid(std::size_t n, CollisionSolid *solid)
  CollisionSolid *arg_this = (CollisionSolid *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CollisionSolid, 2, "CollisionNode.set_solid", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_solid)(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_solid(const CollisionNode self, index, CollisionSolid solid)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionNode_solids_Sequence_insert(PyObject *self, size_t index, PyObject *arg) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.solids")) {
    return nullptr;
  }

  // 1-inline void CollisionNode::insert_solid(std::size_t n, CollisionSolid const *solid)
  CollisionSolid const *arg_this = (CollisionSolid *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CollisionSolid, 2, "CollisionNode.insert_solid", true, true);
  if (arg_this != nullptr) {
    ((*local_this).insert_solid)(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "insert_solid(const CollisionNode self, index, const CollisionSolid solid)\n");
  }
  return nullptr;
}

static PyObject *Dtool_CollisionNode_solids_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MutableSequenceWrapper *wrap = Dtool_NewMutableSequenceWrapper(self, "CollisionNode.solids");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_CollisionNode_solids_Len;
    wrap->_getitem_func = &Dtool_CollisionNode_solids_Sequence_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_CollisionNode_solids_Sequence_Setitem;
      wrap->_insert_func = &Dtool_CollisionNode_solids_Sequence_insert;
    }
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_CollisionNode_collider_sort_Getter(PyObject *self, void *) {
  const CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int CollisionNode::get_collider_sort(void) const
  int return_value = ((*(const CollisionNode*)local_this).get_collider_sort)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionNode_collider_sort_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionNode, (void **)&local_this, "CollisionNode.collider_sort")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete collider_sort attribute");
    return -1;
  }
  // 1-inline void CollisionNode::set_collider_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_collider_sort)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_collider_sort(const CollisionNode self, int sort)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionNode_default_collide_mask_Getter(PyObject *self, void *) {
  // 1-static inline CollideMask CollisionNode::get_default_collide_mask(void)
  CollideMask *return_value = new CollideMask((CollisionNode::get_default_collide_mask)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

/**
 * Python function wrapper for:
 * explicit CollisionNode::CollisionNode(std::string const &name)
 */
static int Dtool_Init_CollisionNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CollisionNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit CollisionNode::CollisionNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      CollisionNode *return_value = new CollisionNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionNode(str name)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionNode_get_solids(PyObject *self, PyObject *) {
  CollisionNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionNode, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_solids)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionNode_get_solid_82(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_CollisionNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionNode) {
    printf("CollisionNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionNode *local_this = (CollisionNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (CollisionNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (CollisionNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionTraverser
 */
/**
 * Python function wrapper for:
 * inline void CollisionTraverser::set_respect_prev_transform(bool flag)
 */
static PyObject *Dtool_CollisionTraverser_set_respect_prev_transform_102(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.set_respect_prev_transform")) {
    return nullptr;
  }
  // 1-inline void CollisionTraverser::set_respect_prev_transform(bool flag)
  ((*local_this).set_respect_prev_transform)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_respect_prev_transform(const CollisionTraverser self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_set_respect_prev_transform_102_comment =
  "C++ Interface:\n"
  "set_respect_prev_transform(const CollisionTraverser self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the flag that indicates whether the prev_transform stored on a node\n"
  " * (as updated via set_fluid_pos(), etc.) is respected to calculate\n"
  " * collisions.  If this is true, certain types of collision tests will be\n"
  " * enhanced by the information about objects in motion.  If this is false,\n"
  " * objects are always considered to be static.  The default is false.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_set_respect_prev_transform_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionTraverser::get_respect_prev_transform(void) const
 */
static PyObject *Dtool_CollisionTraverser_get_respect_prev_transform_103(PyObject *self, PyObject *) {
  CollisionTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionTraverser)) {
    return nullptr;
  }
  // 1-inline bool CollisionTraverser::get_respect_prev_transform(void) const
  bool return_value = ((*(const CollisionTraverser*)local_this).get_respect_prev_transform)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_get_respect_prev_transform_103_comment =
  "C++ Interface:\n"
  "get_respect_prev_transform(CollisionTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns the flag that indicates whether the prev_transform stored on a node\n"
  " * is respected to calculate collisions.  See set_respect_prev_transform().\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_get_respect_prev_transform_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionTraverser::add_collider(NodePath const &collider, CollisionHandler *handler)
 */
static PyObject *Dtool_CollisionTraverser_add_collider_105(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.add_collider")) {
    return nullptr;
  }
  // 1-void CollisionTraverser::add_collider(NodePath const &collider, CollisionHandler *handler)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"collider", "handler", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_collider", (char **)keyword_list, &param1, &param2)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "CollisionTraverser.add_collider", true, true);
    CollisionHandler *param2_this = (CollisionHandler *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_CollisionHandler, 2, "CollisionTraverser.add_collider", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*local_this).add_collider)(*param1_this, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_collider(const CollisionTraverser self, const NodePath collider, CollisionHandler handler)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_add_collider_105_comment =
  "C++ Interface:\n"
  "add_collider(const CollisionTraverser self, const NodePath collider, CollisionHandler handler)\n"
  "\n"
  "/**\n"
  " * Adds a new CollisionNode, representing an object that will be tested for\n"
  " * collisions into other objects, along with the handler that will serve each\n"
  " * detected collision.  Each CollisionNode may be served by only one handler\n"
  " * at a time, but a given handler may serve many CollisionNodes.\n"
  " *\n"
  " * The handler that serves a particular node may be changed from time to time\n"
  " * by calling add_collider() again on the same node.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_add_collider_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CollisionTraverser::remove_collider(NodePath const &collider)
 */
static PyObject *Dtool_CollisionTraverser_remove_collider_106(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.remove_collider")) {
    return nullptr;
  }
  // 1-bool CollisionTraverser::remove_collider(NodePath const &collider)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionTraverser.remove_collider", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).remove_collider)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_collider(const CollisionTraverser self, const NodePath collider)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_remove_collider_106_comment =
  "C++ Interface:\n"
  "remove_collider(const CollisionTraverser self, const NodePath collider)\n"
  "\n"
  "/**\n"
  " * Removes the collider (and its associated handler) from the set of\n"
  " * CollisionNodes that will be tested each frame for collisions into other\n"
  " * objects.  Returns true if the definition was found and removed, false if it\n"
  " * wasn't present to begin with.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_remove_collider_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CollisionTraverser::has_collider(NodePath const &collider) const
 */
static PyObject *Dtool_CollisionTraverser_has_collider_107(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionTraverser)) {
    return nullptr;
  }
  // 1-bool CollisionTraverser::has_collider(NodePath const &collider) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionTraverser.has_collider", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const CollisionTraverser*)local_this).has_collider)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_collider(CollisionTraverser self, const NodePath collider)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_has_collider_107_comment =
  "C++ Interface:\n"
  "has_collider(CollisionTraverser self, const NodePath collider)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated node is current in the set of nodes that will\n"
  " * be tested each frame for collisions into other objects.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_has_collider_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CollisionTraverser::get_num_colliders(void) const
 */
static PyObject *Dtool_CollisionTraverser_get_num_colliders_108(PyObject *self, PyObject *) {
  CollisionTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionTraverser)) {
    return nullptr;
  }
  // 1-int CollisionTraverser::get_num_colliders(void) const
  int return_value = ((*(const CollisionTraverser*)local_this).get_num_colliders)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_get_num_colliders_108_comment =
  "C++ Interface:\n"
  "get_num_colliders(CollisionTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns the number of CollisionNodes that have been added to the traverser\n"
  " * via add_collider().\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_get_num_colliders_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath CollisionTraverser::get_collider(int n) const
 */
static PyObject *Dtool_CollisionTraverser_get_collider_109(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionTraverser)) {
    return nullptr;
  }
  // 1-NodePath CollisionTraverser::get_collider(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    NodePath *return_value = new NodePath(((*(const CollisionTraverser*)local_this).get_collider)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_collider(CollisionTraverser self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_get_collider_109_comment =
  "C++ Interface:\n"
  "get_collider(CollisionTraverser self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth CollisionNode that has been added to the traverser via\n"
  " * add_collider().\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_get_collider_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CollisionHandler *CollisionTraverser::get_handler(NodePath const &collider) const
 */
static PyObject *Dtool_CollisionTraverser_get_handler_111(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionTraverser)) {
    return nullptr;
  }
  // 1-CollisionHandler *CollisionTraverser::get_handler(NodePath const &collider) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionTraverser.get_handler", true, true);
  if (arg_this != nullptr) {
    CollisionHandler *return_value = ((*(const CollisionTraverser*)local_this).get_handler)(*arg_this);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionHandler, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_handler(CollisionTraverser self, const NodePath collider)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_get_handler_111_comment =
  "C++ Interface:\n"
  "get_handler(CollisionTraverser self, const NodePath collider)\n"
  "\n"
  "/**\n"
  " * Returns the handler that is currently assigned to serve the indicated\n"
  " * collision node, or NULL if the node is not on the traverser's set of active\n"
  " * nodes.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_get_handler_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionTraverser::clear_colliders(void)
 */
static PyObject *Dtool_CollisionTraverser_clear_colliders_112(PyObject *self, PyObject *) {
  CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.clear_colliders")) {
    return nullptr;
  }
  // 1-void CollisionTraverser::clear_colliders(void)
  ((*local_this).clear_colliders)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_clear_colliders_112_comment =
  "C++ Interface:\n"
  "clear_colliders(const CollisionTraverser self)\n"
  "\n"
  "/**\n"
  " * Completely empties the set of collision nodes and their associated\n"
  " * handlers.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_clear_colliders_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionTraverser::traverse(NodePath const &root)
 */
static PyObject *Dtool_CollisionTraverser_traverse_115(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.traverse")) {
    return nullptr;
  }
  // 1-void CollisionTraverser::traverse(NodePath const &root)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionTraverser.traverse", true, true);
  if (arg_this != nullptr) {
    ((*local_this).traverse)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "traverse(const CollisionTraverser self, const NodePath root)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_traverse_115_comment =
  "C++ Interface:\n"
  "traverse(const CollisionTraverser self, const NodePath root)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_traverse_115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionTraverser::set_recorder(CollisionRecorder *recorder)
 */
static PyObject *Dtool_CollisionTraverser_set_recorder_116(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.set_recorder")) {
    return nullptr;
  }
  // 1-void CollisionTraverser::set_recorder(CollisionRecorder *recorder)
  CollisionRecorder *arg_this = (CollisionRecorder *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CollisionRecorder, 1, "CollisionTraverser.set_recorder", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_recorder)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_recorder(const CollisionTraverser self, CollisionRecorder recorder)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_set_recorder_116_comment =
  "C++ Interface:\n"
  "set_recorder(const CollisionTraverser self, CollisionRecorder recorder)\n"
  "\n"
  "/**\n"
  " * Uses the indicated CollisionRecorder object to start recording the\n"
  " * intersection tests made by each subsequent call to traverse() on this\n"
  " * object.  A particular CollisionRecorder object can only record one\n"
  " * traverser at a time; if this object has already been assigned to another\n"
  " * traverser, that assignment is broken.\n"
  " *\n"
  " * This is intended to be used in a debugging mode to try to determine what\n"
  " * work is being performed by the collision traversal.  Usually, attaching a\n"
  " * recorder will impose significant runtime overhead.\n"
  " *\n"
  " * This does not transfer ownership of the CollisionRecorder pointer;\n"
  " * maintenance of that remains the caller's responsibility.  If the\n"
  " * CollisionRecorder is destructed, it will cleanly remove itself from the\n"
  " * traverser.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_set_recorder_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionTraverser::has_recorder(void) const
 */
static PyObject *Dtool_CollisionTraverser_has_recorder_117(PyObject *self, PyObject *) {
  CollisionTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionTraverser)) {
    return nullptr;
  }
  // 1-inline bool CollisionTraverser::has_recorder(void) const
  bool return_value = ((*(const CollisionTraverser*)local_this).has_recorder)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_has_recorder_117_comment =
  "C++ Interface:\n"
  "has_recorder(CollisionTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns true if the CollisionTraverser has a CollisionRecorder object\n"
  " * currently assigned, false otherwise.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_has_recorder_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CollisionRecorder *CollisionTraverser::get_recorder(void) const
 */
static PyObject *Dtool_CollisionTraverser_get_recorder_118(PyObject *self, PyObject *) {
  CollisionTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionTraverser)) {
    return nullptr;
  }
  // 1-inline CollisionRecorder *CollisionTraverser::get_recorder(void) const
  CollisionRecorder *return_value = ((*(const CollisionTraverser*)local_this).get_recorder)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionRecorder, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_get_recorder_118_comment =
  "C++ Interface:\n"
  "get_recorder(CollisionTraverser self)\n"
  "\n"
  "/**\n"
  " * Returns the CollisionRecorder currently assigned, or NULL if no recorder is\n"
  " * assigned.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_get_recorder_118_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionTraverser::clear_recorder(void)
 */
static PyObject *Dtool_CollisionTraverser_clear_recorder_119(PyObject *self, PyObject *) {
  CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.clear_recorder")) {
    return nullptr;
  }
  // 1-inline void CollisionTraverser::clear_recorder(void)
  ((*local_this).clear_recorder)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_clear_recorder_119_comment =
  "C++ Interface:\n"
  "clear_recorder(const CollisionTraverser self)\n"
  "\n"
  "/**\n"
  " * Removes the CollisionRecorder from the traverser and restores normal low-\n"
  " * overhead operation.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_clear_recorder_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PandaNode *CollisionTraverser::show_collisions(NodePath const &root)
 */
static PyObject *Dtool_CollisionTraverser_show_collisions_126(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.show_collisions")) {
    return nullptr;
  }
  // 1-PandaNode *CollisionTraverser::show_collisions(NodePath const &root)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionTraverser.show_collisions", true, true);
  if (arg_this != nullptr) {
    PandaNode *return_value = ((*local_this).show_collisions)(*arg_this);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "show_collisions(const CollisionTraverser self, const NodePath root)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_show_collisions_126_comment =
  "C++ Interface:\n"
  "show_collisions(const CollisionTraverser self, const NodePath root)\n"
  "\n"
  "/**\n"
  " * This is a high-level function to create a CollisionVisualizer object to\n"
  " * render the collision tests performed by this traverser.  The supplied root\n"
  " * should be any node in the scene graph; typically, the top node (e.g.\n"
  " * render).  The CollisionVisualizer will be attached to this node.\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_show_collisions_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionTraverser::hide_collisions(void)
 */
static PyObject *Dtool_CollisionTraverser_hide_collisions_127(PyObject *self, PyObject *) {
  CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.hide_collisions")) {
    return nullptr;
  }
  // 1-void CollisionTraverser::hide_collisions(void)
  ((*local_this).hide_collisions)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_hide_collisions_127_comment =
  "C++ Interface:\n"
  "hide_collisions(const CollisionTraverser self)\n"
  "\n"
  "/**\n"
  " * Undoes the effect of a previous call to show_collisions().\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_hide_collisions_127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionTraverser::output(std::ostream &out) const
 */
static PyObject *Dtool_CollisionTraverser_output_128(PyObject *self, PyObject *arg) {
  CollisionTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionTraverser)) {
    return nullptr;
  }
  // 1-void CollisionTraverser::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "CollisionTraverser.output", false, true);
  if (arg_this != nullptr) {
    ((*(const CollisionTraverser*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CollisionTraverser self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_output_128_comment =
  "C++ Interface:\n"
  "output(CollisionTraverser self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_output_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionTraverser::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_CollisionTraverser_write_129(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionTraverser *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionTraverser)) {
    return nullptr;
  }
  // 1-void CollisionTraverser::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "CollisionTraverser.write", false, true);
    if (param1_this != nullptr) {
      ((*(const CollisionTraverser*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(CollisionTraverser self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_write_129_comment =
  "C++ Interface:\n"
  "write(CollisionTraverser self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionTraverser_write_129_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionTraverser::get_class_type(void)
 */
static PyObject *Dtool_CollisionTraverser_get_class_type_130(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionTraverser::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionTraverser::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionTraverser_get_class_type_130_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionTraverser_get_class_type_130_comment = nullptr;
#endif

static PyObject *Dtool_CollisionTraverser_respect_prev_transform_Getter(PyObject *self, void *) {
  const CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool CollisionTraverser::get_respect_prev_transform(void) const
  bool return_value = ((*(const CollisionTraverser*)local_this).get_respect_prev_transform)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionTraverser_respect_prev_transform_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.respect_prev_transform")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete respect_prev_transform attribute");
    return -1;
  }
  // 1-inline void CollisionTraverser::set_respect_prev_transform(bool flag)
  ((*local_this).set_respect_prev_transform)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_respect_prev_transform(const CollisionTraverser self, bool flag)\n");
  }
  return -1;
}

/**
 * sequence length function for property CollisionTraverser::colliders
 */
static Py_ssize_t Dtool_CollisionTraverser_colliders_Len(PyObject *self) {
  CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_colliders)();
}

/**
 * sequence getter for property CollisionTraverser::colliders
 */
static PyObject *Dtool_CollisionTraverser_colliders_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_colliders)()) {
    PyErr_SetString(PyExc_IndexError, "CollisionTraverser.colliders[] index out of range");
    return nullptr;
  }
  // 1-NodePath CollisionTraverser::get_collider(int n) const
  NodePath *return_value = new NodePath(((*(const CollisionTraverser*)local_this).get_collider)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_collider(CollisionTraverser self, index)\n");
  }
}

static PyObject *Dtool_CollisionTraverser_colliders_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "CollisionTraverser.colliders");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_CollisionTraverser_colliders_Len;
    wrap->_getitem_func = &Dtool_CollisionTraverser_colliders_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_CollisionTraverser_recorder_Getter(PyObject *self, void *) {
  const CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_recorder()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline CollisionRecorder *CollisionTraverser::get_recorder(void) const
  CollisionRecorder *return_value = ((*(const CollisionTraverser*)local_this).get_recorder)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionRecorder, false, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_CollisionTraverser_recorder_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionTraverser, (void **)&local_this, "CollisionTraverser.recorder")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete recorder attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_recorder();
    return 0;
  }
  // 1-void CollisionTraverser::set_recorder(CollisionRecorder *recorder)
  CollisionRecorder *arg_this = (CollisionRecorder *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CollisionRecorder, 1, "CollisionTraverser.set_recorder", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_recorder)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_recorder(const CollisionTraverser self, CollisionRecorder recorder)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline CollisionTraverser::CollisionTraverser(CollisionTraverser const &) = default
 * explicit CollisionTraverser::CollisionTraverser(std::string const &name = "ctrav")
 */
static int Dtool_Init_CollisionTraverser(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-explicit CollisionTraverser::CollisionTraverser(std::string const &name)
      CollisionTraverser *return_value = new CollisionTraverser();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionTraverser, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline CollisionTraverser::CollisionTraverser(CollisionTraverser const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          CollisionTraverser const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_CollisionTraverser);
          if (param0_this != nullptr) {
            CollisionTraverser *return_value = new CollisionTraverser(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionTraverser, true, false);
          }
        }
      }

      {
        // -2 explicit CollisionTraverser::CollisionTraverser(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:CollisionTraverser", (char **)keyword_list, &param0_str, &param0_len)) {
          CollisionTraverser *return_value = new CollisionTraverser(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionTraverser, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline CollisionTraverser::CollisionTraverser(CollisionTraverser const &) = default
      // No coercion possible: explicit CollisionTraverser::CollisionTraverser(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionTraverser() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionTraverser()\n"
      "CollisionTraverser(const CollisionTraverser param0)\n"
      "CollisionTraverser(str name)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionTraverser_get_colliders(PyObject *self, PyObject *) {
  CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_colliders)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionTraverser_get_collider_109(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_CollisionTraverser(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionTraverser) {
    printf("CollisionTraverser ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionTraverser *local_this = (CollisionTraverser *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionTraverser) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionTraverser(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionTraverser) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (CollisionTraverser*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionRecorder
 */
/**
 * Python function wrapper for:
 * void CollisionRecorder::output(std::ostream &out) const
 */
static PyObject *Dtool_CollisionRecorder_output_124(PyObject *self, PyObject *arg) {
  CollisionRecorder *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionRecorder)) {
    return nullptr;
  }
  // 1-void CollisionRecorder::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "CollisionRecorder.output", false, true);
  if (arg_this != nullptr) {
    ((*(const CollisionRecorder*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CollisionRecorder self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionRecorder_output_124_comment =
  "C++ Interface:\n"
  "output(CollisionRecorder self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionRecorder_output_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionRecorder::get_class_type(void)
 */
static PyObject *Dtool_CollisionRecorder_get_class_type_125(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionRecorder::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionRecorder::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionRecorder_get_class_type_125_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionRecorder_get_class_type_125_comment = nullptr;
#endif

static int Dtool_Init_CollisionRecorder(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CollisionRecorder(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionRecorder) {
    printf("CollisionRecorder ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionRecorder *local_this = (CollisionRecorder *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionRecorder) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionRecorder(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionRecorder) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionRecorder*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionEntry
 */
/**
 * Python function wrapper for:
 * inline CollisionSolid const *CollisionEntry::get_from(void) const
 */
static PyObject *Dtool_CollisionEntry_get_from_133(PyObject *self, PyObject *) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-inline CollisionSolid const *CollisionEntry::get_from(void) const
  CollisionSolid const *return_value = ((*(const CollisionEntry*)local_this).get_from)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionSolid, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_from_133_comment =
  "C++ Interface:\n"
  "get_from(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the CollisionSolid pointer for the particular solid that triggered\n"
  " * this collision.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_from_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionEntry::has_into(void) const
 */
static PyObject *Dtool_CollisionEntry_has_into_134(PyObject *self, PyObject *) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-inline bool CollisionEntry::has_into(void) const
  bool return_value = ((*(const CollisionEntry*)local_this).has_into)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_has_into_134_comment =
  "C++ Interface:\n"
  "has_into(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns true if the \"into\" solid is, in fact, a CollisionSolid, and its\n"
  " * pointer is known (in which case get_into() may be called to retrieve it).\n"
  " * If this returns false, the collision was detected into a GeomNode, and\n"
  " * there is no CollisionSolid pointer to be retrieved.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_has_into_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CollisionSolid const *CollisionEntry::get_into(void) const
 */
static PyObject *Dtool_CollisionEntry_get_into_135(PyObject *self, PyObject *) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-inline CollisionSolid const *CollisionEntry::get_into(void) const
  CollisionSolid const *return_value = ((*(const CollisionEntry*)local_this).get_into)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionSolid, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_into_135_comment =
  "C++ Interface:\n"
  "get_into(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the CollisionSolid pointer for the particular solid was collided\n"
  " * into.  This pointer might be NULL if the collision was into a piece of\n"
  " * visible geometry, instead of a normal CollisionSolid collision; see\n"
  " * has_into().\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_into_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CollisionNode *CollisionEntry::get_from_node(void) const
 */
static PyObject *Dtool_CollisionEntry_get_from_node_136(PyObject *self, PyObject *) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-inline CollisionNode *CollisionEntry::get_from_node(void) const
  CollisionNode *return_value = ((*(const CollisionEntry*)local_this).get_from_node)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_from_node_136_comment =
  "C++ Interface:\n"
  "get_from_node(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the node that contains the CollisionSolid that triggered this\n"
  " * collision.  This will be a node that has been added to a CollisionTraverser\n"
  " * via add_collider().\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_from_node_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *CollisionEntry::get_into_node(void) const
 */
static PyObject *Dtool_CollisionEntry_get_into_node_137(PyObject *self, PyObject *) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-inline PandaNode *CollisionEntry::get_into_node(void) const
  PandaNode *return_value = ((*(const CollisionEntry*)local_this).get_into_node)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_into_node_137_comment =
  "C++ Interface:\n"
  "get_into_node(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the node that contains the CollisionSolid that was collided into.\n"
  " * This returns a PandaNode pointer instead of something more specific,\n"
  " * because it might be either a CollisionNode or a GeomNode.\n"
  " *\n"
  " * Also see get_into_node_path().\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_into_node_137_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath CollisionEntry::get_from_node_path(void) const
 */
static PyObject *Dtool_CollisionEntry_get_from_node_path_138(PyObject *self, PyObject *) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-inline NodePath CollisionEntry::get_from_node_path(void) const
  NodePath *return_value = new NodePath(((*(const CollisionEntry*)local_this).get_from_node_path)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_from_node_path_138_comment =
  "C++ Interface:\n"
  "get_from_node_path(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath that represents the CollisionNode that contains the\n"
  " * CollisionSolid that triggered this collision.  This will be a NodePath that\n"
  " * has been added to a CollisionTraverser via add_collider().\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_from_node_path_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath CollisionEntry::get_into_node_path(void) const
 */
static PyObject *Dtool_CollisionEntry_get_into_node_path_139(PyObject *self, PyObject *) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-inline NodePath CollisionEntry::get_into_node_path(void) const
  NodePath *return_value = new NodePath(((*(const CollisionEntry*)local_this).get_into_node_path)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_into_node_path_139_comment =
  "C++ Interface:\n"
  "get_into_node_path(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath that represents the specific CollisionNode or GeomNode\n"
  " * instance that was collided into.  This is the same node returned by\n"
  " * get_into_node(), represented as a NodePath; however, it may be more useful\n"
  " * because the NodePath can resolve the particular instance of the node, if\n"
  " * there is more than one.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_into_node_path_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionEntry::set_t(PN_stdfloat t)
 */
static PyObject *Dtool_CollisionEntry_set_t_140(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionEntry, (void **)&local_this, "CollisionEntry.set_t")) {
    return nullptr;
  }
  // 1-inline void CollisionEntry::set_t(PN_stdfloat t)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_t)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_t(const CollisionEntry self, float t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_set_t_140_comment =
  "C++ Interface:\n"
  "set_t(const CollisionEntry self, float t)\n"
  "\n"
  "/**\n"
  " * Sets a time value for this collision relative to other CollisionEntries\n"
  " */";
#else
static const char *Dtool_CollisionEntry_set_t_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionEntry::get_t(void) const
 */
static PyObject *Dtool_CollisionEntry_get_t_141(PyObject *self, PyObject *) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat CollisionEntry::get_t(void) const
  PN_stdfloat return_value = ((*(const CollisionEntry*)local_this).get_t)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_t_141_comment =
  "C++ Interface:\n"
  "get_t(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * returns time value for this collision relative to other CollisionEntries\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_t_141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionEntry::collided(void) const
 */
static PyObject *Dtool_CollisionEntry_collided_142(PyObject *self, PyObject *) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-inline bool CollisionEntry::collided(void) const
  bool return_value = ((*(const CollisionEntry*)local_this).collided)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_collided_142_comment =
  "C++ Interface:\n"
  "collided(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * returns true if this represents an actual collision as opposed to a\n"
  " * potential collision, needed for iterative collision resolution where path\n"
  " * of collider changes mid-frame\n"
  " */";
#else
static const char *Dtool_CollisionEntry_collided_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionEntry::reset_collided(void)
 */
static PyObject *Dtool_CollisionEntry_reset_collided_143(PyObject *self, PyObject *) {
  CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionEntry, (void **)&local_this, "CollisionEntry.reset_collided")) {
    return nullptr;
  }
  // 1-inline void CollisionEntry::reset_collided(void)
  ((*local_this).reset_collided)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_reset_collided_143_comment =
  "C++ Interface:\n"
  "reset_collided(const CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * prepare for another collision test\n"
  " */";
#else
static const char *Dtool_CollisionEntry_reset_collided_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionEntry::get_respect_prev_transform(void) const
 */
static PyObject *Dtool_CollisionEntry_get_respect_prev_transform_144(PyObject *self, PyObject *) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-inline bool CollisionEntry::get_respect_prev_transform(void) const
  bool return_value = ((*(const CollisionEntry*)local_this).get_respect_prev_transform)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_respect_prev_transform_144_comment =
  "C++ Interface:\n"
  "get_respect_prev_transform(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns true if the collision was detected by a CollisionTraverser whose\n"
  " * respect_prev_transform flag was set true, meaning we should consider motion\n"
  " * significant in evaluating collisions.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_respect_prev_transform_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionEntry::set_surface_point(LPoint3 const &point)
 */
static PyObject *Dtool_CollisionEntry_set_surface_point_145(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionEntry, (void **)&local_this, "CollisionEntry.set_surface_point")) {
    return nullptr;
  }
  // 1-inline void CollisionEntry::set_surface_point(LPoint3 const &point)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionEntry.set_surface_point", "LPoint3f");
  }
  ((*local_this).set_surface_point)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_surface_point(const CollisionEntry self, const LPoint3f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_set_surface_point_145_comment =
  "C++ Interface:\n"
  "set_surface_point(const CollisionEntry self, const LPoint3f point)\n"
  "\n"
  "/**\n"
  " * Stores the point, on the surface of the \"into\" object, at which a collision\n"
  " * is detected.\n"
  " *\n"
  " * This point is specified in the coordinate space of the \"into\" object.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_set_surface_point_145_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionEntry::set_surface_normal(LVector3 const &normal)
 */
static PyObject *Dtool_CollisionEntry_set_surface_normal_146(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionEntry, (void **)&local_this, "CollisionEntry.set_surface_normal")) {
    return nullptr;
  }
  // 1-inline void CollisionEntry::set_surface_normal(LVector3 const &normal)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionEntry.set_surface_normal", "LVector3f");
  }
  ((*local_this).set_surface_normal)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_surface_normal(const CollisionEntry self, const LVector3f normal)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_set_surface_normal_146_comment =
  "C++ Interface:\n"
  "set_surface_normal(const CollisionEntry self, const LVector3f normal)\n"
  "\n"
  "/**\n"
  " * Stores the surface normal of the \"into\" object at the point of the\n"
  " * intersection.\n"
  " *\n"
  " * This normal is specified in the coordinate space of the \"into\" object.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_set_surface_normal_146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionEntry::set_interior_point(LPoint3 const &point)
 */
static PyObject *Dtool_CollisionEntry_set_interior_point_147(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionEntry, (void **)&local_this, "CollisionEntry.set_interior_point")) {
    return nullptr;
  }
  // 1-inline void CollisionEntry::set_interior_point(LPoint3 const &point)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionEntry.set_interior_point", "LPoint3f");
  }
  ((*local_this).set_interior_point)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_interior_point(const CollisionEntry self, const LPoint3f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_set_interior_point_147_comment =
  "C++ Interface:\n"
  "set_interior_point(const CollisionEntry self, const LPoint3f point)\n"
  "\n"
  "/**\n"
  " * Stores the point, within the interior of the \"into\" object, which\n"
  " * represents the depth to which the \"from\" object has penetrated.  This can\n"
  " * also be described as the intersection point on the surface of the \"from\"\n"
  " * object (which is inside the \"into\" object).\n"
  " *\n"
  " * This point is specified in the coordinate space of the \"into\" object.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_set_interior_point_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionEntry::has_surface_point(void) const
 */
static PyObject *Dtool_CollisionEntry_has_surface_point_148(PyObject *self, PyObject *) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-inline bool CollisionEntry::has_surface_point(void) const
  bool return_value = ((*(const CollisionEntry*)local_this).has_surface_point)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_has_surface_point_148_comment =
  "C++ Interface:\n"
  "has_surface_point(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns true if the surface point has been specified, false otherwise.  See\n"
  " * get_surface_point().  Some types of collisions may not compute the surface\n"
  " * point.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_has_surface_point_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionEntry::has_surface_normal(void) const
 */
static PyObject *Dtool_CollisionEntry_has_surface_normal_149(PyObject *self, PyObject *) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-inline bool CollisionEntry::has_surface_normal(void) const
  bool return_value = ((*(const CollisionEntry*)local_this).has_surface_normal)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_has_surface_normal_149_comment =
  "C++ Interface:\n"
  "has_surface_normal(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns true if the surface normal has been specified, false otherwise.\n"
  " * See get_surface_normal().  Some types of collisions may not compute the\n"
  " * surface normal.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_has_surface_normal_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionEntry::has_interior_point(void) const
 */
static PyObject *Dtool_CollisionEntry_has_interior_point_150(PyObject *self, PyObject *) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-inline bool CollisionEntry::has_interior_point(void) const
  bool return_value = ((*(const CollisionEntry*)local_this).has_interior_point)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_has_interior_point_150_comment =
  "C++ Interface:\n"
  "has_interior_point(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns true if the interior point has been specified, false otherwise.\n"
  " * See get_interior_point().  Some types of collisions may not compute the\n"
  " * interior point.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_has_interior_point_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionEntry::set_contact_pos(LPoint3 const &pos)
 */
static PyObject *Dtool_CollisionEntry_set_contact_pos_151(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionEntry, (void **)&local_this, "CollisionEntry.set_contact_pos")) {
    return nullptr;
  }
  // 1-inline void CollisionEntry::set_contact_pos(LPoint3 const &pos)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionEntry.set_contact_pos", "LPoint3f");
  }
  ((*local_this).set_contact_pos)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_contact_pos(const CollisionEntry self, const LPoint3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_set_contact_pos_151_comment =
  "C++ Interface:\n"
  "set_contact_pos(const CollisionEntry self, const LPoint3f pos)\n"
  "\n"
  "/**\n"
  " * Stores the position of the \"from\" object at the instant at which the\n"
  " * collision is first detected.\n"
  " *\n"
  " * This position is specified in the coordinate space of the \"into\" object.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_set_contact_pos_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionEntry::set_contact_normal(LVector3 const &normal)
 */
static PyObject *Dtool_CollisionEntry_set_contact_normal_152(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionEntry, (void **)&local_this, "CollisionEntry.set_contact_normal")) {
    return nullptr;
  }
  // 1-inline void CollisionEntry::set_contact_normal(LVector3 const &normal)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionEntry.set_contact_normal", "LVector3f");
  }
  ((*local_this).set_contact_normal)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_contact_normal(const CollisionEntry self, const LVector3f normal)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_set_contact_normal_152_comment =
  "C++ Interface:\n"
  "set_contact_normal(const CollisionEntry self, const LVector3f normal)\n"
  "\n"
  "/**\n"
  " * Stores the surface normal of the \"into\" object at the contact pos.\n"
  " *\n"
  " * This normal is specified in the coordinate space of the \"into\" object.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_set_contact_normal_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionEntry::has_contact_pos(void) const
 */
static PyObject *Dtool_CollisionEntry_has_contact_pos_153(PyObject *self, PyObject *) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-inline bool CollisionEntry::has_contact_pos(void) const
  bool return_value = ((*(const CollisionEntry*)local_this).has_contact_pos)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_has_contact_pos_153_comment =
  "C++ Interface:\n"
  "has_contact_pos(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns true if the contact position has been specified, false otherwise.\n"
  " * See get_contact_pos().  Some types of collisions may not compute the\n"
  " * contact pos.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_has_contact_pos_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionEntry::has_contact_normal(void) const
 */
static PyObject *Dtool_CollisionEntry_has_contact_normal_154(PyObject *self, PyObject *) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-inline bool CollisionEntry::has_contact_normal(void) const
  bool return_value = ((*(const CollisionEntry*)local_this).has_contact_normal)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_has_contact_normal_154_comment =
  "C++ Interface:\n"
  "has_contact_normal(CollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns true if the contact normal has been specified, false otherwise.\n"
  " * See get_contact_normal().  Some types of collisions may not compute the\n"
  " * contact normal.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_has_contact_normal_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LPoint3 CollisionEntry::get_surface_point(NodePath const &space) const
 */
static PyObject *Dtool_CollisionEntry_get_surface_point_155(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-LPoint3 CollisionEntry::get_surface_point(NodePath const &space) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionEntry.get_surface_point", true, true);
  if (arg_this != nullptr) {
    LPoint3 *return_value = new LPoint3(((*(const CollisionEntry*)local_this).get_surface_point)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_surface_point(CollisionEntry self, const NodePath space)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_surface_point_155_comment =
  "C++ Interface:\n"
  "get_surface_point(CollisionEntry self, const NodePath space)\n"
  "\n"
  "/**\n"
  " * Returns the point, on the surface of the \"into\" object, at which a\n"
  " * collision is detected.  This can be thought of as the first point of\n"
  " * intersection.  However the contact point is the actual first point of\n"
  " * intersection.\n"
  " *\n"
  " * The point will be converted into whichever coordinate space the caller\n"
  " * specifies.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_surface_point_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector3 CollisionEntry::get_surface_normal(NodePath const &space) const
 */
static PyObject *Dtool_CollisionEntry_get_surface_normal_156(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-LVector3 CollisionEntry::get_surface_normal(NodePath const &space) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionEntry.get_surface_normal", true, true);
  if (arg_this != nullptr) {
    LVector3 *return_value = new LVector3(((*(const CollisionEntry*)local_this).get_surface_normal)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_surface_normal(CollisionEntry self, const NodePath space)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_surface_normal_156_comment =
  "C++ Interface:\n"
  "get_surface_normal(CollisionEntry self, const NodePath space)\n"
  "\n"
  "/**\n"
  " * Returns the surface normal of the \"into\" object at the point at which a\n"
  " * collision is detected.\n"
  " *\n"
  " * The normal will be converted into whichever coordinate space the caller\n"
  " * specifies.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_surface_normal_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LPoint3 CollisionEntry::get_interior_point(NodePath const &space) const
 */
static PyObject *Dtool_CollisionEntry_get_interior_point_157(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-LPoint3 CollisionEntry::get_interior_point(NodePath const &space) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionEntry.get_interior_point", true, true);
  if (arg_this != nullptr) {
    LPoint3 *return_value = new LPoint3(((*(const CollisionEntry*)local_this).get_interior_point)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_interior_point(CollisionEntry self, const NodePath space)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_interior_point_157_comment =
  "C++ Interface:\n"
  "get_interior_point(CollisionEntry self, const NodePath space)\n"
  "\n"
  "/**\n"
  " * Returns the point, within the interior of the \"into\" object, which\n"
  " * represents the depth to which the \"from\" object has penetrated.  This can\n"
  " * also be described as the intersection point on the surface of the \"from\"\n"
  " * object (which is inside the \"into\" object).  It can be thought of as the\n"
  " * deepest point of intersection.\n"
  " *\n"
  " * The point will be converted into whichever coordinate space the caller\n"
  " * specifies.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_interior_point_157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CollisionEntry::get_all(NodePath const &space, LPoint3 &surface_point, LVector3 &surface_normal, LPoint3 &interior_point) const
 */
static PyObject *Dtool_CollisionEntry_get_all_158(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-bool CollisionEntry::get_all(NodePath const &space, LPoint3 &surface_point, LVector3 &surface_normal, LPoint3 &interior_point) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  PyObject *param4;
  static const char *keyword_list[] = {"space", "surface_point", "surface_normal", "interior_point", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:get_all", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "CollisionEntry.get_all", true, true);
    LPoint3f param2_local;
    LPoint3 *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CollisionEntry.get_all", "LPoint3f");
    }
    LVector3f param3_local;
    LVector3 *param3_this = Dtool_Coerce_LVector3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "CollisionEntry.get_all", "LVector3f");
    }
    LPoint3f param4_local;
    LPoint3 *param4_this = Dtool_Coerce_LPoint3f(param4, param4_local);
    if (!(param4_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "CollisionEntry.get_all", "LPoint3f");
    }
    if (param1_this != nullptr) {
      bool return_value = ((*(const CollisionEntry*)local_this).get_all)(*param1_this, *param2_this, *param3_this, *param4_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_all(CollisionEntry self, const NodePath space, LPoint3f surface_point, LVector3f surface_normal, LPoint3f interior_point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_all_158_comment =
  "C++ Interface:\n"
  "get_all(CollisionEntry self, const NodePath space, LPoint3f surface_point, LVector3f surface_normal, LPoint3f interior_point)\n"
  "\n"
  "/**\n"
  " * Simultaneously transforms the surface point, surface normal, and interior\n"
  " * point of the collision into the indicated coordinate space.\n"
  " *\n"
  " * Returns true if all three properties are available, or false if any one of\n"
  " * them is not.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_all_158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LPoint3 CollisionEntry::get_contact_pos(NodePath const &space) const
 */
static PyObject *Dtool_CollisionEntry_get_contact_pos_159(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-LPoint3 CollisionEntry::get_contact_pos(NodePath const &space) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionEntry.get_contact_pos", true, true);
  if (arg_this != nullptr) {
    LPoint3 *return_value = new LPoint3(((*(const CollisionEntry*)local_this).get_contact_pos)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_contact_pos(CollisionEntry self, const NodePath space)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_contact_pos_159_comment =
  "C++ Interface:\n"
  "get_contact_pos(CollisionEntry self, const NodePath space)\n"
  "\n"
  "/**\n"
  " * Returns the position of the \"from\" object at the instant that a collision\n"
  " * is first detected.\n"
  " *\n"
  " * The position will be converted into whichever coordinate space the caller\n"
  " * specifies.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_contact_pos_159_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector3 CollisionEntry::get_contact_normal(NodePath const &space) const
 */
static PyObject *Dtool_CollisionEntry_get_contact_normal_160(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-LVector3 CollisionEntry::get_contact_normal(NodePath const &space) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionEntry.get_contact_normal", true, true);
  if (arg_this != nullptr) {
    LVector3 *return_value = new LVector3(((*(const CollisionEntry*)local_this).get_contact_normal)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_contact_normal(CollisionEntry self, const NodePath space)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_contact_normal_160_comment =
  "C++ Interface:\n"
  "get_contact_normal(CollisionEntry self, const NodePath space)\n"
  "\n"
  "/**\n"
  " * Returns the surface normal of the \"into\" object at the contact position.\n"
  " *\n"
  " * The normal will be converted into whichever coordinate space the caller\n"
  " * specifies.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_contact_normal_160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CollisionEntry::get_all_contact_info(NodePath const &space, LPoint3 &contact_pos, LVector3 &contact_normal) const
 */
static PyObject *Dtool_CollisionEntry_get_all_contact_info_161(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-bool CollisionEntry::get_all_contact_info(NodePath const &space, LPoint3 &contact_pos, LVector3 &contact_normal) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"space", "contact_pos", "contact_normal", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:get_all_contact_info", (char **)keyword_list, &param1, &param2, &param3)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "CollisionEntry.get_all_contact_info", true, true);
    LPoint3f param2_local;
    LPoint3 *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "CollisionEntry.get_all_contact_info", "LPoint3f");
    }
    LVector3f param3_local;
    LVector3 *param3_this = Dtool_Coerce_LVector3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "CollisionEntry.get_all_contact_info", "LVector3f");
    }
    if (param1_this != nullptr) {
      bool return_value = ((*(const CollisionEntry*)local_this).get_all_contact_info)(*param1_this, *param2_this, *param3_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_all_contact_info(CollisionEntry self, const NodePath space, LPoint3f contact_pos, LVector3f contact_normal)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_all_contact_info_161_comment =
  "C++ Interface:\n"
  "get_all_contact_info(CollisionEntry self, const NodePath space, LPoint3f contact_pos, LVector3f contact_normal)\n"
  "\n"
  "/**\n"
  " * Simultaneously transforms the contact position and contact normal of the\n"
  " * collision into the indicated coordinate space.\n"
  " *\n"
  " * Returns true if all three properties are available, or false if any one of\n"
  " * them is not.\n"
  " */";
#else
static const char *Dtool_CollisionEntry_get_all_contact_info_161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionEntry::output(std::ostream &out) const
 */
static PyObject *Dtool_CollisionEntry_output_162(PyObject *self, PyObject *arg) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-void CollisionEntry::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "CollisionEntry.output", false, true);
  if (arg_this != nullptr) {
    ((*(const CollisionEntry*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CollisionEntry self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_output_162_comment =
  "C++ Interface:\n"
  "output(CollisionEntry self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionEntry_output_162_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionEntry::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_CollisionEntry_write_163(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionEntry)) {
    return nullptr;
  }
  // 1-void CollisionEntry::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "CollisionEntry.write", false, true);
    if (param1_this != nullptr) {
      ((*(const CollisionEntry*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(CollisionEntry self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_write_163_comment =
  "C++ Interface:\n"
  "write(CollisionEntry self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionEntry_write_163_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionEntry::get_class_type(void)
 */
static PyObject *Dtool_CollisionEntry_get_class_type_176(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionEntry::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionEntry::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionEntry_get_class_type_176_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionEntry_get_class_type_176_comment = nullptr;
#endif

static PyObject *Dtool_CollisionEntry_from_solid_Getter(PyObject *self, void *) {
  const CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CollisionSolid const *CollisionEntry::get_from(void) const
  CollisionSolid const *return_value = ((*(const CollisionEntry*)local_this).get_from)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionSolid, true, true, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_CollisionEntry_into_solid_Getter(PyObject *self, void *) {
  const CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CollisionSolid const *CollisionEntry::get_into(void) const
  CollisionSolid const *return_value = ((*(const CollisionEntry*)local_this).get_into)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionSolid, true, true, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_CollisionEntry_from_node_Getter(PyObject *self, void *) {
  const CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CollisionNode *CollisionEntry::get_from_node(void) const
  CollisionNode *return_value = ((*(const CollisionEntry*)local_this).get_from_node)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_CollisionEntry_into_node_Getter(PyObject *self, void *) {
  const CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PandaNode *CollisionEntry::get_into_node(void) const
  PandaNode *return_value = ((*(const CollisionEntry*)local_this).get_into_node)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_CollisionEntry_from_node_path_Getter(PyObject *self, void *) {
  const CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline NodePath CollisionEntry::get_from_node_path(void) const
  NodePath *return_value = new NodePath(((*(const CollisionEntry*)local_this).get_from_node_path)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

static PyObject *Dtool_CollisionEntry_into_node_path_Getter(PyObject *self, void *) {
  const CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline NodePath CollisionEntry::get_into_node_path(void) const
  NodePath *return_value = new NodePath(((*(const CollisionEntry*)local_this).get_into_node_path)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

static PyObject *Dtool_CollisionEntry_t_Getter(PyObject *self, void *) {
  const CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat CollisionEntry::get_t(void) const
  PN_stdfloat return_value = ((*(const CollisionEntry*)local_this).get_t)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionEntry_t_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionEntry, (void **)&local_this, "CollisionEntry.t")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete t attribute");
    return -1;
  }
  // 1-inline void CollisionEntry::set_t(PN_stdfloat t)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_t)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_t(const CollisionEntry self, float t)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionEntry_respect_prev_transform_Getter(PyObject *self, void *) {
  const CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool CollisionEntry::get_respect_prev_transform(void) const
  bool return_value = ((*(const CollisionEntry*)local_this).get_respect_prev_transform)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_CollisionEntry(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CollisionEntry(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionEntry) {
    printf("CollisionEntry ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionEntry *local_this = (CollisionEntry *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionEntry) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionEntry(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionEntry) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionEntry*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionEntry*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionEntry*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionEntry*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionPlane
 */
/**
 * Python function wrapper for:
 * inline LVector3 CollisionPlane::get_normal(void) const
 */
static PyObject *Dtool_CollisionPlane_get_normal_180(PyObject *self, PyObject *) {
  CollisionPlane *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionPlane)) {
    return nullptr;
  }
  // 1-inline LVector3 CollisionPlane::get_normal(void) const
  LVector3 *return_value = new LVector3(((*(const CollisionPlane*)local_this).get_normal)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionPlane_get_normal_180_comment =
  "C++ Interface:\n"
  "get_normal(CollisionPlane self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionPlane_get_normal_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionPlane::dist_to_plane(LPoint3 const &point) const
 */
static PyObject *Dtool_CollisionPlane_dist_to_plane_181(PyObject *self, PyObject *arg) {
  CollisionPlane *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionPlane)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat CollisionPlane::dist_to_plane(LPoint3 const &point) const
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionPlane.dist_to_plane", "LPoint3f");
  }
  PN_stdfloat return_value = ((*(const CollisionPlane*)local_this).dist_to_plane)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dist_to_plane(CollisionPlane self, const LPoint3f point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionPlane_dist_to_plane_181_comment =
  "C++ Interface:\n"
  "dist_to_plane(CollisionPlane self, const LPoint3f point)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionPlane_dist_to_plane_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionPlane::set_plane(LPlane const &plane)
 */
static PyObject *Dtool_CollisionPlane_set_plane_182(PyObject *self, PyObject *arg) {
  CollisionPlane *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionPlane, (void **)&local_this, "CollisionPlane.set_plane")) {
    return nullptr;
  }
  // 1-inline void CollisionPlane::set_plane(LPlane const &plane)
  LPlanef arg_local;
  LPlane const *arg_this = Dtool_Coerce_LPlanef(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionPlane.set_plane", "LPlanef");
  }
  ((*local_this).set_plane)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_plane(const CollisionPlane self, const LPlanef plane)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionPlane_set_plane_182_comment =
  "C++ Interface:\n"
  "set_plane(const CollisionPlane self, const LPlanef plane)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionPlane_set_plane_182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPlane const &CollisionPlane::get_plane(void) const
 */
static PyObject *Dtool_CollisionPlane_get_plane_183(PyObject *self, PyObject *) {
  CollisionPlane *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionPlane)) {
    return nullptr;
  }
  // 1-inline LPlane const &CollisionPlane::get_plane(void) const
  LPlane const *return_value = &(((*(const CollisionPlane*)local_this).get_plane)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionPlane_get_plane_183_comment =
  "C++ Interface:\n"
  "get_plane(CollisionPlane self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionPlane_get_plane_183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionPlane::flip(void)
 */
static PyObject *Dtool_CollisionPlane_flip_184(PyObject *self, PyObject *) {
  CollisionPlane *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionPlane, (void **)&local_this, "CollisionPlane.flip")) {
    return nullptr;
  }
  // 1-inline void CollisionPlane::flip(void)
  ((*local_this).flip)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionPlane_flip_184_comment =
  "C++ Interface:\n"
  "flip(const CollisionPlane self)\n"
  "\n"
  "/**\n"
  " * Convenience method to flip the plane in-place.\n"
  " */";
#else
static const char *Dtool_CollisionPlane_flip_184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionPlane::get_class_type(void)
 */
static PyObject *Dtool_CollisionPlane_get_class_type_190(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionPlane::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionPlane::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionPlane_get_class_type_190_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionPlane_get_class_type_190_comment = nullptr;
#endif

static PyObject *Dtool_CollisionPlane_normal_Getter(PyObject *self, void *) {
  const CollisionPlane *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPlane, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVector3 CollisionPlane::get_normal(void) const
  LVector3 *return_value = new LVector3(((*(const CollisionPlane*)local_this).get_normal)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

static PyObject *Dtool_CollisionPlane_plane_Getter(PyObject *self, void *) {
  const CollisionPlane *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPlane, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPlane const &CollisionPlane::get_plane(void) const
  LPlane const *return_value = &(((*(const CollisionPlane*)local_this).get_plane)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPlanef, false, true);
}

static int Dtool_CollisionPlane_plane_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionPlane *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionPlane, (void **)&local_this, "CollisionPlane.plane")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete plane attribute");
    return -1;
  }
  // 1-inline void CollisionPlane::set_plane(LPlane const &plane)
  LPlanef arg_local;
  LPlane const *arg_this = Dtool_Coerce_LPlanef(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionPlane.set_plane", "LPlanef");
    return -1;
  }
  ((*local_this).set_plane)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_plane(const CollisionPlane self, const LPlanef plane)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline CollisionPlane::CollisionPlane(CollisionPlane const &copy)
 * inline CollisionPlane::CollisionPlane(LPlane const &plane)
 */
static int Dtool_Init_CollisionPlane(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CollisionPlane() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline CollisionPlane::CollisionPlane(CollisionPlane const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      CollisionPlane const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_CollisionPlane);
      if (param0_this != nullptr) {
        CollisionPlane *return_value = new CollisionPlane(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionPlane, true, false);
      }
    }
  }

  {
    // -2 inline CollisionPlane::CollisionPlane(LPlane const &plane)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "plane")) {
      LPlane const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LPlanef);
      if (param0_this != nullptr) {
        CollisionPlane *return_value = new CollisionPlane(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionPlane, true, false);
      }
    }
  }

  {
    // -2 inline CollisionPlane::CollisionPlane(CollisionPlane const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      CPT(CollisionPlane) param0_this;
      if (Dtool_ConstCoerce_CollisionPlane(param0, param0_this)) {
        CollisionPlane *return_value = new CollisionPlane(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionPlane, true, false);
      }
    }
  }

  {
    // -2 inline CollisionPlane::CollisionPlane(LPlane const &plane)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "plane")) {
      LPlanef param0_local;
      LPlane const *param0_this = Dtool_Coerce_LPlanef(param0, param0_local);
      if ((param0_this != nullptr)) {
        CollisionPlane *return_value = new CollisionPlane(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionPlane, true, false);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionPlane(const CollisionPlane copy)\n"
      "CollisionPlane(const LPlanef plane)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CollisionPlane(PyObject *args, CPT(CollisionPlane) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_CollisionPlane)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline CollisionPlane::CollisionPlane(LPlane const &plane)
    LPlane const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPlanef);
    if (arg_this != nullptr) {
      CollisionPlane *return_value = new CollisionPlane(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_CollisionPlane(PyObject *args, PT(CollisionPlane) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_CollisionPlane)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline CollisionPlane::CollisionPlane(LPlane const &plane)
    LPlane const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LPlanef);
    if (arg_this != nullptr) {
      CollisionPlane *return_value = new CollisionPlane(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_CollisionPlane(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionPlane) {
    printf("CollisionPlane ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionPlane *local_this = (CollisionPlane *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionPlane) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionPlane(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionPlane) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionPlane*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionPlane*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionFloorMesh
 */
/**
 * Python function wrapper for:
 * inline void CollisionFloorMesh::add_vertex(LPoint3 const &vert)
 */
static PyObject *Dtool_CollisionFloorMesh_add_vertex_194(PyObject *self, PyObject *arg) {
  CollisionFloorMesh *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionFloorMesh, (void **)&local_this, "CollisionFloorMesh.add_vertex")) {
    return nullptr;
  }
  // 1-inline void CollisionFloorMesh::add_vertex(LPoint3 const &vert)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionFloorMesh.add_vertex", "LPoint3f");
  }
  ((*local_this).add_vertex)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_vertex(const CollisionFloorMesh self, const LPoint3f vert)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionFloorMesh_add_vertex_194_comment =
  "C++ Interface:\n"
  "add_vertex(const CollisionFloorMesh self, const LPoint3f vert)\n"
  "\n"
  "/**\n"
  " * store away a vertex to index against\n"
  " */";
#else
static const char *Dtool_CollisionFloorMesh_add_vertex_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionFloorMesh::add_triangle(unsigned int pointA, unsigned int pointB, unsigned int pointC)
 */
static PyObject *Dtool_CollisionFloorMesh_add_triangle_195(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionFloorMesh *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionFloorMesh, (void **)&local_this, "CollisionFloorMesh.add_triangle")) {
    return nullptr;
  }
  // 1-void CollisionFloorMesh::add_triangle(unsigned int pointA, unsigned int pointB, unsigned int pointC)
  unsigned long param1;
  unsigned long param2;
  unsigned long param3;
  static const char *keyword_list[] = {"pointA", "pointB", "pointC", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kkk:add_triangle", (char **)keyword_list, &param1, &param2, &param3)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param3 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param3);
    }
#endif
    ((*local_this).add_triangle)((unsigned int)param1, (unsigned int)param2, (unsigned int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_triangle(const CollisionFloorMesh self, int pointA, int pointB, int pointC)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionFloorMesh_add_triangle_195_comment =
  "C++ Interface:\n"
  "add_triangle(const CollisionFloorMesh self, int pointA, int pointB, int pointC)\n"
  "\n"
  "/**\n"
  " * store a triangle for processing\n"
  " */";
#else
static const char *Dtool_CollisionFloorMesh_add_triangle_195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int CollisionFloorMesh::get_num_vertices(void) const
 */
static PyObject *Dtool_CollisionFloorMesh_get_num_vertices_196(PyObject *self, PyObject *) {
  CollisionFloorMesh *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionFloorMesh)) {
    return nullptr;
  }
  // 1-inline unsigned int CollisionFloorMesh::get_num_vertices(void) const
  unsigned int return_value = ((*(const CollisionFloorMesh*)local_this).get_num_vertices)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionFloorMesh_get_num_vertices_196_comment =
  "C++ Interface:\n"
  "get_num_vertices(CollisionFloorMesh self)\n";
#else
static const char *Dtool_CollisionFloorMesh_get_num_vertices_196_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionFloorMesh::get_vertex(unsigned int index) const
 */
static PyObject *Dtool_CollisionFloorMesh_get_vertex_197(PyObject *self, PyObject *arg) {
  CollisionFloorMesh *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionFloorMesh)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &CollisionFloorMesh::get_vertex(unsigned int index) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    LPoint3 const *return_value = &(((*(const CollisionFloorMesh*)local_this).get_vertex)((unsigned int)param1));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(CollisionFloorMesh self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionFloorMesh_get_vertex_197_comment =
  "C++ Interface:\n"
  "get_vertex(CollisionFloorMesh self, int index)\n";
#else
static const char *Dtool_CollisionFloorMesh_get_vertex_197_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int CollisionFloorMesh::get_num_triangles(void) const
 */
static PyObject *Dtool_CollisionFloorMesh_get_num_triangles_199(PyObject *self, PyObject *) {
  CollisionFloorMesh *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionFloorMesh)) {
    return nullptr;
  }
  // 1-inline unsigned int CollisionFloorMesh::get_num_triangles(void) const
  unsigned int return_value = ((*(const CollisionFloorMesh*)local_this).get_num_triangles)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionFloorMesh_get_num_triangles_199_comment =
  "C++ Interface:\n"
  "get_num_triangles(CollisionFloorMesh self)\n";
#else
static const char *Dtool_CollisionFloorMesh_get_num_triangles_199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3i CollisionFloorMesh::get_triangle(unsigned int index) const
 */
static PyObject *Dtool_CollisionFloorMesh_get_triangle_200(PyObject *self, PyObject *arg) {
  CollisionFloorMesh *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionFloorMesh)) {
    return nullptr;
  }
  // 1-inline LPoint3i CollisionFloorMesh::get_triangle(unsigned int index) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    LPoint3i *return_value = new LPoint3i(((*(const CollisionFloorMesh*)local_this).get_triangle)((unsigned int)param1));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_triangle(CollisionFloorMesh self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionFloorMesh_get_triangle_200_comment =
  "C++ Interface:\n"
  "get_triangle(CollisionFloorMesh self, int index)\n";
#else
static const char *Dtool_CollisionFloorMesh_get_triangle_200_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionFloorMesh::get_class_type(void)
 */
static PyObject *Dtool_CollisionFloorMesh_get_class_type_205(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionFloorMesh::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionFloorMesh::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionFloorMesh_get_class_type_205_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionFloorMesh_get_class_type_205_comment = nullptr;
#endif

/**
 * sequence length function for property CollisionFloorMesh::vertices
 */
static Py_ssize_t Dtool_CollisionFloorMesh_vertices_Len(PyObject *self) {
  CollisionFloorMesh *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionFloorMesh, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_vertices)();
}

/**
 * sequence getter for property CollisionFloorMesh::vertices
 */
static PyObject *Dtool_CollisionFloorMesh_vertices_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionFloorMesh *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionFloorMesh, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_vertices)()) {
    PyErr_SetString(PyExc_IndexError, "CollisionFloorMesh.vertices[] index out of range");
    return nullptr;
  }
  // 1-inline LPoint3 const &CollisionFloorMesh::get_vertex(unsigned int index) const
  LPoint3 const *return_value = &(((*(const CollisionFloorMesh*)local_this).get_vertex)(index));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vertex(CollisionFloorMesh self, index)\n");
  }
}

static PyObject *Dtool_CollisionFloorMesh_vertices_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "CollisionFloorMesh.vertices");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_CollisionFloorMesh_vertices_Len;
    wrap->_getitem_func = &Dtool_CollisionFloorMesh_vertices_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property CollisionFloorMesh::triangles
 */
static Py_ssize_t Dtool_CollisionFloorMesh_triangles_Len(PyObject *self) {
  CollisionFloorMesh *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionFloorMesh, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_triangles)();
}

/**
 * sequence getter for property CollisionFloorMesh::triangles
 */
static PyObject *Dtool_CollisionFloorMesh_triangles_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionFloorMesh *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionFloorMesh, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_triangles)()) {
    PyErr_SetString(PyExc_IndexError, "CollisionFloorMesh.triangles[] index out of range");
    return nullptr;
  }
  // 1-inline LPoint3i CollisionFloorMesh::get_triangle(unsigned int index) const
  LPoint3i *return_value = new LPoint3i(((*(const CollisionFloorMesh*)local_this).get_triangle)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3i, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_triangle(CollisionFloorMesh self, index)\n");
  }
}

static PyObject *Dtool_CollisionFloorMesh_triangles_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "CollisionFloorMesh.triangles");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_CollisionFloorMesh_triangles_Len;
    wrap->_getitem_func = &Dtool_CollisionFloorMesh_triangles_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline CollisionFloorMesh::CollisionFloorMesh(void)
 */
static int Dtool_Init_CollisionFloorMesh(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CollisionFloorMesh() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CollisionFloorMesh() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline CollisionFloorMesh::CollisionFloorMesh(void)
  CollisionFloorMesh *return_value = new CollisionFloorMesh();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionFloorMesh, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionFloorMesh()\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionFloorMesh_get_vertices(PyObject *self, PyObject *) {
  CollisionFloorMesh *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionFloorMesh, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_vertices)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionFloorMesh_get_vertex_197(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionFloorMesh_get_triangles(PyObject *self, PyObject *) {
  CollisionFloorMesh *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionFloorMesh, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_triangles)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionFloorMesh_get_triangle_200(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_CollisionFloorMesh(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionFloorMesh) {
    printf("CollisionFloorMesh ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionFloorMesh *local_this = (CollisionFloorMesh *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionFloorMesh) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionFloorMesh(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionFloorMesh) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionFloorMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionFloorMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionFloorMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionFloorMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionFloorMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionFloorMesh*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionFloorMesh*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionPolygon
 */
/**
 * Python function wrapper for:
 * inline std::size_t CollisionPolygon::get_num_points(void) const
 */
static PyObject *Dtool_CollisionPolygon_get_num_points_209(PyObject *self, PyObject *) {
  CollisionPolygon *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionPolygon)) {
    return nullptr;
  }
  // 1-inline std::size_t CollisionPolygon::get_num_points(void) const
  std::size_t return_value = ((*(const CollisionPolygon*)local_this).get_num_points)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionPolygon_get_num_points_209_comment =
  "C++ Interface:\n"
  "get_num_points(CollisionPolygon self)\n"
  "\n"
  "/**\n"
  " * Returns the number of vertices of the CollisionPolygon.\n"
  " */";
#else
static const char *Dtool_CollisionPolygon_get_num_points_209_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 CollisionPolygon::get_point(std::size_t n) const
 */
static PyObject *Dtool_CollisionPolygon_get_point_210(PyObject *self, PyObject *arg) {
  CollisionPolygon *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionPolygon)) {
    return nullptr;
  }
  // 1-inline LPoint3 CollisionPolygon::get_point(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    LPoint3 *return_value = new LPoint3(((*(const CollisionPolygon*)local_this).get_point)(arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(CollisionPolygon self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionPolygon_get_point_210_comment =
  "C++ Interface:\n"
  "get_point(CollisionPolygon self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth vertex of the CollisionPolygon, expressed in 3-D space.\n"
  " */";
#else
static const char *Dtool_CollisionPolygon_get_point_210_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static bool CollisionPolygon::verify_points(LPoint3 const *begin, LPoint3 const *end)
 * static inline bool CollisionPolygon::verify_points(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c)
 * static inline bool CollisionPolygon::verify_points(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c, LPoint3 const &d)
 */
static PyObject *Dtool_CollisionPolygon_verify_points_212(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-static bool CollisionPolygon::verify_points(LPoint3 const *begin, LPoint3 const *end)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"begin", "end", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:verify_points", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "CollisionPolygon.verify_points", "LPoint3f");
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "CollisionPolygon.verify_points", "LPoint3f");
        }
        bool return_value = (CollisionPolygon::verify_points)(param0_this, param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-static inline bool CollisionPolygon::verify_points(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"a", "b", "c", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:verify_points", (char **)keyword_list, &param0, &param1, &param2)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "CollisionPolygon.verify_points", "LPoint3f");
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "CollisionPolygon.verify_points", "LPoint3f");
        }
        LPoint3f param2_local;
        LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "CollisionPolygon.verify_points", "LPoint3f");
        }
        bool return_value = (CollisionPolygon::verify_points)(*param0_this, *param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-static inline bool CollisionPolygon::verify_points(LPoint3 const &a, LPoint3 const &b, LPoint3 const &c, LPoint3 const &d)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"a", "b", "c", "d", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:verify_points", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param0, 0, "CollisionPolygon.verify_points", "LPoint3f");
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "CollisionPolygon.verify_points", "LPoint3f");
        }
        LPoint3f param2_local;
        LPoint3 const *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "CollisionPolygon.verify_points", "LPoint3f");
        }
        LPoint3f param3_local;
        LPoint3 const *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "CollisionPolygon.verify_points", "LPoint3f");
        }
        bool return_value = (CollisionPolygon::verify_points)(*param0_this, *param1_this, *param2_this, *param3_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "verify_points() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "verify_points(const LPoint3f begin, const LPoint3f end)\n"
      "verify_points(const LPoint3f a, const LPoint3f b, const LPoint3f c)\n"
      "verify_points(const LPoint3f a, const LPoint3f b, const LPoint3f c, const LPoint3f d)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionPolygon_verify_points_212_comment =
  "C++ Interface:\n"
  "verify_points(const LPoint3f begin, const LPoint3f end)\n"
  "verify_points(const LPoint3f a, const LPoint3f b, const LPoint3f c)\n"
  "verify_points(const LPoint3f a, const LPoint3f b, const LPoint3f c, const LPoint3f d)\n"
  "\n"
  "/**\n"
  " * Verifies that the indicated set of points will define a valid\n"
  " * CollisionPolygon: that is, at least three non-collinear points, with no\n"
  " * points repeated.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Verifies that the indicated set of points will define a valid\n"
  " * CollisionPolygon: that is, at least three non-collinear points, with no\n"
  " * points repeated.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Verifies that the indicated set of points will define a valid\n"
  " * CollisionPolygon: that is, at least three non-collinear points, with no\n"
  " * points repeated.\n"
  " *\n"
  " * This does not check that the polygon defined is convex; that check is made\n"
  " * later, once we have projected the points to 2-d space where the decision is\n"
  " * easier.\n"
  " */";
#else
static const char *Dtool_CollisionPolygon_verify_points_212_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CollisionPolygon::is_valid(void) const
 */
static PyObject *Dtool_CollisionPolygon_is_valid_213(PyObject *self, PyObject *) {
  CollisionPolygon *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionPolygon)) {
    return nullptr;
  }
  // 1-bool CollisionPolygon::is_valid(void) const
  bool return_value = ((*(const CollisionPolygon*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionPolygon_is_valid_213_comment =
  "C++ Interface:\n"
  "is_valid(CollisionPolygon self)\n"
  "\n"
  "/**\n"
  " * Returns true if the CollisionPolygon is valid (that is, it has at least\n"
  " * three vertices), or false otherwise.\n"
  " */";
#else
static const char *Dtool_CollisionPolygon_is_valid_213_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CollisionPolygon::is_concave(void) const
 */
static PyObject *Dtool_CollisionPolygon_is_concave_214(PyObject *self, PyObject *) {
  CollisionPolygon *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionPolygon)) {
    return nullptr;
  }
  // 1-bool CollisionPolygon::is_concave(void) const
  bool return_value = ((*(const CollisionPolygon*)local_this).is_concave)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionPolygon_is_concave_214_comment =
  "C++ Interface:\n"
  "is_concave(CollisionPolygon self)\n"
  "\n"
  "/**\n"
  " * Returns true if the CollisionPolygon appears to be concave, or false if it\n"
  " * is safely convex.\n"
  " */";
#else
static const char *Dtool_CollisionPolygon_is_concave_214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionPolygon::get_class_type(void)
 */
static PyObject *Dtool_CollisionPolygon_get_class_type_218(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionPolygon::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionPolygon::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionPolygon_get_class_type_218_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionPolygon_get_class_type_218_comment = nullptr;
#endif

/**
 * sequence length function for property CollisionPolygon::points
 */
static Py_ssize_t Dtool_CollisionPolygon_points_Len(PyObject *self) {
  CollisionPolygon *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPolygon, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_points)();
}

/**
 * sequence getter for property CollisionPolygon::points
 */
static PyObject *Dtool_CollisionPolygon_points_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionPolygon *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPolygon, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_points)()) {
    PyErr_SetString(PyExc_IndexError, "CollisionPolygon.points[] index out of range");
    return nullptr;
  }
  // 1-inline LPoint3 CollisionPolygon::get_point(std::size_t n) const
  LPoint3 *return_value = new LPoint3(((*(const CollisionPolygon*)local_this).get_point)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(CollisionPolygon self, index)\n");
  }
}

static PyObject *Dtool_CollisionPolygon_points_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "CollisionPolygon.points");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_CollisionPolygon_points_Len;
    wrap->_getitem_func = &Dtool_CollisionPolygon_points_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_CollisionPolygon_valid_Getter(PyObject *self, void *) {
  const CollisionPolygon *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPolygon, (void **)&local_this)) {
    return nullptr;
  }

  // 1-bool CollisionPolygon::is_valid(void) const
  bool return_value = ((*(const CollisionPolygon*)local_this).is_valid)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CollisionPolygon_concave_Getter(PyObject *self, void *) {
  const CollisionPolygon *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPolygon, (void **)&local_this)) {
    return nullptr;
  }

  // 1-bool CollisionPolygon::is_concave(void) const
  bool return_value = ((*(const CollisionPolygon*)local_this).is_concave)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline CollisionPolygon::CollisionPolygon(LPoint3 const *begin, LPoint3 const *end)
 * inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c)
 * inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c, LVecBase3 const &d)
 */
static int Dtool_Init_CollisionPolygon(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline CollisionPolygon::CollisionPolygon(LPoint3 const *begin, LPoint3 const *end)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"begin", "end", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:CollisionPolygon", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionPolygon.CollisionPolygon", "LPoint3f");
          return -1;
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "CollisionPolygon.CollisionPolygon", "LPoint3f");
          return -1;
        }
        CollisionPolygon *return_value = new CollisionPolygon(param0_this, param1_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionPolygon, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"a", "b", "c", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:CollisionPolygon", (char **)keyword_list, &param0, &param1, &param2)) {
        LVecBase3f param0_local;
        LVecBase3 const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionPolygon.CollisionPolygon", "LVecBase3f");
          return -1;
        }
        LVecBase3f param1_local;
        LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "CollisionPolygon.CollisionPolygon", "LVecBase3f");
          return -1;
        }
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param2, 2, "CollisionPolygon.CollisionPolygon", "LVecBase3f");
          return -1;
        }
        CollisionPolygon *return_value = new CollisionPolygon(*param0_this, *param1_this, *param2_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionPolygon, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c, LVecBase3 const &d)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"a", "b", "c", "d", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:CollisionPolygon", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LVecBase3f param0_local;
        LVecBase3 const *param0_this = Dtool_Coerce_LVecBase3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionPolygon.CollisionPolygon", "LVecBase3f");
          return -1;
        }
        LVecBase3f param1_local;
        LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "CollisionPolygon.CollisionPolygon", "LVecBase3f");
          return -1;
        }
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param2, 2, "CollisionPolygon.CollisionPolygon", "LVecBase3f");
          return -1;
        }
        LVecBase3f param3_local;
        LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param3, 3, "CollisionPolygon.CollisionPolygon", "LVecBase3f");
          return -1;
        }
        CollisionPolygon *return_value = new CollisionPolygon(*param0_this, *param1_this, *param2_this, *param3_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionPolygon, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionPolygon() takes 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionPolygon(const LPoint3f begin, const LPoint3f end)\n"
      "CollisionPolygon(const LVecBase3f a, const LVecBase3f b, const LVecBase3f c)\n"
      "CollisionPolygon(const LVecBase3f a, const LVecBase3f b, const LVecBase3f c, const LVecBase3f d)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CollisionPolygon(PyObject *args, CPT(CollisionPolygon) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_CollisionPolygon)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline CollisionPolygon::CollisionPolygon(LPoint3 const *begin, LPoint3 const *end)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "CollisionPolygon", 2, 2, &param0, &param1)) {
          LPoint3 const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3f);
          if (param0_this != nullptr && param1_this != nullptr) {
            CollisionPolygon *return_value = new CollisionPolygon(param0_this, param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        if (PyArg_UnpackTuple(args, "CollisionPolygon", 3, 3, &param0, &param1, &param2)) {
          LVecBase3 const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LVecBase3f);
          LVecBase3 const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVecBase3f);
          LVecBase3 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVecBase3f);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            CollisionPolygon *return_value = new CollisionPolygon(*param0_this, *param1_this, *param2_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c, LVecBase3 const &d)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        if (PyArg_UnpackTuple(args, "CollisionPolygon", 4, 4, &param0, &param1, &param2, &param3)) {
          LVecBase3 const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LVecBase3f);
          LVecBase3 const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVecBase3f);
          LVecBase3 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVecBase3f);
          LVecBase3 const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase3f);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
            CollisionPolygon *return_value = new CollisionPolygon(*param0_this, *param1_this, *param2_this, *param3_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_CollisionPolygon(PyObject *args, PT(CollisionPolygon) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_CollisionPolygon)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-inline CollisionPolygon::CollisionPolygon(LPoint3 const *begin, LPoint3 const *end)
        PyObject *param0;
        PyObject *param1;
        if (PyArg_UnpackTuple(args, "CollisionPolygon", 2, 2, &param0, &param1)) {
          LPoint3 const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LPoint3f);
          LPoint3 const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LPoint3f);
          if (param0_this != nullptr && param1_this != nullptr) {
            CollisionPolygon *return_value = new CollisionPolygon(param0_this, param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        if (PyArg_UnpackTuple(args, "CollisionPolygon", 3, 3, &param0, &param1, &param2)) {
          LVecBase3 const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LVecBase3f);
          LVecBase3 const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVecBase3f);
          LVecBase3 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVecBase3f);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr) {
            CollisionPolygon *return_value = new CollisionPolygon(*param0_this, *param1_this, *param2_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 4: {
        // 1-inline CollisionPolygon::CollisionPolygon(LVecBase3 const &a, LVecBase3 const &b, LVecBase3 const &c, LVecBase3 const &d)
        PyObject *param0;
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        if (PyArg_UnpackTuple(args, "CollisionPolygon", 4, 4, &param0, &param1, &param2, &param3)) {
          LVecBase3 const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LVecBase3f);
          LVecBase3 const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVecBase3f);
          LVecBase3 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVecBase3f);
          LVecBase3 const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LVecBase3f);
          if (param0_this != nullptr && param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
            CollisionPolygon *return_value = new CollisionPolygon(*param0_this, *param1_this, *param2_this, *param3_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionPolygon_get_points(PyObject *self, PyObject *) {
  CollisionPolygon *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionPolygon, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_points)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionPolygon_get_point_210(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_CollisionPolygon(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionPolygon) {
    printf("CollisionPolygon ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionPolygon *local_this = (CollisionPolygon *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionPolygon) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionPlane *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionPlane) {
    return (CollisionPlane *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *)(CollisionPlane *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *)(CollisionPlane *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionPlane *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionPlane *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionPlane *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionPlane *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionPolygon(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionPolygon) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionPlane) {
    CollisionPlane* other_this = (CollisionPlane*)from_this;
    return (CollisionPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionPolygon*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionPolygon*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionHandlerEvent
 */
/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::clear_in_patterns(void)
 */
static PyObject *Dtool_CollisionHandlerEvent_clear_in_patterns_222(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.clear_in_patterns")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerEvent::clear_in_patterns(void)
  ((*local_this).clear_in_patterns)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_clear_in_patterns_222_comment =
  "C++ Interface:\n"
  "clear_in_patterns(const CollisionHandlerEvent self)\n"
  "\n"
  "/**\n"
  " * Removes all of the previously-added in patterns.  See add_in_pattern.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_clear_in_patterns_222_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::add_in_pattern(std::string const &in_pattern)
 */
static PyObject *Dtool_CollisionHandlerEvent_add_in_pattern_223(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.add_in_pattern")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerEvent::add_in_pattern(std::string const &in_pattern)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).add_in_pattern)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_in_pattern(const CollisionHandlerEvent self, str in_pattern)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_add_in_pattern_223_comment =
  "C++ Interface:\n"
  "add_in_pattern(const CollisionHandlerEvent self, str in_pattern)\n"
  "\n"
  "/**\n"
  " * Adds a pattern string to the list of events that will be generated in\n"
  " * response to a collision.  The pattern string describes how the event name\n"
  " * will be composed.  It is a string that may contain any of the following:\n"
  " *\n"
  " * %fn  - the name of the \"from\" object's node %in  - the name of the \"into\"\n"
  " * object's node %fs  - 't' if \"from\" is tangible, 'i' if intangible %is  -\n"
  " * 't' if \"into\" is tangible, 'i' if intangible %ig  - 'c' if the collision is\n"
  " * into a CollisionNode, 'g' if it is a geom.\n"
  " *\n"
  " * %(tag)fh - generate event only if \"from\" node has the indicated net tag.\n"
  " * %(tag)fx - generate event only if \"from\" node does not have the indicated\n"
  " * net tag.  %(tag)ih - generate event only if \"into\" node has the indicated\n"
  " * net tag.  %(tag)ix - generate event only if \"into\" node does not have the\n"
  " * indicated net tag.  %(tag)ft - the indicated net tag value of the \"from\"\n"
  " * node.  %(tag)it - the indicated net tag value of the \"into\" node.\n"
  " *\n"
  " * Parentheses in the above are literal and should be included in the actual\n"
  " * pattern.\n"
  " *\n"
  " * The event name will be based on the in_pattern string specified here, with\n"
  " * all occurrences of the above strings replaced with the corresponding\n"
  " * values.\n"
  " *\n"
  " * In general, the in_pattern event is thrown on the first detection of a\n"
  " * collision between two particular nodes.  In subsequent passes, as long as a\n"
  " * collision between those two nodes continues to be detected each frame, the\n"
  " * again_pattern is thrown.  The first frame in which the collision is no\n"
  " * longer detected, the out_pattern event is thrown.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_add_in_pattern_223_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::set_in_pattern(std::string const &in_pattern)
 */
static PyObject *Dtool_CollisionHandlerEvent_set_in_pattern_224(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.set_in_pattern")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerEvent::set_in_pattern(std::string const &in_pattern)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_in_pattern)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_in_pattern(const CollisionHandlerEvent self, str in_pattern)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_set_in_pattern_224_comment =
  "C++ Interface:\n"
  "set_in_pattern(const CollisionHandlerEvent self, str in_pattern)\n"
  "\n"
  "/**\n"
  " * This method is deprecated; it completely replaces all the in patterns that\n"
  " * have previously been set with the indicated pattern.\n"
  " *\n"
  " * @deprecated Use add_in_pattern() instead.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_set_in_pattern_224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int CollisionHandlerEvent::get_num_in_patterns(void) const
 */
static PyObject *Dtool_CollisionHandlerEvent_get_num_in_patterns_225(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerEvent)) {
    return nullptr;
  }
  // 1-inline int CollisionHandlerEvent::get_num_in_patterns(void) const
  int return_value = ((*(const CollisionHandlerEvent*)local_this).get_num_in_patterns)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_get_num_in_patterns_225_comment =
  "C++ Interface:\n"
  "get_num_in_patterns(CollisionHandlerEvent self)\n"
  "\n"
  "/**\n"
  " * Returns the number of in pattern strings that have been added.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_get_num_in_patterns_225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string CollisionHandlerEvent::get_in_pattern(int n) const
 */
static PyObject *Dtool_CollisionHandlerEvent_get_in_pattern_226(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerEvent)) {
    return nullptr;
  }
  // 1-inline std::string CollisionHandlerEvent::get_in_pattern(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const CollisionHandlerEvent*)local_this).get_in_pattern)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_in_pattern(CollisionHandlerEvent self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_get_in_pattern_226_comment =
  "C++ Interface:\n"
  "get_in_pattern(CollisionHandlerEvent self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth pattern string that indicates how the event names are\n"
  " * generated for each collision detected.  See add_in_pattern().\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_get_in_pattern_226_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::clear_again_patterns(void)
 */
static PyObject *Dtool_CollisionHandlerEvent_clear_again_patterns_228(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.clear_again_patterns")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerEvent::clear_again_patterns(void)
  ((*local_this).clear_again_patterns)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_clear_again_patterns_228_comment =
  "C++ Interface:\n"
  "clear_again_patterns(const CollisionHandlerEvent self)\n"
  "\n"
  "/**\n"
  " * Removes all of the previously-added in patterns.  See add_again_pattern.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_clear_again_patterns_228_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::add_again_pattern(std::string const &again_pattern)
 */
static PyObject *Dtool_CollisionHandlerEvent_add_again_pattern_229(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.add_again_pattern")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerEvent::add_again_pattern(std::string const &again_pattern)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).add_again_pattern)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_again_pattern(const CollisionHandlerEvent self, str again_pattern)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_add_again_pattern_229_comment =
  "C++ Interface:\n"
  "add_again_pattern(const CollisionHandlerEvent self, str again_pattern)\n"
  "\n"
  "/**\n"
  " * Adds the pattern string that indicates how the event names are generated\n"
  " * when a collision between two particular nodes is *still* detected.  This\n"
  " * event is thrown each consecutive time a collision between two particular\n"
  " * nodes is detected, starting with the second time.\n"
  " *\n"
  " * In general, the in_pattern event is thrown on the first detection of a\n"
  " * collision between two particular nodes.  In subsequent passes, as long as a\n"
  " * collision between those two nodes continues to be detected each frame, the\n"
  " * again_pattern is thrown.  The first frame in which the collision is no\n"
  " * longer detected, the out_pattern event is thrown.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_add_again_pattern_229_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::set_again_pattern(std::string const &again_pattern)
 */
static PyObject *Dtool_CollisionHandlerEvent_set_again_pattern_230(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.set_again_pattern")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerEvent::set_again_pattern(std::string const &again_pattern)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_again_pattern)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_again_pattern(const CollisionHandlerEvent self, str again_pattern)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_set_again_pattern_230_comment =
  "C++ Interface:\n"
  "set_again_pattern(const CollisionHandlerEvent self, str again_pattern)\n"
  "\n"
  "/**\n"
  " * This method is deprecated; it completely replaces all the in patterns that\n"
  " * have previously been set with the indicated pattern.\n"
  " *\n"
  " * @deprecated Use add_again_pattern() instead.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_set_again_pattern_230_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int CollisionHandlerEvent::get_num_again_patterns(void) const
 */
static PyObject *Dtool_CollisionHandlerEvent_get_num_again_patterns_231(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerEvent)) {
    return nullptr;
  }
  // 1-inline int CollisionHandlerEvent::get_num_again_patterns(void) const
  int return_value = ((*(const CollisionHandlerEvent*)local_this).get_num_again_patterns)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_get_num_again_patterns_231_comment =
  "C++ Interface:\n"
  "get_num_again_patterns(CollisionHandlerEvent self)\n"
  "\n"
  "/**\n"
  " * Returns the number of in pattern strings that have been added.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_get_num_again_patterns_231_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string CollisionHandlerEvent::get_again_pattern(int n) const
 */
static PyObject *Dtool_CollisionHandlerEvent_get_again_pattern_232(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerEvent)) {
    return nullptr;
  }
  // 1-inline std::string CollisionHandlerEvent::get_again_pattern(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const CollisionHandlerEvent*)local_this).get_again_pattern)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_again_pattern(CollisionHandlerEvent self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_get_again_pattern_232_comment =
  "C++ Interface:\n"
  "get_again_pattern(CollisionHandlerEvent self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth pattern string that indicates how the event names are\n"
  " * generated for each collision detected.  See add_again_pattern().\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_get_again_pattern_232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::clear_out_patterns(void)
 */
static PyObject *Dtool_CollisionHandlerEvent_clear_out_patterns_234(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.clear_out_patterns")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerEvent::clear_out_patterns(void)
  ((*local_this).clear_out_patterns)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_clear_out_patterns_234_comment =
  "C++ Interface:\n"
  "clear_out_patterns(const CollisionHandlerEvent self)\n"
  "\n"
  "/**\n"
  " * Removes all of the previously-added in patterns.  See add_out_pattern.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_clear_out_patterns_234_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::add_out_pattern(std::string const &out_pattern)
 */
static PyObject *Dtool_CollisionHandlerEvent_add_out_pattern_235(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.add_out_pattern")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerEvent::add_out_pattern(std::string const &out_pattern)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).add_out_pattern)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_out_pattern(const CollisionHandlerEvent self, str out_pattern)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_add_out_pattern_235_comment =
  "C++ Interface:\n"
  "add_out_pattern(const CollisionHandlerEvent self, str out_pattern)\n"
  "\n"
  "/**\n"
  " * Adds the pattern string that indicates how the event names are generated\n"
  " * when a collision between two particular nodes is *no longer* detected.\n"
  " *\n"
  " * In general, the in_pattern event is thrown on the first detection of a\n"
  " * collision between two particular nodes.  In subsequent passes, as long as a\n"
  " * collision between those two nodes continues to be detected each frame, the\n"
  " * again_pattern is thrown.  The first frame in which the collision is no\n"
  " * longer detected, the out_pattern event is thrown.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_add_out_pattern_235_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerEvent::set_out_pattern(std::string const &out_pattern)
 */
static PyObject *Dtool_CollisionHandlerEvent_set_out_pattern_236(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.set_out_pattern")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerEvent::set_out_pattern(std::string const &out_pattern)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_out_pattern)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_out_pattern(const CollisionHandlerEvent self, str out_pattern)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_set_out_pattern_236_comment =
  "C++ Interface:\n"
  "set_out_pattern(const CollisionHandlerEvent self, str out_pattern)\n"
  "\n"
  "/**\n"
  " * This method is deprecated; it completely replaces all the in patterns that\n"
  " * have previously been set with the indicated pattern.\n"
  " *\n"
  " * @deprecated Use add_out_pattern() instead.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_set_out_pattern_236_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int CollisionHandlerEvent::get_num_out_patterns(void) const
 */
static PyObject *Dtool_CollisionHandlerEvent_get_num_out_patterns_237(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerEvent)) {
    return nullptr;
  }
  // 1-inline int CollisionHandlerEvent::get_num_out_patterns(void) const
  int return_value = ((*(const CollisionHandlerEvent*)local_this).get_num_out_patterns)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_get_num_out_patterns_237_comment =
  "C++ Interface:\n"
  "get_num_out_patterns(CollisionHandlerEvent self)\n"
  "\n"
  "/**\n"
  " * Returns the number of in pattern strings that have been added.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_get_num_out_patterns_237_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string CollisionHandlerEvent::get_out_pattern(int n) const
 */
static PyObject *Dtool_CollisionHandlerEvent_get_out_pattern_238(PyObject *self, PyObject *arg) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerEvent)) {
    return nullptr;
  }
  // 1-inline std::string CollisionHandlerEvent::get_out_pattern(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const CollisionHandlerEvent*)local_this).get_out_pattern)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_out_pattern(CollisionHandlerEvent self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_get_out_pattern_238_comment =
  "C++ Interface:\n"
  "get_out_pattern(CollisionHandlerEvent self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth pattern string that indicates how the event names are\n"
  " * generated for each collision detected.  See add_out_pattern().\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_get_out_pattern_238_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionHandlerEvent::clear(void)
 */
static PyObject *Dtool_CollisionHandlerEvent_clear_245(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.clear")) {
    return nullptr;
  }
  // 1-void CollisionHandlerEvent::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_clear_245_comment =
  "C++ Interface:\n"
  "clear(const CollisionHandlerEvent self)\n"
  "\n"
  "/**\n"
  " * Empties the list of elements that all colliders are known to be colliding\n"
  " * with.  No \"out\" events will be thrown; if the same collision is detected\n"
  " * next frame, a new \"in\" event will be thrown for each collision.\n"
  " *\n"
  " * This can be called each frame to defeat the persistent \"in\" event\n"
  " * mechanism, which prevents the same \"in\" event from being thrown repeatedly.\n"
  " * However, also see add_again_pattern(), which can be used to set the event\n"
  " * that is thrown when a collision is detected for two or more consecutive\n"
  " * frames.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_clear_245_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionHandlerEvent::flush(void)
 */
static PyObject *Dtool_CollisionHandlerEvent_flush_246(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerEvent, (void **)&local_this, "CollisionHandlerEvent.flush")) {
    return nullptr;
  }
  // 1-void CollisionHandlerEvent::flush(void)
  ((*local_this).flush)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_flush_246_comment =
  "C++ Interface:\n"
  "flush(const CollisionHandlerEvent self)\n"
  "\n"
  "/**\n"
  " * Same as clear() except \"out\" events are thrown.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerEvent_flush_246_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandlerEvent::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandlerEvent_get_class_type_247(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandlerEvent::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionHandlerEvent::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerEvent_get_class_type_247_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandlerEvent_get_class_type_247_comment = nullptr;
#endif

/**
 * sequence length function for property CollisionHandlerEvent::in_patterns
 */
static Py_ssize_t Dtool_CollisionHandlerEvent_in_patterns_Len(PyObject *self) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_in_patterns)();
}

/**
 * sequence getter for property CollisionHandlerEvent::in_patterns
 */
static PyObject *Dtool_CollisionHandlerEvent_in_patterns_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_in_patterns)()) {
    PyErr_SetString(PyExc_IndexError, "CollisionHandlerEvent.in_patterns[] index out of range");
    return nullptr;
  }
  // 1-inline std::string CollisionHandlerEvent::get_in_pattern(int n) const
  std::string return_value = ((*(const CollisionHandlerEvent*)local_this).get_in_pattern)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_in_pattern(CollisionHandlerEvent self, index)\n");
  }
}

static PyObject *Dtool_CollisionHandlerEvent_in_patterns_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "CollisionHandlerEvent.in_patterns");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_CollisionHandlerEvent_in_patterns_Len;
    wrap->_getitem_func = &Dtool_CollisionHandlerEvent_in_patterns_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property CollisionHandlerEvent::again_patterns
 */
static Py_ssize_t Dtool_CollisionHandlerEvent_again_patterns_Len(PyObject *self) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_again_patterns)();
}

/**
 * sequence getter for property CollisionHandlerEvent::again_patterns
 */
static PyObject *Dtool_CollisionHandlerEvent_again_patterns_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_again_patterns)()) {
    PyErr_SetString(PyExc_IndexError, "CollisionHandlerEvent.again_patterns[] index out of range");
    return nullptr;
  }
  // 1-inline std::string CollisionHandlerEvent::get_out_pattern(int n) const
  std::string return_value = ((*(const CollisionHandlerEvent*)local_this).get_out_pattern)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_out_pattern(CollisionHandlerEvent self, index)\n");
  }
}

static PyObject *Dtool_CollisionHandlerEvent_again_patterns_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "CollisionHandlerEvent.again_patterns");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_CollisionHandlerEvent_again_patterns_Len;
    wrap->_getitem_func = &Dtool_CollisionHandlerEvent_again_patterns_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property CollisionHandlerEvent::out_patterns
 */
static Py_ssize_t Dtool_CollisionHandlerEvent_out_patterns_Len(PyObject *self) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_out_patterns)();
}

/**
 * sequence getter for property CollisionHandlerEvent::out_patterns
 */
static PyObject *Dtool_CollisionHandlerEvent_out_patterns_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_out_patterns)()) {
    PyErr_SetString(PyExc_IndexError, "CollisionHandlerEvent.out_patterns[] index out of range");
    return nullptr;
  }
  // 1-inline std::string CollisionHandlerEvent::get_out_pattern(int n) const
  std::string return_value = ((*(const CollisionHandlerEvent*)local_this).get_out_pattern)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_out_pattern(CollisionHandlerEvent self, index)\n");
  }
}

static PyObject *Dtool_CollisionHandlerEvent_out_patterns_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "CollisionHandlerEvent.out_patterns");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_CollisionHandlerEvent_out_patterns_Len;
    wrap->_getitem_func = &Dtool_CollisionHandlerEvent_out_patterns_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * CollisionHandlerEvent::CollisionHandlerEvent(void)
 * inline CollisionHandlerEvent::CollisionHandlerEvent(CollisionHandlerEvent const &) = default
 */
static int Dtool_Init_CollisionHandlerEvent(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CollisionHandlerEvent() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CollisionHandlerEvent::CollisionHandlerEvent(void)
      CollisionHandlerEvent *return_value = new CollisionHandlerEvent();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerEvent, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CollisionHandlerEvent::CollisionHandlerEvent(CollisionHandlerEvent const &) = default
      CollisionHandlerEvent const *arg_this = (CollisionHandlerEvent *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CollisionHandlerEvent, 0, "CollisionHandlerEvent.CollisionHandlerEvent", true, true);
      if (arg_this != nullptr) {
        CollisionHandlerEvent *return_value = new CollisionHandlerEvent(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerEvent, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionHandlerEvent() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionHandlerEvent()\n"
      "CollisionHandlerEvent(const CollisionHandlerEvent param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionHandlerEvent_get_in_patterns(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_in_patterns)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionHandlerEvent_get_in_pattern_226(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionHandlerEvent_get_again_patterns(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_again_patterns)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionHandlerEvent_get_again_pattern_232(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionHandlerEvent_get_out_patterns(PyObject *self, PyObject *) {
  CollisionHandlerEvent *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerEvent, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_out_patterns)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionHandlerEvent_get_out_pattern_238(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_CollisionHandlerEvent(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionHandlerEvent) {
    printf("CollisionHandlerEvent ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionHandlerEvent *local_this = (CollisionHandlerEvent *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionHandlerEvent) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionHandlerEvent(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerEvent) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (CollisionHandlerEvent*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandlerEvent*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandlerEvent*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandlerEvent*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionHandlerPhysical
 */
/**
 * Python function wrapper for:
 * void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target)
 * void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target, DriveInterface *drive_interface)
 */
static PyObject *Dtool_CollisionHandlerPhysical_add_collider_250(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionHandlerPhysical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerPhysical, (void **)&local_this, "CollisionHandlerPhysical.add_collider")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"collider", "target", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_collider", (char **)keyword_list, &param1, &param2)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "CollisionHandlerPhysical.add_collider", true, true);
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "CollisionHandlerPhysical.add_collider", true, true);
        if (param1_this != nullptr && param2_this != nullptr) {
          ((*local_this).add_collider)(*param1_this, *param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 3:
    {
      // 1-void CollisionHandlerPhysical::add_collider(NodePath const &collider, NodePath const &target, DriveInterface *drive_interface)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"collider", "target", "drive_interface", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:add_collider", (char **)keyword_list, &param1, &param2, &param3)) {
        NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "CollisionHandlerPhysical.add_collider", true, true);
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "CollisionHandlerPhysical.add_collider", true, true);
        DriveInterface *param3_this = (DriveInterface *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_DriveInterface, 3, "CollisionHandlerPhysical.add_collider", false, true);
        if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
          ((*local_this).add_collider)(*param1_this, *param2_this, param3_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_collider() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_collider(const CollisionHandlerPhysical self, const NodePath collider, const NodePath target)\n"
      "add_collider(const CollisionHandlerPhysical self, const NodePath collider, const NodePath target, DriveInterface drive_interface)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_add_collider_250_comment =
  "C++ Interface:\n"
  "add_collider(const CollisionHandlerPhysical self, const NodePath collider, const NodePath target)\n"
  "add_collider(const CollisionHandlerPhysical self, const NodePath collider, const NodePath target, DriveInterface drive_interface)\n"
  "\n"
  "/**\n"
  " * Adds a new collider to the list with a NodePath that will be updated with\n"
  " * the collider's new position, or updates the existing collider with a new\n"
  " * NodePath object.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new collider to the list with a NodePath that will be updated with\n"
  " * the collider's new position, or updates the existing collider with a new\n"
  " * NodePath object.\n"
  " *\n"
  " * The indicated DriveInterface will also be updated with the target's new\n"
  " * transform each frame.  This method should be used when the target is\n"
  " * directly controlled by a DriveInterface.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_add_collider_250_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CollisionHandlerPhysical::remove_collider(NodePath const &collider)
 */
static PyObject *Dtool_CollisionHandlerPhysical_remove_collider_251(PyObject *self, PyObject *arg) {
  CollisionHandlerPhysical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerPhysical, (void **)&local_this, "CollisionHandlerPhysical.remove_collider")) {
    return nullptr;
  }
  // 1-bool CollisionHandlerPhysical::remove_collider(NodePath const &collider)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionHandlerPhysical.remove_collider", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).remove_collider)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_collider(const CollisionHandlerPhysical self, const NodePath collider)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_remove_collider_251_comment =
  "C++ Interface:\n"
  "remove_collider(const CollisionHandlerPhysical self, const NodePath collider)\n"
  "\n"
  "/**\n"
  " * Removes the collider from the list of colliders that this handler knows\n"
  " * about.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_remove_collider_251_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CollisionHandlerPhysical::has_collider(NodePath const &collider) const
 */
static PyObject *Dtool_CollisionHandlerPhysical_has_collider_252(PyObject *self, PyObject *arg) {
  CollisionHandlerPhysical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerPhysical)) {
    return nullptr;
  }
  // 1-bool CollisionHandlerPhysical::has_collider(NodePath const &collider) const
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionHandlerPhysical.has_collider", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const CollisionHandlerPhysical*)local_this).has_collider)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_collider(CollisionHandlerPhysical self, const NodePath collider)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_has_collider_252_comment =
  "C++ Interface:\n"
  "has_collider(CollisionHandlerPhysical self, const NodePath collider)\n"
  "\n"
  "/**\n"
  " * Returns true if the handler knows about the indicated collider, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_has_collider_252_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionHandlerPhysical::clear_colliders(void)
 */
static PyObject *Dtool_CollisionHandlerPhysical_clear_colliders_253(PyObject *self, PyObject *) {
  CollisionHandlerPhysical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerPhysical, (void **)&local_this, "CollisionHandlerPhysical.clear_colliders")) {
    return nullptr;
  }
  // 1-void CollisionHandlerPhysical::clear_colliders(void)
  ((*local_this).clear_colliders)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_clear_colliders_253_comment =
  "C++ Interface:\n"
  "clear_colliders(const CollisionHandlerPhysical self)\n"
  "\n"
  "/**\n"
  " * Completely empties the list of colliders this handler knows about.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_clear_colliders_253_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerPhysical::set_center(NodePath const &center)
 */
static PyObject *Dtool_CollisionHandlerPhysical_set_center_254(PyObject *self, PyObject *arg) {
  CollisionHandlerPhysical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerPhysical, (void **)&local_this, "CollisionHandlerPhysical.set_center")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerPhysical::set_center(NodePath const &center)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionHandlerPhysical.set_center", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_center)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_center(const CollisionHandlerPhysical self, const NodePath center)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_set_center_254_comment =
  "C++ Interface:\n"
  "set_center(const CollisionHandlerPhysical self, const NodePath center)\n"
  "\n"
  "/**\n"
  " * Specifies an arbitrary NodePath that the handler is always considered to be\n"
  " * facing.  It does not detect collisions with surfaces that appear to be\n"
  " * facing away from this NodePath.  This works best when the collision\n"
  " * surfaces in question are polygons.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_set_center_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerPhysical::clear_center(void)
 */
static PyObject *Dtool_CollisionHandlerPhysical_clear_center_255(PyObject *self, PyObject *) {
  CollisionHandlerPhysical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerPhysical, (void **)&local_this, "CollisionHandlerPhysical.clear_center")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerPhysical::clear_center(void)
  ((*local_this).clear_center)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_clear_center_255_comment =
  "C++ Interface:\n"
  "clear_center(const CollisionHandlerPhysical self)\n"
  "\n"
  "/**\n"
  " * Clears the center NodePath specified with set_center.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_clear_center_255_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &CollisionHandlerPhysical::get_center(void) const
 */
static PyObject *Dtool_CollisionHandlerPhysical_get_center_256(PyObject *self, PyObject *) {
  CollisionHandlerPhysical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerPhysical)) {
    return nullptr;
  }
  // 1-inline NodePath const &CollisionHandlerPhysical::get_center(void) const
  NodePath const *return_value = &(((*(const CollisionHandlerPhysical*)local_this).get_center)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_get_center_256_comment =
  "C++ Interface:\n"
  "get_center(CollisionHandlerPhysical self)\n"
  "\n"
  "/**\n"
  " * Returns the NodePath specified with set_center, or the empty NodePath if\n"
  " * nothing has been specified.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_get_center_256_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionHandlerPhysical::has_center(void) const
 */
static PyObject *Dtool_CollisionHandlerPhysical_has_center_257(PyObject *self, PyObject *) {
  CollisionHandlerPhysical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerPhysical)) {
    return nullptr;
  }
  // 1-inline bool CollisionHandlerPhysical::has_center(void) const
  bool return_value = ((*(const CollisionHandlerPhysical*)local_this).has_center)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_has_center_257_comment =
  "C++ Interface:\n"
  "has_center(CollisionHandlerPhysical self)\n"
  "\n"
  "/**\n"
  " * Returns true if a NodePath has been specified with set_center(), false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_has_center_257_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionHandlerPhysical::has_contact(void) const
 */
static PyObject *Dtool_CollisionHandlerPhysical_has_contact_258(PyObject *self, PyObject *) {
  CollisionHandlerPhysical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerPhysical)) {
    return nullptr;
  }
  // 1-inline bool CollisionHandlerPhysical::has_contact(void) const
  bool return_value = ((*(const CollisionHandlerPhysical*)local_this).has_contact)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_has_contact_258_comment =
  "C++ Interface:\n"
  "has_contact(CollisionHandlerPhysical self)\n"
  "\n"
  "/**\n"
  " * Did the handler make any contacts with anything on the last collision pass?\n"
  " * Depending on how your world is setup, this can be used to tell if the\n"
  " * handler is out of the world (i.e.  out of bounds). That is the original use\n"
  " * of this call.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPhysical_has_contact_258_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandlerPhysical::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandlerPhysical_get_class_type_261(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandlerPhysical::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionHandlerPhysical::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPhysical_get_class_type_261_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandlerPhysical_get_class_type_261_comment = nullptr;
#endif

static PyObject *Dtool_CollisionHandlerPhysical_center_Getter(PyObject *self, void *) {
  const CollisionHandlerPhysical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerPhysical, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_center()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline NodePath const &CollisionHandlerPhysical::get_center(void) const
  NodePath const *return_value = &(((*(const CollisionHandlerPhysical*)local_this).get_center)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

static int Dtool_CollisionHandlerPhysical_center_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerPhysical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerPhysical, (void **)&local_this, "CollisionHandlerPhysical.center")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete center attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_center();
    return 0;
  }
  // 1-inline void CollisionHandlerPhysical::set_center(NodePath const &center)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "CollisionHandlerPhysical.set_center", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_center)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_center(const CollisionHandlerPhysical self, const NodePath center)\n");
  }
  return -1;
}

static int Dtool_Init_CollisionHandlerPhysical(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CollisionHandlerPhysical(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionHandlerPhysical) {
    printf("CollisionHandlerPhysical ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionHandlerPhysical *local_this = (CollisionHandlerPhysical *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionHandlerPhysical) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *)(CollisionHandlerEvent *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerEvent) {
    return (CollisionHandlerEvent *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionHandlerPhysical(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPhysical) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (CollisionHandlerPhysical*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerEvent) {
    CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
    return (CollisionHandlerPhysical*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandlerPhysical*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandlerPhysical*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandlerPhysical*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionHandlerFloor
 */
/**
 * Python function wrapper for:
 * inline void CollisionHandlerFloor::set_offset(PN_stdfloat offset)
 */
static PyObject *Dtool_CollisionHandlerFloor_set_offset_264(PyObject *self, PyObject *arg) {
  CollisionHandlerFloor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerFloor, (void **)&local_this, "CollisionHandlerFloor.set_offset")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerFloor::set_offset(PN_stdfloat offset)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_offset)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset(const CollisionHandlerFloor self, float offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerFloor_set_offset_264_comment =
  "C++ Interface:\n"
  "set_offset(const CollisionHandlerFloor self, float offset)\n"
  "\n"
  "/**\n"
  " * Sets the linear offset to add to (or subtract from) the highest detected\n"
  " * collision point to determine the actual height at which to set the\n"
  " * collider.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerFloor_set_offset_264_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerFloor::get_offset(void) const
 */
static PyObject *Dtool_CollisionHandlerFloor_get_offset_265(PyObject *self, PyObject *) {
  CollisionHandlerFloor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerFloor)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat CollisionHandlerFloor::get_offset(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerFloor*)local_this).get_offset)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerFloor_get_offset_265_comment =
  "C++ Interface:\n"
  "get_offset(CollisionHandlerFloor self)\n"
  "\n"
  "/**\n"
  " * Returns the linear offset to add to (or subtract from) the highest detected\n"
  " * collision point to determine the actual height at which to set the\n"
  " * collider.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerFloor_get_offset_265_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerFloor::set_reach(PN_stdfloat reach)
 */
static PyObject *Dtool_CollisionHandlerFloor_set_reach_266(PyObject *self, PyObject *arg) {
  CollisionHandlerFloor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerFloor, (void **)&local_this, "CollisionHandlerFloor.set_reach")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerFloor::set_reach(PN_stdfloat reach)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_reach)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_reach(const CollisionHandlerFloor self, float reach)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerFloor_set_reach_266_comment =
  "C++ Interface:\n"
  "set_reach(const CollisionHandlerFloor self, float reach)\n"
  "\n"
  "/**\n"
  " * Sets the reach to add to (or subtract from) the highest collision point\n"
  " */";
#else
static const char *Dtool_CollisionHandlerFloor_set_reach_266_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerFloor::get_reach(void) const
 */
static PyObject *Dtool_CollisionHandlerFloor_get_reach_267(PyObject *self, PyObject *) {
  CollisionHandlerFloor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerFloor)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat CollisionHandlerFloor::get_reach(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerFloor*)local_this).get_reach)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerFloor_get_reach_267_comment =
  "C++ Interface:\n"
  "get_reach(CollisionHandlerFloor self)\n"
  "\n"
  "/**\n"
  " * Returns the reach to add to (or subtract from) the highest collision point\n"
  " */";
#else
static const char *Dtool_CollisionHandlerFloor_get_reach_267_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerFloor::set_max_velocity(PN_stdfloat max_vel)
 */
static PyObject *Dtool_CollisionHandlerFloor_set_max_velocity_268(PyObject *self, PyObject *arg) {
  CollisionHandlerFloor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerFloor, (void **)&local_this, "CollisionHandlerFloor.set_max_velocity")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerFloor::set_max_velocity(PN_stdfloat max_vel)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_velocity)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_velocity(const CollisionHandlerFloor self, float max_vel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerFloor_set_max_velocity_268_comment =
  "C++ Interface:\n"
  "set_max_velocity(const CollisionHandlerFloor self, float max_vel)\n"
  "\n"
  "/**\n"
  " * Sets the maximum speed at which the object will be allowed to descend\n"
  " * towards a floor below it, in units per second.  Set this to zero to allow\n"
  " * it to instantly teleport any distance.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerFloor_set_max_velocity_268_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerFloor::get_max_velocity(void) const
 */
static PyObject *Dtool_CollisionHandlerFloor_get_max_velocity_269(PyObject *self, PyObject *) {
  CollisionHandlerFloor *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerFloor)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat CollisionHandlerFloor::get_max_velocity(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerFloor*)local_this).get_max_velocity)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerFloor_get_max_velocity_269_comment =
  "C++ Interface:\n"
  "get_max_velocity(CollisionHandlerFloor self)\n"
  "\n"
  "/**\n"
  " * Retrieves the maximum speed at which the object will be allowed to descend\n"
  " * towards a floor below it, in units per second.  See set_max_velocity().\n"
  " */";
#else
static const char *Dtool_CollisionHandlerFloor_get_max_velocity_269_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandlerFloor::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandlerFloor_get_class_type_273(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandlerFloor::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionHandlerFloor::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerFloor_get_class_type_273_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandlerFloor_get_class_type_273_comment = nullptr;
#endif

static PyObject *Dtool_CollisionHandlerFloor_offset_Getter(PyObject *self, void *) {
  const CollisionHandlerFloor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerFloor, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat CollisionHandlerFloor::get_offset(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerFloor*)local_this).get_offset)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerFloor_offset_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerFloor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerFloor, (void **)&local_this, "CollisionHandlerFloor.offset")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete offset attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerFloor::set_offset(PN_stdfloat offset)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_offset)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_offset(const CollisionHandlerFloor self, float offset)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionHandlerFloor_reach_Getter(PyObject *self, void *) {
  const CollisionHandlerFloor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerFloor, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat CollisionHandlerFloor::get_reach(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerFloor*)local_this).get_reach)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerFloor_reach_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerFloor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerFloor, (void **)&local_this, "CollisionHandlerFloor.reach")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete reach attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerFloor::set_reach(PN_stdfloat reach)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_reach)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_reach(const CollisionHandlerFloor self, float reach)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionHandlerFloor_max_velocity_Getter(PyObject *self, void *) {
  const CollisionHandlerFloor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerFloor, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat CollisionHandlerFloor::get_max_velocity(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerFloor*)local_this).get_max_velocity)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerFloor_max_velocity_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerFloor *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerFloor, (void **)&local_this, "CollisionHandlerFloor.max_velocity")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete max_velocity attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerFloor::set_max_velocity(PN_stdfloat max_vel)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_velocity)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_velocity(const CollisionHandlerFloor self, float max_vel)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * CollisionHandlerFloor::CollisionHandlerFloor(void)
 */
static int Dtool_Init_CollisionHandlerFloor(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CollisionHandlerFloor() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CollisionHandlerFloor() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-CollisionHandlerFloor::CollisionHandlerFloor(void)
  CollisionHandlerFloor *return_value = new CollisionHandlerFloor();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerFloor, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionHandlerFloor()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionHandlerFloor(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionHandlerFloor) {
    printf("CollisionHandlerFloor ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionHandlerFloor *local_this = (CollisionHandlerFloor *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionHandlerFloor) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerEvent) {
    return (CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerPhysical) {
    return (CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionHandlerFloor(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerFloor) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (CollisionHandlerFloor*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerEvent) {
    CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
    return (CollisionHandlerFloor*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPhysical) {
    CollisionHandlerPhysical* other_this = (CollisionHandlerPhysical*)from_this;
    return (CollisionHandlerFloor*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandlerFloor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandlerFloor*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandlerFloor*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionHandlerPusher
 */
/**
 * Python function wrapper for:
 * inline void CollisionHandlerPusher::set_horizontal(bool flag)
 */
static PyObject *Dtool_CollisionHandlerPusher_set_horizontal_276(PyObject *self, PyObject *arg) {
  CollisionHandlerPusher *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerPusher, (void **)&local_this, "CollisionHandlerPusher.set_horizontal")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerPusher::set_horizontal(bool flag)
  ((*local_this).set_horizontal)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_horizontal(const CollisionHandlerPusher self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPusher_set_horizontal_276_comment =
  "C++ Interface:\n"
  "set_horizontal(const CollisionHandlerPusher self, bool flag)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPusher_set_horizontal_276_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionHandlerPusher::get_horizontal(void) const
 */
static PyObject *Dtool_CollisionHandlerPusher_get_horizontal_277(PyObject *self, PyObject *) {
  CollisionHandlerPusher *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerPusher)) {
    return nullptr;
  }
  // 1-inline bool CollisionHandlerPusher::get_horizontal(void) const
  bool return_value = ((*(const CollisionHandlerPusher*)local_this).get_horizontal)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPusher_get_horizontal_277_comment =
  "C++ Interface:\n"
  "get_horizontal(CollisionHandlerPusher self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionHandlerPusher_get_horizontal_277_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandlerPusher::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandlerPusher_get_class_type_279(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandlerPusher::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionHandlerPusher::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerPusher_get_class_type_279_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandlerPusher_get_class_type_279_comment = nullptr;
#endif

static PyObject *Dtool_CollisionHandlerPusher_horizontal_Getter(PyObject *self, void *) {
  const CollisionHandlerPusher *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerPusher, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool CollisionHandlerPusher::get_horizontal(void) const
  bool return_value = ((*(const CollisionHandlerPusher*)local_this).get_horizontal)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerPusher_horizontal_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerPusher *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerPusher, (void **)&local_this, "CollisionHandlerPusher.horizontal")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete horizontal attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerPusher::set_horizontal(bool flag)
  ((*local_this).set_horizontal)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_horizontal(const CollisionHandlerPusher self, bool flag)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * CollisionHandlerPusher::CollisionHandlerPusher(void)
 */
static int Dtool_Init_CollisionHandlerPusher(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CollisionHandlerPusher() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CollisionHandlerPusher() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-CollisionHandlerPusher::CollisionHandlerPusher(void)
  CollisionHandlerPusher *return_value = new CollisionHandlerPusher();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerPusher, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionHandlerPusher()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionHandlerPusher(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionHandlerPusher) {
    printf("CollisionHandlerPusher ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionHandlerPusher *local_this = (CollisionHandlerPusher *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionHandlerPusher) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerEvent) {
    return (CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerPhysical) {
    return (CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionHandlerPusher(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPusher) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (CollisionHandlerPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerEvent) {
    CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
    return (CollisionHandlerPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPhysical) {
    CollisionHandlerPhysical* other_this = (CollisionHandlerPhysical*)from_this;
    return (CollisionHandlerPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandlerPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandlerPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandlerPusher*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionHandlerFluidPusher
 */
/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandlerFluidPusher::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandlerFluidPusher_get_class_type_282(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandlerFluidPusher::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionHandlerFluidPusher::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerFluidPusher_get_class_type_282_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandlerFluidPusher_get_class_type_282_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CollisionHandlerFluidPusher::CollisionHandlerFluidPusher(void)
 */
static int Dtool_Init_CollisionHandlerFluidPusher(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CollisionHandlerFluidPusher() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CollisionHandlerFluidPusher() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-CollisionHandlerFluidPusher::CollisionHandlerFluidPusher(void)
  CollisionHandlerFluidPusher *return_value = new CollisionHandlerFluidPusher();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerFluidPusher, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionHandlerFluidPusher()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionHandlerFluidPusher(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionHandlerFluidPusher) {
    printf("CollisionHandlerFluidPusher ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionHandlerFluidPusher *local_this = (CollisionHandlerFluidPusher *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionHandlerFluidPusher) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerEvent) {
    return (CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerPhysical) {
    return (CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerPusher) {
    return (CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionHandlerFluidPusher(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerFluidPusher) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (CollisionHandlerFluidPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerEvent) {
    CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
    return (CollisionHandlerFluidPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPhysical) {
    CollisionHandlerPhysical* other_this = (CollisionHandlerPhysical*)from_this;
    return (CollisionHandlerFluidPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPusher) {
    CollisionHandlerPusher* other_this = (CollisionHandlerPusher*)from_this;
    return (CollisionHandlerFluidPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandlerFluidPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandlerFluidPusher*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandlerFluidPusher*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionHandlerGravity
 */
/**
 * Python function wrapper for:
 * inline void CollisionHandlerGravity::set_offset(PN_stdfloat offset)
 */
static PyObject *Dtool_CollisionHandlerGravity_set_offset_286(PyObject *self, PyObject *arg) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.set_offset")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerGravity::set_offset(PN_stdfloat offset)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_offset)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset(const CollisionHandlerGravity self, float offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_set_offset_286_comment =
  "C++ Interface:\n"
  "set_offset(const CollisionHandlerGravity self, float offset)\n"
  "\n"
  "/**\n"
  " * Sets the linear offset to add to (or subtract from) the highest detected\n"
  " * collision point to determine the actual height at which to set the\n"
  " * collider.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_set_offset_286_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerGravity::get_offset(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_offset_287(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerGravity)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat CollisionHandlerGravity::get_offset(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerGravity*)local_this).get_offset)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_offset_287_comment =
  "C++ Interface:\n"
  "get_offset(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * Returns the linear offset to add to (or subtract from) the highest detected\n"
  " * collision point to determine the actual height at which to set the\n"
  " * collider.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_offset_287_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerGravity::set_reach(PN_stdfloat reach)
 */
static PyObject *Dtool_CollisionHandlerGravity_set_reach_288(PyObject *self, PyObject *arg) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.set_reach")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerGravity::set_reach(PN_stdfloat reach)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_reach)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_reach(const CollisionHandlerGravity self, float reach)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_set_reach_288_comment =
  "C++ Interface:\n"
  "set_reach(const CollisionHandlerGravity self, float reach)\n"
  "\n"
  "/**\n"
  " * Sets the reach to add to (or subtract from) the highest collision point\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_set_reach_288_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerGravity::get_reach(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_reach_289(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerGravity)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat CollisionHandlerGravity::get_reach(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerGravity*)local_this).get_reach)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_reach_289_comment =
  "C++ Interface:\n"
  "get_reach(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * Returns the reach to add to (or subtract from) the highest collision point\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_reach_289_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerGravity::get_airborne_height(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_airborne_height_290(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerGravity)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat CollisionHandlerGravity::get_airborne_height(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerGravity*)local_this).get_airborne_height)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_airborne_height_290_comment =
  "C++ Interface:\n"
  "get_airborne_height(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * Return the height of the object from the ground.\n"
  " *\n"
  " * The object might not necessarily be at rest.  Use is_on_ground() if you\n"
  " * want to know whether the object is on the ground and at rest.\n"
  " *\n"
  " * See Also: is_in_outer_space()\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_airborne_height_290_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionHandlerGravity::is_on_ground(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_is_on_ground_291(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerGravity)) {
    return nullptr;
  }
  // 1-inline bool CollisionHandlerGravity::is_on_ground(void) const
  bool return_value = ((*(const CollisionHandlerGravity*)local_this).is_on_ground)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_is_on_ground_291_comment =
  "C++ Interface:\n"
  "is_on_ground(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * Is the object at rest?\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_is_on_ground_291_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerGravity::get_impact_velocity(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_impact_velocity_292(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerGravity)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat CollisionHandlerGravity::get_impact_velocity(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerGravity*)local_this).get_impact_velocity)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_impact_velocity_292_comment =
  "C++ Interface:\n"
  "get_impact_velocity(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * How hard did the object hit the ground.  This value is set on impact with\n"
  " * the ground.  You may want to watch (poll) on is_on_groun() and when that is\n"
  " * true, call get_impact_velocity(). Normally I avoid polling, but we are\n"
  " * calling is_on_ground() frequently anyway.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_impact_velocity_292_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 const &CollisionHandlerGravity::get_contact_normal(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_contact_normal_293(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerGravity)) {
    return nullptr;
  }
  // 1-inline LVector3 const &CollisionHandlerGravity::get_contact_normal(void) const
  LVector3 const *return_value = &(((*(const CollisionHandlerGravity*)local_this).get_contact_normal)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_contact_normal_293_comment =
  "C++ Interface:\n"
  "get_contact_normal(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_contact_normal_293_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerGravity::add_velocity(PN_stdfloat velocity)
 */
static PyObject *Dtool_CollisionHandlerGravity_add_velocity_294(PyObject *self, PyObject *arg) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.add_velocity")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerGravity::add_velocity(PN_stdfloat velocity)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_velocity)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_velocity(const CollisionHandlerGravity self, float velocity)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_add_velocity_294_comment =
  "C++ Interface:\n"
  "add_velocity(const CollisionHandlerGravity self, float velocity)\n"
  "\n"
  "/**\n"
  " * Adds the sepcified amount to the current velocity.  This is mostly here\n"
  " * allow this common operation to be faster for scripting, but it's also more\n"
  " * concise even in cpp.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_add_velocity_294_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerGravity::set_velocity(PN_stdfloat velocity)
 */
static PyObject *Dtool_CollisionHandlerGravity_set_velocity_295(PyObject *self, PyObject *arg) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.set_velocity")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerGravity::set_velocity(PN_stdfloat velocity)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_velocity)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_velocity(const CollisionHandlerGravity self, float velocity)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_set_velocity_295_comment =
  "C++ Interface:\n"
  "set_velocity(const CollisionHandlerGravity self, float velocity)\n"
  "\n"
  "/**\n"
  " * Sets the current vertical velocity.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_set_velocity_295_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerGravity::get_velocity(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_velocity_296(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerGravity)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat CollisionHandlerGravity::get_velocity(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerGravity*)local_this).get_velocity)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_velocity_296_comment =
  "C++ Interface:\n"
  "get_velocity(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * Gets the current vertical velocity.\n"
  " *\n"
  " * Generally, negative values mean the object is in free fall; while postive\n"
  " * values mean the object has vertical thrust.\n"
  " *\n"
  " * A zero value does not necessarily mean the object on the ground, it may\n"
  " * also be weightless and/or at the apex of its jump.\n"
  " *\n"
  " * See Also: is_on_ground() and get_gravity()\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_velocity_296_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerGravity::set_gravity(PN_stdfloat gravity)
 */
static PyObject *Dtool_CollisionHandlerGravity_set_gravity_297(PyObject *self, PyObject *arg) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.set_gravity")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerGravity::set_gravity(PN_stdfloat gravity)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_gravity)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gravity(const CollisionHandlerGravity self, float gravity)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_set_gravity_297_comment =
  "C++ Interface:\n"
  "set_gravity(const CollisionHandlerGravity self, float gravity)\n"
  "\n"
  "/**\n"
  " * Sets the linear gravity force (always plumb).\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_set_gravity_297_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerGravity::get_gravity(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_gravity_298(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerGravity)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat CollisionHandlerGravity::get_gravity(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerGravity*)local_this).get_gravity)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_gravity_298_comment =
  "C++ Interface:\n"
  "get_gravity(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * Gets the linear gravity force (always plumb).\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_gravity_298_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerGravity::set_max_velocity(PN_stdfloat max_vel)
 */
static PyObject *Dtool_CollisionHandlerGravity_set_max_velocity_299(PyObject *self, PyObject *arg) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.set_max_velocity")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerGravity::set_max_velocity(PN_stdfloat max_vel)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_velocity)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_velocity(const CollisionHandlerGravity self, float max_vel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_set_max_velocity_299_comment =
  "C++ Interface:\n"
  "set_max_velocity(const CollisionHandlerGravity self, float max_vel)\n"
  "\n"
  "/**\n"
  " * Sets the maximum speed at which the object will be allowed to descend\n"
  " * towards a floor below it, in units per second.  Set this to zero to allow\n"
  " * it to instantly teleport any distance.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_set_max_velocity_299_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionHandlerGravity::get_max_velocity(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_max_velocity_300(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerGravity)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat CollisionHandlerGravity::get_max_velocity(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerGravity*)local_this).get_max_velocity)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_max_velocity_300_comment =
  "C++ Interface:\n"
  "get_max_velocity(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * Retrieves the maximum speed at which the object will be allowed to descend\n"
  " * towards a floor below it, in units per second.  See set_max_velocity().\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_max_velocity_300_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionHandlerGravity::set_legacy_mode(bool legacy_mode)
 */
static PyObject *Dtool_CollisionHandlerGravity_set_legacy_mode_301(PyObject *self, PyObject *arg) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.set_legacy_mode")) {
    return nullptr;
  }
  // 1-inline void CollisionHandlerGravity::set_legacy_mode(bool legacy_mode)
  ((*local_this).set_legacy_mode)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_legacy_mode(const CollisionHandlerGravity self, bool legacy_mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_set_legacy_mode_301_comment =
  "C++ Interface:\n"
  "set_legacy_mode(const CollisionHandlerGravity self, bool legacy_mode)\n"
  "\n"
  "/**\n"
  " * Enables old behavior required by Toontown (Sellbot Factory lava room is\n"
  " * good test case, lava and conveyor belt specifically). Behavior is to throw\n"
  " * enter/exit events only for floor that the toon is in contact with\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_set_legacy_mode_301_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CollisionHandlerGravity::get_legacy_mode(void) const
 */
static PyObject *Dtool_CollisionHandlerGravity_get_legacy_mode_302(PyObject *self, PyObject *) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerGravity)) {
    return nullptr;
  }
  // 1-inline bool CollisionHandlerGravity::get_legacy_mode(void) const
  bool return_value = ((*(const CollisionHandlerGravity*)local_this).get_legacy_mode)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_legacy_mode_302_comment =
  "C++ Interface:\n"
  "get_legacy_mode(CollisionHandlerGravity self)\n"
  "\n"
  "/**\n"
  " * returns true if legacy mode is enabled\n"
  " */";
#else
static const char *Dtool_CollisionHandlerGravity_get_legacy_mode_302_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandlerGravity::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandlerGravity_get_class_type_313(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandlerGravity::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionHandlerGravity::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerGravity_get_class_type_313_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandlerGravity_get_class_type_313_comment = nullptr;
#endif

static PyObject *Dtool_CollisionHandlerGravity_offset_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat CollisionHandlerGravity::get_offset(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerGravity*)local_this).get_offset)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerGravity_offset_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.offset")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete offset attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerGravity::set_offset(PN_stdfloat offset)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_offset)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_offset(const CollisionHandlerGravity self, float offset)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionHandlerGravity_reach_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat CollisionHandlerGravity::get_reach(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerGravity*)local_this).get_reach)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerGravity_reach_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.reach")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete reach attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerGravity::set_reach(PN_stdfloat reach)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_reach)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_reach(const CollisionHandlerGravity self, float reach)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionHandlerGravity_airborne_height_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat CollisionHandlerGravity::get_airborne_height(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerGravity*)local_this).get_airborne_height)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CollisionHandlerGravity_on_ground_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool CollisionHandlerGravity::is_on_ground(void) const
  bool return_value = ((*(const CollisionHandlerGravity*)local_this).is_on_ground)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CollisionHandlerGravity_impact_velocity_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat CollisionHandlerGravity::get_impact_velocity(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerGravity*)local_this).get_impact_velocity)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CollisionHandlerGravity_contact_normal_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVector3 const &CollisionHandlerGravity::get_contact_normal(void) const
  LVector3 const *return_value = &(((*(const CollisionHandlerGravity*)local_this).get_contact_normal)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

static PyObject *Dtool_CollisionHandlerGravity_velocity_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat CollisionHandlerGravity::get_velocity(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerGravity*)local_this).get_velocity)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerGravity_velocity_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.velocity")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete velocity attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerGravity::set_velocity(PN_stdfloat velocity)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_velocity)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_velocity(const CollisionHandlerGravity self, float velocity)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionHandlerGravity_gravity_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat CollisionHandlerGravity::get_gravity(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerGravity*)local_this).get_gravity)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerGravity_gravity_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.gravity")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete gravity attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerGravity::set_gravity(PN_stdfloat gravity)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_gravity)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_gravity(const CollisionHandlerGravity self, float gravity)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionHandlerGravity_max_velocity_Getter(PyObject *self, void *) {
  const CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerGravity, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat CollisionHandlerGravity::get_max_velocity(void) const
  PN_stdfloat return_value = ((*(const CollisionHandlerGravity*)local_this).get_max_velocity)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionHandlerGravity_max_velocity_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionHandlerGravity *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerGravity, (void **)&local_this, "CollisionHandlerGravity.max_velocity")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete max_velocity attribute");
    return -1;
  }
  // 1-inline void CollisionHandlerGravity::set_max_velocity(PN_stdfloat max_vel)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_velocity)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_velocity(const CollisionHandlerGravity self, float max_vel)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * CollisionHandlerGravity::CollisionHandlerGravity(void)
 */
static int Dtool_Init_CollisionHandlerGravity(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CollisionHandlerGravity() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CollisionHandlerGravity() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-CollisionHandlerGravity::CollisionHandlerGravity(void)
  CollisionHandlerGravity *return_value = new CollisionHandlerGravity();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerGravity, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionHandlerGravity()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionHandlerGravity(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionHandlerGravity) {
    printf("CollisionHandlerGravity ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionHandlerGravity *local_this = (CollisionHandlerGravity *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionHandlerGravity) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerEvent) {
    return (CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerPhysical) {
    return (CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionHandlerGravity(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerGravity) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (CollisionHandlerGravity*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerEvent) {
    CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
    return (CollisionHandlerGravity*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPhysical) {
    CollisionHandlerPhysical* other_this = (CollisionHandlerPhysical*)from_this;
    return (CollisionHandlerGravity*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandlerGravity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandlerGravity*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandlerGravity*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionHandlerHighestEvent
 */
/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandlerHighestEvent::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandlerHighestEvent_get_class_type_316(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandlerHighestEvent::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionHandlerHighestEvent::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerHighestEvent_get_class_type_316_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandlerHighestEvent_get_class_type_316_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(void)
 * inline CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(CollisionHandlerHighestEvent const &) = default
 */
static int Dtool_Init_CollisionHandlerHighestEvent(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CollisionHandlerHighestEvent() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(void)
      CollisionHandlerHighestEvent *return_value = new CollisionHandlerHighestEvent();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerHighestEvent, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CollisionHandlerHighestEvent::CollisionHandlerHighestEvent(CollisionHandlerHighestEvent const &) = default
      CollisionHandlerHighestEvent const *arg_this = (CollisionHandlerHighestEvent *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CollisionHandlerHighestEvent, 0, "CollisionHandlerHighestEvent.CollisionHandlerHighestEvent", true, true);
      if (arg_this != nullptr) {
        CollisionHandlerHighestEvent *return_value = new CollisionHandlerHighestEvent(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerHighestEvent, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionHandlerHighestEvent() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionHandlerHighestEvent()\n"
      "CollisionHandlerHighestEvent(const CollisionHandlerHighestEvent param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionHandlerHighestEvent(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionHandlerHighestEvent) {
    printf("CollisionHandlerHighestEvent ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionHandlerHighestEvent *local_this = (CollisionHandlerHighestEvent *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionHandlerHighestEvent) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *)(CollisionHandlerEvent *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerEvent) {
    return (CollisionHandlerEvent *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionHandlerHighestEvent(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerHighestEvent) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (CollisionHandlerHighestEvent*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerEvent) {
    CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
    return (CollisionHandlerHighestEvent*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandlerHighestEvent*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandlerHighestEvent*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandlerHighestEvent*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionHandlerQueue
 */
/**
 * Python function wrapper for:
 * void CollisionHandlerQueue::sort_entries(void)
 */
static PyObject *Dtool_CollisionHandlerQueue_sort_entries_320(PyObject *self, PyObject *) {
  CollisionHandlerQueue *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerQueue, (void **)&local_this, "CollisionHandlerQueue.sort_entries")) {
    return nullptr;
  }
  // 1-void CollisionHandlerQueue::sort_entries(void)
  ((*local_this).sort_entries)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerQueue_sort_entries_320_comment =
  "C++ Interface:\n"
  "sort_entries(const CollisionHandlerQueue self)\n"
  "\n"
  "/**\n"
  " * Sorts all the detected collisions front-to-back by\n"
  " * from_intersection_point() so that those intersection points closest to the\n"
  " * collider's origin (e.g., the center of the CollisionSphere, or the point_a\n"
  " * of a CollisionSegment) appear first.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerQueue_sort_entries_320_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionHandlerQueue::clear_entries(void)
 */
static PyObject *Dtool_CollisionHandlerQueue_clear_entries_321(PyObject *self, PyObject *) {
  CollisionHandlerQueue *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionHandlerQueue, (void **)&local_this, "CollisionHandlerQueue.clear_entries")) {
    return nullptr;
  }
  // 1-void CollisionHandlerQueue::clear_entries(void)
  ((*local_this).clear_entries)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerQueue_clear_entries_321_comment =
  "C++ Interface:\n"
  "clear_entries(const CollisionHandlerQueue self)\n"
  "\n"
  "/**\n"
  " * Removes all the entries from the queue.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerQueue_clear_entries_321_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CollisionHandlerQueue::get_num_entries(void) const
 */
static PyObject *Dtool_CollisionHandlerQueue_get_num_entries_322(PyObject *self, PyObject *) {
  CollisionHandlerQueue *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerQueue)) {
    return nullptr;
  }
  // 1-int CollisionHandlerQueue::get_num_entries(void) const
  int return_value = ((*(const CollisionHandlerQueue*)local_this).get_num_entries)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerQueue_get_num_entries_322_comment =
  "C++ Interface:\n"
  "get_num_entries(CollisionHandlerQueue self)\n"
  "\n"
  "/**\n"
  " * Returns the number of CollisionEntries detected last pass.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerQueue_get_num_entries_322_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CollisionEntry *CollisionHandlerQueue::get_entry(int n) const
 */
static PyObject *Dtool_CollisionHandlerQueue_get_entry_323(PyObject *self, PyObject *arg) {
  CollisionHandlerQueue *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerQueue)) {
    return nullptr;
  }
  // 1-CollisionEntry *CollisionHandlerQueue::get_entry(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    CollisionEntry *return_value = ((*(const CollisionHandlerQueue*)local_this).get_entry)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionEntry, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entry(CollisionHandlerQueue self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerQueue_get_entry_323_comment =
  "C++ Interface:\n"
  "get_entry(CollisionHandlerQueue self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth CollisionEntry detected last pass.\n"
  " */";
#else
static const char *Dtool_CollisionHandlerQueue_get_entry_323_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionHandlerQueue::output(std::ostream &out) const
 */
static PyObject *Dtool_CollisionHandlerQueue_output_327(PyObject *self, PyObject *arg) {
  CollisionHandlerQueue *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerQueue)) {
    return nullptr;
  }
  // 1-void CollisionHandlerQueue::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "CollisionHandlerQueue.output", false, true);
  if (arg_this != nullptr) {
    ((*(const CollisionHandlerQueue*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CollisionHandlerQueue self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerQueue_output_327_comment =
  "C++ Interface:\n"
  "output(CollisionHandlerQueue self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionHandlerQueue_output_327_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CollisionHandlerQueue::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_CollisionHandlerQueue_write_328(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionHandlerQueue *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionHandlerQueue)) {
    return nullptr;
  }
  // 1-void CollisionHandlerQueue::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "CollisionHandlerQueue.write", false, true);
    if (param1_this != nullptr) {
      ((*(const CollisionHandlerQueue*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(CollisionHandlerQueue self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerQueue_write_328_comment =
  "C++ Interface:\n"
  "write(CollisionHandlerQueue self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionHandlerQueue_write_328_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionHandlerQueue::get_class_type(void)
 */
static PyObject *Dtool_CollisionHandlerQueue_get_class_type_329(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionHandlerQueue::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionHandlerQueue::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionHandlerQueue_get_class_type_329_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionHandlerQueue_get_class_type_329_comment = nullptr;
#endif

/**
 * sequence length function for property CollisionHandlerQueue::entries
 */
static Py_ssize_t Dtool_CollisionHandlerQueue_entries_Len(PyObject *self) {
  CollisionHandlerQueue *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerQueue, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_entries)();
}

/**
 * sequence getter for property CollisionHandlerQueue::entries
 */
static PyObject *Dtool_CollisionHandlerQueue_entries_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  CollisionHandlerQueue *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerQueue, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_entries)()) {
    PyErr_SetString(PyExc_IndexError, "CollisionHandlerQueue.entries[] index out of range");
    return nullptr;
  }
  // 1-CollisionEntry *CollisionHandlerQueue::get_entry(int n) const
  CollisionEntry *return_value = ((*(const CollisionHandlerQueue*)local_this).get_entry)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CollisionEntry, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_entry(CollisionHandlerQueue self, index)\n");
  }
}

static PyObject *Dtool_CollisionHandlerQueue_entries_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "CollisionHandlerQueue.entries");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_CollisionHandlerQueue_entries_Len;
    wrap->_getitem_func = &Dtool_CollisionHandlerQueue_entries_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * CollisionHandlerQueue::CollisionHandlerQueue(void)
 * inline CollisionHandlerQueue::CollisionHandlerQueue(CollisionHandlerQueue const &) = default
 */
static int Dtool_Init_CollisionHandlerQueue(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CollisionHandlerQueue() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CollisionHandlerQueue::CollisionHandlerQueue(void)
      CollisionHandlerQueue *return_value = new CollisionHandlerQueue();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerQueue, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CollisionHandlerQueue::CollisionHandlerQueue(CollisionHandlerQueue const &) = default
      CollisionHandlerQueue const *arg_this = (CollisionHandlerQueue *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CollisionHandlerQueue, 0, "CollisionHandlerQueue.CollisionHandlerQueue", true, true);
      if (arg_this != nullptr) {
        CollisionHandlerQueue *return_value = new CollisionHandlerQueue(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionHandlerQueue, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionHandlerQueue() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionHandlerQueue()\n"
      "CollisionHandlerQueue(const CollisionHandlerQueue param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_CollisionHandlerQueue_get_entries(PyObject *self, PyObject *) {
  CollisionHandlerQueue *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerQueue, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_entries)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_CollisionHandlerQueue_get_entry_323(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_CollisionHandlerQueue(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionHandlerQueue) {
    printf("CollisionHandlerQueue ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionHandlerQueue *local_this = (CollisionHandlerQueue *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionHandlerQueue) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionHandlerQueue(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerQueue) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (CollisionHandlerQueue*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionHandlerQueue*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionHandlerQueue*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CollisionHandlerQueue*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionSphere
 */
/**
 * Python function wrapper for:
 * inline void CollisionSphere::set_center(LPoint3 const &center)
 * inline void CollisionSphere::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_CollisionSphere_set_center_333(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionSphere *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSphere, (void **)&local_this, "CollisionSphere.set_center")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "center")) {
        // 1-inline void CollisionSphere::set_center(LPoint3 const &center)
        LPoint3f arg_local;
        LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "CollisionSphere.set_center", "LPoint3f");
        }
        ((*local_this).set_center)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void CollisionSphere::set_center(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_center", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_center)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_center() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_center(const CollisionSphere self, const LPoint3f center)\n"
      "set_center(const CollisionSphere self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSphere_set_center_333_comment =
  "C++ Interface:\n"
  "set_center(const CollisionSphere self, const LPoint3f center)\n"
  "set_center(const CollisionSphere self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSphere_set_center_333_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionSphere::get_center(void) const
 */
static PyObject *Dtool_CollisionSphere_get_center_334(PyObject *self, PyObject *) {
  CollisionSphere *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionSphere)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &CollisionSphere::get_center(void) const
  LPoint3 const *return_value = &(((*(const CollisionSphere*)local_this).get_center)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSphere_get_center_334_comment =
  "C++ Interface:\n"
  "get_center(CollisionSphere self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSphere_get_center_334_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionSphere::set_radius(PN_stdfloat radius)
 */
static PyObject *Dtool_CollisionSphere_set_radius_335(PyObject *self, PyObject *arg) {
  CollisionSphere *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSphere, (void **)&local_this, "CollisionSphere.set_radius")) {
    return nullptr;
  }
  // 1-inline void CollisionSphere::set_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_radius)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const CollisionSphere self, float radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSphere_set_radius_335_comment =
  "C++ Interface:\n"
  "set_radius(const CollisionSphere self, float radius)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSphere_set_radius_335_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionSphere::get_radius(void) const
 */
static PyObject *Dtool_CollisionSphere_get_radius_336(PyObject *self, PyObject *) {
  CollisionSphere *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionSphere)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat CollisionSphere::get_radius(void) const
  PN_stdfloat return_value = ((*(const CollisionSphere*)local_this).get_radius)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSphere_get_radius_336_comment =
  "C++ Interface:\n"
  "get_radius(CollisionSphere self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSphere_get_radius_336_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionSphere::get_class_type(void)
 */
static PyObject *Dtool_CollisionSphere_get_class_type_339(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionSphere::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionSphere::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSphere_get_class_type_339_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionSphere_get_class_type_339_comment = nullptr;
#endif

static PyObject *Dtool_CollisionSphere_center_Getter(PyObject *self, void *) {
  const CollisionSphere *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSphere, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint3 const &CollisionSphere::get_center(void) const
  LPoint3 const *return_value = &(((*(const CollisionSphere*)local_this).get_center)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_CollisionSphere_center_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionSphere *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSphere, (void **)&local_this, "CollisionSphere.center")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete center attribute");
    return -1;
  }
  // 1-inline void CollisionSphere::set_center(LPoint3 const &center)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionSphere.set_center", "LPoint3f");
    return -1;
  }
  ((*local_this).set_center)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_center(const CollisionSphere self, const LPoint3f center)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionSphere_radius_Getter(PyObject *self, void *) {
  const CollisionSphere *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSphere, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat CollisionSphere::get_radius(void) const
  PN_stdfloat return_value = ((*(const CollisionSphere*)local_this).get_radius)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionSphere_radius_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionSphere *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSphere, (void **)&local_this, "CollisionSphere.radius")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete radius attribute");
    return -1;
  }
  // 1-inline void CollisionSphere::set_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_radius)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_radius(const CollisionSphere self, float radius)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline explicit CollisionSphere::CollisionSphere(LPoint3 const &center, PN_stdfloat radius)
 * inline explicit CollisionSphere::CollisionSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius)
 */
static int Dtool_Init_CollisionSphere(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline explicit CollisionSphere::CollisionSphere(LPoint3 const &center, PN_stdfloat radius)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"center", "radius", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:CollisionSphere", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionSphere.CollisionSphere", "LPoint3f");
          return -1;
        }
        CollisionSphere *return_value = new CollisionSphere(*param0_this, (PN_stdfloat)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionSphere, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline explicit CollisionSphere::CollisionSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"cx", "cy", "cz", "radius", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:CollisionSphere", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        CollisionSphere *return_value = new CollisionSphere((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionSphere, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionSphere() takes 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionSphere(const LPoint3f center, float radius)\n"
      "CollisionSphere(float cx, float cy, float cz, float radius)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionSphere(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionSphere) {
    printf("CollisionSphere ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionSphere *local_this = (CollisionSphere *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionSphere) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionSphere(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionSphere) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionSphere*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionInvSphere
 */
/**
 * Python function wrapper for:
 * static TypeHandle CollisionInvSphere::get_class_type(void)
 */
static PyObject *Dtool_CollisionInvSphere_get_class_type_343(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionInvSphere::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionInvSphere::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionInvSphere_get_class_type_343_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionInvSphere_get_class_type_343_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline explicit CollisionInvSphere::CollisionInvSphere(LPoint3 const &center, PN_stdfloat radius)
 * inline explicit CollisionInvSphere::CollisionInvSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius)
 */
static int Dtool_Init_CollisionInvSphere(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline explicit CollisionInvSphere::CollisionInvSphere(LPoint3 const &center, PN_stdfloat radius)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"center", "radius", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:CollisionInvSphere", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionInvSphere.CollisionInvSphere", "LPoint3f");
          return -1;
        }
        CollisionInvSphere *return_value = new CollisionInvSphere(*param0_this, (PN_stdfloat)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionInvSphere, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline explicit CollisionInvSphere::CollisionInvSphere(PN_stdfloat cx, PN_stdfloat cy, PN_stdfloat cz, PN_stdfloat radius)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"cx", "cy", "cz", "radius", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:CollisionInvSphere", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        CollisionInvSphere *return_value = new CollisionInvSphere((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionInvSphere, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionInvSphere() takes 2 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionInvSphere(const LPoint3f center, float radius)\n"
      "CollisionInvSphere(float cx, float cy, float cz, float radius)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionInvSphere(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionInvSphere) {
    printf("CollisionInvSphere ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionInvSphere *local_this = (CollisionInvSphere *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionInvSphere) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionSphere *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *)(CollisionSphere *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSphere) {
    return (CollisionSphere *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *)(CollisionSphere *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionSphere *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionSphere *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionSphere *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionSphere *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionInvSphere(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionInvSphere) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionInvSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionInvSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSphere) {
    CollisionSphere* other_this = (CollisionSphere*)from_this;
    return (CollisionInvSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionInvSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionInvSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionInvSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionInvSphere*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionInvSphere*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionRay
 */
/**
 * Python function wrapper for:
 * inline void CollisionRay::set_origin(LPoint3 const &origin)
 * inline void CollisionRay::set_origin(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_CollisionRay_set_origin_347(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionRay *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionRay, (void **)&local_this, "CollisionRay.set_origin")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "origin")) {
        // 1-inline void CollisionRay::set_origin(LPoint3 const &origin)
        LPoint3f arg_local;
        LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "CollisionRay.set_origin", "LPoint3f");
        }
        ((*local_this).set_origin)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void CollisionRay::set_origin(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_origin", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_origin)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_origin() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_origin(const CollisionRay self, const LPoint3f origin)\n"
      "set_origin(const CollisionRay self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionRay_set_origin_347_comment =
  "C++ Interface:\n"
  "set_origin(const CollisionRay self, const LPoint3f origin)\n"
  "set_origin(const CollisionRay self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionRay_set_origin_347_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionRay::get_origin(void) const
 */
static PyObject *Dtool_CollisionRay_get_origin_348(PyObject *self, PyObject *) {
  CollisionRay *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionRay)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &CollisionRay::get_origin(void) const
  LPoint3 const *return_value = &(((*(const CollisionRay*)local_this).get_origin)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionRay_get_origin_348_comment =
  "C++ Interface:\n"
  "get_origin(CollisionRay self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionRay_get_origin_348_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionRay::set_direction(LVector3 const &direction)
 * inline void CollisionRay::set_direction(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_CollisionRay_set_direction_350(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionRay *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionRay, (void **)&local_this, "CollisionRay.set_direction")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "direction")) {
        // 1-inline void CollisionRay::set_direction(LVector3 const &direction)
        LVector3f arg_local;
        LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "CollisionRay.set_direction", "LVector3f");
        }
        ((*local_this).set_direction)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void CollisionRay::set_direction(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_direction", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_direction)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_direction() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_direction(const CollisionRay self, const LVector3f direction)\n"
      "set_direction(const CollisionRay self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionRay_set_direction_350_comment =
  "C++ Interface:\n"
  "set_direction(const CollisionRay self, const LVector3f direction)\n"
  "set_direction(const CollisionRay self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionRay_set_direction_350_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 const &CollisionRay::get_direction(void) const
 */
static PyObject *Dtool_CollisionRay_get_direction_351(PyObject *self, PyObject *) {
  CollisionRay *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionRay)) {
    return nullptr;
  }
  // 1-inline LVector3 const &CollisionRay::get_direction(void) const
  LVector3 const *return_value = &(((*(const CollisionRay*)local_this).get_direction)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionRay_get_direction_351_comment =
  "C++ Interface:\n"
  "get_direction(CollisionRay self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionRay_get_direction_351_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CollisionRay::set_from_lens(LensNode *camera, LPoint2 const &point)
 * inline bool CollisionRay::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py)
 */
static PyObject *Dtool_CollisionRay_set_from_lens_353(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionRay *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionRay, (void **)&local_this, "CollisionRay.set_from_lens")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-bool CollisionRay::set_from_lens(LensNode *camera, LPoint2 const &point)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"camera", "point", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_from_lens", (char **)keyword_list, &param1, &param2)) {
        LensNode *param1_this = (LensNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LensNode, 1, "CollisionRay.set_from_lens", false, true);
        LPoint2f param2_local;
        LPoint2 const *param2_this = Dtool_Coerce_LPoint2f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "CollisionRay.set_from_lens", "LPoint2f");
        }
        if (param1_this != nullptr) {
          bool return_value = ((*local_this).set_from_lens)(param1_this, *param2_this);
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
  case 3:
    {
      // 1-inline bool CollisionRay::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py)
      PyObject *param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"camera", "px", "py", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:set_from_lens", (char **)keyword_list, &param1, &param2, &param3)) {
        LensNode *param1_this = (LensNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LensNode, 1, "CollisionRay.set_from_lens", false, true);
        if (param1_this != nullptr) {
          bool return_value = ((*local_this).set_from_lens)(param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3);
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_from_lens() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_lens(const CollisionRay self, LensNode camera, const LPoint2f point)\n"
      "set_from_lens(const CollisionRay self, LensNode camera, float px, float py)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionRay_set_from_lens_353_comment =
  "C++ Interface:\n"
  "set_from_lens(const CollisionRay self, LensNode camera, const LPoint2f point)\n"
  "set_from_lens(const CollisionRay self, LensNode camera, float px, float py)\n"
  "\n"
  "/**\n"
  " * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the\n"
  " * CollisionRay so that it begins at the LensNode's near plane and extends to\n"
  " * infinity, making it suitable for picking objects from the screen given a\n"
  " * camera and a mouse location.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the\n"
  " * CollisionRay so that it begins at the LensNode's near plane and extends to\n"
  " * infinity, making it suitable for picking objects from the screen given a\n"
  " * camera and a mouse location.\n"
  " *\n"
  " * Returns true if the point was acceptable, false otherwise.\n"
  " */";
#else
static const char *Dtool_CollisionRay_set_from_lens_353_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionRay::get_class_type(void)
 */
static PyObject *Dtool_CollisionRay_get_class_type_354(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionRay::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionRay::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionRay_get_class_type_354_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionRay_get_class_type_354_comment = nullptr;
#endif

static PyObject *Dtool_CollisionRay_origin_Getter(PyObject *self, void *) {
  const CollisionRay *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionRay, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint3 const &CollisionRay::get_origin(void) const
  LPoint3 const *return_value = &(((*(const CollisionRay*)local_this).get_origin)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_CollisionRay_origin_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionRay *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionRay, (void **)&local_this, "CollisionRay.origin")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete origin attribute");
    return -1;
  }
  // 1-inline void CollisionRay::set_origin(LPoint3 const &origin)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionRay.set_origin", "LPoint3f");
    return -1;
  }
  ((*local_this).set_origin)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_origin(const CollisionRay self, const LPoint3f origin)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionRay_direction_Getter(PyObject *self, void *) {
  const CollisionRay *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionRay, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVector3 const &CollisionRay::get_direction(void) const
  LVector3 const *return_value = &(((*(const CollisionRay*)local_this).get_direction)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

static int Dtool_CollisionRay_direction_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionRay *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionRay, (void **)&local_this, "CollisionRay.direction")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete direction attribute");
    return -1;
  }
  // 1-inline void CollisionRay::set_direction(LVector3 const &direction)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionRay.set_direction", "LVector3f");
    return -1;
  }
  ((*local_this).set_direction)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_direction(const CollisionRay self, const LVector3f direction)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline CollisionRay::CollisionRay(void)
 * inline explicit CollisionRay::CollisionRay(LPoint3 const &origin, LVector3 const &direction)
 * inline explicit CollisionRay::CollisionRay(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz)
 */
static int Dtool_Init_CollisionRay(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline CollisionRay::CollisionRay(void)
      CollisionRay *return_value = new CollisionRay();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionRay, true, false);
    }
    break;
  case 2:
    {
      // 1-inline explicit CollisionRay::CollisionRay(LPoint3 const &origin, LVector3 const &direction)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"origin", "direction", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:CollisionRay", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionRay.CollisionRay", "LPoint3f");
          return -1;
        }
        LVector3f param1_local;
        LVector3 const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "CollisionRay.CollisionRay", "LVector3f");
          return -1;
        }
        CollisionRay *return_value = new CollisionRay(*param0_this, *param1_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionRay, true, false);
      }
    }
    break;
  case 6:
    {
      // 1-inline explicit CollisionRay::CollisionRay(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz)
      float param0;
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"ox", "oy", "oz", "dx", "dy", "dz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:CollisionRay", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
        CollisionRay *return_value = new CollisionRay((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionRay, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionRay() takes 0, 2 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionRay()\n"
      "CollisionRay(const LPoint3f origin, const LVector3f direction)\n"
      "CollisionRay(float ox, float oy, float oz, float dx, float dy, float dz)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionRay(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionRay) {
    printf("CollisionRay ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionRay *local_this = (CollisionRay *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionRay) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionRay(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionRay) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionRay*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionRay*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionRay*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionRay*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionRay*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionRay*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionRay*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionLine
 */
/**
 * Python function wrapper for:
 * static TypeHandle CollisionLine::get_class_type(void)
 */
static PyObject *Dtool_CollisionLine_get_class_type_358(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionLine::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionLine::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionLine_get_class_type_358_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionLine_get_class_type_358_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CollisionLine::CollisionLine(void)
 * inline explicit CollisionLine::CollisionLine(LPoint3 const &origin, LVector3 const &direction)
 * inline explicit CollisionLine::CollisionLine(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz)
 */
static int Dtool_Init_CollisionLine(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline CollisionLine::CollisionLine(void)
      CollisionLine *return_value = new CollisionLine();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionLine, true, false);
    }
    break;
  case 2:
    {
      // 1-inline explicit CollisionLine::CollisionLine(LPoint3 const &origin, LVector3 const &direction)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"origin", "direction", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:CollisionLine", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionLine.CollisionLine", "LPoint3f");
          return -1;
        }
        LVector3f param1_local;
        LVector3 const *param1_this = Dtool_Coerce_LVector3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "CollisionLine.CollisionLine", "LVector3f");
          return -1;
        }
        CollisionLine *return_value = new CollisionLine(*param0_this, *param1_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionLine, true, false);
      }
    }
    break;
  case 6:
    {
      // 1-inline explicit CollisionLine::CollisionLine(PN_stdfloat ox, PN_stdfloat oy, PN_stdfloat oz, PN_stdfloat dx, PN_stdfloat dy, PN_stdfloat dz)
      float param0;
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"ox", "oy", "oz", "dx", "dy", "dz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:CollisionLine", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
        CollisionLine *return_value = new CollisionLine((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionLine, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionLine() takes 0, 2 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionLine()\n"
      "CollisionLine(const LPoint3f origin, const LVector3f direction)\n"
      "CollisionLine(float ox, float oy, float oz, float dx, float dy, float dz)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionLine(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionLine) {
    printf("CollisionLine ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionLine *local_this = (CollisionLine *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionLine) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionRay *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionRay) {
    return (CollisionRay *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *)(CollisionRay *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *)(CollisionRay *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionRay *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionRay *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionRay *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *)(CollisionRay *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionLine(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionLine) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionLine*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionRay) {
    CollisionRay* other_this = (CollisionRay*)from_this;
    return (CollisionLine*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionLine*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionLine*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionLine*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionLine*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionLine*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionLine*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionParabola
 */
/**
 * Python function wrapper for:
 * inline void CollisionParabola::set_parabola(LParabola const &parabola)
 */
static PyObject *Dtool_CollisionParabola_set_parabola_362(PyObject *self, PyObject *arg) {
  CollisionParabola *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionParabola, (void **)&local_this, "CollisionParabola.set_parabola")) {
    return nullptr;
  }
  // 1-inline void CollisionParabola::set_parabola(LParabola const &parabola)
  LParabolaf arg_local;
  LParabola const *arg_this = Dtool_Coerce_LParabolaf(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CollisionParabola.set_parabola", "LParabolaf");
  }
  ((*local_this).set_parabola)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_parabola(const CollisionParabola self, const LParabolaf parabola)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionParabola_set_parabola_362_comment =
  "C++ Interface:\n"
  "set_parabola(const CollisionParabola self, const LParabolaf parabola)\n"
  "\n"
  "/**\n"
  " * Replaces the parabola specified by this solid.\n"
  " */";
#else
static const char *Dtool_CollisionParabola_set_parabola_362_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LParabola const &CollisionParabola::get_parabola(void) const
 */
static PyObject *Dtool_CollisionParabola_get_parabola_363(PyObject *self, PyObject *) {
  CollisionParabola *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionParabola)) {
    return nullptr;
  }
  // 1-inline LParabola const &CollisionParabola::get_parabola(void) const
  LParabola const *return_value = &(((*(const CollisionParabola*)local_this).get_parabola)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LParabolaf, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionParabola_get_parabola_363_comment =
  "C++ Interface:\n"
  "get_parabola(CollisionParabola self)\n"
  "\n"
  "/**\n"
  " * Returns the parabola specified by this solid.\n"
  " */";
#else
static const char *Dtool_CollisionParabola_get_parabola_363_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionParabola::set_t1(PN_stdfloat t1)
 */
static PyObject *Dtool_CollisionParabola_set_t1_364(PyObject *self, PyObject *arg) {
  CollisionParabola *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionParabola, (void **)&local_this, "CollisionParabola.set_t1")) {
    return nullptr;
  }
  // 1-inline void CollisionParabola::set_t1(PN_stdfloat t1)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_t1)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_t1(const CollisionParabola self, float t1)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionParabola_set_t1_364_comment =
  "C++ Interface:\n"
  "set_t1(const CollisionParabola self, float t1)\n"
  "\n"
  "/**\n"
  " * Changes the starting point on the parabola.\n"
  " */";
#else
static const char *Dtool_CollisionParabola_set_t1_364_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionParabola::get_t1(void) const
 */
static PyObject *Dtool_CollisionParabola_get_t1_365(PyObject *self, PyObject *) {
  CollisionParabola *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionParabola)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat CollisionParabola::get_t1(void) const
  PN_stdfloat return_value = ((*(const CollisionParabola*)local_this).get_t1)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionParabola_get_t1_365_comment =
  "C++ Interface:\n"
  "get_t1(CollisionParabola self)\n"
  "\n"
  "/**\n"
  " * Returns the starting point on the parabola.\n"
  " */";
#else
static const char *Dtool_CollisionParabola_get_t1_365_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionParabola::set_t2(PN_stdfloat t2)
 */
static PyObject *Dtool_CollisionParabola_set_t2_366(PyObject *self, PyObject *arg) {
  CollisionParabola *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionParabola, (void **)&local_this, "CollisionParabola.set_t2")) {
    return nullptr;
  }
  // 1-inline void CollisionParabola::set_t2(PN_stdfloat t2)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_t2)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_t2(const CollisionParabola self, float t2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionParabola_set_t2_366_comment =
  "C++ Interface:\n"
  "set_t2(const CollisionParabola self, float t2)\n"
  "\n"
  "/**\n"
  " * Changes the ending point on the parabola.\n"
  " */";
#else
static const char *Dtool_CollisionParabola_set_t2_366_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat CollisionParabola::get_t2(void) const
 */
static PyObject *Dtool_CollisionParabola_get_t2_367(PyObject *self, PyObject *) {
  CollisionParabola *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionParabola)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat CollisionParabola::get_t2(void) const
  PN_stdfloat return_value = ((*(const CollisionParabola*)local_this).get_t2)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CollisionParabola_get_t2_367_comment =
  "C++ Interface:\n"
  "get_t2(CollisionParabola self)\n"
  "\n"
  "/**\n"
  " * Returns the ending point on the parabola.\n"
  " */";
#else
static const char *Dtool_CollisionParabola_get_t2_367_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionParabola::get_class_type(void)
 */
static PyObject *Dtool_CollisionParabola_get_class_type_374(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionParabola::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionParabola::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionParabola_get_class_type_374_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionParabola_get_class_type_374_comment = nullptr;
#endif

static PyObject *Dtool_CollisionParabola_parabola_Getter(PyObject *self, void *) {
  const CollisionParabola *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionParabola, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LParabola const &CollisionParabola::get_parabola(void) const
  LParabola const *return_value = &(((*(const CollisionParabola*)local_this).get_parabola)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LParabolaf, false, true);
}

static int Dtool_CollisionParabola_parabola_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionParabola *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionParabola, (void **)&local_this, "CollisionParabola.parabola")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete parabola attribute");
    return -1;
  }
  // 1-inline void CollisionParabola::set_parabola(LParabola const &parabola)
  LParabolaf arg_local;
  LParabola const *arg_this = Dtool_Coerce_LParabolaf(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionParabola.set_parabola", "LParabolaf");
    return -1;
  }
  ((*local_this).set_parabola)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_parabola(const CollisionParabola self, const LParabolaf parabola)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionParabola_t1_Getter(PyObject *self, void *) {
  const CollisionParabola *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionParabola, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat CollisionParabola::get_t1(void) const
  PN_stdfloat return_value = ((*(const CollisionParabola*)local_this).get_t1)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionParabola_t1_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionParabola *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionParabola, (void **)&local_this, "CollisionParabola.t1")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete t1 attribute");
    return -1;
  }
  // 1-inline void CollisionParabola::set_t1(PN_stdfloat t1)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_t1)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_t1(const CollisionParabola self, float t1)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionParabola_t2_Getter(PyObject *self, void *) {
  const CollisionParabola *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionParabola, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat CollisionParabola::get_t2(void) const
  PN_stdfloat return_value = ((*(const CollisionParabola*)local_this).get_t2)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CollisionParabola_t2_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionParabola *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionParabola, (void **)&local_this, "CollisionParabola.t2")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete t2 attribute");
    return -1;
  }
  // 1-inline void CollisionParabola::set_t2(PN_stdfloat t2)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_t2)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_t2(const CollisionParabola self, float t2)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline CollisionParabola::CollisionParabola(void)
 * inline explicit CollisionParabola::CollisionParabola(LParabola const &parabola, PN_stdfloat t1, PN_stdfloat t2)
 */
static int Dtool_Init_CollisionParabola(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline CollisionParabola::CollisionParabola(void)
      CollisionParabola *return_value = new CollisionParabola();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionParabola, true, false);
    }
    break;
  case 3:
    {
      // 1-inline explicit CollisionParabola::CollisionParabola(LParabola const &parabola, PN_stdfloat t1, PN_stdfloat t2)
      PyObject *param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"parabola", "t1", "t2", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:CollisionParabola", (char **)keyword_list, &param0, &param1, &param2)) {
        LParabolaf param0_local;
        LParabola const *param0_this = Dtool_Coerce_LParabolaf(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionParabola.CollisionParabola", "LParabolaf");
          return -1;
        }
        CollisionParabola *return_value = new CollisionParabola(*param0_this, (PN_stdfloat)param1, (PN_stdfloat)param2);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionParabola, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionParabola() takes 0 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionParabola()\n"
      "CollisionParabola(const LParabolaf parabola, float t1, float t2)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionParabola(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionParabola) {
    printf("CollisionParabola ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionParabola *local_this = (CollisionParabola *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionParabola) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionParabola(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionParabola) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionParabola*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionParabola*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionParabola*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionParabola*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionParabola*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionParabola*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionParabola*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CollisionSegment
 */
/**
 * Python function wrapper for:
 * inline void CollisionSegment::set_point_a(LPoint3 const &a)
 * inline void CollisionSegment::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_CollisionSegment_set_point_a_378(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionSegment *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSegment, (void **)&local_this, "CollisionSegment.set_point_a")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "a")) {
        // 1-inline void CollisionSegment::set_point_a(LPoint3 const &a)
        LPoint3f arg_local;
        LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "CollisionSegment.set_point_a", "LPoint3f");
        }
        ((*local_this).set_point_a)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void CollisionSegment::set_point_a(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_point_a", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_point_a)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_point_a() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point_a(const CollisionSegment self, const LPoint3f a)\n"
      "set_point_a(const CollisionSegment self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSegment_set_point_a_378_comment =
  "C++ Interface:\n"
  "set_point_a(const CollisionSegment self, const LPoint3f a)\n"
  "set_point_a(const CollisionSegment self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSegment_set_point_a_378_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionSegment::get_point_a(void) const
 */
static PyObject *Dtool_CollisionSegment_get_point_a_379(PyObject *self, PyObject *) {
  CollisionSegment *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionSegment)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &CollisionSegment::get_point_a(void) const
  LPoint3 const *return_value = &(((*(const CollisionSegment*)local_this).get_point_a)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSegment_get_point_a_379_comment =
  "C++ Interface:\n"
  "get_point_a(CollisionSegment self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSegment_get_point_a_379_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CollisionSegment::set_point_b(LPoint3 const &b)
 * inline void CollisionSegment::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_CollisionSegment_set_point_b_380(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionSegment *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSegment, (void **)&local_this, "CollisionSegment.set_point_b")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "b")) {
        // 1-inline void CollisionSegment::set_point_b(LPoint3 const &b)
        LPoint3f arg_local;
        LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "CollisionSegment.set_point_b", "LPoint3f");
        }
        ((*local_this).set_point_b)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void CollisionSegment::set_point_b(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_point_b", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_point_b)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_point_b() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_point_b(const CollisionSegment self, const LPoint3f b)\n"
      "set_point_b(const CollisionSegment self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSegment_set_point_b_380_comment =
  "C++ Interface:\n"
  "set_point_b(const CollisionSegment self, const LPoint3f b)\n"
  "set_point_b(const CollisionSegment self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " *\n"
  " */\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSegment_set_point_b_380_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &CollisionSegment::get_point_b(void) const
 */
static PyObject *Dtool_CollisionSegment_get_point_b_381(PyObject *self, PyObject *) {
  CollisionSegment *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CollisionSegment)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &CollisionSegment::get_point_b(void) const
  LPoint3 const *return_value = &(((*(const CollisionSegment*)local_this).get_point_b)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSegment_get_point_b_381_comment =
  "C++ Interface:\n"
  "get_point_b(CollisionSegment self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CollisionSegment_get_point_b_381_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CollisionSegment::set_from_lens(LensNode *camera, LPoint2 const &point)
 * inline bool CollisionSegment::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py)
 */
static PyObject *Dtool_CollisionSegment_set_from_lens_382(PyObject *self, PyObject *args, PyObject *kwds) {
  CollisionSegment *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSegment, (void **)&local_this, "CollisionSegment.set_from_lens")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-bool CollisionSegment::set_from_lens(LensNode *camera, LPoint2 const &point)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"camera", "point", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_from_lens", (char **)keyword_list, &param1, &param2)) {
        LensNode *param1_this = (LensNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LensNode, 1, "CollisionSegment.set_from_lens", false, true);
        LPoint2f param2_local;
        LPoint2 const *param2_this = Dtool_Coerce_LPoint2f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "CollisionSegment.set_from_lens", "LPoint2f");
        }
        if (param1_this != nullptr) {
          bool return_value = ((*local_this).set_from_lens)(param1_this, *param2_this);
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
  case 3:
    {
      // 1-inline bool CollisionSegment::set_from_lens(LensNode *camera, PN_stdfloat px, PN_stdfloat py)
      PyObject *param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"camera", "px", "py", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:set_from_lens", (char **)keyword_list, &param1, &param2, &param3)) {
        LensNode *param1_this = (LensNode *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LensNode, 1, "CollisionSegment.set_from_lens", false, true);
        if (param1_this != nullptr) {
          bool return_value = ((*local_this).set_from_lens)(param1_this, (PN_stdfloat)param2, (PN_stdfloat)param3);
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_from_lens() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_lens(const CollisionSegment self, LensNode camera, const LPoint2f point)\n"
      "set_from_lens(const CollisionSegment self, LensNode camera, float px, float py)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CollisionSegment_set_from_lens_382_comment =
  "C++ Interface:\n"
  "set_from_lens(const CollisionSegment self, LensNode camera, const LPoint2f point)\n"
  "set_from_lens(const CollisionSegment self, LensNode camera, float px, float py)\n"
  "\n"
  "/**\n"
  " * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the\n"
  " * CollisionSegment so that it begins at the LensNode's near plane and extends\n"
  " * to the far plane, making it suitable for picking objects from the screen\n"
  " * given a camera and a mouse location.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Accepts a LensNode and a 2-d point in the range [-1,1].  Sets the\n"
  " * CollisionSegment so that it begins at the LensNode's near plane and extends\n"
  " * to the far plane, making it suitable for picking objects from the screen\n"
  " * given a camera and a mouse location.\n"
  " *\n"
  " * Returns true if the point was acceptable, false otherwise.\n"
  " */";
#else
static const char *Dtool_CollisionSegment_set_from_lens_382_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CollisionSegment::get_class_type(void)
 */
static PyObject *Dtool_CollisionSegment_get_class_type_385(PyObject *, PyObject *) {
  // 1-static TypeHandle CollisionSegment::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CollisionSegment::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CollisionSegment_get_class_type_385_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CollisionSegment_get_class_type_385_comment = nullptr;
#endif

static PyObject *Dtool_CollisionSegment_point_a_Getter(PyObject *self, void *) {
  const CollisionSegment *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSegment, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint3 const &CollisionSegment::get_point_a(void) const
  LPoint3 const *return_value = &(((*(const CollisionSegment*)local_this).get_point_a)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_CollisionSegment_point_a_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionSegment *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSegment, (void **)&local_this, "CollisionSegment.point_a")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete point_a attribute");
    return -1;
  }
  // 1-inline void CollisionSegment::set_point_a(LPoint3 const &a)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionSegment.set_point_a", "LPoint3f");
    return -1;
  }
  ((*local_this).set_point_a)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_point_a(const CollisionSegment self, const LPoint3f a)\n");
  }
  return -1;
}

static PyObject *Dtool_CollisionSegment_point_b_Getter(PyObject *self, void *) {
  const CollisionSegment *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSegment, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint3 const &CollisionSegment::get_point_b(void) const
  LPoint3 const *return_value = &(((*(const CollisionSegment*)local_this).get_point_b)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_CollisionSegment_point_b_Setter(PyObject *self, PyObject *arg, void *) {
  CollisionSegment *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CollisionSegment, (void **)&local_this, "CollisionSegment.point_b")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete point_b attribute");
    return -1;
  }
  // 1-inline void CollisionSegment::set_point_b(LPoint3 const &b)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "CollisionSegment.set_point_b", "LPoint3f");
    return -1;
  }
  ((*local_this).set_point_b)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_point_b(const CollisionSegment self, const LPoint3f b)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline CollisionSegment::CollisionSegment(void)
 * inline explicit CollisionSegment::CollisionSegment(LPoint3 const &a, LPoint3 const &db)
 * inline explicit CollisionSegment::CollisionSegment(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz)
 */
static int Dtool_Init_CollisionSegment(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline CollisionSegment::CollisionSegment(void)
      CollisionSegment *return_value = new CollisionSegment();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionSegment, true, false);
    }
    break;
  case 2:
    {
      // 1-inline explicit CollisionSegment::CollisionSegment(LPoint3 const &a, LPoint3 const &db)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"a", "db", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:CollisionSegment", (char **)keyword_list, &param0, &param1)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "CollisionSegment.CollisionSegment", "LPoint3f");
          return -1;
        }
        LPoint3f param1_local;
        LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "CollisionSegment.CollisionSegment", "LPoint3f");
          return -1;
        }
        CollisionSegment *return_value = new CollisionSegment(*param0_this, *param1_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionSegment, true, false);
      }
    }
    break;
  case 6:
    {
      // 1-inline explicit CollisionSegment::CollisionSegment(PN_stdfloat ax, PN_stdfloat ay, PN_stdfloat az, PN_stdfloat bx, PN_stdfloat by, PN_stdfloat bz)
      float param0;
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"ax", "ay", "az", "bx", "by", "bz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:CollisionSegment", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
        CollisionSegment *return_value = new CollisionSegment((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CollisionSegment, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CollisionSegment() takes 0, 2 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CollisionSegment()\n"
      "CollisionSegment(const LPoint3f a, const LPoint3f db)\n"
      "CollisionSegment(float ax, float ay, float az, float bx, float by, float bz)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CollisionSegment(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CollisionSegment) {
    printf("CollisionSegment ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CollisionSegment *local_this = (CollisionSegment *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CollisionSegment) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionSolid) {
    return (CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *)(CollisionSolid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CollisionSegment(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CollisionSegment) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CollisionSegment*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionSolid) {
    CollisionSolid* other_this = (CollisionSolid*)from_this;
    return (CollisionSegment*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (CollisionSegment*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CollisionSegment*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CollisionSegment*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CollisionSegment*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CollisionSegment*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for CollisionSolid (CollisionSolid)
 */
static PyMethodDef Dtool_Methods_CollisionSolid[] = {
  {"get_collision_origin", &Dtool_CollisionSolid_get_collision_origin_3, METH_NOARGS, (const char *)Dtool_CollisionSolid_get_collision_origin_3_comment},
  {"getCollisionOrigin", &Dtool_CollisionSolid_get_collision_origin_3, METH_NOARGS, (const char *)Dtool_CollisionSolid_get_collision_origin_3_comment},
  {"set_tangible", &Dtool_CollisionSolid_set_tangible_7, METH_O, (const char *)Dtool_CollisionSolid_set_tangible_7_comment},
  {"setTangible", &Dtool_CollisionSolid_set_tangible_7, METH_O, (const char *)Dtool_CollisionSolid_set_tangible_7_comment},
  {"is_tangible", &Dtool_CollisionSolid_is_tangible_8, METH_NOARGS, (const char *)Dtool_CollisionSolid_is_tangible_8_comment},
  {"isTangible", &Dtool_CollisionSolid_is_tangible_8, METH_NOARGS, (const char *)Dtool_CollisionSolid_is_tangible_8_comment},
  {"set_effective_normal", &Dtool_CollisionSolid_set_effective_normal_11, METH_O, (const char *)Dtool_CollisionSolid_set_effective_normal_11_comment},
  {"setEffectiveNormal", &Dtool_CollisionSolid_set_effective_normal_11, METH_O, (const char *)Dtool_CollisionSolid_set_effective_normal_11_comment},
  {"clear_effective_normal", &Dtool_CollisionSolid_clear_effective_normal_12, METH_NOARGS, (const char *)Dtool_CollisionSolid_clear_effective_normal_12_comment},
  {"clearEffectiveNormal", &Dtool_CollisionSolid_clear_effective_normal_12, METH_NOARGS, (const char *)Dtool_CollisionSolid_clear_effective_normal_12_comment},
  {"has_effective_normal", &Dtool_CollisionSolid_has_effective_normal_13, METH_NOARGS, (const char *)Dtool_CollisionSolid_has_effective_normal_13_comment},
  {"hasEffectiveNormal", &Dtool_CollisionSolid_has_effective_normal_13, METH_NOARGS, (const char *)Dtool_CollisionSolid_has_effective_normal_13_comment},
  {"get_effective_normal", &Dtool_CollisionSolid_get_effective_normal_14, METH_NOARGS, (const char *)Dtool_CollisionSolid_get_effective_normal_14_comment},
  {"getEffectiveNormal", &Dtool_CollisionSolid_get_effective_normal_14, METH_NOARGS, (const char *)Dtool_CollisionSolid_get_effective_normal_14_comment},
  {"set_respect_effective_normal", &Dtool_CollisionSolid_set_respect_effective_normal_15, METH_O, (const char *)Dtool_CollisionSolid_set_respect_effective_normal_15_comment},
  {"setRespectEffectiveNormal", &Dtool_CollisionSolid_set_respect_effective_normal_15, METH_O, (const char *)Dtool_CollisionSolid_set_respect_effective_normal_15_comment},
  {"get_respect_effective_normal", &Dtool_CollisionSolid_get_respect_effective_normal_16, METH_NOARGS, (const char *)Dtool_CollisionSolid_get_respect_effective_normal_16_comment},
  {"getRespectEffectiveNormal", &Dtool_CollisionSolid_get_respect_effective_normal_16, METH_NOARGS, (const char *)Dtool_CollisionSolid_get_respect_effective_normal_16_comment},
  {"get_bounds", &Dtool_CollisionSolid_get_bounds_18, METH_NOARGS, (const char *)Dtool_CollisionSolid_get_bounds_18_comment},
  {"getBounds", &Dtool_CollisionSolid_get_bounds_18, METH_NOARGS, (const char *)Dtool_CollisionSolid_get_bounds_18_comment},
  {"set_bounds", &Dtool_CollisionSolid_set_bounds_19, METH_O, (const char *)Dtool_CollisionSolid_set_bounds_19_comment},
  {"setBounds", &Dtool_CollisionSolid_set_bounds_19, METH_O, (const char *)Dtool_CollisionSolid_set_bounds_19_comment},
  {"output", &Dtool_CollisionSolid_output_22, METH_O, (const char *)Dtool_CollisionSolid_output_22_comment},
  {"write", (PyCFunction) &Dtool_CollisionSolid_write_23, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSolid_write_23_comment},
  {"get_class_type", &Dtool_CollisionSolid_get_class_type_24, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionSolid_get_class_type_24_comment},
  {"getClassType", &Dtool_CollisionSolid_get_class_type_24, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionSolid_get_class_type_24_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     CollisionSolid
//////////////////
static PyObject *Dtool_Repr_CollisionSolid(PyObject *self) {
  CollisionSolid *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     CollisionSolid
//////////////////
static PyObject *Dtool_Str_CollisionSolid(PyObject *self) {
  CollisionSolid *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionSolid, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_CollisionSolid[] = {
  {(char *)"collision_origin", &Dtool_CollisionSolid_collision_origin_Getter, nullptr, nullptr, nullptr},
  {(char *)"tangible", &Dtool_CollisionSolid_tangible_Getter, &Dtool_CollisionSolid_tangible_Setter, nullptr, nullptr},
  {(char *)"respect_effective_normal", &Dtool_CollisionSolid_respect_effective_normal_Getter, &Dtool_CollisionSolid_respect_effective_normal_Setter, nullptr, nullptr},
  {(char *)"bounds", &Dtool_CollisionSolid_bounds_Getter, &Dtool_CollisionSolid_bounds_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionSolid = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionSolid = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionSolid = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionSolid = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionSolid = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionSolid = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionSolid",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionSolid,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionSolid,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_CollisionSolid,
    &Dtool_NumberMethods_CollisionSolid,
    &Dtool_SequenceMethods_CollisionSolid,
    &Dtool_MappingMethods_CollisionSolid,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_CollisionSolid,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionSolid,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The abstract base class for all things that can collide with other things\n"
    " * in the world, and all the things they can collide with (except geometry).\n"
    " *\n"
    " * This class and its derivatives really work very similarly to the way\n"
    " * BoundingVolume and all of its derivatives work.  There's a different\n"
    " * subclass for each basic shape of solid, and double-dispatch function calls\n"
    " * handle the subset of the N*N intersection tests that we care about.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionSolid,
    nullptr, // tp_members
    Dtool_Properties_CollisionSolid,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionSolid,
    PyType_GenericAlloc,
    Dtool_new_CollisionSolid,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionSolid,
  Dtool_UpcastInterface_CollisionSolid,
  Dtool_DowncastInterface_CollisionSolid,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionSolid(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CopyOnWriteObject != nullptr);
    assert(Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_CollisionSolid._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_CopyOnWriteObject);
    Dtool_CollisionSolid._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionSolid._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionSolid) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionSolid)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionSolid);
  }
}

/**
 * Python method tables for CollisionBox (CollisionBox)
 */
static PyMethodDef Dtool_Methods_CollisionBox[] = {
  {"get_num_points", &Dtool_CollisionBox_get_num_points_27, METH_NOARGS, (const char *)Dtool_CollisionBox_get_num_points_27_comment},
  {"getNumPoints", &Dtool_CollisionBox_get_num_points_27, METH_NOARGS, (const char *)Dtool_CollisionBox_get_num_points_27_comment},
  {"get_point_aabb", &Dtool_CollisionBox_get_point_aabb_28, METH_O, (const char *)Dtool_CollisionBox_get_point_aabb_28_comment},
  {"getPointAabb", &Dtool_CollisionBox_get_point_aabb_28, METH_O, (const char *)Dtool_CollisionBox_get_point_aabb_28_comment},
  {"get_point", &Dtool_CollisionBox_get_point_29, METH_O, (const char *)Dtool_CollisionBox_get_point_29_comment},
  {"getPoint", &Dtool_CollisionBox_get_point_29, METH_O, (const char *)Dtool_CollisionBox_get_point_29_comment},
  {"get_num_planes", &Dtool_CollisionBox_get_num_planes_30, METH_NOARGS, (const char *)Dtool_CollisionBox_get_num_planes_30_comment},
  {"getNumPlanes", &Dtool_CollisionBox_get_num_planes_30, METH_NOARGS, (const char *)Dtool_CollisionBox_get_num_planes_30_comment},
  {"set_plane", &Dtool_CollisionBox_set_plane_31, METH_O, (const char *)Dtool_CollisionBox_set_plane_31_comment},
  {"setPlane", &Dtool_CollisionBox_set_plane_31, METH_O, (const char *)Dtool_CollisionBox_set_plane_31_comment},
  {"get_plane", &Dtool_CollisionBox_get_plane_32, METH_O, (const char *)Dtool_CollisionBox_get_plane_32_comment},
  {"getPlane", &Dtool_CollisionBox_get_plane_32, METH_O, (const char *)Dtool_CollisionBox_get_plane_32_comment},
  {"set_center", (PyCFunction) &Dtool_CollisionBox_set_center_33, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionBox_set_center_33_comment},
  {"setCenter", (PyCFunction) &Dtool_CollisionBox_set_center_33, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionBox_set_center_33_comment},
  {"get_center", &Dtool_CollisionBox_get_center_34, METH_NOARGS, (const char *)Dtool_CollisionBox_get_center_34_comment},
  {"getCenter", &Dtool_CollisionBox_get_center_34, METH_NOARGS, (const char *)Dtool_CollisionBox_get_center_34_comment},
  {"get_min", &Dtool_CollisionBox_get_min_35, METH_NOARGS, (const char *)Dtool_CollisionBox_get_min_35_comment},
  {"getMin", &Dtool_CollisionBox_get_min_35, METH_NOARGS, (const char *)Dtool_CollisionBox_get_min_35_comment},
  {"get_max", &Dtool_CollisionBox_get_max_36, METH_NOARGS, (const char *)Dtool_CollisionBox_get_max_36_comment},
  {"getMax", &Dtool_CollisionBox_get_max_36, METH_NOARGS, (const char *)Dtool_CollisionBox_get_max_36_comment},
  {"get_dimensions", &Dtool_CollisionBox_get_dimensions_37, METH_NOARGS, (const char *)Dtool_CollisionBox_get_dimensions_37_comment},
  {"getDimensions", &Dtool_CollisionBox_get_dimensions_37, METH_NOARGS, (const char *)Dtool_CollisionBox_get_dimensions_37_comment},
  {"get_class_type", &Dtool_CollisionBox_get_class_type_45, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionBox_get_class_type_45_comment},
  {"getClassType", &Dtool_CollisionBox_get_class_type_45, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionBox_get_class_type_45_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CollisionBox[] = {
  {(char *)"center", &Dtool_CollisionBox_center_Getter, nullptr, nullptr, nullptr},
  {(char *)"min", &Dtool_CollisionBox_min_Getter, nullptr, nullptr, nullptr},
  {(char *)"max", &Dtool_CollisionBox_max_Getter, nullptr, nullptr, nullptr},
  {(char *)"dimensions", &Dtool_CollisionBox_dimensions_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionBox = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionBox = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionBox = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionBox = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionBox = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionBox = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionBox",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionBox,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionBox,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionBox,
    &Dtool_SequenceMethods_CollisionBox,
    &Dtool_MappingMethods_CollisionBox,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionBox,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A cuboid collision volume or object.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionBox,
    nullptr, // tp_members
    Dtool_Properties_CollisionBox,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionBox,
    PyType_GenericAlloc,
    Dtool_new_CollisionBox,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionBox,
  Dtool_UpcastInterface_CollisionBox,
  Dtool_DowncastInterface_CollisionBox,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionBox(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSolid(nullptr);
    Dtool_CollisionBox._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSolid);
    Dtool_CollisionBox._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionBox._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionBox) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionBox)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionBox);
  }
}

/**
 * Python method tables for CollisionCapsule (CollisionCapsule)
 */
static PyMethodDef Dtool_Methods_CollisionCapsule[] = {
  {"set_point_a", (PyCFunction) &Dtool_CollisionCapsule_set_point_a_49, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionCapsule_set_point_a_49_comment},
  {"setPointA", (PyCFunction) &Dtool_CollisionCapsule_set_point_a_49, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionCapsule_set_point_a_49_comment},
  {"get_point_a", &Dtool_CollisionCapsule_get_point_a_50, METH_NOARGS, (const char *)Dtool_CollisionCapsule_get_point_a_50_comment},
  {"getPointA", &Dtool_CollisionCapsule_get_point_a_50, METH_NOARGS, (const char *)Dtool_CollisionCapsule_get_point_a_50_comment},
  {"set_point_b", (PyCFunction) &Dtool_CollisionCapsule_set_point_b_51, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionCapsule_set_point_b_51_comment},
  {"setPointB", (PyCFunction) &Dtool_CollisionCapsule_set_point_b_51, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionCapsule_set_point_b_51_comment},
  {"get_point_b", &Dtool_CollisionCapsule_get_point_b_52, METH_NOARGS, (const char *)Dtool_CollisionCapsule_get_point_b_52_comment},
  {"getPointB", &Dtool_CollisionCapsule_get_point_b_52, METH_NOARGS, (const char *)Dtool_CollisionCapsule_get_point_b_52_comment},
  {"set_radius", &Dtool_CollisionCapsule_set_radius_53, METH_O, (const char *)Dtool_CollisionCapsule_set_radius_53_comment},
  {"setRadius", &Dtool_CollisionCapsule_set_radius_53, METH_O, (const char *)Dtool_CollisionCapsule_set_radius_53_comment},
  {"get_radius", &Dtool_CollisionCapsule_get_radius_54, METH_NOARGS, (const char *)Dtool_CollisionCapsule_get_radius_54_comment},
  {"getRadius", &Dtool_CollisionCapsule_get_radius_54, METH_NOARGS, (const char *)Dtool_CollisionCapsule_get_radius_54_comment},
  {"get_class_type", &Dtool_CollisionCapsule_get_class_type_60, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionCapsule_get_class_type_60_comment},
  {"getClassType", &Dtool_CollisionCapsule_get_class_type_60, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionCapsule_get_class_type_60_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CollisionCapsule[] = {
  {(char *)"point_a", &Dtool_CollisionCapsule_point_a_Getter, &Dtool_CollisionCapsule_point_a_Setter, nullptr, nullptr},
  {(char *)"point_b", &Dtool_CollisionCapsule_point_b_Getter, &Dtool_CollisionCapsule_point_b_Setter, nullptr, nullptr},
  {(char *)"radius", &Dtool_CollisionCapsule_radius_Getter, &Dtool_CollisionCapsule_radius_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionCapsule = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionCapsule = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionCapsule = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionCapsule = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionCapsule = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionCapsule = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionCapsule",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionCapsule,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionCapsule,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionCapsule,
    &Dtool_SequenceMethods_CollisionCapsule,
    &Dtool_MappingMethods_CollisionCapsule,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionCapsule,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This implements a solid consisting of a cylinder with hemispherical endcaps,\n"
    " * also known as a capsule or a spherocylinder.\n"
    " *\n"
    " * This shape was previously erroneously called CollisionTube.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionCapsule,
    nullptr, // tp_members
    Dtool_Properties_CollisionCapsule,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionCapsule,
    PyType_GenericAlloc,
    Dtool_new_CollisionCapsule,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionCapsule,
  Dtool_UpcastInterface_CollisionCapsule,
  Dtool_DowncastInterface_CollisionCapsule,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionCapsule(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSolid(nullptr);
    Dtool_CollisionCapsule._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSolid);
    Dtool_CollisionCapsule._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionCapsule._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionCapsule) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionCapsule)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionCapsule);
  }
}

/**
 * Python method tables for CollisionHandler (CollisionHandler)
 */
static PyMethodDef Dtool_Methods_CollisionHandler[] = {
  {"get_class_type", &Dtool_CollisionHandler_get_class_type_64, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandler_get_class_type_64_comment},
  {"getClassType", &Dtool_CollisionHandler_get_class_type_64, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandler_get_class_type_64_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandler = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandler = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandler = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandler = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionHandler = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionHandler = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionHandler",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandler,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionHandler,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionHandler,
    &Dtool_SequenceMethods_CollisionHandler,
    &Dtool_MappingMethods_CollisionHandler,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionHandler,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The abstract interface to a number of classes that decide what to do when a\n"
    " * collision is detected.  One of these must be assigned to the\n"
    " * CollisionTraverser that is processing collisions in order to specify how to\n"
    " * dispatch detected collisions.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionHandler,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionHandler,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandler,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandler,
  Dtool_UpcastInterface_CollisionHandler,
  Dtool_DowncastInterface_CollisionHandler,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionHandler(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_CollisionHandler._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_CollisionHandler._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandler._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandler) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandler)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandler);
  }
}

/**
 * Python method tables for CollisionNode (CollisionNode)
 */
static PyMethodDef Dtool_Methods_CollisionNode[] = {
  {"set_collide_mask", &Dtool_CollisionNode_set_collide_mask_70, METH_O, (const char *)Dtool_CollisionNode_set_collide_mask_70_comment},
  {"setCollideMask", &Dtool_CollisionNode_set_collide_mask_70, METH_O, (const char *)Dtool_CollisionNode_set_collide_mask_70_comment},
  {"set_from_collide_mask", &Dtool_CollisionNode_set_from_collide_mask_71, METH_O, (const char *)Dtool_CollisionNode_set_from_collide_mask_71_comment},
  {"setFromCollideMask", &Dtool_CollisionNode_set_from_collide_mask_71, METH_O, (const char *)Dtool_CollisionNode_set_from_collide_mask_71_comment},
  {"set_into_collide_mask", &Dtool_CollisionNode_set_into_collide_mask_72, METH_O, (const char *)Dtool_CollisionNode_set_into_collide_mask_72_comment},
  {"setIntoCollideMask", &Dtool_CollisionNode_set_into_collide_mask_72, METH_O, (const char *)Dtool_CollisionNode_set_into_collide_mask_72_comment},
  {"get_from_collide_mask", &Dtool_CollisionNode_get_from_collide_mask_73, METH_NOARGS, (const char *)Dtool_CollisionNode_get_from_collide_mask_73_comment},
  {"getFromCollideMask", &Dtool_CollisionNode_get_from_collide_mask_73, METH_NOARGS, (const char *)Dtool_CollisionNode_get_from_collide_mask_73_comment},
  {"get_into_collide_mask", &Dtool_CollisionNode_get_into_collide_mask_74, METH_NOARGS, (const char *)Dtool_CollisionNode_get_into_collide_mask_74_comment},
  {"getIntoCollideMask", &Dtool_CollisionNode_get_into_collide_mask_74, METH_NOARGS, (const char *)Dtool_CollisionNode_get_into_collide_mask_74_comment},
  {"clear_solids", &Dtool_CollisionNode_clear_solids_80, METH_NOARGS, (const char *)Dtool_CollisionNode_clear_solids_80_comment},
  {"clearSolids", &Dtool_CollisionNode_clear_solids_80, METH_NOARGS, (const char *)Dtool_CollisionNode_clear_solids_80_comment},
  {"get_num_solids", &Dtool_CollisionNode_get_num_solids_81, METH_NOARGS, (const char *)Dtool_CollisionNode_get_num_solids_81_comment},
  {"getNumSolids", &Dtool_CollisionNode_get_num_solids_81, METH_NOARGS, (const char *)Dtool_CollisionNode_get_num_solids_81_comment},
  {"get_solid", &Dtool_CollisionNode_get_solid_82, METH_O, (const char *)Dtool_CollisionNode_get_solid_82_comment},
  {"getSolid", &Dtool_CollisionNode_get_solid_82, METH_O, (const char *)Dtool_CollisionNode_get_solid_82_comment},
  {"modify_solid", &Dtool_CollisionNode_modify_solid_84, METH_O, (const char *)Dtool_CollisionNode_modify_solid_84_comment},
  {"modifySolid", &Dtool_CollisionNode_modify_solid_84, METH_O, (const char *)Dtool_CollisionNode_modify_solid_84_comment},
  {"set_solid", (PyCFunction) &Dtool_CollisionNode_set_solid_85, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionNode_set_solid_85_comment},
  {"setSolid", (PyCFunction) &Dtool_CollisionNode_set_solid_85, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionNode_set_solid_85_comment},
  {"insert_solid", (PyCFunction) &Dtool_CollisionNode_insert_solid_86, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionNode_insert_solid_86_comment},
  {"insertSolid", (PyCFunction) &Dtool_CollisionNode_insert_solid_86, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionNode_insert_solid_86_comment},
  {"remove_solid", &Dtool_CollisionNode_remove_solid_87, METH_O, (const char *)Dtool_CollisionNode_remove_solid_87_comment},
  {"removeSolid", &Dtool_CollisionNode_remove_solid_87, METH_O, (const char *)Dtool_CollisionNode_remove_solid_87_comment},
  {"add_solid", &Dtool_CollisionNode_add_solid_88, METH_O, (const char *)Dtool_CollisionNode_add_solid_88_comment},
  {"addSolid", &Dtool_CollisionNode_add_solid_88, METH_O, (const char *)Dtool_CollisionNode_add_solid_88_comment},
  {"get_collider_sort", &Dtool_CollisionNode_get_collider_sort_91, METH_NOARGS, (const char *)Dtool_CollisionNode_get_collider_sort_91_comment},
  {"getColliderSort", &Dtool_CollisionNode_get_collider_sort_91, METH_NOARGS, (const char *)Dtool_CollisionNode_get_collider_sort_91_comment},
  {"set_collider_sort", &Dtool_CollisionNode_set_collider_sort_92, METH_O, (const char *)Dtool_CollisionNode_set_collider_sort_92_comment},
  {"setColliderSort", &Dtool_CollisionNode_set_collider_sort_92, METH_O, (const char *)Dtool_CollisionNode_set_collider_sort_92_comment},
  {"get_default_collide_mask", &Dtool_CollisionNode_get_default_collide_mask_95, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionNode_get_default_collide_mask_95_comment},
  {"getDefaultCollideMask", &Dtool_CollisionNode_get_default_collide_mask_95, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionNode_get_default_collide_mask_95_comment},
  {"get_class_type", &Dtool_CollisionNode_get_class_type_97, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionNode_get_class_type_97_comment},
  {"getClassType", &Dtool_CollisionNode_get_class_type_97, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionNode_get_class_type_97_comment},
  {"get_solids", (PyCFunction) &MakeSeq_CollisionNode_get_solids, METH_NOARGS, nullptr},
  { "getSolids", (PyCFunction) &MakeSeq_CollisionNode_get_solids, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CollisionNode[] = {
  {(char *)"from_collide_mask", &Dtool_CollisionNode_from_collide_mask_Getter, &Dtool_CollisionNode_from_collide_mask_Setter, nullptr, nullptr},
  {(char *)"into_collide_mask", &Dtool_CollisionNode_into_collide_mask_Getter, &Dtool_CollisionNode_into_collide_mask_Setter, nullptr, nullptr},
  {(char *)"solids", &Dtool_CollisionNode_solids_Getter, nullptr, nullptr, nullptr},
  {(char *)"collider_sort", &Dtool_CollisionNode_collider_sort_Getter, &Dtool_CollisionNode_collider_sort_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionNode,
    &Dtool_SequenceMethods_CollisionNode,
    &Dtool_MappingMethods_CollisionNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A node in the scene graph that can hold any number of CollisionSolids.\n"
    " * This may either represent a bit of static geometry in the scene that things\n"
    " * will collide with, or an animated object twirling around in the world and\n"
    " * running into things.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionNode,
    nullptr, // tp_members
    Dtool_Properties_CollisionNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionNode,
    PyType_GenericAlloc,
    Dtool_new_CollisionNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionNode,
  Dtool_UpcastInterface_CollisionNode,
  Dtool_DowncastInterface_CollisionNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_CollisionNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    Dtool_CollisionNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_default_collide_mask = {(char *)"default_collide_mask", &Dtool_CollisionNode_default_collide_mask_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "default_collide_mask", Dtool_NewStaticProperty(&Dtool_CollisionNode._PyType, &def_default_collide_mask));
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionNode);
  }
}

/**
 * Python method tables for CollisionTraverser (CollisionTraverser)
 */
static PyMethodDef Dtool_Methods_CollisionTraverser[] = {
  {"set_respect_prev_transform", &Dtool_CollisionTraverser_set_respect_prev_transform_102, METH_O, (const char *)Dtool_CollisionTraverser_set_respect_prev_transform_102_comment},
  {"setRespectPrevTransform", &Dtool_CollisionTraverser_set_respect_prev_transform_102, METH_O, (const char *)Dtool_CollisionTraverser_set_respect_prev_transform_102_comment},
  {"get_respect_prev_transform", &Dtool_CollisionTraverser_get_respect_prev_transform_103, METH_NOARGS, (const char *)Dtool_CollisionTraverser_get_respect_prev_transform_103_comment},
  {"getRespectPrevTransform", &Dtool_CollisionTraverser_get_respect_prev_transform_103, METH_NOARGS, (const char *)Dtool_CollisionTraverser_get_respect_prev_transform_103_comment},
  {"add_collider", (PyCFunction) &Dtool_CollisionTraverser_add_collider_105, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionTraverser_add_collider_105_comment},
  {"addCollider", (PyCFunction) &Dtool_CollisionTraverser_add_collider_105, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionTraverser_add_collider_105_comment},
  {"remove_collider", &Dtool_CollisionTraverser_remove_collider_106, METH_O, (const char *)Dtool_CollisionTraverser_remove_collider_106_comment},
  {"removeCollider", &Dtool_CollisionTraverser_remove_collider_106, METH_O, (const char *)Dtool_CollisionTraverser_remove_collider_106_comment},
  {"has_collider", &Dtool_CollisionTraverser_has_collider_107, METH_O, (const char *)Dtool_CollisionTraverser_has_collider_107_comment},
  {"hasCollider", &Dtool_CollisionTraverser_has_collider_107, METH_O, (const char *)Dtool_CollisionTraverser_has_collider_107_comment},
  {"get_num_colliders", &Dtool_CollisionTraverser_get_num_colliders_108, METH_NOARGS, (const char *)Dtool_CollisionTraverser_get_num_colliders_108_comment},
  {"getNumColliders", &Dtool_CollisionTraverser_get_num_colliders_108, METH_NOARGS, (const char *)Dtool_CollisionTraverser_get_num_colliders_108_comment},
  {"get_collider", &Dtool_CollisionTraverser_get_collider_109, METH_O, (const char *)Dtool_CollisionTraverser_get_collider_109_comment},
  {"getCollider", &Dtool_CollisionTraverser_get_collider_109, METH_O, (const char *)Dtool_CollisionTraverser_get_collider_109_comment},
  {"get_handler", &Dtool_CollisionTraverser_get_handler_111, METH_O, (const char *)Dtool_CollisionTraverser_get_handler_111_comment},
  {"getHandler", &Dtool_CollisionTraverser_get_handler_111, METH_O, (const char *)Dtool_CollisionTraverser_get_handler_111_comment},
  {"clear_colliders", &Dtool_CollisionTraverser_clear_colliders_112, METH_NOARGS, (const char *)Dtool_CollisionTraverser_clear_colliders_112_comment},
  {"clearColliders", &Dtool_CollisionTraverser_clear_colliders_112, METH_NOARGS, (const char *)Dtool_CollisionTraverser_clear_colliders_112_comment},
  {"traverse", &Dtool_CollisionTraverser_traverse_115, METH_O, (const char *)Dtool_CollisionTraverser_traverse_115_comment},
  {"set_recorder", &Dtool_CollisionTraverser_set_recorder_116, METH_O, (const char *)Dtool_CollisionTraverser_set_recorder_116_comment},
  {"setRecorder", &Dtool_CollisionTraverser_set_recorder_116, METH_O, (const char *)Dtool_CollisionTraverser_set_recorder_116_comment},
  {"has_recorder", &Dtool_CollisionTraverser_has_recorder_117, METH_NOARGS, (const char *)Dtool_CollisionTraverser_has_recorder_117_comment},
  {"hasRecorder", &Dtool_CollisionTraverser_has_recorder_117, METH_NOARGS, (const char *)Dtool_CollisionTraverser_has_recorder_117_comment},
  {"get_recorder", &Dtool_CollisionTraverser_get_recorder_118, METH_NOARGS, (const char *)Dtool_CollisionTraverser_get_recorder_118_comment},
  {"getRecorder", &Dtool_CollisionTraverser_get_recorder_118, METH_NOARGS, (const char *)Dtool_CollisionTraverser_get_recorder_118_comment},
  {"clear_recorder", &Dtool_CollisionTraverser_clear_recorder_119, METH_NOARGS, (const char *)Dtool_CollisionTraverser_clear_recorder_119_comment},
  {"clearRecorder", &Dtool_CollisionTraverser_clear_recorder_119, METH_NOARGS, (const char *)Dtool_CollisionTraverser_clear_recorder_119_comment},
  {"show_collisions", &Dtool_CollisionTraverser_show_collisions_126, METH_O, (const char *)Dtool_CollisionTraverser_show_collisions_126_comment},
  {"showCollisions", &Dtool_CollisionTraverser_show_collisions_126, METH_O, (const char *)Dtool_CollisionTraverser_show_collisions_126_comment},
  {"hide_collisions", &Dtool_CollisionTraverser_hide_collisions_127, METH_NOARGS, (const char *)Dtool_CollisionTraverser_hide_collisions_127_comment},
  {"hideCollisions", &Dtool_CollisionTraverser_hide_collisions_127, METH_NOARGS, (const char *)Dtool_CollisionTraverser_hide_collisions_127_comment},
  {"output", &Dtool_CollisionTraverser_output_128, METH_O, (const char *)Dtool_CollisionTraverser_output_128_comment},
  {"write", (PyCFunction) &Dtool_CollisionTraverser_write_129, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionTraverser_write_129_comment},
  {"get_class_type", &Dtool_CollisionTraverser_get_class_type_130, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionTraverser_get_class_type_130_comment},
  {"getClassType", &Dtool_CollisionTraverser_get_class_type_130, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionTraverser_get_class_type_130_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_colliders", (PyCFunction) &MakeSeq_CollisionTraverser_get_colliders, METH_NOARGS, nullptr},
  { "getColliders", (PyCFunction) &MakeSeq_CollisionTraverser_get_colliders, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     CollisionTraverser
//////////////////
static PyObject *Dtool_Repr_CollisionTraverser(PyObject *self) {
  CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     CollisionTraverser
//////////////////
static PyObject *Dtool_Str_CollisionTraverser(PyObject *self) {
  CollisionTraverser *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionTraverser, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_CollisionTraverser[] = {
  {(char *)"respect_prev_transform", &Dtool_CollisionTraverser_respect_prev_transform_Getter, &Dtool_CollisionTraverser_respect_prev_transform_Setter, nullptr, nullptr},
  {(char *)"colliders", &Dtool_CollisionTraverser_colliders_Getter, nullptr, nullptr, nullptr},
  {(char *)"recorder", &Dtool_CollisionTraverser_recorder_Getter, &Dtool_CollisionTraverser_recorder_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionTraverser = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionTraverser = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionTraverser = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionTraverser = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionTraverser = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionTraverser = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionTraverser",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionTraverser,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionTraverser,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_CollisionTraverser,
    &Dtool_NumberMethods_CollisionTraverser,
    &Dtool_SequenceMethods_CollisionTraverser,
    &Dtool_MappingMethods_CollisionTraverser,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_CollisionTraverser,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionTraverser,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class manages the traversal through the scene graph to detect\n"
    " * collisions.  It holds ownership of a number of collider objects, each of\n"
    " * which is a CollisionNode and an associated CollisionHandler.\n"
    " *\n"
    " * When traverse() is called, it begins at the indicated root and detects all\n"
    " * collisions with any of its collider objects against nodes at or below the\n"
    " * indicated root, calling the appropriate CollisionHandler for each detected\n"
    " * collision.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionTraverser,
    nullptr, // tp_members
    Dtool_Properties_CollisionTraverser,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionTraverser,
    PyType_GenericAlloc,
    Dtool_new_CollisionTraverser,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionTraverser,
  Dtool_UpcastInterface_CollisionTraverser,
  Dtool_DowncastInterface_CollisionTraverser,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionTraverser(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_CollisionTraverser._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_CollisionTraverser._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionTraverser._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionTraverser) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionTraverser)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionTraverser);
  }
}

/**
 * Python method tables for CollisionRecorder (CollisionRecorder)
 */
static PyMethodDef Dtool_Methods_CollisionRecorder[] = {
  {"output", &Dtool_CollisionRecorder_output_124, METH_O, (const char *)Dtool_CollisionRecorder_output_124_comment},
  {"get_class_type", &Dtool_CollisionRecorder_get_class_type_125, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionRecorder_get_class_type_125_comment},
  {"getClassType", &Dtool_CollisionRecorder_get_class_type_125, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionRecorder_get_class_type_125_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     CollisionRecorder
//////////////////
static PyObject *Dtool_Repr_CollisionRecorder(PyObject *self) {
  CollisionRecorder *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionRecorder, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_CollisionRecorder = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionRecorder = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionRecorder = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionRecorder = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionRecorder = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionRecorder = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionRecorder",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionRecorder,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionRecorder,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_CollisionRecorder,
    &Dtool_NumberMethods_CollisionRecorder,
    &Dtool_SequenceMethods_CollisionRecorder,
    &Dtool_MappingMethods_CollisionRecorder,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_CollisionRecorder,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionRecorder,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used to help debug the work the collisions system is doing.\n"
    " * It is a virtual base class that just provides an interface for recording\n"
    " * collisions tested and detected each frame.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionRecorder,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionRecorder,
    PyType_GenericAlloc,
    Dtool_new_CollisionRecorder,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionRecorder,
  Dtool_UpcastInterface_CollisionRecorder,
  Dtool_DowncastInterface_CollisionRecorder,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionRecorder(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != nullptr);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_CollisionRecorder._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    Dtool_CollisionRecorder._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionRecorder._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionRecorder) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionRecorder)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionRecorder);
  }
}

/**
 * Python method tables for CollisionEntry (CollisionEntry)
 */
static PyMethodDef Dtool_Methods_CollisionEntry[] = {
  {"get_from", &Dtool_CollisionEntry_get_from_133, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_from_133_comment},
  {"getFrom", &Dtool_CollisionEntry_get_from_133, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_from_133_comment},
  {"has_into", &Dtool_CollisionEntry_has_into_134, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_into_134_comment},
  {"hasInto", &Dtool_CollisionEntry_has_into_134, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_into_134_comment},
  {"get_into", &Dtool_CollisionEntry_get_into_135, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_into_135_comment},
  {"getInto", &Dtool_CollisionEntry_get_into_135, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_into_135_comment},
  {"get_from_node", &Dtool_CollisionEntry_get_from_node_136, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_from_node_136_comment},
  {"getFromNode", &Dtool_CollisionEntry_get_from_node_136, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_from_node_136_comment},
  {"get_into_node", &Dtool_CollisionEntry_get_into_node_137, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_into_node_137_comment},
  {"getIntoNode", &Dtool_CollisionEntry_get_into_node_137, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_into_node_137_comment},
  {"get_from_node_path", &Dtool_CollisionEntry_get_from_node_path_138, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_from_node_path_138_comment},
  {"getFromNodePath", &Dtool_CollisionEntry_get_from_node_path_138, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_from_node_path_138_comment},
  {"get_into_node_path", &Dtool_CollisionEntry_get_into_node_path_139, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_into_node_path_139_comment},
  {"getIntoNodePath", &Dtool_CollisionEntry_get_into_node_path_139, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_into_node_path_139_comment},
  {"set_t", &Dtool_CollisionEntry_set_t_140, METH_O, (const char *)Dtool_CollisionEntry_set_t_140_comment},
  {"setT", &Dtool_CollisionEntry_set_t_140, METH_O, (const char *)Dtool_CollisionEntry_set_t_140_comment},
  {"get_t", &Dtool_CollisionEntry_get_t_141, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_t_141_comment},
  {"getT", &Dtool_CollisionEntry_get_t_141, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_t_141_comment},
  {"collided", &Dtool_CollisionEntry_collided_142, METH_NOARGS, (const char *)Dtool_CollisionEntry_collided_142_comment},
  {"reset_collided", &Dtool_CollisionEntry_reset_collided_143, METH_NOARGS, (const char *)Dtool_CollisionEntry_reset_collided_143_comment},
  {"resetCollided", &Dtool_CollisionEntry_reset_collided_143, METH_NOARGS, (const char *)Dtool_CollisionEntry_reset_collided_143_comment},
  {"get_respect_prev_transform", &Dtool_CollisionEntry_get_respect_prev_transform_144, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_respect_prev_transform_144_comment},
  {"getRespectPrevTransform", &Dtool_CollisionEntry_get_respect_prev_transform_144, METH_NOARGS, (const char *)Dtool_CollisionEntry_get_respect_prev_transform_144_comment},
  {"set_surface_point", &Dtool_CollisionEntry_set_surface_point_145, METH_O, (const char *)Dtool_CollisionEntry_set_surface_point_145_comment},
  {"setSurfacePoint", &Dtool_CollisionEntry_set_surface_point_145, METH_O, (const char *)Dtool_CollisionEntry_set_surface_point_145_comment},
  {"set_surface_normal", &Dtool_CollisionEntry_set_surface_normal_146, METH_O, (const char *)Dtool_CollisionEntry_set_surface_normal_146_comment},
  {"setSurfaceNormal", &Dtool_CollisionEntry_set_surface_normal_146, METH_O, (const char *)Dtool_CollisionEntry_set_surface_normal_146_comment},
  {"set_interior_point", &Dtool_CollisionEntry_set_interior_point_147, METH_O, (const char *)Dtool_CollisionEntry_set_interior_point_147_comment},
  {"setInteriorPoint", &Dtool_CollisionEntry_set_interior_point_147, METH_O, (const char *)Dtool_CollisionEntry_set_interior_point_147_comment},
  {"has_surface_point", &Dtool_CollisionEntry_has_surface_point_148, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_surface_point_148_comment},
  {"hasSurfacePoint", &Dtool_CollisionEntry_has_surface_point_148, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_surface_point_148_comment},
  {"has_surface_normal", &Dtool_CollisionEntry_has_surface_normal_149, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_surface_normal_149_comment},
  {"hasSurfaceNormal", &Dtool_CollisionEntry_has_surface_normal_149, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_surface_normal_149_comment},
  {"has_interior_point", &Dtool_CollisionEntry_has_interior_point_150, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_interior_point_150_comment},
  {"hasInteriorPoint", &Dtool_CollisionEntry_has_interior_point_150, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_interior_point_150_comment},
  {"set_contact_pos", &Dtool_CollisionEntry_set_contact_pos_151, METH_O, (const char *)Dtool_CollisionEntry_set_contact_pos_151_comment},
  {"setContactPos", &Dtool_CollisionEntry_set_contact_pos_151, METH_O, (const char *)Dtool_CollisionEntry_set_contact_pos_151_comment},
  {"set_contact_normal", &Dtool_CollisionEntry_set_contact_normal_152, METH_O, (const char *)Dtool_CollisionEntry_set_contact_normal_152_comment},
  {"setContactNormal", &Dtool_CollisionEntry_set_contact_normal_152, METH_O, (const char *)Dtool_CollisionEntry_set_contact_normal_152_comment},
  {"has_contact_pos", &Dtool_CollisionEntry_has_contact_pos_153, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_contact_pos_153_comment},
  {"hasContactPos", &Dtool_CollisionEntry_has_contact_pos_153, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_contact_pos_153_comment},
  {"has_contact_normal", &Dtool_CollisionEntry_has_contact_normal_154, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_contact_normal_154_comment},
  {"hasContactNormal", &Dtool_CollisionEntry_has_contact_normal_154, METH_NOARGS, (const char *)Dtool_CollisionEntry_has_contact_normal_154_comment},
  {"get_surface_point", &Dtool_CollisionEntry_get_surface_point_155, METH_O, (const char *)Dtool_CollisionEntry_get_surface_point_155_comment},
  {"getSurfacePoint", &Dtool_CollisionEntry_get_surface_point_155, METH_O, (const char *)Dtool_CollisionEntry_get_surface_point_155_comment},
  {"get_surface_normal", &Dtool_CollisionEntry_get_surface_normal_156, METH_O, (const char *)Dtool_CollisionEntry_get_surface_normal_156_comment},
  {"getSurfaceNormal", &Dtool_CollisionEntry_get_surface_normal_156, METH_O, (const char *)Dtool_CollisionEntry_get_surface_normal_156_comment},
  {"get_interior_point", &Dtool_CollisionEntry_get_interior_point_157, METH_O, (const char *)Dtool_CollisionEntry_get_interior_point_157_comment},
  {"getInteriorPoint", &Dtool_CollisionEntry_get_interior_point_157, METH_O, (const char *)Dtool_CollisionEntry_get_interior_point_157_comment},
  {"get_all", (PyCFunction) &Dtool_CollisionEntry_get_all_158, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionEntry_get_all_158_comment},
  {"getAll", (PyCFunction) &Dtool_CollisionEntry_get_all_158, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionEntry_get_all_158_comment},
  {"get_contact_pos", &Dtool_CollisionEntry_get_contact_pos_159, METH_O, (const char *)Dtool_CollisionEntry_get_contact_pos_159_comment},
  {"getContactPos", &Dtool_CollisionEntry_get_contact_pos_159, METH_O, (const char *)Dtool_CollisionEntry_get_contact_pos_159_comment},
  {"get_contact_normal", &Dtool_CollisionEntry_get_contact_normal_160, METH_O, (const char *)Dtool_CollisionEntry_get_contact_normal_160_comment},
  {"getContactNormal", &Dtool_CollisionEntry_get_contact_normal_160, METH_O, (const char *)Dtool_CollisionEntry_get_contact_normal_160_comment},
  {"get_all_contact_info", (PyCFunction) &Dtool_CollisionEntry_get_all_contact_info_161, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionEntry_get_all_contact_info_161_comment},
  {"getAllContactInfo", (PyCFunction) &Dtool_CollisionEntry_get_all_contact_info_161, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionEntry_get_all_contact_info_161_comment},
  {"output", &Dtool_CollisionEntry_output_162, METH_O, (const char *)Dtool_CollisionEntry_output_162_comment},
  {"write", (PyCFunction) &Dtool_CollisionEntry_write_163, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionEntry_write_163_comment},
  {"get_class_type", &Dtool_CollisionEntry_get_class_type_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionEntry_get_class_type_176_comment},
  {"getClassType", &Dtool_CollisionEntry_get_class_type_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionEntry_get_class_type_176_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     CollisionEntry
//////////////////
static PyObject *Dtool_Repr_CollisionEntry(PyObject *self) {
  CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     CollisionEntry
//////////////////
static PyObject *Dtool_Str_CollisionEntry(PyObject *self) {
  CollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionEntry, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_CollisionEntry[] = {
  {(char *)"from_solid", &Dtool_CollisionEntry_from_solid_Getter, nullptr, nullptr, nullptr},
  {(char *)"into_solid", &Dtool_CollisionEntry_into_solid_Getter, nullptr, nullptr, nullptr},
  {(char *)"from_node", &Dtool_CollisionEntry_from_node_Getter, nullptr, nullptr, nullptr},
  {(char *)"into_node", &Dtool_CollisionEntry_into_node_Getter, nullptr, nullptr, nullptr},
  {(char *)"from_node_path", &Dtool_CollisionEntry_from_node_path_Getter, nullptr, nullptr, nullptr},
  {(char *)"into_node_path", &Dtool_CollisionEntry_into_node_path_Getter, nullptr, nullptr, nullptr},
  {(char *)"t", &Dtool_CollisionEntry_t_Getter, &Dtool_CollisionEntry_t_Setter, nullptr, nullptr},
  {(char *)"respect_prev_transform", &Dtool_CollisionEntry_respect_prev_transform_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionEntry = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionEntry = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionEntry = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionEntry = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionEntry = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionEntry = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionEntry",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionEntry,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionEntry,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_CollisionEntry,
    &Dtool_NumberMethods_CollisionEntry,
    &Dtool_SequenceMethods_CollisionEntry,
    &Dtool_MappingMethods_CollisionEntry,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_CollisionEntry,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionEntry,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a single collision event.  One of these is created for each\n"
    " * collision detected by a CollisionTraverser, to be dealt with by the\n"
    " * CollisionHandler.\n"
    " *\n"
    " * A CollisionEntry provides slots for a number of data values (such as\n"
    " * intersection point and normal) that might or might not be known for each\n"
    " * collision.  It is up to the handler to determine what information is known\n"
    " * and to do the right thing with it.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionEntry,
    nullptr, // tp_members
    Dtool_Properties_CollisionEntry,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionEntry,
    PyType_GenericAlloc,
    Dtool_new_CollisionEntry,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionEntry,
  Dtool_UpcastInterface_CollisionEntry,
  Dtool_DowncastInterface_CollisionEntry,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionEntry(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_CollisionEntry._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount);
    Dtool_CollisionEntry._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionEntry._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionEntry) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionEntry)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionEntry);
  }
}

/**
 * Python method tables for CollisionPlane (CollisionPlane)
 */
static PyMethodDef Dtool_Methods_CollisionPlane[] = {
  {"get_normal", &Dtool_CollisionPlane_get_normal_180, METH_NOARGS, (const char *)Dtool_CollisionPlane_get_normal_180_comment},
  {"getNormal", &Dtool_CollisionPlane_get_normal_180, METH_NOARGS, (const char *)Dtool_CollisionPlane_get_normal_180_comment},
  {"dist_to_plane", &Dtool_CollisionPlane_dist_to_plane_181, METH_O, (const char *)Dtool_CollisionPlane_dist_to_plane_181_comment},
  {"distToPlane", &Dtool_CollisionPlane_dist_to_plane_181, METH_O, (const char *)Dtool_CollisionPlane_dist_to_plane_181_comment},
  {"set_plane", &Dtool_CollisionPlane_set_plane_182, METH_O, (const char *)Dtool_CollisionPlane_set_plane_182_comment},
  {"setPlane", &Dtool_CollisionPlane_set_plane_182, METH_O, (const char *)Dtool_CollisionPlane_set_plane_182_comment},
  {"get_plane", &Dtool_CollisionPlane_get_plane_183, METH_NOARGS, (const char *)Dtool_CollisionPlane_get_plane_183_comment},
  {"getPlane", &Dtool_CollisionPlane_get_plane_183, METH_NOARGS, (const char *)Dtool_CollisionPlane_get_plane_183_comment},
  {"flip", &Dtool_CollisionPlane_flip_184, METH_NOARGS, (const char *)Dtool_CollisionPlane_flip_184_comment},
  {"get_class_type", &Dtool_CollisionPlane_get_class_type_190, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionPlane_get_class_type_190_comment},
  {"getClassType", &Dtool_CollisionPlane_get_class_type_190, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionPlane_get_class_type_190_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CollisionPlane[] = {
  {(char *)"normal", &Dtool_CollisionPlane_normal_Getter, nullptr, nullptr, nullptr},
  {(char *)"plane", &Dtool_CollisionPlane_plane_Getter, &Dtool_CollisionPlane_plane_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionPlane = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionPlane = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionPlane = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionPlane = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionPlane = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionPlane = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionPlane",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionPlane,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionPlane,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionPlane,
    &Dtool_SequenceMethods_CollisionPlane,
    &Dtool_MappingMethods_CollisionPlane,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionPlane,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionPlane,
    nullptr, // tp_members
    Dtool_Properties_CollisionPlane,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionPlane,
    PyType_GenericAlloc,
    Dtool_new_CollisionPlane,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionPlane,
  Dtool_UpcastInterface_CollisionPlane,
  Dtool_DowncastInterface_CollisionPlane,
  (CoerceFunction)Dtool_ConstCoerce_CollisionPlane,
  (CoerceFunction)Dtool_Coerce_CollisionPlane,
};

static void Dtool_PyModuleClassInit_CollisionPlane(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSolid(nullptr);
    Dtool_CollisionPlane._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSolid);
    Dtool_CollisionPlane._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionPlane._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionPlane) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionPlane)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionPlane);
  }
}

/**
 * Python method tables for CollisionFloorMesh (CollisionFloorMesh)
 */
static PyMethodDef Dtool_Methods_CollisionFloorMesh[] = {
  {"add_vertex", &Dtool_CollisionFloorMesh_add_vertex_194, METH_O, (const char *)Dtool_CollisionFloorMesh_add_vertex_194_comment},
  {"addVertex", &Dtool_CollisionFloorMesh_add_vertex_194, METH_O, (const char *)Dtool_CollisionFloorMesh_add_vertex_194_comment},
  {"add_triangle", (PyCFunction) &Dtool_CollisionFloorMesh_add_triangle_195, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionFloorMesh_add_triangle_195_comment},
  {"addTriangle", (PyCFunction) &Dtool_CollisionFloorMesh_add_triangle_195, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionFloorMesh_add_triangle_195_comment},
  {"get_num_vertices", &Dtool_CollisionFloorMesh_get_num_vertices_196, METH_NOARGS, (const char *)Dtool_CollisionFloorMesh_get_num_vertices_196_comment},
  {"getNumVertices", &Dtool_CollisionFloorMesh_get_num_vertices_196, METH_NOARGS, (const char *)Dtool_CollisionFloorMesh_get_num_vertices_196_comment},
  {"get_vertex", &Dtool_CollisionFloorMesh_get_vertex_197, METH_O, (const char *)Dtool_CollisionFloorMesh_get_vertex_197_comment},
  {"getVertex", &Dtool_CollisionFloorMesh_get_vertex_197, METH_O, (const char *)Dtool_CollisionFloorMesh_get_vertex_197_comment},
  {"get_num_triangles", &Dtool_CollisionFloorMesh_get_num_triangles_199, METH_NOARGS, (const char *)Dtool_CollisionFloorMesh_get_num_triangles_199_comment},
  {"getNumTriangles", &Dtool_CollisionFloorMesh_get_num_triangles_199, METH_NOARGS, (const char *)Dtool_CollisionFloorMesh_get_num_triangles_199_comment},
  {"get_triangle", &Dtool_CollisionFloorMesh_get_triangle_200, METH_O, (const char *)Dtool_CollisionFloorMesh_get_triangle_200_comment},
  {"getTriangle", &Dtool_CollisionFloorMesh_get_triangle_200, METH_O, (const char *)Dtool_CollisionFloorMesh_get_triangle_200_comment},
  {"get_class_type", &Dtool_CollisionFloorMesh_get_class_type_205, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionFloorMesh_get_class_type_205_comment},
  {"getClassType", &Dtool_CollisionFloorMesh_get_class_type_205, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionFloorMesh_get_class_type_205_comment},
  {"get_vertices", (PyCFunction) &MakeSeq_CollisionFloorMesh_get_vertices, METH_NOARGS, nullptr},
  { "getVertices", (PyCFunction) &MakeSeq_CollisionFloorMesh_get_vertices, METH_NOARGS, nullptr},
  {"get_triangles", (PyCFunction) &MakeSeq_CollisionFloorMesh_get_triangles, METH_NOARGS, nullptr},
  { "getTriangles", (PyCFunction) &MakeSeq_CollisionFloorMesh_get_triangles, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CollisionFloorMesh[] = {
  {(char *)"vertices", &Dtool_CollisionFloorMesh_vertices_Getter, nullptr, nullptr, nullptr},
  {(char *)"triangles", &Dtool_CollisionFloorMesh_triangles_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionFloorMesh = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionFloorMesh = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionFloorMesh = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionFloorMesh = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionFloorMesh = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionFloorMesh = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionFloorMesh",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionFloorMesh,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionFloorMesh,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionFloorMesh,
    &Dtool_SequenceMethods_CollisionFloorMesh,
    &Dtool_MappingMethods_CollisionFloorMesh,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionFloorMesh,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This object represents a solid made entirely of triangles, which will only\n"
    " * be tested again z axis aligned rays\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionFloorMesh,
    nullptr, // tp_members
    Dtool_Properties_CollisionFloorMesh,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionFloorMesh,
    PyType_GenericAlloc,
    Dtool_new_CollisionFloorMesh,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionFloorMesh,
  Dtool_UpcastInterface_CollisionFloorMesh,
  Dtool_DowncastInterface_CollisionFloorMesh,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionFloorMesh(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSolid(nullptr);
    Dtool_CollisionFloorMesh._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSolid);
    Dtool_CollisionFloorMesh._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionFloorMesh._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionFloorMesh) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionFloorMesh)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionFloorMesh);
  }
}

/**
 * Python method tables for CollisionPolygon (CollisionPolygon)
 */
static PyMethodDef Dtool_Methods_CollisionPolygon[] = {
  {"get_num_points", &Dtool_CollisionPolygon_get_num_points_209, METH_NOARGS, (const char *)Dtool_CollisionPolygon_get_num_points_209_comment},
  {"getNumPoints", &Dtool_CollisionPolygon_get_num_points_209, METH_NOARGS, (const char *)Dtool_CollisionPolygon_get_num_points_209_comment},
  {"get_point", &Dtool_CollisionPolygon_get_point_210, METH_O, (const char *)Dtool_CollisionPolygon_get_point_210_comment},
  {"getPoint", &Dtool_CollisionPolygon_get_point_210, METH_O, (const char *)Dtool_CollisionPolygon_get_point_210_comment},
  {"verify_points", (PyCFunction) &Dtool_CollisionPolygon_verify_points_212, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_CollisionPolygon_verify_points_212_comment},
  {"verifyPoints", (PyCFunction) &Dtool_CollisionPolygon_verify_points_212, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_CollisionPolygon_verify_points_212_comment},
  {"is_valid", &Dtool_CollisionPolygon_is_valid_213, METH_NOARGS, (const char *)Dtool_CollisionPolygon_is_valid_213_comment},
  {"isValid", &Dtool_CollisionPolygon_is_valid_213, METH_NOARGS, (const char *)Dtool_CollisionPolygon_is_valid_213_comment},
  {"is_concave", &Dtool_CollisionPolygon_is_concave_214, METH_NOARGS, (const char *)Dtool_CollisionPolygon_is_concave_214_comment},
  {"isConcave", &Dtool_CollisionPolygon_is_concave_214, METH_NOARGS, (const char *)Dtool_CollisionPolygon_is_concave_214_comment},
  {"get_class_type", &Dtool_CollisionPolygon_get_class_type_218, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionPolygon_get_class_type_218_comment},
  {"getClassType", &Dtool_CollisionPolygon_get_class_type_218, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionPolygon_get_class_type_218_comment},
  {"get_points", (PyCFunction) &MakeSeq_CollisionPolygon_get_points, METH_NOARGS, nullptr},
  { "getPoints", (PyCFunction) &MakeSeq_CollisionPolygon_get_points, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CollisionPolygon[] = {
  {(char *)"points", &Dtool_CollisionPolygon_points_Getter, nullptr, nullptr, nullptr},
  {(char *)"valid", &Dtool_CollisionPolygon_valid_Getter, nullptr, nullptr, nullptr},
  {(char *)"concave", &Dtool_CollisionPolygon_concave_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionPolygon = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionPolygon = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionPolygon = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionPolygon = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionPolygon = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionPolygon = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionPolygon",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionPolygon,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionPolygon,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionPolygon,
    &Dtool_SequenceMethods_CollisionPolygon,
    &Dtool_MappingMethods_CollisionPolygon,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionPolygon,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionPolygon,
    nullptr, // tp_members
    Dtool_Properties_CollisionPolygon,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionPolygon,
    PyType_GenericAlloc,
    Dtool_new_CollisionPolygon,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionPolygon,
  Dtool_UpcastInterface_CollisionPolygon,
  Dtool_DowncastInterface_CollisionPolygon,
  (CoerceFunction)Dtool_ConstCoerce_CollisionPolygon,
  (CoerceFunction)Dtool_Coerce_CollisionPolygon,
};

static void Dtool_PyModuleClassInit_CollisionPolygon(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionPlane(nullptr);
    Dtool_CollisionPolygon._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionPlane);
    Dtool_CollisionPolygon._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionPolygon._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionPolygon) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionPolygon)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionPolygon);
  }
}

/**
 * Python method tables for CollisionHandlerEvent (CollisionHandlerEvent)
 */
static PyMethodDef Dtool_Methods_CollisionHandlerEvent[] = {
  {"clear_in_patterns", &Dtool_CollisionHandlerEvent_clear_in_patterns_222, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_clear_in_patterns_222_comment},
  {"clearInPatterns", &Dtool_CollisionHandlerEvent_clear_in_patterns_222, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_clear_in_patterns_222_comment},
  {"add_in_pattern", &Dtool_CollisionHandlerEvent_add_in_pattern_223, METH_O, (const char *)Dtool_CollisionHandlerEvent_add_in_pattern_223_comment},
  {"addInPattern", &Dtool_CollisionHandlerEvent_add_in_pattern_223, METH_O, (const char *)Dtool_CollisionHandlerEvent_add_in_pattern_223_comment},
  {"set_in_pattern", &Dtool_CollisionHandlerEvent_set_in_pattern_224, METH_O, (const char *)Dtool_CollisionHandlerEvent_set_in_pattern_224_comment},
  {"setInPattern", &Dtool_CollisionHandlerEvent_set_in_pattern_224, METH_O, (const char *)Dtool_CollisionHandlerEvent_set_in_pattern_224_comment},
  {"get_num_in_patterns", &Dtool_CollisionHandlerEvent_get_num_in_patterns_225, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_get_num_in_patterns_225_comment},
  {"getNumInPatterns", &Dtool_CollisionHandlerEvent_get_num_in_patterns_225, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_get_num_in_patterns_225_comment},
  {"get_in_pattern", &Dtool_CollisionHandlerEvent_get_in_pattern_226, METH_O, (const char *)Dtool_CollisionHandlerEvent_get_in_pattern_226_comment},
  {"getInPattern", &Dtool_CollisionHandlerEvent_get_in_pattern_226, METH_O, (const char *)Dtool_CollisionHandlerEvent_get_in_pattern_226_comment},
  {"clear_again_patterns", &Dtool_CollisionHandlerEvent_clear_again_patterns_228, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_clear_again_patterns_228_comment},
  {"clearAgainPatterns", &Dtool_CollisionHandlerEvent_clear_again_patterns_228, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_clear_again_patterns_228_comment},
  {"add_again_pattern", &Dtool_CollisionHandlerEvent_add_again_pattern_229, METH_O, (const char *)Dtool_CollisionHandlerEvent_add_again_pattern_229_comment},
  {"addAgainPattern", &Dtool_CollisionHandlerEvent_add_again_pattern_229, METH_O, (const char *)Dtool_CollisionHandlerEvent_add_again_pattern_229_comment},
  {"set_again_pattern", &Dtool_CollisionHandlerEvent_set_again_pattern_230, METH_O, (const char *)Dtool_CollisionHandlerEvent_set_again_pattern_230_comment},
  {"setAgainPattern", &Dtool_CollisionHandlerEvent_set_again_pattern_230, METH_O, (const char *)Dtool_CollisionHandlerEvent_set_again_pattern_230_comment},
  {"get_num_again_patterns", &Dtool_CollisionHandlerEvent_get_num_again_patterns_231, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_get_num_again_patterns_231_comment},
  {"getNumAgainPatterns", &Dtool_CollisionHandlerEvent_get_num_again_patterns_231, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_get_num_again_patterns_231_comment},
  {"get_again_pattern", &Dtool_CollisionHandlerEvent_get_again_pattern_232, METH_O, (const char *)Dtool_CollisionHandlerEvent_get_again_pattern_232_comment},
  {"getAgainPattern", &Dtool_CollisionHandlerEvent_get_again_pattern_232, METH_O, (const char *)Dtool_CollisionHandlerEvent_get_again_pattern_232_comment},
  {"clear_out_patterns", &Dtool_CollisionHandlerEvent_clear_out_patterns_234, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_clear_out_patterns_234_comment},
  {"clearOutPatterns", &Dtool_CollisionHandlerEvent_clear_out_patterns_234, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_clear_out_patterns_234_comment},
  {"add_out_pattern", &Dtool_CollisionHandlerEvent_add_out_pattern_235, METH_O, (const char *)Dtool_CollisionHandlerEvent_add_out_pattern_235_comment},
  {"addOutPattern", &Dtool_CollisionHandlerEvent_add_out_pattern_235, METH_O, (const char *)Dtool_CollisionHandlerEvent_add_out_pattern_235_comment},
  {"set_out_pattern", &Dtool_CollisionHandlerEvent_set_out_pattern_236, METH_O, (const char *)Dtool_CollisionHandlerEvent_set_out_pattern_236_comment},
  {"setOutPattern", &Dtool_CollisionHandlerEvent_set_out_pattern_236, METH_O, (const char *)Dtool_CollisionHandlerEvent_set_out_pattern_236_comment},
  {"get_num_out_patterns", &Dtool_CollisionHandlerEvent_get_num_out_patterns_237, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_get_num_out_patterns_237_comment},
  {"getNumOutPatterns", &Dtool_CollisionHandlerEvent_get_num_out_patterns_237, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_get_num_out_patterns_237_comment},
  {"get_out_pattern", &Dtool_CollisionHandlerEvent_get_out_pattern_238, METH_O, (const char *)Dtool_CollisionHandlerEvent_get_out_pattern_238_comment},
  {"getOutPattern", &Dtool_CollisionHandlerEvent_get_out_pattern_238, METH_O, (const char *)Dtool_CollisionHandlerEvent_get_out_pattern_238_comment},
  {"clear", &Dtool_CollisionHandlerEvent_clear_245, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_clear_245_comment},
  {"flush", &Dtool_CollisionHandlerEvent_flush_246, METH_NOARGS, (const char *)Dtool_CollisionHandlerEvent_flush_246_comment},
  {"get_class_type", &Dtool_CollisionHandlerEvent_get_class_type_247, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerEvent_get_class_type_247_comment},
  {"getClassType", &Dtool_CollisionHandlerEvent_get_class_type_247, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerEvent_get_class_type_247_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_in_patterns", (PyCFunction) &MakeSeq_CollisionHandlerEvent_get_in_patterns, METH_NOARGS, nullptr},
  { "getInPatterns", (PyCFunction) &MakeSeq_CollisionHandlerEvent_get_in_patterns, METH_NOARGS, nullptr},
  {"get_again_patterns", (PyCFunction) &MakeSeq_CollisionHandlerEvent_get_again_patterns, METH_NOARGS, nullptr},
  { "getAgainPatterns", (PyCFunction) &MakeSeq_CollisionHandlerEvent_get_again_patterns, METH_NOARGS, nullptr},
  {"get_out_patterns", (PyCFunction) &MakeSeq_CollisionHandlerEvent_get_out_patterns, METH_NOARGS, nullptr},
  { "getOutPatterns", (PyCFunction) &MakeSeq_CollisionHandlerEvent_get_out_patterns, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CollisionHandlerEvent[] = {
  {(char *)"in_patterns", &Dtool_CollisionHandlerEvent_in_patterns_Getter, nullptr, nullptr, nullptr},
  {(char *)"again_patterns", &Dtool_CollisionHandlerEvent_again_patterns_Getter, nullptr, nullptr, nullptr},
  {(char *)"out_patterns", &Dtool_CollisionHandlerEvent_out_patterns_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandlerEvent = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandlerEvent = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandlerEvent = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandlerEvent = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionHandlerEvent = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionHandlerEvent = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionHandlerEvent",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandlerEvent,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionHandlerEvent,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionHandlerEvent,
    &Dtool_SequenceMethods_CollisionHandlerEvent,
    &Dtool_MappingMethods_CollisionHandlerEvent,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionHandlerEvent,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specialized kind of CollisionHandler that throws an event for each\n"
    " * collision detected.  The event thrown may be based on the name of the\n"
    " * moving object or the struck object, or both.  The first parameter of the\n"
    " * event will be a pointer to the CollisionEntry that triggered it.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionHandlerEvent,
    nullptr, // tp_members
    Dtool_Properties_CollisionHandlerEvent,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionHandlerEvent,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandlerEvent,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandlerEvent,
  Dtool_UpcastInterface_CollisionHandlerEvent,
  Dtool_DowncastInterface_CollisionHandlerEvent,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionHandlerEvent(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionHandler(nullptr);
    Dtool_CollisionHandlerEvent._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionHandler);
    Dtool_CollisionHandlerEvent._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandlerEvent._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandlerEvent) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandlerEvent)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandlerEvent);
  }
}

/**
 * Python method tables for CollisionHandlerPhysical (CollisionHandlerPhysical)
 */
static PyMethodDef Dtool_Methods_CollisionHandlerPhysical[] = {
  {"add_collider", (PyCFunction) &Dtool_CollisionHandlerPhysical_add_collider_250, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionHandlerPhysical_add_collider_250_comment},
  {"addCollider", (PyCFunction) &Dtool_CollisionHandlerPhysical_add_collider_250, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionHandlerPhysical_add_collider_250_comment},
  {"remove_collider", &Dtool_CollisionHandlerPhysical_remove_collider_251, METH_O, (const char *)Dtool_CollisionHandlerPhysical_remove_collider_251_comment},
  {"removeCollider", &Dtool_CollisionHandlerPhysical_remove_collider_251, METH_O, (const char *)Dtool_CollisionHandlerPhysical_remove_collider_251_comment},
  {"has_collider", &Dtool_CollisionHandlerPhysical_has_collider_252, METH_O, (const char *)Dtool_CollisionHandlerPhysical_has_collider_252_comment},
  {"hasCollider", &Dtool_CollisionHandlerPhysical_has_collider_252, METH_O, (const char *)Dtool_CollisionHandlerPhysical_has_collider_252_comment},
  {"clear_colliders", &Dtool_CollisionHandlerPhysical_clear_colliders_253, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_clear_colliders_253_comment},
  {"clearColliders", &Dtool_CollisionHandlerPhysical_clear_colliders_253, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_clear_colliders_253_comment},
  {"set_center", &Dtool_CollisionHandlerPhysical_set_center_254, METH_O, (const char *)Dtool_CollisionHandlerPhysical_set_center_254_comment},
  {"setCenter", &Dtool_CollisionHandlerPhysical_set_center_254, METH_O, (const char *)Dtool_CollisionHandlerPhysical_set_center_254_comment},
  {"clear_center", &Dtool_CollisionHandlerPhysical_clear_center_255, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_clear_center_255_comment},
  {"clearCenter", &Dtool_CollisionHandlerPhysical_clear_center_255, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_clear_center_255_comment},
  {"get_center", &Dtool_CollisionHandlerPhysical_get_center_256, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_get_center_256_comment},
  {"getCenter", &Dtool_CollisionHandlerPhysical_get_center_256, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_get_center_256_comment},
  {"has_center", &Dtool_CollisionHandlerPhysical_has_center_257, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_has_center_257_comment},
  {"hasCenter", &Dtool_CollisionHandlerPhysical_has_center_257, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_has_center_257_comment},
  {"has_contact", &Dtool_CollisionHandlerPhysical_has_contact_258, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_has_contact_258_comment},
  {"hasContact", &Dtool_CollisionHandlerPhysical_has_contact_258, METH_NOARGS, (const char *)Dtool_CollisionHandlerPhysical_has_contact_258_comment},
  {"get_class_type", &Dtool_CollisionHandlerPhysical_get_class_type_261, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerPhysical_get_class_type_261_comment},
  {"getClassType", &Dtool_CollisionHandlerPhysical_get_class_type_261, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerPhysical_get_class_type_261_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CollisionHandlerPhysical[] = {
  {(char *)"center", &Dtool_CollisionHandlerPhysical_center_Getter, &Dtool_CollisionHandlerPhysical_center_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandlerPhysical = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandlerPhysical = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandlerPhysical = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandlerPhysical = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionHandlerPhysical = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionHandlerPhysical = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionHandlerPhysical",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandlerPhysical,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionHandlerPhysical,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionHandlerPhysical,
    &Dtool_SequenceMethods_CollisionHandlerPhysical,
    &Dtool_MappingMethods_CollisionHandlerPhysical,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionHandlerPhysical,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The abstract base class for a number of CollisionHandlers that have some\n"
    " * physical effect on their moving bodies: they need to update the nodes'\n"
    " * positions based on the effects of the collision.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionHandlerPhysical,
    nullptr, // tp_members
    Dtool_Properties_CollisionHandlerPhysical,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionHandlerPhysical,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandlerPhysical,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandlerPhysical,
  Dtool_UpcastInterface_CollisionHandlerPhysical,
  Dtool_DowncastInterface_CollisionHandlerPhysical,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionHandlerPhysical(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionHandlerEvent(nullptr);
    Dtool_CollisionHandlerPhysical._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionHandlerEvent);
    Dtool_CollisionHandlerPhysical._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandlerPhysical._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandlerPhysical) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandlerPhysical)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandlerPhysical);
  }
}

/**
 * Python method tables for CollisionHandlerFloor (CollisionHandlerFloor)
 */
static PyMethodDef Dtool_Methods_CollisionHandlerFloor[] = {
  {"set_offset", &Dtool_CollisionHandlerFloor_set_offset_264, METH_O, (const char *)Dtool_CollisionHandlerFloor_set_offset_264_comment},
  {"setOffset", &Dtool_CollisionHandlerFloor_set_offset_264, METH_O, (const char *)Dtool_CollisionHandlerFloor_set_offset_264_comment},
  {"get_offset", &Dtool_CollisionHandlerFloor_get_offset_265, METH_NOARGS, (const char *)Dtool_CollisionHandlerFloor_get_offset_265_comment},
  {"getOffset", &Dtool_CollisionHandlerFloor_get_offset_265, METH_NOARGS, (const char *)Dtool_CollisionHandlerFloor_get_offset_265_comment},
  {"set_reach", &Dtool_CollisionHandlerFloor_set_reach_266, METH_O, (const char *)Dtool_CollisionHandlerFloor_set_reach_266_comment},
  {"setReach", &Dtool_CollisionHandlerFloor_set_reach_266, METH_O, (const char *)Dtool_CollisionHandlerFloor_set_reach_266_comment},
  {"get_reach", &Dtool_CollisionHandlerFloor_get_reach_267, METH_NOARGS, (const char *)Dtool_CollisionHandlerFloor_get_reach_267_comment},
  {"getReach", &Dtool_CollisionHandlerFloor_get_reach_267, METH_NOARGS, (const char *)Dtool_CollisionHandlerFloor_get_reach_267_comment},
  {"set_max_velocity", &Dtool_CollisionHandlerFloor_set_max_velocity_268, METH_O, (const char *)Dtool_CollisionHandlerFloor_set_max_velocity_268_comment},
  {"setMaxVelocity", &Dtool_CollisionHandlerFloor_set_max_velocity_268, METH_O, (const char *)Dtool_CollisionHandlerFloor_set_max_velocity_268_comment},
  {"get_max_velocity", &Dtool_CollisionHandlerFloor_get_max_velocity_269, METH_NOARGS, (const char *)Dtool_CollisionHandlerFloor_get_max_velocity_269_comment},
  {"getMaxVelocity", &Dtool_CollisionHandlerFloor_get_max_velocity_269, METH_NOARGS, (const char *)Dtool_CollisionHandlerFloor_get_max_velocity_269_comment},
  {"get_class_type", &Dtool_CollisionHandlerFloor_get_class_type_273, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerFloor_get_class_type_273_comment},
  {"getClassType", &Dtool_CollisionHandlerFloor_get_class_type_273, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerFloor_get_class_type_273_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CollisionHandlerFloor[] = {
  {(char *)"offset", &Dtool_CollisionHandlerFloor_offset_Getter, &Dtool_CollisionHandlerFloor_offset_Setter, nullptr, nullptr},
  {(char *)"reach", &Dtool_CollisionHandlerFloor_reach_Getter, &Dtool_CollisionHandlerFloor_reach_Setter, nullptr, nullptr},
  {(char *)"max_velocity", &Dtool_CollisionHandlerFloor_max_velocity_Getter, &Dtool_CollisionHandlerFloor_max_velocity_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandlerFloor = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandlerFloor = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandlerFloor = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandlerFloor = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionHandlerFloor = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionHandlerFloor = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionHandlerFloor",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandlerFloor,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionHandlerFloor,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionHandlerFloor,
    &Dtool_SequenceMethods_CollisionHandlerFloor,
    &Dtool_MappingMethods_CollisionHandlerFloor,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionHandlerFloor,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specialized kind of CollisionHandler that sets the Z height of the\n"
    " * collider to a fixed linear offset from the highest detected collision point\n"
    " * each frame.  It's intended to implement walking around on a floor of\n"
    " * varying height by casting a ray down from the avatar's head.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionHandlerFloor,
    nullptr, // tp_members
    Dtool_Properties_CollisionHandlerFloor,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionHandlerFloor,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandlerFloor,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandlerFloor,
  Dtool_UpcastInterface_CollisionHandlerFloor,
  Dtool_DowncastInterface_CollisionHandlerFloor,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionHandlerFloor(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionHandlerPhysical(nullptr);
    Dtool_CollisionHandlerFloor._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionHandlerPhysical);
    Dtool_CollisionHandlerFloor._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandlerFloor._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandlerFloor) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandlerFloor)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandlerFloor);
  }
}

/**
 * Python method tables for CollisionHandlerPusher (CollisionHandlerPusher)
 */
static PyMethodDef Dtool_Methods_CollisionHandlerPusher[] = {
  {"set_horizontal", &Dtool_CollisionHandlerPusher_set_horizontal_276, METH_O, (const char *)Dtool_CollisionHandlerPusher_set_horizontal_276_comment},
  {"setHorizontal", &Dtool_CollisionHandlerPusher_set_horizontal_276, METH_O, (const char *)Dtool_CollisionHandlerPusher_set_horizontal_276_comment},
  {"get_horizontal", &Dtool_CollisionHandlerPusher_get_horizontal_277, METH_NOARGS, (const char *)Dtool_CollisionHandlerPusher_get_horizontal_277_comment},
  {"getHorizontal", &Dtool_CollisionHandlerPusher_get_horizontal_277, METH_NOARGS, (const char *)Dtool_CollisionHandlerPusher_get_horizontal_277_comment},
  {"get_class_type", &Dtool_CollisionHandlerPusher_get_class_type_279, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerPusher_get_class_type_279_comment},
  {"getClassType", &Dtool_CollisionHandlerPusher_get_class_type_279, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerPusher_get_class_type_279_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CollisionHandlerPusher[] = {
  {(char *)"horizontal", &Dtool_CollisionHandlerPusher_horizontal_Getter, &Dtool_CollisionHandlerPusher_horizontal_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandlerPusher = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandlerPusher = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandlerPusher = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandlerPusher = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionHandlerPusher = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionHandlerPusher = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionHandlerPusher",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandlerPusher,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionHandlerPusher,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionHandlerPusher,
    &Dtool_SequenceMethods_CollisionHandlerPusher,
    &Dtool_MappingMethods_CollisionHandlerPusher,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionHandlerPusher,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specialized kind of CollisionHandler that simply pushes back on things\n"
    " * that attempt to move into solid walls.  This is the simplest kind of \"real-\n"
    " * world\" collisions you can have.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionHandlerPusher,
    nullptr, // tp_members
    Dtool_Properties_CollisionHandlerPusher,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionHandlerPusher,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandlerPusher,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandlerPusher,
  Dtool_UpcastInterface_CollisionHandlerPusher,
  Dtool_DowncastInterface_CollisionHandlerPusher,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionHandlerPusher(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionHandlerPhysical(nullptr);
    Dtool_CollisionHandlerPusher._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionHandlerPhysical);
    Dtool_CollisionHandlerPusher._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandlerPusher._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandlerPusher) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandlerPusher)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandlerPusher);
  }
}

/**
 * Python method tables for CollisionHandlerFluidPusher (CollisionHandlerFluidPusher)
 */
static PyMethodDef Dtool_Methods_CollisionHandlerFluidPusher[] = {
  {"get_class_type", &Dtool_CollisionHandlerFluidPusher_get_class_type_282, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerFluidPusher_get_class_type_282_comment},
  {"getClassType", &Dtool_CollisionHandlerFluidPusher_get_class_type_282, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerFluidPusher_get_class_type_282_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandlerFluidPusher = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandlerFluidPusher = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandlerFluidPusher = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandlerFluidPusher = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionHandlerFluidPusher = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionHandlerFluidPusher = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionHandlerFluidPusher",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandlerFluidPusher,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionHandlerFluidPusher,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionHandlerFluidPusher,
    &Dtool_SequenceMethods_CollisionHandlerFluidPusher,
    &Dtool_MappingMethods_CollisionHandlerFluidPusher,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionHandlerFluidPusher,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A CollisionHandlerPusher that makes use of timing and spatial information\n"
    " * from fluid collisions to improve collision response\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionHandlerFluidPusher,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionHandlerFluidPusher,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandlerFluidPusher,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandlerFluidPusher,
  Dtool_UpcastInterface_CollisionHandlerFluidPusher,
  Dtool_DowncastInterface_CollisionHandlerFluidPusher,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionHandlerFluidPusher(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionHandlerPusher(nullptr);
    Dtool_CollisionHandlerFluidPusher._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionHandlerPusher);
    Dtool_CollisionHandlerFluidPusher._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandlerFluidPusher._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandlerFluidPusher) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandlerFluidPusher)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandlerFluidPusher);
  }
}

/**
 * Python method tables for CollisionHandlerGravity (CollisionHandlerGravity)
 */
static PyMethodDef Dtool_Methods_CollisionHandlerGravity[] = {
  {"set_offset", &Dtool_CollisionHandlerGravity_set_offset_286, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_offset_286_comment},
  {"setOffset", &Dtool_CollisionHandlerGravity_set_offset_286, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_offset_286_comment},
  {"get_offset", &Dtool_CollisionHandlerGravity_get_offset_287, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_offset_287_comment},
  {"getOffset", &Dtool_CollisionHandlerGravity_get_offset_287, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_offset_287_comment},
  {"set_reach", &Dtool_CollisionHandlerGravity_set_reach_288, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_reach_288_comment},
  {"setReach", &Dtool_CollisionHandlerGravity_set_reach_288, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_reach_288_comment},
  {"get_reach", &Dtool_CollisionHandlerGravity_get_reach_289, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_reach_289_comment},
  {"getReach", &Dtool_CollisionHandlerGravity_get_reach_289, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_reach_289_comment},
  {"get_airborne_height", &Dtool_CollisionHandlerGravity_get_airborne_height_290, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_airborne_height_290_comment},
  {"getAirborneHeight", &Dtool_CollisionHandlerGravity_get_airborne_height_290, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_airborne_height_290_comment},
  {"is_on_ground", &Dtool_CollisionHandlerGravity_is_on_ground_291, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_is_on_ground_291_comment},
  {"isOnGround", &Dtool_CollisionHandlerGravity_is_on_ground_291, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_is_on_ground_291_comment},
  {"get_impact_velocity", &Dtool_CollisionHandlerGravity_get_impact_velocity_292, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_impact_velocity_292_comment},
  {"getImpactVelocity", &Dtool_CollisionHandlerGravity_get_impact_velocity_292, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_impact_velocity_292_comment},
  {"get_contact_normal", &Dtool_CollisionHandlerGravity_get_contact_normal_293, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_contact_normal_293_comment},
  {"getContactNormal", &Dtool_CollisionHandlerGravity_get_contact_normal_293, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_contact_normal_293_comment},
  {"add_velocity", &Dtool_CollisionHandlerGravity_add_velocity_294, METH_O, (const char *)Dtool_CollisionHandlerGravity_add_velocity_294_comment},
  {"addVelocity", &Dtool_CollisionHandlerGravity_add_velocity_294, METH_O, (const char *)Dtool_CollisionHandlerGravity_add_velocity_294_comment},
  {"set_velocity", &Dtool_CollisionHandlerGravity_set_velocity_295, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_velocity_295_comment},
  {"setVelocity", &Dtool_CollisionHandlerGravity_set_velocity_295, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_velocity_295_comment},
  {"get_velocity", &Dtool_CollisionHandlerGravity_get_velocity_296, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_velocity_296_comment},
  {"getVelocity", &Dtool_CollisionHandlerGravity_get_velocity_296, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_velocity_296_comment},
  {"set_gravity", &Dtool_CollisionHandlerGravity_set_gravity_297, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_gravity_297_comment},
  {"setGravity", &Dtool_CollisionHandlerGravity_set_gravity_297, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_gravity_297_comment},
  {"get_gravity", &Dtool_CollisionHandlerGravity_get_gravity_298, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_gravity_298_comment},
  {"getGravity", &Dtool_CollisionHandlerGravity_get_gravity_298, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_gravity_298_comment},
  {"set_max_velocity", &Dtool_CollisionHandlerGravity_set_max_velocity_299, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_max_velocity_299_comment},
  {"setMaxVelocity", &Dtool_CollisionHandlerGravity_set_max_velocity_299, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_max_velocity_299_comment},
  {"get_max_velocity", &Dtool_CollisionHandlerGravity_get_max_velocity_300, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_max_velocity_300_comment},
  {"getMaxVelocity", &Dtool_CollisionHandlerGravity_get_max_velocity_300, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_max_velocity_300_comment},
  {"set_legacy_mode", &Dtool_CollisionHandlerGravity_set_legacy_mode_301, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_legacy_mode_301_comment},
  {"setLegacyMode", &Dtool_CollisionHandlerGravity_set_legacy_mode_301, METH_O, (const char *)Dtool_CollisionHandlerGravity_set_legacy_mode_301_comment},
  {"get_legacy_mode", &Dtool_CollisionHandlerGravity_get_legacy_mode_302, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_legacy_mode_302_comment},
  {"getLegacyMode", &Dtool_CollisionHandlerGravity_get_legacy_mode_302, METH_NOARGS, (const char *)Dtool_CollisionHandlerGravity_get_legacy_mode_302_comment},
  {"get_class_type", &Dtool_CollisionHandlerGravity_get_class_type_313, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerGravity_get_class_type_313_comment},
  {"getClassType", &Dtool_CollisionHandlerGravity_get_class_type_313, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerGravity_get_class_type_313_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CollisionHandlerGravity[] = {
  {(char *)"offset", &Dtool_CollisionHandlerGravity_offset_Getter, &Dtool_CollisionHandlerGravity_offset_Setter, nullptr, nullptr},
  {(char *)"reach", &Dtool_CollisionHandlerGravity_reach_Getter, &Dtool_CollisionHandlerGravity_reach_Setter, nullptr, nullptr},
  {(char *)"airborne_height", &Dtool_CollisionHandlerGravity_airborne_height_Getter, nullptr, nullptr, nullptr},
  {(char *)"on_ground", &Dtool_CollisionHandlerGravity_on_ground_Getter, nullptr, nullptr, nullptr},
  {(char *)"impact_velocity", &Dtool_CollisionHandlerGravity_impact_velocity_Getter, nullptr, nullptr, nullptr},
  {(char *)"contact_normal", &Dtool_CollisionHandlerGravity_contact_normal_Getter, nullptr, nullptr, nullptr},
  {(char *)"velocity", &Dtool_CollisionHandlerGravity_velocity_Getter, &Dtool_CollisionHandlerGravity_velocity_Setter, nullptr, nullptr},
  {(char *)"gravity", &Dtool_CollisionHandlerGravity_gravity_Getter, &Dtool_CollisionHandlerGravity_gravity_Setter, nullptr, nullptr},
  {(char *)"max_velocity", &Dtool_CollisionHandlerGravity_max_velocity_Getter, &Dtool_CollisionHandlerGravity_max_velocity_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandlerGravity = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandlerGravity = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandlerGravity = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandlerGravity = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionHandlerGravity = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionHandlerGravity = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionHandlerGravity",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandlerGravity,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionHandlerGravity,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionHandlerGravity,
    &Dtool_SequenceMethods_CollisionHandlerGravity,
    &Dtool_MappingMethods_CollisionHandlerGravity,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionHandlerGravity,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specialized kind of CollisionHandler that sets the Z height of the\n"
    " * collider to a fixed linear offset from the highest detected collision point\n"
    " * each frame.  It's intended to implement walking around on a floor of\n"
    " * varying height by casting a ray down from the avatar's head.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionHandlerGravity,
    nullptr, // tp_members
    Dtool_Properties_CollisionHandlerGravity,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionHandlerGravity,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandlerGravity,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandlerGravity,
  Dtool_UpcastInterface_CollisionHandlerGravity,
  Dtool_DowncastInterface_CollisionHandlerGravity,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionHandlerGravity(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionHandlerPhysical(nullptr);
    Dtool_CollisionHandlerGravity._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionHandlerPhysical);
    Dtool_CollisionHandlerGravity._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandlerGravity._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandlerGravity) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandlerGravity)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandlerGravity);
  }
}

/**
 * Python method tables for CollisionHandlerHighestEvent (CollisionHandlerHighestEvent)
 */
static PyMethodDef Dtool_Methods_CollisionHandlerHighestEvent[] = {
  {"get_class_type", &Dtool_CollisionHandlerHighestEvent_get_class_type_316, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerHighestEvent_get_class_type_316_comment},
  {"getClassType", &Dtool_CollisionHandlerHighestEvent_get_class_type_316, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerHighestEvent_get_class_type_316_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandlerHighestEvent = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandlerHighestEvent = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandlerHighestEvent = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandlerHighestEvent = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionHandlerHighestEvent = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionHandlerHighestEvent = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionHandlerHighestEvent",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandlerHighestEvent,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionHandlerHighestEvent,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionHandlerHighestEvent,
    &Dtool_SequenceMethods_CollisionHandlerHighestEvent,
    &Dtool_MappingMethods_CollisionHandlerHighestEvent,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionHandlerHighestEvent,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specialized kind of CollisionHandler that throws an event for each\n"
    " * collision detected.  The event thrown may be based on the name of the\n"
    " * moving object or the struck object, or both.  The first parameter of the\n"
    " * event will be a pointer to the CollisionEntry that triggered it.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionHandlerHighestEvent,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionHandlerHighestEvent,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandlerHighestEvent,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandlerHighestEvent,
  Dtool_UpcastInterface_CollisionHandlerHighestEvent,
  Dtool_DowncastInterface_CollisionHandlerHighestEvent,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionHandlerHighestEvent(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionHandlerEvent(nullptr);
    Dtool_CollisionHandlerHighestEvent._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionHandlerEvent);
    Dtool_CollisionHandlerHighestEvent._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandlerHighestEvent._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandlerHighestEvent) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandlerHighestEvent)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandlerHighestEvent);
  }
}

/**
 * Python method tables for CollisionHandlerQueue (CollisionHandlerQueue)
 */
static PyMethodDef Dtool_Methods_CollisionHandlerQueue[] = {
  {"sort_entries", &Dtool_CollisionHandlerQueue_sort_entries_320, METH_NOARGS, (const char *)Dtool_CollisionHandlerQueue_sort_entries_320_comment},
  {"sortEntries", &Dtool_CollisionHandlerQueue_sort_entries_320, METH_NOARGS, (const char *)Dtool_CollisionHandlerQueue_sort_entries_320_comment},
  {"clear_entries", &Dtool_CollisionHandlerQueue_clear_entries_321, METH_NOARGS, (const char *)Dtool_CollisionHandlerQueue_clear_entries_321_comment},
  {"clearEntries", &Dtool_CollisionHandlerQueue_clear_entries_321, METH_NOARGS, (const char *)Dtool_CollisionHandlerQueue_clear_entries_321_comment},
  {"get_num_entries", &Dtool_CollisionHandlerQueue_get_num_entries_322, METH_NOARGS, (const char *)Dtool_CollisionHandlerQueue_get_num_entries_322_comment},
  {"getNumEntries", &Dtool_CollisionHandlerQueue_get_num_entries_322, METH_NOARGS, (const char *)Dtool_CollisionHandlerQueue_get_num_entries_322_comment},
  {"get_entry", &Dtool_CollisionHandlerQueue_get_entry_323, METH_O, (const char *)Dtool_CollisionHandlerQueue_get_entry_323_comment},
  {"getEntry", &Dtool_CollisionHandlerQueue_get_entry_323, METH_O, (const char *)Dtool_CollisionHandlerQueue_get_entry_323_comment},
  {"output", &Dtool_CollisionHandlerQueue_output_327, METH_O, (const char *)Dtool_CollisionHandlerQueue_output_327_comment},
  {"write", (PyCFunction) &Dtool_CollisionHandlerQueue_write_328, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionHandlerQueue_write_328_comment},
  {"get_class_type", &Dtool_CollisionHandlerQueue_get_class_type_329, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerQueue_get_class_type_329_comment},
  {"getClassType", &Dtool_CollisionHandlerQueue_get_class_type_329, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionHandlerQueue_get_class_type_329_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_entries", (PyCFunction) &MakeSeq_CollisionHandlerQueue_get_entries, METH_NOARGS, nullptr},
  { "getEntries", (PyCFunction) &MakeSeq_CollisionHandlerQueue_get_entries, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     CollisionHandlerQueue
//////////////////
static PyObject *Dtool_Repr_CollisionHandlerQueue(PyObject *self) {
  CollisionHandlerQueue *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerQueue, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     CollisionHandlerQueue
//////////////////
static PyObject *Dtool_Str_CollisionHandlerQueue(PyObject *self) {
  CollisionHandlerQueue *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CollisionHandlerQueue, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_CollisionHandlerQueue[] = {
  {(char *)"entries", &Dtool_CollisionHandlerQueue_entries_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionHandlerQueue = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionHandlerQueue = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionHandlerQueue = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionHandlerQueue = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionHandlerQueue = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionHandlerQueue = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionHandlerQueue",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionHandlerQueue,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionHandlerQueue,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_CollisionHandlerQueue,
    &Dtool_NumberMethods_CollisionHandlerQueue,
    &Dtool_SequenceMethods_CollisionHandlerQueue,
    &Dtool_MappingMethods_CollisionHandlerQueue,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_CollisionHandlerQueue,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionHandlerQueue,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A special kind of CollisionHandler that does nothing except remember the\n"
    " * CollisionEntries detected the last pass.  This set of CollisionEntries may\n"
    " * then be queried by the calling function.  It's primarily useful when a\n"
    " * simple intersection test is being made, e.g.  for picking from the window.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionHandlerQueue,
    nullptr, // tp_members
    Dtool_Properties_CollisionHandlerQueue,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionHandlerQueue,
    PyType_GenericAlloc,
    Dtool_new_CollisionHandlerQueue,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionHandlerQueue,
  Dtool_UpcastInterface_CollisionHandlerQueue,
  Dtool_DowncastInterface_CollisionHandlerQueue,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionHandlerQueue(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionHandler(nullptr);
    Dtool_CollisionHandlerQueue._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionHandler);
    Dtool_CollisionHandlerQueue._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionHandlerQueue._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionHandlerQueue) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionHandlerQueue)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionHandlerQueue);
  }
}

/**
 * Python method tables for CollisionSphere (CollisionSphere)
 */
static PyMethodDef Dtool_Methods_CollisionSphere[] = {
  {"set_center", (PyCFunction) &Dtool_CollisionSphere_set_center_333, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSphere_set_center_333_comment},
  {"setCenter", (PyCFunction) &Dtool_CollisionSphere_set_center_333, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSphere_set_center_333_comment},
  {"get_center", &Dtool_CollisionSphere_get_center_334, METH_NOARGS, (const char *)Dtool_CollisionSphere_get_center_334_comment},
  {"getCenter", &Dtool_CollisionSphere_get_center_334, METH_NOARGS, (const char *)Dtool_CollisionSphere_get_center_334_comment},
  {"set_radius", &Dtool_CollisionSphere_set_radius_335, METH_O, (const char *)Dtool_CollisionSphere_set_radius_335_comment},
  {"setRadius", &Dtool_CollisionSphere_set_radius_335, METH_O, (const char *)Dtool_CollisionSphere_set_radius_335_comment},
  {"get_radius", &Dtool_CollisionSphere_get_radius_336, METH_NOARGS, (const char *)Dtool_CollisionSphere_get_radius_336_comment},
  {"getRadius", &Dtool_CollisionSphere_get_radius_336, METH_NOARGS, (const char *)Dtool_CollisionSphere_get_radius_336_comment},
  {"get_class_type", &Dtool_CollisionSphere_get_class_type_339, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionSphere_get_class_type_339_comment},
  {"getClassType", &Dtool_CollisionSphere_get_class_type_339, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionSphere_get_class_type_339_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CollisionSphere[] = {
  {(char *)"center", &Dtool_CollisionSphere_center_Getter, &Dtool_CollisionSphere_center_Setter, nullptr, nullptr},
  {(char *)"radius", &Dtool_CollisionSphere_radius_Getter, &Dtool_CollisionSphere_radius_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionSphere = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionSphere = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionSphere = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionSphere = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionSphere = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionSphere = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionSphere",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionSphere,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionSphere,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionSphere,
    &Dtool_SequenceMethods_CollisionSphere,
    &Dtool_MappingMethods_CollisionSphere,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionSphere,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A spherical collision volume or object.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionSphere,
    nullptr, // tp_members
    Dtool_Properties_CollisionSphere,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionSphere,
    PyType_GenericAlloc,
    Dtool_new_CollisionSphere,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionSphere,
  Dtool_UpcastInterface_CollisionSphere,
  Dtool_DowncastInterface_CollisionSphere,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionSphere(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSolid(nullptr);
    Dtool_CollisionSphere._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSolid);
    Dtool_CollisionSphere._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionSphere._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionSphere) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionSphere)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionSphere);
  }
}

/**
 * Python method tables for CollisionInvSphere (CollisionInvSphere)
 */
static PyMethodDef Dtool_Methods_CollisionInvSphere[] = {
  {"get_class_type", &Dtool_CollisionInvSphere_get_class_type_343, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionInvSphere_get_class_type_343_comment},
  {"getClassType", &Dtool_CollisionInvSphere_get_class_type_343, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionInvSphere_get_class_type_343_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CollisionInvSphere = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionInvSphere = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionInvSphere = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionInvSphere = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionInvSphere = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionInvSphere = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionInvSphere",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionInvSphere,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionInvSphere,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionInvSphere,
    &Dtool_SequenceMethods_CollisionInvSphere,
    &Dtool_MappingMethods_CollisionInvSphere,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionInvSphere,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An inverted sphere: this is a sphere whose collision surface is the inside\n"
    " * surface of the sphere.  Everything outside the sphere is solid matter;\n"
    " * everything inside is empty space.  Useful for constraining objects to\n"
    " * remain within a spherical perimeter.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionInvSphere,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionInvSphere,
    PyType_GenericAlloc,
    Dtool_new_CollisionInvSphere,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionInvSphere,
  Dtool_UpcastInterface_CollisionInvSphere,
  Dtool_DowncastInterface_CollisionInvSphere,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionInvSphere(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSphere(nullptr);
    Dtool_CollisionInvSphere._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSphere);
    Dtool_CollisionInvSphere._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionInvSphere._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionInvSphere) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionInvSphere)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionInvSphere);
  }
}

/**
 * Python method tables for CollisionRay (CollisionRay)
 */
static PyMethodDef Dtool_Methods_CollisionRay[] = {
  {"set_origin", (PyCFunction) &Dtool_CollisionRay_set_origin_347, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionRay_set_origin_347_comment},
  {"setOrigin", (PyCFunction) &Dtool_CollisionRay_set_origin_347, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionRay_set_origin_347_comment},
  {"get_origin", &Dtool_CollisionRay_get_origin_348, METH_NOARGS, (const char *)Dtool_CollisionRay_get_origin_348_comment},
  {"getOrigin", &Dtool_CollisionRay_get_origin_348, METH_NOARGS, (const char *)Dtool_CollisionRay_get_origin_348_comment},
  {"set_direction", (PyCFunction) &Dtool_CollisionRay_set_direction_350, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionRay_set_direction_350_comment},
  {"setDirection", (PyCFunction) &Dtool_CollisionRay_set_direction_350, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionRay_set_direction_350_comment},
  {"get_direction", &Dtool_CollisionRay_get_direction_351, METH_NOARGS, (const char *)Dtool_CollisionRay_get_direction_351_comment},
  {"getDirection", &Dtool_CollisionRay_get_direction_351, METH_NOARGS, (const char *)Dtool_CollisionRay_get_direction_351_comment},
  {"set_from_lens", (PyCFunction) &Dtool_CollisionRay_set_from_lens_353, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionRay_set_from_lens_353_comment},
  {"setFromLens", (PyCFunction) &Dtool_CollisionRay_set_from_lens_353, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionRay_set_from_lens_353_comment},
  {"get_class_type", &Dtool_CollisionRay_get_class_type_354, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionRay_get_class_type_354_comment},
  {"getClassType", &Dtool_CollisionRay_get_class_type_354, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionRay_get_class_type_354_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CollisionRay[] = {
  {(char *)"origin", &Dtool_CollisionRay_origin_Getter, &Dtool_CollisionRay_origin_Setter, nullptr, nullptr},
  {(char *)"direction", &Dtool_CollisionRay_direction_Getter, &Dtool_CollisionRay_direction_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionRay = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionRay = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionRay = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionRay = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionRay = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionRay = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionRay",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionRay,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionRay,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionRay,
    &Dtool_SequenceMethods_CollisionRay,
    &Dtool_MappingMethods_CollisionRay,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionRay,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An infinite ray, with a specific origin and direction.  It begins at its\n"
    " * origin and continues in one direction to infinity, and it has no radius.\n"
    " * Useful for picking from a window, or for gravity effects.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionRay,
    nullptr, // tp_members
    Dtool_Properties_CollisionRay,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionRay,
    PyType_GenericAlloc,
    Dtool_new_CollisionRay,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionRay,
  Dtool_UpcastInterface_CollisionRay,
  Dtool_DowncastInterface_CollisionRay,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionRay(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSolid(nullptr);
    Dtool_CollisionRay._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSolid);
    Dtool_CollisionRay._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionRay._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionRay) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionRay)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionRay);
  }
}

/**
 * Python method tables for CollisionLine (CollisionLine)
 */
static PyMethodDef Dtool_Methods_CollisionLine[] = {
  {"get_class_type", &Dtool_CollisionLine_get_class_type_358, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionLine_get_class_type_358_comment},
  {"getClassType", &Dtool_CollisionLine_get_class_type_358, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionLine_get_class_type_358_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CollisionLine = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionLine = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionLine = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionLine = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionLine = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionLine = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionLine",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionLine,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionLine,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionLine,
    &Dtool_SequenceMethods_CollisionLine,
    &Dtool_MappingMethods_CollisionLine,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionLine,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An infinite line, similar to a CollisionRay, except that it extends in both\n"
    " * directions.  It is, however, directional.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionLine,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionLine,
    PyType_GenericAlloc,
    Dtool_new_CollisionLine,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionLine,
  Dtool_UpcastInterface_CollisionLine,
  Dtool_DowncastInterface_CollisionLine,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionLine(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionRay(nullptr);
    Dtool_CollisionLine._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionRay);
    Dtool_CollisionLine._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionLine._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionLine) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionLine)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionLine);
  }
}

/**
 * Python method tables for CollisionParabola (CollisionParabola)
 */
static PyMethodDef Dtool_Methods_CollisionParabola[] = {
  {"set_parabola", &Dtool_CollisionParabola_set_parabola_362, METH_O, (const char *)Dtool_CollisionParabola_set_parabola_362_comment},
  {"setParabola", &Dtool_CollisionParabola_set_parabola_362, METH_O, (const char *)Dtool_CollisionParabola_set_parabola_362_comment},
  {"get_parabola", &Dtool_CollisionParabola_get_parabola_363, METH_NOARGS, (const char *)Dtool_CollisionParabola_get_parabola_363_comment},
  {"getParabola", &Dtool_CollisionParabola_get_parabola_363, METH_NOARGS, (const char *)Dtool_CollisionParabola_get_parabola_363_comment},
  {"set_t1", &Dtool_CollisionParabola_set_t1_364, METH_O, (const char *)Dtool_CollisionParabola_set_t1_364_comment},
  {"setT1", &Dtool_CollisionParabola_set_t1_364, METH_O, (const char *)Dtool_CollisionParabola_set_t1_364_comment},
  {"get_t1", &Dtool_CollisionParabola_get_t1_365, METH_NOARGS, (const char *)Dtool_CollisionParabola_get_t1_365_comment},
  {"getT1", &Dtool_CollisionParabola_get_t1_365, METH_NOARGS, (const char *)Dtool_CollisionParabola_get_t1_365_comment},
  {"set_t2", &Dtool_CollisionParabola_set_t2_366, METH_O, (const char *)Dtool_CollisionParabola_set_t2_366_comment},
  {"setT2", &Dtool_CollisionParabola_set_t2_366, METH_O, (const char *)Dtool_CollisionParabola_set_t2_366_comment},
  {"get_t2", &Dtool_CollisionParabola_get_t2_367, METH_NOARGS, (const char *)Dtool_CollisionParabola_get_t2_367_comment},
  {"getT2", &Dtool_CollisionParabola_get_t2_367, METH_NOARGS, (const char *)Dtool_CollisionParabola_get_t2_367_comment},
  {"get_class_type", &Dtool_CollisionParabola_get_class_type_374, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionParabola_get_class_type_374_comment},
  {"getClassType", &Dtool_CollisionParabola_get_class_type_374, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionParabola_get_class_type_374_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CollisionParabola[] = {
  {(char *)"parabola", &Dtool_CollisionParabola_parabola_Getter, &Dtool_CollisionParabola_parabola_Setter, nullptr, nullptr},
  {(char *)"t1", &Dtool_CollisionParabola_t1_Getter, &Dtool_CollisionParabola_t1_Setter, nullptr, nullptr},
  {(char *)"t2", &Dtool_CollisionParabola_t2_Getter, &Dtool_CollisionParabola_t2_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionParabola = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionParabola = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionParabola = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionParabola = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionParabola = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionParabola = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionParabola",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionParabola,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionParabola,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionParabola,
    &Dtool_SequenceMethods_CollisionParabola,
    &Dtool_MappingMethods_CollisionParabola,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionParabola,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This defines a parabolic arc, or subset of an arc, similar to the path of a\n"
    " * projectile or falling object.  It is finite, having a specific beginning\n"
    " * and end, but it is infinitely thin.\n"
    " *\n"
    " * Think of it as a wire bending from point t1 to point t2 along the path of a\n"
    " * pre-defined parabola.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionParabola,
    nullptr, // tp_members
    Dtool_Properties_CollisionParabola,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionParabola,
    PyType_GenericAlloc,
    Dtool_new_CollisionParabola,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionParabola,
  Dtool_UpcastInterface_CollisionParabola,
  Dtool_DowncastInterface_CollisionParabola,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionParabola(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSolid(nullptr);
    Dtool_CollisionParabola._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSolid);
    Dtool_CollisionParabola._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionParabola._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionParabola) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionParabola)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionParabola);
  }
}

/**
 * Python method tables for CollisionSegment (CollisionSegment)
 */
static PyMethodDef Dtool_Methods_CollisionSegment[] = {
  {"set_point_a", (PyCFunction) &Dtool_CollisionSegment_set_point_a_378, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSegment_set_point_a_378_comment},
  {"setPointA", (PyCFunction) &Dtool_CollisionSegment_set_point_a_378, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSegment_set_point_a_378_comment},
  {"get_point_a", &Dtool_CollisionSegment_get_point_a_379, METH_NOARGS, (const char *)Dtool_CollisionSegment_get_point_a_379_comment},
  {"getPointA", &Dtool_CollisionSegment_get_point_a_379, METH_NOARGS, (const char *)Dtool_CollisionSegment_get_point_a_379_comment},
  {"set_point_b", (PyCFunction) &Dtool_CollisionSegment_set_point_b_380, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSegment_set_point_b_380_comment},
  {"setPointB", (PyCFunction) &Dtool_CollisionSegment_set_point_b_380, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSegment_set_point_b_380_comment},
  {"get_point_b", &Dtool_CollisionSegment_get_point_b_381, METH_NOARGS, (const char *)Dtool_CollisionSegment_get_point_b_381_comment},
  {"getPointB", &Dtool_CollisionSegment_get_point_b_381, METH_NOARGS, (const char *)Dtool_CollisionSegment_get_point_b_381_comment},
  {"set_from_lens", (PyCFunction) &Dtool_CollisionSegment_set_from_lens_382, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSegment_set_from_lens_382_comment},
  {"setFromLens", (PyCFunction) &Dtool_CollisionSegment_set_from_lens_382, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CollisionSegment_set_from_lens_382_comment},
  {"get_class_type", &Dtool_CollisionSegment_get_class_type_385, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionSegment_get_class_type_385_comment},
  {"getClassType", &Dtool_CollisionSegment_get_class_type_385, METH_NOARGS | METH_STATIC, (const char *)Dtool_CollisionSegment_get_class_type_385_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CollisionSegment[] = {
  {(char *)"point_a", &Dtool_CollisionSegment_point_a_Getter, &Dtool_CollisionSegment_point_a_Setter, nullptr, nullptr},
  {(char *)"point_b", &Dtool_CollisionSegment_point_b_Getter, &Dtool_CollisionSegment_point_b_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CollisionSegment = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CollisionSegment = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CollisionSegment = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CollisionSegment = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CollisionSegment = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CollisionSegment = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CollisionSegment",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CollisionSegment,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CollisionSegment,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CollisionSegment,
    &Dtool_SequenceMethods_CollisionSegment,
    &Dtool_MappingMethods_CollisionSegment,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CollisionSegment,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A finite line segment, with two specific endpoints but no thickness.  It's\n"
    " * similar to a CollisionRay, except it does not continue to infinity.\n"
    " *\n"
    " * It does have an ordering, from point A to point B. If more than a single\n"
    " * point of the segment is intersecting a solid, the reported intersection\n"
    " * point is generally the closest on the segment to point A.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CollisionSegment,
    nullptr, // tp_members
    Dtool_Properties_CollisionSegment,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CollisionSegment,
    PyType_GenericAlloc,
    Dtool_new_CollisionSegment,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CollisionSegment,
  Dtool_UpcastInterface_CollisionSegment,
  Dtool_DowncastInterface_CollisionSegment,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CollisionSegment(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CollisionSolid(nullptr);
    Dtool_CollisionSegment._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CollisionSolid);
    Dtool_CollisionSegment._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CollisionSegment._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CollisionSegment) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CollisionSegment)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CollisionSegment);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3collide_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    CollisionSolid::init_type();
    TypeHandle handle = CollisionSolid::get_class_type();
    Dtool_CollisionSolid._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionSolid);
  }
  {
    CollisionBox::init_type();
    TypeHandle handle = CollisionBox::get_class_type();
    Dtool_CollisionBox._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionBox);
  }
  {
    CollisionCapsule::init_type();
    TypeHandle handle = CollisionCapsule::get_class_type();
    Dtool_CollisionCapsule._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionCapsule);
  }
  {
    CollisionHandler::init_type();
    TypeHandle handle = CollisionHandler::get_class_type();
    Dtool_CollisionHandler._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionHandler);
  }
  {
    CollisionNode::init_type();
    TypeHandle handle = CollisionNode::get_class_type();
    Dtool_CollisionNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionNode);
  }
  {
    CollisionTraverser::init_type();
    TypeHandle handle = CollisionTraverser::get_class_type();
    Dtool_CollisionTraverser._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionTraverser);
  }
  {
    CollisionRecorder::init_type();
    TypeHandle handle = CollisionRecorder::get_class_type();
    Dtool_CollisionRecorder._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionRecorder);
  }
  {
    CollisionEntry::init_type();
    TypeHandle handle = CollisionEntry::get_class_type();
    Dtool_CollisionEntry._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionEntry);
  }
  {
    CollisionPlane::init_type();
    TypeHandle handle = CollisionPlane::get_class_type();
    Dtool_CollisionPlane._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionPlane);
  }
  {
    CollisionFloorMesh::init_type();
    TypeHandle handle = CollisionFloorMesh::get_class_type();
    Dtool_CollisionFloorMesh._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionFloorMesh);
  }
  {
    CollisionPolygon::init_type();
    TypeHandle handle = CollisionPolygon::get_class_type();
    Dtool_CollisionPolygon._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionPolygon);
  }
  {
    CollisionHandlerEvent::init_type();
    TypeHandle handle = CollisionHandlerEvent::get_class_type();
    Dtool_CollisionHandlerEvent._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionHandlerEvent);
  }
  {
    CollisionHandlerPhysical::init_type();
    TypeHandle handle = CollisionHandlerPhysical::get_class_type();
    Dtool_CollisionHandlerPhysical._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionHandlerPhysical);
  }
  {
    CollisionHandlerFloor::init_type();
    TypeHandle handle = CollisionHandlerFloor::get_class_type();
    Dtool_CollisionHandlerFloor._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionHandlerFloor);
  }
  {
    CollisionHandlerPusher::init_type();
    TypeHandle handle = CollisionHandlerPusher::get_class_type();
    Dtool_CollisionHandlerPusher._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionHandlerPusher);
  }
  {
    CollisionHandlerFluidPusher::init_type();
    TypeHandle handle = CollisionHandlerFluidPusher::get_class_type();
    Dtool_CollisionHandlerFluidPusher._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionHandlerFluidPusher);
  }
  {
    CollisionHandlerGravity::init_type();
    TypeHandle handle = CollisionHandlerGravity::get_class_type();
    Dtool_CollisionHandlerGravity._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionHandlerGravity);
  }
  {
    CollisionHandlerHighestEvent::init_type();
    TypeHandle handle = CollisionHandlerHighestEvent::get_class_type();
    Dtool_CollisionHandlerHighestEvent._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionHandlerHighestEvent);
  }
  {
    CollisionHandlerQueue::init_type();
    TypeHandle handle = CollisionHandlerQueue::get_class_type();
    Dtool_CollisionHandlerQueue._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionHandlerQueue);
  }
  {
    CollisionSphere::init_type();
    TypeHandle handle = CollisionSphere::get_class_type();
    Dtool_CollisionSphere._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionSphere);
  }
  {
    CollisionInvSphere::init_type();
    TypeHandle handle = CollisionInvSphere::get_class_type();
    Dtool_CollisionInvSphere._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionInvSphere);
  }
  {
    CollisionRay::init_type();
    TypeHandle handle = CollisionRay::get_class_type();
    Dtool_CollisionRay._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionRay);
  }
  {
    CollisionLine::init_type();
    TypeHandle handle = CollisionLine::get_class_type();
    Dtool_CollisionLine._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionLine);
  }
  {
    CollisionParabola::init_type();
    TypeHandle handle = CollisionParabola::get_class_type();
    Dtool_CollisionParabola._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionParabola);
  }
  {
    CollisionSegment::init_type();
    TypeHandle handle = CollisionSegment::get_class_type();
    Dtool_CollisionSegment._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CollisionSegment);
  }
}

void Dtool_libp3collide_BuildInstants(PyObject *module) {
  (void) module;
  // CollisionSolid
  Dtool_PyModuleClassInit_CollisionSolid(module);
  PyModule_AddObject(module, "CollisionSolid", (PyObject *)&Dtool_CollisionSolid);
  // CollisionBox
  Dtool_PyModuleClassInit_CollisionBox(module);
  PyModule_AddObject(module, "CollisionBox", (PyObject *)&Dtool_CollisionBox);
  // CollisionCapsule
  Dtool_PyModuleClassInit_CollisionCapsule(module);
  PyModule_AddObject(module, "CollisionCapsule", (PyObject *)&Dtool_CollisionCapsule);
  // CollisionHandler
  Dtool_PyModuleClassInit_CollisionHandler(module);
  PyModule_AddObject(module, "CollisionHandler", (PyObject *)&Dtool_CollisionHandler);
  // CollisionNode
  Dtool_PyModuleClassInit_CollisionNode(module);
  PyModule_AddObject(module, "CollisionNode", (PyObject *)&Dtool_CollisionNode);
  // CollisionTraverser
  Dtool_PyModuleClassInit_CollisionTraverser(module);
  PyModule_AddObject(module, "CollisionTraverser", (PyObject *)&Dtool_CollisionTraverser);
  // CollisionRecorder
  Dtool_PyModuleClassInit_CollisionRecorder(module);
  PyModule_AddObject(module, "CollisionRecorder", (PyObject *)&Dtool_CollisionRecorder);
  // CollisionEntry
  Dtool_PyModuleClassInit_CollisionEntry(module);
  PyModule_AddObject(module, "CollisionEntry", (PyObject *)&Dtool_CollisionEntry);
  // CollisionPlane
  Dtool_PyModuleClassInit_CollisionPlane(module);
  PyModule_AddObject(module, "CollisionPlane", (PyObject *)&Dtool_CollisionPlane);
  // CollisionFloorMesh
  Dtool_PyModuleClassInit_CollisionFloorMesh(module);
  PyModule_AddObject(module, "CollisionFloorMesh", (PyObject *)&Dtool_CollisionFloorMesh);
  // CollisionPolygon
  Dtool_PyModuleClassInit_CollisionPolygon(module);
  PyModule_AddObject(module, "CollisionPolygon", (PyObject *)&Dtool_CollisionPolygon);
  // CollisionHandlerEvent
  Dtool_PyModuleClassInit_CollisionHandlerEvent(module);
  PyModule_AddObject(module, "CollisionHandlerEvent", (PyObject *)&Dtool_CollisionHandlerEvent);
  // CollisionHandlerPhysical
  Dtool_PyModuleClassInit_CollisionHandlerPhysical(module);
  PyModule_AddObject(module, "CollisionHandlerPhysical", (PyObject *)&Dtool_CollisionHandlerPhysical);
  // CollisionHandlerFloor
  Dtool_PyModuleClassInit_CollisionHandlerFloor(module);
  PyModule_AddObject(module, "CollisionHandlerFloor", (PyObject *)&Dtool_CollisionHandlerFloor);
  // CollisionHandlerPusher
  Dtool_PyModuleClassInit_CollisionHandlerPusher(module);
  PyModule_AddObject(module, "CollisionHandlerPusher", (PyObject *)&Dtool_CollisionHandlerPusher);
  // CollisionHandlerFluidPusher
  Dtool_PyModuleClassInit_CollisionHandlerFluidPusher(module);
  PyModule_AddObject(module, "CollisionHandlerFluidPusher", (PyObject *)&Dtool_CollisionHandlerFluidPusher);
  // CollisionHandlerGravity
  Dtool_PyModuleClassInit_CollisionHandlerGravity(module);
  PyModule_AddObject(module, "CollisionHandlerGravity", (PyObject *)&Dtool_CollisionHandlerGravity);
  // CollisionHandlerHighestEvent
  Dtool_PyModuleClassInit_CollisionHandlerHighestEvent(module);
  PyModule_AddObject(module, "CollisionHandlerHighestEvent", (PyObject *)&Dtool_CollisionHandlerHighestEvent);
  // CollisionHandlerQueue
  Dtool_PyModuleClassInit_CollisionHandlerQueue(module);
  PyModule_AddObject(module, "CollisionHandlerQueue", (PyObject *)&Dtool_CollisionHandlerQueue);
  // CollisionSphere
  Dtool_PyModuleClassInit_CollisionSphere(module);
  PyModule_AddObject(module, "CollisionSphere", (PyObject *)&Dtool_CollisionSphere);
  // CollisionInvSphere
  Dtool_PyModuleClassInit_CollisionInvSphere(module);
  PyModule_AddObject(module, "CollisionInvSphere", (PyObject *)&Dtool_CollisionInvSphere);
  // CollisionRay
  Dtool_PyModuleClassInit_CollisionRay(module);
  PyModule_AddObject(module, "CollisionRay", (PyObject *)&Dtool_CollisionRay);
  // CollisionLine
  Dtool_PyModuleClassInit_CollisionLine(module);
  PyModule_AddObject(module, "CollisionLine", (PyObject *)&Dtool_CollisionLine);
  // CollisionParabola
  Dtool_PyModuleClassInit_CollisionParabola(module);
  PyModule_AddObject(module, "CollisionParabola", (PyObject *)&Dtool_CollisionParabola);
  // CollisionSegment
  Dtool_PyModuleClassInit_CollisionSegment(module);
  PyModule_AddObject(module, "CollisionSegment", (PyObject *)&Dtool_CollisionSegment);
  // typedef CollisionCapsule CollisionTube
  Dtool_PyModuleClassInit_CollisionCapsule(module);
  Py_INCREF((PyObject *)&Dtool_CollisionCapsule);
  PyModule_AddObject(module, "CollisionTube", (PyObject *)&Dtool_CollisionCapsule);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3collide_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3collide_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613831,  /* file_identifier */
  "libp3collide",  /* library_name */
  "dlaq",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3collide.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  753  /* next_index */
};

Configure(_in_configure_libp3collide);
ConfigureFn(_in_configure_libp3collide) {
  interrogate_request_module(&_in_module_def);
}

