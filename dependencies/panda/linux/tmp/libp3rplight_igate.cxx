/*
 * This file was generated by:
 * built/bin/interrogate -srcdir contrib/src/rplight -Icontrib/src/rplight -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3rplight_igate.cxx -od built/pandac/input/libp3rplight.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Icontrib/src/rplight -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d._rplight -library libp3rplight config_rplight.h gpuCommand.h gpuCommandList.h iesDataset.h internalLightManager.h p3rplight_composite1.cxx pointerSlotStorage.h pssmCameraRig.h rpLight.h rpPointLight.h rpSpotLight.h shadowAtlas.h shadowManager.h shadowSource.h tagStateManager.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "configVariableDouble.h"
#include "configVariableInt.h"
#include "configVariableString.h"
#include "config_rplight.h"
#include "gpuCommand.h"
#include "gpuCommandList.h"
#include "iesDataset.h"
#include "internalLightManager.h"
#include "luse.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "pnmImage.h"
#include "pointerSlotStorage.h"
#include "pointerToArray.h"
#include "pssmCameraRig.h"
#include "pta_float.h"
#include <queue>
#include "referenceCount.h"
#include "rpLight.h"
#include "rpPointLight.h"
#include "rpSpotLight.h"
#include "shadowAtlas.h"
#include "shadowManager.h"
#include "shadowSource.h"
#include "tagStateManager.h"
#include "texture.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class GPUCommand
 */
typedef GPUCommand GPUCommand_localtype;
Define_Module_Class(panda3d._rplight, GPUCommand, GPUCommand_localtype, GPUCommand);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GPUCommand = &Dtool_GPUCommand;
static void Dtool_PyModuleClassInit_GPUCommand(PyObject *module);

/**
 * Forward declarations for top-level class GPUCommandList
 */
typedef GPUCommandList GPUCommandList_localtype;
Define_Module_Class(panda3d._rplight, GPUCommandList, GPUCommandList_localtype, GPUCommandList);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GPUCommandList = &Dtool_GPUCommandList;
static void Dtool_PyModuleClassInit_GPUCommandList(PyObject *module);

/**
 * Forward declarations for top-level class IESDataset
 */
typedef IESDataset IESDataset_localtype;
Define_Module_Class(panda3d._rplight, IESDataset, IESDataset_localtype, IESDataset);
static struct Dtool_PyTypedObject *const Dtool_Ptr_IESDataset = &Dtool_IESDataset;
static void Dtool_PyModuleClassInit_IESDataset(PyObject *module);

/**
 * Forward declarations for top-level class RPLight
 */
typedef RPLight RPLight_localtype;
Define_Module_ClassRef(panda3d._rplight, RPLight, RPLight_localtype, RPLight);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RPLight = &Dtool_RPLight;
static void Dtool_PyModuleClassInit_RPLight(PyObject *module);

/**
 * Forward declarations for top-level class ShadowAtlas
 */
typedef ShadowAtlas ShadowAtlas_localtype;
Define_Module_Class(panda3d._rplight, ShadowAtlas, ShadowAtlas_localtype, ShadowAtlas);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShadowAtlas = &Dtool_ShadowAtlas;
static void Dtool_PyModuleClassInit_ShadowAtlas(PyObject *module);

/**
 * Forward declarations for top-level class TagStateManager
 */
typedef TagStateManager TagStateManager_localtype;
Define_Module_Class(panda3d._rplight, TagStateManager, TagStateManager_localtype, TagStateManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TagStateManager = &Dtool_TagStateManager;
static void Dtool_PyModuleClassInit_TagStateManager(PyObject *module);

/**
 * Forward declarations for top-level class ShadowManager
 */
typedef ShadowManager ShadowManager_localtype;
Define_Module_ClassRef(panda3d._rplight, ShadowManager, ShadowManager_localtype, ShadowManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShadowManager = &Dtool_ShadowManager;
static void Dtool_PyModuleClassInit_ShadowManager(PyObject *module);

/**
 * Forward declarations for top-level class InternalLightManager
 */
typedef InternalLightManager InternalLightManager_localtype;
Define_Module_Class(panda3d._rplight, InternalLightManager, InternalLightManager_localtype, InternalLightManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_InternalLightManager = &Dtool_InternalLightManager;
static void Dtool_PyModuleClassInit_InternalLightManager(PyObject *module);

/**
 * Forward declarations for top-level class RPPointLight
 */
typedef RPPointLight RPPointLight_localtype;
Define_Module_ClassRef(panda3d._rplight, RPPointLight, RPPointLight_localtype, RPPointLight);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RPPointLight = &Dtool_RPPointLight;
static void Dtool_PyModuleClassInit_RPPointLight(PyObject *module);

/**
 * Forward declarations for top-level class PSSMCameraRig
 */
typedef PSSMCameraRig PSSMCameraRig_localtype;
Define_Module_Class(panda3d._rplight, PSSMCameraRig, PSSMCameraRig_localtype, PSSMCameraRig);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PSSMCameraRig = &Dtool_PSSMCameraRig;
static void Dtool_PyModuleClassInit_PSSMCameraRig(PyObject *module);

/**
 * Forward declarations for top-level class RPSpotLight
 */
typedef RPSpotLight RPSpotLight_localtype;
Define_Module_ClassRef(panda3d._rplight, RPSpotLight, RPSpotLight_localtype, RPSpotLight);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RPSpotLight = &Dtool_RPSpotLight;
static void Dtool_PyModuleClassInit_RPSpotLight(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"GPUCommand", &Dtool_GPUCommand},
  {"GPUCommandList", &Dtool_GPUCommandList},
  {"IESDataset", &Dtool_IESDataset},
  {"RPLight", &Dtool_RPLight},
  {"ShadowAtlas", &Dtool_ShadowAtlas},
  {"TagStateManager", &Dtool_TagStateManager},
  {"ShadowManager", &Dtool_ShadowManager},
  {"InternalLightManager", &Dtool_InternalLightManager},
  {"RPPointLight", &Dtool_RPPointLight},
  {"PSSMCameraRig", &Dtool_PSSMCameraRig},
  {"RPSpotLight", &Dtool_RPSpotLight},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[1].type)
  {"PointerToArray< unsigned char >", nullptr},
#define Dtool_Ptr_PointerToArray_unsigned_char (imports[2].type)
  {"LVecBase3f", nullptr},
#define Dtool_Ptr_LVecBase3f (imports[3].type)
  {"LVecBase3i", nullptr},
#define Dtool_Ptr_LVecBase3i (imports[4].type)
  {"LPoint3f", nullptr},
#define Dtool_Ptr_LPoint3f (imports[5].type)
  {"LVecBase4f", nullptr},
#define Dtool_Ptr_LVecBase4f (imports[6].type)
  {"LVecBase4i", nullptr},
#define Dtool_Ptr_LVecBase4i (imports[7].type)
  {"LMatrix3f", nullptr},
#define Dtool_Ptr_LMatrix3f (imports[8].type)
  {"LMatrix4f", nullptr},
#define Dtool_Ptr_LMatrix4f (imports[9].type)
  {"PointerToArray< float >", nullptr},
#define Dtool_Ptr_PointerToArray_float (imports[10].type)
  {"BitMask< uint32_t, 32 >", nullptr},
#define Dtool_Ptr_BitMask_uint32_t_32 (imports[11].type)
  {"Texture", nullptr},
#define Dtool_Ptr_Texture (imports[12].type)
  {"PointerToArray< UnalignedLMatrix4f >", nullptr},
#define Dtool_Ptr_PointerToArray_UnalignedLMatrix4f (imports[13].type)
  {"PointerToArray< LVecBase2f >", nullptr},
#define Dtool_Ptr_PointerToArray_LVecBase2f (imports[14].type)
  {"Shader", nullptr},
#define Dtool_Ptr_Shader (imports[15].type)
  {"NodePath", nullptr},
#define Dtool_Ptr_NodePath (imports[16].type)
  {"Camera", nullptr},
#define Dtool_Ptr_Camera (imports[17].type)
  {"GraphicsOutput", nullptr},
#define Dtool_Ptr_GraphicsOutput (imports[18].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// PointerToArray< unsigned char >
#ifndef LINK_ALL_STATIC
inline static PointerToArray< unsigned char > *Dtool_Coerce_PointerToArray_unsigned_char(PyObject *args, PointerToArray< unsigned char > &coerced) {
  nassertr(Dtool_Ptr_PointerToArray_unsigned_char != nullptr, nullptr);
  nassertr(Dtool_Ptr_PointerToArray_unsigned_char->_Dtool_Coerce != nullptr, nullptr);
  return ((PointerToArray< unsigned char > *(*)(PyObject *, PointerToArray< unsigned char > &))Dtool_Ptr_PointerToArray_unsigned_char->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_PointerToArray_unsigned_char;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_unsigned_char = &Dtool_PointerToArray_unsigned_char;
extern PointerToArray< unsigned char > *Dtool_Coerce_PointerToArray_unsigned_char(PyObject *args, PointerToArray< unsigned char > &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LVecBase3i
#ifndef LINK_ALL_STATIC
inline static LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced) {
  nassertr(Dtool_Ptr_LVecBase3i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3i *(*)(PyObject *, LVecBase3i &))Dtool_Ptr_LVecBase3i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3i = &Dtool_LVecBase3i;
extern LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LVecBase4i
#ifndef LINK_ALL_STATIC
inline static LVecBase4i *Dtool_Coerce_LVecBase4i(PyObject *args, LVecBase4i &coerced) {
  nassertr(Dtool_Ptr_LVecBase4i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4i *(*)(PyObject *, LVecBase4i &))Dtool_Ptr_LVecBase4i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4i = &Dtool_LVecBase4i;
extern LVecBase4i *Dtool_Coerce_LVecBase4i(PyObject *args, LVecBase4i &coerced);
#endif
// LMatrix3f
#ifndef LINK_ALL_STATIC
inline static LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced) {
  nassertr(Dtool_Ptr_LMatrix3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix3f *(*)(PyObject *, LMatrix3f &))Dtool_Ptr_LMatrix3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3f = &Dtool_LMatrix3f;
extern LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// PointerToArray< float >
#ifndef LINK_ALL_STATIC
inline static PointerToArray< float > *Dtool_Coerce_PointerToArray_float(PyObject *args, PointerToArray< float > &coerced) {
  nassertr(Dtool_Ptr_PointerToArray_float != nullptr, nullptr);
  nassertr(Dtool_Ptr_PointerToArray_float->_Dtool_Coerce != nullptr, nullptr);
  return ((PointerToArray< float > *(*)(PyObject *, PointerToArray< float > &))Dtool_Ptr_PointerToArray_float->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_PointerToArray_float;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_float = &Dtool_PointerToArray_float;
extern PointerToArray< float > *Dtool_Coerce_PointerToArray_float(PyObject *args, PointerToArray< float > &coerced);
#endif
// BitMask< uint32_t, 32 >
#ifndef LINK_ALL_STATIC
inline static BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced) {
  nassertr(Dtool_Ptr_BitMask_uint32_t_32 != nullptr, nullptr);
  nassertr(Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce != nullptr, nullptr);
  return ((BitMask< uint32_t, 32 > *(*)(PyObject *, BitMask< uint32_t, 32 > &))Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_BitMask_uint32_t_32;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint32_t_32 = &Dtool_BitMask_uint32_t_32;
extern BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced);
#endif
// Texture
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Texture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Texture = &Dtool_Texture;
#endif
// PointerToArray< UnalignedLMatrix4f >
#ifndef LINK_ALL_STATIC
inline static PointerToArray< UnalignedLMatrix4f > *Dtool_Coerce_PointerToArray_UnalignedLMatrix4f(PyObject *args, PointerToArray< UnalignedLMatrix4f > &coerced) {
  nassertr(Dtool_Ptr_PointerToArray_UnalignedLMatrix4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_PointerToArray_UnalignedLMatrix4f->_Dtool_Coerce != nullptr, nullptr);
  return ((PointerToArray< UnalignedLMatrix4f > *(*)(PyObject *, PointerToArray< UnalignedLMatrix4f > &))Dtool_Ptr_PointerToArray_UnalignedLMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_PointerToArray_UnalignedLMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_UnalignedLMatrix4f = &Dtool_PointerToArray_UnalignedLMatrix4f;
extern PointerToArray< UnalignedLMatrix4f > *Dtool_Coerce_PointerToArray_UnalignedLMatrix4f(PyObject *args, PointerToArray< UnalignedLMatrix4f > &coerced);
#endif
// PointerToArray< LVecBase2f >
#ifndef LINK_ALL_STATIC
inline static PointerToArray< LVecBase2f > *Dtool_Coerce_PointerToArray_LVecBase2f(PyObject *args, PointerToArray< LVecBase2f > &coerced) {
  nassertr(Dtool_Ptr_PointerToArray_LVecBase2f != nullptr, nullptr);
  nassertr(Dtool_Ptr_PointerToArray_LVecBase2f->_Dtool_Coerce != nullptr, nullptr);
  return ((PointerToArray< LVecBase2f > *(*)(PyObject *, PointerToArray< LVecBase2f > &))Dtool_Ptr_PointerToArray_LVecBase2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_PointerToArray_LVecBase2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_LVecBase2f = &Dtool_PointerToArray_LVecBase2f;
extern PointerToArray< LVecBase2f > *Dtool_Coerce_PointerToArray_LVecBase2f(PyObject *args, PointerToArray< LVecBase2f > &coerced);
#endif
// Shader
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_Shader(PyObject *args, CPT(Shader) &coerced) {
  nassertr(Dtool_Ptr_Shader != nullptr, false);
  nassertr(Dtool_Ptr_Shader->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(Shader) &))Dtool_Ptr_Shader->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_Shader(PyObject *args, PT(Shader) &coerced) {
  nassertr(Dtool_Ptr_Shader != nullptr, false);
  nassertr(Dtool_Ptr_Shader->_Dtool_Coerce != nullptr, false);
  return ((bool (*)(PyObject *, PT(Shader) &))Dtool_Ptr_Shader->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Shader;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Shader = &Dtool_Shader;
extern bool Dtool_ConstCoerce_Shader(PyObject *args, CPT(Shader) &coerced);
extern bool Dtool_Coerce_Shader(PyObject *args, PT(Shader) &coerced);
#endif
// NodePath
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// Camera
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Camera;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Camera = &Dtool_Camera;
#endif
// GraphicsOutput
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsOutput;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsOutput = &Dtool_GraphicsOutput;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class GPUCommand
 */
/**
 * Python function wrapper for:
 * inline void GPUCommand::push_int(int v)
 */
static PyObject *Dtool_GPUCommand_push_int_4(PyObject *self, PyObject *arg) {
  GPUCommand *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommand, (void **)&local_this, "GPUCommand.push_int")) {
    return nullptr;
  }
  // 1-inline void GPUCommand::push_int(int v)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).push_int)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_int(const GPUCommand self, int v)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_push_int_4_comment =
  "C++ Interface:\n"
  "push_int(const GPUCommand self, int v)\n"
  "\n"
  "/**\n"
  " * @brief Appends an integer to the GPUCommand.\n"
  " * @details This adds an integer to the back of the GPUCommand. Depending on the\n"
  " *   setting in convert_int_to_float, this will either just convert the int to a\n"
  " *   float by casting it, or just do a bitwise copy.\n"
  " *\n"
  " * @param v The integer to append.\n"
  " */";
#else
static const char *Dtool_GPUCommand_push_int_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GPUCommand::push_float(float v)
 */
static PyObject *Dtool_GPUCommand_push_float_5(PyObject *self, PyObject *arg) {
  GPUCommand *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommand, (void **)&local_this, "GPUCommand.push_float")) {
    return nullptr;
  }
  // 1-inline void GPUCommand::push_float(float v)
  if (PyNumber_Check(arg)) {
    ((*local_this).push_float)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_float(const GPUCommand self, float v)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_push_float_5_comment =
  "C++ Interface:\n"
  "push_float(const GPUCommand self, float v)\n"
  "\n"
  "/**\n"
  " * @brief Appends a float to the GPUCommand.\n"
  " * @details This adds an integer to the back of the GPUCommand. Its used by all\n"
  " *   other push_xxx methods, and simply stores the value, then increments the write\n"
  " *   pointer. When the amount of floats exceeds the capacity of the GPUCommand,\n"
  " *   an error will be printed, and the method returns without doing anything else.\n"
  " *\n"
  " * @param v The float to append.\n"
  " */";
#else
static const char *Dtool_GPUCommand_push_float_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GPUCommand::push_vec3(LVecBase3 const &v)
 * inline void GPUCommand::push_vec3(LVecBase3i const &v)
 */
static PyObject *Dtool_GPUCommand_push_vec3_6(PyObject *self, PyObject *arg) {
  GPUCommand *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommand, (void **)&local_this, "GPUCommand.push_vec3")) {
    return nullptr;
  }
  {
    // -2 inline void GPUCommand::push_vec3(LVecBase3 const &v)
    LVecBase3 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3f);
    if (arg_this != nullptr) {
      ((*local_this).push_vec3)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void GPUCommand::push_vec3(LVecBase3i const &v)
    LVecBase3i const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3i);
    if (arg_this != nullptr) {
      ((*local_this).push_vec3)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void GPUCommand::push_vec3(LVecBase3 const &v)
    LVecBase3f arg_local;
    LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).push_vec3)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void GPUCommand::push_vec3(LVecBase3i const &v)
    LVecBase3i arg_local;
    LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).push_vec3)(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_vec3(const GPUCommand self, const LVecBase3f v)\n"
      "push_vec3(const GPUCommand self, const LVecBase3i v)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_push_vec3_6_comment =
  "C++ Interface:\n"
  "push_vec3(const GPUCommand self, const LVecBase3f v)\n"
  "push_vec3(const GPUCommand self, const LVecBase3i v)\n"
  "\n"
  "/**\n"
  " * @brief Appends a 3-component floating point vector to the GPUCommand.\n"
  " * @details This appends a 3-component floating point vector to the command.\n"
  " *   It basically just calls push_float() for every component, in the order\n"
  " *   x, y, z, which causes the vector to occupy the space of 3 floats.\n"
  " *\n"
  " * @param v Int-Vector to append.\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Appends a 3-component integer vector to the GPUCommand.\n"
  " * @details This appends a 3-component integer vector to the command.\n"
  " *   It basically just calls push_int() for every component, in the order\n"
  " *   x, y, z, which causes the vector to occupy the space of 3 floats.\n"
  " *\n"
  " * @param v Int-Vector to append.\n"
  " */";
#else
static const char *Dtool_GPUCommand_push_vec3_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GPUCommand::push_vec4(LVecBase4 const &v)
 * inline void GPUCommand::push_vec4(LVecBase4i const &v)
 */
static PyObject *Dtool_GPUCommand_push_vec4_7(PyObject *self, PyObject *arg) {
  GPUCommand *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommand, (void **)&local_this, "GPUCommand.push_vec4")) {
    return nullptr;
  }
  {
    // -2 inline void GPUCommand::push_vec4(LVecBase4 const &v)
    LVecBase4 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase4f);
    if (arg_this != nullptr) {
      ((*local_this).push_vec4)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void GPUCommand::push_vec4(LVecBase4i const &v)
    LVecBase4i const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase4i);
    if (arg_this != nullptr) {
      ((*local_this).push_vec4)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void GPUCommand::push_vec4(LVecBase4 const &v)
    LVecBase4f arg_local;
    LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).push_vec4)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void GPUCommand::push_vec4(LVecBase4i const &v)
    LVecBase4i arg_local;
    LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).push_vec4)(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_vec4(const GPUCommand self, const LVecBase4f v)\n"
      "push_vec4(const GPUCommand self, const LVecBase4i v)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_push_vec4_7_comment =
  "C++ Interface:\n"
  "push_vec4(const GPUCommand self, const LVecBase4f v)\n"
  "push_vec4(const GPUCommand self, const LVecBase4i v)\n"
  "\n"
  "/**\n"
  " * @brief Appends a 4-component floating point vector to the GPUCommand.\n"
  " * @details This appends a 4-component floating point vector to the command.\n"
  " *   It basically just calls push_float() for every component, in the order\n"
  " *   x, y, z, which causes the vector to occupy the space of 3 floats.\n"
  " *\n"
  " * @param v Int-Vector to append.\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Appends a 4-component integer vector to the GPUCommand.\n"
  " * @details This appends a 4-component integer vector to the command.\n"
  " *   It basically just calls push_int() for every component, in the order\n"
  " *   x, y, z, w, which causes the vector to occupy the space of 4 floats.\n"
  " *\n"
  " * @param v Int-Vector to append.\n"
  " */";
#else
static const char *Dtool_GPUCommand_push_vec4_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GPUCommand::push_mat3(LMatrix3 const &v)
 */
static PyObject *Dtool_GPUCommand_push_mat3_8(PyObject *self, PyObject *arg) {
  GPUCommand *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommand, (void **)&local_this, "GPUCommand.push_mat3")) {
    return nullptr;
  }
  // 1-inline void GPUCommand::push_mat3(LMatrix3 const &v)
  LMatrix3f arg_local;
  LMatrix3 const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GPUCommand.push_mat3", "LMatrix3f");
  }
  ((*local_this).push_mat3)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_mat3(const GPUCommand self, const LMatrix3f v)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_push_mat3_8_comment =
  "C++ Interface:\n"
  "push_mat3(const GPUCommand self, const LMatrix3f v)\n"
  "\n"
  "/**\n"
  " * @brief Appends a floating point 3x3 matrix to the GPUCommand.\n"
  " * @details This appends a floating point 3x3 matrix to the GPUCommand, by\n"
  " *   pushing all components in row-order to the command. This occupies a space of\n"
  " *   9 floats.\n"
  " *\n"
  " * @param v Matrix to append\n"
  " */";
#else
static const char *Dtool_GPUCommand_push_mat3_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GPUCommand::push_mat4(LMatrix4 const &v)
 */
static PyObject *Dtool_GPUCommand_push_mat4_9(PyObject *self, PyObject *arg) {
  GPUCommand *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommand, (void **)&local_this, "GPUCommand.push_mat4")) {
    return nullptr;
  }
  // 1-inline void GPUCommand::push_mat4(LMatrix4 const &v)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GPUCommand.push_mat4", "LMatrix4f");
  }
  ((*local_this).push_mat4)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_mat4(const GPUCommand self, const LMatrix4f v)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_push_mat4_9_comment =
  "C++ Interface:\n"
  "push_mat4(const GPUCommand self, const LMatrix4f v)\n"
  "\n"
  "/**\n"
  " * @brief Appends a floating point 4x4 matrix to the GPUCommand.\n"
  " * @details This appends a floating point 4x4 matrix to the GPUCommand, by\n"
  " *   pushing all components in row-order to the command. This occupies a space of\n"
  " *   16 floats.\n"
  " *\n"
  " * @param v Matrix to append\n"
  " */";
#else
static const char *Dtool_GPUCommand_push_mat4_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool GPUCommand::get_uses_integer_packing(void)
 */
static PyObject *Dtool_GPUCommand_get_uses_integer_packing_10(PyObject *, PyObject *) {
  // 1-static inline bool GPUCommand::get_uses_integer_packing(void)
  bool return_value = (GPUCommand::get_uses_integer_packing)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_get_uses_integer_packing_10_comment =
  "C++ Interface:\n"
  "get_uses_integer_packing()\n"
  "\n"
  "/**\n"
  " * @brief Returns whether integers are packed as floats.\n"
  " * @details This returns how integer are packed into the data stream. If the\n"
  " *   returned value is true, then integers are packed using their binary\n"
  " *   representation converted to floating point format. If the returned value\n"
  " *   is false, then integers are packed by simply casting them to float,\n"
  " *   e.g. val = (float)i;\n"
  " * @return The integer representation flag\n"
  " */";
#else
static const char *Dtool_GPUCommand_get_uses_integer_packing_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GPUCommand::write_to(PTA_uchar const &dest, std::size_t command_index)
 */
static PyObject *Dtool_GPUCommand_write_to_11(PyObject *self, PyObject *args, PyObject *kwds) {
  GPUCommand *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommand, (void **)&local_this, "GPUCommand.write_to")) {
    return nullptr;
  }
  // 1-void GPUCommand::write_to(PTA_uchar const &dest, std::size_t command_index)
  PyObject *param1;
  Py_ssize_t param2;
  static const char *keyword_list[] = {"dest", "command_index", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "On:write_to", (char **)keyword_list, &param1, &param2)) {
    PointerToArray< unsigned char > param1_local;
    PTA_uchar const *param1_this = Dtool_Coerce_PointerToArray_unsigned_char(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "GPUCommand.write_to", "PointerToArray");
    }
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
    ((*local_this).write_to)(*param1_this, (std::size_t)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_to(const GPUCommand self, const PointerToArray dest, int command_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_write_to_11_comment =
  "C++ Interface:\n"
  "write_to(const GPUCommand self, const PointerToArray dest, int command_index)\n"
  "\n"
  "/**\n"
  " * @brief Writes the GPU command to a given target.\n"
  " * @details This method writes all the data of the GPU command to a given target.\n"
  " *   The target should be a pointer to memory being big enough to hold the\n"
  " *   data. Presumably #dest will be a handle to texture memory.\n"
  " *   The command_index controls the offset where the data will be written\n"
  " *   to.\n"
  " *\n"
  " * @param dest Handle to the memory to write the command to\n"
  " * @param command_index Offset to write the command to. The command will write\n"
  " *   its data to command_index * GPU_COMMAND_ENTRIES. When writing\n"
  " *   the GPUCommand in a GPUCommandList, the command_index will\n"
  " *   most likely be the index of the command in the list.\n"
  " */";
#else
static const char *Dtool_GPUCommand_write_to_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GPUCommand::write(std::ostream &out) const
 */
static PyObject *Dtool_GPUCommand_write_12(PyObject *self, PyObject *arg) {
  GPUCommand *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GPUCommand)) {
    return nullptr;
  }
  // 1-void GPUCommand::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "GPUCommand.write", false, true);
  if (arg_this != nullptr) {
    ((*(const GPUCommand*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(GPUCommand self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommand_write_12_comment =
  "C++ Interface:\n"
  "write(GPUCommand self, ostream out)\n"
  "\n"
  "/**\n"
  " * @brief Prints out the GPUCommand to the console\n"
  " * @details This method prints the type, size, and data of the GPUCommand to the\n"
  " *   console. This helps for debugging the contents of the GPUCommand. Keep\n"
  " *   in mind that integers might be shown in their binary float representation,\n"
  " *   depending on the setting in the GPUCommand::convert_int_to_float method.\n"
  " */";
#else
static const char *Dtool_GPUCommand_write_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GPUCommand::GPUCommand(GPUCommand const &) = default
 * GPUCommand::GPUCommand(GPUCommand::CommandType command_type)
 */
static int Dtool_Init_GPUCommand(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "GPUCommand() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline GPUCommand::GPUCommand(GPUCommand const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      GPUCommand const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GPUCommand);
      if (param0_this != nullptr) {
        GPUCommand *return_value = new GPUCommand(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GPUCommand, true, false);
      }
    }
  }

  {
    // -2 GPUCommand::GPUCommand(GPUCommand::CommandType command_type)
    int param0;
    static const char *keyword_list[] = {"command_type", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "i:GPUCommand", (char **)keyword_list, &param0)) {
      GPUCommand *return_value = new GPUCommand((GPUCommand::CommandType)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GPUCommand, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline GPUCommand::GPUCommand(GPUCommand const &) = default
  // No coercion possible: GPUCommand::GPUCommand(GPUCommand::CommandType command_type)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GPUCommand(const GPUCommand param0)\n"
      "GPUCommand(int command_type)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GPUCommand(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GPUCommand) {
    printf("GPUCommand ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GPUCommand *local_this = (GPUCommand *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GPUCommand) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GPUCommand(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GPUCommand) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GPUCommandList
 */
/**
 * Python function wrapper for:
 * void GPUCommandList::add_command(GPUCommand const &cmd)
 */
static PyObject *Dtool_GPUCommandList_add_command_16(PyObject *self, PyObject *arg) {
  GPUCommandList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommandList, (void **)&local_this, "GPUCommandList.add_command")) {
    return nullptr;
  }
  // 1-void GPUCommandList::add_command(GPUCommand const &cmd)
  GPUCommand const *arg_this = (GPUCommand *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GPUCommand, 1, "GPUCommandList.add_command", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_command)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_command(const GPUCommandList self, const GPUCommand cmd)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommandList_add_command_16_comment =
  "C++ Interface:\n"
  "add_command(const GPUCommandList self, const GPUCommand cmd)\n"
  "\n"
  "/**\n"
  " * @brief Pushes a GPUCommand to the command list.\n"
  " * @details This adds a new GPUCommand to the list of commands to be processed.\n"
  " *\n"
  " * @param cmd The command to add\n"
  " */";
#else
static const char *Dtool_GPUCommandList_add_command_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t GPUCommandList::get_num_commands(void)
 */
static PyObject *Dtool_GPUCommandList_get_num_commands_17(PyObject *self, PyObject *) {
  GPUCommandList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommandList, (void **)&local_this, "GPUCommandList.get_num_commands")) {
    return nullptr;
  }
  // 1-std::size_t GPUCommandList::get_num_commands(void)
  std::size_t return_value = ((*local_this).get_num_commands)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GPUCommandList_get_num_commands_17_comment =
  "C++ Interface:\n"
  "get_num_commands(const GPUCommandList self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the number of commands in this list.\n"
  " * @details This returns the amount of commands which are currently stored in this\n"
  " *   list, and are waiting to get processed.\n"
  " * @return Amount of commands\n"
  " */";
#else
static const char *Dtool_GPUCommandList_get_num_commands_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t GPUCommandList::write_commands_to(PTA_uchar const &dest, std::size_t limit = 32)
 */
static PyObject *Dtool_GPUCommandList_write_commands_to_18(PyObject *self, PyObject *args, PyObject *kwds) {
  GPUCommandList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommandList, (void **)&local_this, "GPUCommandList.write_commands_to")) {
    return nullptr;
  }
  // 1-std::size_t GPUCommandList::write_commands_to(PTA_uchar const &dest, std::size_t limit = 32)
  PyObject *param1;
  Py_ssize_t param2 = 32;
  static const char *keyword_list[] = {"dest", "limit", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|n:write_commands_to", (char **)keyword_list, &param1, &param2)) {
    PointerToArray< unsigned char > param1_local;
    PTA_uchar const *param1_this = Dtool_Coerce_PointerToArray_unsigned_char(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "GPUCommandList.write_commands_to", "PointerToArray");
    }
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
    std::size_t return_value = ((*local_this).write_commands_to)(*param1_this, (std::size_t)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_commands_to(const GPUCommandList self, const PointerToArray dest, int limit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GPUCommandList_write_commands_to_18_comment =
  "C++ Interface:\n"
  "write_commands_to(const GPUCommandList self, const PointerToArray dest, int limit)\n"
  "\n"
  "/**\n"
  " * @brief Writes the first n-commands to a destination.\n"
  " * @details This takes the first #limit commands, and writes them to the\n"
  " *   destination using GPUCommand::write_to. See GPUCommand::write_to for\n"
  " *   further information about #dest. The limit controls after how much\n"
  " *   commands the processing will be stopped. All commands which got processed\n"
  " *   will get removed from the list.\n"
  " *\n"
  " * @param dest Destination to write to, see GPUCommand::write_to\n"
  " * @param limit Maximum amount of commands to process\n"
  " *\n"
  " * @return Amount of commands processed, between 0 and #limit.\n"
  " */";
#else
static const char *Dtool_GPUCommandList_write_commands_to_18_comment = nullptr;
#endif

static PyObject *Dtool_GPUCommandList_num_commands_Getter(PyObject *self, void *) {
  GPUCommandList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GPUCommandList, (void **)&local_this, "GPUCommandList.num_commands")) {
    return nullptr;
  }

  // 1-std::size_t GPUCommandList::get_num_commands(void)
  std::size_t return_value = ((*local_this).get_num_commands)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * GPUCommandList::GPUCommandList(void)
 * inline GPUCommandList::GPUCommandList(GPUCommandList const &) = default
 */
static int Dtool_Init_GPUCommandList(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("GPUCommandList() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-GPUCommandList::GPUCommandList(void)
      GPUCommandList *return_value = new GPUCommandList();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GPUCommandList, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline GPUCommandList::GPUCommandList(GPUCommandList const &) = default
      GPUCommandList const *arg_this = (GPUCommandList *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GPUCommandList, 0, "GPUCommandList.GPUCommandList", true, true);
      if (arg_this != nullptr) {
        GPUCommandList *return_value = new GPUCommandList(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GPUCommandList, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GPUCommandList() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GPUCommandList()\n"
      "GPUCommandList(const GPUCommandList param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GPUCommandList(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GPUCommandList) {
    printf("GPUCommandList ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GPUCommandList *local_this = (GPUCommandList *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GPUCommandList) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GPUCommandList(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GPUCommandList) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class IESDataset
 */
/**
 * Python function wrapper for:
 * void IESDataset::set_vertical_angles(PTA_float const &vertical_angles)
 */
static PyObject *Dtool_IESDataset_set_vertical_angles_25(PyObject *self, PyObject *arg) {
  IESDataset *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IESDataset, (void **)&local_this, "IESDataset.set_vertical_angles")) {
    return nullptr;
  }
  // 1-void IESDataset::set_vertical_angles(PTA_float const &vertical_angles)
  PointerToArray< float > arg_local;
  PTA_float const *arg_this = Dtool_Coerce_PointerToArray_float(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "IESDataset.set_vertical_angles", "PointerToArray");
  }
  ((*local_this).set_vertical_angles)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vertical_angles(const IESDataset self, const PointerToArray vertical_angles)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_IESDataset_set_vertical_angles_25_comment =
  "C++ Interface:\n"
  "set_vertical_angles(const IESDataset self, const PointerToArray vertical_angles)\n"
  "\n"
  "/**\n"
  " * @brief Sets the vertical angles of the dataset.\n"
  " * @details This sets the list of vertical angles of the dataset.\n"
  " *\n"
  " * @param vertical_angles Vector of all vertical angles.\n"
  " */";
#else
static const char *Dtool_IESDataset_set_vertical_angles_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void IESDataset::set_horizontal_angles(PTA_float const &horizontal_angles)
 */
static PyObject *Dtool_IESDataset_set_horizontal_angles_26(PyObject *self, PyObject *arg) {
  IESDataset *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IESDataset, (void **)&local_this, "IESDataset.set_horizontal_angles")) {
    return nullptr;
  }
  // 1-void IESDataset::set_horizontal_angles(PTA_float const &horizontal_angles)
  PointerToArray< float > arg_local;
  PTA_float const *arg_this = Dtool_Coerce_PointerToArray_float(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "IESDataset.set_horizontal_angles", "PointerToArray");
  }
  ((*local_this).set_horizontal_angles)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_horizontal_angles(const IESDataset self, const PointerToArray horizontal_angles)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_IESDataset_set_horizontal_angles_26_comment =
  "C++ Interface:\n"
  "set_horizontal_angles(const IESDataset self, const PointerToArray horizontal_angles)\n"
  "\n"
  "/**\n"
  " * @brief Sets the horizontal angles of the dataset.\n"
  " * @details This sets the list of horizontal angles of the dataset.\n"
  " *\n"
  " * @param horizontal_angles Vector of all horizontal angles.\n"
  " */";
#else
static const char *Dtool_IESDataset_set_horizontal_angles_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void IESDataset::set_candela_values(PTA_float const &candela_values)
 */
static PyObject *Dtool_IESDataset_set_candela_values_27(PyObject *self, PyObject *arg) {
  IESDataset *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IESDataset, (void **)&local_this, "IESDataset.set_candela_values")) {
    return nullptr;
  }
  // 1-void IESDataset::set_candela_values(PTA_float const &candela_values)
  PointerToArray< float > arg_local;
  PTA_float const *arg_this = Dtool_Coerce_PointerToArray_float(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "IESDataset.set_candela_values", "PointerToArray");
  }
  ((*local_this).set_candela_values)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_candela_values(const IESDataset self, const PointerToArray candela_values)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_IESDataset_set_candela_values_27_comment =
  "C++ Interface:\n"
  "set_candela_values(const IESDataset self, const PointerToArray candela_values)\n"
  "\n"
  "/**\n"
  " * @brief Sets the candela values.\n"
  " * @details This sets the candela values of the dataset. They should be an\n"
  " *   interleaved 2D array with the dimensions vertical_angles x horizontal_angles.\n"
  " *   They also should be normalized by dividing by the maximum entry.\n"
  " * @param candela_values Interleaved 2D-vector of candela values.\n"
  " */";
#else
static const char *Dtool_IESDataset_set_candela_values_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void IESDataset::generate_dataset_texture_into(Texture *dest_tex, std::size_t z) const
 */
static PyObject *Dtool_IESDataset_generate_dataset_texture_into_28(PyObject *self, PyObject *args, PyObject *kwds) {
  IESDataset *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_IESDataset)) {
    return nullptr;
  }
  // 1-void IESDataset::generate_dataset_texture_into(Texture *dest_tex, std::size_t z) const
  PyObject *param1;
  Py_ssize_t param2;
  static const char *keyword_list[] = {"dest_tex", "z", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "On:generate_dataset_texture_into", (char **)keyword_list, &param1, &param2)) {
    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "IESDataset.generate_dataset_texture_into", false, true);
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
    if (param1_this != nullptr) {
      ((*(const IESDataset*)local_this).generate_dataset_texture_into)(param1_this, (std::size_t)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "generate_dataset_texture_into(IESDataset self, Texture dest_tex, int z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_IESDataset_generate_dataset_texture_into_28_comment =
  "C++ Interface:\n"
  "generate_dataset_texture_into(IESDataset self, Texture dest_tex, int z)\n"
  "\n"
  "/**\n"
  " * @brief Generates the IES LUT\n"
  " * @details This generates the LUT into a given dataset texture. The x-axis\n"
  " *   referes to the vertical_angle, whereas the y-axis refers to the\n"
  " *   horizontal angle.\n"
  " *\n"
  " * @param dest_tex Texture to write the LUT into\n"
  " * @param z Layer to write the LUT into, in case the texture is a 3D Texture or\n"
  " *   2D Texture Array.\n"
  " */";
#else
static const char *Dtool_IESDataset_generate_dataset_texture_into_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * IESDataset::IESDataset(void)
 * inline IESDataset::IESDataset(IESDataset const &) = default
 */
static int Dtool_Init_IESDataset(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("IESDataset() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-IESDataset::IESDataset(void)
      IESDataset *return_value = new IESDataset();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IESDataset, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline IESDataset::IESDataset(IESDataset const &) = default
      IESDataset const *arg_this = (IESDataset *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_IESDataset, 0, "IESDataset.IESDataset", true, true);
      if (arg_this != nullptr) {
        IESDataset *return_value = new IESDataset(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IESDataset, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "IESDataset() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "IESDataset()\n"
      "IESDataset(const IESDataset param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_IESDataset(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_IESDataset) {
    printf("IESDataset ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  IESDataset *local_this = (IESDataset *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_IESDataset) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_IESDataset(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_IESDataset) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RPLight
 */
/**
 * Python function wrapper for:
 * inline void RPLight::invalidate_shadows(void)
 */
static PyObject *Dtool_RPLight_invalidate_shadows_33(PyObject *self, PyObject *) {
  RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.invalidate_shadows")) {
    return nullptr;
  }
  // 1-inline void RPLight::invalidate_shadows(void)
  ((*local_this).invalidate_shadows)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RPLight_invalidate_shadows_33_comment =
  "C++ Interface:\n"
  "invalidate_shadows(const RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Invalidates the shadows\n"
  " * @details This invalidates all shadows of the light, causing them to get\n"
  " *   regenerated. This might be the case  when the lights position or similar\n"
  " *   changed. This will cause all shadow sources to be updated, emitting a\n"
  " *   shadow update. Be careful when calling this method if you don't want all\n"
  " *   sources to get updated. If you only have to invalidate a single shadow source,\n"
  " *   use get_shadow_source(n)->set_needs_update(true).\n"
  " */";
#else
static const char *Dtool_RPLight_invalidate_shadows_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RPLight::set_pos(LVecBase3 const &pos)
 * inline void RPLight::set_pos(float x, float y, float z)
 */
static PyObject *Dtool_RPLight_set_pos_34(PyObject *self, PyObject *args, PyObject *kwds) {
  RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.set_pos")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-inline void RPLight::set_pos(LVecBase3 const &pos)
        LVecBase3f arg_local;
        LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "RPLight.set_pos", "LVecBase3f");
        }
        ((*local_this).set_pos)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void RPLight::set_pos(float x, float y, float z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_pos", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_pos)((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_pos() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos(const RPLight self, const LVecBase3f pos)\n"
      "set_pos(const RPLight self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RPLight_set_pos_34_comment =
  "C++ Interface:\n"
  "set_pos(const RPLight self, const LVecBase3f pos)\n"
  "set_pos(const RPLight self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * @brief Sets the position of the light\n"
  " * @details This sets the position of the light in world space. It will cause\n"
  " *   the light to get invalidated, and resubmitted to the GPU.\n"
  " *\n"
  " * @param pos Position in world space\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Sets the position of the light\n"
  " * @details @copydetails RPLight::set_pos(const LVecBase3 &pos)\n"
  " *\n"
  " * @param x X-component of the position\n"
  " * @param y Y-component of the position\n"
  " * @param z Z-component of the position\n"
  " */";
#else
static const char *Dtool_RPLight_set_pos_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 const &RPLight::get_pos(void) const
 */
static PyObject *Dtool_RPLight_get_pos_35(PyObject *self, PyObject *) {
  RPLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RPLight)) {
    return nullptr;
  }
  // 1-inline LVecBase3 const &RPLight::get_pos(void) const
  LVecBase3 const *return_value = &(((*(const RPLight*)local_this).get_pos)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_get_pos_35_comment =
  "C++ Interface:\n"
  "get_pos(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the position of the light\n"
  " * @details This returns the position of the light previously set with\n"
  " *   RPLight::set_pos(). The returned position is in world space.\n"
  " * @return Light-position\n"
  " */";
#else
static const char *Dtool_RPLight_get_pos_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RPLight::set_color(LVecBase3 const &color)
 * inline void RPLight::set_color(float r, float g, float b)
 */
static PyObject *Dtool_RPLight_set_color_40(PyObject *self, PyObject *args, PyObject *kwds) {
  RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.set_color")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "color")) {
        // 1-inline void RPLight::set_color(LVecBase3 const &color)
        LVecBase3f arg_local;
        LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "RPLight.set_color", "LVecBase3f");
        }
        ((*local_this).set_color)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void RPLight::set_color(float r, float g, float b)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"r", "g", "b", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_color", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_color)((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_color() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const RPLight self, const LVecBase3f color)\n"
      "set_color(const RPLight self, float r, float g, float b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RPLight_set_color_40_comment =
  "C++ Interface:\n"
  "set_color(const RPLight self, const LVecBase3f color)\n"
  "set_color(const RPLight self, float r, float g, float b)\n"
  "\n"
  "/**\n"
  " * @brief Sets the lights color\n"
  " * @details This sets the lights color. The color should not include the brightness\n"
  " *   of the light, you should control that with the energy. The color specifies\n"
  " *   the lights \"tint\" and will get multiplied with its specular and diffuse\n"
  " *   contribution.\n"
  " *\n"
  " *   The color will be normalized by dividing by the colors luminance. Setting\n"
  " *   higher values than 1.0 will have no effect.\n"
  " *\n"
  " * @param color Light color\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Sets the lights color\n"
  " * @details @copydetails RPLight::set_color(const LVecBase3 &color)\n"
  " *\n"
  " * @param r Red-component of the color\n"
  " * @param g Green-component of the color\n"
  " * @param b Blue-component of the color\n"
  " */";
#else
static const char *Dtool_RPLight_set_color_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 const &RPLight::get_color(void) const
 */
static PyObject *Dtool_RPLight_get_color_41(PyObject *self, PyObject *) {
  RPLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RPLight)) {
    return nullptr;
  }
  // 1-inline LVecBase3 const &RPLight::get_color(void) const
  LVecBase3 const *return_value = &(((*(const RPLight*)local_this).get_color)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_get_color_41_comment =
  "C++ Interface:\n"
  "get_color(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the lights color\n"
  " * @details This returns the light color, previously set with RPLight::set_color.\n"
  " *   This does not include the energy of the light. It might differ from what\n"
  " *   was set with set_color, because the color is normalized by dividing it\n"
  " *   by its luminance.\n"
  " * @return Light-color\n"
  " */";
#else
static const char *Dtool_RPLight_get_color_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void RPLight::set_color_from_temperature(float temperature)
 */
static PyObject *Dtool_RPLight_set_color_from_temperature_43(PyObject *self, PyObject *arg) {
  RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.set_color_from_temperature")) {
    return nullptr;
  }
  // 1-void RPLight::set_color_from_temperature(float temperature)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_color_from_temperature)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color_from_temperature(const RPLight self, float temperature)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RPLight_set_color_from_temperature_43_comment =
  "C++ Interface:\n"
  "set_color_from_temperature(const RPLight self, float temperature)\n"
  "\n"
  "/**\n"
  " * @brief Sets the lights color from a given color temperature\n"
  " * @details This sets the lights color, given a temperature. This is more\n"
  " *   physically based than setting a user defined color. The color will be\n"
  " *   computed from the given temperature.\n"
  " *\n"
  " * @param temperature Light temperature\n"
  " */";
#else
static const char *Dtool_RPLight_set_color_from_temperature_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RPLight::set_energy(float energy)
 */
static PyObject *Dtool_RPLight_set_energy_44(PyObject *self, PyObject *arg) {
  RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.set_energy")) {
    return nullptr;
  }
  // 1-inline void RPLight::set_energy(float energy)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_energy)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_energy(const RPLight self, float energy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RPLight_set_energy_44_comment =
  "C++ Interface:\n"
  "set_energy(const RPLight self, float energy)\n"
  "\n"
  "/**\n"
  " * @brief Sets the energy of the light\n"
  " * @details This sets the energy of the light, which can be seen as the brightness\n"
  " *   of the light. It will get multiplied with the normalized color.\n"
  " *\n"
  " * @param energy energy of the light\n"
  " */";
#else
static const char *Dtool_RPLight_set_energy_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float RPLight::get_energy(void) const
 */
static PyObject *Dtool_RPLight_get_energy_45(PyObject *self, PyObject *) {
  RPLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RPLight)) {
    return nullptr;
  }
  // 1-inline float RPLight::get_energy(void) const
  float return_value = ((*(const RPLight*)local_this).get_energy)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_get_energy_45_comment =
  "C++ Interface:\n"
  "get_energy(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the energy of the light\n"
  " * @details This returns the energy of the light, previously set with\n"
  " *   RPLight::set_energy.\n"
  " *\n"
  " * @return energy of the light\n"
  " */";
#else
static const char *Dtool_RPLight_get_energy_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline RPLight::LightType RPLight::get_light_type(void) const
 */
static PyObject *Dtool_RPLight_get_light_type_48(PyObject *self, PyObject *) {
  RPLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RPLight)) {
    return nullptr;
  }
  // 1-inline RPLight::LightType RPLight::get_light_type(void) const
  RPLight::LightType return_value = ((*(const RPLight*)local_this).get_light_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_get_light_type_48_comment =
  "C++ Interface:\n"
  "get_light_type(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the type of the light\n"
  " * @details This returns the internal type of the light, which was specified\n"
  " *   in the lights constructor. This can be used to distinguish between light\n"
  " *   types.\n"
  " * @return Type of the light\n"
  " */";
#else
static const char *Dtool_RPLight_get_light_type_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RPLight::set_casts_shadows(bool flag = true)
 */
static PyObject *Dtool_RPLight_set_casts_shadows_50(PyObject *self, PyObject *args, PyObject *kwds) {
  RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.set_casts_shadows")) {
    return nullptr;
  }
  // 1-inline void RPLight::set_casts_shadows(bool flag = true)
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "flag")) {
    ((*local_this).set_casts_shadows)((PyObject_IsTrue(param1) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_casts_shadows(const RPLight self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RPLight_set_casts_shadows_50_comment =
  "C++ Interface:\n"
  "set_casts_shadows(const RPLight self, bool flag)\n"
  "\n"
  "/**\n"
  " * @brief Controls whether the light casts shadows\n"
  " * @details This sets whether the light casts shadows. You can not change this\n"
  " *   while the light is attached. When flag is set to true, the light will be\n"
  " *   setup to cast shadows, spawning shadow sources based on the lights type.\n"
  " *   If the flag is set to false, the light will be inddicated to cast no shadows.\n"
  " *\n"
  " * @param flag Whether the light casts shadows\n"
  " */";
#else
static const char *Dtool_RPLight_set_casts_shadows_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RPLight::get_casts_shadows(void) const
 */
static PyObject *Dtool_RPLight_get_casts_shadows_51(PyObject *self, PyObject *) {
  RPLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RPLight)) {
    return nullptr;
  }
  // 1-inline bool RPLight::get_casts_shadows(void) const
  bool return_value = ((*(const RPLight*)local_this).get_casts_shadows)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_get_casts_shadows_51_comment =
  "C++ Interface:\n"
  "get_casts_shadows(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns whether the light casts shadows\n"
  " * @details This returns whether the light casts shadows, the returned value\n"
  " *   is the one previously set with RPLight::set_casts_shadows.\n"
  " *\n"
  " * @return true if the light casts shadows, false otherwise\n"
  " */";
#else
static const char *Dtool_RPLight_get_casts_shadows_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RPLight::set_shadow_map_resolution(std::size_t resolution)
 */
static PyObject *Dtool_RPLight_set_shadow_map_resolution_54(PyObject *self, PyObject *arg) {
  RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.set_shadow_map_resolution")) {
    return nullptr;
  }
  // 1-inline void RPLight::set_shadow_map_resolution(std::size_t resolution)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).set_shadow_map_resolution)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_map_resolution(const RPLight self, int resolution)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RPLight_set_shadow_map_resolution_54_comment =
  "C++ Interface:\n"
  "set_shadow_map_resolution(const RPLight self, int resolution)\n"
  "\n"
  "/**\n"
  " * @brief Sets the lights shadow map resolution\n"
  " * @details This sets the lights shadow map resolution. This has no effect\n"
  " *   when the light is not told to cast shadows (Use RPLight::set_casts_shadows).\n"
  " *\n"
  " *   When calling this on a light with multiple shadow sources (e.g. PointLight),\n"
  " *   this controls the resolution of each source. If the light has 6 shadow sources,\n"
  " *   and you use a resolution of 512x512, the lights shadow map will occur a\n"
  " *   space of 6 * 512x512 maps in the shadow atlas.\n"
  " *\n"
  " * @param resolution Resolution of the shadow map in pixels\n"
  " */";
#else
static const char *Dtool_RPLight_set_shadow_map_resolution_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t RPLight::get_shadow_map_resolution(void) const
 */
static PyObject *Dtool_RPLight_get_shadow_map_resolution_55(PyObject *self, PyObject *) {
  RPLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RPLight)) {
    return nullptr;
  }
  // 1-inline std::size_t RPLight::get_shadow_map_resolution(void) const
  std::size_t return_value = ((*(const RPLight*)local_this).get_shadow_map_resolution)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_get_shadow_map_resolution_55_comment =
  "C++ Interface:\n"
  "get_shadow_map_resolution(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the shadow map resolution\n"
  " * @details This returns the shadow map resolution of each source of the light.\n"
  " *   If the light is not setup to cast shadows, this value is meaningless.\n"
  " *   The returned value is the one previously set with RPLight::set_shadow_map_resolution.\n"
  " *\n"
  " * @return Shadow map resolution in pixels\n"
  " */";
#else
static const char *Dtool_RPLight_get_shadow_map_resolution_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RPLight::set_ies_profile(int profile)
 */
static PyObject *Dtool_RPLight_set_ies_profile_57(PyObject *self, PyObject *arg) {
  RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.set_ies_profile")) {
    return nullptr;
  }
  // 1-inline void RPLight::set_ies_profile(int profile)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_ies_profile)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ies_profile(const RPLight self, int profile)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RPLight_set_ies_profile_57_comment =
  "C++ Interface:\n"
  "set_ies_profile(const RPLight self, int profile)\n"
  "\n"
  "/**\n"
  " * @brief Sets the ies profile\n"
  " * @details This sets the ies profile of the light. The parameter should be a\n"
  " *   handle previously returned by RenderPipeline.load_ies_profile. Using a\n"
  " *   value of -1 indicates no ies profile.\n"
  " *\n"
  " *   Notice that for ies profiles which cover a whole range, you should use\n"
  " *   PointLights, whereas for ies profiles which only cover the lower hemisphere\n"
  " *   you should use SpotLights for the best performance.\n"
  " *\n"
  " * @param profile IES Profile handle\n"
  " */";
#else
static const char *Dtool_RPLight_set_ies_profile_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int RPLight::get_ies_profile(void) const
 */
static PyObject *Dtool_RPLight_get_ies_profile_58(PyObject *self, PyObject *) {
  RPLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RPLight)) {
    return nullptr;
  }
  // 1-inline int RPLight::get_ies_profile(void) const
  int return_value = ((*(const RPLight*)local_this).get_ies_profile)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_get_ies_profile_58_comment =
  "C++ Interface:\n"
  "get_ies_profile(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the lights ies profile\n"
  " * @details This returns the ies profile of a light, previously set with\n"
  " *   RPLight::set_ies_profile. In case no ies profile was set, returns -1.\n"
  " *\n"
  " * @return IES Profile handle\n"
  " */";
#else
static const char *Dtool_RPLight_get_ies_profile_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool RPLight::has_ies_profile(void) const
 */
static PyObject *Dtool_RPLight_has_ies_profile_59(PyObject *self, PyObject *) {
  RPLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RPLight)) {
    return nullptr;
  }
  // 1-inline bool RPLight::has_ies_profile(void) const
  bool return_value = ((*(const RPLight*)local_this).has_ies_profile)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_has_ies_profile_59_comment =
  "C++ Interface:\n"
  "has_ies_profile(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns whether the light has an ies profile assigned\n"
  " * @details This returns whether the light has an ies profile assigned,\n"
  " *   previously done with RPLight::set_ies_profile.\n"
  " *\n"
  " * @return true if the light has an ies profile assigned, false otherwise\n"
  " */";
#else
static const char *Dtool_RPLight_has_ies_profile_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RPLight::clear_ies_profile(void)
 */
static PyObject *Dtool_RPLight_clear_ies_profile_60(PyObject *self, PyObject *) {
  RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.clear_ies_profile")) {
    return nullptr;
  }
  // 1-inline void RPLight::clear_ies_profile(void)
  ((*local_this).clear_ies_profile)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_RPLight_clear_ies_profile_60_comment =
  "C++ Interface:\n"
  "clear_ies_profile(const RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Clears the ies profile\n"
  " * @details This clears the ies profile of the light, telling it to no longer\n"
  " *   use an ies profile, and instead use the default attenuation.\n"
  " */";
#else
static const char *Dtool_RPLight_clear_ies_profile_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RPLight::set_near_plane(float near_plane)
 */
static PyObject *Dtool_RPLight_set_near_plane_63(PyObject *self, PyObject *arg) {
  RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.set_near_plane")) {
    return nullptr;
  }
  // 1-inline void RPLight::set_near_plane(float near_plane)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_near_plane)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_near_plane(const RPLight self, float near_plane)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RPLight_set_near_plane_63_comment =
  "C++ Interface:\n"
  "set_near_plane(const RPLight self, float near_plane)\n"
  "\n"
  "/**\n"
  " * @brief Sets the near plane of the light\n"
  " * @details This sets the near plane of all shadow sources of the light. It has\n"
  " *   no effects if the light does not cast shadows. This prevents artifacts from\n"
  " *   objects near to the light. It behaves like Lens::set_near_plane.\n"
  " *\n"
  " *   It can also help increasing shadow map precision, low near planes will\n"
  " *   cause the precision to suffer. Try setting the near plane as big as possible.\n"
  " *\n"
  " *   If a negative or zero near plane is passed, an assertion is thrown.\n"
  " *\n"
  " * @param near_plane Near-plane\n"
  " */";
#else
static const char *Dtool_RPLight_set_near_plane_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float RPLight::get_near_plane(void) const
 */
static PyObject *Dtool_RPLight_get_near_plane_64(PyObject *self, PyObject *) {
  RPLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RPLight)) {
    return nullptr;
  }
  // 1-inline float RPLight::get_near_plane(void) const
  float return_value = ((*(const RPLight*)local_this).get_near_plane)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPLight_get_near_plane_64_comment =
  "C++ Interface:\n"
  "get_near_plane(RPLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the near plane of the light\n"
  " * @details This returns the lights near plane, previously set with\n"
  " *   RPLight::set_near_plane. If the light does not cast shadows, this value\n"
  " *   is meaningless.\n"
  " *\n"
  " * @return Near-plane\n"
  " */";
#else
static const char *Dtool_RPLight_get_near_plane_64_comment = nullptr;
#endif

static PyObject *Dtool_RPLight_pos_Getter(PyObject *self, void *) {
  const RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase3 const &RPLight::get_pos(void) const
  LVecBase3 const *return_value = &(((*(const RPLight*)local_this).get_pos)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

static int Dtool_RPLight_pos_Setter(PyObject *self, PyObject *arg, void *) {
  RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.pos")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete pos attribute");
    return -1;
  }
  // 1-inline void RPLight::set_pos(LVecBase3 const &pos)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "RPLight.set_pos", "LVecBase3f");
    return -1;
  }
  ((*local_this).set_pos)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_pos(const RPLight self, const LVecBase3f pos)\n");
  }
  return -1;
}

static PyObject *Dtool_RPLight_color_Getter(PyObject *self, void *) {
  const RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase3 const &RPLight::get_color(void) const
  LVecBase3 const *return_value = &(((*(const RPLight*)local_this).get_color)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

static int Dtool_RPLight_color_Setter(PyObject *self, PyObject *arg, void *) {
  RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete color attribute");
    return -1;
  }
  // 1-inline void RPLight::set_color(LVecBase3 const &color)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "RPLight.set_color", "LVecBase3f");
    return -1;
  }
  ((*local_this).set_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_color(const RPLight self, const LVecBase3f color)\n");
  }
  return -1;
}

static PyObject *Dtool_RPLight_energy_Getter(PyObject *self, void *) {
  const RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float RPLight::get_energy(void) const
  float return_value = ((*(const RPLight*)local_this).get_energy)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RPLight_energy_Setter(PyObject *self, PyObject *arg, void *) {
  RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.energy")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete energy attribute");
    return -1;
  }
  // 1-inline void RPLight::set_energy(float energy)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_energy)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_energy(const RPLight self, float energy)\n");
  }
  return -1;
}

static PyObject *Dtool_RPLight_light_type_Getter(PyObject *self, void *) {
  const RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline RPLight::LightType RPLight::get_light_type(void) const
  RPLight::LightType return_value = ((*(const RPLight*)local_this).get_light_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_RPLight_casts_shadows_Getter(PyObject *self, void *) {
  const RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool RPLight::get_casts_shadows(void) const
  bool return_value = ((*(const RPLight*)local_this).get_casts_shadows)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RPLight_casts_shadows_Setter(PyObject *self, PyObject *arg, void *) {
  RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.casts_shadows")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete casts_shadows attribute");
    return -1;
  }
  // 1-inline void RPLight::set_casts_shadows(bool flag)
  ((*local_this).set_casts_shadows)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_casts_shadows(const RPLight self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_RPLight_shadow_map_resolution_Getter(PyObject *self, void *) {
  const RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::size_t RPLight::get_shadow_map_resolution(void) const
  std::size_t return_value = ((*(const RPLight*)local_this).get_shadow_map_resolution)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RPLight_shadow_map_resolution_Setter(PyObject *self, PyObject *arg, void *) {
  RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.shadow_map_resolution")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete shadow_map_resolution attribute");
    return -1;
  }
  // 1-inline void RPLight::set_shadow_map_resolution(std::size_t resolution)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return -1;
    }
#endif
    ((*local_this).set_shadow_map_resolution)(arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shadow_map_resolution(const RPLight self, int resolution)\n");
  }
  return -1;
}

static PyObject *Dtool_RPLight_ies_profile_Getter(PyObject *self, void *) {
  const RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_ies_profile()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline int RPLight::get_ies_profile(void) const
  int return_value = ((*(const RPLight*)local_this).get_ies_profile)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RPLight_ies_profile_Setter(PyObject *self, PyObject *arg, void *) {
  RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.ies_profile")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete ies_profile attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_ies_profile();
    return 0;
  }
  // 1-inline void RPLight::set_ies_profile(int profile)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_ies_profile)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_ies_profile(const RPLight self, int profile)\n");
  }
  return -1;
}

static PyObject *Dtool_RPLight_near_plane_Getter(PyObject *self, void *) {
  const RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float RPLight::get_near_plane(void) const
  float return_value = ((*(const RPLight*)local_this).get_near_plane)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RPLight_near_plane_Setter(PyObject *self, PyObject *arg, void *) {
  RPLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPLight, (void **)&local_this, "RPLight.near_plane")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete near_plane attribute");
    return -1;
  }
  // 1-inline void RPLight::set_near_plane(float near_plane)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_near_plane)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_near_plane(const RPLight self, float near_plane)\n");
  }
  return -1;
}

static int Dtool_Init_RPLight(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_RPLight(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RPLight) {
    printf("RPLight ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RPLight *local_this = (RPLight *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RPLight) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RPLight(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RPLight) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RPLight*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ShadowAtlas
 */
/**
 * Python function wrapper for:
 * inline int ShadowAtlas::get_num_used_tiles(void) const
 */
static PyObject *Dtool_ShadowAtlas_get_num_used_tiles_69(PyObject *self, PyObject *) {
  ShadowAtlas *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShadowAtlas)) {
    return nullptr;
  }
  // 1-inline int ShadowAtlas::get_num_used_tiles(void) const
  int return_value = ((*(const ShadowAtlas*)local_this).get_num_used_tiles)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShadowAtlas_get_num_used_tiles_69_comment =
  "C++ Interface:\n"
  "get_num_used_tiles(ShadowAtlas self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the amount of used tiles\n"
  " * @details Returns the amount of used tiles in the atlas\n"
  " * @return Amount of used tiles\n"
  " */";
#else
static const char *Dtool_ShadowAtlas_get_num_used_tiles_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float ShadowAtlas::get_coverage(void) const
 */
static PyObject *Dtool_ShadowAtlas_get_coverage_70(PyObject *self, PyObject *) {
  ShadowAtlas *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShadowAtlas)) {
    return nullptr;
  }
  // 1-inline float ShadowAtlas::get_coverage(void) const
  float return_value = ((*(const ShadowAtlas*)local_this).get_coverage)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShadowAtlas_get_coverage_70_comment =
  "C++ Interface:\n"
  "get_coverage(ShadowAtlas self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the amount of used tiles in percentage\n"
  " * @details This returns in percentage from 0 to 1 how much space of the atlas\n"
  " *   is used right now. A value of 1 means the atlas is completely full, whereas\n"
  " *   a value of 0 means the atlas is completely free.\n"
  " * @return Atlas usage in percentage\n"
  " */";
#else
static const char *Dtool_ShadowAtlas_get_coverage_70_comment = nullptr;
#endif

static PyObject *Dtool_ShadowAtlas_num_used_tiles_Getter(PyObject *self, void *) {
  const ShadowAtlas *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShadowAtlas, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int ShadowAtlas::get_num_used_tiles(void) const
  int return_value = ((*(const ShadowAtlas*)local_this).get_num_used_tiles)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ShadowAtlas_coverage_Getter(PyObject *self, void *) {
  const ShadowAtlas *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShadowAtlas, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float ShadowAtlas::get_coverage(void) const
  float return_value = ((*(const ShadowAtlas*)local_this).get_coverage)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline ShadowAtlas::ShadowAtlas(ShadowAtlas const &) = default
 * ShadowAtlas::ShadowAtlas(std::size_t size, std::size_t tile_size = 32)
 */
static int Dtool_Init_ShadowAtlas(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 ShadowAtlas::ShadowAtlas(std::size_t size, std::size_t tile_size = 32)
    Py_ssize_t param0;
    Py_ssize_t param1 = 32;
    static const char *keyword_list[] = {"size", "tile_size", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "n|n:ShadowAtlas", (char **)keyword_list, &param0, &param1)) {
#ifndef NDEBUG
      if (param0 < 0) {
        PyErr_Format(PyExc_OverflowError,
                     "can't convert negative value %zd to size_t",
                     param0);
        return -1;
      }
#endif
#ifndef NDEBUG
      if (param1 < 0) {
        PyErr_Format(PyExc_OverflowError,
                     "can't convert negative value %zd to size_t",
                     param1);
        return -1;
      }
#endif
      ShadowAtlas *return_value = new ShadowAtlas((std::size_t)param0, (std::size_t)param1);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShadowAtlas, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline ShadowAtlas::ShadowAtlas(ShadowAtlas const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      ShadowAtlas const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_ShadowAtlas);
      if (param0_this != nullptr) {
        ShadowAtlas *return_value = new ShadowAtlas(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShadowAtlas, true, false);
      }
    }
  }

  // No coercion possible: ShadowAtlas::ShadowAtlas(std::size_t size, std::size_t tile_size = 32)
  // No coercion possible: inline ShadowAtlas::ShadowAtlas(ShadowAtlas const &) = default
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ShadowAtlas(int size, int tile_size)\n"
      "ShadowAtlas(const ShadowAtlas param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ShadowAtlas(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ShadowAtlas) {
    printf("ShadowAtlas ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ShadowAtlas *local_this = (ShadowAtlas *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ShadowAtlas) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ShadowAtlas(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ShadowAtlas) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TagStateManager
 */
/**
 * Python function wrapper for:
 * inline void TagStateManager::apply_state(std::string const &state, NodePath np, Shader *shader, std::string const &name, int sort)
 */
static PyObject *Dtool_TagStateManager_apply_state_76(PyObject *self, PyObject *args, PyObject *kwds) {
  TagStateManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TagStateManager, (void **)&local_this, "TagStateManager.apply_state")) {
    return nullptr;
  }
  // 1-inline void TagStateManager::apply_state(std::string const &state, NodePath np, Shader *shader, std::string const &name, int sort)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  PyObject *param3;
  const char *param4_str = nullptr;
  Py_ssize_t param4_len;
  int param5;
  static const char *keyword_list[] = {"state", "np", "shader", "name", "sort", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#OOs#i:apply_state", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3, &param4_str, &param4_len, &param5)) {
    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "TagStateManager.apply_state", true, true);
    PT(Shader) param3_this;
    if (!Dtool_Coerce_Shader(param3, param3_this)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "TagStateManager.apply_state", "Shader");
    }
    if (param2_this != nullptr) {
      ((*local_this).apply_state)(std::string(param1_str, param1_len), *param2_this, std::move(param3_this), std::string(param4_str, param4_len), (int)param5);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_state(const TagStateManager self, str state, NodePath np, Shader shader, str name, int sort)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_apply_state_76_comment =
  "C++ Interface:\n"
  "apply_state(const TagStateManager self, str state, NodePath np, Shader shader, str name, int sort)\n"
  "\n"
  "/**\n"
  " * @brief Applies a given state for a pass to a NodePath\n"
  " * @details This applies a shader to the given NodePath which is used when the\n"
  " *   NodePath is rendered by any registered camera for that pass.\n"
  " *   It also disables color write depending on the pass.\n"
  " *\n"
  " * @param np The nodepath to apply the shader to\n"
  " * @param shader A handle to the shader to apply\n"
  " * @param name Name of the state, should be a unique identifier\n"
  " * @param sort Determines the sort with which the shader will be applied.\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Applies a given state to a NodePath\n"
  " * @details This applies a shader to the given NodePath which is used when the\n"
  " *   NodePath is rendered by any registered camera of the container.\n"
  " *\n"
  " * @param container The container which is used to store the state\n"
  " * @param np The nodepath to apply the shader to\n"
  " * @param shader A handle to the shader to apply\n"
  " * @param name Name of the state, should be a unique identifier\n"
  " * @param sort Changes the sort with which the shader will be applied.\n"
  " */";
#else
static const char *Dtool_TagStateManager_apply_state_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void TagStateManager::cleanup_states(void)
 */
static PyObject *Dtool_TagStateManager_cleanup_states_77(PyObject *self, PyObject *) {
  TagStateManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TagStateManager, (void **)&local_this, "TagStateManager.cleanup_states")) {
    return nullptr;
  }
  // 1-void TagStateManager::cleanup_states(void)
  ((*local_this).cleanup_states)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_cleanup_states_77_comment =
  "C++ Interface:\n"
  "cleanup_states(const TagStateManager self)\n"
  "\n"
  "/**\n"
  " * @brief Cleans up all registered states.\n"
  " * @details This cleans up all states which were registered to the TagStateManager.\n"
  " *   It also calls Camera::clear_tag_states() on the main_cam_node and all attached\n"
  " *   cameras.\n"
  " */";
#else
static const char *Dtool_TagStateManager_cleanup_states_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TagStateManager::register_camera(std::string const &state, Camera *source)
 */
static PyObject *Dtool_TagStateManager_register_camera_78(PyObject *self, PyObject *args, PyObject *kwds) {
  TagStateManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TagStateManager, (void **)&local_this, "TagStateManager.register_camera")) {
    return nullptr;
  }
  // 1-inline void TagStateManager::register_camera(std::string const &state, Camera *source)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"state", "source", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:register_camera", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    Camera *param2_this = (Camera *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Camera, 2, "TagStateManager.register_camera", false, true);
    if (param2_this != nullptr) {
      ((*local_this).register_camera)(std::string(param1_str, param1_len), param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "register_camera(const TagStateManager self, str state, Camera source)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_register_camera_78_comment =
  "C++ Interface:\n"
  "register_camera(const TagStateManager self, str state, Camera source)\n"
  "\n"
  "/**\n"
  " * @brief Registers a new camera which renders a certain pass\n"
  " * @details This registers a new camera which will be used to render the given\n"
  " *   pass. The TagStateManager will keep track of the camera and\n"
  " *   applies all registered states onto the camera with Camera::set_tag_state.\n"
  " *   It also applies the appropriate camera mask to the camera,\n"
  " *   and sets an initial state to disable color write depending on the pass.\n"
  " *\n"
  " * @param source Camera which will be used to render shadows\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Registers a new camera to a given container\n"
  " * @details This registers a new camera to a container, and sets its initial\n"
  " *   state as well as the camera mask.\n"
  " *\n"
  " * @param container The container to add the camera to\n"
  " * @param source The camera to add\n"
  " */";
#else
static const char *Dtool_TagStateManager_register_camera_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TagStateManager::unregister_camera(std::string const &state, Camera *source)
 */
static PyObject *Dtool_TagStateManager_unregister_camera_79(PyObject *self, PyObject *args, PyObject *kwds) {
  TagStateManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TagStateManager, (void **)&local_this, "TagStateManager.unregister_camera")) {
    return nullptr;
  }
  // 1-inline void TagStateManager::unregister_camera(std::string const &state, Camera *source)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"state", "source", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:unregister_camera", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    Camera *param2_this = (Camera *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Camera, 2, "TagStateManager.unregister_camera", false, true);
    if (param2_this != nullptr) {
      ((*local_this).unregister_camera)(std::string(param1_str, param1_len), param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unregister_camera(const TagStateManager self, str state, Camera source)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_unregister_camera_79_comment =
  "C++ Interface:\n"
  "unregister_camera(const TagStateManager self, str state, Camera source)\n"
  "\n"
  "/**\n"
  " * @brief Unregisters a camera from the list of shadow cameras\n"
  " * @details This unregisters a camera from the list of shadows cameras. It also\n"
  " *   resets all tag states of the camera, and also its initial state.\n"
  " *\n"
  " * @param source Camera to unregister\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Unregisters a camera from a container\n"
  " * @details This unregisters a camera from the list of cameras of a given\n"
  " *   container. It also resets all tag states of the camera, and also its initial\n"
  " *   state.\n"
  " *\n"
  " * @param source Camera to unregister\n"
  " */";
#else
static const char *Dtool_TagStateManager_unregister_camera_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask32 TagStateManager::get_mask(std::string const &container_name)
 */
static PyObject *Dtool_TagStateManager_get_mask_80(PyObject *self, PyObject *arg) {
  TagStateManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TagStateManager, (void **)&local_this, "TagStateManager.get_mask")) {
    return nullptr;
  }
  // 1-inline BitMask32 TagStateManager::get_mask(std::string const &container_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    BitMask32 *return_value = new BitMask32(((*local_this).get_mask)(std::string(param1_str, param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_mask(const TagStateManager self, str container_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TagStateManager_get_mask_80_comment =
  "C++ Interface:\n"
  "get_mask(const TagStateManager self, str container_name)\n"
  "\n"
  "/**\n"
  " * @brief Returns the render mask for the given state\n"
  " * @details This returns the mask of a given render pass, which can be used\n"
  " *   to either show or hide objects from this pass.\n"
  " *\n"
  " * @param container_name Name of the render-pass\n"
  " * @return Bit mask of the render pass\n"
  " */";
#else
static const char *Dtool_TagStateManager_get_mask_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TagStateManager::TagStateManager(NodePath main_cam_node)
 * inline TagStateManager::TagStateManager(TagStateManager const &) = default
 */
static int Dtool_Init_TagStateManager(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "TagStateManager() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 TagStateManager::TagStateManager(NodePath main_cam_node)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "main_cam_node")) {
      NodePath *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_NodePath);
      if (param0_this != nullptr) {
        TagStateManager *return_value = new TagStateManager(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TagStateManager, true, false);
      }
    }
  }

  {
    // -2 inline TagStateManager::TagStateManager(TagStateManager const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      TagStateManager const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TagStateManager);
      if (param0_this != nullptr) {
        TagStateManager *return_value = new TagStateManager(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TagStateManager, true, false);
      }
    }
  }

  // No coercion possible: TagStateManager::TagStateManager(NodePath main_cam_node)
  // No coercion possible: inline TagStateManager::TagStateManager(TagStateManager const &) = default
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TagStateManager(NodePath main_cam_node)\n"
      "TagStateManager(const TagStateManager param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TagStateManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TagStateManager) {
    printf("TagStateManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TagStateManager *local_this = (TagStateManager *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TagStateManager) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TagStateManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TagStateManager) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ShadowManager
 */
/**
 * Python function wrapper for:
 * inline void ShadowManager::set_max_updates(std::size_t max_updates)
 */
static PyObject *Dtool_ShadowManager_set_max_updates_83(PyObject *self, PyObject *arg) {
  ShadowManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShadowManager, (void **)&local_this, "ShadowManager.set_max_updates")) {
    return nullptr;
  }
  // 1-inline void ShadowManager::set_max_updates(std::size_t max_updates)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).set_max_updates)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_updates(const ShadowManager self, int max_updates)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_set_max_updates_83_comment =
  "C++ Interface:\n"
  "set_max_updates(const ShadowManager self, int max_updates)\n"
  "\n"
  "/**\n"
  " * @brief Sets the maximum amount of updates per frame.\n"
  " * @details This controls the maximum amount of updated ShadowSources per frame.\n"
  " *   The ShadowManager will take the first <max_updates> ShadowSources, and\n"
  " *   generate shadow maps for them every frame. If there are more ShadowSources\n"
  " *   waiting to get updated than available updates, the sources are sorted by\n"
  " *   priority, and the update of the less important sources is delayed to the\n"
  " *   next frame.\n"
  " *\n"
  " *   If the update count is set too low, and there are a lot of ShadowSources\n"
  " *   waiting to get updated, artifacts will occur, and there might be ShadowSources\n"
  " *   which never get updated, due to low priority.\n"
  " *\n"
  " *   If an update count of 0 is passed, no updates will happen. This also means\n"
  " *   that there are no shadows. This is not recommended.\n"
  " *\n"
  " *   If an update count < 0 is passed, undefined behaviour occurs.\n"
  " *\n"
  " *   This method has to get called before ShadowManager::init, otherwise an\n"
  " *   assertion will get triggered.\n"
  " *\n"
  " * @param max_updates Maximum amoumt of updates\n"
  " */";
#else
static const char *Dtool_ShadowManager_set_max_updates_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ShadowManager::set_scene(NodePath scene_parent)
 */
static PyObject *Dtool_ShadowManager_set_scene_84(PyObject *self, PyObject *arg) {
  ShadowManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShadowManager, (void **)&local_this, "ShadowManager.set_scene")) {
    return nullptr;
  }
  // 1-inline void ShadowManager::set_scene(NodePath scene_parent)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "ShadowManager.set_scene", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_scene)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scene(const ShadowManager self, NodePath scene_parent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_set_scene_84_comment =
  "C++ Interface:\n"
  "set_scene(const ShadowManager self, NodePath scene_parent)\n"
  "\n"
  "/**\n"
  " * @brief Sets the target scene\n"
  " * @details This sets the target scene for rendering shadows. All shadow cameras\n"
  " *   will be parented to this scene to render shadows.\n"
  " *\n"
  " *   Usually the scene will be ShowBase.render. If the scene is an empty or\n"
  " *   invalid NodePath, an assertion will be triggered.\n"
  " *\n"
  " *   This method has to get called before calling ShadowManager::init, or an\n"
  " *   assertion will get triggered.\n"
  " *\n"
  " * @param scene_parent The target scene\n"
  " */";
#else
static const char *Dtool_ShadowManager_set_scene_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ShadowManager::set_tag_state_manager(TagStateManager *tag_mgr)
 */
static PyObject *Dtool_ShadowManager_set_tag_state_manager_85(PyObject *self, PyObject *arg) {
  ShadowManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShadowManager, (void **)&local_this, "ShadowManager.set_tag_state_manager")) {
    return nullptr;
  }
  // 1-inline void ShadowManager::set_tag_state_manager(TagStateManager *tag_mgr)
  TagStateManager *arg_this = (TagStateManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TagStateManager, 1, "ShadowManager.set_tag_state_manager", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_tag_state_manager)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tag_state_manager(const ShadowManager self, TagStateManager tag_mgr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_set_tag_state_manager_85_comment =
  "C++ Interface:\n"
  "set_tag_state_manager(const ShadowManager self, TagStateManager tag_mgr)\n"
  "\n"
  "/**\n"
  " * @brief Sets the handle to the TagStageManager.\n"
  " * @details This sets the handle to the TagStateManager used by the pipeline.\n"
  " *   Usually this is RenderPipeline.get_tag_mgr().\n"
  " *\n"
  " *   This has to get called before ShadowManager::init, otherwise an assertion\n"
  " *   will get triggered.\n"
  " *\n"
  " * @param tag_mgr [description]\n"
  " */";
#else
static const char *Dtool_ShadowManager_set_tag_state_manager_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ShadowManager::set_atlas_graphics_output(GraphicsOutput *graphics_output)
 */
static PyObject *Dtool_ShadowManager_set_atlas_graphics_output_86(PyObject *self, PyObject *arg) {
  ShadowManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShadowManager, (void **)&local_this, "ShadowManager.set_atlas_graphics_output")) {
    return nullptr;
  }
  // 1-inline void ShadowManager::set_atlas_graphics_output(GraphicsOutput *graphics_output)
  GraphicsOutput *arg_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsOutput, 1, "ShadowManager.set_atlas_graphics_output", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_atlas_graphics_output)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_atlas_graphics_output(const ShadowManager self, GraphicsOutput graphics_output)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_set_atlas_graphics_output_86_comment =
  "C++ Interface:\n"
  "set_atlas_graphics_output(const ShadowManager self, GraphicsOutput graphics_output)\n"
  "\n"
  "/**\n"
  " * @brief Sets the handle to the Shadow targets output\n"
  " * @details This sets the handle to the GraphicsOutput of the shadow atlas.\n"
  " *   Usually this is RenderTarget.get_internal_buffer(), whereas the RenderTarget\n"
  " *   is the target of the ShadowStage.\n"
  " *\n"
  " *   This is used for creating display regions and attaching cameras to them,\n"
  " *   for performing shadow updates.\n"
  " *\n"
  " *   This has to get called before ShadowManager::init, otherwise an assertion\n"
  " *   will be triggered.\n"
  " *\n"
  " * @param graphics_output [description]\n"
  " */";
#else
static const char *Dtool_ShadowManager_set_atlas_graphics_output_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ShadowManager::set_atlas_size(std::size_t atlas_size)
 */
static PyObject *Dtool_ShadowManager_set_atlas_size_87(PyObject *self, PyObject *arg) {
  ShadowManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShadowManager, (void **)&local_this, "ShadowManager.set_atlas_size")) {
    return nullptr;
  }
  // 1-inline void ShadowManager::set_atlas_size(std::size_t atlas_size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).set_atlas_size)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_atlas_size(const ShadowManager self, int atlas_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_set_atlas_size_87_comment =
  "C++ Interface:\n"
  "set_atlas_size(const ShadowManager self, int atlas_size)\n"
  "\n"
  "/**\n"
  " * @brief Sets the shadow atlas size\n"
  " * @details This sets the desired shadow atlas size. It should be big enough\n"
  " *   to store all important shadow sources, with some buffer, because the shadow\n"
  " *   maps usually won't be fitted perfectly, so gaps can occur.\n"
  " *\n"
  " *   This has to get called before calling ShadowManager::init. When calling this\n"
  " *   method after initialization, an assertion will get triggered.\n"
  " *\n"
  " * @param atlas_size Size of the shadow atlas in pixels\n"
  " */";
#else
static const char *Dtool_ShadowManager_set_atlas_size_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ShadowManager::get_atlas_size(void) const
 */
static PyObject *Dtool_ShadowManager_get_atlas_size_88(PyObject *self, PyObject *) {
  ShadowManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShadowManager)) {
    return nullptr;
  }
  // 1-inline std::size_t ShadowManager::get_atlas_size(void) const
  std::size_t return_value = ((*(const ShadowManager*)local_this).get_atlas_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_get_atlas_size_88_comment =
  "C++ Interface:\n"
  "get_atlas_size(ShadowManager self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the shadow atlas size.\n"
  " * @details This returns the shadow atlas size previously set with\n"
  " *   ShadowManager::set_atlas_size.\n"
  " * @return Shadow atlas size in pixels\n"
  " */";
#else
static const char *Dtool_ShadowManager_get_atlas_size_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ShadowManager::get_num_update_slots_left(void) const
 */
static PyObject *Dtool_ShadowManager_get_num_update_slots_left_90(PyObject *self, PyObject *) {
  ShadowManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShadowManager)) {
    return nullptr;
  }
  // 1-inline std::size_t ShadowManager::get_num_update_slots_left(void) const
  std::size_t return_value = ((*(const ShadowManager*)local_this).get_num_update_slots_left)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_get_num_update_slots_left_90_comment =
  "C++ Interface:\n"
  "get_num_update_slots_left(ShadowManager self)\n"
  "\n"
  "/**\n"
  " * @brief Returns how many update slots are left.\n"
  " * @details This returns how many update slots are left. You can assume the\n"
  " *   next n calls to add_update will succeed, whereas n is the value returned\n"
  " *   by this function.\n"
  " * @return Number of update slots left.\n"
  " */";
#else
static const char *Dtool_ShadowManager_get_num_update_slots_left_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ShadowAtlas *ShadowManager::get_atlas(void) const
 */
static PyObject *Dtool_ShadowManager_get_atlas_92(PyObject *self, PyObject *) {
  ShadowManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ShadowManager)) {
    return nullptr;
  }
  // 1-inline ShadowAtlas *ShadowManager::get_atlas(void) const
  ShadowAtlas *return_value = ((*(const ShadowManager*)local_this).get_atlas)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ShadowAtlas, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_get_atlas_92_comment =
  "C++ Interface:\n"
  "get_atlas(ShadowManager self)\n"
  "\n"
  "/**\n"
  " * @brief Returns a handle to the shadow atlas.\n"
  " * @details This returns a handle to the internal shadow atlas instance. This\n"
  " *   is only valid after calling ShadowManager::init. Calling this earlier will\n"
  " *   trigger an assertion and undefined behaviour.\n"
  " * @return The internal ShadowAtlas instance\n"
  " */";
#else
static const char *Dtool_ShadowManager_get_atlas_92_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ShadowManager::init(void)
 */
static PyObject *Dtool_ShadowManager_init_95(PyObject *self, PyObject *) {
  ShadowManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShadowManager, (void **)&local_this, "ShadowManager.init")) {
    return nullptr;
  }
  // 1-void ShadowManager::init(void)
  ((*local_this).init)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_init_95_comment =
  "C++ Interface:\n"
  "init(const ShadowManager self)\n"
  "\n"
  "/**\n"
  " * @brief Initializes the ShadowManager.\n"
  " * @details This initializes the ShadowManager. All properties should have\n"
  " *   been set before calling this, otherwise assertions will get triggered.\n"
  " *\n"
  " *   This setups everything required for rendering shadows, including the\n"
  " *   shadow atlas and the various shadow cameras. After calling this method,\n"
  " *   no properties can be changed anymore.\n"
  " */";
#else
static const char *Dtool_ShadowManager_init_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ShadowManager::update(void)
 */
static PyObject *Dtool_ShadowManager_update_96(PyObject *self, PyObject *) {
  ShadowManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShadowManager, (void **)&local_this, "ShadowManager.update")) {
    return nullptr;
  }
  // 1-void ShadowManager::update(void)
  ((*local_this).update)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ShadowManager_update_96_comment =
  "C++ Interface:\n"
  "update(const ShadowManager self)\n"
  "\n"
  "/**\n"
  " * @brief Updates the ShadowManager\n"
  " * @details This updates the ShadowManager, processing all shadow sources which\n"
  " *   need to get updated.\n"
  " *\n"
  " *   This first collects all sources which require an update, sorts them by priority,\n"
  " *   and then processes the first <max_updates> ShadowSources.\n"
  " *\n"
  " *   This may not get called before ShadowManager::init, or an assertion will be\n"
  " *   thrown.\n"
  " */";
#else
static const char *Dtool_ShadowManager_update_96_comment = nullptr;
#endif

static PyObject *Dtool_ShadowManager_atlas_size_Getter(PyObject *self, void *) {
  const ShadowManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShadowManager, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::size_t ShadowManager::get_atlas_size(void) const
  std::size_t return_value = ((*(const ShadowManager*)local_this).get_atlas_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ShadowManager_atlas_size_Setter(PyObject *self, PyObject *arg, void *) {
  ShadowManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ShadowManager, (void **)&local_this, "ShadowManager.atlas_size")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete atlas_size attribute");
    return -1;
  }
  // 1-inline void ShadowManager::set_atlas_size(std::size_t atlas_size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return -1;
    }
#endif
    ((*local_this).set_atlas_size)(arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_atlas_size(const ShadowManager self, int atlas_size)\n");
  }
  return -1;
}

static PyObject *Dtool_ShadowManager_num_update_slots_left_Getter(PyObject *self, void *) {
  const ShadowManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShadowManager, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::size_t ShadowManager::get_num_update_slots_left(void) const
  std::size_t return_value = ((*(const ShadowManager*)local_this).get_num_update_slots_left)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ShadowManager_atlas_Getter(PyObject *self, void *) {
  const ShadowManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ShadowManager, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ShadowAtlas *ShadowManager::get_atlas(void) const
  ShadowAtlas *return_value = ((*(const ShadowManager*)local_this).get_atlas)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ShadowAtlas, false, false);
}

/**
 * Python function wrapper for:
 * ShadowManager::ShadowManager(void)
 * inline ShadowManager::ShadowManager(ShadowManager const &) = default
 */
static int Dtool_Init_ShadowManager(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("ShadowManager() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-ShadowManager::ShadowManager(void)
      ShadowManager *return_value = new ShadowManager();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShadowManager, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline ShadowManager::ShadowManager(ShadowManager const &) = default
      ShadowManager const *arg_this = (ShadowManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ShadowManager, 0, "ShadowManager.ShadowManager", true, true);
      if (arg_this != nullptr) {
        ShadowManager *return_value = new ShadowManager(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShadowManager, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ShadowManager() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ShadowManager()\n"
      "ShadowManager(const ShadowManager param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ShadowManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ShadowManager) {
    printf("ShadowManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ShadowManager *local_this = (ShadowManager *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ShadowManager) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ShadowManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ShadowManager) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ShadowManager*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class InternalLightManager
 */
/**
 * Python function wrapper for:
 * void InternalLightManager::add_light(PointerTo< RPLight > light)
 */
static PyObject *Dtool_InternalLightManager_add_light_99(PyObject *self, PyObject *arg) {
  InternalLightManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalLightManager, (void **)&local_this, "InternalLightManager.add_light")) {
    return nullptr;
  }
  // 1-void InternalLightManager::add_light(PointerTo< RPLight > light)
  RPLight *arg_this = (RPLight *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RPLight, 1, "InternalLightManager.add_light", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_light)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_light(const InternalLightManager self, RPLight light)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_add_light_99_comment =
  "C++ Interface:\n"
  "add_light(const InternalLightManager self, RPLight light)\n"
  "\n"
  "/**\n"
  " * @brief Adds a new light.\n"
  " * @details This adds a new light to the list of lights. This will throw an\n"
  " *   error and return if the light is already attached. You may only call\n"
  " *   this after the ShadowManager was already set.\n"
  " *\n"
  " *   While the light is attached, the light manager keeps a reference to it, so\n"
  " *   the light does not get destructed.\n"
  " *\n"
  " *   This also setups the shadows on the light, in case shadows are enabled.\n"
  " *   While a light is attached, you can not change whether it casts shadows or not.\n"
  " *   To do so, detach the light, change the setting, and re-add the light.\n"
  " *\n"
  " *   In case no free light slot is available, an error will be printed and no\n"
  " *   action will be performed.\n"
  " *\n"
  " *   If no shadow manager was set, an assertion will be triggered.\n"
  " *\n"
  " * @param light The light to add.\n"
  " */";
#else
static const char *Dtool_InternalLightManager_add_light_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void InternalLightManager::remove_light(PointerTo< RPLight > light)
 */
static PyObject *Dtool_InternalLightManager_remove_light_100(PyObject *self, PyObject *arg) {
  InternalLightManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalLightManager, (void **)&local_this, "InternalLightManager.remove_light")) {
    return nullptr;
  }
  // 1-void InternalLightManager::remove_light(PointerTo< RPLight > light)
  RPLight *arg_this = (RPLight *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_RPLight, 1, "InternalLightManager.remove_light", false, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_light)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_light(const InternalLightManager self, RPLight light)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_remove_light_100_comment =
  "C++ Interface:\n"
  "remove_light(const InternalLightManager self, RPLight light)\n"
  "\n"
  "/**\n"
  " * @brief Removes a light\n"
  " * @details This detaches a light. This prevents it from being rendered, and also\n"
  " *   cleans up all resources used by that light. If no reference is kept on the\n"
  " *   python side, the light will also get destructed.\n"
  " *\n"
  " *   If the light was not previously attached with InternalLightManager::add_light,\n"
  " *   an error will be triggered and nothing happens.\n"
  " *\n"
  " *   In case the light was set to cast shadows, all shadow sources are cleaned\n"
  " *   up, and their regions in the shadow atlas are freed.\n"
  " *\n"
  " *   All resources used by the light in the light and shadow storage are also\n"
  " *   cleaned up, by emitting cleanup GPUCommands.\n"
  " *\n"
  " *   If no shadow manager was set, an assertion will be triggered.\n"
  " *\n"
  " * @param light [description]\n"
  " */";
#else
static const char *Dtool_InternalLightManager_remove_light_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void InternalLightManager::update(void)
 */
static PyObject *Dtool_InternalLightManager_update_101(PyObject *self, PyObject *) {
  InternalLightManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalLightManager, (void **)&local_this, "InternalLightManager.update")) {
    return nullptr;
  }
  // 1-void InternalLightManager::update(void)
  ((*local_this).update)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_update_101_comment =
  "C++ Interface:\n"
  "update(const InternalLightManager self)\n"
  "\n"
  "/**\n"
  " * @brief Main update method\n"
  " * @details This is the main update method of the InternalLightManager. It\n"
  " *   processes all lights and shadow sources, updates them, and notifies the\n"
  " *   GPU about it. This should be called on a per-frame basis.\n"
  " *\n"
  " *   If the InternalLightManager was not initialized yet, an assertion is thrown.\n"
  " */";
#else
static const char *Dtool_InternalLightManager_update_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void InternalLightManager::set_camera_pos(LPoint3 const &pos)
 */
static PyObject *Dtool_InternalLightManager_set_camera_pos_102(PyObject *self, PyObject *arg) {
  InternalLightManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalLightManager, (void **)&local_this, "InternalLightManager.set_camera_pos")) {
    return nullptr;
  }
  // 1-inline void InternalLightManager::set_camera_pos(LPoint3 const &pos)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "InternalLightManager.set_camera_pos", "LPoint3f");
  }
  ((*local_this).set_camera_pos)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_camera_pos(const InternalLightManager self, const LPoint3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_set_camera_pos_102_comment =
  "C++ Interface:\n"
  "set_camera_pos(const InternalLightManager self, const LPoint3f pos)\n"
  "\n"
  "/**\n"
  " * @brief Sets the camera position\n"
  " * @details This sets the camera position, which will be used to determine which\n"
  " *   shadow sources have to get updated\n"
  " *\n"
  " * @param mat View projection mat\n"
  " */";
#else
static const char *Dtool_InternalLightManager_set_camera_pos_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void InternalLightManager::set_shadow_update_distance(PN_stdfloat dist)
 */
static PyObject *Dtool_InternalLightManager_set_shadow_update_distance_103(PyObject *self, PyObject *arg) {
  InternalLightManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalLightManager, (void **)&local_this, "InternalLightManager.set_shadow_update_distance")) {
    return nullptr;
  }
  // 1-inline void InternalLightManager::set_shadow_update_distance(PN_stdfloat dist)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_shadow_update_distance)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_update_distance(const InternalLightManager self, float dist)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_set_shadow_update_distance_103_comment =
  "C++ Interface:\n"
  "set_shadow_update_distance(const InternalLightManager self, float dist)\n"
  "\n"
  "/**\n"
  " * @brief Sets the maximum shadow update distance\n"
  " * @details This controls the maximum distance until which shadows are updated.\n"
  " *   If a shadow source is past that distance, it is ignored and no longer recieves\n"
  " *   updates until it is in range again\n"
  " *\n"
  " * @param dist Distance in world space units\n"
  " */";
#else
static const char *Dtool_InternalLightManager_set_shadow_update_distance_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int InternalLightManager::get_max_light_index(void) const
 */
static PyObject *Dtool_InternalLightManager_get_max_light_index_104(PyObject *self, PyObject *) {
  InternalLightManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalLightManager)) {
    return nullptr;
  }
  // 1-inline int InternalLightManager::get_max_light_index(void) const
  int return_value = ((*(const InternalLightManager*)local_this).get_max_light_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_get_max_light_index_104_comment =
  "C++ Interface:\n"
  "get_max_light_index(InternalLightManager self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the maximum light index\n"
  " * @details This returns the maximum light index (also called slot). Any lights\n"
  " *   after that slot are guaranteed to be zero-lights. This is useful when\n"
  " *   iterating over the list of lights, because iteration can be stopped when\n"
  " *   the maximum light index is reached.\n"
  " *\n"
  " *   The maximum light index points to the last slot which is used. If no lights\n"
  " *   are attached, -1 is returned. If one light is attached at slot 0, the index\n"
  " *   is 0, if two are attached at the slots 0 and 1, the index is 1, and so on.\n"
  " *\n"
  " *   If, for example, two lights are attached at the slots 2 and 5, then the\n"
  " *   index will be 5. Keep in mind that the max-index is not an indicator for\n"
  " *   how many lights are attached. Also, zero lights still may occur when iterating\n"
  " *   over the light lists\n"
  " *\n"
  " * @return Maximum light index\n"
  " */";
#else
static const char *Dtool_InternalLightManager_get_max_light_index_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t InternalLightManager::get_num_lights(void) const
 */
static PyObject *Dtool_InternalLightManager_get_num_lights_106(PyObject *self, PyObject *) {
  InternalLightManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalLightManager)) {
    return nullptr;
  }
  // 1-inline std::size_t InternalLightManager::get_num_lights(void) const
  std::size_t return_value = ((*(const InternalLightManager*)local_this).get_num_lights)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_get_num_lights_106_comment =
  "C++ Interface:\n"
  "get_num_lights(InternalLightManager self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the amount of stored lights.\n"
  " * @details This returns the amount of stored lights. This behaves unlike\n"
  " *   InternalLightManager::get_max_light_index, and instead returns the true\n"
  " *   amount of lights, which is completely unrelated to the amount of used slots.\n"
  " *\n"
  " * @return Amount of stored lights\n"
  " */";
#else
static const char *Dtool_InternalLightManager_get_num_lights_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t InternalLightManager::get_num_shadow_sources(void) const
 */
static PyObject *Dtool_InternalLightManager_get_num_shadow_sources_108(PyObject *self, PyObject *) {
  InternalLightManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalLightManager)) {
    return nullptr;
  }
  // 1-inline std::size_t InternalLightManager::get_num_shadow_sources(void) const
  std::size_t return_value = ((*(const InternalLightManager*)local_this).get_num_shadow_sources)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_get_num_shadow_sources_108_comment =
  "C++ Interface:\n"
  "get_num_shadow_sources(InternalLightManager self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the amount of shadow sources.\n"
  " * @details This returns the total amount of stored shadow sources. This does\n"
  " *   not denote the amount of updated sources, but instead takes into account\n"
  " *   all sources, even those out of frustum.\n"
  " * @return Amount of shadow sources.\n"
  " */";
#else
static const char *Dtool_InternalLightManager_get_num_shadow_sources_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void InternalLightManager::set_shadow_manager(ShadowManager *mgr)
 */
static PyObject *Dtool_InternalLightManager_set_shadow_manager_110(PyObject *self, PyObject *arg) {
  InternalLightManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalLightManager, (void **)&local_this, "InternalLightManager.set_shadow_manager")) {
    return nullptr;
  }
  // 1-inline void InternalLightManager::set_shadow_manager(ShadowManager *mgr)
  ShadowManager *arg_this = (ShadowManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ShadowManager, 1, "InternalLightManager.set_shadow_manager", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_shadow_manager)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shadow_manager(const InternalLightManager self, ShadowManager mgr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_set_shadow_manager_110_comment =
  "C++ Interface:\n"
  "set_shadow_manager(const InternalLightManager self, ShadowManager mgr)\n"
  "\n"
  "/**\n"
  " * @brief Sets the handle to the shadow manager\n"
  " * @details This sets the handle to the global shadow manager. It is usually\n"
  " *   constructed on the python side, so we need to get a handle to it.\n"
  " *\n"
  " *   The manager should be a handle to a ShadowManager instance, and will be\n"
  " *   stored somewhere on the python side most likely. The light manager does not\n"
  " *   keep a reference to it, so the python side should make sure to keep one.\n"
  " *\n"
  " *   Be sure to call this before the InternalLightManager::update() method is\n"
  " *   called, otherwise an assertion will get triggered.\n"
  " *\n"
  " * @param mgr The ShadowManager instance\n"
  " */";
#else
static const char *Dtool_InternalLightManager_set_shadow_manager_110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ShadowManager *InternalLightManager::get_shadow_manager(void) const
 */
static PyObject *Dtool_InternalLightManager_get_shadow_manager_111(PyObject *self, PyObject *) {
  InternalLightManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InternalLightManager)) {
    return nullptr;
  }
  // 1-inline ShadowManager *InternalLightManager::get_shadow_manager(void) const
  ShadowManager *return_value = ((*(const InternalLightManager*)local_this).get_shadow_manager)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ShadowManager, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_get_shadow_manager_111_comment =
  "C++ Interface:\n"
  "get_shadow_manager(InternalLightManager self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the internal used ShadowManager\n"
  " * @details This returns a handle to the internally used shadow manager\n"
  " * @return Shadow manager\n"
  " */";
#else
static const char *Dtool_InternalLightManager_get_shadow_manager_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void InternalLightManager::set_command_list(GPUCommandList *cmd_list)
 */
static PyObject *Dtool_InternalLightManager_set_command_list_114(PyObject *self, PyObject *arg) {
  InternalLightManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalLightManager, (void **)&local_this, "InternalLightManager.set_command_list")) {
    return nullptr;
  }
  // 1-inline void InternalLightManager::set_command_list(GPUCommandList *cmd_list)
  GPUCommandList *arg_this = (GPUCommandList *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GPUCommandList, 1, "InternalLightManager.set_command_list", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_command_list)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_command_list(const InternalLightManager self, GPUCommandList cmd_list)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InternalLightManager_set_command_list_114_comment =
  "C++ Interface:\n"
  "set_command_list(const InternalLightManager self, GPUCommandList cmd_list)\n"
  "\n"
  "/**\n"
  " * @brief Sets a handle to the command list\n"
  " * @details This sets a handle to the global GPUCommandList. This is required to\n"
  " *   emit GPUCommands, which are used for attaching and detaching lights, as well\n"
  " *   as shadow source updates.\n"
  " *\n"
  " *   The cmd_list should be a handle to a GPUCommandList handle, and will be\n"
  " *   stored somewhere on the python side most likely. The light manager does not\n"
  " *   keep a reference to it, so the python side should make sure to keep one.\n"
  " *\n"
  " *   Be sure to call this before the InternalLightManager::update() method is\n"
  " *   called, otherwise an assertion will get triggered.\n"
  " *\n"
  " * @param cmd_list The GPUCommandList instance\n"
  " */";
#else
static const char *Dtool_InternalLightManager_set_command_list_114_comment = nullptr;
#endif

static PyObject *Dtool_InternalLightManager_max_light_index_Getter(PyObject *self, void *) {
  const InternalLightManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InternalLightManager, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int InternalLightManager::get_max_light_index(void) const
  int return_value = ((*(const InternalLightManager*)local_this).get_max_light_index)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_InternalLightManager_num_lights_Getter(PyObject *self, void *) {
  const InternalLightManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InternalLightManager, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::size_t InternalLightManager::get_num_lights(void) const
  std::size_t return_value = ((*(const InternalLightManager*)local_this).get_num_lights)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_InternalLightManager_num_shadow_sources_Getter(PyObject *self, void *) {
  const InternalLightManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InternalLightManager, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::size_t InternalLightManager::get_num_shadow_sources(void) const
  std::size_t return_value = ((*(const InternalLightManager*)local_this).get_num_shadow_sources)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_InternalLightManager_shadow_manager_Getter(PyObject *self, void *) {
  const InternalLightManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InternalLightManager, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ShadowManager *InternalLightManager::get_shadow_manager(void) const
  ShadowManager *return_value = ((*(const InternalLightManager*)local_this).get_shadow_manager)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ShadowManager, true, false);
}

static int Dtool_InternalLightManager_shadow_manager_Setter(PyObject *self, PyObject *arg, void *) {
  InternalLightManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InternalLightManager, (void **)&local_this, "InternalLightManager.shadow_manager")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete shadow_manager attribute");
    return -1;
  }
  // 1-inline void InternalLightManager::set_shadow_manager(ShadowManager *mgr)
  ShadowManager *arg_this = (ShadowManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ShadowManager, 1, "InternalLightManager.set_shadow_manager", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_shadow_manager)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shadow_manager(const InternalLightManager self, ShadowManager mgr)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * InternalLightManager::InternalLightManager(void)
 * inline InternalLightManager::InternalLightManager(InternalLightManager const &) = default
 */
static int Dtool_Init_InternalLightManager(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("InternalLightManager() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-InternalLightManager::InternalLightManager(void)
      InternalLightManager *return_value = new InternalLightManager();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InternalLightManager, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline InternalLightManager::InternalLightManager(InternalLightManager const &) = default
      InternalLightManager const *arg_this = (InternalLightManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InternalLightManager, 0, "InternalLightManager.InternalLightManager", true, true);
      if (arg_this != nullptr) {
        InternalLightManager *return_value = new InternalLightManager(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InternalLightManager, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "InternalLightManager() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "InternalLightManager()\n"
      "InternalLightManager(const InternalLightManager param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_InternalLightManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_InternalLightManager) {
    printf("InternalLightManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  InternalLightManager *local_this = (InternalLightManager *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_InternalLightManager) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_InternalLightManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_InternalLightManager) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RPPointLight
 */
/**
 * Python function wrapper for:
 * inline void RPPointLight::set_radius(float radius)
 */
static PyObject *Dtool_RPPointLight_set_radius_118(PyObject *self, PyObject *arg) {
  RPPointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPPointLight, (void **)&local_this, "RPPointLight.set_radius")) {
    return nullptr;
  }
  // 1-inline void RPPointLight::set_radius(float radius)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_radius)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const RPPointLight self, float radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RPPointLight_set_radius_118_comment =
  "C++ Interface:\n"
  "set_radius(const RPPointLight self, float radius)\n"
  "\n"
  "/**\n"
  " * @brief Sets the radius of the light\n"
  " * @details This sets the radius of the light. It controls the lights\n"
  " *   influence. After a distance greater than this radius, the light influence\n"
  " *   is zero.\n"
  " *\n"
  " * @param radius Light radius in world space\n"
  " */";
#else
static const char *Dtool_RPPointLight_set_radius_118_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float RPPointLight::get_radius(void) const
 */
static PyObject *Dtool_RPPointLight_get_radius_119(PyObject *self, PyObject *) {
  RPPointLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RPPointLight)) {
    return nullptr;
  }
  // 1-inline float RPPointLight::get_radius(void) const
  float return_value = ((*(const RPPointLight*)local_this).get_radius)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPPointLight_get_radius_119_comment =
  "C++ Interface:\n"
  "get_radius(RPPointLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the lights radius\n"
  " * @details This returns the lights radius previously set with\n"
  " *   RPPointLight::set_radius\n"
  " * @return Light radius in world space\n"
  " */";
#else
static const char *Dtool_RPPointLight_get_radius_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RPPointLight::set_inner_radius(float inner_radius)
 */
static PyObject *Dtool_RPPointLight_set_inner_radius_121(PyObject *self, PyObject *arg) {
  RPPointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPPointLight, (void **)&local_this, "RPPointLight.set_inner_radius")) {
    return nullptr;
  }
  // 1-inline void RPPointLight::set_inner_radius(float inner_radius)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_inner_radius)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_inner_radius(const RPPointLight self, float inner_radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RPPointLight_set_inner_radius_121_comment =
  "C++ Interface:\n"
  "set_inner_radius(const RPPointLight self, float inner_radius)\n"
  "\n"
  "/**\n"
  " * @brief Sets the inner radius of the light\n"
  " * @details This sets the inner radius of the light. Anything greater than\n"
  " *   zero causes the light to get an area light. This has influence on the\n"
  " *   specular highlights of the light aswell as the shadows.\n"
  " *\n"
  " *   The inner radius controls the size of the lights sphere size in world\n"
  " *   space units. A radius of 0 means the light has no inner radius, and the\n"
  " *   light will be have like an infinite small point light source.\n"
  " *   A radius greater than zero will cause the light to behave like it would be\n"
  " *   an emissive sphere with the given inner radius emitting light. This is\n"
  " *   more physically correct.\n"
  " *\n"
  " * @param inner_radius Inner-radius in world space\n"
  " */";
#else
static const char *Dtool_RPPointLight_set_inner_radius_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float RPPointLight::get_inner_radius(void) const
 */
static PyObject *Dtool_RPPointLight_get_inner_radius_122(PyObject *self, PyObject *) {
  RPPointLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RPPointLight)) {
    return nullptr;
  }
  // 1-inline float RPPointLight::get_inner_radius(void) const
  float return_value = ((*(const RPPointLight*)local_this).get_inner_radius)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPPointLight_get_inner_radius_122_comment =
  "C++ Interface:\n"
  "get_inner_radius(RPPointLight self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the inner radius of the light\n"
  " * @details This returns the inner radius of the light, previously set with\n"
  " *   RPPointLight::get_inner_radius.\n"
  " * @return [description]\n"
  " */";
#else
static const char *Dtool_RPPointLight_get_inner_radius_122_comment = nullptr;
#endif

static PyObject *Dtool_RPPointLight_radius_Getter(PyObject *self, void *) {
  const RPPointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPPointLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float RPPointLight::get_radius(void) const
  float return_value = ((*(const RPPointLight*)local_this).get_radius)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RPPointLight_radius_Setter(PyObject *self, PyObject *arg, void *) {
  RPPointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPPointLight, (void **)&local_this, "RPPointLight.radius")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete radius attribute");
    return -1;
  }
  // 1-inline void RPPointLight::set_radius(float radius)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_radius)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_radius(const RPPointLight self, float radius)\n");
  }
  return -1;
}

static PyObject *Dtool_RPPointLight_inner_radius_Getter(PyObject *self, void *) {
  const RPPointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPPointLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float RPPointLight::get_inner_radius(void) const
  float return_value = ((*(const RPPointLight*)local_this).get_inner_radius)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RPPointLight_inner_radius_Setter(PyObject *self, PyObject *arg, void *) {
  RPPointLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPPointLight, (void **)&local_this, "RPPointLight.inner_radius")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete inner_radius attribute");
    return -1;
  }
  // 1-inline void RPPointLight::set_inner_radius(float inner_radius)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_inner_radius)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_inner_radius(const RPPointLight self, float inner_radius)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * RPPointLight::RPPointLight(void)
 */
static int Dtool_Init_RPPointLight(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("RPPointLight() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "RPPointLight() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-RPPointLight::RPPointLight(void)
  RPPointLight *return_value = new RPPointLight();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RPPointLight, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RPPointLight()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_RPPointLight(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RPPointLight) {
    printf("RPPointLight ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RPPointLight *local_this = (RPPointLight *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RPPointLight) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_RPLight) {
    return (RPLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(RPLight *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RPPointLight(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RPPointLight) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_RPLight) {
    RPLight* other_this = (RPLight*)from_this;
    return (RPPointLight*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RPPointLight*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PSSMCameraRig
 */
/**
 * Python function wrapper for:
 * inline void PSSMCameraRig::set_pssm_distance(float distance)
 */
static PyObject *Dtool_PSSMCameraRig_set_pssm_distance_128(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.set_pssm_distance")) {
    return nullptr;
  }
  // 1-inline void PSSMCameraRig::set_pssm_distance(float distance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_pssm_distance)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pssm_distance(const PSSMCameraRig self, float distance)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_set_pssm_distance_128_comment =
  "C++ Interface:\n"
  "set_pssm_distance(const PSSMCameraRig self, float distance)\n"
  "\n"
  "/**\n"
  " * @brief Sets the maximum pssm distance.\n"
  " * @details This sets the maximum distance in world space until which shadows\n"
  " *   are rendered. After this distance, no shadows will be rendered.\n"
  " *\n"
  " *   If the distance is below zero, an assertion is triggered.\n"
  " *\n"
  " * @param distance Maximum distance in world space\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_set_pssm_distance_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PSSMCameraRig::set_sun_distance(float distance)
 */
static PyObject *Dtool_PSSMCameraRig_set_sun_distance_129(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.set_sun_distance")) {
    return nullptr;
  }
  // 1-inline void PSSMCameraRig::set_sun_distance(float distance)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_sun_distance)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sun_distance(const PSSMCameraRig self, float distance)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_set_sun_distance_129_comment =
  "C++ Interface:\n"
  "set_sun_distance(const PSSMCameraRig self, float distance)\n"
  "\n"
  "/**\n"
  " * @brief Sets the suns distance\n"
  " * @details This sets the distance the cameras will have from the cameras frustum.\n"
  " *   This prevents far objects from having no shadows, which can occur when these\n"
  " *   objects are between the cameras frustum and the sun, but not inside of the\n"
  " *   cameras frustum. Setting the sun distance high enough will move the cameras\n"
  " *   away from the camera frustum, being able to cover those distant objects too.\n"
  " *\n"
  " *   If the sun distance is set too high, artifacts will occur due to the reduced\n"
  " *   range of depth. If a value below zero is passed, an assertion will get\n"
  " *   triggered.\n"
  " *\n"
  " * @param distance The sun distance\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_set_sun_distance_129_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PSSMCameraRig::set_use_fixed_film_size(bool flag)
 */
static PyObject *Dtool_PSSMCameraRig_set_use_fixed_film_size_130(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.set_use_fixed_film_size")) {
    return nullptr;
  }
  // 1-inline void PSSMCameraRig::set_use_fixed_film_size(bool flag)
  ((*local_this).set_use_fixed_film_size)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_use_fixed_film_size(const PSSMCameraRig self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_set_use_fixed_film_size_130_comment =
  "C++ Interface:\n"
  "set_use_fixed_film_size(const PSSMCameraRig self, bool flag)\n"
  "\n"
  "/**\n"
  " * @brief Sets whether to use a fixed film size\n"
  " * @details This controls if a fixed film size should be used. This will cause\n"
  " *   the camera rig to cache the current film size, and only change it in case\n"
  " *   it gets too small. This provides less flickering when moving, because the\n"
  " *   film size will stay roughly constant. However, to prevent the cached film\n"
  " *   size getting too big, one should call PSSMCameraRig::reset_film_size\n"
  " *   once in a while, otherwise there might be a lot of wasted space.\n"
  " *\n"
  " * @param flag Whether to use a fixed film size\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_set_use_fixed_film_size_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PSSMCameraRig::set_resolution(std::size_t resolution)
 */
static PyObject *Dtool_PSSMCameraRig_set_resolution_131(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.set_resolution")) {
    return nullptr;
  }
  // 1-inline void PSSMCameraRig::set_resolution(std::size_t resolution)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).set_resolution)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_resolution(const PSSMCameraRig self, int resolution)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_set_resolution_131_comment =
  "C++ Interface:\n"
  "set_resolution(const PSSMCameraRig self, int resolution)\n"
  "\n"
  "/**\n"
  " * @brief Sets the resolution of each split\n"
  " * @details This sets the resolution of each split. Currently it is equal for\n"
  " *   each split. This is required when using PSSMCameraRig::set_use_stable_csm,\n"
  " *   to compute how bix a texel is.\n"
  " *\n"
  " *   It has to match the y-resolution of the pssm shadow map. If an invalid\n"
  " *   resolution is triggered, an assertion is thrown.\n"
  " *\n"
  " * @param resolution The resolution of each split.\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_set_resolution_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PSSMCameraRig::set_use_stable_csm(bool flag)
 */
static PyObject *Dtool_PSSMCameraRig_set_use_stable_csm_132(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.set_use_stable_csm")) {
    return nullptr;
  }
  // 1-inline void PSSMCameraRig::set_use_stable_csm(bool flag)
  ((*local_this).set_use_stable_csm)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_use_stable_csm(const PSSMCameraRig self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_set_use_stable_csm_132_comment =
  "C++ Interface:\n"
  "set_use_stable_csm(const PSSMCameraRig self, bool flag)\n"
  "\n"
  "/**\n"
  " * @brief Sets whether to use stable CSM snapping.\n"
  " * @details This option controls if stable CSM snapping should be used. When the\n"
  " *   option is enabled, all splits will snap to their texels, so that when moving,\n"
  " *   no flickering will occur. However, this only works when the splits do not\n"
  " *   change their film size, rotation and angle.\n"
  " *\n"
  " * @param flag Whether to use stable CSM snapping\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_set_use_stable_csm_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PSSMCameraRig::set_logarithmic_factor(float factor)
 */
static PyObject *Dtool_PSSMCameraRig_set_logarithmic_factor_133(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.set_logarithmic_factor")) {
    return nullptr;
  }
  // 1-inline void PSSMCameraRig::set_logarithmic_factor(float factor)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_logarithmic_factor)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_logarithmic_factor(const PSSMCameraRig self, float factor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_set_logarithmic_factor_133_comment =
  "C++ Interface:\n"
  "set_logarithmic_factor(const PSSMCameraRig self, float factor)\n"
  "\n"
  "/**\n"
  " * @brief Sets the logarithmic factor\n"
  " * @details This sets the logarithmic factor, which is the core of the algorithm.\n"
  " *   PSSM splits the camera frustum based on a linear and a logarithmic factor.\n"
  " *   While a linear factor provides a good distribution, it often is not applicable\n"
  " *   for wider distances. A logarithmic distribution provides a better distribution\n"
  " *   at distance, but suffers from splitting in the near areas.\n"
  " *\n"
  " *   The logarithmic factor mixes the logarithmic and linear split distribution,\n"
  " *   to get the best of both. A greater factor will make the distribution more\n"
  " *   logarithmic, while a smaller factor will make it more linear.\n"
  " *\n"
  " *   If the factor is below zero, an ssertion is triggered.\n"
  " *\n"
  " * @param factor The logarithmic factor\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_set_logarithmic_factor_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PSSMCameraRig::set_border_bias(float bias)
 */
static PyObject *Dtool_PSSMCameraRig_set_border_bias_134(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.set_border_bias")) {
    return nullptr;
  }
  // 1-inline void PSSMCameraRig::set_border_bias(float bias)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_border_bias)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_border_bias(const PSSMCameraRig self, float bias)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_set_border_bias_134_comment =
  "C++ Interface:\n"
  "set_border_bias(const PSSMCameraRig self, float bias)\n"
  "\n"
  "/**\n"
  " * @brief Sets the border bias for each split\n"
  " * @details This sets the border bias for every split. This increases each\n"
  " *   splits frustum by multiplying it by (1 + bias), and helps reducing artifacts\n"
  " *   at the borders of the splits. Artifacts can occur when the bias is too low,\n"
  " *   because then the filtering will go over the bounds of the split, producing\n"
  " *   invalid results.\n"
  " *\n"
  " *   If the bias is below zero, an assertion is thrown.\n"
  " *\n"
  " * @param bias Border bias\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_set_border_bias_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PSSMCameraRig::update(NodePath cam_node, LVecBase3 const &light_vector)
 */
static PyObject *Dtool_PSSMCameraRig_update_135(PyObject *self, PyObject *args, PyObject *kwds) {
  PSSMCameraRig *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.update")) {
    return nullptr;
  }
  // 1-void PSSMCameraRig::update(NodePath cam_node, LVecBase3 const &light_vector)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"cam_node", "light_vector", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:update", (char **)keyword_list, &param1, &param2)) {
    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "PSSMCameraRig.update", true, true);
    LVecBase3f param2_local;
    LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PSSMCameraRig.update", "LVecBase3f");
    }
    if (param1_this != nullptr) {
      ((*local_this).update)(*param1_this, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "update(const PSSMCameraRig self, NodePath cam_node, const LVecBase3f light_vector)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_update_135_comment =
  "C++ Interface:\n"
  "update(const PSSMCameraRig self, NodePath cam_node, const LVecBase3f light_vector)\n"
  "\n"
  "/**\n"
  " * @brief Updates the PSSM camera rig\n"
  " * @details This updates the rig with an updated camera position, and a given\n"
  " *   light vector. This should be called on a per-frame basis. It will reposition\n"
  " *   all camera sources to fit the frustum based on the pssm distribution.\n"
  " *\n"
  " *   The light vector should be the vector from the light source, not the\n"
  " *   vector to the light source.\n"
  " *\n"
  " * @param cam_node Target camera node\n"
  " * @param light_vector The vector from the light to any point\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_update_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PSSMCameraRig::reset_film_size_cache(void)
 */
static PyObject *Dtool_PSSMCameraRig_reset_film_size_cache_136(PyObject *self, PyObject *) {
  PSSMCameraRig *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.reset_film_size_cache")) {
    return nullptr;
  }
  // 1-inline void PSSMCameraRig::reset_film_size_cache(void)
  ((*local_this).reset_film_size_cache)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_reset_film_size_cache_136_comment =
  "C++ Interface:\n"
  "reset_film_size_cache(const PSSMCameraRig self)\n"
  "\n"
  "/**\n"
  " * @brief Resets the film size cache\n"
  " * @details In case PSSMCameraRig::set_use_fixed_film_size is used, this resets\n"
  " *   the film size cache. This might lead to a small \"jump\" in the shadows,\n"
  " *   because the film size changes, however it leads to a better shadow distribution.\n"
  " *\n"
  " *   This is the case because when using a fixed film size, the cache will get\n"
  " *   bigger and bigger, whenever the camera moves to a grazing angle. However,\n"
  " *   when moving back to a normal angle, the film size cache still stores this\n"
  " *   big angle, and thus the splits will have a much bigger film size than actualy\n"
  " *   required. To prevent this, call this method once in a while, so an optimal\n"
  " *   distribution is ensured.\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_reset_film_size_cache_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath PSSMCameraRig::get_camera(std::size_t index)
 */
static PyObject *Dtool_PSSMCameraRig_get_camera_137(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.get_camera")) {
    return nullptr;
  }
  // 1-inline NodePath PSSMCameraRig::get_camera(std::size_t index)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    NodePath *return_value = new NodePath(((*local_this).get_camera)(arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_camera(const PSSMCameraRig self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_get_camera_137_comment =
  "C++ Interface:\n"
  "get_camera(const PSSMCameraRig self, int index)\n"
  "\n"
  "/**\n"
  " * @brief Returns the n-th camera\n"
  " * @details This returns the n-th camera of the camera rig, which can be used\n"
  " *   for various stuff like showing its frustum, passing it as a shader input,\n"
  " *   and so on.\n"
  " *\n"
  " *   The first camera is the camera which is the camera of the first split,\n"
  " *   which is the split closest to the camera. All cameras follow in descending\n"
  " *   order until to the last camera, which is the split furthest away from the\n"
  " *   camera.\n"
  " *\n"
  " *   If an invalid index is passed, an assertion is thrown.\n"
  " *\n"
  " * @param index Index of the camera.\n"
  " * @return [description]\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_get_camera_137_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PSSMCameraRig::reparent_to(NodePath parent)
 */
static PyObject *Dtool_PSSMCameraRig_reparent_to_138(PyObject *self, PyObject *arg) {
  PSSMCameraRig *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.reparent_to")) {
    return nullptr;
  }
  // 1-void PSSMCameraRig::reparent_to(NodePath parent)
  NodePath *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "PSSMCameraRig.reparent_to", true, true);
  if (arg_this != nullptr) {
    ((*local_this).reparent_to)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reparent_to(const PSSMCameraRig self, NodePath parent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_reparent_to_138_comment =
  "C++ Interface:\n"
  "reparent_to(const PSSMCameraRig self, NodePath parent)\n"
  "\n"
  "/**\n"
  " * @brief Reparents the camera rig\n"
  " * @details This reparents all cameras to the given parent. Usually the parent\n"
  " *   will be ShowBase.render. The parent should be the same node where the\n"
  " *   main camera is located in, too.\n"
  " *\n"
  " *   If an empty parrent is passed, an assertion will get triggered.\n"
  " *\n"
  " * @param parent Parent node path\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_reparent_to_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PTA_LMatrix4 const &PSSMCameraRig::get_mvp_array(void)
 */
static PyObject *Dtool_PSSMCameraRig_get_mvp_array_139(PyObject *self, PyObject *) {
  PSSMCameraRig *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.get_mvp_array")) {
    return nullptr;
  }
  // 1-inline PTA_LMatrix4 const &PSSMCameraRig::get_mvp_array(void)
  PTA_LMatrix4 const *return_value = &(((*local_this).get_mvp_array)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_UnalignedLMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_get_mvp_array_139_comment =
  "C++ Interface:\n"
  "get_mvp_array(const PSSMCameraRig self)\n"
  "\n"
  "/**\n"
  " * @brief Returns a handle to the MVP array\n"
  " * @details This returns a handle to the array of view-projection matrices\n"
  " *   of the different splits. This can be used for computing shadows. The array\n"
  " *   is a PTALMatrix4 and thus can be directly bound to a shader.\n"
  " *\n"
  " * @return view-projection matrix array\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_get_mvp_array_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PTA_LVecBase2 const &PSSMCameraRig::get_nearfar_array(void)
 */
static PyObject *Dtool_PSSMCameraRig_get_nearfar_array_140(PyObject *self, PyObject *) {
  PSSMCameraRig *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PSSMCameraRig, (void **)&local_this, "PSSMCameraRig.get_nearfar_array")) {
    return nullptr;
  }
  // 1-inline PTA_LVecBase2 const &PSSMCameraRig::get_nearfar_array(void)
  PTA_LVecBase2 const *return_value = &(((*local_this).get_nearfar_array)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_LVecBase2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PSSMCameraRig_get_nearfar_array_140_comment =
  "C++ Interface:\n"
  "get_nearfar_array(const PSSMCameraRig self)\n"
  "\n"
  "/**\n"
  " * @brief Returns a handle to the near and far planes array\n"
  " * @details This returns a handle to the near and far plane array. Each split\n"
  " *   has an entry in the array, whereas the x component of the vecto denotes the\n"
  " *   near plane, and the y component denotes the far plane of the split.\n"
  " *\n"
  " *   This is required because the near and far planes of the splits change\n"
  " *   constantly. To access them in a shader, the shader needs access to the\n"
  " *   array.\n"
  " *\n"
  " * @return Array of near and far planes\n"
  " */";
#else
static const char *Dtool_PSSMCameraRig_get_nearfar_array_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PSSMCameraRig::PSSMCameraRig(PSSMCameraRig const &) = default
 * PSSMCameraRig::PSSMCameraRig(std::size_t num_splits)
 */
static int Dtool_Init_PSSMCameraRig(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PSSMCameraRig() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline PSSMCameraRig::PSSMCameraRig(PSSMCameraRig const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      PSSMCameraRig const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PSSMCameraRig);
      if (param0_this != nullptr) {
        PSSMCameraRig *return_value = new PSSMCameraRig(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PSSMCameraRig, true, false);
      }
    }
  }

  {
    // -2 PSSMCameraRig::PSSMCameraRig(std::size_t num_splits)
    Py_ssize_t param0;
    static const char *keyword_list[] = {"num_splits", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "n:PSSMCameraRig", (char **)keyword_list, &param0)) {
#ifndef NDEBUG
      if (param0 < 0) {
        PyErr_Format(PyExc_OverflowError,
                     "can't convert negative value %zd to size_t",
                     param0);
        return -1;
      }
#endif
      PSSMCameraRig *return_value = new PSSMCameraRig((std::size_t)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PSSMCameraRig, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline PSSMCameraRig::PSSMCameraRig(PSSMCameraRig const &) = default
  // No coercion possible: PSSMCameraRig::PSSMCameraRig(std::size_t num_splits)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PSSMCameraRig(const PSSMCameraRig param0)\n"
      "PSSMCameraRig(int num_splits)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PSSMCameraRig(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PSSMCameraRig) {
    printf("PSSMCameraRig ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PSSMCameraRig *local_this = (PSSMCameraRig *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PSSMCameraRig) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PSSMCameraRig(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PSSMCameraRig) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RPSpotLight
 */
/**
 * Python function wrapper for:
 * inline void RPSpotLight::set_radius(float radius)
 */
static PyObject *Dtool_RPSpotLight_set_radius_143(PyObject *self, PyObject *arg) {
  RPSpotLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPSpotLight, (void **)&local_this, "RPSpotLight.set_radius")) {
    return nullptr;
  }
  // 1-inline void RPSpotLight::set_radius(float radius)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_radius)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const RPSpotLight self, float radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RPSpotLight_set_radius_143_comment =
  "C++ Interface:\n"
  "set_radius(const RPSpotLight self, float radius)\n";
#else
static const char *Dtool_RPSpotLight_set_radius_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float RPSpotLight::get_radius(void) const
 */
static PyObject *Dtool_RPSpotLight_get_radius_144(PyObject *self, PyObject *) {
  RPSpotLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RPSpotLight)) {
    return nullptr;
  }
  // 1-inline float RPSpotLight::get_radius(void) const
  float return_value = ((*(const RPSpotLight*)local_this).get_radius)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPSpotLight_get_radius_144_comment =
  "C++ Interface:\n"
  "get_radius(RPSpotLight self)\n";
#else
static const char *Dtool_RPSpotLight_get_radius_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RPSpotLight::set_fov(float fov)
 */
static PyObject *Dtool_RPSpotLight_set_fov_146(PyObject *self, PyObject *arg) {
  RPSpotLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPSpotLight, (void **)&local_this, "RPSpotLight.set_fov")) {
    return nullptr;
  }
  // 1-inline void RPSpotLight::set_fov(float fov)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_fov)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fov(const RPSpotLight self, float fov)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RPSpotLight_set_fov_146_comment =
  "C++ Interface:\n"
  "set_fov(const RPSpotLight self, float fov)\n";
#else
static const char *Dtool_RPSpotLight_set_fov_146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float RPSpotLight::get_fov(void) const
 */
static PyObject *Dtool_RPSpotLight_get_fov_147(PyObject *self, PyObject *) {
  RPSpotLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RPSpotLight)) {
    return nullptr;
  }
  // 1-inline float RPSpotLight::get_fov(void) const
  float return_value = ((*(const RPSpotLight*)local_this).get_fov)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RPSpotLight_get_fov_147_comment =
  "C++ Interface:\n"
  "get_fov(RPSpotLight self)\n";
#else
static const char *Dtool_RPSpotLight_get_fov_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RPSpotLight::set_direction(LVecBase3 direction)
 * inline void RPSpotLight::set_direction(float dx, float dy, float dz)
 */
static PyObject *Dtool_RPSpotLight_set_direction_149(PyObject *self, PyObject *args, PyObject *kwds) {
  RPSpotLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPSpotLight, (void **)&local_this, "RPSpotLight.set_direction")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "direction")) {
        // 1-inline void RPSpotLight::set_direction(LVecBase3 direction)
        LVecBase3f arg_local;
        LVecBase3 *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "RPSpotLight.set_direction", "LVecBase3f");
        }
        ((*local_this).set_direction)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void RPSpotLight::set_direction(float dx, float dy, float dz)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"dx", "dy", "dz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_direction", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_direction)((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_direction() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_direction(const RPSpotLight self, LVecBase3f direction)\n"
      "set_direction(const RPSpotLight self, float dx, float dy, float dz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RPSpotLight_set_direction_149_comment =
  "C++ Interface:\n"
  "set_direction(const RPSpotLight self, LVecBase3f direction)\n"
  "set_direction(const RPSpotLight self, float dx, float dy, float dz)\n";
#else
static const char *Dtool_RPSpotLight_set_direction_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3 const &RPSpotLight::get_direction(void) const
 */
static PyObject *Dtool_RPSpotLight_get_direction_150(PyObject *self, PyObject *) {
  RPSpotLight *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_RPSpotLight)) {
    return nullptr;
  }
  // 1-inline LVecBase3 const &RPSpotLight::get_direction(void) const
  LVecBase3 const *return_value = &(((*(const RPSpotLight*)local_this).get_direction)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_RPSpotLight_get_direction_150_comment =
  "C++ Interface:\n"
  "get_direction(RPSpotLight self)\n";
#else
static const char *Dtool_RPSpotLight_get_direction_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void RPSpotLight::look_at(LVecBase3 point)
 * inline void RPSpotLight::look_at(float x, float y, float z)
 */
static PyObject *Dtool_RPSpotLight_look_at_151(PyObject *self, PyObject *args, PyObject *kwds) {
  RPSpotLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPSpotLight, (void **)&local_this, "RPSpotLight.look_at")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "point")) {
        // 1-inline void RPSpotLight::look_at(LVecBase3 point)
        LVecBase3f arg_local;
        LVecBase3 *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "RPSpotLight.look_at", "LVecBase3f");
        }
        ((*local_this).look_at)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void RPSpotLight::look_at(float x, float y, float z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:look_at", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).look_at)((float)param1, (float)param2, (float)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "look_at() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "look_at(const RPSpotLight self, LVecBase3f point)\n"
      "look_at(const RPSpotLight self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RPSpotLight_look_at_151_comment =
  "C++ Interface:\n"
  "look_at(const RPSpotLight self, LVecBase3f point)\n"
  "look_at(const RPSpotLight self, float x, float y, float z)\n";
#else
static const char *Dtool_RPSpotLight_look_at_151_comment = nullptr;
#endif

static PyObject *Dtool_RPSpotLight_radius_Getter(PyObject *self, void *) {
  const RPSpotLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPSpotLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float RPSpotLight::get_radius(void) const
  float return_value = ((*(const RPSpotLight*)local_this).get_radius)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RPSpotLight_radius_Setter(PyObject *self, PyObject *arg, void *) {
  RPSpotLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPSpotLight, (void **)&local_this, "RPSpotLight.radius")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete radius attribute");
    return -1;
  }
  // 1-inline void RPSpotLight::set_radius(float radius)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_radius)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_radius(const RPSpotLight self, float radius)\n");
  }
  return -1;
}

static PyObject *Dtool_RPSpotLight_fov_Getter(PyObject *self, void *) {
  const RPSpotLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPSpotLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float RPSpotLight::get_fov(void) const
  float return_value = ((*(const RPSpotLight*)local_this).get_fov)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_RPSpotLight_fov_Setter(PyObject *self, PyObject *arg, void *) {
  RPSpotLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPSpotLight, (void **)&local_this, "RPSpotLight.fov")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete fov attribute");
    return -1;
  }
  // 1-inline void RPSpotLight::set_fov(float fov)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_fov)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_fov(const RPSpotLight self, float fov)\n");
  }
  return -1;
}

static PyObject *Dtool_RPSpotLight_direction_Getter(PyObject *self, void *) {
  const RPSpotLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_RPSpotLight, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase3 const &RPSpotLight::get_direction(void) const
  LVecBase3 const *return_value = &(((*(const RPSpotLight*)local_this).get_direction)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

static int Dtool_RPSpotLight_direction_Setter(PyObject *self, PyObject *arg, void *) {
  RPSpotLight *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RPSpotLight, (void **)&local_this, "RPSpotLight.direction")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete direction attribute");
    return -1;
  }
  // 1-inline void RPSpotLight::set_direction(LVecBase3 direction)
  LVecBase3f arg_local;
  LVecBase3 *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "RPSpotLight.set_direction", "LVecBase3f");
    return -1;
  }
  ((*local_this).set_direction)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_direction(const RPSpotLight self, LVecBase3f direction)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * RPSpotLight::RPSpotLight(void)
 */
static int Dtool_Init_RPSpotLight(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("RPSpotLight() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "RPSpotLight() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-RPSpotLight::RPSpotLight(void)
  RPSpotLight *return_value = new RPSpotLight();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RPSpotLight, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RPSpotLight()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_RPSpotLight(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RPSpotLight) {
    printf("RPSpotLight ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RPSpotLight *local_this = (RPSpotLight *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RPSpotLight) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_RPLight) {
    return (RPLight *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(RPLight *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RPSpotLight(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RPSpotLight) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_RPLight) {
    RPLight* other_this = (RPLight*)from_this;
    return (RPSpotLight*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (RPSpotLight*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for GPUCommand (GPUCommand)
 */
static PyMethodDef Dtool_Methods_GPUCommand[] = {
  {"push_int", &Dtool_GPUCommand_push_int_4, METH_O, (const char *)Dtool_GPUCommand_push_int_4_comment},
  {"pushInt", &Dtool_GPUCommand_push_int_4, METH_O, (const char *)Dtool_GPUCommand_push_int_4_comment},
  {"push_float", &Dtool_GPUCommand_push_float_5, METH_O, (const char *)Dtool_GPUCommand_push_float_5_comment},
  {"pushFloat", &Dtool_GPUCommand_push_float_5, METH_O, (const char *)Dtool_GPUCommand_push_float_5_comment},
  {"push_vec3", &Dtool_GPUCommand_push_vec3_6, METH_O, (const char *)Dtool_GPUCommand_push_vec3_6_comment},
  {"pushVec3", &Dtool_GPUCommand_push_vec3_6, METH_O, (const char *)Dtool_GPUCommand_push_vec3_6_comment},
  {"push_vec4", &Dtool_GPUCommand_push_vec4_7, METH_O, (const char *)Dtool_GPUCommand_push_vec4_7_comment},
  {"pushVec4", &Dtool_GPUCommand_push_vec4_7, METH_O, (const char *)Dtool_GPUCommand_push_vec4_7_comment},
  {"push_mat3", &Dtool_GPUCommand_push_mat3_8, METH_O, (const char *)Dtool_GPUCommand_push_mat3_8_comment},
  {"pushMat3", &Dtool_GPUCommand_push_mat3_8, METH_O, (const char *)Dtool_GPUCommand_push_mat3_8_comment},
  {"push_mat4", &Dtool_GPUCommand_push_mat4_9, METH_O, (const char *)Dtool_GPUCommand_push_mat4_9_comment},
  {"pushMat4", &Dtool_GPUCommand_push_mat4_9, METH_O, (const char *)Dtool_GPUCommand_push_mat4_9_comment},
  {"get_uses_integer_packing", &Dtool_GPUCommand_get_uses_integer_packing_10, METH_NOARGS | METH_STATIC, (const char *)Dtool_GPUCommand_get_uses_integer_packing_10_comment},
  {"getUsesIntegerPacking", &Dtool_GPUCommand_get_uses_integer_packing_10, METH_NOARGS | METH_STATIC, (const char *)Dtool_GPUCommand_get_uses_integer_packing_10_comment},
  {"write_to", (PyCFunction) &Dtool_GPUCommand_write_to_11, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GPUCommand_write_to_11_comment},
  {"writeTo", (PyCFunction) &Dtool_GPUCommand_write_to_11, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GPUCommand_write_to_11_comment},
  {"write", &Dtool_GPUCommand_write_12, METH_O, (const char *)Dtool_GPUCommand_write_12_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     GPUCommand
//////////////////
static PyObject *Dtool_Str_GPUCommand(PyObject *self) {
  GPUCommand *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GPUCommand, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_GPUCommand = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_GPUCommand = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d._rplight.GPUCommand",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GPUCommand,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GPUCommand,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_GPUCommand,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief Class for storing data to be transferred to the GPU.\n"
    " * @details This class can be seen like a packet, to be transferred to the GPU.\n"
    " *   It has a command type, which tells the GPU what to do once it recieved this\n"
    " *   \"packet\". It stores a limited amount of floating point components.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GPUCommand,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GPUCommand,
    PyType_GenericAlloc,
    Dtool_new_GPUCommand,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GPUCommand,
  Dtool_UpcastInterface_GPUCommand,
  Dtool_DowncastInterface_GPUCommand,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GPUCommand(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_GPUCommand._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_GPUCommand._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum GPUCommand::CommandType;
    PyDict_SetItemString(dict, "CMD_invalid", Dtool_WrapValue(GPUCommand::CMD_invalid));
    PyDict_SetItemString(dict, "CMDInvalid", Dtool_WrapValue(GPUCommand::CMD_invalid));
    PyDict_SetItemString(dict, "CMD_store_light", Dtool_WrapValue(GPUCommand::CMD_store_light));
    PyDict_SetItemString(dict, "CMDStoreLight", Dtool_WrapValue(GPUCommand::CMD_store_light));
    PyDict_SetItemString(dict, "CMD_remove_light", Dtool_WrapValue(GPUCommand::CMD_remove_light));
    PyDict_SetItemString(dict, "CMDRemoveLight", Dtool_WrapValue(GPUCommand::CMD_remove_light));
    PyDict_SetItemString(dict, "CMD_store_source", Dtool_WrapValue(GPUCommand::CMD_store_source));
    PyDict_SetItemString(dict, "CMDStoreSource", Dtool_WrapValue(GPUCommand::CMD_store_source));
    PyDict_SetItemString(dict, "CMD_remove_sources", Dtool_WrapValue(GPUCommand::CMD_remove_sources));
    PyDict_SetItemString(dict, "CMDRemoveSources", Dtool_WrapValue(GPUCommand::CMD_remove_sources));
    if (PyType_Ready((PyTypeObject *)&Dtool_GPUCommand) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GPUCommand)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GPUCommand);
  }
}

/**
 * Python method tables for GPUCommandList (GPUCommandList)
 */
static PyMethodDef Dtool_Methods_GPUCommandList[] = {
  {"add_command", &Dtool_GPUCommandList_add_command_16, METH_O, (const char *)Dtool_GPUCommandList_add_command_16_comment},
  {"addCommand", &Dtool_GPUCommandList_add_command_16, METH_O, (const char *)Dtool_GPUCommandList_add_command_16_comment},
  {"get_num_commands", &Dtool_GPUCommandList_get_num_commands_17, METH_NOARGS, (const char *)Dtool_GPUCommandList_get_num_commands_17_comment},
  {"getNumCommands", &Dtool_GPUCommandList_get_num_commands_17, METH_NOARGS, (const char *)Dtool_GPUCommandList_get_num_commands_17_comment},
  {"write_commands_to", (PyCFunction) &Dtool_GPUCommandList_write_commands_to_18, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GPUCommandList_write_commands_to_18_comment},
  {"writeCommandsTo", (PyCFunction) &Dtool_GPUCommandList_write_commands_to_18, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GPUCommandList_write_commands_to_18_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_GPUCommandList[] = {
  {(char *)"num_commands", &Dtool_GPUCommandList_num_commands_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_GPUCommandList = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_GPUCommandList = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d._rplight.GPUCommandList",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GPUCommandList,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GPUCommandList,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief Class to store a list of commands.\n"
    " * @details This is a class to store a list of GPUCommands. It provides\n"
    " *   functionality to only provide the a given amount of commands at one time.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GPUCommandList,
    nullptr, // tp_members
    Dtool_Properties_GPUCommandList,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GPUCommandList,
    PyType_GenericAlloc,
    Dtool_new_GPUCommandList,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GPUCommandList,
  Dtool_UpcastInterface_GPUCommandList,
  Dtool_DowncastInterface_GPUCommandList,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GPUCommandList(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_GPUCommandList._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GPUCommandList._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GPUCommandList) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GPUCommandList)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GPUCommandList);
  }
}

/**
 * Python method tables for IESDataset (IESDataset)
 */
static PyMethodDef Dtool_Methods_IESDataset[] = {
  {"set_vertical_angles", &Dtool_IESDataset_set_vertical_angles_25, METH_O, (const char *)Dtool_IESDataset_set_vertical_angles_25_comment},
  {"setVerticalAngles", &Dtool_IESDataset_set_vertical_angles_25, METH_O, (const char *)Dtool_IESDataset_set_vertical_angles_25_comment},
  {"set_horizontal_angles", &Dtool_IESDataset_set_horizontal_angles_26, METH_O, (const char *)Dtool_IESDataset_set_horizontal_angles_26_comment},
  {"setHorizontalAngles", &Dtool_IESDataset_set_horizontal_angles_26, METH_O, (const char *)Dtool_IESDataset_set_horizontal_angles_26_comment},
  {"set_candela_values", &Dtool_IESDataset_set_candela_values_27, METH_O, (const char *)Dtool_IESDataset_set_candela_values_27_comment},
  {"setCandelaValues", &Dtool_IESDataset_set_candela_values_27, METH_O, (const char *)Dtool_IESDataset_set_candela_values_27_comment},
  {"generate_dataset_texture_into", (PyCFunction) &Dtool_IESDataset_generate_dataset_texture_into_28, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_IESDataset_generate_dataset_texture_into_28_comment},
  {"generateDatasetTextureInto", (PyCFunction) &Dtool_IESDataset_generate_dataset_texture_into_28, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_IESDataset_generate_dataset_texture_into_28_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_IESDataset = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_IESDataset = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d._rplight.IESDataset",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_IESDataset,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_IESDataset,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief This class generates a LUT from IES data.\n"
    " * @details This class is used by the IESLoader to generate a LUT texture which\n"
    " *   is used in the shaders to perform IES lighting. It takes a set of vertical\n"
    " *   and horizontal angles, as well as a set of candela values, which then are\n"
    " *   lineary interpolated onto a 2D LUT Texture.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_IESDataset,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_IESDataset,
    PyType_GenericAlloc,
    Dtool_new_IESDataset,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_IESDataset,
  Dtool_UpcastInterface_IESDataset,
  Dtool_DowncastInterface_IESDataset,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_IESDataset(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_IESDataset._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_IESDataset._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_IESDataset) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(IESDataset)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_IESDataset);
  }
}

/**
 * Python method tables for RPLight (RPLight)
 */
static PyMethodDef Dtool_Methods_RPLight[] = {
  {"invalidate_shadows", &Dtool_RPLight_invalidate_shadows_33, METH_NOARGS, (const char *)Dtool_RPLight_invalidate_shadows_33_comment},
  {"invalidateShadows", &Dtool_RPLight_invalidate_shadows_33, METH_NOARGS, (const char *)Dtool_RPLight_invalidate_shadows_33_comment},
  {"set_pos", (PyCFunction) &Dtool_RPLight_set_pos_34, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RPLight_set_pos_34_comment},
  {"setPos", (PyCFunction) &Dtool_RPLight_set_pos_34, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RPLight_set_pos_34_comment},
  {"get_pos", &Dtool_RPLight_get_pos_35, METH_NOARGS, (const char *)Dtool_RPLight_get_pos_35_comment},
  {"getPos", &Dtool_RPLight_get_pos_35, METH_NOARGS, (const char *)Dtool_RPLight_get_pos_35_comment},
  {"set_color", (PyCFunction) &Dtool_RPLight_set_color_40, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RPLight_set_color_40_comment},
  {"setColor", (PyCFunction) &Dtool_RPLight_set_color_40, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RPLight_set_color_40_comment},
  {"get_color", &Dtool_RPLight_get_color_41, METH_NOARGS, (const char *)Dtool_RPLight_get_color_41_comment},
  {"getColor", &Dtool_RPLight_get_color_41, METH_NOARGS, (const char *)Dtool_RPLight_get_color_41_comment},
  {"set_color_from_temperature", &Dtool_RPLight_set_color_from_temperature_43, METH_O, (const char *)Dtool_RPLight_set_color_from_temperature_43_comment},
  {"setColorFromTemperature", &Dtool_RPLight_set_color_from_temperature_43, METH_O, (const char *)Dtool_RPLight_set_color_from_temperature_43_comment},
  {"set_energy", &Dtool_RPLight_set_energy_44, METH_O, (const char *)Dtool_RPLight_set_energy_44_comment},
  {"setEnergy", &Dtool_RPLight_set_energy_44, METH_O, (const char *)Dtool_RPLight_set_energy_44_comment},
  {"get_energy", &Dtool_RPLight_get_energy_45, METH_NOARGS, (const char *)Dtool_RPLight_get_energy_45_comment},
  {"getEnergy", &Dtool_RPLight_get_energy_45, METH_NOARGS, (const char *)Dtool_RPLight_get_energy_45_comment},
  {"get_light_type", &Dtool_RPLight_get_light_type_48, METH_NOARGS, (const char *)Dtool_RPLight_get_light_type_48_comment},
  {"getLightType", &Dtool_RPLight_get_light_type_48, METH_NOARGS, (const char *)Dtool_RPLight_get_light_type_48_comment},
  {"set_casts_shadows", (PyCFunction) &Dtool_RPLight_set_casts_shadows_50, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RPLight_set_casts_shadows_50_comment},
  {"setCastsShadows", (PyCFunction) &Dtool_RPLight_set_casts_shadows_50, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RPLight_set_casts_shadows_50_comment},
  {"get_casts_shadows", &Dtool_RPLight_get_casts_shadows_51, METH_NOARGS, (const char *)Dtool_RPLight_get_casts_shadows_51_comment},
  {"getCastsShadows", &Dtool_RPLight_get_casts_shadows_51, METH_NOARGS, (const char *)Dtool_RPLight_get_casts_shadows_51_comment},
  {"set_shadow_map_resolution", &Dtool_RPLight_set_shadow_map_resolution_54, METH_O, (const char *)Dtool_RPLight_set_shadow_map_resolution_54_comment},
  {"setShadowMapResolution", &Dtool_RPLight_set_shadow_map_resolution_54, METH_O, (const char *)Dtool_RPLight_set_shadow_map_resolution_54_comment},
  {"get_shadow_map_resolution", &Dtool_RPLight_get_shadow_map_resolution_55, METH_NOARGS, (const char *)Dtool_RPLight_get_shadow_map_resolution_55_comment},
  {"getShadowMapResolution", &Dtool_RPLight_get_shadow_map_resolution_55, METH_NOARGS, (const char *)Dtool_RPLight_get_shadow_map_resolution_55_comment},
  {"set_ies_profile", &Dtool_RPLight_set_ies_profile_57, METH_O, (const char *)Dtool_RPLight_set_ies_profile_57_comment},
  {"setIesProfile", &Dtool_RPLight_set_ies_profile_57, METH_O, (const char *)Dtool_RPLight_set_ies_profile_57_comment},
  {"get_ies_profile", &Dtool_RPLight_get_ies_profile_58, METH_NOARGS, (const char *)Dtool_RPLight_get_ies_profile_58_comment},
  {"getIesProfile", &Dtool_RPLight_get_ies_profile_58, METH_NOARGS, (const char *)Dtool_RPLight_get_ies_profile_58_comment},
  {"has_ies_profile", &Dtool_RPLight_has_ies_profile_59, METH_NOARGS, (const char *)Dtool_RPLight_has_ies_profile_59_comment},
  {"hasIesProfile", &Dtool_RPLight_has_ies_profile_59, METH_NOARGS, (const char *)Dtool_RPLight_has_ies_profile_59_comment},
  {"clear_ies_profile", &Dtool_RPLight_clear_ies_profile_60, METH_NOARGS, (const char *)Dtool_RPLight_clear_ies_profile_60_comment},
  {"clearIesProfile", &Dtool_RPLight_clear_ies_profile_60, METH_NOARGS, (const char *)Dtool_RPLight_clear_ies_profile_60_comment},
  {"set_near_plane", &Dtool_RPLight_set_near_plane_63, METH_O, (const char *)Dtool_RPLight_set_near_plane_63_comment},
  {"setNearPlane", &Dtool_RPLight_set_near_plane_63, METH_O, (const char *)Dtool_RPLight_set_near_plane_63_comment},
  {"get_near_plane", &Dtool_RPLight_get_near_plane_64, METH_NOARGS, (const char *)Dtool_RPLight_get_near_plane_64_comment},
  {"getNearPlane", &Dtool_RPLight_get_near_plane_64, METH_NOARGS, (const char *)Dtool_RPLight_get_near_plane_64_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_RPLight[] = {
  {(char *)"pos", &Dtool_RPLight_pos_Getter, &Dtool_RPLight_pos_Setter, nullptr, nullptr},
  {(char *)"color", &Dtool_RPLight_color_Getter, &Dtool_RPLight_color_Setter, nullptr, nullptr},
  {(char *)"energy", &Dtool_RPLight_energy_Getter, &Dtool_RPLight_energy_Setter, nullptr, nullptr},
  {(char *)"light_type", &Dtool_RPLight_light_type_Getter, nullptr, nullptr, nullptr},
  {(char *)"casts_shadows", &Dtool_RPLight_casts_shadows_Getter, &Dtool_RPLight_casts_shadows_Setter, nullptr, nullptr},
  {(char *)"shadow_map_resolution", &Dtool_RPLight_shadow_map_resolution_Getter, &Dtool_RPLight_shadow_map_resolution_Setter, nullptr, nullptr},
  {(char *)"ies_profile", &Dtool_RPLight_ies_profile_Getter, &Dtool_RPLight_ies_profile_Setter, nullptr, nullptr},
  {(char *)"near_plane", &Dtool_RPLight_near_plane_Getter, &Dtool_RPLight_near_plane_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_RPLight = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RPLight = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_RPLight = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_RPLight = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_RPLight = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_RPLight = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d._rplight.RPLight",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RPLight,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_RPLight,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_RPLight,
    &Dtool_SequenceMethods_RPLight,
    &Dtool_MappingMethods_RPLight,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_RPLight,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief Base class for Lights\n"
    " * @details This is the base class for all lights in the render pipeline. It\n"
    " *   stores common properties, and provides methods to modify these.\n"
    " *   It also defines some interface functions which subclasses have to implement.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RPLight,
    nullptr, // tp_members
    Dtool_Properties_RPLight,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RPLight,
    PyType_GenericAlloc,
    Dtool_new_RPLight,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RPLight,
  Dtool_UpcastInterface_RPLight,
  Dtool_DowncastInterface_RPLight,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_RPLight(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_RPLight._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_RPLight._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_RPLight._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum RPLight::LightType;
    PyDict_SetItemString(dict, "LT_empty", Dtool_WrapValue(RPLight::LT_empty));
    PyDict_SetItemString(dict, "LTEmpty", Dtool_WrapValue(RPLight::LT_empty));
    PyDict_SetItemString(dict, "LT_point_light", Dtool_WrapValue(RPLight::LT_point_light));
    PyDict_SetItemString(dict, "LTPointLight", Dtool_WrapValue(RPLight::LT_point_light));
    PyDict_SetItemString(dict, "LT_spot_light", Dtool_WrapValue(RPLight::LT_spot_light));
    PyDict_SetItemString(dict, "LTSpotLight", Dtool_WrapValue(RPLight::LT_spot_light));
    if (PyType_Ready((PyTypeObject *)&Dtool_RPLight) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RPLight)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RPLight);
  }
}

/**
 * Python method tables for ShadowAtlas (ShadowAtlas)
 */
static PyMethodDef Dtool_Methods_ShadowAtlas[] = {
  {"get_num_used_tiles", &Dtool_ShadowAtlas_get_num_used_tiles_69, METH_NOARGS, (const char *)Dtool_ShadowAtlas_get_num_used_tiles_69_comment},
  {"getNumUsedTiles", &Dtool_ShadowAtlas_get_num_used_tiles_69, METH_NOARGS, (const char *)Dtool_ShadowAtlas_get_num_used_tiles_69_comment},
  {"get_coverage", &Dtool_ShadowAtlas_get_coverage_70, METH_NOARGS, (const char *)Dtool_ShadowAtlas_get_coverage_70_comment},
  {"getCoverage", &Dtool_ShadowAtlas_get_coverage_70, METH_NOARGS, (const char *)Dtool_ShadowAtlas_get_coverage_70_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ShadowAtlas[] = {
  {(char *)"num_used_tiles", &Dtool_ShadowAtlas_num_used_tiles_Getter, nullptr, nullptr, nullptr},
  {(char *)"coverage", &Dtool_ShadowAtlas_coverage_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ShadowAtlas = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ShadowAtlas = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d._rplight.ShadowAtlas",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ShadowAtlas,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ShadowAtlas,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief Class which manages distributing shadow maps in an atlas.\n"
    " * @details This class manages the shadow atlas. It handles finding and reserving\n"
    " *   space for new shadow maps.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ShadowAtlas,
    nullptr, // tp_members
    Dtool_Properties_ShadowAtlas,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ShadowAtlas,
    PyType_GenericAlloc,
    Dtool_new_ShadowAtlas,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShadowAtlas,
  Dtool_UpcastInterface_ShadowAtlas,
  Dtool_DowncastInterface_ShadowAtlas,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ShadowAtlas(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ShadowAtlas._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ShadowAtlas._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ShadowAtlas) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShadowAtlas)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShadowAtlas);
  }
}

/**
 * Python method tables for TagStateManager (TagStateManager)
 */
static PyMethodDef Dtool_Methods_TagStateManager[] = {
  {"apply_state", (PyCFunction) &Dtool_TagStateManager_apply_state_76, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TagStateManager_apply_state_76_comment},
  {"applyState", (PyCFunction) &Dtool_TagStateManager_apply_state_76, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TagStateManager_apply_state_76_comment},
  {"cleanup_states", &Dtool_TagStateManager_cleanup_states_77, METH_NOARGS, (const char *)Dtool_TagStateManager_cleanup_states_77_comment},
  {"cleanupStates", &Dtool_TagStateManager_cleanup_states_77, METH_NOARGS, (const char *)Dtool_TagStateManager_cleanup_states_77_comment},
  {"register_camera", (PyCFunction) &Dtool_TagStateManager_register_camera_78, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TagStateManager_register_camera_78_comment},
  {"registerCamera", (PyCFunction) &Dtool_TagStateManager_register_camera_78, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TagStateManager_register_camera_78_comment},
  {"unregister_camera", (PyCFunction) &Dtool_TagStateManager_unregister_camera_79, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TagStateManager_unregister_camera_79_comment},
  {"unregisterCamera", (PyCFunction) &Dtool_TagStateManager_unregister_camera_79, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TagStateManager_unregister_camera_79_comment},
  {"get_mask", &Dtool_TagStateManager_get_mask_80, METH_O, (const char *)Dtool_TagStateManager_get_mask_80_comment},
  {"getMask", &Dtool_TagStateManager_get_mask_80, METH_O, (const char *)Dtool_TagStateManager_get_mask_80_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TagStateManager = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TagStateManager = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d._rplight.TagStateManager",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TagStateManager,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TagStateManager,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief This class handles all different tag states\n"
    " * @details The TagStateManager stores a list of RenderStates assigned to different\n"
    " *   steps in the pipeline. For example, there are a list of shadow states, which\n"
    " *   are applied whenever objects are rendered from a shadow camera.\n"
    " *\n"
    " *   The Manager also stores a list of all cameras used in the different stages,\n"
    " *   to keep track of the states used and to be able to attach new states.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TagStateManager,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TagStateManager,
    PyType_GenericAlloc,
    Dtool_new_TagStateManager,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TagStateManager,
  Dtool_UpcastInterface_TagStateManager,
  Dtool_DowncastInterface_TagStateManager,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TagStateManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TagStateManager._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TagStateManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TagStateManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TagStateManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TagStateManager);
  }
}

/**
 * Python method tables for ShadowManager (ShadowManager)
 */
static PyMethodDef Dtool_Methods_ShadowManager[] = {
  {"set_max_updates", &Dtool_ShadowManager_set_max_updates_83, METH_O, (const char *)Dtool_ShadowManager_set_max_updates_83_comment},
  {"setMaxUpdates", &Dtool_ShadowManager_set_max_updates_83, METH_O, (const char *)Dtool_ShadowManager_set_max_updates_83_comment},
  {"set_scene", &Dtool_ShadowManager_set_scene_84, METH_O, (const char *)Dtool_ShadowManager_set_scene_84_comment},
  {"setScene", &Dtool_ShadowManager_set_scene_84, METH_O, (const char *)Dtool_ShadowManager_set_scene_84_comment},
  {"set_tag_state_manager", &Dtool_ShadowManager_set_tag_state_manager_85, METH_O, (const char *)Dtool_ShadowManager_set_tag_state_manager_85_comment},
  {"setTagStateManager", &Dtool_ShadowManager_set_tag_state_manager_85, METH_O, (const char *)Dtool_ShadowManager_set_tag_state_manager_85_comment},
  {"set_atlas_graphics_output", &Dtool_ShadowManager_set_atlas_graphics_output_86, METH_O, (const char *)Dtool_ShadowManager_set_atlas_graphics_output_86_comment},
  {"setAtlasGraphicsOutput", &Dtool_ShadowManager_set_atlas_graphics_output_86, METH_O, (const char *)Dtool_ShadowManager_set_atlas_graphics_output_86_comment},
  {"set_atlas_size", &Dtool_ShadowManager_set_atlas_size_87, METH_O, (const char *)Dtool_ShadowManager_set_atlas_size_87_comment},
  {"setAtlasSize", &Dtool_ShadowManager_set_atlas_size_87, METH_O, (const char *)Dtool_ShadowManager_set_atlas_size_87_comment},
  {"get_atlas_size", &Dtool_ShadowManager_get_atlas_size_88, METH_NOARGS, (const char *)Dtool_ShadowManager_get_atlas_size_88_comment},
  {"getAtlasSize", &Dtool_ShadowManager_get_atlas_size_88, METH_NOARGS, (const char *)Dtool_ShadowManager_get_atlas_size_88_comment},
  {"get_num_update_slots_left", &Dtool_ShadowManager_get_num_update_slots_left_90, METH_NOARGS, (const char *)Dtool_ShadowManager_get_num_update_slots_left_90_comment},
  {"getNumUpdateSlotsLeft", &Dtool_ShadowManager_get_num_update_slots_left_90, METH_NOARGS, (const char *)Dtool_ShadowManager_get_num_update_slots_left_90_comment},
  {"get_atlas", &Dtool_ShadowManager_get_atlas_92, METH_NOARGS, (const char *)Dtool_ShadowManager_get_atlas_92_comment},
  {"getAtlas", &Dtool_ShadowManager_get_atlas_92, METH_NOARGS, (const char *)Dtool_ShadowManager_get_atlas_92_comment},
  {"init", &Dtool_ShadowManager_init_95, METH_NOARGS, (const char *)Dtool_ShadowManager_init_95_comment},
  {"update", &Dtool_ShadowManager_update_96, METH_NOARGS, (const char *)Dtool_ShadowManager_update_96_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ShadowManager[] = {
  {(char *)"atlas_size", &Dtool_ShadowManager_atlas_size_Getter, &Dtool_ShadowManager_atlas_size_Setter, nullptr, nullptr},
  {(char *)"num_update_slots_left", &Dtool_ShadowManager_num_update_slots_left_Getter, nullptr, nullptr, nullptr},
  {(char *)"atlas", &Dtool_ShadowManager_atlas_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ShadowManager = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ShadowManager = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ShadowManager = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ShadowManager = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ShadowManager = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ShadowManager = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d._rplight.ShadowManager",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ShadowManager,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ShadowManager,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ShadowManager,
    &Dtool_SequenceMethods_ShadowManager,
    &Dtool_MappingMethods_ShadowManager,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ShadowManager,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ShadowManager,
    nullptr, // tp_members
    Dtool_Properties_ShadowManager,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ShadowManager,
    PyType_GenericAlloc,
    Dtool_new_ShadowManager,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShadowManager,
  Dtool_UpcastInterface_ShadowManager,
  Dtool_DowncastInterface_ShadowManager,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ShadowManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_ShadowManager._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_ShadowManager._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ShadowManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ShadowManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShadowManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShadowManager);
  }
}

/**
 * Python method tables for InternalLightManager (InternalLightManager)
 */
static PyMethodDef Dtool_Methods_InternalLightManager[] = {
  {"add_light", &Dtool_InternalLightManager_add_light_99, METH_O, (const char *)Dtool_InternalLightManager_add_light_99_comment},
  {"addLight", &Dtool_InternalLightManager_add_light_99, METH_O, (const char *)Dtool_InternalLightManager_add_light_99_comment},
  {"remove_light", &Dtool_InternalLightManager_remove_light_100, METH_O, (const char *)Dtool_InternalLightManager_remove_light_100_comment},
  {"removeLight", &Dtool_InternalLightManager_remove_light_100, METH_O, (const char *)Dtool_InternalLightManager_remove_light_100_comment},
  {"update", &Dtool_InternalLightManager_update_101, METH_NOARGS, (const char *)Dtool_InternalLightManager_update_101_comment},
  {"set_camera_pos", &Dtool_InternalLightManager_set_camera_pos_102, METH_O, (const char *)Dtool_InternalLightManager_set_camera_pos_102_comment},
  {"setCameraPos", &Dtool_InternalLightManager_set_camera_pos_102, METH_O, (const char *)Dtool_InternalLightManager_set_camera_pos_102_comment},
  {"set_shadow_update_distance", &Dtool_InternalLightManager_set_shadow_update_distance_103, METH_O, (const char *)Dtool_InternalLightManager_set_shadow_update_distance_103_comment},
  {"setShadowUpdateDistance", &Dtool_InternalLightManager_set_shadow_update_distance_103, METH_O, (const char *)Dtool_InternalLightManager_set_shadow_update_distance_103_comment},
  {"get_max_light_index", &Dtool_InternalLightManager_get_max_light_index_104, METH_NOARGS, (const char *)Dtool_InternalLightManager_get_max_light_index_104_comment},
  {"getMaxLightIndex", &Dtool_InternalLightManager_get_max_light_index_104, METH_NOARGS, (const char *)Dtool_InternalLightManager_get_max_light_index_104_comment},
  {"get_num_lights", &Dtool_InternalLightManager_get_num_lights_106, METH_NOARGS, (const char *)Dtool_InternalLightManager_get_num_lights_106_comment},
  {"getNumLights", &Dtool_InternalLightManager_get_num_lights_106, METH_NOARGS, (const char *)Dtool_InternalLightManager_get_num_lights_106_comment},
  {"get_num_shadow_sources", &Dtool_InternalLightManager_get_num_shadow_sources_108, METH_NOARGS, (const char *)Dtool_InternalLightManager_get_num_shadow_sources_108_comment},
  {"getNumShadowSources", &Dtool_InternalLightManager_get_num_shadow_sources_108, METH_NOARGS, (const char *)Dtool_InternalLightManager_get_num_shadow_sources_108_comment},
  {"set_shadow_manager", &Dtool_InternalLightManager_set_shadow_manager_110, METH_O, (const char *)Dtool_InternalLightManager_set_shadow_manager_110_comment},
  {"setShadowManager", &Dtool_InternalLightManager_set_shadow_manager_110, METH_O, (const char *)Dtool_InternalLightManager_set_shadow_manager_110_comment},
  {"get_shadow_manager", &Dtool_InternalLightManager_get_shadow_manager_111, METH_NOARGS, (const char *)Dtool_InternalLightManager_get_shadow_manager_111_comment},
  {"getShadowManager", &Dtool_InternalLightManager_get_shadow_manager_111, METH_NOARGS, (const char *)Dtool_InternalLightManager_get_shadow_manager_111_comment},
  {"set_command_list", &Dtool_InternalLightManager_set_command_list_114, METH_O, (const char *)Dtool_InternalLightManager_set_command_list_114_comment},
  {"setCommandList", &Dtool_InternalLightManager_set_command_list_114, METH_O, (const char *)Dtool_InternalLightManager_set_command_list_114_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_InternalLightManager[] = {
  {(char *)"max_light_index", &Dtool_InternalLightManager_max_light_index_Getter, nullptr, nullptr, nullptr},
  {(char *)"num_lights", &Dtool_InternalLightManager_num_lights_Getter, nullptr, nullptr, nullptr},
  {(char *)"num_shadow_sources", &Dtool_InternalLightManager_num_shadow_sources_Getter, nullptr, nullptr, nullptr},
  {(char *)"shadow_manager", &Dtool_InternalLightManager_shadow_manager_Getter, &Dtool_InternalLightManager_shadow_manager_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_InternalLightManager = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_InternalLightManager = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d._rplight.InternalLightManager",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_InternalLightManager,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_InternalLightManager,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief Internal class used for handling lights and shadows.\n"
    " * @details This is the internal class used by the pipeline to handle all\n"
    " *   lights and shadows. It stores references to the lights, manages handling\n"
    " *   the light and shadow slots, and also communicates with the GPU with the\n"
    " *   GPUCommandQueue to store light and shadow source data.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_InternalLightManager,
    nullptr, // tp_members
    Dtool_Properties_InternalLightManager,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_InternalLightManager,
    PyType_GenericAlloc,
    Dtool_new_InternalLightManager,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_InternalLightManager,
  Dtool_UpcastInterface_InternalLightManager,
  Dtool_DowncastInterface_InternalLightManager,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_InternalLightManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_InternalLightManager._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_InternalLightManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_InternalLightManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(InternalLightManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_InternalLightManager);
  }
}

/**
 * Python method tables for RPPointLight (RPPointLight)
 */
static PyMethodDef Dtool_Methods_RPPointLight[] = {
  {"set_radius", &Dtool_RPPointLight_set_radius_118, METH_O, (const char *)Dtool_RPPointLight_set_radius_118_comment},
  {"setRadius", &Dtool_RPPointLight_set_radius_118, METH_O, (const char *)Dtool_RPPointLight_set_radius_118_comment},
  {"get_radius", &Dtool_RPPointLight_get_radius_119, METH_NOARGS, (const char *)Dtool_RPPointLight_get_radius_119_comment},
  {"getRadius", &Dtool_RPPointLight_get_radius_119, METH_NOARGS, (const char *)Dtool_RPPointLight_get_radius_119_comment},
  {"set_inner_radius", &Dtool_RPPointLight_set_inner_radius_121, METH_O, (const char *)Dtool_RPPointLight_set_inner_radius_121_comment},
  {"setInnerRadius", &Dtool_RPPointLight_set_inner_radius_121, METH_O, (const char *)Dtool_RPPointLight_set_inner_radius_121_comment},
  {"get_inner_radius", &Dtool_RPPointLight_get_inner_radius_122, METH_NOARGS, (const char *)Dtool_RPPointLight_get_inner_radius_122_comment},
  {"getInnerRadius", &Dtool_RPPointLight_get_inner_radius_122, METH_NOARGS, (const char *)Dtool_RPPointLight_get_inner_radius_122_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_RPPointLight[] = {
  {(char *)"radius", &Dtool_RPPointLight_radius_Getter, &Dtool_RPPointLight_radius_Setter, nullptr, nullptr},
  {(char *)"inner_radius", &Dtool_RPPointLight_inner_radius_Getter, &Dtool_RPPointLight_inner_radius_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_RPPointLight = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RPPointLight = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_RPPointLight = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_RPPointLight = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_RPPointLight = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_RPPointLight = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d._rplight.RPPointLight",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RPPointLight,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_RPPointLight,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_RPPointLight,
    &Dtool_SequenceMethods_RPPointLight,
    &Dtool_MappingMethods_RPPointLight,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_RPPointLight,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief PointLight class\n"
    " * @details This represents a point light, a light which has a position and\n"
    " *   radius. Checkout the RenderPipeline documentation for more information\n"
    " *   about this type of light.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RPPointLight,
    nullptr, // tp_members
    Dtool_Properties_RPPointLight,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RPPointLight,
    PyType_GenericAlloc,
    Dtool_new_RPPointLight,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RPPointLight,
  Dtool_UpcastInterface_RPPointLight,
  Dtool_DowncastInterface_RPPointLight,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_RPPointLight(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RPLight(nullptr);
    Dtool_RPPointLight._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RPLight);
    Dtool_RPPointLight._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_RPPointLight._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RPPointLight) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RPPointLight)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RPPointLight);
  }
}

/**
 * Python method tables for PSSMCameraRig (PSSMCameraRig)
 */
static PyMethodDef Dtool_Methods_PSSMCameraRig[] = {
  {"set_pssm_distance", &Dtool_PSSMCameraRig_set_pssm_distance_128, METH_O, (const char *)Dtool_PSSMCameraRig_set_pssm_distance_128_comment},
  {"setPssmDistance", &Dtool_PSSMCameraRig_set_pssm_distance_128, METH_O, (const char *)Dtool_PSSMCameraRig_set_pssm_distance_128_comment},
  {"set_sun_distance", &Dtool_PSSMCameraRig_set_sun_distance_129, METH_O, (const char *)Dtool_PSSMCameraRig_set_sun_distance_129_comment},
  {"setSunDistance", &Dtool_PSSMCameraRig_set_sun_distance_129, METH_O, (const char *)Dtool_PSSMCameraRig_set_sun_distance_129_comment},
  {"set_use_fixed_film_size", &Dtool_PSSMCameraRig_set_use_fixed_film_size_130, METH_O, (const char *)Dtool_PSSMCameraRig_set_use_fixed_film_size_130_comment},
  {"setUseFixedFilmSize", &Dtool_PSSMCameraRig_set_use_fixed_film_size_130, METH_O, (const char *)Dtool_PSSMCameraRig_set_use_fixed_film_size_130_comment},
  {"set_resolution", &Dtool_PSSMCameraRig_set_resolution_131, METH_O, (const char *)Dtool_PSSMCameraRig_set_resolution_131_comment},
  {"setResolution", &Dtool_PSSMCameraRig_set_resolution_131, METH_O, (const char *)Dtool_PSSMCameraRig_set_resolution_131_comment},
  {"set_use_stable_csm", &Dtool_PSSMCameraRig_set_use_stable_csm_132, METH_O, (const char *)Dtool_PSSMCameraRig_set_use_stable_csm_132_comment},
  {"setUseStableCsm", &Dtool_PSSMCameraRig_set_use_stable_csm_132, METH_O, (const char *)Dtool_PSSMCameraRig_set_use_stable_csm_132_comment},
  {"set_logarithmic_factor", &Dtool_PSSMCameraRig_set_logarithmic_factor_133, METH_O, (const char *)Dtool_PSSMCameraRig_set_logarithmic_factor_133_comment},
  {"setLogarithmicFactor", &Dtool_PSSMCameraRig_set_logarithmic_factor_133, METH_O, (const char *)Dtool_PSSMCameraRig_set_logarithmic_factor_133_comment},
  {"set_border_bias", &Dtool_PSSMCameraRig_set_border_bias_134, METH_O, (const char *)Dtool_PSSMCameraRig_set_border_bias_134_comment},
  {"setBorderBias", &Dtool_PSSMCameraRig_set_border_bias_134, METH_O, (const char *)Dtool_PSSMCameraRig_set_border_bias_134_comment},
  {"update", (PyCFunction) &Dtool_PSSMCameraRig_update_135, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PSSMCameraRig_update_135_comment},
  {"reset_film_size_cache", &Dtool_PSSMCameraRig_reset_film_size_cache_136, METH_NOARGS, (const char *)Dtool_PSSMCameraRig_reset_film_size_cache_136_comment},
  {"resetFilmSizeCache", &Dtool_PSSMCameraRig_reset_film_size_cache_136, METH_NOARGS, (const char *)Dtool_PSSMCameraRig_reset_film_size_cache_136_comment},
  {"get_camera", &Dtool_PSSMCameraRig_get_camera_137, METH_O, (const char *)Dtool_PSSMCameraRig_get_camera_137_comment},
  {"getCamera", &Dtool_PSSMCameraRig_get_camera_137, METH_O, (const char *)Dtool_PSSMCameraRig_get_camera_137_comment},
  {"reparent_to", &Dtool_PSSMCameraRig_reparent_to_138, METH_O, (const char *)Dtool_PSSMCameraRig_reparent_to_138_comment},
  {"reparentTo", &Dtool_PSSMCameraRig_reparent_to_138, METH_O, (const char *)Dtool_PSSMCameraRig_reparent_to_138_comment},
  {"get_mvp_array", &Dtool_PSSMCameraRig_get_mvp_array_139, METH_NOARGS, (const char *)Dtool_PSSMCameraRig_get_mvp_array_139_comment},
  {"getMvpArray", &Dtool_PSSMCameraRig_get_mvp_array_139, METH_NOARGS, (const char *)Dtool_PSSMCameraRig_get_mvp_array_139_comment},
  {"get_nearfar_array", &Dtool_PSSMCameraRig_get_nearfar_array_140, METH_NOARGS, (const char *)Dtool_PSSMCameraRig_get_nearfar_array_140_comment},
  {"getNearfarArray", &Dtool_PSSMCameraRig_get_nearfar_array_140, METH_NOARGS, (const char *)Dtool_PSSMCameraRig_get_nearfar_array_140_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PSSMCameraRig = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_PSSMCameraRig = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d._rplight.PSSMCameraRig",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PSSMCameraRig,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PSSMCameraRig,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief Main class used for handling PSSM\n"
    " * @details This is the main class for supporting PSSM, it is used by the PSSM\n"
    " *   plugin to compute the position of the splits.\n"
    " *\n"
    " *   It supports handling a varying amount of cameras, and fitting those cameras\n"
    " *   into the main camera frustum, to render distant shadows. It also supports\n"
    " *   various optimizations for fitting the frustum, e.g. rotating the sources\n"
    " *   to get a better coverage.\n"
    " *\n"
    " *   It also provides methods to get arrays of data about the used cameras\n"
    " *   view-projection matrices and their near and far plane, which is required for\n"
    " *   processing the data in the shadow sampling shader.\n"
    " *\n"
    " *   In this class, there is often referred to \"Splits\" or also called \"Cascades\".\n"
    " *   These denote the different cameras which are used to split the frustum,\n"
    " *   and are a common term related to the PSSM algorithm.\n"
    " *\n"
    " *   To understand the functionality of this class, a detailed knowledge of the\n"
    " *   PSSM algorithm is helpful.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PSSMCameraRig,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PSSMCameraRig,
    PyType_GenericAlloc,
    Dtool_new_PSSMCameraRig,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PSSMCameraRig,
  Dtool_UpcastInterface_PSSMCameraRig,
  Dtool_DowncastInterface_PSSMCameraRig,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PSSMCameraRig(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PSSMCameraRig._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PSSMCameraRig._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PSSMCameraRig) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PSSMCameraRig)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PSSMCameraRig);
  }
}

/**
 * Python method tables for RPSpotLight (RPSpotLight)
 */
static PyMethodDef Dtool_Methods_RPSpotLight[] = {
  {"set_radius", &Dtool_RPSpotLight_set_radius_143, METH_O, (const char *)Dtool_RPSpotLight_set_radius_143_comment},
  {"setRadius", &Dtool_RPSpotLight_set_radius_143, METH_O, (const char *)Dtool_RPSpotLight_set_radius_143_comment},
  {"get_radius", &Dtool_RPSpotLight_get_radius_144, METH_NOARGS, (const char *)Dtool_RPSpotLight_get_radius_144_comment},
  {"getRadius", &Dtool_RPSpotLight_get_radius_144, METH_NOARGS, (const char *)Dtool_RPSpotLight_get_radius_144_comment},
  {"set_fov", &Dtool_RPSpotLight_set_fov_146, METH_O, (const char *)Dtool_RPSpotLight_set_fov_146_comment},
  {"setFov", &Dtool_RPSpotLight_set_fov_146, METH_O, (const char *)Dtool_RPSpotLight_set_fov_146_comment},
  {"get_fov", &Dtool_RPSpotLight_get_fov_147, METH_NOARGS, (const char *)Dtool_RPSpotLight_get_fov_147_comment},
  {"getFov", &Dtool_RPSpotLight_get_fov_147, METH_NOARGS, (const char *)Dtool_RPSpotLight_get_fov_147_comment},
  {"set_direction", (PyCFunction) &Dtool_RPSpotLight_set_direction_149, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RPSpotLight_set_direction_149_comment},
  {"setDirection", (PyCFunction) &Dtool_RPSpotLight_set_direction_149, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RPSpotLight_set_direction_149_comment},
  {"get_direction", &Dtool_RPSpotLight_get_direction_150, METH_NOARGS, (const char *)Dtool_RPSpotLight_get_direction_150_comment},
  {"getDirection", &Dtool_RPSpotLight_get_direction_150, METH_NOARGS, (const char *)Dtool_RPSpotLight_get_direction_150_comment},
  {"look_at", (PyCFunction) &Dtool_RPSpotLight_look_at_151, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RPSpotLight_look_at_151_comment},
  {"lookAt", (PyCFunction) &Dtool_RPSpotLight_look_at_151, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_RPSpotLight_look_at_151_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_RPSpotLight[] = {
  {(char *)"radius", &Dtool_RPSpotLight_radius_Getter, &Dtool_RPSpotLight_radius_Setter, nullptr, nullptr},
  {(char *)"fov", &Dtool_RPSpotLight_fov_Getter, &Dtool_RPSpotLight_fov_Setter, nullptr, nullptr},
  {(char *)"direction", &Dtool_RPSpotLight_direction_Getter, &Dtool_RPSpotLight_direction_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_RPSpotLight = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RPSpotLight = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_RPSpotLight = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_RPSpotLight = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_RPSpotLight = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_RPSpotLight = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d._rplight.RPSpotLight",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RPSpotLight,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_RPSpotLight,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_RPSpotLight,
    &Dtool_SequenceMethods_RPSpotLight,
    &Dtool_MappingMethods_RPSpotLight,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_RPSpotLight,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief SpotLight class\n"
    " * @details This represents a spot light, a light which has a position, radius,\n"
    " *   direction and FoV. Checkout the RenderPipeline documentation for more\n"
    " *   information about this type of light.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RPSpotLight,
    nullptr, // tp_members
    Dtool_Properties_RPSpotLight,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RPSpotLight,
    PyType_GenericAlloc,
    Dtool_new_RPSpotLight,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RPSpotLight,
  Dtool_UpcastInterface_RPSpotLight,
  Dtool_DowncastInterface_RPSpotLight,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_RPSpotLight(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_RPLight(nullptr);
    Dtool_RPSpotLight._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_RPLight);
    Dtool_RPSpotLight._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_RPSpotLight._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RPSpotLight) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RPSpotLight)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RPSpotLight);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3rplight_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
}

void Dtool_libp3rplight_BuildInstants(PyObject *module) {
  (void) module;
  // GPUCommand
  Dtool_PyModuleClassInit_GPUCommand(module);
  PyModule_AddObject(module, "GPUCommand", (PyObject *)&Dtool_GPUCommand);
  // GPUCommandList
  Dtool_PyModuleClassInit_GPUCommandList(module);
  PyModule_AddObject(module, "GPUCommandList", (PyObject *)&Dtool_GPUCommandList);
  // IESDataset
  Dtool_PyModuleClassInit_IESDataset(module);
  PyModule_AddObject(module, "IESDataset", (PyObject *)&Dtool_IESDataset);
  // RPLight
  Dtool_PyModuleClassInit_RPLight(module);
  PyModule_AddObject(module, "RPLight", (PyObject *)&Dtool_RPLight);
  // ShadowAtlas
  Dtool_PyModuleClassInit_ShadowAtlas(module);
  PyModule_AddObject(module, "ShadowAtlas", (PyObject *)&Dtool_ShadowAtlas);
  // TagStateManager
  Dtool_PyModuleClassInit_TagStateManager(module);
  PyModule_AddObject(module, "TagStateManager", (PyObject *)&Dtool_TagStateManager);
  // ShadowManager
  Dtool_PyModuleClassInit_ShadowManager(module);
  PyModule_AddObject(module, "ShadowManager", (PyObject *)&Dtool_ShadowManager);
  // InternalLightManager
  Dtool_PyModuleClassInit_InternalLightManager(module);
  PyModule_AddObject(module, "InternalLightManager", (PyObject *)&Dtool_InternalLightManager);
  // RPPointLight
  Dtool_PyModuleClassInit_RPPointLight(module);
  PyModule_AddObject(module, "RPPointLight", (PyObject *)&Dtool_RPPointLight);
  // PSSMCameraRig
  Dtool_PyModuleClassInit_PSSMCameraRig(module);
  PyModule_AddObject(module, "PSSMCameraRig", (PyObject *)&Dtool_PSSMCameraRig);
  // RPSpotLight
  Dtool_PyModuleClassInit_RPSpotLight(module);
  PyModule_AddObject(module, "RPSpotLight", (PyObject *)&Dtool_RPSpotLight);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3rplight_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3rplight_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583615453,  /* file_identifier */
  "libp3rplight",  /* library_name */
  "_K37",  /* library_hash_name */
  "panda3d._rplight",  /* module_name */
  "libp3rplight.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  356  /* next_index */
};

Configure(_in_configure_libp3rplight);
ConfigureFn(_in_configure_libp3rplight) {
  interrogate_request_module(&_in_module_def);
}

