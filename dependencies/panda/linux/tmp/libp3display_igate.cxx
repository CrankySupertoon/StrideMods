/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/display -Ipanda/src/display -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3display_igate.cxx -od built/pandac/input/libp3display.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/display -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3display callbackGraphicsWindow.h config_display.h displayInformation.h displayRegion.h displayRegionCullCallbackData.h displayRegionDrawCallbackData.h displaySearchParameters.h drawableRegion.h frameBufferProperties.h get_x11.h graphicsBuffer.h graphicsDevice.h graphicsEngine.h graphicsOutput.h graphicsPipe.h graphicsPipeSelection.h graphicsStateGuardian.h graphicsStateGuardian_ext.h graphicsThreadingModel.h graphicsWindow.h graphicsWindowInputDevice.h graphicsWindowProc.h graphicsWindowProcCallbackData.h graphicsWindow_ext.h mouseAndKeyboard.h nativeWindowHandle.h p3display_composite1.cxx p3display_composite2.cxx p3display_ext_composite.cxx pStatGPUTimer.h parasiteBuffer.h post_x11_include.h pre_x11_include.h pythonGraphicsWindowProc.h standardMunger.h stereoDisplayRegion.h subprocessWindow.h subprocessWindowBuffer.h touchInfo.h windowHandle.h windowProperties.h windowProperties_ext.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include <assert.h>
#include "buttonEventList.h"
#include "callbackData.h"
#include "callbackGraphicsWindow.h"
#include "conditionVar.h"
#include "config_display.h"
#include "dataNode.h"
#include "displayInformation.h"
#include "displayRegion.h"
#include "displayRegionCullCallbackData.h"
#include "displayRegionDrawCallbackData.h"
#include "displaySearchParameters.h"
#include "drawableRegion.h"
#include "dtoolbase.h"
#include "extension.h"
#include "frameBufferProperties.h"
#include "get_x11.h"
#include "graphicsBuffer.h"
#include "graphicsDevice.h"
#include "graphicsEngine.h"
#include "graphicsOutput.h"
#include "graphicsPipe.h"
#include "graphicsPipeSelection.h"
#include "graphicsStateGuardian.h"
#include "graphicsStateGuardian_ext.h"
#include "graphicsThreadingModel.h"
#include "graphicsWindow.h"
#include "graphicsWindowInputDevice.h"
#include "graphicsWindowProc.h"
#include "graphicsWindowProcCallbackData.h"
#include "graphicsWindow_ext.h"
#include "indirectLess.h"
#include "lightMutex.h"
#include "lightReMutex.h"
#include "linmath_events.h"
#include "loader.h"
#include "mouseAndKeyboard.h"
#include "nativeWindowHandle.h"
#include "ordered_vector.h"
#include "pStatCollector.h"
#include "pStatGPUTimer.h"
#include "pandabase.h"
#include "parasiteBuffer.h"
#include "pmutex.h"
#include "pointerEventList.h"
#include "pointerTo.h"
#include "post_x11_include.h"
#include "pre_x11_include.h"
#include "pset.h"
#include "py_panda.h"
#include "pythonGraphicsWindowProc.h"
#include "reMutex.h"
#include "referenceCount.h"
#include "sceneSetup.h"
#include "standardMunger.h"
#include <stdio.h>
#include "stereoDisplayRegion.h"
#include <string>
#include "subprocessWindow.h"
#include "subprocessWindowBuffer.h"
#include "texture.h"
#include "thread.h"
#include "touchInfo.h"
#include "typeHandle.h"
#include "typedef.h"
#include "vector_string.h"
#include "windowHandle.h"
#include "windowProperties.h"
#include "windowProperties_ext.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class GraphicsDevice
 */
typedef GraphicsDevice GraphicsDevice_localtype;
Define_Module_ClassRef(panda3d.core, GraphicsDevice, GraphicsDevice_localtype, GraphicsDevice);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsDevice = &Dtool_GraphicsDevice;
static void Dtool_PyModuleClassInit_GraphicsDevice(PyObject *module);

/**
 * Forward declarations for top-level class GraphicsPipe
 */
typedef GraphicsPipe GraphicsPipe_localtype;
Define_Module_ClassRef(panda3d.core, GraphicsPipe, GraphicsPipe_localtype, GraphicsPipe);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsPipe = &Dtool_GraphicsPipe;
static void Dtool_PyModuleClassInit_GraphicsPipe(PyObject *module);

/**
 * Forward declarations for top-level class DisplayInformation
 */
typedef DisplayInformation DisplayInformation_localtype;
Define_Module_Class(panda3d.core, DisplayInformation, DisplayInformation_localtype, DisplayInformation);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DisplayInformation = &Dtool_DisplayInformation;
static void Dtool_PyModuleClassInit_DisplayInformation(PyObject *module);

/**
 * Forward declarations for top-level class DrawableRegion
 */
typedef DrawableRegion DrawableRegion_localtype;
Define_Module_Class(panda3d.core, DrawableRegion, DrawableRegion_localtype, DrawableRegion);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DrawableRegion = &Dtool_DrawableRegion;
static void Dtool_PyModuleClassInit_DrawableRegion(PyObject *module);

/**
 * Forward declarations for top-level class WindowHandle
 */
typedef WindowHandle WindowHandle_localtype;
Define_Module_ClassRef(panda3d.core, WindowHandle, WindowHandle_localtype, WindowHandle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_WindowHandle = &Dtool_WindowHandle;
static void Dtool_PyModuleClassInit_WindowHandle(PyObject *module);
bool Dtool_ConstCoerce_WindowHandle(PyObject *args, CPT(WindowHandle) &coerced);
bool Dtool_Coerce_WindowHandle(PyObject *args, PT(WindowHandle) &coerced);

/**
 * Forward declarations for top-level class WindowHandle_OSHandle
 */
typedef WindowHandle::OSHandle WindowHandle_OSHandle_localtype;
Define_Module_ClassRef(panda3d.core, WindowHandle_OSHandle, WindowHandle_OSHandle_localtype, OSHandle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_WindowHandle_OSHandle = &Dtool_WindowHandle_OSHandle;
static void Dtool_PyModuleClassInit_WindowHandle_OSHandle(PyObject *module);

/**
 * Forward declarations for top-level class WindowProperties
 */
typedef WindowProperties WindowProperties_localtype;
Define_Module_Class(panda3d.core, WindowProperties, WindowProperties_localtype, WindowProperties);
static struct Dtool_PyTypedObject *const Dtool_Ptr_WindowProperties = &Dtool_WindowProperties;
static void Dtool_PyModuleClassInit_WindowProperties(PyObject *module);
WindowProperties *Dtool_Coerce_WindowProperties(PyObject *args, WindowProperties &coerced);

/**
 * Forward declarations for top-level class DisplayRegion
 */
typedef DisplayRegion DisplayRegion_localtype;
Define_Module_ClassRef(panda3d.core, DisplayRegion, DisplayRegion_localtype, DisplayRegion);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DisplayRegion = &Dtool_DisplayRegion;
static void Dtool_PyModuleClassInit_DisplayRegion(PyObject *module);

/**
 * Forward declarations for top-level class GraphicsOutput
 */
typedef GraphicsOutput GraphicsOutput_localtype;
Define_Module_ClassRef(panda3d.core, GraphicsOutput, GraphicsOutput_localtype, GraphicsOutput);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsOutput = &Dtool_GraphicsOutput;
static void Dtool_PyModuleClassInit_GraphicsOutput(PyObject *module);

/**
 * Forward declarations for top-level class GraphicsStateGuardian
 */
typedef GraphicsStateGuardian GraphicsStateGuardian_localtype;
Define_Module_ClassRef(panda3d.core, GraphicsStateGuardian, GraphicsStateGuardian_localtype, GraphicsStateGuardian);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsStateGuardian = &Dtool_GraphicsStateGuardian;
static void Dtool_PyModuleClassInit_GraphicsStateGuardian(PyObject *module);

/**
 * Forward declarations for top-level class GraphicsEngine
 */
typedef GraphicsEngine GraphicsEngine_localtype;
Define_Module_ClassRef(panda3d.core, GraphicsEngine, GraphicsEngine_localtype, GraphicsEngine);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsEngine = &Dtool_GraphicsEngine;
static void Dtool_PyModuleClassInit_GraphicsEngine(PyObject *module);

/**
 * Forward declarations for top-level class GraphicsThreadingModel
 */
typedef GraphicsThreadingModel GraphicsThreadingModel_localtype;
Define_Module_Class(panda3d.core, GraphicsThreadingModel, GraphicsThreadingModel_localtype, GraphicsThreadingModel);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsThreadingModel = &Dtool_GraphicsThreadingModel;
static void Dtool_PyModuleClassInit_GraphicsThreadingModel(PyObject *module);
GraphicsThreadingModel *Dtool_Coerce_GraphicsThreadingModel(PyObject *args, GraphicsThreadingModel &coerced);

/**
 * Forward declarations for top-level class StereoDisplayRegion
 */
typedef StereoDisplayRegion StereoDisplayRegion_localtype;
Define_Module_ClassRef(panda3d.core, StereoDisplayRegion, StereoDisplayRegion_localtype, StereoDisplayRegion);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StereoDisplayRegion = &Dtool_StereoDisplayRegion;
static void Dtool_PyModuleClassInit_StereoDisplayRegion(PyObject *module);

/**
 * Forward declarations for top-level class FrameBufferProperties
 */
typedef FrameBufferProperties FrameBufferProperties_localtype;
Define_Module_Class(panda3d.core, FrameBufferProperties, FrameBufferProperties_localtype, FrameBufferProperties);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FrameBufferProperties = &Dtool_FrameBufferProperties;
static void Dtool_PyModuleClassInit_FrameBufferProperties(PyObject *module);

/**
 * Forward declarations for top-level class GraphicsWindowInputDevice
 */
typedef GraphicsWindowInputDevice GraphicsWindowInputDevice_localtype;
Define_Module_ClassRef(panda3d.core, GraphicsWindowInputDevice, GraphicsWindowInputDevice_localtype, GraphicsWindowInputDevice);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsWindowInputDevice = &Dtool_GraphicsWindowInputDevice;
static void Dtool_PyModuleClassInit_GraphicsWindowInputDevice(PyObject *module);

/**
 * Forward declarations for top-level class TouchInfo
 */
typedef TouchInfo TouchInfo_localtype;
Define_Module_Class(panda3d.core, TouchInfo, TouchInfo_localtype, TouchInfo);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TouchInfo = &Dtool_TouchInfo;
static void Dtool_PyModuleClassInit_TouchInfo(PyObject *module);

/**
 * Forward declarations for top-level class GraphicsWindowProcCallbackData
 */
typedef GraphicsWindowProcCallbackData GraphicsWindowProcCallbackData_localtype;
Define_Module_Class(panda3d.core, GraphicsWindowProcCallbackData, GraphicsWindowProcCallbackData_localtype, GraphicsWindowProcCallbackData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsWindowProcCallbackData = &Dtool_GraphicsWindowProcCallbackData;
static void Dtool_PyModuleClassInit_GraphicsWindowProcCallbackData(PyObject *module);

/**
 * Forward declarations for top-level class GraphicsWindow
 */
typedef GraphicsWindow GraphicsWindow_localtype;
Define_Module_ClassRef(panda3d.core, GraphicsWindow, GraphicsWindow_localtype, GraphicsWindow);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsWindow = &Dtool_GraphicsWindow;
static void Dtool_PyModuleClassInit_GraphicsWindow(PyObject *module);

/**
 * Forward declarations for top-level class CallbackGraphicsWindow
 */
typedef CallbackGraphicsWindow CallbackGraphicsWindow_localtype;
Define_Module_ClassRef(panda3d.core, CallbackGraphicsWindow, CallbackGraphicsWindow_localtype, CallbackGraphicsWindow);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackGraphicsWindow = &Dtool_CallbackGraphicsWindow;
static void Dtool_PyModuleClassInit_CallbackGraphicsWindow(PyObject *module);

/**
 * Forward declarations for top-level class CallbackGraphicsWindow_WindowCallbackData
 */
typedef CallbackGraphicsWindow::WindowCallbackData CallbackGraphicsWindow_WindowCallbackData_localtype;
Define_Module_Class(panda3d.core, CallbackGraphicsWindow_WindowCallbackData, CallbackGraphicsWindow_WindowCallbackData_localtype, WindowCallbackData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackGraphicsWindow_WindowCallbackData = &Dtool_CallbackGraphicsWindow_WindowCallbackData;
static void Dtool_PyModuleClassInit_CallbackGraphicsWindow_WindowCallbackData(PyObject *module);

/**
 * Forward declarations for top-level class CallbackGraphicsWindow_EventsCallbackData
 */
typedef CallbackGraphicsWindow::EventsCallbackData CallbackGraphicsWindow_EventsCallbackData_localtype;
Define_Module_Class(panda3d.core, CallbackGraphicsWindow_EventsCallbackData, CallbackGraphicsWindow_EventsCallbackData_localtype, EventsCallbackData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackGraphicsWindow_EventsCallbackData = &Dtool_CallbackGraphicsWindow_EventsCallbackData;
static void Dtool_PyModuleClassInit_CallbackGraphicsWindow_EventsCallbackData(PyObject *module);

/**
 * Forward declarations for top-level class CallbackGraphicsWindow_PropertiesCallbackData
 */
typedef CallbackGraphicsWindow::PropertiesCallbackData CallbackGraphicsWindow_PropertiesCallbackData_localtype;
Define_Module_Class_Private(panda3d.core, CallbackGraphicsWindow_PropertiesCallbackData, CallbackGraphicsWindow_PropertiesCallbackData_localtype, PropertiesCallbackData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackGraphicsWindow_PropertiesCallbackData = &Dtool_CallbackGraphicsWindow_PropertiesCallbackData;
static void Dtool_PyModuleClassInit_CallbackGraphicsWindow_PropertiesCallbackData(PyObject *module);

/**
 * Forward declarations for top-level class CallbackGraphicsWindow_RenderCallbackData
 */
typedef CallbackGraphicsWindow::RenderCallbackData CallbackGraphicsWindow_RenderCallbackData_localtype;
Define_Module_Class(panda3d.core, CallbackGraphicsWindow_RenderCallbackData, CallbackGraphicsWindow_RenderCallbackData_localtype, RenderCallbackData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackGraphicsWindow_RenderCallbackData = &Dtool_CallbackGraphicsWindow_RenderCallbackData;
static void Dtool_PyModuleClassInit_CallbackGraphicsWindow_RenderCallbackData(PyObject *module);

/**
 * Forward declarations for top-level class DisplayMode
 */
typedef DisplayMode DisplayMode_localtype;
Define_Module_Class(panda3d.core, DisplayMode, DisplayMode_localtype, DisplayMode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DisplayMode = &Dtool_DisplayMode;
static void Dtool_PyModuleClassInit_DisplayMode(PyObject *module);

/**
 * Forward declarations for top-level class DisplayRegionCullCallbackData
 */
typedef DisplayRegionCullCallbackData DisplayRegionCullCallbackData_localtype;
Define_Module_Class(panda3d.core, DisplayRegionCullCallbackData, DisplayRegionCullCallbackData_localtype, DisplayRegionCullCallbackData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DisplayRegionCullCallbackData = &Dtool_DisplayRegionCullCallbackData;
static void Dtool_PyModuleClassInit_DisplayRegionCullCallbackData(PyObject *module);

/**
 * Forward declarations for top-level class DisplayRegionDrawCallbackData
 */
typedef DisplayRegionDrawCallbackData DisplayRegionDrawCallbackData_localtype;
Define_Module_Class(panda3d.core, DisplayRegionDrawCallbackData, DisplayRegionDrawCallbackData_localtype, DisplayRegionDrawCallbackData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DisplayRegionDrawCallbackData = &Dtool_DisplayRegionDrawCallbackData;
static void Dtool_PyModuleClassInit_DisplayRegionDrawCallbackData(PyObject *module);

/**
 * Forward declarations for top-level class DisplaySearchParameters
 */
typedef DisplaySearchParameters DisplaySearchParameters_localtype;
Define_Module_Class(panda3d.core, DisplaySearchParameters, DisplaySearchParameters_localtype, DisplaySearchParameters);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DisplaySearchParameters = &Dtool_DisplaySearchParameters;
static void Dtool_PyModuleClassInit_DisplaySearchParameters(PyObject *module);

/**
 * Forward declarations for top-level class GraphicsBuffer
 */
typedef GraphicsBuffer GraphicsBuffer_localtype;
Define_Module_ClassRef(panda3d.core, GraphicsBuffer, GraphicsBuffer_localtype, GraphicsBuffer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsBuffer = &Dtool_GraphicsBuffer;
static void Dtool_PyModuleClassInit_GraphicsBuffer(PyObject *module);

/**
 * Forward declarations for top-level class GraphicsPipeSelection
 */
typedef GraphicsPipeSelection GraphicsPipeSelection_localtype;
Define_Module_Class_Private(panda3d.core, GraphicsPipeSelection, GraphicsPipeSelection_localtype, GraphicsPipeSelection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsPipeSelection = &Dtool_GraphicsPipeSelection;
static void Dtool_PyModuleClassInit_GraphicsPipeSelection(PyObject *module);

/**
 * Forward declarations for top-level class MouseAndKeyboard
 */
typedef MouseAndKeyboard MouseAndKeyboard_localtype;
Define_Module_ClassRef(panda3d.core, MouseAndKeyboard, MouseAndKeyboard_localtype, MouseAndKeyboard);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseAndKeyboard = &Dtool_MouseAndKeyboard;
static void Dtool_PyModuleClassInit_MouseAndKeyboard(PyObject *module);

/**
 * Forward declarations for top-level class NativeWindowHandle
 */
typedef NativeWindowHandle NativeWindowHandle_localtype;
Define_Module_ClassRef(panda3d.core, NativeWindowHandle, NativeWindowHandle_localtype, NativeWindowHandle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NativeWindowHandle = &Dtool_NativeWindowHandle;
static void Dtool_PyModuleClassInit_NativeWindowHandle(PyObject *module);

/**
 * Forward declarations for top-level class ParasiteBuffer
 */
typedef ParasiteBuffer ParasiteBuffer_localtype;
Define_Module_ClassRef(panda3d.core, ParasiteBuffer, ParasiteBuffer_localtype, ParasiteBuffer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParasiteBuffer = &Dtool_ParasiteBuffer;
static void Dtool_PyModuleClassInit_ParasiteBuffer(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"GraphicsDevice", &Dtool_GraphicsDevice},
  {"GraphicsPipe", &Dtool_GraphicsPipe},
  {"DisplayInformation", &Dtool_DisplayInformation},
  {"DrawableRegion", &Dtool_DrawableRegion},
  {"WindowHandle", &Dtool_WindowHandle},
  {"WindowHandle::OSHandle", &Dtool_WindowHandle_OSHandle},
  {"WindowProperties", &Dtool_WindowProperties},
  {"DisplayRegion", &Dtool_DisplayRegion},
  {"GraphicsOutput", &Dtool_GraphicsOutput},
  {"GraphicsStateGuardian", &Dtool_GraphicsStateGuardian},
  {"GraphicsEngine", &Dtool_GraphicsEngine},
  {"GraphicsThreadingModel", &Dtool_GraphicsThreadingModel},
  {"StereoDisplayRegion", &Dtool_StereoDisplayRegion},
  {"FrameBufferProperties", &Dtool_FrameBufferProperties},
  {"GraphicsWindowInputDevice", &Dtool_GraphicsWindowInputDevice},
  {"TouchInfo", &Dtool_TouchInfo},
  {"GraphicsWindowProcCallbackData", &Dtool_GraphicsWindowProcCallbackData},
  {"GraphicsWindow", &Dtool_GraphicsWindow},
  {"CallbackGraphicsWindow", &Dtool_CallbackGraphicsWindow},
  {"CallbackGraphicsWindow::WindowCallbackData", &Dtool_CallbackGraphicsWindow_WindowCallbackData},
  {"CallbackGraphicsWindow::EventsCallbackData", &Dtool_CallbackGraphicsWindow_EventsCallbackData},
  {"CallbackGraphicsWindow::PropertiesCallbackData", &Dtool_CallbackGraphicsWindow_PropertiesCallbackData},
  {"CallbackGraphicsWindow::RenderCallbackData", &Dtool_CallbackGraphicsWindow_RenderCallbackData},
  {"DisplayMode", &Dtool_DisplayMode},
  {"DisplayRegionCullCallbackData", &Dtool_DisplayRegionCullCallbackData},
  {"DisplayRegionDrawCallbackData", &Dtool_DisplayRegionDrawCallbackData},
  {"DisplaySearchParameters", &Dtool_DisplaySearchParameters},
  {"GraphicsBuffer", &Dtool_GraphicsBuffer},
  {"GraphicsPipeSelection", &Dtool_GraphicsPipeSelection},
  {"MouseAndKeyboard", &Dtool_MouseAndKeyboard},
  {"NativeWindowHandle", &Dtool_NativeWindowHandle},
  {"ParasiteBuffer", &Dtool_ParasiteBuffer},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[1].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[2].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[3].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[4].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[5].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[6].type)
  {"Thread", nullptr},
#define Dtool_Ptr_Thread (imports[7].type)
  {"LVecBase2i", nullptr},
#define Dtool_Ptr_LVecBase2i (imports[8].type)
  {"LVector2i", nullptr},
#define Dtool_Ptr_LVector2i (imports[9].type)
  {"LPoint2i", nullptr},
#define Dtool_Ptr_LPoint2i (imports[10].type)
  {"LVecBase3i", nullptr},
#define Dtool_Ptr_LVecBase3i (imports[11].type)
  {"LVecBase4f", nullptr},
#define Dtool_Ptr_LVecBase4f (imports[12].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[13].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[14].type)
  {"ReMutex", nullptr},
#define Dtool_Ptr_ReMutex (imports[15].type)
  {"BitMask< uint32_t, 32 >", nullptr},
#define Dtool_Ptr_BitMask_uint32_t_32 (imports[16].type)
  {"GraphicsStateGuardianBase", nullptr},
#define Dtool_Ptr_GraphicsStateGuardianBase (imports[17].type)
  {"TextureStage", nullptr},
#define Dtool_Ptr_TextureStage (imports[18].type)
  {"PandaNode", nullptr},
#define Dtool_Ptr_PandaNode (imports[19].type)
  {"AsyncFuture", nullptr},
#define Dtool_Ptr_AsyncFuture (imports[20].type)
  {"PNMImage", nullptr},
#define Dtool_Ptr_PNMImage (imports[21].type)
  {"Texture", nullptr},
#define Dtool_Ptr_Texture (imports[22].type)
  {"NodePath", nullptr},
#define Dtool_Ptr_NodePath (imports[23].type)
  {"SceneSetup", nullptr},
#define Dtool_Ptr_SceneSetup (imports[24].type)
  {"CullTraverser", nullptr},
#define Dtool_Ptr_CullTraverser (imports[25].type)
  {"CallbackObject", nullptr},
#define Dtool_Ptr_CallbackObject (imports[26].type)
  {"CallbackData", nullptr},
#define Dtool_Ptr_CallbackData (imports[27].type)
  {"CullResult", nullptr},
#define Dtool_Ptr_CullResult (imports[28].type)
  {"PreparedGraphicsObjects", nullptr},
#define Dtool_Ptr_PreparedGraphicsObjects (imports[29].type)
  {"Loader", nullptr},
#define Dtool_Ptr_Loader (imports[30].type)
  {"ShaderAttrib", nullptr},
#define Dtool_Ptr_ShaderAttrib (imports[31].type)
  {"TextureAttrib", nullptr},
#define Dtool_Ptr_TextureAttrib (imports[32].type)
  {"GraphicsOutputBase", nullptr},
#define Dtool_Ptr_GraphicsOutputBase (imports[33].type)
  {"ShaderGenerator", nullptr},
#define Dtool_Ptr_ShaderGenerator (imports[34].type)
  {"ButtonHandle", nullptr},
#define Dtool_Ptr_ButtonHandle (imports[35].type)
  {"PointerData", nullptr},
#define Dtool_Ptr_PointerData (imports[36].type)
  {"InputDevice", nullptr},
#define Dtool_Ptr_InputDevice (imports[37].type)
  {"ButtonMap", nullptr},
#define Dtool_Ptr_ButtonMap (imports[38].type)
  {"DataNode", nullptr},
#define Dtool_Ptr_DataNode (imports[39].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// Thread
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Thread;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Thread = &Dtool_Thread;
#endif
// LVecBase2i
#ifndef LINK_ALL_STATIC
inline static LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced) {
  nassertr(Dtool_Ptr_LVecBase2i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2i *(*)(PyObject *, LVecBase2i &))Dtool_Ptr_LVecBase2i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2i = &Dtool_LVecBase2i;
extern LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced);
#endif
// LVector2i
#ifndef LINK_ALL_STATIC
inline static LVector2i *Dtool_Coerce_LVector2i(PyObject *args, LVector2i &coerced) {
  nassertr(Dtool_Ptr_LVector2i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector2i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector2i *(*)(PyObject *, LVector2i &))Dtool_Ptr_LVector2i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector2i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector2i = &Dtool_LVector2i;
extern LVector2i *Dtool_Coerce_LVector2i(PyObject *args, LVector2i &coerced);
#endif
// LPoint2i
#ifndef LINK_ALL_STATIC
inline static LPoint2i *Dtool_Coerce_LPoint2i(PyObject *args, LPoint2i &coerced) {
  nassertr(Dtool_Ptr_LPoint2i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint2i->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint2i *(*)(PyObject *, LPoint2i &))Dtool_Ptr_LPoint2i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2i = &Dtool_LPoint2i;
extern LPoint2i *Dtool_Coerce_LPoint2i(PyObject *args, LPoint2i &coerced);
#endif
// LVecBase3i
#ifndef LINK_ALL_STATIC
inline static LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced) {
  nassertr(Dtool_Ptr_LVecBase3i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3i *(*)(PyObject *, LVecBase3i &))Dtool_Ptr_LVecBase3i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3i = &Dtool_LVecBase3i;
extern LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// ReMutex
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReMutex;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReMutex = &Dtool_ReMutex;
#endif
// BitMask< uint32_t, 32 >
#ifndef LINK_ALL_STATIC
inline static BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced) {
  nassertr(Dtool_Ptr_BitMask_uint32_t_32 != nullptr, nullptr);
  nassertr(Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce != nullptr, nullptr);
  return ((BitMask< uint32_t, 32 > *(*)(PyObject *, BitMask< uint32_t, 32 > &))Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_BitMask_uint32_t_32;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint32_t_32 = &Dtool_BitMask_uint32_t_32;
extern BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced);
#endif
// GraphicsStateGuardianBase
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsStateGuardianBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsStateGuardianBase = &Dtool_GraphicsStateGuardianBase;
#endif
// TextureStage
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TextureStage;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureStage = &Dtool_TextureStage;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// AsyncFuture
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_AsyncFuture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncFuture = &Dtool_AsyncFuture;
#endif
// PNMImage
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PNMImage;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PNMImage = &Dtool_PNMImage;
#endif
// Texture
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Texture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Texture = &Dtool_Texture;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// SceneSetup
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_SceneSetup;
static struct Dtool_PyTypedObject *const Dtool_Ptr_SceneSetup = &Dtool_SceneSetup;
#endif
// CullTraverser
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CullTraverser;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CullTraverser = &Dtool_CullTraverser;
#endif
// CallbackObject
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_CallbackObject(PyObject *args, CPT(CallbackObject) &coerced) {
  nassertr(Dtool_Ptr_CallbackObject != nullptr, false);
  nassertr(Dtool_Ptr_CallbackObject->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(CallbackObject) &))Dtool_Ptr_CallbackObject->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_CallbackObject(PyObject *args, PT(CallbackObject) &coerced) {
  nassertr(Dtool_Ptr_CallbackObject != nullptr, false);
  nassertr(Dtool_Ptr_CallbackObject->_Dtool_Coerce != nullptr, false);
  return ((bool (*)(PyObject *, PT(CallbackObject) &))Dtool_Ptr_CallbackObject->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_CallbackObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackObject = &Dtool_CallbackObject;
extern bool Dtool_ConstCoerce_CallbackObject(PyObject *args, CPT(CallbackObject) &coerced);
extern bool Dtool_Coerce_CallbackObject(PyObject *args, PT(CallbackObject) &coerced);
#endif
// CallbackData
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CallbackData;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackData = &Dtool_CallbackData;
#endif
// CullResult
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CullResult;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CullResult = &Dtool_CullResult;
#endif
// PreparedGraphicsObjects
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PreparedGraphicsObjects;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PreparedGraphicsObjects = &Dtool_PreparedGraphicsObjects;
#endif
// Loader
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Loader;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Loader = &Dtool_Loader;
#endif
// ShaderAttrib
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_ShaderAttrib(PyObject *args, CPT(ShaderAttrib) &coerced) {
  nassertr(Dtool_Ptr_ShaderAttrib != nullptr, false);
  nassertr(Dtool_Ptr_ShaderAttrib->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(ShaderAttrib) &))Dtool_Ptr_ShaderAttrib->_Dtool_ConstCoerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_ShaderAttrib;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderAttrib = &Dtool_ShaderAttrib;
extern bool Dtool_ConstCoerce_ShaderAttrib(PyObject *args, CPT(ShaderAttrib) &coerced);
#endif
// TextureAttrib
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_TextureAttrib(PyObject *args, CPT(TextureAttrib) &coerced) {
  nassertr(Dtool_Ptr_TextureAttrib != nullptr, false);
  nassertr(Dtool_Ptr_TextureAttrib->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(TextureAttrib) &))Dtool_Ptr_TextureAttrib->_Dtool_ConstCoerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TextureAttrib;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureAttrib = &Dtool_TextureAttrib;
extern bool Dtool_ConstCoerce_TextureAttrib(PyObject *args, CPT(TextureAttrib) &coerced);
#endif
// GraphicsOutputBase
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsOutputBase;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsOutputBase = &Dtool_GraphicsOutputBase;
#endif
// ShaderGenerator
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_ShaderGenerator(PyObject *args, CPT(ShaderGenerator) &coerced) {
  nassertr(Dtool_Ptr_ShaderGenerator != nullptr, false);
  nassertr(Dtool_Ptr_ShaderGenerator->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(ShaderGenerator) &))Dtool_Ptr_ShaderGenerator->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_ShaderGenerator(PyObject *args, PT(ShaderGenerator) &coerced) {
  nassertr(Dtool_Ptr_ShaderGenerator != nullptr, false);
  nassertr(Dtool_Ptr_ShaderGenerator->_Dtool_Coerce != nullptr, false);
  return ((bool (*)(PyObject *, PT(ShaderGenerator) &))Dtool_Ptr_ShaderGenerator->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_ShaderGenerator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShaderGenerator = &Dtool_ShaderGenerator;
extern bool Dtool_ConstCoerce_ShaderGenerator(PyObject *args, CPT(ShaderGenerator) &coerced);
extern bool Dtool_Coerce_ShaderGenerator(PyObject *args, PT(ShaderGenerator) &coerced);
#endif
// ButtonHandle
#ifndef LINK_ALL_STATIC
inline static ButtonHandle *Dtool_Coerce_ButtonHandle(PyObject *args, ButtonHandle &coerced) {
  nassertr(Dtool_Ptr_ButtonHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_ButtonHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((ButtonHandle *(*)(PyObject *, ButtonHandle &))Dtool_Ptr_ButtonHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_ButtonHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ButtonHandle = &Dtool_ButtonHandle;
extern ButtonHandle *Dtool_Coerce_ButtonHandle(PyObject *args, ButtonHandle &coerced);
#endif
// PointerData
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PointerData;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerData = &Dtool_PointerData;
#endif
// InputDevice
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_InputDevice;
static struct Dtool_PyTypedObject *const Dtool_Ptr_InputDevice = &Dtool_InputDevice;
#endif
// ButtonMap
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ButtonMap;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ButtonMap = &Dtool_ButtonMap;
#endif
// DataNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DataNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DataNode = &Dtool_DataNode;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class GraphicsDevice
 */
/**
 * Python function wrapper for:
 * inline GraphicsPipe *GraphicsDevice::get_pipe(void) const
 */
static PyObject *Dtool_GraphicsDevice_get_pipe_3(PyObject *self, PyObject *) {
  GraphicsDevice *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsDevice)) {
    return nullptr;
  }
  // 1-inline GraphicsPipe *GraphicsDevice::get_pipe(void) const
  GraphicsPipe *return_value = ((*(const GraphicsDevice*)local_this).get_pipe)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsPipe, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsDevice_get_pipe_3_comment =
  "C++ Interface:\n"
  "get_pipe(GraphicsDevice self)\n"
  "\n"
  "/**\n"
  " * Returns the GraphicsPipe that this device is associated with.\n"
  " */";
#else
static const char *Dtool_GraphicsDevice_get_pipe_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GraphicsDevice::get_class_type(void)
 */
static PyObject *Dtool_GraphicsDevice_get_class_type_4(PyObject *, PyObject *) {
  // 1-static TypeHandle GraphicsDevice::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GraphicsDevice::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsDevice_get_class_type_4_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GraphicsDevice_get_class_type_4_comment = nullptr;
#endif

static int Dtool_Init_GraphicsDevice(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_GraphicsDevice(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GraphicsDevice) {
    printf("GraphicsDevice ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GraphicsDevice *local_this = (GraphicsDevice *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GraphicsDevice) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GraphicsDevice(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GraphicsDevice) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GraphicsDevice*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GraphicsDevice*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (GraphicsDevice*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GraphicsPipe
 */
/**
 * Python function wrapper for:
 * inline bool GraphicsPipe::is_valid(void) const
 */
static PyObject *Dtool_GraphicsPipe_is_valid_8(PyObject *self, PyObject *) {
  GraphicsPipe *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsPipe)) {
    return nullptr;
  }
  // 1-inline bool GraphicsPipe::is_valid(void) const
  bool return_value = ((*(const GraphicsPipe*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipe_is_valid_8_comment =
  "C++ Interface:\n"
  "is_valid(GraphicsPipe self)\n"
  "\n"
  "/**\n"
  " * Returns false if this pipe is known to be invalid, meaning that an attempt\n"
  " * to create a GraphicsWindow with the pipe will certainly fail.  Returns true\n"
  " * if the pipe is probably valid (is this case, an attempt to create a\n"
  " * GraphicsWindow should succeed, but might still fail).\n"
  " *\n"
  " * Use the GraphicsEngine class to create a GraphicsWindow on a particular\n"
  " * pipe.\n"
  " */";
#else
static const char *Dtool_GraphicsPipe_is_valid_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsPipe::get_supported_types(void) const
 */
static PyObject *Dtool_GraphicsPipe_get_supported_types_9(PyObject *self, PyObject *) {
  GraphicsPipe *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsPipe)) {
    return nullptr;
  }
  // 1-inline int GraphicsPipe::get_supported_types(void) const
  int return_value = ((*(const GraphicsPipe*)local_this).get_supported_types)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipe_get_supported_types_9_comment =
  "C++ Interface:\n"
  "get_supported_types(GraphicsPipe self)\n"
  "\n"
  "/**\n"
  " * Returns the mask of bits that represents the kinds of GraphicsOutput\n"
  " * objects this pipe might be able to successfully create.  The return value\n"
  " * is the union of bits in GraphicsPipe::OutputTypes that represents the set\n"
  " * of GraphicsOutput types.\n"
  " *\n"
  " * A 1 bit in a particular position is not a guarantee of success, but a 0 bit\n"
  " * is a guarantee of failure.\n"
  " */";
#else
static const char *Dtool_GraphicsPipe_get_supported_types_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsPipe::supports_type(int flags) const
 */
static PyObject *Dtool_GraphicsPipe_supports_type_10(PyObject *self, PyObject *arg) {
  GraphicsPipe *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsPipe)) {
    return nullptr;
  }
  // 1-inline bool GraphicsPipe::supports_type(int flags) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const GraphicsPipe*)local_this).supports_type)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "supports_type(GraphicsPipe self, int flags)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipe_supports_type_10_comment =
  "C++ Interface:\n"
  "supports_type(GraphicsPipe self, int flags)\n"
  "\n"
  "/**\n"
  " * A convenience function to ask if a particular type or types of\n"
  " * GraphicsObjects are supported.  The parameter is a union of one or more\n"
  " * bits defined in GrpahicsPipe::OutputTypes.\n"
  " *\n"
  " * Returns true if all of the requested types are listed in the\n"
  " * supported_types mask, false if any one of them is not.  This is not a\n"
  " * guarantee that the indicated output type will successfully be created when\n"
  " * it is attempted.\n"
  " */";
#else
static const char *Dtool_GraphicsPipe_supports_type_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsPipe::get_display_width(void) const
 */
static PyObject *Dtool_GraphicsPipe_get_display_width_11(PyObject *self, PyObject *) {
  GraphicsPipe *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsPipe)) {
    return nullptr;
  }
  // 1-inline int GraphicsPipe::get_display_width(void) const
  int return_value = ((*(const GraphicsPipe*)local_this).get_display_width)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipe_get_display_width_11_comment =
  "C++ Interface:\n"
  "get_display_width(GraphicsPipe self)\n"
  "\n"
  "/**\n"
  " * Returns the width of the entire display, if it is known.  This may return\n"
  " * 0.  This is not a guarantee that windows (particularly fullscreen windows)\n"
  " * may not be created larger than this width, but it is intended to provide a\n"
  " * hint to the application.\n"
  " */";
#else
static const char *Dtool_GraphicsPipe_get_display_width_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsPipe::get_display_height(void) const
 */
static PyObject *Dtool_GraphicsPipe_get_display_height_12(PyObject *self, PyObject *) {
  GraphicsPipe *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsPipe)) {
    return nullptr;
  }
  // 1-inline int GraphicsPipe::get_display_height(void) const
  int return_value = ((*(const GraphicsPipe*)local_this).get_display_height)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipe_get_display_height_12_comment =
  "C++ Interface:\n"
  "get_display_height(GraphicsPipe self)\n"
  "\n"
  "/**\n"
  " * Returns the height of the entire display, if it is known.  This may return\n"
  " * 0.  See the caveats for get_display_width().\n"
  " */";
#else
static const char *Dtool_GraphicsPipe_get_display_height_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DisplayInformation *GraphicsPipe::get_display_information(void)
 */
static PyObject *Dtool_GraphicsPipe_get_display_information_16(PyObject *self, PyObject *) {
  GraphicsPipe *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsPipe, (void **)&local_this, "GraphicsPipe.get_display_information")) {
    return nullptr;
  }
  // 1-DisplayInformation *GraphicsPipe::get_display_information(void)
  DisplayInformation *return_value = ((*local_this).get_display_information)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DisplayInformation, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipe_get_display_information_16_comment =
  "C++ Interface:\n"
  "get_display_information(const GraphicsPipe self)\n"
  "\n"
  "/**\n"
  " * Gets the pipe's DisplayInformation.\n"
  " */";
#else
static const char *Dtool_GraphicsPipe_get_display_information_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void GraphicsPipe::lookup_cpu_data(void)
 */
static PyObject *Dtool_GraphicsPipe_lookup_cpu_data_75(PyObject *self, PyObject *) {
  GraphicsPipe *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsPipe, (void **)&local_this, "GraphicsPipe.lookup_cpu_data")) {
    return nullptr;
  }
  // 1-virtual void GraphicsPipe::lookup_cpu_data(void)
  ((*local_this).lookup_cpu_data)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipe_lookup_cpu_data_75_comment =
  "C++ Interface:\n"
  "lookup_cpu_data(const GraphicsPipe self)\n"
  "\n"
  "/**\n"
  " * Looks up the detailed CPU information and stores it in\n"
  " * _display_information, if supported by the OS. This may take a second or\n"
  " * two.\n"
  " */";
#else
static const char *Dtool_GraphicsPipe_lookup_cpu_data_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::string GraphicsPipe::get_interface_name(void) const = 0
 */
static PyObject *Dtool_GraphicsPipe_get_interface_name_76(PyObject *self, PyObject *) {
  GraphicsPipe *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsPipe)) {
    return nullptr;
  }
  // 1-virtual std::string GraphicsPipe::get_interface_name(void) const = 0
  std::string return_value = ((*(const GraphicsPipe*)local_this).get_interface_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipe_get_interface_name_76_comment =
  "C++ Interface:\n"
  "get_interface_name(GraphicsPipe self)\n";
#else
static const char *Dtool_GraphicsPipe_get_interface_name_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GraphicsPipe::get_class_type(void)
 */
static PyObject *Dtool_GraphicsPipe_get_class_type_80(PyObject *, PyObject *) {
  // 1-static TypeHandle GraphicsPipe::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GraphicsPipe::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipe_get_class_type_80_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GraphicsPipe_get_class_type_80_comment = nullptr;
#endif

static PyObject *Dtool_GraphicsPipe_display_width_Getter(PyObject *self, void *) {
  const GraphicsPipe *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsPipe, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GraphicsPipe::get_display_width(void) const
  int return_value = ((*(const GraphicsPipe*)local_this).get_display_width)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsPipe_display_height_Getter(PyObject *self, void *) {
  const GraphicsPipe *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsPipe, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GraphicsPipe::get_display_height(void) const
  int return_value = ((*(const GraphicsPipe*)local_this).get_display_height)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsPipe_display_information_Getter(PyObject *self, void *) {
  GraphicsPipe *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsPipe, (void **)&local_this, "GraphicsPipe.display_information")) {
    return nullptr;
  }

  // 1-DisplayInformation *GraphicsPipe::get_display_information(void)
  DisplayInformation *return_value = ((*local_this).get_display_information)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DisplayInformation, false, false);
}

static PyObject *Dtool_GraphicsPipe_interface_name_Getter(PyObject *self, void *) {
  const GraphicsPipe *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsPipe, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual std::string GraphicsPipe::get_interface_name(void) const = 0
  std::string return_value = ((*(const GraphicsPipe*)local_this).get_interface_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_GraphicsPipe(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_GraphicsPipe(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GraphicsPipe) {
    printf("GraphicsPipe ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GraphicsPipe *local_this = (GraphicsPipe *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GraphicsPipe) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GraphicsPipe(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GraphicsPipe) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GraphicsPipe*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GraphicsPipe*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (GraphicsPipe*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DisplayInformation
 */
/**
 * Python function wrapper for:
 * int DisplayInformation::get_display_state(void)
 */
static PyObject *Dtool_DisplayInformation_get_display_state_23(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_display_state")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_display_state(void)
  int return_value = ((*local_this).get_display_state)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_display_state_23_comment =
  "C++ Interface:\n"
  "get_display_state(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_display_state_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_maximum_window_width(void)
 */
static PyObject *Dtool_DisplayInformation_get_maximum_window_width_24(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_maximum_window_width")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_maximum_window_width(void)
  int return_value = ((*local_this).get_maximum_window_width)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_maximum_window_width_24_comment =
  "C++ Interface:\n"
  "get_maximum_window_width(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_maximum_window_width_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_maximum_window_height(void)
 */
static PyObject *Dtool_DisplayInformation_get_maximum_window_height_25(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_maximum_window_height")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_maximum_window_height(void)
  int return_value = ((*local_this).get_maximum_window_height)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_maximum_window_height_25_comment =
  "C++ Interface:\n"
  "get_maximum_window_height(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_maximum_window_height_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_window_bits_per_pixel(void)
 */
static PyObject *Dtool_DisplayInformation_get_window_bits_per_pixel_26(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_window_bits_per_pixel")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_window_bits_per_pixel(void)
  int return_value = ((*local_this).get_window_bits_per_pixel)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_window_bits_per_pixel_26_comment =
  "C++ Interface:\n"
  "get_window_bits_per_pixel(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_window_bits_per_pixel_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_total_display_modes(void)
 */
static PyObject *Dtool_DisplayInformation_get_total_display_modes_27(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_total_display_modes")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_total_display_modes(void)
  int return_value = ((*local_this).get_total_display_modes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_total_display_modes_27_comment =
  "C++ Interface:\n"
  "get_total_display_modes(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_total_display_modes_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DisplayMode const &DisplayInformation::get_display_mode(int display_index)
 */
static PyObject *Dtool_DisplayInformation_get_display_mode_28(PyObject *self, PyObject *arg) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_display_mode")) {
    return nullptr;
  }
  // 1-DisplayMode const &DisplayInformation::get_display_mode(int display_index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DisplayMode const *return_value = &(((*local_this).get_display_mode)((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DisplayMode, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_display_mode(const DisplayInformation self, int display_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_display_mode_28_comment =
  "C++ Interface:\n"
  "get_display_mode(const DisplayInformation self, int display_index)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_display_mode_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_display_mode_width(int display_index)
 */
static PyObject *Dtool_DisplayInformation_get_display_mode_width_30(PyObject *self, PyObject *arg) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_display_mode_width")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_display_mode_width(int display_index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*local_this).get_display_mode_width)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_display_mode_width(const DisplayInformation self, int display_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_display_mode_width_30_comment =
  "C++ Interface:\n"
  "get_display_mode_width(const DisplayInformation self, int display_index)\n"
  "\n"
  "// Older interface for display modes.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_display_mode_width_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_display_mode_height(int display_index)
 */
static PyObject *Dtool_DisplayInformation_get_display_mode_height_31(PyObject *self, PyObject *arg) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_display_mode_height")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_display_mode_height(int display_index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*local_this).get_display_mode_height)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_display_mode_height(const DisplayInformation self, int display_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_display_mode_height_31_comment =
  "C++ Interface:\n"
  "get_display_mode_height(const DisplayInformation self, int display_index)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_display_mode_height_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_display_mode_bits_per_pixel(int display_index)
 */
static PyObject *Dtool_DisplayInformation_get_display_mode_bits_per_pixel_32(PyObject *self, PyObject *arg) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_display_mode_bits_per_pixel")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_display_mode_bits_per_pixel(int display_index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*local_this).get_display_mode_bits_per_pixel)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_display_mode_bits_per_pixel(const DisplayInformation self, int display_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_display_mode_bits_per_pixel_32_comment =
  "C++ Interface:\n"
  "get_display_mode_bits_per_pixel(const DisplayInformation self, int display_index)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_display_mode_bits_per_pixel_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_display_mode_refresh_rate(int display_index)
 */
static PyObject *Dtool_DisplayInformation_get_display_mode_refresh_rate_33(PyObject *self, PyObject *arg) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_display_mode_refresh_rate")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_display_mode_refresh_rate(int display_index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*local_this).get_display_mode_refresh_rate)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_display_mode_refresh_rate(const DisplayInformation self, int display_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_display_mode_refresh_rate_33_comment =
  "C++ Interface:\n"
  "get_display_mode_refresh_rate(const DisplayInformation self, int display_index)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_display_mode_refresh_rate_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_display_mode_fullscreen_only(int display_index)
 */
static PyObject *Dtool_DisplayInformation_get_display_mode_fullscreen_only_34(PyObject *self, PyObject *arg) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_display_mode_fullscreen_only")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_display_mode_fullscreen_only(int display_index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*local_this).get_display_mode_fullscreen_only)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_display_mode_fullscreen_only(const DisplayInformation self, int display_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_display_mode_fullscreen_only_34_comment =
  "C++ Interface:\n"
  "get_display_mode_fullscreen_only(const DisplayInformation self, int display_index)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_display_mode_fullscreen_only_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GraphicsStateGuardian::ShaderModel DisplayInformation::get_shader_model(void)
 */
static PyObject *Dtool_DisplayInformation_get_shader_model_35(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_shader_model")) {
    return nullptr;
  }
  // 1-GraphicsStateGuardian::ShaderModel DisplayInformation::get_shader_model(void)
  GraphicsStateGuardian::ShaderModel return_value = ((*local_this).get_shader_model)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_shader_model_35_comment =
  "C++ Interface:\n"
  "get_shader_model(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_shader_model_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_video_memory(void)
 */
static PyObject *Dtool_DisplayInformation_get_video_memory_36(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_video_memory")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_video_memory(void)
  int return_value = ((*local_this).get_video_memory)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_video_memory_36_comment =
  "C++ Interface:\n"
  "get_video_memory(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_video_memory_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_texture_memory(void)
 */
static PyObject *Dtool_DisplayInformation_get_texture_memory_37(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_texture_memory")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_texture_memory(void)
  int return_value = ((*local_this).get_texture_memory)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_texture_memory_37_comment =
  "C++ Interface:\n"
  "get_texture_memory(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_texture_memory_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DisplayInformation::update_memory_information(void)
 */
static PyObject *Dtool_DisplayInformation_update_memory_information_38(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.update_memory_information")) {
    return nullptr;
  }
  // 1-void DisplayInformation::update_memory_information(void)
  ((*local_this).update_memory_information)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_update_memory_information_38_comment =
  "C++ Interface:\n"
  "update_memory_information(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_update_memory_information_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * uint64_t DisplayInformation::get_physical_memory(void)
 */
static PyObject *Dtool_DisplayInformation_get_physical_memory_39(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_physical_memory")) {
    return nullptr;
  }
  // 1-uint64_t DisplayInformation::get_physical_memory(void)
  uint64_t return_value = ((*local_this).get_physical_memory)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_physical_memory_39_comment =
  "C++ Interface:\n"
  "get_physical_memory(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_physical_memory_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * uint64_t DisplayInformation::get_available_physical_memory(void)
 */
static PyObject *Dtool_DisplayInformation_get_available_physical_memory_40(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_available_physical_memory")) {
    return nullptr;
  }
  // 1-uint64_t DisplayInformation::get_available_physical_memory(void)
  uint64_t return_value = ((*local_this).get_available_physical_memory)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_available_physical_memory_40_comment =
  "C++ Interface:\n"
  "get_available_physical_memory(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_available_physical_memory_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * uint64_t DisplayInformation::get_page_file_size(void)
 */
static PyObject *Dtool_DisplayInformation_get_page_file_size_41(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_page_file_size")) {
    return nullptr;
  }
  // 1-uint64_t DisplayInformation::get_page_file_size(void)
  uint64_t return_value = ((*local_this).get_page_file_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_page_file_size_41_comment =
  "C++ Interface:\n"
  "get_page_file_size(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_page_file_size_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * uint64_t DisplayInformation::get_available_page_file_size(void)
 */
static PyObject *Dtool_DisplayInformation_get_available_page_file_size_42(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_available_page_file_size")) {
    return nullptr;
  }
  // 1-uint64_t DisplayInformation::get_available_page_file_size(void)
  uint64_t return_value = ((*local_this).get_available_page_file_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_available_page_file_size_42_comment =
  "C++ Interface:\n"
  "get_available_page_file_size(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_available_page_file_size_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * uint64_t DisplayInformation::get_process_virtual_memory(void)
 */
static PyObject *Dtool_DisplayInformation_get_process_virtual_memory_43(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_process_virtual_memory")) {
    return nullptr;
  }
  // 1-uint64_t DisplayInformation::get_process_virtual_memory(void)
  uint64_t return_value = ((*local_this).get_process_virtual_memory)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_process_virtual_memory_43_comment =
  "C++ Interface:\n"
  "get_process_virtual_memory(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_process_virtual_memory_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * uint64_t DisplayInformation::get_available_process_virtual_memory(void)
 */
static PyObject *Dtool_DisplayInformation_get_available_process_virtual_memory_44(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_available_process_virtual_memory")) {
    return nullptr;
  }
  // 1-uint64_t DisplayInformation::get_available_process_virtual_memory(void)
  uint64_t return_value = ((*local_this).get_available_process_virtual_memory)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_available_process_virtual_memory_44_comment =
  "C++ Interface:\n"
  "get_available_process_virtual_memory(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_available_process_virtual_memory_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_memory_load(void)
 */
static PyObject *Dtool_DisplayInformation_get_memory_load_45(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_memory_load")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_memory_load(void)
  int return_value = ((*local_this).get_memory_load)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_memory_load_45_comment =
  "C++ Interface:\n"
  "get_memory_load(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_memory_load_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * uint64_t DisplayInformation::get_page_fault_count(void)
 */
static PyObject *Dtool_DisplayInformation_get_page_fault_count_46(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_page_fault_count")) {
    return nullptr;
  }
  // 1-uint64_t DisplayInformation::get_page_fault_count(void)
  uint64_t return_value = ((*local_this).get_page_fault_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_page_fault_count_46_comment =
  "C++ Interface:\n"
  "get_page_fault_count(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_page_fault_count_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * uint64_t DisplayInformation::get_process_memory(void)
 */
static PyObject *Dtool_DisplayInformation_get_process_memory_47(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_process_memory")) {
    return nullptr;
  }
  // 1-uint64_t DisplayInformation::get_process_memory(void)
  uint64_t return_value = ((*local_this).get_process_memory)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_process_memory_47_comment =
  "C++ Interface:\n"
  "get_process_memory(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_process_memory_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * uint64_t DisplayInformation::get_peak_process_memory(void)
 */
static PyObject *Dtool_DisplayInformation_get_peak_process_memory_48(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_peak_process_memory")) {
    return nullptr;
  }
  // 1-uint64_t DisplayInformation::get_peak_process_memory(void)
  uint64_t return_value = ((*local_this).get_peak_process_memory)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_peak_process_memory_48_comment =
  "C++ Interface:\n"
  "get_peak_process_memory(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_peak_process_memory_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * uint64_t DisplayInformation::get_page_file_usage(void)
 */
static PyObject *Dtool_DisplayInformation_get_page_file_usage_49(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_page_file_usage")) {
    return nullptr;
  }
  // 1-uint64_t DisplayInformation::get_page_file_usage(void)
  uint64_t return_value = ((*local_this).get_page_file_usage)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_page_file_usage_49_comment =
  "C++ Interface:\n"
  "get_page_file_usage(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_page_file_usage_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * uint64_t DisplayInformation::get_peak_page_file_usage(void)
 */
static PyObject *Dtool_DisplayInformation_get_peak_page_file_usage_50(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_peak_page_file_usage")) {
    return nullptr;
  }
  // 1-uint64_t DisplayInformation::get_peak_page_file_usage(void)
  uint64_t return_value = ((*local_this).get_peak_page_file_usage)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_peak_page_file_usage_50_comment =
  "C++ Interface:\n"
  "get_peak_page_file_usage(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_peak_page_file_usage_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_vendor_id(void)
 */
static PyObject *Dtool_DisplayInformation_get_vendor_id_51(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_vendor_id")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_vendor_id(void)
  int return_value = ((*local_this).get_vendor_id)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_vendor_id_51_comment =
  "C++ Interface:\n"
  "get_vendor_id(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_vendor_id_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_device_id(void)
 */
static PyObject *Dtool_DisplayInformation_get_device_id_52(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_device_id")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_device_id(void)
  int return_value = ((*local_this).get_device_id)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_device_id_52_comment =
  "C++ Interface:\n"
  "get_device_id(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_device_id_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_driver_product(void)
 */
static PyObject *Dtool_DisplayInformation_get_driver_product_53(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_driver_product")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_driver_product(void)
  int return_value = ((*local_this).get_driver_product)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_driver_product_53_comment =
  "C++ Interface:\n"
  "get_driver_product(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_driver_product_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_driver_version(void)
 */
static PyObject *Dtool_DisplayInformation_get_driver_version_54(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_driver_version")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_driver_version(void)
  int return_value = ((*local_this).get_driver_version)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_driver_version_54_comment =
  "C++ Interface:\n"
  "get_driver_version(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_driver_version_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_driver_sub_version(void)
 */
static PyObject *Dtool_DisplayInformation_get_driver_sub_version_55(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_driver_sub_version")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_driver_sub_version(void)
  int return_value = ((*local_this).get_driver_sub_version)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_driver_sub_version_55_comment =
  "C++ Interface:\n"
  "get_driver_sub_version(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_driver_sub_version_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_driver_build(void)
 */
static PyObject *Dtool_DisplayInformation_get_driver_build_56(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_driver_build")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_driver_build(void)
  int return_value = ((*local_this).get_driver_build)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_driver_build_56_comment =
  "C++ Interface:\n"
  "get_driver_build(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_driver_build_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_driver_date_month(void)
 */
static PyObject *Dtool_DisplayInformation_get_driver_date_month_57(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_driver_date_month")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_driver_date_month(void)
  int return_value = ((*local_this).get_driver_date_month)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_driver_date_month_57_comment =
  "C++ Interface:\n"
  "get_driver_date_month(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_driver_date_month_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_driver_date_day(void)
 */
static PyObject *Dtool_DisplayInformation_get_driver_date_day_58(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_driver_date_day")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_driver_date_day(void)
  int return_value = ((*local_this).get_driver_date_day)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_driver_date_day_58_comment =
  "C++ Interface:\n"
  "get_driver_date_day(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_driver_date_day_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_driver_date_year(void)
 */
static PyObject *Dtool_DisplayInformation_get_driver_date_year_59(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_driver_date_year")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_driver_date_year(void)
  int return_value = ((*local_this).get_driver_date_year)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_driver_date_year_59_comment =
  "C++ Interface:\n"
  "get_driver_date_year(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_driver_date_year_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string const &DisplayInformation::get_cpu_vendor_string(void) const
 */
static PyObject *Dtool_DisplayInformation_get_cpu_vendor_string_60(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayInformation)) {
    return nullptr;
  }
  // 1-std::string const &DisplayInformation::get_cpu_vendor_string(void) const
  std::string const &return_value = ((*(const DisplayInformation*)local_this).get_cpu_vendor_string)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_cpu_vendor_string_60_comment =
  "C++ Interface:\n"
  "get_cpu_vendor_string(DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_cpu_vendor_string_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string const &DisplayInformation::get_cpu_brand_string(void) const
 */
static PyObject *Dtool_DisplayInformation_get_cpu_brand_string_61(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayInformation)) {
    return nullptr;
  }
  // 1-std::string const &DisplayInformation::get_cpu_brand_string(void) const
  std::string const &return_value = ((*(const DisplayInformation*)local_this).get_cpu_brand_string)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_cpu_brand_string_61_comment =
  "C++ Interface:\n"
  "get_cpu_brand_string(DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_cpu_brand_string_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * unsigned int DisplayInformation::get_cpu_version_information(void)
 */
static PyObject *Dtool_DisplayInformation_get_cpu_version_information_62(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_cpu_version_information")) {
    return nullptr;
  }
  // 1-unsigned int DisplayInformation::get_cpu_version_information(void)
  unsigned int return_value = ((*local_this).get_cpu_version_information)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_cpu_version_information_62_comment =
  "C++ Interface:\n"
  "get_cpu_version_information(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_cpu_version_information_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * unsigned int DisplayInformation::get_cpu_brand_index(void)
 */
static PyObject *Dtool_DisplayInformation_get_cpu_brand_index_63(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_cpu_brand_index")) {
    return nullptr;
  }
  // 1-unsigned int DisplayInformation::get_cpu_brand_index(void)
  unsigned int return_value = ((*local_this).get_cpu_brand_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_cpu_brand_index_63_comment =
  "C++ Interface:\n"
  "get_cpu_brand_index(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_cpu_brand_index_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * uint64_t DisplayInformation::get_cpu_frequency(void)
 */
static PyObject *Dtool_DisplayInformation_get_cpu_frequency_64(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_cpu_frequency")) {
    return nullptr;
  }
  // 1-uint64_t DisplayInformation::get_cpu_frequency(void)
  uint64_t return_value = ((*local_this).get_cpu_frequency)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_cpu_frequency_64_comment =
  "C++ Interface:\n"
  "get_cpu_frequency(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_cpu_frequency_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static uint64_t DisplayInformation::get_cpu_time(void)
 */
static PyObject *Dtool_DisplayInformation_get_cpu_time_65(PyObject *, PyObject *) {
  // 1-static uint64_t DisplayInformation::get_cpu_time(void)
  uint64_t return_value = (DisplayInformation::get_cpu_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_cpu_time_65_comment =
  "C++ Interface:\n"
  "get_cpu_time()\n"
  "\n"
  "/**\n"
  " * Equivalent to the rdtsc processor instruction.\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_cpu_time_65_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * uint64_t DisplayInformation::get_maximum_cpu_frequency(void)
 */
static PyObject *Dtool_DisplayInformation_get_maximum_cpu_frequency_66(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_maximum_cpu_frequency")) {
    return nullptr;
  }
  // 1-uint64_t DisplayInformation::get_maximum_cpu_frequency(void)
  uint64_t return_value = ((*local_this).get_maximum_cpu_frequency)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_maximum_cpu_frequency_66_comment =
  "C++ Interface:\n"
  "get_maximum_cpu_frequency(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_maximum_cpu_frequency_66_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * uint64_t DisplayInformation::get_current_cpu_frequency(void)
 */
static PyObject *Dtool_DisplayInformation_get_current_cpu_frequency_67(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_current_cpu_frequency")) {
    return nullptr;
  }
  // 1-uint64_t DisplayInformation::get_current_cpu_frequency(void)
  uint64_t return_value = ((*local_this).get_current_cpu_frequency)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_current_cpu_frequency_67_comment =
  "C++ Interface:\n"
  "get_current_cpu_frequency(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_current_cpu_frequency_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DisplayInformation::update_cpu_frequency(int processor_number)
 */
static PyObject *Dtool_DisplayInformation_update_cpu_frequency_68(PyObject *self, PyObject *arg) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.update_cpu_frequency")) {
    return nullptr;
  }
  // 1-void DisplayInformation::update_cpu_frequency(int processor_number)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).update_cpu_frequency)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "update_cpu_frequency(const DisplayInformation self, int processor_number)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_update_cpu_frequency_68_comment =
  "C++ Interface:\n"
  "update_cpu_frequency(const DisplayInformation self, int processor_number)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayInformation_update_cpu_frequency_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_num_cpu_cores(void)
 */
static PyObject *Dtool_DisplayInformation_get_num_cpu_cores_69(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_num_cpu_cores")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_num_cpu_cores(void)
  int return_value = ((*local_this).get_num_cpu_cores)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_num_cpu_cores_69_comment =
  "C++ Interface:\n"
  "get_num_cpu_cores(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " * Returns the number of individual CPU cores in the system, or 0 if this\n"
  " * number is not available.  A hyperthreaded CPU counts once here.\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_num_cpu_cores_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_num_logical_cpus(void)
 */
static PyObject *Dtool_DisplayInformation_get_num_logical_cpus_70(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_num_logical_cpus")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_num_logical_cpus(void)
  int return_value = ((*local_this).get_num_logical_cpus)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_num_logical_cpus_70_comment =
  "C++ Interface:\n"
  "get_num_logical_cpus(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " * Returns the number of logical CPU's in the system, or 0 if this number is\n"
  " * not available.  A hyperthreaded CPU counts as two or more here.\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_num_logical_cpus_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_os_version_major(void)
 */
static PyObject *Dtool_DisplayInformation_get_os_version_major_71(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_os_version_major")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_os_version_major(void)
  int return_value = ((*local_this).get_os_version_major)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_os_version_major_71_comment =
  "C++ Interface:\n"
  "get_os_version_major(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " * Returns -1 if not set.\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_os_version_major_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_os_version_minor(void)
 */
static PyObject *Dtool_DisplayInformation_get_os_version_minor_72(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_os_version_minor")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_os_version_minor(void)
  int return_value = ((*local_this).get_os_version_minor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_os_version_minor_72_comment =
  "C++ Interface:\n"
  "get_os_version_minor(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " * Returns -1 if not set.\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_os_version_minor_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_os_version_build(void)
 */
static PyObject *Dtool_DisplayInformation_get_os_version_build_73(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_os_version_build")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_os_version_build(void)
  int return_value = ((*local_this).get_os_version_build)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_os_version_build_73_comment =
  "C++ Interface:\n"
  "get_os_version_build(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " * Returns -1 if not set.\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_os_version_build_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int DisplayInformation::get_os_platform_id(void)
 */
static PyObject *Dtool_DisplayInformation_get_os_platform_id_74(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayInformation, (void **)&local_this, "DisplayInformation.get_os_platform_id")) {
    return nullptr;
  }
  // 1-int DisplayInformation::get_os_platform_id(void)
  int return_value = ((*local_this).get_os_platform_id)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayInformation_get_os_platform_id_74_comment =
  "C++ Interface:\n"
  "get_os_platform_id(const DisplayInformation self)\n"
  "\n"
  "/**\n"
  " * Returns -1 if not set.\n"
  " */";
#else
static const char *Dtool_DisplayInformation_get_os_platform_id_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DisplayInformation::DisplayInformation(void)
 * inline DisplayInformation::DisplayInformation(DisplayInformation const &) = default
 */
static int Dtool_Init_DisplayInformation(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("DisplayInformation() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-DisplayInformation::DisplayInformation(void)
      DisplayInformation *return_value = new DisplayInformation();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DisplayInformation, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline DisplayInformation::DisplayInformation(DisplayInformation const &) = default
      DisplayInformation const *arg_this = (DisplayInformation *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DisplayInformation, 0, "DisplayInformation.DisplayInformation", true, true);
      if (arg_this != nullptr) {
        DisplayInformation *return_value = new DisplayInformation(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DisplayInformation, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DisplayInformation() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DisplayInformation()\n"
      "DisplayInformation(const DisplayInformation param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_DisplayInformation_get_display_modes(PyObject *self, PyObject *) {
  DisplayInformation *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayInformation, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_total_display_modes)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_DisplayInformation_get_display_mode_28(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_DisplayInformation(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DisplayInformation) {
    printf("DisplayInformation ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DisplayInformation *local_this = (DisplayInformation *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DisplayInformation) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DisplayInformation(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DisplayInformation) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DrawableRegion
 */
/**
 * Python function wrapper for:
 * inline void DrawableRegion::set_clear_color_active(bool clear_color_active)
 */
static PyObject *Dtool_DrawableRegion_set_clear_color_active_84(PyObject *self, PyObject *arg) {
  DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DrawableRegion, (void **)&local_this, "DrawableRegion.set_clear_color_active")) {
    return nullptr;
  }
  // 1-inline void DrawableRegion::set_clear_color_active(bool clear_color_active)
  ((*local_this).set_clear_color_active)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clear_color_active(const DrawableRegion self, bool clear_color_active)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_set_clear_color_active_84_comment =
  "C++ Interface:\n"
  "set_clear_color_active(const DrawableRegion self, bool clear_color_active)\n"
  "\n"
  "/**\n"
  " * Toggles the flag that indicates whether the color buffer should be cleared\n"
  " * every frame.  If this is true, the color buffer will be cleared to the\n"
  " * color indicated by set_clear_color(); otherwise, it will be left alone.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_set_clear_color_active_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DrawableRegion::get_clear_color_active(void) const
 */
static PyObject *Dtool_DrawableRegion_get_clear_color_active_85(PyObject *self, PyObject *) {
  DrawableRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DrawableRegion)) {
    return nullptr;
  }
  // 1-inline bool DrawableRegion::get_clear_color_active(void) const
  bool return_value = ((*(const DrawableRegion*)local_this).get_clear_color_active)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_get_clear_color_active_85_comment =
  "C++ Interface:\n"
  "get_clear_color_active(DrawableRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the flag that indicates whether the color\n"
  " * buffer should be cleared every frame.  See set_clear_color_active().\n"
  " */";
#else
static const char *Dtool_DrawableRegion_get_clear_color_active_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DrawableRegion::set_clear_depth_active(bool clear_depth_active)
 */
static PyObject *Dtool_DrawableRegion_set_clear_depth_active_86(PyObject *self, PyObject *arg) {
  DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DrawableRegion, (void **)&local_this, "DrawableRegion.set_clear_depth_active")) {
    return nullptr;
  }
  // 1-inline void DrawableRegion::set_clear_depth_active(bool clear_depth_active)
  ((*local_this).set_clear_depth_active)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clear_depth_active(const DrawableRegion self, bool clear_depth_active)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_set_clear_depth_active_86_comment =
  "C++ Interface:\n"
  "set_clear_depth_active(const DrawableRegion self, bool clear_depth_active)\n"
  "\n"
  "/**\n"
  " * Toggles the flag that indicates whether the depth buffer should be cleared\n"
  " * every frame.  If this is true, the depth buffer will be cleared to the\n"
  " * depth value indicated by set_clear_depth(); otherwise, it will be left\n"
  " * alone.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_set_clear_depth_active_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DrawableRegion::get_clear_depth_active(void) const
 */
static PyObject *Dtool_DrawableRegion_get_clear_depth_active_87(PyObject *self, PyObject *) {
  DrawableRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DrawableRegion)) {
    return nullptr;
  }
  // 1-inline bool DrawableRegion::get_clear_depth_active(void) const
  bool return_value = ((*(const DrawableRegion*)local_this).get_clear_depth_active)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_get_clear_depth_active_87_comment =
  "C++ Interface:\n"
  "get_clear_depth_active(DrawableRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the flag that indicates whether the depth\n"
  " * buffer should be cleared every frame.  See set_clear_depth_active().\n"
  " */";
#else
static const char *Dtool_DrawableRegion_get_clear_depth_active_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DrawableRegion::set_clear_stencil_active(bool clear_stencil_active)
 */
static PyObject *Dtool_DrawableRegion_set_clear_stencil_active_88(PyObject *self, PyObject *arg) {
  DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DrawableRegion, (void **)&local_this, "DrawableRegion.set_clear_stencil_active")) {
    return nullptr;
  }
  // 1-inline void DrawableRegion::set_clear_stencil_active(bool clear_stencil_active)
  ((*local_this).set_clear_stencil_active)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clear_stencil_active(const DrawableRegion self, bool clear_stencil_active)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_set_clear_stencil_active_88_comment =
  "C++ Interface:\n"
  "set_clear_stencil_active(const DrawableRegion self, bool clear_stencil_active)\n"
  "\n"
  "/**\n"
  " * Toggles the flag that indicates whether the stencil buffer should be\n"
  " * cleared every frame.  If this is true, the stencil buffer will be cleared\n"
  " * to the value indicated by set_clear_stencil(); otherwise, it will be left\n"
  " * alone.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_set_clear_stencil_active_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DrawableRegion::get_clear_stencil_active(void) const
 */
static PyObject *Dtool_DrawableRegion_get_clear_stencil_active_89(PyObject *self, PyObject *) {
  DrawableRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DrawableRegion)) {
    return nullptr;
  }
  // 1-inline bool DrawableRegion::get_clear_stencil_active(void) const
  bool return_value = ((*(const DrawableRegion*)local_this).get_clear_stencil_active)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_get_clear_stencil_active_89_comment =
  "C++ Interface:\n"
  "get_clear_stencil_active(DrawableRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the flag that indicates whether the color\n"
  " * buffer should be cleared every frame.  See set_clear_stencil_active().\n"
  " */";
#else
static const char *Dtool_DrawableRegion_get_clear_stencil_active_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DrawableRegion::set_clear_color(LColor const &color)
 */
static PyObject *Dtool_DrawableRegion_set_clear_color_90(PyObject *self, PyObject *arg) {
  DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DrawableRegion, (void **)&local_this, "DrawableRegion.set_clear_color")) {
    return nullptr;
  }
  // 1-inline void DrawableRegion::set_clear_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DrawableRegion.set_clear_color", "LVecBase4f");
  }
  ((*local_this).set_clear_color)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clear_color(const DrawableRegion self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_set_clear_color_90_comment =
  "C++ Interface:\n"
  "set_clear_color(const DrawableRegion self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Sets the clear color to the indicated value.  This is the value that will\n"
  " * be used to clear the color buffer every frame, but only if\n"
  " * get_clear_color_active() returns true.  If get_clear_color_active() returns\n"
  " * false, this is meaningless.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_set_clear_color_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &DrawableRegion::get_clear_color(void) const
 */
static PyObject *Dtool_DrawableRegion_get_clear_color_91(PyObject *self, PyObject *) {
  DrawableRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DrawableRegion)) {
    return nullptr;
  }
  // 1-inline LColor const &DrawableRegion::get_clear_color(void) const
  LColor const *return_value = &(((*(const DrawableRegion*)local_this).get_clear_color)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_get_clear_color_91_comment =
  "C++ Interface:\n"
  "get_clear_color(DrawableRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the current clear color value.  This is the value that will be used\n"
  " * to clear the color buffer every frame, but only if get_clear_color_active()\n"
  " * returns true.  If get_clear_color_active() returns false, this is\n"
  " * meaningless.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_get_clear_color_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DrawableRegion::set_clear_depth(PN_stdfloat depth)
 */
static PyObject *Dtool_DrawableRegion_set_clear_depth_97(PyObject *self, PyObject *arg) {
  DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DrawableRegion, (void **)&local_this, "DrawableRegion.set_clear_depth")) {
    return nullptr;
  }
  // 1-inline void DrawableRegion::set_clear_depth(PN_stdfloat depth)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_clear_depth)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clear_depth(const DrawableRegion self, float depth)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_set_clear_depth_97_comment =
  "C++ Interface:\n"
  "set_clear_depth(const DrawableRegion self, float depth)\n"
  "\n"
  "/**\n"
  " * Sets the clear depth to the indicated value.  This is the value that will\n"
  " * be used to clear the depth buffer every frame, but only if\n"
  " * get_clear_depth_active() returns true.  If get_clear_depth_active() returns\n"
  " * false, this is meaningless.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_set_clear_depth_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DrawableRegion::get_clear_depth(void) const
 */
static PyObject *Dtool_DrawableRegion_get_clear_depth_98(PyObject *self, PyObject *) {
  DrawableRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DrawableRegion)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DrawableRegion::get_clear_depth(void) const
  PN_stdfloat return_value = ((*(const DrawableRegion*)local_this).get_clear_depth)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_get_clear_depth_98_comment =
  "C++ Interface:\n"
  "get_clear_depth(DrawableRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the current clear depth value.  This is the value that will be used\n"
  " * to clear the depth buffer every frame, but only if get_clear_depth_active()\n"
  " * returns true.  If get_clear_depth_active() returns false, this is\n"
  " * meaningless.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_get_clear_depth_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DrawableRegion::set_clear_stencil(unsigned int stencil)
 */
static PyObject *Dtool_DrawableRegion_set_clear_stencil_102(PyObject *self, PyObject *arg) {
  DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DrawableRegion, (void **)&local_this, "DrawableRegion.set_clear_stencil")) {
    return nullptr;
  }
  // 1-inline void DrawableRegion::set_clear_stencil(unsigned int stencil)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).set_clear_stencil)((unsigned int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clear_stencil(const DrawableRegion self, int stencil)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_set_clear_stencil_102_comment =
  "C++ Interface:\n"
  "set_clear_stencil(const DrawableRegion self, int stencil)\n"
  "\n"
  "/**\n"
  " * Sets the clear stencil to the indicated value.  This is the value that will\n"
  " * be used to clear the stencil buffer every frame, but only if\n"
  " * get_clear_color_active() returns true.  If get_clear_stencil_active()\n"
  " * returns false, this is meaningless.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_set_clear_stencil_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int DrawableRegion::get_clear_stencil(void) const
 */
static PyObject *Dtool_DrawableRegion_get_clear_stencil_103(PyObject *self, PyObject *) {
  DrawableRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DrawableRegion)) {
    return nullptr;
  }
  // 1-inline unsigned int DrawableRegion::get_clear_stencil(void) const
  unsigned int return_value = ((*(const DrawableRegion*)local_this).get_clear_stencil)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_get_clear_stencil_103_comment =
  "C++ Interface:\n"
  "get_clear_stencil(DrawableRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the current clear stencil value.  This is the value that will be\n"
  " * used to clear the stencil buffer every frame, but only if\n"
  " * get_clear_stencil_active() returns true.  If get_clear_stencil_active()\n"
  " * returns false, this is meaningless.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_get_clear_stencil_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DrawableRegion::set_clear_active(int n, bool clear_aux_active)
 */
static PyObject *Dtool_DrawableRegion_set_clear_active_106(PyObject *self, PyObject *args, PyObject *kwds) {
  DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DrawableRegion, (void **)&local_this, "DrawableRegion.set_clear_active")) {
    return nullptr;
  }
  // 1-virtual void DrawableRegion::set_clear_active(int n, bool clear_aux_active)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "clear_aux_active", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_clear_active", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_clear_active)((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clear_active(const DrawableRegion self, int n, bool clear_aux_active)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_set_clear_active_106_comment =
  "C++ Interface:\n"
  "set_clear_active(const DrawableRegion self, int n, bool clear_aux_active)\n"
  "\n"
  "/**\n"
  " * Sets the clear-active flag for any bitplane.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_set_clear_active_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool DrawableRegion::get_clear_active(int n) const
 */
static PyObject *Dtool_DrawableRegion_get_clear_active_107(PyObject *self, PyObject *arg) {
  DrawableRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DrawableRegion)) {
    return nullptr;
  }
  // 1-virtual bool DrawableRegion::get_clear_active(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const DrawableRegion*)local_this).get_clear_active)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_clear_active(DrawableRegion self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_get_clear_active_107_comment =
  "C++ Interface:\n"
  "get_clear_active(DrawableRegion self, int n)\n"
  "\n"
  "/**\n"
  " * Gets the clear-active flag for any bitplane.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_get_clear_active_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DrawableRegion::set_clear_value(int n, LColor const &clear_value)
 */
static PyObject *Dtool_DrawableRegion_set_clear_value_108(PyObject *self, PyObject *args, PyObject *kwds) {
  DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DrawableRegion, (void **)&local_this, "DrawableRegion.set_clear_value")) {
    return nullptr;
  }
  // 1-virtual void DrawableRegion::set_clear_value(int n, LColor const &clear_value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "clear_value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_clear_value", (char **)keyword_list, &param1, &param2)) {
    LVecBase4f param2_local;
    LColor const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "DrawableRegion.set_clear_value", "LVecBase4f");
    }
    ((*local_this).set_clear_value)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clear_value(const DrawableRegion self, int n, const LVecBase4f clear_value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_set_clear_value_108_comment =
  "C++ Interface:\n"
  "set_clear_value(const DrawableRegion self, int n, const LVecBase4f clear_value)\n"
  "\n"
  "/**\n"
  " * Sets the clear value for any bitplane.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_set_clear_value_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual LColor const &DrawableRegion::get_clear_value(int n) const
 */
static PyObject *Dtool_DrawableRegion_get_clear_value_109(PyObject *self, PyObject *arg) {
  DrawableRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DrawableRegion)) {
    return nullptr;
  }
  // 1-virtual LColor const &DrawableRegion::get_clear_value(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LColor const *return_value = &(((*(const DrawableRegion*)local_this).get_clear_value)((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_clear_value(DrawableRegion self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_get_clear_value_109_comment =
  "C++ Interface:\n"
  "get_clear_value(DrawableRegion self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the clear value for any bitplane.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_get_clear_value_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DrawableRegion::disable_clears(void)
 */
static PyObject *Dtool_DrawableRegion_disable_clears_110(PyObject *self, PyObject *) {
  DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DrawableRegion, (void **)&local_this, "DrawableRegion.disable_clears")) {
    return nullptr;
  }
  // 1-virtual void DrawableRegion::disable_clears(void)
  ((*local_this).disable_clears)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_disable_clears_110_comment =
  "C++ Interface:\n"
  "disable_clears(const DrawableRegion self)\n"
  "\n"
  "/**\n"
  " * Disables both the color and depth clear.  See set_clear_color_active and\n"
  " * set_clear_depth_active.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_disable_clears_110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool DrawableRegion::is_any_clear_active(void) const
 */
static PyObject *Dtool_DrawableRegion_is_any_clear_active_111(PyObject *self, PyObject *) {
  DrawableRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DrawableRegion)) {
    return nullptr;
  }
  // 1-virtual bool DrawableRegion::is_any_clear_active(void) const
  bool return_value = ((*(const DrawableRegion*)local_this).is_any_clear_active)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_is_any_clear_active_111_comment =
  "C++ Interface:\n"
  "is_any_clear_active(DrawableRegion self)\n"
  "\n"
  "/**\n"
  " * Returns true if any of the clear types (so far there are just color or\n"
  " * depth) have been set active, or false if none of them are active and there\n"
  " * is no need to clear.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_is_any_clear_active_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DrawableRegion::set_pixel_zoom(PN_stdfloat pixel_zoom)
 */
static PyObject *Dtool_DrawableRegion_set_pixel_zoom_112(PyObject *self, PyObject *arg) {
  DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DrawableRegion, (void **)&local_this, "DrawableRegion.set_pixel_zoom")) {
    return nullptr;
  }
  // 1-virtual void DrawableRegion::set_pixel_zoom(PN_stdfloat pixel_zoom)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_pixel_zoom)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pixel_zoom(const DrawableRegion self, float pixel_zoom)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_set_pixel_zoom_112_comment =
  "C++ Interface:\n"
  "set_pixel_zoom(const DrawableRegion self, float pixel_zoom)\n"
  "\n"
  "/**\n"
  " * Sets the amount by which the pixels of the region are scaled internally\n"
  " * when filling the image interally.  Setting this number larger makes the\n"
  " * pixels blockier, but may make the rendering faster, particularly for\n"
  " * software renderers.  Setting this number to 2.0 reduces the number of\n"
  " * pixels that have to be filled by the renderer by a factor of 2.0.  It\n"
  " * doesn't make sense to set this lower than 1.0.\n"
  " *\n"
  " * It is possible to set this on either individual DisplayRegions or on\n"
  " * overall GraphicsWindows, but you will get better performance for setting it\n"
  " * on the window rather than its individual DisplayRegions.  Also, you may not\n"
  " * set it on a DisplayRegion that doesn't have both clear_color() and\n"
  " * clear_depth() enabled.\n"
  " *\n"
  " * This property is only supported on renderers for which it is particularly\n"
  " * useful--currently, this is the tinydisplay software renderer.  Other kinds\n"
  " * of renderers allow you to set this property, but ignore it.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_set_pixel_zoom_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DrawableRegion::get_pixel_zoom(void) const
 */
static PyObject *Dtool_DrawableRegion_get_pixel_zoom_113(PyObject *self, PyObject *) {
  DrawableRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DrawableRegion)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DrawableRegion::get_pixel_zoom(void) const
  PN_stdfloat return_value = ((*(const DrawableRegion*)local_this).get_pixel_zoom)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_get_pixel_zoom_113_comment =
  "C++ Interface:\n"
  "get_pixel_zoom(DrawableRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the value set by set_pixel_zoom(), regardless of whether it is\n"
  " * being respected or not.  Also see get_pixel_factor().\n"
  " */";
#else
static const char *Dtool_DrawableRegion_get_pixel_zoom_113_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DrawableRegion::get_pixel_factor(void) const
 */
static PyObject *Dtool_DrawableRegion_get_pixel_factor_114(PyObject *self, PyObject *) {
  DrawableRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DrawableRegion)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DrawableRegion::get_pixel_factor(void) const
  PN_stdfloat return_value = ((*(const DrawableRegion*)local_this).get_pixel_factor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_get_pixel_factor_114_comment =
  "C++ Interface:\n"
  "get_pixel_factor(DrawableRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the amount by which the height and width of the region will be\n"
  " * scaled internally, based on the zoom factor set by set_pixel_zoom().  This\n"
  " * will return 1.0 if the pixel_zoom was not set or if it is not being\n"
  " * respected (for instance, because the underlying renderer doesn't support it\n"
  " * --see supports_pixel_zoom).\n"
  " */";
#else
static const char *Dtool_DrawableRegion_get_pixel_factor_114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool DrawableRegion::supports_pixel_zoom(void) const
 */
static PyObject *Dtool_DrawableRegion_supports_pixel_zoom_115(PyObject *self, PyObject *) {
  DrawableRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DrawableRegion)) {
    return nullptr;
  }
  // 1-virtual bool DrawableRegion::supports_pixel_zoom(void) const
  bool return_value = ((*(const DrawableRegion*)local_this).supports_pixel_zoom)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_supports_pixel_zoom_115_comment =
  "C++ Interface:\n"
  "supports_pixel_zoom(DrawableRegion self)\n"
  "\n"
  "/**\n"
  " * Returns true if a call to set_pixel_zoom() will be respected, false if it\n"
  " * will be ignored.  If this returns false, then get_pixel_factor() will\n"
  " * always return 1.0, regardless of what value you specify for\n"
  " * set_pixel_zoom().\n"
  " *\n"
  " * This may return false if the underlying renderer doesn't support pixel\n"
  " * zooming, or if you have called this on a DisplayRegion that doesn't have\n"
  " * both set_clear_color() and set_clear_depth() enabled.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_supports_pixel_zoom_115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int DrawableRegion::get_renderbuffer_type(int plane)
 */
static PyObject *Dtool_DrawableRegion_get_renderbuffer_type_118(PyObject *, PyObject *arg) {
  // 1-static int DrawableRegion::get_renderbuffer_type(int plane)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = (DrawableRegion::get_renderbuffer_type)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_renderbuffer_type(int plane)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DrawableRegion_get_renderbuffer_type_118_comment =
  "C++ Interface:\n"
  "get_renderbuffer_type(int plane)\n"
  "\n"
  "/**\n"
  " * Returns the RenderBuffer::Type that corresponds to a RenderTexturePlane.\n"
  " */";
#else
static const char *Dtool_DrawableRegion_get_renderbuffer_type_118_comment = nullptr;
#endif

static PyObject *Dtool_DrawableRegion_clear_color_Getter(PyObject *self, void *) {
  const DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DrawableRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LColor const &DrawableRegion::get_clear_color(void) const
  LColor const *return_value = &(((*(const DrawableRegion*)local_this).get_clear_color)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_DrawableRegion_clear_color_Setter(PyObject *self, PyObject *arg, void *) {
  DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DrawableRegion, (void **)&local_this, "DrawableRegion.clear_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete clear_color attribute");
    return -1;
  }
  // 1-inline void DrawableRegion::set_clear_color(LColor const &color)
  LVecBase4f arg_local;
  LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DrawableRegion.set_clear_color", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_clear_color)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_clear_color(const DrawableRegion self, const LVecBase4f color)\n");
  }
  return -1;
}

static PyObject *Dtool_DrawableRegion_clear_depth_Getter(PyObject *self, void *) {
  const DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DrawableRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat DrawableRegion::get_clear_depth(void) const
  PN_stdfloat return_value = ((*(const DrawableRegion*)local_this).get_clear_depth)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DrawableRegion_clear_depth_Setter(PyObject *self, PyObject *arg, void *) {
  DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DrawableRegion, (void **)&local_this, "DrawableRegion.clear_depth")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete clear_depth attribute");
    return -1;
  }
  // 1-inline void DrawableRegion::set_clear_depth(PN_stdfloat depth)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_clear_depth)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_clear_depth(const DrawableRegion self, float depth)\n");
  }
  return -1;
}

static PyObject *Dtool_DrawableRegion_clear_stencil_Getter(PyObject *self, void *) {
  const DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DrawableRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline unsigned int DrawableRegion::get_clear_stencil(void) const
  unsigned int return_value = ((*(const DrawableRegion*)local_this).get_clear_stencil)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DrawableRegion_clear_stencil_Setter(PyObject *self, PyObject *arg, void *) {
  DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DrawableRegion, (void **)&local_this, "DrawableRegion.clear_stencil")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete clear_stencil attribute");
    return -1;
  }
  // 1-inline void DrawableRegion::set_clear_stencil(unsigned int stencil)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %lu out of range for unsigned integer",
                   param1);
      return -1;
    }
#endif
    ((*local_this).set_clear_stencil)((unsigned int)param1);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_clear_stencil(const DrawableRegion self, int stencil)\n");
  }
  return -1;
}

static PyObject *Dtool_DrawableRegion_pixel_zoom_Getter(PyObject *self, void *) {
  const DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DrawableRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat DrawableRegion::get_pixel_zoom(void) const
  PN_stdfloat return_value = ((*(const DrawableRegion*)local_this).get_pixel_zoom)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DrawableRegion_pixel_zoom_Setter(PyObject *self, PyObject *arg, void *) {
  DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DrawableRegion, (void **)&local_this, "DrawableRegion.pixel_zoom")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete pixel_zoom attribute");
    return -1;
  }
  // 1-virtual void DrawableRegion::set_pixel_zoom(PN_stdfloat pixel_zoom)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_pixel_zoom)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_pixel_zoom(const DrawableRegion self, float pixel_zoom)\n");
  }
  return -1;
}

static PyObject *Dtool_DrawableRegion_pixel_factor_Getter(PyObject *self, void *) {
  const DrawableRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DrawableRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat DrawableRegion::get_pixel_factor(void) const
  PN_stdfloat return_value = ((*(const DrawableRegion*)local_this).get_pixel_factor)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_DrawableRegion(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DrawableRegion(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DrawableRegion) {
    printf("DrawableRegion ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DrawableRegion *local_this = (DrawableRegion *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DrawableRegion) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DrawableRegion(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DrawableRegion) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class WindowHandle
 */
/**
 * Python function wrapper for:
 * inline WindowHandle::OSHandle *WindowHandle::get_os_handle(void) const
 */
static PyObject *Dtool_WindowHandle_get_os_handle_121(PyObject *self, PyObject *) {
  WindowHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowHandle)) {
    return nullptr;
  }
  // 1-inline WindowHandle::OSHandle *WindowHandle::get_os_handle(void) const
  WindowHandle::OSHandle *return_value = ((*(const WindowHandle*)local_this).get_os_handle)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_WindowHandle_OSHandle, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_WindowHandle_get_os_handle_121_comment =
  "C++ Interface:\n"
  "get_os_handle(WindowHandle self)\n"
  "\n"
  "/**\n"
  " * Returns the OS-specific handle stored internally to the WindowHandle\n"
  " * wrapper.\n"
  " */";
#else
static const char *Dtool_WindowHandle_get_os_handle_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowHandle::set_os_handle(WindowHandle::OSHandle *os_handle)
 */
static PyObject *Dtool_WindowHandle_set_os_handle_122(PyObject *self, PyObject *arg) {
  WindowHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowHandle, (void **)&local_this, "WindowHandle.set_os_handle")) {
    return nullptr;
  }
  // 1-inline void WindowHandle::set_os_handle(WindowHandle::OSHandle *os_handle)
  WindowHandle::OSHandle *arg_this = (WindowHandle::OSHandle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_WindowHandle_OSHandle, 1, "WindowHandle.set_os_handle", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_os_handle)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_os_handle(const WindowHandle self, OSHandle os_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowHandle_set_os_handle_122_comment =
  "C++ Interface:\n"
  "set_os_handle(const WindowHandle self, OSHandle os_handle)\n"
  "\n"
  "/**\n"
  " * Changes the OS-specific handle stored internally to the WindowHandle\n"
  " * wrapper.\n"
  " */";
#else
static const char *Dtool_WindowHandle_set_os_handle_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void WindowHandle::send_windows_message(unsigned int msg, int wparam, int lparam)
 */
static PyObject *Dtool_WindowHandle_send_windows_message_130(PyObject *self, PyObject *args, PyObject *kwds) {
  WindowHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowHandle, (void **)&local_this, "WindowHandle.send_windows_message")) {
    return nullptr;
  }
  // 1-void WindowHandle::send_windows_message(unsigned int msg, int wparam, int lparam)
  unsigned long param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"msg", "wparam", "lparam", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kii:send_windows_message", (char **)keyword_list, &param1, &param2, &param3)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).send_windows_message)((unsigned int)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "send_windows_message(const WindowHandle self, int msg, int wparam, int lparam)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowHandle_send_windows_message_130_comment =
  "C++ Interface:\n"
  "send_windows_message(const WindowHandle self, int msg, int wparam, int lparam)\n"
  "\n"
  "/**\n"
  " * Call this method on a parent WindowHandle to deliver a Windows message to\n"
  " * the current child window, if any.  This is used in the web plugin system to\n"
  " * deliver button events detected directly by the browser system into Panda,\n"
  " * which is particularly necessary on Vista.\n"
  " */";
#else
static const char *Dtool_WindowHandle_send_windows_message_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t WindowHandle::get_int_handle(void) const
 */
static PyObject *Dtool_WindowHandle_get_int_handle_131(PyObject *self, PyObject *) {
  WindowHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowHandle)) {
    return nullptr;
  }
  // 1-std::size_t WindowHandle::get_int_handle(void) const
  std::size_t return_value = ((*(const WindowHandle*)local_this).get_int_handle)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowHandle_get_int_handle_131_comment =
  "C++ Interface:\n"
  "get_int_handle(WindowHandle self)\n"
  "\n"
  "/**\n"
  " * Returns the OS-specific handle converted to an integer, if this is possible\n"
  " * for the particular representation.  Returns 0 if it is not.\n"
  " */";
#else
static const char *Dtool_WindowHandle_get_int_handle_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void WindowHandle::output(std::ostream &out) const
 */
static PyObject *Dtool_WindowHandle_output_132(PyObject *self, PyObject *arg) {
  WindowHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowHandle)) {
    return nullptr;
  }
  // 1-void WindowHandle::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "WindowHandle.output", false, true);
  if (arg_this != nullptr) {
    ((*(const WindowHandle*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(WindowHandle self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowHandle_output_132_comment =
  "C++ Interface:\n"
  "output(WindowHandle self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_WindowHandle_output_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle WindowHandle::get_class_type(void)
 */
static PyObject *Dtool_WindowHandle_get_class_type_133(PyObject *, PyObject *) {
  // 1-static TypeHandle WindowHandle::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((WindowHandle::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_WindowHandle_get_class_type_133_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_WindowHandle_get_class_type_133_comment = nullptr;
#endif

static PyObject *Dtool_WindowHandle_os_handle_Getter(PyObject *self, void *) {
  const WindowHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowHandle, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline WindowHandle::OSHandle *WindowHandle::get_os_handle(void) const
  WindowHandle::OSHandle *return_value = ((*(const WindowHandle*)local_this).get_os_handle)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_WindowHandle_OSHandle, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_WindowHandle_os_handle_Setter(PyObject *self, PyObject *arg, void *) {
  WindowHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowHandle, (void **)&local_this, "WindowHandle.os_handle")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete os_handle attribute");
    return -1;
  }
  // 1-inline void WindowHandle::set_os_handle(WindowHandle::OSHandle *os_handle)
  WindowHandle::OSHandle *arg_this = (WindowHandle::OSHandle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_WindowHandle_OSHandle, 1, "WindowHandle.set_os_handle", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_os_handle)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_os_handle(const WindowHandle self, OSHandle os_handle)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline WindowHandle::WindowHandle(WindowHandle const &copy)
 * inline WindowHandle::WindowHandle(WindowHandle::OSHandle *os_handle)
 */
static int Dtool_Init_WindowHandle(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "WindowHandle() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline WindowHandle::WindowHandle(WindowHandle const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      WindowHandle const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_WindowHandle);
      if (param0_this != nullptr) {
        WindowHandle *return_value = new WindowHandle(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WindowHandle, true, false);
      }
    }
  }

  {
    // -2 inline WindowHandle::WindowHandle(WindowHandle::OSHandle *os_handle)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "os_handle")) {
      WindowHandle::OSHandle *param0_this = (WindowHandle::OSHandle *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_WindowHandle_OSHandle, 0, "WindowHandle.WindowHandle", false, false);
      if (param0_this != nullptr) {
        WindowHandle *return_value = new WindowHandle(param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WindowHandle, true, false);
      }
    }
  }

  {
    // -2 inline WindowHandle::WindowHandle(WindowHandle const &copy)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
      CPT(WindowHandle) param0_this;
      if (Dtool_ConstCoerce_WindowHandle(param0, param0_this)) {
        WindowHandle *return_value = new WindowHandle(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WindowHandle, true, false);
      }
    }
  }

  // No coercion possible: inline WindowHandle::WindowHandle(WindowHandle::OSHandle *os_handle)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "WindowHandle(const WindowHandle copy)\n"
      "WindowHandle(OSHandle os_handle)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_WindowHandle(PyObject *args, CPT(WindowHandle) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_WindowHandle)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline WindowHandle::WindowHandle(WindowHandle::OSHandle *os_handle)
    WindowHandle::OSHandle *arg_this = (WindowHandle::OSHandle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_WindowHandle_OSHandle, 0, "WindowHandle.WindowHandle", false, false);
    if (arg_this != nullptr) {
      WindowHandle *return_value = new WindowHandle(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_WindowHandle(PyObject *args, PT(WindowHandle) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_WindowHandle)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline WindowHandle::WindowHandle(WindowHandle::OSHandle *os_handle)
    WindowHandle::OSHandle *arg_this = (WindowHandle::OSHandle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_WindowHandle_OSHandle, 0, "WindowHandle.WindowHandle", false, false);
    if (arg_this != nullptr) {
      WindowHandle *return_value = new WindowHandle(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_WindowHandle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_WindowHandle) {
    printf("WindowHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  WindowHandle *local_this = (WindowHandle *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_WindowHandle) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_WindowHandle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_WindowHandle) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (WindowHandle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (WindowHandle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (WindowHandle*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class WindowHandle::OSHandle
 */
/**
 * Python function wrapper for:
 * virtual std::size_t WindowHandle::OSHandle::get_int_handle(void) const
 */
static PyObject *Dtool_WindowHandle_OSHandle_get_int_handle_126(PyObject *self, PyObject *) {
  WindowHandle::OSHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowHandle_OSHandle)) {
    return nullptr;
  }
  // 1-virtual std::size_t WindowHandle::OSHandle::get_int_handle(void) const
  std::size_t return_value = ((*(const WindowHandle::OSHandle*)local_this).get_int_handle)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowHandle_OSHandle_get_int_handle_126_comment =
  "C++ Interface:\n"
  "get_int_handle(OSHandle self)\n"
  "\n"
  "/**\n"
  " * Returns the OS-specific handle converted to an integer, if this is possible\n"
  " * for the particular representation.  Returns 0 if it is not.\n"
  " */";
#else
static const char *Dtool_WindowHandle_OSHandle_get_int_handle_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void WindowHandle::OSHandle::output(std::ostream &out) const
 */
static PyObject *Dtool_WindowHandle_OSHandle_output_127(PyObject *self, PyObject *arg) {
  WindowHandle::OSHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowHandle_OSHandle)) {
    return nullptr;
  }
  // 1-virtual void WindowHandle::OSHandle::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "OSHandle.output", false, true);
  if (arg_this != nullptr) {
    ((*(const WindowHandle::OSHandle*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(OSHandle self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowHandle_OSHandle_output_127_comment =
  "C++ Interface:\n"
  "output(OSHandle self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_WindowHandle_OSHandle_output_127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle WindowHandle::OSHandle::get_class_type(void)
 */
static PyObject *Dtool_WindowHandle_OSHandle_get_class_type_128(PyObject *, PyObject *) {
  // 1-static TypeHandle WindowHandle::OSHandle::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((WindowHandle::OSHandle::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_WindowHandle_OSHandle_get_class_type_128_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_WindowHandle_OSHandle_get_class_type_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline WindowHandle::OSHandle::OSHandle(WindowHandle::OSHandle const &) = default
 */
static int Dtool_Init_WindowHandle_OSHandle(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("OSHandle() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline WindowHandle::OSHandle::OSHandle(WindowHandle::OSHandle const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    WindowHandle::OSHandle const *param0_this = (WindowHandle::OSHandle *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_WindowHandle_OSHandle, 0, "OSHandle.OSHandle", true, true);
    if (param0_this != nullptr) {
      WindowHandle::OSHandle *return_value = new WindowHandle::OSHandle(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WindowHandle_OSHandle, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OSHandle(const OSHandle param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_WindowHandle_OSHandle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_WindowHandle_OSHandle) {
    printf("WindowHandle_OSHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  WindowHandle::OSHandle *local_this = (WindowHandle::OSHandle *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_WindowHandle_OSHandle) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_WindowHandle_OSHandle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_WindowHandle_OSHandle) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (WindowHandle::OSHandle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (WindowHandle::OSHandle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (WindowHandle::OSHandle*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class WindowProperties
 */
/**
 * Python function wrapper for:
 * void WindowProperties::operator =(WindowProperties const &copy)
 */
static PyObject *Dtool_WindowProperties_operator_138(PyObject *self, PyObject *arg) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.assign")) {
    return nullptr;
  }
  // 1-void WindowProperties::operator =(WindowProperties const &copy)
  WindowProperties arg_local;
  WindowProperties const *arg_this = Dtool_Coerce_WindowProperties(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "WindowProperties.assign", "WindowProperties");
  }
  ((*local_this).operator =)(*arg_this);
  WindowProperties *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_WindowProperties, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const WindowProperties self, const WindowProperties copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_operator_138_comment =
  "C++ Interface:\n"
  "assign(const WindowProperties self, const WindowProperties copy)\n";
#else
static const char *Dtool_WindowProperties_operator_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static WindowProperties WindowProperties::get_config_properties(void)
 */
static PyObject *Dtool_WindowProperties_get_config_properties_140(PyObject *, PyObject *) {
  // 1-static WindowProperties WindowProperties::get_config_properties(void)
  WindowProperties *return_value = new WindowProperties((WindowProperties::get_config_properties)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_WindowProperties, true, false);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_config_properties_140_comment =
  "C++ Interface:\n"
  "get_config_properties()\n"
  "\n"
  "/**\n"
  " * Returns a WindowProperties structure with all of the default values filled\n"
  " * in according to the user's config file.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_config_properties_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static WindowProperties WindowProperties::get_default(void)
 */
static PyObject *Dtool_WindowProperties_get_default_141(PyObject *, PyObject *) {
  // 1-static WindowProperties WindowProperties::get_default(void)
  WindowProperties *return_value = new WindowProperties((WindowProperties::get_default)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_WindowProperties, true, false);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_default_141_comment =
  "C++ Interface:\n"
  "get_default()\n"
  "\n"
  "/**\n"
  " * Returns the \"default\" WindowProperties.  If set_default() has been called,\n"
  " * this returns that WindowProperties structure; otherwise, this returns\n"
  " * get_config_properties().\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_default_141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void WindowProperties::set_default(WindowProperties const &default_properties)
 */
static PyObject *Dtool_WindowProperties_set_default_142(PyObject *, PyObject *arg) {
  // 1-static void WindowProperties::set_default(WindowProperties const &default_properties)
  WindowProperties arg_local;
  WindowProperties const *arg_this = Dtool_Coerce_WindowProperties(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "WindowProperties.set_default", "WindowProperties");
  }
  (WindowProperties::set_default)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_default(const WindowProperties default_properties)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_set_default_142_comment =
  "C++ Interface:\n"
  "set_default(const WindowProperties default_properties)\n"
  "\n"
  "/**\n"
  " * Replaces the \"default\" WindowProperties with the specified structure.  The\n"
  " * specified WindowProperties will be returned by future calls to\n"
  " * get_default(), until clear_default() is called.\n"
  " *\n"
  " * Note that this completely replaces the default properties; it is not\n"
  " * additive.\n"
  " */";
#else
static const char *Dtool_WindowProperties_set_default_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void WindowProperties::clear_default(void)
 */
static PyObject *Dtool_WindowProperties_clear_default_143(PyObject *, PyObject *) {
  // 1-static void WindowProperties::clear_default(void)
  (WindowProperties::clear_default)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_default_143_comment =
  "C++ Interface:\n"
  "clear_default()\n"
  "\n"
  "/**\n"
  " * Returns the \"default\" WindowProperties to whatever is specified in the\n"
  " * user's config file.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_default_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static WindowProperties WindowProperties::size(LVecBase2i const &size)
 * static WindowProperties WindowProperties::size(int x_size, int y_size)
 */
static PyObject *Dtool_WindowProperties_size_146(PyObject *, PyObject *args) {
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-static WindowProperties WindowProperties::size(LVecBase2i const &size)
      LVecBase2i arg_local;
      LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
      if (!(arg_this != nullptr)) {
        return Dtool_Raise_ArgTypeError(arg, 0, "WindowProperties.size", "LVecBase2i");
      }
      WindowProperties *return_value = new WindowProperties((WindowProperties::size)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_WindowProperties, true, false);
    }
    break;
  case 2:
    {
      // 1-static WindowProperties WindowProperties::size(int x_size, int y_size)
      int param0;
      int param1;
      if (PyArg_ParseTuple(args, "ii:size", &param0, &param1)) {
        WindowProperties *return_value = new WindowProperties((WindowProperties::size)((int)param0, (int)param1));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_WindowProperties, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "size() takes 1 or 2 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "size(const LVecBase2i size)\n"
      "size(int x_size, int y_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_size_146_comment =
  "C++ Interface:\n"
  "size(const LVecBase2i size)\n"
  "size(int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Returns a WindowProperties structure with only the size specified.  The\n"
  " * size is the only property that matters to buffers.\n"
  " *\n"
  " * @deprecated in the Python API, use WindowProperties(size=(x, y)) instead.\n"
  " */";
#else
static const char *Dtool_WindowProperties_size_146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void WindowProperties::clear(void)
 */
static PyObject *Dtool_WindowProperties_clear_149(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.clear")) {
    return nullptr;
  }
  // 1-void WindowProperties::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_149_comment =
  "C++ Interface:\n"
  "clear(const WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Unsets all properties that have been specified so far, and resets the\n"
  " * WindowProperties structure to its initial empty state.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::is_any_specified(void) const
 */
static PyObject *Dtool_WindowProperties_is_any_specified_150(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::is_any_specified(void) const
  bool return_value = ((*(const WindowProperties*)local_this).is_any_specified)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_is_any_specified_150_comment =
  "C++ Interface:\n"
  "is_any_specified(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if any properties have been specified, false otherwise.\n"
  " */";
#else
static const char *Dtool_WindowProperties_is_any_specified_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::set_origin(LPoint2i const &origin)
 * inline void WindowProperties::set_origin(int x_origin, int y_origin)
 */
static PyObject *Dtool_WindowProperties_set_origin_151(PyObject *self, PyObject *args, PyObject *kwds) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.set_origin")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "origin")) {
        // 1-inline void WindowProperties::set_origin(LPoint2i const &origin)
        LPoint2i arg_local;
        LPoint2i const *arg_this = Dtool_Coerce_LPoint2i(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "WindowProperties.set_origin", "LPoint2i");
        }
        ((*local_this).set_origin)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void WindowProperties::set_origin(int x_origin, int y_origin)
      int param1;
      int param2;
      static const char *keyword_list[] = {"x_origin", "y_origin", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_origin", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).set_origin)((int)param1, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_origin() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_origin(const WindowProperties self, const LPoint2i origin)\n"
      "set_origin(const WindowProperties self, int x_origin, int y_origin)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_set_origin_151_comment =
  "C++ Interface:\n"
  "set_origin(const WindowProperties self, const LPoint2i origin)\n"
  "set_origin(const WindowProperties self, int x_origin, int y_origin)\n"
  "\n"
  "/**\n"
  " * Specifies the origin on the screen (in pixels, relative to the top-left\n"
  " * corner) at which the window should appear.  This is the origin of the top-\n"
  " * left corner of the useful part of the window, not including decorations.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies the origin on the screen (in pixels, relative to the top-left\n"
  " * corner) at which the window should appear.  This is the origin of the top-\n"
  " * left corner of the useful part of the window, not including decorations.\n"
  " */";
#else
static const char *Dtool_WindowProperties_set_origin_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2i const &WindowProperties::get_origin(void) const
 */
static PyObject *Dtool_WindowProperties_get_origin_152(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline LPoint2i const &WindowProperties::get_origin(void) const
  LPoint2i const *return_value = &(((*(const WindowProperties*)local_this).get_origin)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_origin_152_comment =
  "C++ Interface:\n"
  "get_origin(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinates of the window's top-left corner, not including\n"
  " * decorations.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_origin_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int WindowProperties::get_x_origin(void) const
 */
static PyObject *Dtool_WindowProperties_get_x_origin_153(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline int WindowProperties::get_x_origin(void) const
  int return_value = ((*(const WindowProperties*)local_this).get_x_origin)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_x_origin_153_comment =
  "C++ Interface:\n"
  "get_x_origin(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the x coordinate of the window's top-left corner, not including\n"
  " * decorations.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_x_origin_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int WindowProperties::get_y_origin(void) const
 */
static PyObject *Dtool_WindowProperties_get_y_origin_154(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline int WindowProperties::get_y_origin(void) const
  int return_value = ((*(const WindowProperties*)local_this).get_y_origin)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_y_origin_154_comment =
  "C++ Interface:\n"
  "get_y_origin(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the y coordinate of the window's top-left corner, not including\n"
  " * decorations.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_y_origin_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::has_origin(void) const
 */
static PyObject *Dtool_WindowProperties_has_origin_155(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::has_origin(void) const
  bool return_value = ((*(const WindowProperties*)local_this).has_origin)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_has_origin_155_comment =
  "C++ Interface:\n"
  "has_origin(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if the window origin has been specified, false otherwise.\n"
  " */";
#else
static const char *Dtool_WindowProperties_has_origin_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::clear_origin(void)
 */
static PyObject *Dtool_WindowProperties_clear_origin_156(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.clear_origin")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::clear_origin(void)
  ((*local_this).clear_origin)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_origin_156_comment =
  "C++ Interface:\n"
  "clear_origin(const WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the origin specification from the properties.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_origin_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::set_size(LVector2i const &size)
 * inline void WindowProperties::set_size(int x_size, int y_size)
 */
static PyObject *Dtool_WindowProperties_set_size_160(PyObject *self, PyObject *args, PyObject *kwds) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.set_size")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "size")) {
        // 1-inline void WindowProperties::set_size(LVector2i const &size)
        LVector2i arg_local;
        LVector2i const *arg_this = Dtool_Coerce_LVector2i(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "WindowProperties.set_size", "LVector2i");
        }
        ((*local_this).set_size)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void WindowProperties::set_size(int x_size, int y_size)
      int param1;
      int param2;
      static const char *keyword_list[] = {"x_size", "y_size", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_size", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).set_size)((int)param1, (int)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_size() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_size(const WindowProperties self, const LVector2i size)\n"
      "set_size(const WindowProperties self, int x_size, int y_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_set_size_160_comment =
  "C++ Interface:\n"
  "set_size(const WindowProperties self, const LVector2i size)\n"
  "set_size(const WindowProperties self, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Specifies the requested size of the window, in pixels.  This is the size of\n"
  " * the useful part of the window, not including decorations.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies the requested size of the window, in pixels.  This is the size of\n"
  " * the useful part of the window, not including decorations.\n"
  " */";
#else
static const char *Dtool_WindowProperties_set_size_160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector2i const &WindowProperties::get_size(void) const
 */
static PyObject *Dtool_WindowProperties_get_size_161(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline LVector2i const &WindowProperties::get_size(void) const
  LVector2i const *return_value = &(((*(const WindowProperties*)local_this).get_size)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_size_161_comment =
  "C++ Interface:\n"
  "get_size(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns size in pixels of the useful part of the window, not including\n"
  " * decorations.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_size_161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int WindowProperties::get_x_size(void) const
 */
static PyObject *Dtool_WindowProperties_get_x_size_162(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline int WindowProperties::get_x_size(void) const
  int return_value = ((*(const WindowProperties*)local_this).get_x_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_x_size_162_comment =
  "C++ Interface:\n"
  "get_x_size(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns size in pixels in the x dimension of the useful part of the window,\n"
  " * not including decorations.  That is, this is the window's width.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_x_size_162_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int WindowProperties::get_y_size(void) const
 */
static PyObject *Dtool_WindowProperties_get_y_size_163(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline int WindowProperties::get_y_size(void) const
  int return_value = ((*(const WindowProperties*)local_this).get_y_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_y_size_163_comment =
  "C++ Interface:\n"
  "get_y_size(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns size in pixels in the y dimension of the useful part of the window,\n"
  " * not including decorations.  That is, this is the window's height.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_y_size_163_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::has_size(void) const
 */
static PyObject *Dtool_WindowProperties_has_size_164(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::has_size(void) const
  bool return_value = ((*(const WindowProperties*)local_this).has_size)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_has_size_164_comment =
  "C++ Interface:\n"
  "has_size(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if the window size has been specified, false otherwise.\n"
  " */";
#else
static const char *Dtool_WindowProperties_has_size_164_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::clear_size(void)
 */
static PyObject *Dtool_WindowProperties_clear_size_165(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.clear_size")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::clear_size(void)
  ((*local_this).clear_size)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_size_165_comment =
  "C++ Interface:\n"
  "clear_size(const WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the size specification from the properties.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_size_165_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::has_mouse_mode(void) const
 */
static PyObject *Dtool_WindowProperties_has_mouse_mode_169(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::has_mouse_mode(void) const
  bool return_value = ((*(const WindowProperties*)local_this).has_mouse_mode)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_has_mouse_mode_169_comment =
  "C++ Interface:\n"
  "has_mouse_mode(WindowProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_WindowProperties_has_mouse_mode_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::set_mouse_mode(WindowProperties::MouseMode mode)
 */
static PyObject *Dtool_WindowProperties_set_mouse_mode_170(PyObject *self, PyObject *arg) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.set_mouse_mode")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::set_mouse_mode(WindowProperties::MouseMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_mouse_mode)((WindowProperties::MouseMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mouse_mode(const WindowProperties self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_set_mouse_mode_170_comment =
  "C++ Interface:\n"
  "set_mouse_mode(const WindowProperties self, int mode)\n"
  "\n"
  "/**\n"
  " * Specifies the mode in which the window is to operate its mouse pointer.\n"
  " *\n"
  " * M_absolute: the normal mode in which a mouse pointer operates, where the\n"
  " * mouse can move outside the window and the mouse coordinates are relative to\n"
  " * its position in the window.\n"
  " *\n"
  " * M_relative (OSX or Unix/X11 only): a mode where only relative movements are\n"
  " * reported; particularly useful for FPS-style mouse movements where you have\n"
  " * hidden the mouse pointer and are are more interested in how fast the mouse\n"
  " * is moving, rather than precisely where the pointer is hovering.\n"
  " *\n"
  " * This has no effect on Windows.  On Unix/X11, this requires the Xxf86dga\n"
  " * extension to be available.\n"
  " *\n"
  " * M_confined: this mode reports absolute mouse positions, but confines the\n"
  " * mouse pointer to the window boundary.  It can portably replace M_relative\n"
  " * for an FPS, but you need to periodically move the pointer to the center of\n"
  " * the window and track movement deltas.\n"
  " *\n"
  " */";
#else
static const char *Dtool_WindowProperties_set_mouse_mode_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline WindowProperties::MouseMode WindowProperties::get_mouse_mode(void) const
 */
static PyObject *Dtool_WindowProperties_get_mouse_mode_171(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline WindowProperties::MouseMode WindowProperties::get_mouse_mode(void) const
  WindowProperties::MouseMode return_value = ((*(const WindowProperties*)local_this).get_mouse_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_mouse_mode_171_comment =
  "C++ Interface:\n"
  "get_mouse_mode(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * See set_mouse_mode().\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_mouse_mode_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::clear_mouse_mode(void)
 */
static PyObject *Dtool_WindowProperties_clear_mouse_mode_172(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.clear_mouse_mode")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::clear_mouse_mode(void)
  ((*local_this).clear_mouse_mode)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_mouse_mode_172_comment =
  "C++ Interface:\n"
  "clear_mouse_mode(const WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the mouse_mode specification from the properties.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_mouse_mode_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::set_title(std::string const &title)
 */
static PyObject *Dtool_WindowProperties_set_title_174(PyObject *self, PyObject *arg) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.set_title")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::set_title(std::string const &title)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_title)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_title(const WindowProperties self, str title)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_set_title_174_comment =
  "C++ Interface:\n"
  "set_title(const WindowProperties self, str title)\n"
  "\n"
  "/**\n"
  " * Specifies the title that should be assigned to the window.\n"
  " */";
#else
static const char *Dtool_WindowProperties_set_title_174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &WindowProperties::get_title(void) const
 */
static PyObject *Dtool_WindowProperties_get_title_175(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline std::string const &WindowProperties::get_title(void) const
  std::string const &return_value = ((*(const WindowProperties*)local_this).get_title)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_title_175_comment =
  "C++ Interface:\n"
  "get_title(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the window's title.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_title_175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::has_title(void) const
 */
static PyObject *Dtool_WindowProperties_has_title_176(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::has_title(void) const
  bool return_value = ((*(const WindowProperties*)local_this).has_title)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_has_title_176_comment =
  "C++ Interface:\n"
  "has_title(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if the window title has been specified, false otherwise.\n"
  " */";
#else
static const char *Dtool_WindowProperties_has_title_176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::clear_title(void)
 */
static PyObject *Dtool_WindowProperties_clear_title_177(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.clear_title")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::clear_title(void)
  ((*local_this).clear_title)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_title_177_comment =
  "C++ Interface:\n"
  "clear_title(const WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the title specification from the properties.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_title_177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::set_undecorated(bool undecorated)
 */
static PyObject *Dtool_WindowProperties_set_undecorated_180(PyObject *self, PyObject *arg) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.set_undecorated")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::set_undecorated(bool undecorated)
  ((*local_this).set_undecorated)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_undecorated(const WindowProperties self, bool undecorated)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_set_undecorated_180_comment =
  "C++ Interface:\n"
  "set_undecorated(const WindowProperties self, bool undecorated)\n"
  "\n"
  "/**\n"
  " * Specifies whether the window should be created with a visible title and\n"
  " * border (false, the default) or not (true).\n"
  " */";
#else
static const char *Dtool_WindowProperties_set_undecorated_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::get_undecorated(void) const
 */
static PyObject *Dtool_WindowProperties_get_undecorated_181(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::get_undecorated(void) const
  bool return_value = ((*(const WindowProperties*)local_this).get_undecorated)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_undecorated_181_comment =
  "C++ Interface:\n"
  "get_undecorated(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if the window has no border.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_undecorated_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::has_undecorated(void) const
 */
static PyObject *Dtool_WindowProperties_has_undecorated_182(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::has_undecorated(void) const
  bool return_value = ((*(const WindowProperties*)local_this).has_undecorated)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_has_undecorated_182_comment =
  "C++ Interface:\n"
  "has_undecorated(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if set_undecorated() has been specified.\n"
  " */";
#else
static const char *Dtool_WindowProperties_has_undecorated_182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::clear_undecorated(void)
 */
static PyObject *Dtool_WindowProperties_clear_undecorated_183(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.clear_undecorated")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::clear_undecorated(void)
  ((*local_this).clear_undecorated)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_undecorated_183_comment =
  "C++ Interface:\n"
  "clear_undecorated(const WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the undecorated specification from the properties.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_undecorated_183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::set_fixed_size(bool fixed_size)
 */
static PyObject *Dtool_WindowProperties_set_fixed_size_186(PyObject *self, PyObject *arg) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.set_fixed_size")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::set_fixed_size(bool fixed_size)
  ((*local_this).set_fixed_size)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fixed_size(const WindowProperties self, bool fixed_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_set_fixed_size_186_comment =
  "C++ Interface:\n"
  "set_fixed_size(const WindowProperties self, bool fixed_size)\n"
  "\n"
  "/**\n"
  " * Specifies whether the window should be resizable by the user.\n"
  " */";
#else
static const char *Dtool_WindowProperties_set_fixed_size_186_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::get_fixed_size(void) const
 */
static PyObject *Dtool_WindowProperties_get_fixed_size_187(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::get_fixed_size(void) const
  bool return_value = ((*(const WindowProperties*)local_this).get_fixed_size)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_fixed_size_187_comment =
  "C++ Interface:\n"
  "get_fixed_size(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if the window cannot be resized by the user, false otherwise.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_fixed_size_187_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::has_fixed_size(void) const
 */
static PyObject *Dtool_WindowProperties_has_fixed_size_188(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::has_fixed_size(void) const
  bool return_value = ((*(const WindowProperties*)local_this).has_fixed_size)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_has_fixed_size_188_comment =
  "C++ Interface:\n"
  "has_fixed_size(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if set_fixed_size() has been specified.\n"
  " */";
#else
static const char *Dtool_WindowProperties_has_fixed_size_188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::clear_fixed_size(void)
 */
static PyObject *Dtool_WindowProperties_clear_fixed_size_189(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.clear_fixed_size")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::clear_fixed_size(void)
  ((*local_this).clear_fixed_size)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_fixed_size_189_comment =
  "C++ Interface:\n"
  "clear_fixed_size(const WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the fixed_size specification from the properties.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_fixed_size_189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::set_fullscreen(bool fullscreen)
 */
static PyObject *Dtool_WindowProperties_set_fullscreen_191(PyObject *self, PyObject *arg) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.set_fullscreen")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::set_fullscreen(bool fullscreen)
  ((*local_this).set_fullscreen)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fullscreen(const WindowProperties self, bool fullscreen)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_set_fullscreen_191_comment =
  "C++ Interface:\n"
  "set_fullscreen(const WindowProperties self, bool fullscreen)\n"
  "\n"
  "/**\n"
  " * Specifies whether the window should be opened in fullscreen mode (true) or\n"
  " * normal windowed mode (false, the default).\n"
  " */";
#else
static const char *Dtool_WindowProperties_set_fullscreen_191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::get_fullscreen(void) const
 */
static PyObject *Dtool_WindowProperties_get_fullscreen_192(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::get_fullscreen(void) const
  bool return_value = ((*(const WindowProperties*)local_this).get_fullscreen)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_fullscreen_192_comment =
  "C++ Interface:\n"
  "get_fullscreen(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if the window is in fullscreen mode.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_fullscreen_192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::has_fullscreen(void) const
 */
static PyObject *Dtool_WindowProperties_has_fullscreen_193(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::has_fullscreen(void) const
  bool return_value = ((*(const WindowProperties*)local_this).has_fullscreen)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_has_fullscreen_193_comment =
  "C++ Interface:\n"
  "has_fullscreen(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if set_fullscreen() has been specified.\n"
  " */";
#else
static const char *Dtool_WindowProperties_has_fullscreen_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::clear_fullscreen(void)
 */
static PyObject *Dtool_WindowProperties_clear_fullscreen_194(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.clear_fullscreen")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::clear_fullscreen(void)
  ((*local_this).clear_fullscreen)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_fullscreen_194_comment =
  "C++ Interface:\n"
  "clear_fullscreen(const WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the fullscreen specification from the properties.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_fullscreen_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::set_foreground(bool foreground)
 */
static PyObject *Dtool_WindowProperties_set_foreground_196(PyObject *self, PyObject *arg) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.set_foreground")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::set_foreground(bool foreground)
  ((*local_this).set_foreground)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_foreground(const WindowProperties self, bool foreground)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_set_foreground_196_comment =
  "C++ Interface:\n"
  "set_foreground(const WindowProperties self, bool foreground)\n"
  "\n"
  "/**\n"
  " * Specifies whether the window should be opened in the foreground (true), or\n"
  " * left in the background (false).\n"
  " */";
#else
static const char *Dtool_WindowProperties_set_foreground_196_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::get_foreground(void) const
 */
static PyObject *Dtool_WindowProperties_get_foreground_197(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::get_foreground(void) const
  bool return_value = ((*(const WindowProperties*)local_this).get_foreground)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_foreground_197_comment =
  "C++ Interface:\n"
  "get_foreground(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if the window is in the foreground.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_foreground_197_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::has_foreground(void) const
 */
static PyObject *Dtool_WindowProperties_has_foreground_198(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::has_foreground(void) const
  bool return_value = ((*(const WindowProperties*)local_this).has_foreground)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_has_foreground_198_comment =
  "C++ Interface:\n"
  "has_foreground(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if set_foreground() has been specified.\n"
  " */";
#else
static const char *Dtool_WindowProperties_has_foreground_198_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::clear_foreground(void)
 */
static PyObject *Dtool_WindowProperties_clear_foreground_199(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.clear_foreground")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::clear_foreground(void)
  ((*local_this).clear_foreground)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_foreground_199_comment =
  "C++ Interface:\n"
  "clear_foreground(const WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the foreground specification from the properties.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_foreground_199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::set_minimized(bool minimized)
 */
static PyObject *Dtool_WindowProperties_set_minimized_201(PyObject *self, PyObject *arg) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.set_minimized")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::set_minimized(bool minimized)
  ((*local_this).set_minimized)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_minimized(const WindowProperties self, bool minimized)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_set_minimized_201_comment =
  "C++ Interface:\n"
  "set_minimized(const WindowProperties self, bool minimized)\n"
  "\n"
  "/**\n"
  " * Specifies whether the window should be created minimized (true), or normal\n"
  " * (false).\n"
  " */";
#else
static const char *Dtool_WindowProperties_set_minimized_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::get_minimized(void) const
 */
static PyObject *Dtool_WindowProperties_get_minimized_202(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::get_minimized(void) const
  bool return_value = ((*(const WindowProperties*)local_this).get_minimized)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_minimized_202_comment =
  "C++ Interface:\n"
  "get_minimized(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if the window is minimized.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_minimized_202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::has_minimized(void) const
 */
static PyObject *Dtool_WindowProperties_has_minimized_203(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::has_minimized(void) const
  bool return_value = ((*(const WindowProperties*)local_this).has_minimized)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_has_minimized_203_comment =
  "C++ Interface:\n"
  "has_minimized(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if set_minimized() has been specified.\n"
  " */";
#else
static const char *Dtool_WindowProperties_has_minimized_203_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::clear_minimized(void)
 */
static PyObject *Dtool_WindowProperties_clear_minimized_204(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.clear_minimized")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::clear_minimized(void)
  ((*local_this).clear_minimized)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_minimized_204_comment =
  "C++ Interface:\n"
  "clear_minimized(const WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the minimized specification from the properties.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_minimized_204_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::set_raw_mice(bool raw_mice)
 */
static PyObject *Dtool_WindowProperties_set_raw_mice_206(PyObject *self, PyObject *arg) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.set_raw_mice")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::set_raw_mice(bool raw_mice)
  ((*local_this).set_raw_mice)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_raw_mice(const WindowProperties self, bool raw_mice)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_set_raw_mice_206_comment =
  "C++ Interface:\n"
  "set_raw_mice(const WindowProperties self, bool raw_mice)\n"
  "\n"
  "/**\n"
  " * Specifies whether the window should read the raw mouse devices.\n"
  " */";
#else
static const char *Dtool_WindowProperties_set_raw_mice_206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::get_raw_mice(void) const
 */
static PyObject *Dtool_WindowProperties_get_raw_mice_207(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::get_raw_mice(void) const
  bool return_value = ((*(const WindowProperties*)local_this).get_raw_mice)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_raw_mice_207_comment =
  "C++ Interface:\n"
  "get_raw_mice(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if the window reads the raw mice.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_raw_mice_207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::has_raw_mice(void) const
 */
static PyObject *Dtool_WindowProperties_has_raw_mice_208(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::has_raw_mice(void) const
  bool return_value = ((*(const WindowProperties*)local_this).has_raw_mice)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_has_raw_mice_208_comment =
  "C++ Interface:\n"
  "has_raw_mice(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if set_raw_mice() has been specified.\n"
  " */";
#else
static const char *Dtool_WindowProperties_has_raw_mice_208_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::clear_raw_mice(void)
 */
static PyObject *Dtool_WindowProperties_clear_raw_mice_209(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.clear_raw_mice")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::clear_raw_mice(void)
  ((*local_this).clear_raw_mice)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_raw_mice_209_comment =
  "C++ Interface:\n"
  "clear_raw_mice(const WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the raw_mice specification from the properties.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_raw_mice_209_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::set_open(bool open)
 */
static PyObject *Dtool_WindowProperties_set_open_210(PyObject *self, PyObject *arg) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.set_open")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::set_open(bool open)
  ((*local_this).set_open)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_open(const WindowProperties self, bool open)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_set_open_210_comment =
  "C++ Interface:\n"
  "set_open(const WindowProperties self, bool open)\n"
  "\n"
  "/**\n"
  " * Specifies whether the window should be open.  It is legal to create a\n"
  " * GraphicsWindow in the closed state, and later request it to open by\n"
  " * changing this flag.\n"
  " */";
#else
static const char *Dtool_WindowProperties_set_open_210_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::get_open(void) const
 */
static PyObject *Dtool_WindowProperties_get_open_211(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::get_open(void) const
  bool return_value = ((*(const WindowProperties*)local_this).get_open)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_open_211_comment =
  "C++ Interface:\n"
  "get_open(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if the window is open.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_open_211_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::has_open(void) const
 */
static PyObject *Dtool_WindowProperties_has_open_212(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::has_open(void) const
  bool return_value = ((*(const WindowProperties*)local_this).has_open)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_has_open_212_comment =
  "C++ Interface:\n"
  "has_open(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if set_open() has been specified.\n"
  " */";
#else
static const char *Dtool_WindowProperties_has_open_212_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::clear_open(void)
 */
static PyObject *Dtool_WindowProperties_clear_open_213(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.clear_open")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::clear_open(void)
  ((*local_this).clear_open)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_open_213_comment =
  "C++ Interface:\n"
  "clear_open(const WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the open specification from the properties.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_open_213_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::set_cursor_hidden(bool cursor_hidden)
 */
static PyObject *Dtool_WindowProperties_set_cursor_hidden_215(PyObject *self, PyObject *arg) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.set_cursor_hidden")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::set_cursor_hidden(bool cursor_hidden)
  ((*local_this).set_cursor_hidden)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cursor_hidden(const WindowProperties self, bool cursor_hidden)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_set_cursor_hidden_215_comment =
  "C++ Interface:\n"
  "set_cursor_hidden(const WindowProperties self, bool cursor_hidden)\n"
  "\n"
  "/**\n"
  " * Specifies whether the mouse cursor should be visible.\n"
  " */";
#else
static const char *Dtool_WindowProperties_set_cursor_hidden_215_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::get_cursor_hidden(void) const
 */
static PyObject *Dtool_WindowProperties_get_cursor_hidden_216(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::get_cursor_hidden(void) const
  bool return_value = ((*(const WindowProperties*)local_this).get_cursor_hidden)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_cursor_hidden_216_comment =
  "C++ Interface:\n"
  "get_cursor_hidden(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if the mouse cursor is invisible.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_cursor_hidden_216_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::has_cursor_hidden(void) const
 */
static PyObject *Dtool_WindowProperties_has_cursor_hidden_217(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::has_cursor_hidden(void) const
  bool return_value = ((*(const WindowProperties*)local_this).has_cursor_hidden)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_has_cursor_hidden_217_comment =
  "C++ Interface:\n"
  "has_cursor_hidden(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if set_cursor_hidden() has been specified.\n"
  " */";
#else
static const char *Dtool_WindowProperties_has_cursor_hidden_217_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::clear_cursor_hidden(void)
 */
static PyObject *Dtool_WindowProperties_clear_cursor_hidden_218(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.clear_cursor_hidden")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::clear_cursor_hidden(void)
  ((*local_this).clear_cursor_hidden)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_cursor_hidden_218_comment =
  "C++ Interface:\n"
  "clear_cursor_hidden(const WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the cursor_hidden specification from the properties.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_cursor_hidden_218_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::set_icon_filename(Filename const &icon_filename)
 */
static PyObject *Dtool_WindowProperties_set_icon_filename_220(PyObject *self, PyObject *arg) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.set_icon_filename")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::set_icon_filename(Filename const &icon_filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "WindowProperties.set_icon_filename", "Filename");
  }
  ((*local_this).set_icon_filename)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_icon_filename(const WindowProperties self, const Filename icon_filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_set_icon_filename_220_comment =
  "C++ Interface:\n"
  "set_icon_filename(const WindowProperties self, const Filename icon_filename)\n"
  "\n"
  "/**\n"
  " * Specifies the file that contains the icon to associate with the window when\n"
  " * it is minimized.\n"
  " */";
#else
static const char *Dtool_WindowProperties_set_icon_filename_220_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &WindowProperties::get_icon_filename(void) const
 */
static PyObject *Dtool_WindowProperties_get_icon_filename_221(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline Filename const &WindowProperties::get_icon_filename(void) const
  Filename const *return_value = &(((*(const WindowProperties*)local_this).get_icon_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_icon_filename_221_comment =
  "C++ Interface:\n"
  "get_icon_filename(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the icon filename associated with the window.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_icon_filename_221_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::has_icon_filename(void) const
 */
static PyObject *Dtool_WindowProperties_has_icon_filename_222(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::has_icon_filename(void) const
  bool return_value = ((*(const WindowProperties*)local_this).has_icon_filename)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_has_icon_filename_222_comment =
  "C++ Interface:\n"
  "has_icon_filename(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if set_icon_filename() has been specified.\n"
  " */";
#else
static const char *Dtool_WindowProperties_has_icon_filename_222_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::clear_icon_filename(void)
 */
static PyObject *Dtool_WindowProperties_clear_icon_filename_223(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.clear_icon_filename")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::clear_icon_filename(void)
  ((*local_this).clear_icon_filename)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_icon_filename_223_comment =
  "C++ Interface:\n"
  "clear_icon_filename(const WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the icon_filename specification from the properties.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_icon_filename_223_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::set_cursor_filename(Filename const &cursor_filename)
 */
static PyObject *Dtool_WindowProperties_set_cursor_filename_227(PyObject *self, PyObject *arg) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.set_cursor_filename")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::set_cursor_filename(Filename const &cursor_filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "WindowProperties.set_cursor_filename", "Filename");
  }
  ((*local_this).set_cursor_filename)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cursor_filename(const WindowProperties self, const Filename cursor_filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_set_cursor_filename_227_comment =
  "C++ Interface:\n"
  "set_cursor_filename(const WindowProperties self, const Filename cursor_filename)\n"
  "\n"
  "/**\n"
  " * Specifies the file that contains the icon to associate with the mouse\n"
  " * cursor when it is within the window (and visible).\n"
  " */";
#else
static const char *Dtool_WindowProperties_set_cursor_filename_227_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &WindowProperties::get_cursor_filename(void) const
 */
static PyObject *Dtool_WindowProperties_get_cursor_filename_228(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline Filename const &WindowProperties::get_cursor_filename(void) const
  Filename const *return_value = &(((*(const WindowProperties*)local_this).get_cursor_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_cursor_filename_228_comment =
  "C++ Interface:\n"
  "get_cursor_filename(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the icon filename associated with the mouse cursor.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_cursor_filename_228_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::has_cursor_filename(void) const
 */
static PyObject *Dtool_WindowProperties_has_cursor_filename_229(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::has_cursor_filename(void) const
  bool return_value = ((*(const WindowProperties*)local_this).has_cursor_filename)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_has_cursor_filename_229_comment =
  "C++ Interface:\n"
  "has_cursor_filename(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if set_cursor_filename() has been specified.\n"
  " */";
#else
static const char *Dtool_WindowProperties_has_cursor_filename_229_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::clear_cursor_filename(void)
 */
static PyObject *Dtool_WindowProperties_clear_cursor_filename_230(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.clear_cursor_filename")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::clear_cursor_filename(void)
  ((*local_this).clear_cursor_filename)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_cursor_filename_230_comment =
  "C++ Interface:\n"
  "clear_cursor_filename(const WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the cursor_filename specification from the properties.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_cursor_filename_230_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::set_z_order(WindowProperties::ZOrder z_order)
 */
static PyObject *Dtool_WindowProperties_set_z_order_232(PyObject *self, PyObject *arg) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.set_z_order")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::set_z_order(WindowProperties::ZOrder z_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_z_order)((WindowProperties::ZOrder)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_z_order(const WindowProperties self, int z_order)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_set_z_order_232_comment =
  "C++ Interface:\n"
  "set_z_order(const WindowProperties self, int z_order)\n"
  "\n"
  "/**\n"
  " * Specifies the relative ordering of the window with respect to other\n"
  " * windows.  If the z_order is Z_top, the window will always be on top of\n"
  " * other windows; if it is Z_bottom, it will always be below other windows.\n"
  " * Most windows will want to be Z_normal, which allows the user to control the\n"
  " * order.\n"
  " */";
#else
static const char *Dtool_WindowProperties_set_z_order_232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline WindowProperties::ZOrder WindowProperties::get_z_order(void) const
 */
static PyObject *Dtool_WindowProperties_get_z_order_233(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline WindowProperties::ZOrder WindowProperties::get_z_order(void) const
  WindowProperties::ZOrder return_value = ((*(const WindowProperties*)local_this).get_z_order)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_z_order_233_comment =
  "C++ Interface:\n"
  "get_z_order(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the window's z_order.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_z_order_233_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::has_z_order(void) const
 */
static PyObject *Dtool_WindowProperties_has_z_order_234(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::has_z_order(void) const
  bool return_value = ((*(const WindowProperties*)local_this).has_z_order)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_has_z_order_234_comment =
  "C++ Interface:\n"
  "has_z_order(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if the window z_order has been specified, false otherwise.\n"
  " */";
#else
static const char *Dtool_WindowProperties_has_z_order_234_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::clear_z_order(void)
 */
static PyObject *Dtool_WindowProperties_clear_z_order_235(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.clear_z_order")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::clear_z_order(void)
  ((*local_this).clear_z_order)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_z_order_235_comment =
  "C++ Interface:\n"
  "clear_z_order(const WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the z_order specification from the properties.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_z_order_235_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::set_parent_window(WindowHandle *parent_window = nullptr)
 * void WindowProperties::set_parent_window(std::size_t parent)
 */
static PyObject *Dtool_WindowProperties_set_parent_window_237(PyObject *self, PyObject *args, PyObject *kwds) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.set_parent_window")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void WindowProperties::set_parent_window(WindowHandle *parent_window)
      ((*local_this).set_parent_window)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      {
        // -2 inline void WindowProperties::set_parent_window(WindowHandle *parent_window)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "parent_window")) {
          WindowHandle *param1_this = nullptr;
          if (param1 != Py_None) {
            param1_this = (WindowHandle *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_WindowHandle, 1, "WindowProperties.set_parent_window", false, false);
          }
          if ((param1 == Py_None || param1_this != nullptr)) {
            ((*local_this).set_parent_window)(param1_this);
            return Dtool_Return_None();
          }
        }
      }

      {
        // -2 void WindowProperties::set_parent_window(std::size_t parent)
        Py_ssize_t param1;
        static const char *keyword_list[] = {"parent", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "n:set_parent_window", (char **)keyword_list, &param1)) {
#ifndef NDEBUG
          if (param1 < 0) {
            return PyErr_Format(PyExc_OverflowError,
                                "can't convert negative value %zd to size_t",
                                param1);
          }
#endif
          ((*local_this).set_parent_window)((std::size_t)param1);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      {
        // -2 inline void WindowProperties::set_parent_window(WindowHandle *parent_window)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "parent_window")) {
          PT(WindowHandle) param1_this;
          if ((param1 == Py_None || Dtool_Coerce_WindowHandle(param1, param1_this))) {
            ((*local_this).set_parent_window)(std::move(param1_this));
            return Dtool_Return_None();
          }
        }
      }

      // No coercion possible: void WindowProperties::set_parent_window(std::size_t parent)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_parent_window() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_parent_window(const WindowProperties self)\n"
      "set_parent_window(const WindowProperties self, WindowHandle parent_window)\n"
      "set_parent_window(const WindowProperties self, int parent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_set_parent_window_237_comment =
  "C++ Interface:\n"
  "set_parent_window(const WindowProperties self)\n"
  "set_parent_window(const WindowProperties self, WindowHandle parent_window)\n"
  "set_parent_window(const WindowProperties self, int parent)\n"
  "\n"
  "/**\n"
  " * Specifies the window that this window should be attached to.  If this is\n"
  " * NULL or unspecified, the window will be created as a toplevel window on the\n"
  " * desktop; if this is non-NULL, the window will be bound as a child window to\n"
  " * the indicated parent window.\n"
  " *\n"
  " * You should use GraphicsPipe::make_window_handle() to create an instance of\n"
  " * a WindowHandle object given an appropriate OS-specific window handle\n"
  " * representation.  Each OS-specific GraphicsPipe class defines a\n"
  " * make_window_handle() method that returns an appropriate WindowHandle object\n"
  " * to wrap the particular OS-specific representation.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies the window that this window should be attached to.\n"
  " *\n"
  " * This is a deprecated variant on this method, and exists only for backward\n"
  " * compatibility.  Future code should use the version of set_parent_window()\n"
  " * below that receives a WindowHandle object; that interface is much more\n"
  " * robust.\n"
  " *\n"
  " * In this deprecated variant, the actual value for \"parent\" is platform-\n"
  " * specific.  On Windows, it is the HWND of the parent window, cast to an\n"
  " * unsigned integer.  On X11, it is the Window pointer of the parent window,\n"
  " * similarly cast.  On OSX, this is the NSWindow pointer, which doesn't appear\n"
  " * to work at all.\n"
  " */";
#else
static const char *Dtool_WindowProperties_set_parent_window_237_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline WindowHandle *WindowProperties::get_parent_window(void) const
 */
static PyObject *Dtool_WindowProperties_get_parent_window_238(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline WindowHandle *WindowProperties::get_parent_window(void) const
  WindowHandle *return_value = ((*(const WindowProperties*)local_this).get_parent_window)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_WindowHandle, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_get_parent_window_238_comment =
  "C++ Interface:\n"
  "get_parent_window(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Returns the parent window specification, or NULL if there is no parent\n"
  " * window specified.\n"
  " */";
#else
static const char *Dtool_WindowProperties_get_parent_window_238_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WindowProperties::has_parent_window(void) const
 */
static PyObject *Dtool_WindowProperties_has_parent_window_239(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-inline bool WindowProperties::has_parent_window(void) const
  bool return_value = ((*(const WindowProperties*)local_this).has_parent_window)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_has_parent_window_239_comment =
  "C++ Interface:\n"
  "has_parent_window(WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Checks the S_parent_window specification from the properties.\n"
  " */";
#else
static const char *Dtool_WindowProperties_has_parent_window_239_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WindowProperties::clear_parent_window(void)
 */
static PyObject *Dtool_WindowProperties_clear_parent_window_240(PyObject *self, PyObject *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.clear_parent_window")) {
    return nullptr;
  }
  // 1-inline void WindowProperties::clear_parent_window(void)
  ((*local_this).clear_parent_window)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_clear_parent_window_240_comment =
  "C++ Interface:\n"
  "clear_parent_window(const WindowProperties self)\n"
  "\n"
  "/**\n"
  " * Removes the S_parent_window specification from the properties.\n"
  " */";
#else
static const char *Dtool_WindowProperties_clear_parent_window_240_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void WindowProperties::add_properties(WindowProperties const &other)
 */
static PyObject *Dtool_WindowProperties_add_properties_243(PyObject *self, PyObject *arg) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.add_properties")) {
    return nullptr;
  }
  // 1-void WindowProperties::add_properties(WindowProperties const &other)
  WindowProperties arg_local;
  WindowProperties const *arg_this = Dtool_Coerce_WindowProperties(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "WindowProperties.add_properties", "WindowProperties");
  }
  ((*local_this).add_properties)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_properties(const WindowProperties self, const WindowProperties other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_add_properties_243_comment =
  "C++ Interface:\n"
  "add_properties(const WindowProperties self, const WindowProperties other)\n"
  "\n"
  "/**\n"
  " * Sets any properties that are explicitly specified in other on this object.\n"
  " * Leaves other properties unchanged.\n"
  " */";
#else
static const char *Dtool_WindowProperties_add_properties_243_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void WindowProperties::output(std::ostream &out) const
 */
static PyObject *Dtool_WindowProperties_output_244(PyObject *self, PyObject *arg) {
  WindowProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WindowProperties)) {
    return nullptr;
  }
  // 1-void WindowProperties::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "WindowProperties.output", false, true);
  if (arg_this != nullptr) {
    ((*(const WindowProperties*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(WindowProperties self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WindowProperties_output_244_comment =
  "C++ Interface:\n"
  "output(WindowProperties self, ostream out)\n"
  "\n"
  "/**\n"
  " * Sets any properties that are explicitly specified in other on this object.\n"
  " * Leaves other properties unchanged.\n"
  " */";
#else
static const char *Dtool_WindowProperties_output_244_comment = nullptr;
#endif

static PyObject *Dtool_WindowProperties_config_properties_Getter(PyObject *self, void *) {
  // 1-static WindowProperties WindowProperties::get_config_properties(void)
  WindowProperties *return_value = new WindowProperties((WindowProperties::get_config_properties)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_WindowProperties, true, false);
}

static PyObject *Dtool_WindowProperties_default_Getter(PyObject *self, void *) {
  // 1-static WindowProperties WindowProperties::get_default(void)
  WindowProperties *return_value = new WindowProperties((WindowProperties::get_default)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_WindowProperties, true, false);
}

static int Dtool_WindowProperties_default_Setter(PyObject *self, PyObject *arg, void *) {
  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete default attribute");
    return -1;
  }
  // 1-static void WindowProperties::set_default(WindowProperties const &default_properties)
  WindowProperties arg_local;
  WindowProperties const *arg_this = Dtool_Coerce_WindowProperties(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 0, "WindowProperties.set_default", "WindowProperties");
    return -1;
  }
  (WindowProperties::set_default)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_default(const WindowProperties default_properties)\n");
  }
  return -1;
}

static PyObject *Dtool_WindowProperties_origin_Getter(PyObject *self, void *) {
  const WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_origin()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LPoint2i const &WindowProperties::get_origin(void) const
  LPoint2i const *return_value = &(((*(const WindowProperties*)local_this).get_origin)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2i, false, true);
}

static int Dtool_WindowProperties_origin_Setter(PyObject *self, PyObject *arg, void *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.origin")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete origin attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_origin();
    return 0;
  }
  // 1-inline void WindowProperties::set_origin(LPoint2i const &origin)
  LPoint2i arg_local;
  LPoint2i const *arg_this = Dtool_Coerce_LPoint2i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "WindowProperties.set_origin", "LPoint2i");
    return -1;
  }
  ((*local_this).set_origin)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_origin(const WindowProperties self, const LPoint2i origin)\n");
  }
  return -1;
}

static PyObject *Dtool_WindowProperties_size_Getter(PyObject *self, void *) {
  if (self == nullptr) {
    static PyMethodDef def = {"size", &Dtool_WindowProperties_size_146, METH_VARARGS | METH_STATIC, (const char *)Dtool_WindowProperties_size_146_comment};
    return PyCFunction_New(&def, nullptr);
  }

  const WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_size()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LVector2i const &WindowProperties::get_size(void) const
  LVector2i const *return_value = &(((*(const WindowProperties*)local_this).get_size)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2i, false, true);
}

static int Dtool_WindowProperties_size_Setter(PyObject *self, PyObject *arg, void *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.size")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete size attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_size();
    return 0;
  }
  // 1-inline void WindowProperties::set_size(LVector2i const &size)
  LVector2i arg_local;
  LVector2i const *arg_this = Dtool_Coerce_LVector2i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "WindowProperties.set_size", "LVector2i");
    return -1;
  }
  ((*local_this).set_size)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_size(const WindowProperties self, const LVector2i size)\n");
  }
  return -1;
}

static PyObject *Dtool_WindowProperties_mouse_mode_Getter(PyObject *self, void *) {
  const WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_mouse_mode()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline WindowProperties::MouseMode WindowProperties::get_mouse_mode(void) const
  WindowProperties::MouseMode return_value = ((*(const WindowProperties*)local_this).get_mouse_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_WindowProperties_mouse_mode_Setter(PyObject *self, PyObject *arg, void *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.mouse_mode")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete mouse_mode attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_mouse_mode();
    return 0;
  }
  // 1-inline void WindowProperties::set_mouse_mode(WindowProperties::MouseMode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_mouse_mode)((WindowProperties::MouseMode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_mouse_mode(const WindowProperties self, int mode)\n");
  }
  return -1;
}

static PyObject *Dtool_WindowProperties_title_Getter(PyObject *self, void *) {
  const WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_title()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline std::string const &WindowProperties::get_title(void) const
  std::string const &return_value = ((*(const WindowProperties*)local_this).get_title)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_WindowProperties_title_Setter(PyObject *self, PyObject *arg, void *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.title")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete title attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_title();
    return 0;
  }
  // 1-inline void WindowProperties::set_title(std::string const &title)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_title)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_title(const WindowProperties self, str title)\n");
  }
  return -1;
}

static PyObject *Dtool_WindowProperties_undecorated_Getter(PyObject *self, void *) {
  const WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_undecorated()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool WindowProperties::get_undecorated(void) const
  bool return_value = ((*(const WindowProperties*)local_this).get_undecorated)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_WindowProperties_undecorated_Setter(PyObject *self, PyObject *arg, void *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.undecorated")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete undecorated attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_undecorated();
    return 0;
  }
  // 1-inline void WindowProperties::set_undecorated(bool undecorated)
  ((*local_this).set_undecorated)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_undecorated(const WindowProperties self, bool undecorated)\n");
  }
  return -1;
}

static PyObject *Dtool_WindowProperties_fixed_size_Getter(PyObject *self, void *) {
  const WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_fixed_size()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool WindowProperties::get_fixed_size(void) const
  bool return_value = ((*(const WindowProperties*)local_this).get_fixed_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_WindowProperties_fixed_size_Setter(PyObject *self, PyObject *arg, void *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.fixed_size")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete fixed_size attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_fixed_size();
    return 0;
  }
  // 1-inline void WindowProperties::set_fixed_size(bool fixed_size)
  ((*local_this).set_fixed_size)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_fixed_size(const WindowProperties self, bool fixed_size)\n");
  }
  return -1;
}

static PyObject *Dtool_WindowProperties_fullscreen_Getter(PyObject *self, void *) {
  const WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_fullscreen()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool WindowProperties::get_fullscreen(void) const
  bool return_value = ((*(const WindowProperties*)local_this).get_fullscreen)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_WindowProperties_fullscreen_Setter(PyObject *self, PyObject *arg, void *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.fullscreen")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete fullscreen attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_fullscreen();
    return 0;
  }
  // 1-inline void WindowProperties::set_fullscreen(bool fullscreen)
  ((*local_this).set_fullscreen)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_fullscreen(const WindowProperties self, bool fullscreen)\n");
  }
  return -1;
}

static PyObject *Dtool_WindowProperties_foreground_Getter(PyObject *self, void *) {
  const WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_foreground()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool WindowProperties::get_foreground(void) const
  bool return_value = ((*(const WindowProperties*)local_this).get_foreground)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_WindowProperties_foreground_Setter(PyObject *self, PyObject *arg, void *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.foreground")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete foreground attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_foreground();
    return 0;
  }
  // 1-inline void WindowProperties::set_foreground(bool foreground)
  ((*local_this).set_foreground)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_foreground(const WindowProperties self, bool foreground)\n");
  }
  return -1;
}

static PyObject *Dtool_WindowProperties_minimized_Getter(PyObject *self, void *) {
  const WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_minimized()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool WindowProperties::get_minimized(void) const
  bool return_value = ((*(const WindowProperties*)local_this).get_minimized)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_WindowProperties_minimized_Setter(PyObject *self, PyObject *arg, void *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.minimized")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete minimized attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_minimized();
    return 0;
  }
  // 1-inline void WindowProperties::set_minimized(bool minimized)
  ((*local_this).set_minimized)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_minimized(const WindowProperties self, bool minimized)\n");
  }
  return -1;
}

static PyObject *Dtool_WindowProperties_open_Getter(PyObject *self, void *) {
  const WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_open()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool WindowProperties::get_open(void) const
  bool return_value = ((*(const WindowProperties*)local_this).get_open)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_WindowProperties_open_Setter(PyObject *self, PyObject *arg, void *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.open")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete open attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_open();
    return 0;
  }
  // 1-inline void WindowProperties::set_open(bool open)
  ((*local_this).set_open)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_open(const WindowProperties self, bool open)\n");
  }
  return -1;
}

static PyObject *Dtool_WindowProperties_cursor_hidden_Getter(PyObject *self, void *) {
  const WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_cursor_hidden()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline bool WindowProperties::get_cursor_hidden(void) const
  bool return_value = ((*(const WindowProperties*)local_this).get_cursor_hidden)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_WindowProperties_cursor_hidden_Setter(PyObject *self, PyObject *arg, void *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.cursor_hidden")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete cursor_hidden attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_cursor_hidden();
    return 0;
  }
  // 1-inline void WindowProperties::set_cursor_hidden(bool cursor_hidden)
  ((*local_this).set_cursor_hidden)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cursor_hidden(const WindowProperties self, bool cursor_hidden)\n");
  }
  return -1;
}

static PyObject *Dtool_WindowProperties_icon_filename_Getter(PyObject *self, void *) {
  const WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_icon_filename()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline Filename const &WindowProperties::get_icon_filename(void) const
  Filename const *return_value = &(((*(const WindowProperties*)local_this).get_icon_filename)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static int Dtool_WindowProperties_icon_filename_Setter(PyObject *self, PyObject *arg, void *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.icon_filename")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete icon_filename attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_icon_filename();
    return 0;
  }
  // 1-inline void WindowProperties::set_icon_filename(Filename const &icon_filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "WindowProperties.set_icon_filename", "Filename");
    return -1;
  }
  ((*local_this).set_icon_filename)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_icon_filename(const WindowProperties self, const Filename icon_filename)\n");
  }
  return -1;
}

static PyObject *Dtool_WindowProperties_cursor_filename_Getter(PyObject *self, void *) {
  const WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_cursor_filename()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline Filename const &WindowProperties::get_cursor_filename(void) const
  Filename const *return_value = &(((*(const WindowProperties*)local_this).get_cursor_filename)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static int Dtool_WindowProperties_cursor_filename_Setter(PyObject *self, PyObject *arg, void *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.cursor_filename")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete cursor_filename attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_cursor_filename();
    return 0;
  }
  // 1-inline void WindowProperties::set_cursor_filename(Filename const &cursor_filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "WindowProperties.set_cursor_filename", "Filename");
    return -1;
  }
  ((*local_this).set_cursor_filename)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cursor_filename(const WindowProperties self, const Filename cursor_filename)\n");
  }
  return -1;
}

static PyObject *Dtool_WindowProperties_z_order_Getter(PyObject *self, void *) {
  const WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_z_order()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline WindowProperties::ZOrder WindowProperties::get_z_order(void) const
  WindowProperties::ZOrder return_value = ((*(const WindowProperties*)local_this).get_z_order)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_WindowProperties_z_order_Setter(PyObject *self, PyObject *arg, void *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.z_order")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete z_order attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_z_order();
    return 0;
  }
  // 1-inline void WindowProperties::set_z_order(WindowProperties::ZOrder z_order)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_z_order)((WindowProperties::ZOrder)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_z_order(const WindowProperties self, int z_order)\n");
  }
  return -1;
}

static PyObject *Dtool_WindowProperties_parent_window_Getter(PyObject *self, void *) {
  const WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowProperties, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_parent_window()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline WindowHandle *WindowProperties::get_parent_window(void) const
  WindowHandle *return_value = ((*(const WindowProperties*)local_this).get_parent_window)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_WindowHandle, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_WindowProperties_parent_window_Setter(PyObject *self, PyObject *arg, void *) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_WindowProperties, (void **)&local_this, "WindowProperties.parent_window")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete parent_window attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_parent_window();
    return 0;
  }
  {
    // -2 inline void WindowProperties::set_parent_window(WindowHandle *parent_window)
    WindowHandle *arg_this = nullptr;
    if (arg != Py_None) {
      arg_this = (WindowHandle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_WindowHandle, 1, "WindowProperties.set_parent_window", false, false);
    }
    if ((arg == Py_None || arg_this != nullptr)) {
      ((*local_this).set_parent_window)(arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  {
    // -2 void WindowProperties::set_parent_window(std::size_t parent)
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return -1;
      }
#endif
      ((*local_this).set_parent_window)(arg_val);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  {
    // -2 inline void WindowProperties::set_parent_window(WindowHandle *parent_window)
    PT(WindowHandle) arg_this;
    if ((arg == Py_None || Dtool_Coerce_WindowHandle(arg, arg_this))) {
      ((*local_this).set_parent_window)(std::move(arg_this));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  // No coercion possible: void WindowProperties::set_parent_window(std::size_t parent)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_parent_window(const WindowProperties self, WindowHandle parent_window)\n"
      "set_parent_window(const WindowProperties self, int parent)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * WindowProperties::WindowProperties(PyObject *self, PyObject *args, PyObject *kwds)
 */
static int Dtool_Init_WindowProperties(PyObject *self, PyObject *args, PyObject *kwds) {
  // Pre-initialize self for the constructor
  DTool_PyInit_Finalize(self, nullptr, &Dtool_WindowProperties, false, false);
  WindowProperties *result = new WindowProperties;
  invoke_extension(result).__init__(self, args, kwds);
  WindowProperties *return_value = result;
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WindowProperties, true, false);
}

WindowProperties *Dtool_Coerce_WindowProperties(PyObject *args, WindowProperties &coerced) {
  WindowProperties *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_WindowProperties)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const WindowProperties *)local_this;
      return &coerced;
    }
    return local_this;
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_WindowProperties(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_WindowProperties) {
    printf("WindowProperties ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  WindowProperties *local_this = (WindowProperties *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_WindowProperties) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_WindowProperties(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_WindowProperties) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DisplayRegion
 */
/**
 * Python function wrapper for:
 * inline int DisplayRegion::get_num_regions(void) const
 */
static PyObject *Dtool_DisplayRegion_get_num_regions_251(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline int DisplayRegion::get_num_regions(void) const
  int return_value = ((*(const DisplayRegion*)local_this).get_num_regions)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_num_regions_251_comment =
  "C++ Interface:\n"
  "get_num_regions(DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the number of regions, see set_num_regions.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_num_regions_251_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DisplayRegion::set_num_regions(int i)
 */
static PyObject *Dtool_DisplayRegion_set_num_regions_252(PyObject *self, PyObject *arg) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.set_num_regions")) {
    return nullptr;
  }
  // 1-inline void DisplayRegion::set_num_regions(int i)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_num_regions)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_regions(const DisplayRegion self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_set_num_regions_252_comment =
  "C++ Interface:\n"
  "set_num_regions(const DisplayRegion self, int i)\n"
  "\n"
  "/**\n"
  " * Sets the number of regions that this DisplayRegion indicates.  Usually,\n"
  " * this number is 1 (and it is always at least 1), and only the first is used\n"
  " * for rendering.  However, if more than one is provided, you may select which\n"
  " * one to render into using a geometry shader (gl_ViewportIndex in GLSL).\n"
  " */";
#else
static const char *Dtool_DisplayRegion_set_num_regions_252_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 DisplayRegion::get_dimensions(int i = 0) const
 */
static PyObject *Dtool_DisplayRegion_get_dimensions_253(PyObject *self, PyObject *args, PyObject *kwds) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline LVecBase4 DisplayRegion::get_dimensions(int i = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"i", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_dimensions", (char **)keyword_list, &param1)) {
    LVecBase4 *return_value = new LVecBase4(((*(const DisplayRegion*)local_this).get_dimensions)((int)param1));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_dimensions(DisplayRegion self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_dimensions_253_comment =
  "C++ Interface:\n"
  "get_dimensions(DisplayRegion self, int i)\n"
  "\n"
  "/**\n"
  " * Retrieves the coordinates of the DisplayRegion's rectangle within its\n"
  " * GraphicsOutput.  These numbers will be in the range [0..1].\n"
  " */\n"
  "\n"
  "/**\n"
  " * Retrieves the coordinates of the DisplayRegion's rectangle within its\n"
  " * GraphicsOutput.  These numbers will be in the range [0..1].\n"
  " */\n"
  "\n"
  "/**\n"
  " * Retrieves the coordinates of the DisplayRegion's rectangle within its\n"
  " * GraphicsOutput.  These numbers will be in the range [0..1].\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_dimensions_253_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DisplayRegion::get_left(int i = 0) const
 */
static PyObject *Dtool_DisplayRegion_get_left_254(PyObject *self, PyObject *args, PyObject *kwds) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DisplayRegion::get_left(int i = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"i", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_left", (char **)keyword_list, &param1)) {
    PN_stdfloat return_value = ((*(const DisplayRegion*)local_this).get_left)((int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_left(DisplayRegion self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_left_254_comment =
  "C++ Interface:\n"
  "get_left(DisplayRegion self, int i)\n"
  "\n"
  "/**\n"
  " * Retrieves the x coordinate of the left edge of the rectangle within its\n"
  " * GraphicsOutput.  This number will be in the range [0..1].\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_left_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DisplayRegion::get_right(int i = 0) const
 */
static PyObject *Dtool_DisplayRegion_get_right_255(PyObject *self, PyObject *args, PyObject *kwds) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DisplayRegion::get_right(int i = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"i", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_right", (char **)keyword_list, &param1)) {
    PN_stdfloat return_value = ((*(const DisplayRegion*)local_this).get_right)((int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_right(DisplayRegion self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_right_255_comment =
  "C++ Interface:\n"
  "get_right(DisplayRegion self, int i)\n"
  "\n"
  "/**\n"
  " * Retrieves the x coordinate of the right edge of the rectangle within its\n"
  " * GraphicsOutput.  This number will be in the range [0..1].\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_right_255_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DisplayRegion::get_bottom(int i = 0) const
 */
static PyObject *Dtool_DisplayRegion_get_bottom_256(PyObject *self, PyObject *args, PyObject *kwds) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DisplayRegion::get_bottom(int i = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"i", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_bottom", (char **)keyword_list, &param1)) {
    PN_stdfloat return_value = ((*(const DisplayRegion*)local_this).get_bottom)((int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bottom(DisplayRegion self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_bottom_256_comment =
  "C++ Interface:\n"
  "get_bottom(DisplayRegion self, int i)\n"
  "\n"
  "/**\n"
  " * Retrieves the y coordinate of the bottom edge of the rectangle within its\n"
  " * GraphicsOutput.  This number will be in the range [0..1].\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_bottom_256_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DisplayRegion::get_top(int i = 0) const
 */
static PyObject *Dtool_DisplayRegion_get_top_257(PyObject *self, PyObject *args, PyObject *kwds) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DisplayRegion::get_top(int i = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"i", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_top", (char **)keyword_list, &param1)) {
    PN_stdfloat return_value = ((*(const DisplayRegion*)local_this).get_top)((int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_top(DisplayRegion self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_top_257_comment =
  "C++ Interface:\n"
  "get_top(DisplayRegion self, int i)\n"
  "\n"
  "/**\n"
  " * Retrieves the y coordinate of the top edge of the rectangle within its\n"
  " * GraphicsOutput.  This number will be in the range [0..1].\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_top_257_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DisplayRegion::set_dimensions(LVecBase4 const &dimensions)
 * inline void DisplayRegion::set_dimensions(PN_stdfloat l, PN_stdfloat r, PN_stdfloat b, PN_stdfloat t)
 * virtual void DisplayRegion::set_dimensions(int i, LVecBase4 const &dimensions)
 * inline void DisplayRegion::set_dimensions(int i, PN_stdfloat l, PN_stdfloat r, PN_stdfloat b, PN_stdfloat t)
 */
static PyObject *Dtool_DisplayRegion_set_dimensions_258(PyObject *self, PyObject *args, PyObject *kwds) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.set_dimensions")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "dimensions")) {
        // 1-inline void DisplayRegion::set_dimensions(LVecBase4 const &dimensions)
        LVecBase4f arg_local;
        LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "DisplayRegion.set_dimensions", "LVecBase4f");
        }
        ((*local_this).set_dimensions)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-virtual void DisplayRegion::set_dimensions(int i, LVecBase4 const &dimensions)
      int param1;
      PyObject *param2;
      static const char *keyword_list[] = {"i", "dimensions", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_dimensions", (char **)keyword_list, &param1, &param2)) {
        LVecBase4f param2_local;
        LVecBase4 const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "DisplayRegion.set_dimensions", "LVecBase4f");
        }
        ((*local_this).set_dimensions)((int)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void DisplayRegion::set_dimensions(PN_stdfloat l, PN_stdfloat r, PN_stdfloat b, PN_stdfloat t)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"l", "r", "b", "t", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_dimensions", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_dimensions)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        return Dtool_Return_None();
      }
    }
    break;
  case 5:
    {
      // 1-inline void DisplayRegion::set_dimensions(int i, PN_stdfloat l, PN_stdfloat r, PN_stdfloat b, PN_stdfloat t)
      int param1;
      float param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"i", "l", "r", "b", "t", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iffff:set_dimensions", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        ((*local_this).set_dimensions)((int)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4, (PN_stdfloat)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_dimensions() takes 2, 3, 5 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dimensions(const DisplayRegion self, const LVecBase4f dimensions)\n"
      "set_dimensions(const DisplayRegion self, int i, const LVecBase4f dimensions)\n"
      "set_dimensions(const DisplayRegion self, float l, float r, float b, float t)\n"
      "set_dimensions(const DisplayRegion self, int i, float l, float r, float b, float t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_set_dimensions_258_comment =
  "C++ Interface:\n"
  "set_dimensions(const DisplayRegion self, const LVecBase4f dimensions)\n"
  "set_dimensions(const DisplayRegion self, int i, const LVecBase4f dimensions)\n"
  "set_dimensions(const DisplayRegion self, float l, float r, float b, float t)\n"
  "set_dimensions(const DisplayRegion self, int i, float l, float r, float b, float t)\n"
  "\n"
  "/**\n"
  " * Changes the portion of the framebuffer this DisplayRegion corresponds to.\n"
  " * The parameters range from 0 to 1, where 0,0 is the lower left corner and\n"
  " * 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the portion of the framebuffer this DisplayRegion corresponds to.\n"
  " * The parameters range from 0 to 1, where 0,0 is the lower left corner and\n"
  " * 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the portion of the framebuffer this DisplayRegion corresponds to.\n"
  " * The parameters range from 0 to 1, where 0,0 is the lower left corner and\n"
  " * 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Changes the portion of the framebuffer this DisplayRegion corresponds to.\n"
  " * The parameters range from 0 to 1, where 0,0 is the lower left corner and\n"
  " * 1,1 is the upper right; (0, 1, 0, 1) represents the whole screen.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_set_dimensions_258_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsOutput *DisplayRegion::get_window(void) const
 */
static PyObject *Dtool_DisplayRegion_get_window_261(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline GraphicsOutput *DisplayRegion::get_window(void) const
  GraphicsOutput *return_value = ((*(const DisplayRegion*)local_this).get_window)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutput, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_window_261_comment =
  "C++ Interface:\n"
  "get_window(DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the GraphicsOutput that this DisplayRegion is ultimately associated\n"
  " * with, or NULL if no window is associated.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_window_261_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GraphicsPipe *DisplayRegion::get_pipe(void) const
 */
static PyObject *Dtool_DisplayRegion_get_pipe_262(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-GraphicsPipe *DisplayRegion::get_pipe(void) const
  GraphicsPipe *return_value = ((*(const DisplayRegion*)local_this).get_pipe)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsPipe, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_pipe_262_comment =
  "C++ Interface:\n"
  "get_pipe(DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the GraphicsPipe that this DisplayRegion is ultimately associated\n"
  " * with, or NULL if no pipe is associated.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_pipe_262_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool DisplayRegion::is_stereo(void) const
 */
static PyObject *Dtool_DisplayRegion_is_stereo_263(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-virtual bool DisplayRegion::is_stereo(void) const
  bool return_value = ((*(const DisplayRegion*)local_this).is_stereo)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_is_stereo_263_comment =
  "C++ Interface:\n"
  "is_stereo(DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns true if this is a StereoDisplayRegion, false otherwise.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_is_stereo_263_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DisplayRegion::set_camera(NodePath const &camera)
 */
static PyObject *Dtool_DisplayRegion_set_camera_619(PyObject *self, PyObject *arg) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.set_camera")) {
    return nullptr;
  }
  // 1-virtual void DisplayRegion::set_camera(NodePath const &camera)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "DisplayRegion.set_camera", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_camera)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_camera(const DisplayRegion self, const NodePath camera)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_set_camera_619_comment =
  "C++ Interface:\n"
  "set_camera(const DisplayRegion self, const NodePath camera)\n"
  "\n"
  "/**\n"
  " * Sets the camera that is associated with this DisplayRegion.  There is a\n"
  " * one-to-many association between cameras and DisplayRegions; one camera may\n"
  " * be shared by multiple DisplayRegions.\n"
  " *\n"
  " * The camera is actually set via a NodePath, which clarifies which instance\n"
  " * of the camera (if there happen to be multiple instances) we should use.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_set_camera_619_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath DisplayRegion::get_camera(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_DisplayRegion_get_camera_620(PyObject *self, PyObject *args, PyObject *kwds) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline NodePath DisplayRegion::get_camera(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "DisplayRegion.get_camera", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      NodePath *return_value = new NodePath(((*(const DisplayRegion*)local_this).get_camera)(param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_camera(DisplayRegion self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_camera_620_comment =
  "C++ Interface:\n"
  "get_camera(DisplayRegion self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the camera associated with this DisplayRegion, or an empty NodePath\n"
  " * if no camera is associated.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_camera_620_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DisplayRegion::set_active(bool active)
 */
static PyObject *Dtool_DisplayRegion_set_active_623(PyObject *self, PyObject *arg) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.set_active")) {
    return nullptr;
  }
  // 1-virtual void DisplayRegion::set_active(bool active)
  ((*local_this).set_active)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active(const DisplayRegion self, bool active)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_set_active_623_comment =
  "C++ Interface:\n"
  "set_active(const DisplayRegion self, bool active)\n"
  "\n"
  "/**\n"
  " * Sets the active flag associated with the DisplayRegion.  If the\n"
  " * DisplayRegion is marked inactive, nothing is rendered.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_set_active_623_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DisplayRegion::is_active(void) const
 */
static PyObject *Dtool_DisplayRegion_is_active_624(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline bool DisplayRegion::is_active(void) const
  bool return_value = ((*(const DisplayRegion*)local_this).is_active)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_is_active_624_comment =
  "C++ Interface:\n"
  "is_active(DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the active flag associated with the DisplayRegion.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_is_active_624_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DisplayRegion::set_sort(int sort)
 */
static PyObject *Dtool_DisplayRegion_set_sort_626(PyObject *self, PyObject *arg) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.set_sort")) {
    return nullptr;
  }
  // 1-virtual void DisplayRegion::set_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_sort)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sort(const DisplayRegion self, int sort)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_set_sort_626_comment =
  "C++ Interface:\n"
  "set_sort(const DisplayRegion self, int sort)\n"
  "\n"
  "/**\n"
  " * Sets the sort value associated with the DisplayRegion.  Within a window,\n"
  " * DisplayRegions will be rendered in order from the lowest sort value to the\n"
  " * highest.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_set_sort_626_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DisplayRegion::get_sort(void) const
 */
static PyObject *Dtool_DisplayRegion_get_sort_627(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline int DisplayRegion::get_sort(void) const
  int return_value = ((*(const DisplayRegion*)local_this).get_sort)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_sort_627_comment =
  "C++ Interface:\n"
  "get_sort(DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the sort value associated with the DisplayRegion.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_sort_627_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DisplayRegion::set_stereo_channel(Lens::StereoChannel stereo_channel)
 */
static PyObject *Dtool_DisplayRegion_set_stereo_channel_629(PyObject *self, PyObject *arg) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.set_stereo_channel")) {
    return nullptr;
  }
  // 1-virtual void DisplayRegion::set_stereo_channel(Lens::StereoChannel stereo_channel)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_stereo_channel)((Lens::StereoChannel)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_stereo_channel(const DisplayRegion self, int stereo_channel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_set_stereo_channel_629_comment =
  "C++ Interface:\n"
  "set_stereo_channel(const DisplayRegion self, int stereo_channel)\n"
  "\n"
  "/**\n"
  " * Specifies whether the DisplayRegion represents the left or right channel of\n"
  " * a stereo pair, or whether it is a normal, monocular image.  This\n"
  " * automatically adjusts the lens that is used to render to this DisplayRegion\n"
  " * to its left or right eye, according to the lens's stereo properties.\n"
  " *\n"
  " * When the DisplayRegion is attached to a stereo window (one for which\n"
  " * is_stereo() returns true), this also specifies which physical channel the\n"
  " * DisplayRegion renders to.\n"
  " *\n"
  " * Normally you would create at least two DisplayRegions for a stereo window,\n"
  " * one for each of the left and right channels.  The two DisplayRegions may\n"
  " * share the same camera (and thus the same lens); this parameter is used to\n"
  " * control the exact properties of the lens when it is used to render into\n"
  " * this DisplayRegion.\n"
  " *\n"
  " * Also see the StereoDisplayRegion, which automates managing a pair of\n"
  " * left/right DisplayRegions.\n"
  " *\n"
  " * An ordinary DisplayRegion may be set to SC_mono, SC_left, or SC_right.  You\n"
  " * may set SC_stereo only on a StereoDisplayRegion.\n"
  " *\n"
  " * This call also resets tex_view_offset to its default value, which is 0 for\n"
  " * the left eye or 1 for the right eye of a stereo display region, or 0 for a\n"
  " * mono display region.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_set_stereo_channel_629_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Lens::StereoChannel DisplayRegion::get_stereo_channel(void) const
 */
static PyObject *Dtool_DisplayRegion_get_stereo_channel_630(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline Lens::StereoChannel DisplayRegion::get_stereo_channel(void) const
  Lens::StereoChannel return_value = ((*(const DisplayRegion*)local_this).get_stereo_channel)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_stereo_channel_630_comment =
  "C++ Interface:\n"
  "get_stereo_channel(DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns whether the DisplayRegion is specified as the left or right channel\n"
  " * of a stereo pair, or whether it is a normal, monocular image.  See\n"
  " * set_stereo_channel().\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_stereo_channel_630_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DisplayRegion::set_tex_view_offset(int tex_view_offset)
 */
static PyObject *Dtool_DisplayRegion_set_tex_view_offset_634(PyObject *self, PyObject *arg) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.set_tex_view_offset")) {
    return nullptr;
  }
  // 1-virtual void DisplayRegion::set_tex_view_offset(int tex_view_offset)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_tex_view_offset)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tex_view_offset(const DisplayRegion self, int tex_view_offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_set_tex_view_offset_634_comment =
  "C++ Interface:\n"
  "set_tex_view_offset(const DisplayRegion self, int tex_view_offset)\n"
  "\n"
  "/**\n"
  " * Sets the current texture view offset for this DisplayRegion.  This is\n"
  " * normally set to zero.  If nonzero, it is used to select a particular view\n"
  " * of any multiview textures that are rendered within this DisplayRegion.\n"
  " *\n"
  " * For a StereoDisplayRegion, this is normally 0 for the left eye, and 1 for\n"
  " * the right eye, to support stereo textures.  This is set automatically when\n"
  " * you call set_stereo_channel().\n"
  " */";
#else
static const char *Dtool_DisplayRegion_set_tex_view_offset_634_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DisplayRegion::get_tex_view_offset(void) const
 */
static PyObject *Dtool_DisplayRegion_get_tex_view_offset_635(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline int DisplayRegion::get_tex_view_offset(void) const
  int return_value = ((*(const DisplayRegion*)local_this).get_tex_view_offset)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_tex_view_offset_635_comment =
  "C++ Interface:\n"
  "get_tex_view_offset(DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the current texture view offset for this DisplayRegion.  This is\n"
  " * normally set to zero.  If nonzero, it is used to select a particular view\n"
  " * of any multiview textures that are rendered within this DisplayRegion.\n"
  " *\n"
  " * For a StereoDisplayRegion, this is normally 0 for the left eye, and 1 for\n"
  " * the right eye, to support stereo textures.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_tex_view_offset_635_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DisplayRegion::set_incomplete_render(bool incomplete_render)
 */
static PyObject *Dtool_DisplayRegion_set_incomplete_render_637(PyObject *self, PyObject *arg) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.set_incomplete_render")) {
    return nullptr;
  }
  // 1-virtual void DisplayRegion::set_incomplete_render(bool incomplete_render)
  ((*local_this).set_incomplete_render)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_incomplete_render(const DisplayRegion self, bool incomplete_render)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_set_incomplete_render_637_comment =
  "C++ Interface:\n"
  "set_incomplete_render(const DisplayRegion self, bool incomplete_render)\n"
  "\n"
  "/**\n"
  " * Sets the incomplete_render flag.  When this is true, the frame will be\n"
  " * rendered even if some of the geometry or textures in the scene are not\n"
  " * available (e.g.  they have been temporarily paged out).  When this is\n"
  " * false, the frame will be held up while this data is reloaded.\n"
  " *\n"
  " * This flag may also be set on the GraphicsStateGuardian.  It will be\n"
  " * considered true for a given DisplayRegion only if it is true on both the\n"
  " * GSG and on the DisplayRegion.\n"
  " *\n"
  " * See GraphicsStateGuardian::set_incomplete_render() for more detail.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_set_incomplete_render_637_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DisplayRegion::get_incomplete_render(void) const
 */
static PyObject *Dtool_DisplayRegion_get_incomplete_render_638(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline bool DisplayRegion::get_incomplete_render(void) const
  bool return_value = ((*(const DisplayRegion*)local_this).get_incomplete_render)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_incomplete_render_638_comment =
  "C++ Interface:\n"
  "get_incomplete_render(DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the incomplete_render flag.  See set_incomplete_render().\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_incomplete_render_638_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DisplayRegion::set_texture_reload_priority(int texture_reload_priority)
 */
static PyObject *Dtool_DisplayRegion_set_texture_reload_priority_640(PyObject *self, PyObject *arg) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.set_texture_reload_priority")) {
    return nullptr;
  }
  // 1-virtual void DisplayRegion::set_texture_reload_priority(int texture_reload_priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_texture_reload_priority)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture_reload_priority(const DisplayRegion self, int texture_reload_priority)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_set_texture_reload_priority_640_comment =
  "C++ Interface:\n"
  "set_texture_reload_priority(const DisplayRegion self, int texture_reload_priority)\n"
  "\n"
  "/**\n"
  " * Specifies an integer priority which is assigned to any asynchronous texture\n"
  " * reload requests spawned while processing this DisplayRegion.  This controls\n"
  " * which textures are loaded first when multiple textures need to be reloaded\n"
  " * at once; it also controls the relative priority between asynchronous\n"
  " * texture loads and asynchronous model or animation loads.\n"
  " *\n"
  " * Specifying a larger number here makes the textures rendered by this\n"
  " * DisplayRegion load up first.  This may be particularly useful to do, for\n"
  " * instance, for the DisplayRegion that renders the gui.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_set_texture_reload_priority_640_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DisplayRegion::get_texture_reload_priority(void) const
 */
static PyObject *Dtool_DisplayRegion_get_texture_reload_priority_641(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline int DisplayRegion::get_texture_reload_priority(void) const
  int return_value = ((*(const DisplayRegion*)local_this).get_texture_reload_priority)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_texture_reload_priority_641_comment =
  "C++ Interface:\n"
  "get_texture_reload_priority(DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the priority which is assigned to asynchronous texture reload\n"
  " * requests.  See set_texture_reload_priority().\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_texture_reload_priority_641_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DisplayRegion::set_lens_index(int index)
 */
static PyObject *Dtool_DisplayRegion_set_lens_index_643(PyObject *self, PyObject *arg) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.set_lens_index")) {
    return nullptr;
  }
  // 1-void DisplayRegion::set_lens_index(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_lens_index)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lens_index(const DisplayRegion self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_set_lens_index_643_comment =
  "C++ Interface:\n"
  "set_lens_index(const DisplayRegion self, int index)\n"
  "\n"
  "/**\n"
  " * Sets the lens index, allows for multiple lenses to be attached to a camera.\n"
  " * This is useful for a variety of setups, such as fish eye rendering.  The\n"
  " * default is 0.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_set_lens_index_643_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DisplayRegion::get_lens_index(void) const
 */
static PyObject *Dtool_DisplayRegion_get_lens_index_644(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline int DisplayRegion::get_lens_index(void) const
  int return_value = ((*(const DisplayRegion*)local_this).get_lens_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_lens_index_644_comment =
  "C++ Interface:\n"
  "get_lens_index(DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the specific lens of the associated Camera that will be used for\n"
  " * rendering this scene.  Most Cameras hold only one lens, but for multiple\n"
  " * lenses this method may be used to selected between them.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_lens_index_644_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DisplayRegion::set_cull_traverser(CullTraverser *trav)
 */
static PyObject *Dtool_DisplayRegion_set_cull_traverser_646(PyObject *self, PyObject *arg) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.set_cull_traverser")) {
    return nullptr;
  }
  // 1-virtual void DisplayRegion::set_cull_traverser(CullTraverser *trav)
  CullTraverser *arg_this = (CullTraverser *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CullTraverser, 1, "DisplayRegion.set_cull_traverser", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_cull_traverser)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cull_traverser(const DisplayRegion self, CullTraverser trav)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_set_cull_traverser_646_comment =
  "C++ Interface:\n"
  "set_cull_traverser(const DisplayRegion self, CullTraverser trav)\n"
  "\n"
  "/**\n"
  " * Specifies the CullTraverser that will be used to draw the contents of this\n"
  " * DisplayRegion.  Normally the default CullTraverser is sufficient, but this\n"
  " * may be changed to change the default cull behavior.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_set_cull_traverser_646_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CullTraverser *DisplayRegion::get_cull_traverser(void)
 */
static PyObject *Dtool_DisplayRegion_get_cull_traverser_647(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.get_cull_traverser")) {
    return nullptr;
  }
  // 1-CullTraverser *DisplayRegion::get_cull_traverser(void)
  CullTraverser *return_value = ((*local_this).get_cull_traverser)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CullTraverser, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_cull_traverser_647_comment =
  "C++ Interface:\n"
  "get_cull_traverser(const DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the CullTraverser that will be used to draw the contents of this\n"
  " * DisplayRegion.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_cull_traverser_647_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DisplayRegion::set_cube_map_index(int cube_map_index)
 */
static PyObject *Dtool_DisplayRegion_set_cube_map_index_651(PyObject *self, PyObject *arg) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.set_cube_map_index")) {
    return nullptr;
  }
  // 1-inline void DisplayRegion::set_cube_map_index(int cube_map_index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_cube_map_index)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cube_map_index(const DisplayRegion self, int cube_map_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_set_cube_map_index_651_comment =
  "C++ Interface:\n"
  "set_cube_map_index(const DisplayRegion self, int cube_map_index)\n"
  "\n"
  "/**\n"
  " * Deprecated; replaced by set_target_tex_page().\n"
  " */";
#else
static const char *Dtool_DisplayRegion_set_cube_map_index_651_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DisplayRegion::set_target_tex_page(int page)
 */
static PyObject *Dtool_DisplayRegion_set_target_tex_page_652(PyObject *self, PyObject *arg) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.set_target_tex_page")) {
    return nullptr;
  }
  // 1-virtual void DisplayRegion::set_target_tex_page(int page)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_target_tex_page)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_target_tex_page(const DisplayRegion self, int page)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_set_target_tex_page_652_comment =
  "C++ Interface:\n"
  "set_target_tex_page(const DisplayRegion self, int page)\n"
  "\n"
  "/**\n"
  " * This is a special parameter that is only used when rendering the faces of a\n"
  " * cube map or multipage and/or multiview texture.\n"
  " *\n"
  " * This sets up the DisplayRegion to render to the ith page and jth view of\n"
  " * its associated texture(s); the value must be consistent with the range of\n"
  " * values availble to the texture.  A normal DisplayRegion that is not\n"
  " * associated with any particular page should be set to page -1 and view 0.\n"
  " *\n"
  " * This is particularly useful when rendering cube maps and/or stereo\n"
  " * textures.\n"
  " *\n"
  " * Don't call this in a downstream thread unless you don't mind it blowing\n"
  " * away other changes you might have recently made in an upstream thread.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_set_target_tex_page_652_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DisplayRegion::get_target_tex_page(void) const
 */
static PyObject *Dtool_DisplayRegion_get_target_tex_page_653(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline int DisplayRegion::get_target_tex_page(void) const
  int return_value = ((*(const DisplayRegion*)local_this).get_target_tex_page)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_target_tex_page_653_comment =
  "C++ Interface:\n"
  "get_target_tex_page(DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the target page number associated with this particular\n"
  " * DisplayRegion, or -1 if it is not associated with a page.  See\n"
  " * set_target_tex_page().\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_target_tex_page_653_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DisplayRegion::set_scissor_enabled(bool scissor_enabled)
 */
static PyObject *Dtool_DisplayRegion_set_scissor_enabled_655(PyObject *self, PyObject *arg) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.set_scissor_enabled")) {
    return nullptr;
  }
  // 1-inline void DisplayRegion::set_scissor_enabled(bool scissor_enabled)
  ((*local_this).set_scissor_enabled)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scissor_enabled(const DisplayRegion self, bool scissor_enabled)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_set_scissor_enabled_655_comment =
  "C++ Interface:\n"
  "set_scissor_enabled(const DisplayRegion self, bool scissor_enabled)\n"
  "\n"
  "/**\n"
  " * Sets whether or not scissor testing is enabled for this region.  The\n"
  " * default is true, except for the overlay display region.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_set_scissor_enabled_655_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DisplayRegion::get_scissor_enabled(void) const
 */
static PyObject *Dtool_DisplayRegion_get_scissor_enabled_656(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline bool DisplayRegion::get_scissor_enabled(void) const
  bool return_value = ((*(const DisplayRegion*)local_this).get_scissor_enabled)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_scissor_enabled_656_comment =
  "C++ Interface:\n"
  "get_scissor_enabled(DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns whether or not scissor testing is enabled for this region.  The\n"
  " * default is true, except for the overlay display region.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_scissor_enabled_656_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DisplayRegion::set_cull_callback(CallbackObject *object)
 */
static PyObject *Dtool_DisplayRegion_set_cull_callback_658(PyObject *self, PyObject *arg) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.set_cull_callback")) {
    return nullptr;
  }
  // 1-inline void DisplayRegion::set_cull_callback(CallbackObject *object)
  PT(CallbackObject) arg_this;
  if (!Dtool_Coerce_CallbackObject(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DisplayRegion.set_cull_callback", "CallbackObject");
  }
  ((*local_this).set_cull_callback)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cull_callback(const DisplayRegion self, CallbackObject object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_set_cull_callback_658_comment =
  "C++ Interface:\n"
  "set_cull_callback(const DisplayRegion self, CallbackObject object)\n"
  "\n"
  "/**\n"
  " * Sets the CallbackObject that will be notified when the DisplayRegion is\n"
  " * visited during the cull traversal.  This callback will be made during the\n"
  " * cull thread.\n"
  " *\n"
  " * The cull traversal is responsible for determining which nodes are visible\n"
  " * and within the view frustum, and for accumulating state and transform, and\n"
  " * generally building up the list of CullableObjects that are to be eventually\n"
  " * passed to the draw traversal for rendering.\n"
  " *\n"
  " * At the time the cull traversal callback is made, the traversal for this\n"
  " * DisplayRegion has not yet started.\n"
  " *\n"
  " * The callback is passed an instance of a DisplayRegionCullCallbackData,\n"
  " * which contains pointers to the current scene information, as well as the\n"
  " * current DisplayRegion and GSG.  The callback *replaces* the normal cull\n"
  " * behavior, so if your callback does nothing, the scene graph will not be\n"
  " * traversed and therefore nothing will be drawn.  If you wish the normal cull\n"
  " * traversal to be performed for this DisplayRegion, you must call\n"
  " * cbdata->upcall() from your callback.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_set_cull_callback_658_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DisplayRegion::clear_cull_callback(void)
 */
static PyObject *Dtool_DisplayRegion_clear_cull_callback_659(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.clear_cull_callback")) {
    return nullptr;
  }
  // 1-inline void DisplayRegion::clear_cull_callback(void)
  ((*local_this).clear_cull_callback)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_clear_cull_callback_659_comment =
  "C++ Interface:\n"
  "clear_cull_callback(const DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Removes the callback set by an earlier call to set_cull_callback().\n"
  " */";
#else
static const char *Dtool_DisplayRegion_clear_cull_callback_659_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CallbackObject *DisplayRegion::get_cull_callback(void) const
 */
static PyObject *Dtool_DisplayRegion_get_cull_callback_660(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline CallbackObject *DisplayRegion::get_cull_callback(void) const
  CallbackObject *return_value = ((*(const DisplayRegion*)local_this).get_cull_callback)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_cull_callback_660_comment =
  "C++ Interface:\n"
  "get_cull_callback(DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the CallbackObject set by set_cull_callback().\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_cull_callback_660_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DisplayRegion::set_draw_callback(CallbackObject *object)
 */
static PyObject *Dtool_DisplayRegion_set_draw_callback_664(PyObject *self, PyObject *arg) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.set_draw_callback")) {
    return nullptr;
  }
  // 1-inline void DisplayRegion::set_draw_callback(CallbackObject *object)
  PT(CallbackObject) arg_this;
  if (!Dtool_Coerce_CallbackObject(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DisplayRegion.set_draw_callback", "CallbackObject");
  }
  ((*local_this).set_draw_callback)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_draw_callback(const DisplayRegion self, CallbackObject object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_set_draw_callback_664_comment =
  "C++ Interface:\n"
  "set_draw_callback(const DisplayRegion self, CallbackObject object)\n"
  "\n"
  "/**\n"
  " * Sets the CallbackObject that will be notified when the contents of\n"
  " * DisplayRegion is drawn during the draw traversal.  This callback will be\n"
  " * made during the draw thread.\n"
  " *\n"
  " * The draw traversal is responsible for actually issuing the commands to the\n"
  " * graphics engine to draw primitives.  Its job is to walk through the list of\n"
  " * CullableObjects build up by the cull traversal, as quickly as possible,\n"
  " * issuing the appropriate commands to draw each one.\n"
  " *\n"
  " * At the time the draw traversal callback is made, the graphics state is in\n"
  " * the initial state, and no projection matrix or modelview matrix is in\n"
  " * effect.  begin_scene() has not yet been called, and no objects have yet\n"
  " * been drawn.  However, the viewport has already been set to the appropriate\n"
  " * part of the window, and the clear commands for this DisplayRegion (if any)\n"
  " * have been issued.\n"
  " *\n"
  " * The callback is passed an instance of a DisplayRegionDrawCallbackData,\n"
  " * which contains pointers to the current scene information, as well as the\n"
  " * current DisplayRegion and GSG.  The callback *replaces* the normal draw\n"
  " * behavior, so if your callback does nothing, nothing in the DisplayRegion\n"
  " * will be drawn.  If you wish the draw traversal to continue to draw the\n"
  " * contents of this DisplayRegion, you must call cbdata->upcall() from your\n"
  " * callback.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_set_draw_callback_664_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DisplayRegion::clear_draw_callback(void)
 */
static PyObject *Dtool_DisplayRegion_clear_draw_callback_665(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.clear_draw_callback")) {
    return nullptr;
  }
  // 1-inline void DisplayRegion::clear_draw_callback(void)
  ((*local_this).clear_draw_callback)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_clear_draw_callback_665_comment =
  "C++ Interface:\n"
  "clear_draw_callback(const DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Removes the callback set by an earlier call to set_draw_callback().\n"
  " */";
#else
static const char *Dtool_DisplayRegion_clear_draw_callback_665_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CallbackObject *DisplayRegion::get_draw_callback(void) const
 */
static PyObject *Dtool_DisplayRegion_get_draw_callback_666(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline CallbackObject *DisplayRegion::get_draw_callback(void) const
  CallbackObject *return_value = ((*(const DisplayRegion*)local_this).get_draw_callback)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_draw_callback_666_comment =
  "C++ Interface:\n"
  "get_draw_callback(DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns the CallbackObject set by set_draw_callback().\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_draw_callback_666_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DisplayRegion::get_pixel_width(int i = 0) const
 */
static PyObject *Dtool_DisplayRegion_get_pixel_width_668(PyObject *self, PyObject *args, PyObject *kwds) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline int DisplayRegion::get_pixel_width(int i = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"i", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_pixel_width", (char **)keyword_list, &param1)) {
    int return_value = ((*(const DisplayRegion*)local_this).get_pixel_width)((int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pixel_width(DisplayRegion self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_pixel_width_668_comment =
  "C++ Interface:\n"
  "get_pixel_width(DisplayRegion self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the width of the DisplayRegion in pixels.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_pixel_width_668_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DisplayRegion::get_pixel_height(int i = 0) const
 */
static PyObject *Dtool_DisplayRegion_get_pixel_height_669(PyObject *self, PyObject *args, PyObject *kwds) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline int DisplayRegion::get_pixel_height(int i = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"i", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_pixel_height", (char **)keyword_list, &param1)) {
    int return_value = ((*(const DisplayRegion*)local_this).get_pixel_height)((int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pixel_height(DisplayRegion self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_pixel_height_669_comment =
  "C++ Interface:\n"
  "get_pixel_height(DisplayRegion self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the height of the DisplayRegion in pixels.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_pixel_height_669_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i DisplayRegion::get_pixel_size(int i = 0) const
 */
static PyObject *Dtool_DisplayRegion_get_pixel_size_670(PyObject *self, PyObject *args, PyObject *kwds) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-inline LVecBase2i DisplayRegion::get_pixel_size(int i = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"i", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_pixel_size", (char **)keyword_list, &param1)) {
    LVecBase2i *return_value = new LVecBase2i(((*(const DisplayRegion*)local_this).get_pixel_size)((int)param1));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pixel_size(DisplayRegion self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_pixel_size_670_comment =
  "C++ Interface:\n"
  "get_pixel_size(DisplayRegion self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the size of the DisplayRegion in pixels.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_pixel_size_670_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DisplayRegion::output(std::ostream &out) const
 */
static PyObject *Dtool_DisplayRegion_output_672(PyObject *self, PyObject *arg) {
  DisplayRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegion)) {
    return nullptr;
  }
  // 1-virtual void DisplayRegion::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "DisplayRegion.output", false, true);
  if (arg_this != nullptr) {
    ((*(const DisplayRegion*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DisplayRegion self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_output_672_comment =
  "C++ Interface:\n"
  "output(DisplayRegion self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayRegion_output_672_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static Filename DisplayRegion::make_screenshot_filename(std::string const &prefix = "screenshot")
 */
static PyObject *Dtool_DisplayRegion_make_screenshot_filename_673(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static Filename DisplayRegion::make_screenshot_filename(std::string const &prefix = "screenshot")
  const char *param0_str = "screenshot";
  Py_ssize_t param0_len = 10;
  static const char *keyword_list[] = {"prefix", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:make_screenshot_filename", (char **)keyword_list, &param0_str, &param0_len)) {
    Filename *return_value = new Filename((DisplayRegion::make_screenshot_filename)(std::string(param0_str, param0_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_screenshot_filename(str prefix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_make_screenshot_filename_673_comment =
  "C++ Interface:\n"
  "make_screenshot_filename(str prefix)\n"
  "\n"
  "/**\n"
  " * Synthesizes a suitable default filename for passing to save_screenshot().\n"
  " *\n"
  " * The default filename is generated from the supplied prefix and from the\n"
  " * Config variable screenshot-filename, which contains the following strings:\n"
  " *\n"
  " * %~p - the supplied prefix %~f - the frame count %~e - the value of\n"
  " * screenshot-extension All other % strings in strftime().\n"
  " */";
#else
static const char *Dtool_DisplayRegion_make_screenshot_filename_673_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Filename DisplayRegion::save_screenshot_default(std::string const &prefix = "screenshot")
 */
static PyObject *Dtool_DisplayRegion_save_screenshot_default_674(PyObject *self, PyObject *args, PyObject *kwds) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.save_screenshot_default")) {
    return nullptr;
  }
  // 1-Filename DisplayRegion::save_screenshot_default(std::string const &prefix = "screenshot")
  const char *param1_str = "screenshot";
  Py_ssize_t param1_len = 10;
  static const char *keyword_list[] = {"prefix", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:save_screenshot_default", (char **)keyword_list, &param1_str, &param1_len)) {
    Filename *return_value = new Filename(((*local_this).save_screenshot_default)(std::string(param1_str, param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "save_screenshot_default(const DisplayRegion self, str prefix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_save_screenshot_default_674_comment =
  "C++ Interface:\n"
  "save_screenshot_default(const DisplayRegion self, str prefix)\n"
  "\n"
  "/**\n"
  " * Saves a screenshot of the region to a default filename, and returns the\n"
  " * filename, or empty string if the screenshot failed.  The filename is\n"
  " * generated by make_screenshot_filename().\n"
  " */";
#else
static const char *Dtool_DisplayRegion_save_screenshot_default_674_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DisplayRegion::save_screenshot(Filename const &filename, std::string const &image_comment = "")
 */
static PyObject *Dtool_DisplayRegion_save_screenshot_675(PyObject *self, PyObject *args, PyObject *kwds) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.save_screenshot")) {
    return nullptr;
  }
  // 1-bool DisplayRegion::save_screenshot(Filename const &filename, std::string const &image_comment = "")
  PyObject *param1;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  static const char *keyword_list[] = {"filename", "image_comment", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:save_screenshot", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "DisplayRegion.save_screenshot", "Filename");
    }
    bool return_value = ((*local_this).save_screenshot)(*param1_this, std::string(param2_str, param2_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "save_screenshot(const DisplayRegion self, const Filename filename, str image_comment)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_save_screenshot_675_comment =
  "C++ Interface:\n"
  "save_screenshot(const DisplayRegion self, const Filename filename, str image_comment)\n"
  "\n"
  "/**\n"
  " * Saves a screenshot of the region to the indicated filename.  Returns true\n"
  " * on success, false on failure.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_save_screenshot_675_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< Texture > DisplayRegion::get_screenshot(void)
 * bool DisplayRegion::get_screenshot(PNMImage &image)
 */
static PyObject *Dtool_DisplayRegion_get_screenshot_676(PyObject *self, PyObject *args) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.get_screenshot")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-PointerTo< Texture > DisplayRegion::get_screenshot(void)
      PointerTo< Texture > return_value = ((*local_this).get_screenshot)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      Texture *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Texture, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-bool DisplayRegion::get_screenshot(PNMImage &image)
      PNMImage *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "DisplayRegion.get_screenshot", false, true);
      if (arg_this != nullptr) {
        bool return_value = ((*local_this).get_screenshot)(*arg_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_screenshot() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_screenshot(const DisplayRegion self)\n"
      "get_screenshot(const DisplayRegion self, PNMImage image)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_screenshot_676_comment =
  "C++ Interface:\n"
  "get_screenshot(const DisplayRegion self)\n"
  "get_screenshot(const DisplayRegion self, PNMImage image)\n"
  "\n"
  "/**\n"
  " * Captures the most-recently rendered image from the framebuffer into the\n"
  " * indicated PNMImage.  Returns true on success, false on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Captures the most-recently rendered image from the framebuffer and returns\n"
  " * it as a Texture, or NULL on failure.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_get_screenshot_676_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PointerTo< PandaNode > DisplayRegion::make_cull_result_graph(void)
 */
static PyObject *Dtool_DisplayRegion_make_cull_result_graph_677(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.make_cull_result_graph")) {
    return nullptr;
  }
  // 1-virtual PointerTo< PandaNode > DisplayRegion::make_cull_result_graph(void)
  PointerTo< PandaNode > return_value = ((*local_this).make_cull_result_graph)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  PandaNode *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PandaNode, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_make_cull_result_graph_677_comment =
  "C++ Interface:\n"
  "make_cull_result_graph(const DisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns a special scene graph constructed to represent the results of the\n"
  " * last frame's cull operation.\n"
  " *\n"
  " * This will be a hierarchy of nodes, one node for each bin, each of which\n"
  " * will in term be a parent of a number of GeomNodes, representing the\n"
  " * geometry drawn in each bin.\n"
  " *\n"
  " * This is useful mainly for high-level debugging and abstraction tools; it\n"
  " * should not be mistaken for the low-level cull result itself, which is\n"
  " * constructed and maintained internally.  No such scene graph is normally\n"
  " * constructed during the rendering of a frame; this is an artificial\n"
  " * construct created for the purpose of making it easy to analyze the results\n"
  " * of the cull operation.\n"
  " */";
#else
static const char *Dtool_DisplayRegion_make_cull_result_graph_677_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DisplayRegion::get_class_type(void)
 */
static PyObject *Dtool_DisplayRegion_get_class_type_678(PyObject *, PyObject *) {
  // 1-static TypeHandle DisplayRegion::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((DisplayRegion::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_get_class_type_678_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DisplayRegion_get_class_type_678_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedReferenceCount *DisplayRegion::upcast_to_TypedReferenceCount(void)
 */
static PyObject *Dtool_DisplayRegion_upcast_to_TypedReferenceCount_246(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.upcast_to_TypedReferenceCount")) {
    return nullptr;
  }
  // 1-TypedReferenceCount *DisplayRegion::upcast_to_TypedReferenceCount(void)
  TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_upcast_to_TypedReferenceCount_246_comment =
  "C++ Interface:\n"
  "upcast_to_TypedReferenceCount(const DisplayRegion self)\n"
  "\n"
  "upcast from DisplayRegion to TypedReferenceCount";
#else
static const char *Dtool_DisplayRegion_upcast_to_TypedReferenceCount_246_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DrawableRegion *DisplayRegion::upcast_to_DrawableRegion(void)
 */
static PyObject *Dtool_DisplayRegion_upcast_to_DrawableRegion_248(PyObject *self, PyObject *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.upcast_to_DrawableRegion")) {
    return nullptr;
  }
  // 1-DrawableRegion *DisplayRegion::upcast_to_DrawableRegion(void)
  DrawableRegion *return_value = (DrawableRegion *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DrawableRegion, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegion_upcast_to_DrawableRegion_248_comment =
  "C++ Interface:\n"
  "upcast_to_DrawableRegion(const DisplayRegion self)\n"
  "\n"
  "upcast from DisplayRegion to DrawableRegion";
#else
static const char *Dtool_DisplayRegion_upcast_to_DrawableRegion_248_comment = nullptr;
#endif

static PyObject *Dtool_DisplayRegion_dimensions_Getter(PyObject *self, void *) {
  const DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase4 DisplayRegion::get_dimensions(int i) const
  LVecBase4 *return_value = new LVecBase4(((*(const DisplayRegion*)local_this).get_dimensions)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

static int Dtool_DisplayRegion_dimensions_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.dimensions")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete dimensions attribute");
    return -1;
  }
  // 1-inline void DisplayRegion::set_dimensions(LVecBase4 const &dimensions)
  LVecBase4f arg_local;
  LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DisplayRegion.set_dimensions", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_dimensions)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_dimensions(const DisplayRegion self, const LVecBase4f dimensions)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayRegion_window_Getter(PyObject *self, void *) {
  const DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GraphicsOutput *DisplayRegion::get_window(void) const
  GraphicsOutput *return_value = ((*(const DisplayRegion*)local_this).get_window)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutput, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_DisplayRegion_pipe_Getter(PyObject *self, void *) {
  const DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-GraphicsPipe *DisplayRegion::get_pipe(void) const
  GraphicsPipe *return_value = ((*(const DisplayRegion*)local_this).get_pipe)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsPipe, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_DisplayRegion_stereo_Getter(PyObject *self, void *) {
  const DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual bool DisplayRegion::is_stereo(void) const
  bool return_value = ((*(const DisplayRegion*)local_this).is_stereo)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_DisplayRegion_camera_Getter(PyObject *self, void *) {
  const DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline NodePath DisplayRegion::get_camera(Thread *current_thread) const
  NodePath *return_value = new NodePath(((*(const DisplayRegion*)local_this).get_camera)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

static int Dtool_DisplayRegion_camera_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.camera")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete camera attribute");
    return -1;
  }
  // 1-virtual void DisplayRegion::set_camera(NodePath const &camera)
  NodePath const *arg_this = (NodePath *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NodePath, 1, "DisplayRegion.set_camera", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_camera)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_camera(const DisplayRegion self, const NodePath camera)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayRegion_active_Getter(PyObject *self, void *) {
  const DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool DisplayRegion::is_active(void) const
  bool return_value = ((*(const DisplayRegion*)local_this).is_active)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DisplayRegion_active_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.active")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete active attribute");
    return -1;
  }
  // 1-virtual void DisplayRegion::set_active(bool active)
  ((*local_this).set_active)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_active(const DisplayRegion self, bool active)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayRegion_sort_Getter(PyObject *self, void *) {
  const DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int DisplayRegion::get_sort(void) const
  int return_value = ((*(const DisplayRegion*)local_this).get_sort)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DisplayRegion_sort_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.sort")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete sort attribute");
    return -1;
  }
  // 1-virtual void DisplayRegion::set_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_sort)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_sort(const DisplayRegion self, int sort)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayRegion_stereo_channel_Getter(PyObject *self, void *) {
  const DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Lens::StereoChannel DisplayRegion::get_stereo_channel(void) const
  Lens::StereoChannel return_value = ((*(const DisplayRegion*)local_this).get_stereo_channel)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DisplayRegion_stereo_channel_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.stereo_channel")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete stereo_channel attribute");
    return -1;
  }
  // 1-virtual void DisplayRegion::set_stereo_channel(Lens::StereoChannel stereo_channel)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_stereo_channel)((Lens::StereoChannel)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_stereo_channel(const DisplayRegion self, int stereo_channel)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayRegion_tex_view_offset_Getter(PyObject *self, void *) {
  const DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int DisplayRegion::get_tex_view_offset(void) const
  int return_value = ((*(const DisplayRegion*)local_this).get_tex_view_offset)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DisplayRegion_tex_view_offset_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.tex_view_offset")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete tex_view_offset attribute");
    return -1;
  }
  // 1-virtual void DisplayRegion::set_tex_view_offset(int tex_view_offset)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_tex_view_offset)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_tex_view_offset(const DisplayRegion self, int tex_view_offset)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayRegion_incomplete_render_Getter(PyObject *self, void *) {
  const DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool DisplayRegion::get_incomplete_render(void) const
  bool return_value = ((*(const DisplayRegion*)local_this).get_incomplete_render)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DisplayRegion_incomplete_render_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.incomplete_render")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete incomplete_render attribute");
    return -1;
  }
  // 1-virtual void DisplayRegion::set_incomplete_render(bool incomplete_render)
  ((*local_this).set_incomplete_render)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_incomplete_render(const DisplayRegion self, bool incomplete_render)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayRegion_texture_reload_priority_Getter(PyObject *self, void *) {
  const DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int DisplayRegion::get_texture_reload_priority(void) const
  int return_value = ((*(const DisplayRegion*)local_this).get_texture_reload_priority)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DisplayRegion_texture_reload_priority_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.texture_reload_priority")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete texture_reload_priority attribute");
    return -1;
  }
  // 1-virtual void DisplayRegion::set_texture_reload_priority(int texture_reload_priority)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_texture_reload_priority)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_texture_reload_priority(const DisplayRegion self, int texture_reload_priority)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayRegion_lens_index_Getter(PyObject *self, void *) {
  const DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int DisplayRegion::get_lens_index(void) const
  int return_value = ((*(const DisplayRegion*)local_this).get_lens_index)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DisplayRegion_lens_index_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.lens_index")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete lens_index attribute");
    return -1;
  }
  // 1-void DisplayRegion::set_lens_index(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_lens_index)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_lens_index(const DisplayRegion self, int index)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayRegion_cull_traverser_Getter(PyObject *self, void *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.cull_traverser")) {
    return nullptr;
  }

  // 1-CullTraverser *DisplayRegion::get_cull_traverser(void)
  CullTraverser *return_value = ((*local_this).get_cull_traverser)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CullTraverser, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_DisplayRegion_cull_traverser_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.cull_traverser")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete cull_traverser attribute");
    return -1;
  }
  // 1-virtual void DisplayRegion::set_cull_traverser(CullTraverser *trav)
  CullTraverser *arg_this = (CullTraverser *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CullTraverser, 1, "DisplayRegion.set_cull_traverser", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_cull_traverser)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cull_traverser(const DisplayRegion self, CullTraverser trav)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayRegion_target_tex_page_Getter(PyObject *self, void *) {
  const DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int DisplayRegion::get_target_tex_page(void) const
  int return_value = ((*(const DisplayRegion*)local_this).get_target_tex_page)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DisplayRegion_target_tex_page_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.target_tex_page")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete target_tex_page attribute");
    return -1;
  }
  // 1-virtual void DisplayRegion::set_target_tex_page(int page)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_target_tex_page)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_target_tex_page(const DisplayRegion self, int page)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayRegion_scissor_enabled_Getter(PyObject *self, void *) {
  const DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool DisplayRegion::get_scissor_enabled(void) const
  bool return_value = ((*(const DisplayRegion*)local_this).get_scissor_enabled)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DisplayRegion_scissor_enabled_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.scissor_enabled")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete scissor_enabled attribute");
    return -1;
  }
  // 1-inline void DisplayRegion::set_scissor_enabled(bool scissor_enabled)
  ((*local_this).set_scissor_enabled)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_scissor_enabled(const DisplayRegion self, bool scissor_enabled)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayRegion_cull_callback_Getter(PyObject *self, void *) {
  const DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CallbackObject *DisplayRegion::get_cull_callback(void) const
  CallbackObject *return_value = ((*(const DisplayRegion*)local_this).get_cull_callback)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_DisplayRegion_cull_callback_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.cull_callback")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete cull_callback attribute");
    return -1;
  }
  // 1-inline void DisplayRegion::set_cull_callback(CallbackObject *object)
  PT(CallbackObject) arg_this;
  if (!Dtool_Coerce_CallbackObject(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DisplayRegion.set_cull_callback", "CallbackObject");
    return -1;
  }
  ((*local_this).set_cull_callback)(std::move(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cull_callback(const DisplayRegion self, CallbackObject object)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayRegion_draw_callback_Getter(PyObject *self, void *) {
  const DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CallbackObject *DisplayRegion::get_draw_callback(void) const
  CallbackObject *return_value = ((*(const DisplayRegion*)local_this).get_draw_callback)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_DisplayRegion_draw_callback_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayRegion, (void **)&local_this, "DisplayRegion.draw_callback")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete draw_callback attribute");
    return -1;
  }
  // 1-inline void DisplayRegion::set_draw_callback(CallbackObject *object)
  PT(CallbackObject) arg_this;
  if (!Dtool_Coerce_CallbackObject(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "DisplayRegion.set_draw_callback", "CallbackObject");
    return -1;
  }
  ((*local_this).set_draw_callback)(std::move(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_draw_callback(const DisplayRegion self, CallbackObject object)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayRegion_pixel_size_Getter(PyObject *self, void *) {
  const DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase2i DisplayRegion::get_pixel_size(int i) const
  LVecBase2i *return_value = new LVecBase2i(((*(const DisplayRegion*)local_this).get_pixel_size)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

static int Dtool_Init_DisplayRegion(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DisplayRegion(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DisplayRegion) {
    printf("DisplayRegion ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DisplayRegion *local_this = (DisplayRegion *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DisplayRegion) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DrawableRegion) {
    return (DrawableRegion *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DisplayRegion(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DisplayRegion) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DrawableRegion) {
    DrawableRegion* other_this = (DrawableRegion*)from_this;
    return (DisplayRegion*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DisplayRegion*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DisplayRegion*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (DisplayRegion*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GraphicsOutput
 */
/**
 * Python function wrapper for:
 * inline GraphicsStateGuardian *GraphicsOutput::get_gsg(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_gsg_275(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline GraphicsStateGuardian *GraphicsOutput::get_gsg(void) const
  GraphicsStateGuardian *return_value = ((*(const GraphicsOutput*)local_this).get_gsg)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsStateGuardian, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_gsg_275_comment =
  "C++ Interface:\n"
  "get_gsg(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the GSG that is associated with this window.  There is a one-to-one\n"
  " * association between windows and GSG's.\n"
  " *\n"
  " * This may return NULL if the graphics context has not yet been created for\n"
  " * the window, e.g.  before the first frame has rendered; or after the window\n"
  " * has been closed.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_gsg_275_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsPipe *GraphicsOutput::get_pipe(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_pipe_276(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline GraphicsPipe *GraphicsOutput::get_pipe(void) const
  GraphicsPipe *return_value = ((*(const GraphicsOutput*)local_this).get_pipe)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsPipe, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_pipe_276_comment =
  "C++ Interface:\n"
  "get_pipe(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the GraphicsPipe that this window is associated with.  It is\n"
  " * possible that the GraphicsPipe might have been deleted while an outstanding\n"
  " * PT(GraphicsOutput) prevented all of its children windows from also being\n"
  " * deleted; in this unlikely case, get_pipe() may return NULL.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_pipe_276_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsEngine *GraphicsOutput::get_engine(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_engine_277(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline GraphicsEngine *GraphicsOutput::get_engine(void) const
  GraphicsEngine *return_value = ((*(const GraphicsOutput*)local_this).get_engine)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GraphicsEngine, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_engine_277_comment =
  "C++ Interface:\n"
  "get_engine(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the graphics engine that created this output.  Since there is\n"
  " * normally only one GraphicsEngine object in an application, this is usually\n"
  " * the same as the global GraphicsEngine.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_engine_277_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &GraphicsOutput::get_name(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_name_278(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline std::string const &GraphicsOutput::get_name(void) const
  std::string const &return_value = ((*(const GraphicsOutput*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_name_278_comment =
  "C++ Interface:\n"
  "get_name(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the name that was passed to the GraphicsOutput constructor.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_name_278_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsOutput::count_textures(void) const
 */
static PyObject *Dtool_GraphicsOutput_count_textures_526(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline int GraphicsOutput::count_textures(void) const
  int return_value = ((*(const GraphicsOutput*)local_this).count_textures)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_count_textures_526_comment =
  "C++ Interface:\n"
  "count_textures(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * If the GraphicsOutput is set to render into a texture, returns the number\n"
  " * of textures that are being rendered into.  Normally, the textures would be\n"
  " * associated with different buffers - a color texture, a depth texture, and a\n"
  " * stencil texture.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_count_textures_526_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsOutput::has_texture(void) const
 */
static PyObject *Dtool_GraphicsOutput_has_texture_527(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline bool GraphicsOutput::has_texture(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).has_texture)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_has_texture_527_comment =
  "C++ Interface:\n"
  "has_texture(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns true if the GraphicsOutput is rendering into any textures at all.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_has_texture_527_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual inline Texture *GraphicsOutput::get_texture(int i = 0) const
 */
static PyObject *Dtool_GraphicsOutput_get_texture_528(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-virtual inline Texture *GraphicsOutput::get_texture(int i = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"i", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_texture", (char **)keyword_list, &param1)) {
    Texture *return_value = ((*(const GraphicsOutput*)local_this).get_texture)((int)param1);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_texture(GraphicsOutput self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_texture_528_comment =
  "C++ Interface:\n"
  "get_texture(GraphicsOutput self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the nth texture into which the GraphicsOutput renders.  Returns\n"
  " * NULL if there is no such texture.\n"
  " *\n"
  " * If the texture is non-NULL, it may be applied to geometry to be rendered\n"
  " * for any other windows or outputs that share the same GSG as this\n"
  " * GraphicsOutput.  The effect is undefined for windows that share a different\n"
  " * GSG; usually in these cases the texture will be invalid.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_texture_528_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DrawableRegion::RenderTexturePlane GraphicsOutput::get_texture_plane(int i = 0) const
 */
static PyObject *Dtool_GraphicsOutput_get_texture_plane_529(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline DrawableRegion::RenderTexturePlane GraphicsOutput::get_texture_plane(int i = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"i", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_texture_plane", (char **)keyword_list, &param1)) {
    DrawableRegion::RenderTexturePlane return_value = ((*(const GraphicsOutput*)local_this).get_texture_plane)((int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_texture_plane(GraphicsOutput self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_texture_plane_529_comment =
  "C++ Interface:\n"
  "get_texture_plane(GraphicsOutput self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the RenderTexturePlane associated with the nth render-texture.\n"
  " * Returns 0 if there is no such texture.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_texture_plane_529_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsOutput::RenderTextureMode GraphicsOutput::get_rtm_mode(int i = 0) const
 */
static PyObject *Dtool_GraphicsOutput_get_rtm_mode_530(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline GraphicsOutput::RenderTextureMode GraphicsOutput::get_rtm_mode(int i = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"i", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_rtm_mode", (char **)keyword_list, &param1)) {
    GraphicsOutput::RenderTextureMode return_value = ((*(const GraphicsOutput*)local_this).get_rtm_mode)((int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_rtm_mode(GraphicsOutput self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_rtm_mode_530_comment =
  "C++ Interface:\n"
  "get_rtm_mode(GraphicsOutput self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the RenderTextureMode associated with the nth render-texture.\n"
  " * Returns RTM_none if there is no such texture.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_rtm_mode_530_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsOutput::clear_render_textures(void)
 */
static PyObject *Dtool_GraphicsOutput_clear_render_textures_531(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.clear_render_textures")) {
    return nullptr;
  }
  // 1-void GraphicsOutput::clear_render_textures(void)
  ((*local_this).clear_render_textures)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_clear_render_textures_531_comment =
  "C++ Interface:\n"
  "clear_render_textures(const GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * If the GraphicsOutput is currently rendering to a texture, then all\n"
  " * textures are dissociated from the GraphicsOuput.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_clear_render_textures_531_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsOutput::add_render_texture(Texture *tex, GraphicsOutput::RenderTextureMode mode, DrawableRegion::RenderTexturePlane bitplane = ::DrawableRegion::RTP_COUNT)
 */
static PyObject *Dtool_GraphicsOutput_add_render_texture_532(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.add_render_texture")) {
    return nullptr;
  }
  // 1-void GraphicsOutput::add_render_texture(Texture *tex, GraphicsOutput::RenderTextureMode mode, DrawableRegion::RenderTexturePlane bitplane = ::DrawableRegion::RTP_COUNT)
  PyObject *param1;
  int param2;
  int param3 = DrawableRegion::RTP_COUNT;
  static const char *keyword_list[] = {"tex", "mode", "bitplane", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi|i:add_render_texture", (char **)keyword_list, &param1, &param2, &param3)) {
    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "GraphicsOutput.add_render_texture", false, true);
    if (param1_this != nullptr) {
      ((*local_this).add_render_texture)(param1_this, (GraphicsOutput::RenderTextureMode)param2, (DrawableRegion::RenderTexturePlane)param3);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_render_texture(const GraphicsOutput self, Texture tex, int mode, int bitplane)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_add_render_texture_532_comment =
  "C++ Interface:\n"
  "add_render_texture(const GraphicsOutput self, Texture tex, int mode, int bitplane)\n"
  "\n"
  "/**\n"
  " * Creates a new Texture object, suitable for rendering the contents of this\n"
  " * buffer into, and appends it to the list of render textures.\n"
  " *\n"
  " * If tex is not NULL, it is the texture that will be set up for rendering\n"
  " * into; otherwise, a new Texture object will be created, in which case you\n"
  " * may call get_texture() to retrieve the new texture pointer.\n"
  " *\n"
  " * You can specify a bitplane to attach the texture to.  the legal choices\n"
  " * are:\n"
  " *\n"
  " * - RTP_depth\n"
  " * - RTP_depth_stencil\n"
  " * - RTP_color\n"
  " * - RTP_aux_rgba_0\n"
  " * - RTP_aux_rgba_1\n"
  " * - RTP_aux_rgba_2\n"
  " * - RTP_aux_rgba_3\n"
  " *\n"
  " * If you do not specify a bitplane to attach the texture to, this routine\n"
  " * will use a default based on the texture's format:\n"
  " *\n"
  " * - F_depth_component attaches to RTP_depth\n"
  " * - F_depth_stencil attaches to RTP_depth_stencil\n"
  " * - all other formats attach to RTP_color.\n"
  " *\n"
  " * The texture's format will be changed to match the format of the bitplane to\n"
  " * which it is attached.  For example, if you pass in an F_rgba texture and\n"
  " * order that it be attached to RTP_depth_stencil, it will turn into an\n"
  " * F_depth_stencil texture.\n"
  " *\n"
  " * Also see make_texture_buffer(), which is a higher-level interface for\n"
  " * preparing render-to-a-texture mode.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_add_render_texture_532_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsOutput::setup_render_texture(Texture *tex, bool allow_bind, bool to_ram)
 */
static PyObject *Dtool_GraphicsOutput_setup_render_texture_533(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.setup_render_texture")) {
    return nullptr;
  }
  // 1-void GraphicsOutput::setup_render_texture(Texture *tex, bool allow_bind, bool to_ram)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"tex", "allow_bind", "to_ram", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:setup_render_texture", (char **)keyword_list, &param1, &param2, &param3)) {
    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "GraphicsOutput.setup_render_texture", false, true);
    if (param1_this != nullptr) {
      ((*local_this).setup_render_texture)(param1_this, (PyObject_IsTrue(param2) != 0), (PyObject_IsTrue(param3) != 0));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_render_texture(const GraphicsOutput self, Texture tex, bool allow_bind, bool to_ram)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_setup_render_texture_533_comment =
  "C++ Interface:\n"
  "setup_render_texture(const GraphicsOutput self, Texture tex, bool allow_bind, bool to_ram)\n"
  "\n"
  "/**\n"
  " * This is a deprecated interface that made sense back when GraphicsOutputs\n"
  " * could only render into one texture at a time.  From now on, use\n"
  " * clear_render_textures and add_render_texture instead.\n"
  " *\n"
  " * @deprecated Use add_render_texture() instead.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_setup_render_texture_533_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i const &GraphicsOutput::get_size(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_size_534(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline LVecBase2i const &GraphicsOutput::get_size(void) const
  LVecBase2i const *return_value = &(((*(const GraphicsOutput*)local_this).get_size)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_size_534_comment =
  "C++ Interface:\n"
  "get_size(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the visible size of the window or buffer, if it is known.  In\n"
  " * certain cases (e.g.  fullscreen windows), the size may not be known until\n"
  " * after the object has been fully created.  Check has_size() first.\n"
  " *\n"
  " * Certain objects (like windows) may change size spontaneously; this method\n"
  " * is not thread-safe.  To get the size of a window in a thread-safe manner,\n"
  " * query get_properties().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_size_534_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsOutput::get_x_size(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_x_size_535(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline int GraphicsOutput::get_x_size(void) const
  int return_value = ((*(const GraphicsOutput*)local_this).get_x_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_x_size_535_comment =
  "C++ Interface:\n"
  "get_x_size(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the visible width of the window or buffer, if it is known.  In\n"
  " * certain cases (e.g.  fullscreen windows), the size may not be known until\n"
  " * after the object has been fully created.  Check has_size() first.\n"
  " *\n"
  " * Certain objects (like windows) may change size spontaneously; this method\n"
  " * is not thread-safe.  To get the size of a window in a thread-safe manner,\n"
  " * query get_properties().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_x_size_535_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsOutput::get_y_size(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_y_size_536(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline int GraphicsOutput::get_y_size(void) const
  int return_value = ((*(const GraphicsOutput*)local_this).get_y_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_y_size_536_comment =
  "C++ Interface:\n"
  "get_y_size(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the visible height of the window or buffer, if it is known.  In\n"
  " * certain cases (e.g.  fullscreen windows), the size may not be known until\n"
  " * after the object has been fully created.  Check has_size() first.\n"
  " *\n"
  " * Certain objects (like windows) may change size spontaneously; this method\n"
  " * is not thread-safe.  To get the size of a window in a thread-safe manner,\n"
  " * query get_properties().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_y_size_536_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i GraphicsOutput::get_fb_size(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_fb_size_537(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline LVecBase2i GraphicsOutput::get_fb_size(void) const
  LVecBase2i *return_value = new LVecBase2i(((*(const GraphicsOutput*)local_this).get_fb_size)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_fb_size_537_comment =
  "C++ Interface:\n"
  "get_fb_size(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the internal size of the window or buffer.  This is almost always\n"
  " * the same as get_size(), except when a pixel_zoom is in effect--see\n"
  " * set_pixel_zoom().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_fb_size_537_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsOutput::get_fb_x_size(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_fb_x_size_538(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline int GraphicsOutput::get_fb_x_size(void) const
  int return_value = ((*(const GraphicsOutput*)local_this).get_fb_x_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_fb_x_size_538_comment =
  "C++ Interface:\n"
  "get_fb_x_size(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the internal width of the window or buffer.  This is almost always\n"
  " * the same as get_x_size(), except when a pixel_zoom is in effect--see\n"
  " * set_pixel_zoom().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_fb_x_size_538_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsOutput::get_fb_y_size(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_fb_y_size_539(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline int GraphicsOutput::get_fb_y_size(void) const
  int return_value = ((*(const GraphicsOutput*)local_this).get_fb_y_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_fb_y_size_539_comment =
  "C++ Interface:\n"
  "get_fb_y_size(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the internal height of the window or buffer.  This is almost always\n"
  " * the same as get_y_size(), except when a pixel_zoom is in effect--see\n"
  " * set_pixel_zoom().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_fb_y_size_539_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i GraphicsOutput::get_sbs_left_size(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_sbs_left_size_540(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline LVecBase2i GraphicsOutput::get_sbs_left_size(void) const
  LVecBase2i *return_value = new LVecBase2i(((*(const GraphicsOutput*)local_this).get_sbs_left_size)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_sbs_left_size_540_comment =
  "C++ Interface:\n"
  "get_sbs_left_size(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * If side-by-side stereo is enabled, this returns the pixel size of the left\n"
  " * eye, based on scaling get_size() by get_sbs_left_dimensions().  If side-by-\n"
  " * side stereo is not enabled, this returns the same as get_size().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_sbs_left_size_540_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsOutput::get_sbs_left_x_size(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_sbs_left_x_size_541(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline int GraphicsOutput::get_sbs_left_x_size(void) const
  int return_value = ((*(const GraphicsOutput*)local_this).get_sbs_left_x_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_sbs_left_x_size_541_comment =
  "C++ Interface:\n"
  "get_sbs_left_x_size(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * If side-by-side stereo is enabled, this returns the pixel width of the left\n"
  " * eye, based on scaling get_x_size() by get_sbs_left_dimensions().  If side-\n"
  " * by-side stereo is not enabled, this returns the same as get_x_size().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_sbs_left_x_size_541_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsOutput::get_sbs_left_y_size(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_sbs_left_y_size_542(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline int GraphicsOutput::get_sbs_left_y_size(void) const
  int return_value = ((*(const GraphicsOutput*)local_this).get_sbs_left_y_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_sbs_left_y_size_542_comment =
  "C++ Interface:\n"
  "get_sbs_left_y_size(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * If side-by-side stereo is enabled, this returns the pixel height of the\n"
  " * left eye, based on scaling get_y_size() by get_sbs_left_dimensions().  If\n"
  " * side-by-side stereo is not enabled, this returns the same as get_y_size().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_sbs_left_y_size_542_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i GraphicsOutput::get_sbs_right_size(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_sbs_right_size_543(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline LVecBase2i GraphicsOutput::get_sbs_right_size(void) const
  LVecBase2i *return_value = new LVecBase2i(((*(const GraphicsOutput*)local_this).get_sbs_right_size)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_sbs_right_size_543_comment =
  "C++ Interface:\n"
  "get_sbs_right_size(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * If side-by-side stereo is enabled, this returns the pixel size of the right\n"
  " * eye, based on scaling get_size() by get_sbs_right_dimensions().  If side-\n"
  " * by-side stereo is not enabled, this returns the same as get_size().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_sbs_right_size_543_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsOutput::get_sbs_right_x_size(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_sbs_right_x_size_544(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline int GraphicsOutput::get_sbs_right_x_size(void) const
  int return_value = ((*(const GraphicsOutput*)local_this).get_sbs_right_x_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_sbs_right_x_size_544_comment =
  "C++ Interface:\n"
  "get_sbs_right_x_size(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * If side-by-side stereo is enabled, this returns the pixel width of the\n"
  " * right eye, based on scaling get_x_size() by get_sbs_right_dimensions().  If\n"
  " * side-by-side stereo is not enabled, this returns the same as get_x_size().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_sbs_right_x_size_544_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsOutput::get_sbs_right_y_size(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_sbs_right_y_size_545(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline int GraphicsOutput::get_sbs_right_y_size(void) const
  int return_value = ((*(const GraphicsOutput*)local_this).get_sbs_right_y_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_sbs_right_y_size_545_comment =
  "C++ Interface:\n"
  "get_sbs_right_y_size(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * If side-by-side stereo is enabled, this returns the pixel height of the\n"
  " * right eye, based on scaling get_y_size() by get_sbs_right_dimensions().  If\n"
  " * side-by-side stereo is not enabled, this returns the same as get_y_size().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_sbs_right_y_size_545_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsOutput::has_size(void) const
 */
static PyObject *Dtool_GraphicsOutput_has_size_546(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline bool GraphicsOutput::has_size(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).has_size)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_has_size_546_comment =
  "C++ Interface:\n"
  "has_size(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns true if the size of the window/frame buffer is known, false\n"
  " * otherwise.  In certain cases the size may not be known until after the\n"
  " * object has been fully created.  Also, certain objects (like windows) may\n"
  " * change size spontaneously.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_has_size_546_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsOutput::is_valid(void) const
 */
static PyObject *Dtool_GraphicsOutput_is_valid_547(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline bool GraphicsOutput::is_valid(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_is_valid_547_comment =
  "C++ Interface:\n"
  "is_valid(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns true if the output is fully created and ready for rendering, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_is_valid_547_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsOutput::is_nonzero_size(void) const
 */
static PyObject *Dtool_GraphicsOutput_is_nonzero_size_548(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline bool GraphicsOutput::is_nonzero_size(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).is_nonzero_size)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_is_nonzero_size_548_comment =
  "C++ Interface:\n"
  "is_nonzero_size(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns true if the output has a nonzero size in both X and Y, or false if\n"
  " * it is zero (and therefore invalid).\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_is_nonzero_size_548_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsOutput::set_active(bool active)
 */
static PyObject *Dtool_GraphicsOutput_set_active_555(PyObject *self, PyObject *arg) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.set_active")) {
    return nullptr;
  }
  // 1-void GraphicsOutput::set_active(bool active)
  ((*local_this).set_active)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active(const GraphicsOutput self, bool active)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_set_active_555_comment =
  "C++ Interface:\n"
  "set_active(const GraphicsOutput self, bool active)\n"
  "\n"
  "/**\n"
  " * Sets the active flag associated with the GraphicsOutput.  If the\n"
  " * GraphicsOutput is marked inactive, nothing is rendered.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_set_active_555_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool GraphicsOutput::is_active(void) const
 */
static PyObject *Dtool_GraphicsOutput_is_active_556(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-virtual bool GraphicsOutput::is_active(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).is_active)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_is_active_556_comment =
  "C++ Interface:\n"
  "is_active(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns true if the window is ready to be rendered into, false otherwise.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_is_active_556_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsOutput::set_one_shot(bool one_shot)
 */
static PyObject *Dtool_GraphicsOutput_set_one_shot_558(PyObject *self, PyObject *arg) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.set_one_shot")) {
    return nullptr;
  }
  // 1-void GraphicsOutput::set_one_shot(bool one_shot)
  ((*local_this).set_one_shot)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_one_shot(const GraphicsOutput self, bool one_shot)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_set_one_shot_558_comment =
  "C++ Interface:\n"
  "set_one_shot(const GraphicsOutput self, bool one_shot)\n"
  "\n"
  "/**\n"
  " * Changes the current setting of the one-shot flag.  When this is true, the\n"
  " * GraphicsOutput will render the current frame and then automatically set\n"
  " * itself inactive.  This is particularly useful for buffers that are created\n"
  " * for the purposes of render-to-texture, for static textures that don't need\n"
  " * to be continually re-rendered once they have been rendered the first time.\n"
  " *\n"
  " * Setting the buffer inactive is not the same thing as destroying it.  You\n"
  " * are still responsible for passing this buffer to\n"
  " * GraphicsEngine::remove_window() when you no longer need the texture, in\n"
  " * order to clean up fully.  (However, you should not call remove_window() on\n"
  " * this buffer while the texture is still needed, because depending on the\n"
  " * render-to-texture mechanism in use, this may invalidate the texture\n"
  " * contents.)\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_set_one_shot_558_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GraphicsOutput::get_one_shot(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_one_shot_559(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-bool GraphicsOutput::get_one_shot(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).get_one_shot)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_one_shot_559_comment =
  "C++ Interface:\n"
  "get_one_shot(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the one-shot flag.  When this is true, the\n"
  " * GraphicsOutput will automatically set itself inactive after the next frame.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_one_shot_559_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsOutput::set_inverted(bool inverted)
 */
static PyObject *Dtool_GraphicsOutput_set_inverted_561(PyObject *self, PyObject *arg) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.set_inverted")) {
    return nullptr;
  }
  // 1-void GraphicsOutput::set_inverted(bool inverted)
  ((*local_this).set_inverted)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_inverted(const GraphicsOutput self, bool inverted)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_set_inverted_561_comment =
  "C++ Interface:\n"
  "set_inverted(const GraphicsOutput self, bool inverted)\n"
  "\n"
  "/**\n"
  " * Changes the current setting of the inverted flag.  When this is true, the\n"
  " * scene is rendered into the window upside-down and backwards, that is,\n"
  " * inverted as if viewed through a mirror placed on the floor.\n"
  " *\n"
  " * This is primarily intended to support DirectX (and a few buggy OpenGL\n"
  " * graphics drivers) that perform a framebuffer-to-texture copy upside-down\n"
  " * from the usual OpenGL (and Panda) convention.  Panda will automatically set\n"
  " * this flag for offscreen buffers on hardware that is known to do this, to\n"
  " * compensate when rendering offscreen into a texture.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_set_inverted_561_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsOutput::get_inverted(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_inverted_562(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline bool GraphicsOutput::get_inverted(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).get_inverted)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_inverted_562_comment =
  "C++ Interface:\n"
  "get_inverted(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the inverted flag.  When this is true, the\n"
  " * scene is rendered into the window upside-down, flipped like a mirror along\n"
  " * the X axis.  See set_inverted().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_inverted_562_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsOutput::set_swap_eyes(bool swap_eyes)
 */
static PyObject *Dtool_GraphicsOutput_set_swap_eyes_564(PyObject *self, PyObject *arg) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.set_swap_eyes")) {
    return nullptr;
  }
  // 1-inline void GraphicsOutput::set_swap_eyes(bool swap_eyes)
  ((*local_this).set_swap_eyes)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_swap_eyes(const GraphicsOutput self, bool swap_eyes)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_set_swap_eyes_564_comment =
  "C++ Interface:\n"
  "set_swap_eyes(const GraphicsOutput self, bool swap_eyes)\n"
  "\n"
  "/**\n"
  " * Changes the \"swap eyes\" flag.  This flag is normally false.  When it is\n"
  " * true, the left and right channels of a stereo DisplayRegion are sent to the\n"
  " * opposite channels in the rendering backend.  This is meant to work around\n"
  " * hardware that inadvertently swaps the output channels, or hardware for\n"
  " * which it cannot be determined which channel is which until runtime.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_set_swap_eyes_564_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsOutput::get_swap_eyes(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_swap_eyes_565(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline bool GraphicsOutput::get_swap_eyes(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).get_swap_eyes)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_swap_eyes_565_comment =
  "C++ Interface:\n"
  "get_swap_eyes(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the \"swap eyes\" flag.  See set_swap_eyes().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_swap_eyes_565_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsOutput::set_red_blue_stereo(bool red_blue_stereo, unsigned int left_eye_color_mask, unsigned int right_eye_color_mask)
 */
static PyObject *Dtool_GraphicsOutput_set_red_blue_stereo_567(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.set_red_blue_stereo")) {
    return nullptr;
  }
  // 1-inline void GraphicsOutput::set_red_blue_stereo(bool red_blue_stereo, unsigned int left_eye_color_mask, unsigned int right_eye_color_mask)
  PyObject *param1;
  unsigned long param2;
  unsigned long param3;
  static const char *keyword_list[] = {"red_blue_stereo", "left_eye_color_mask", "right_eye_color_mask", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Okk:set_red_blue_stereo", (char **)keyword_list, &param1, &param2, &param3)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param3 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param3);
    }
#endif
    ((*local_this).set_red_blue_stereo)((PyObject_IsTrue(param1) != 0), (unsigned int)param2, (unsigned int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_red_blue_stereo(const GraphicsOutput self, bool red_blue_stereo, int left_eye_color_mask, int right_eye_color_mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_set_red_blue_stereo_567_comment =
  "C++ Interface:\n"
  "set_red_blue_stereo(const GraphicsOutput self, bool red_blue_stereo, int left_eye_color_mask, int right_eye_color_mask)\n"
  "\n"
  "/**\n"
  " * Enables red-blue stereo mode on this particular window.  When red-blue\n"
  " * stereo mode is in effect, DisplayRegions that have the \"left\" channel set\n"
  " * will render in the red (or specified) channel only, while DisplayRegions\n"
  " * that have the \"right\" channel set will render in the blue (or specified)\n"
  " * channel only.\n"
  " *\n"
  " * The remaining two parameters specify the particular color channel(s) to\n"
  " * associate with each eye.  Use the bits defined in\n"
  " * ColorWriteAttrib::Channels.\n"
  " *\n"
  " * This can be used to achieve a cheesy stereo mode in the absence of\n"
  " * hardware-supported stereo.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_set_red_blue_stereo_567_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsOutput::get_red_blue_stereo(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_red_blue_stereo_568(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline bool GraphicsOutput::get_red_blue_stereo(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).get_red_blue_stereo)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_red_blue_stereo_568_comment =
  "C++ Interface:\n"
  "get_red_blue_stereo(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns whether red-blue stereo mode is in effect for this particular\n"
  " * window.  See set_red_blue_stereo().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_red_blue_stereo_568_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int GraphicsOutput::get_left_eye_color_mask(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_left_eye_color_mask_569(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline unsigned int GraphicsOutput::get_left_eye_color_mask(void) const
  unsigned int return_value = ((*(const GraphicsOutput*)local_this).get_left_eye_color_mask)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_left_eye_color_mask_569_comment =
  "C++ Interface:\n"
  "get_left_eye_color_mask(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the color mask in effect when rendering a left-eye view in red_blue\n"
  " * stereo mode.  This is one or more bits defined in\n"
  " * ColorWriteAttrib::Channels.  See set_red_blue_stereo().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_left_eye_color_mask_569_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int GraphicsOutput::get_right_eye_color_mask(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_right_eye_color_mask_570(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline unsigned int GraphicsOutput::get_right_eye_color_mask(void) const
  unsigned int return_value = ((*(const GraphicsOutput*)local_this).get_right_eye_color_mask)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_right_eye_color_mask_570_comment =
  "C++ Interface:\n"
  "get_right_eye_color_mask(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the color mask in effect when rendering a right-eye view in\n"
  " * red_blue stereo mode.  This is one or more bits defined in\n"
  " * ColorWriteAttrib::Channels.  See set_red_blue_stereo().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_right_eye_color_mask_570_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsOutput::set_side_by_side_stereo(bool side_by_side_stereo)
 * void GraphicsOutput::set_side_by_side_stereo(bool side_by_side_stereo, LVecBase4 const &sbs_left_dimensions, LVecBase4 const &sbs_right_dimensions)
 */
static PyObject *Dtool_GraphicsOutput_set_side_by_side_stereo_571(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.set_side_by_side_stereo")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "side_by_side_stereo")) {
        // 1-void GraphicsOutput::set_side_by_side_stereo(bool side_by_side_stereo)
        ((*local_this).set_side_by_side_stereo)((PyObject_IsTrue(arg) != 0));
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-void GraphicsOutput::set_side_by_side_stereo(bool side_by_side_stereo, LVecBase4 const &sbs_left_dimensions, LVecBase4 const &sbs_right_dimensions)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"side_by_side_stereo", "sbs_left_dimensions", "sbs_right_dimensions", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_side_by_side_stereo", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase4f param2_local;
        LVecBase4 const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "GraphicsOutput.set_side_by_side_stereo", "LVecBase4f");
        }
        LVecBase4f param3_local;
        LVecBase4 const *param3_this = Dtool_Coerce_LVecBase4f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "GraphicsOutput.set_side_by_side_stereo", "LVecBase4f");
        }
        ((*local_this).set_side_by_side_stereo)((PyObject_IsTrue(param1) != 0), *param2_this, *param3_this);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_side_by_side_stereo() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_side_by_side_stereo(const GraphicsOutput self, bool side_by_side_stereo)\n"
      "set_side_by_side_stereo(const GraphicsOutput self, bool side_by_side_stereo, const LVecBase4f sbs_left_dimensions, const LVecBase4f sbs_right_dimensions)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_set_side_by_side_stereo_571_comment =
  "C++ Interface:\n"
  "set_side_by_side_stereo(const GraphicsOutput self, bool side_by_side_stereo)\n"
  "set_side_by_side_stereo(const GraphicsOutput self, bool side_by_side_stereo, const LVecBase4f sbs_left_dimensions, const LVecBase4f sbs_right_dimensions)\n"
  "\n"
  "/**\n"
  " * Enables side-by-side stereo mode on this particular window.  When side-by-\n"
  " * side stereo mode is in effect, DisplayRegions that have the \"left\" channel\n"
  " * set will render on the part of the window specified by sbs_left_dimensions\n"
  " * (typically the left half: (0, 0.5, 0, 1)), while DisplayRegions that have\n"
  " * the \"right\" channel set will render on the part of the window specified by\n"
  " * sbs_right_dimensions (typically the right half: (0.5, 1, 0, 1)).\n"
  " *\n"
  " * This is commonly used in a dual-monitor mode, where a window is opened that\n"
  " * spans two monitors, and each monitor represents a different eye.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Enables side-by-side stereo mode on this particular window.  When side-by-\n"
  " * side stereo mode is in effect, DisplayRegions that have the \"left\" channel\n"
  " * set will render on the part of the window specified by sbs_left_dimensions\n"
  " * (typically the left half: (0, 0.5, 0, 1)), while DisplayRegions that have\n"
  " * the \"right\" channel set will render on the part of the window specified by\n"
  " * sbs_right_dimensions (typically the right half: (0.5, 1, 0, 1)).\n"
  " *\n"
  " * This is commonly used in a dual-monitor mode, where a window is opened that\n"
  " * spans two monitors, and each monitor represents a different eye.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_set_side_by_side_stereo_571_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsOutput::get_side_by_side_stereo(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_side_by_side_stereo_572(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline bool GraphicsOutput::get_side_by_side_stereo(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).get_side_by_side_stereo)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_side_by_side_stereo_572_comment =
  "C++ Interface:\n"
  "get_side_by_side_stereo(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns whether side-by-side stereo mode is in effect for this particular\n"
  " * window.  See set_side_by_side_stereo().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_side_by_side_stereo_572_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 const &GraphicsOutput::get_sbs_left_dimensions(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_sbs_left_dimensions_573(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline LVecBase4 const &GraphicsOutput::get_sbs_left_dimensions(void) const
  LVecBase4 const *return_value = &(((*(const GraphicsOutput*)local_this).get_sbs_left_dimensions)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_sbs_left_dimensions_573_comment =
  "C++ Interface:\n"
  "get_sbs_left_dimensions(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the effective sub-region of the window for displaying the left\n"
  " * channel, if side-by-side stereo mode is in effect for the window.  See\n"
  " * set_side_by_side_stereo().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_sbs_left_dimensions_573_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4 const &GraphicsOutput::get_sbs_right_dimensions(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_sbs_right_dimensions_574(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline LVecBase4 const &GraphicsOutput::get_sbs_right_dimensions(void) const
  LVecBase4 const *return_value = &(((*(const GraphicsOutput*)local_this).get_sbs_right_dimensions)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_sbs_right_dimensions_574_comment =
  "C++ Interface:\n"
  "get_sbs_right_dimensions(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the effective sub-region of the window for displaying the right\n"
  " * channel, if side-by-side stereo mode is in effect for the window.  See\n"
  " * set_side_by_side_stereo().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_sbs_right_dimensions_574_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline FrameBufferProperties const &GraphicsOutput::get_fb_properties(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_fb_properties_575(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline FrameBufferProperties const &GraphicsOutput::get_fb_properties(void) const
  FrameBufferProperties const *return_value = &(((*(const GraphicsOutput*)local_this).get_fb_properties)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_FrameBufferProperties, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_fb_properties_575_comment =
  "C++ Interface:\n"
  "get_fb_properties(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the framebuffer properties of the window.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_fb_properties_575_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsOutput::is_stereo(void) const
 */
static PyObject *Dtool_GraphicsOutput_is_stereo_576(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline bool GraphicsOutput::is_stereo(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).is_stereo)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_is_stereo_576_comment =
  "C++ Interface:\n"
  "is_stereo(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns Returns true if this window can render stereo DisplayRegions,\n"
  " * either through red-blue stereo (see set_red_blue_stereo()) or through true\n"
  " * hardware stereo rendering.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_is_stereo_576_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsOutput::clear_delete_flag(void)
 */
static PyObject *Dtool_GraphicsOutput_clear_delete_flag_577(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.clear_delete_flag")) {
    return nullptr;
  }
  // 1-inline void GraphicsOutput::clear_delete_flag(void)
  ((*local_this).clear_delete_flag)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_clear_delete_flag_577_comment =
  "C++ Interface:\n"
  "clear_delete_flag(const GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Resets the delete flag, so the GraphicsOutput will not be automatically\n"
  " * deleted before the beginning of the next frame.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_clear_delete_flag_577_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GraphicsOutput::get_delete_flag(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_delete_flag_578(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-bool GraphicsOutput::get_delete_flag(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).get_delete_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_delete_flag_578_comment =
  "C++ Interface:\n"
  "get_delete_flag(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the delete flag.  When this is true, the\n"
  " * GraphicsOutput will automatically be removed before the beginning of the\n"
  " * next frame by the GraphicsEngine.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_delete_flag_578_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void GraphicsOutput::set_sort(int sort)
 */
static PyObject *Dtool_GraphicsOutput_set_sort_579(PyObject *self, PyObject *arg) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.set_sort")) {
    return nullptr;
  }
  // 1-virtual void GraphicsOutput::set_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_sort)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sort(const GraphicsOutput self, int sort)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_set_sort_579_comment =
  "C++ Interface:\n"
  "set_sort(const GraphicsOutput self, int sort)\n"
  "\n"
  "/**\n"
  " * Adjusts the sorting order of this particular GraphicsOutput, relative to\n"
  " * other GraphicsOutputs.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_set_sort_579_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsOutput::get_sort(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_sort_580(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline int GraphicsOutput::get_sort(void) const
  int return_value = ((*(const GraphicsOutput*)local_this).get_sort)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_sort_580_comment =
  "C++ Interface:\n"
  "get_sort(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the sorting order of this particular GraphicsOutput.  The various\n"
  " * GraphicsOutputs within a particular thread will be rendered in the\n"
  " * indicated order.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_sort_580_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsOutput::set_child_sort(int child_sort)
 */
static PyObject *Dtool_GraphicsOutput_set_child_sort_582(PyObject *self, PyObject *arg) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.set_child_sort")) {
    return nullptr;
  }
  // 1-inline void GraphicsOutput::set_child_sort(int child_sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_child_sort)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_child_sort(const GraphicsOutput self, int child_sort)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_set_child_sort_582_comment =
  "C++ Interface:\n"
  "set_child_sort(const GraphicsOutput self, int child_sort)\n"
  "\n"
  "/**\n"
  " * Specifies the sort value of future offscreen buffers created by\n"
  " * make_texture_sort().\n"
  " *\n"
  " * The purpose of this method is to allow the user to limit the sort value\n"
  " * chosen for a buffer created via make_texture_buffer().  Normally, this\n"
  " * buffer will be assigned a value of get_sort() - 1, so that it will be\n"
  " * rendered before this window is rendered; but sometimes this isn't\n"
  " * sufficiently early, especially if other buffers also have a view into the\n"
  " * same scene.\n"
  " *\n"
  " * If you specify a value here, then new buffers created via\n"
  " * make_texture_buffer() will be given that sort value instead of get_sort() -\n"
  " * 1.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_set_child_sort_582_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsOutput::clear_child_sort(void)
 */
static PyObject *Dtool_GraphicsOutput_clear_child_sort_583(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.clear_child_sort")) {
    return nullptr;
  }
  // 1-inline void GraphicsOutput::clear_child_sort(void)
  ((*local_this).clear_child_sort)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_clear_child_sort_583_comment =
  "C++ Interface:\n"
  "clear_child_sort(const GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Resets the sort value of future offscreen buffers created by\n"
  " * make_texture_sort() to the default value.  See set_child_sort().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_clear_child_sort_583_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsOutput::get_child_sort(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_child_sort_584(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline int GraphicsOutput::get_child_sort(void) const
  int return_value = ((*(const GraphicsOutput*)local_this).get_child_sort)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_child_sort_584_comment =
  "C++ Interface:\n"
  "get_child_sort(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the sort value of future offscreen buffers created by\n"
  " * make_texture_sort(). See set_child_sort().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_child_sort_584_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AsyncFuture *GraphicsOutput::trigger_copy(void)
 */
static PyObject *Dtool_GraphicsOutput_trigger_copy_586(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.trigger_copy")) {
    return nullptr;
  }
  // 1-inline AsyncFuture *GraphicsOutput::trigger_copy(void)
  AsyncFuture *return_value = ((*local_this).trigger_copy)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AsyncFuture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_trigger_copy_586_comment =
  "C++ Interface:\n"
  "trigger_copy(const GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * When the GraphicsOutput is in triggered copy mode, this function triggers\n"
  " * the copy (at the end of the next frame).\n"
  " * @returns a future that can be awaited.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_trigger_copy_586_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DisplayRegion *GraphicsOutput::make_display_region(void)
 * DisplayRegion *GraphicsOutput::make_display_region(LVecBase4 const &dimensions)
 * inline DisplayRegion *GraphicsOutput::make_display_region(PN_stdfloat l, PN_stdfloat r, PN_stdfloat b, PN_stdfloat t)
 */
static PyObject *Dtool_GraphicsOutput_make_display_region_587(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.make_display_region")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline DisplayRegion *GraphicsOutput::make_display_region(void)
      DisplayRegion *return_value = ((*local_this).make_display_region)();
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "dimensions")) {
        // 1-DisplayRegion *GraphicsOutput::make_display_region(LVecBase4 const &dimensions)
        LVecBase4f arg_local;
        LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GraphicsOutput.make_display_region", "LVecBase4f");
        }
        DisplayRegion *return_value = ((*local_this).make_display_region)(*arg_this);
        if (return_value != nullptr) {
          return_value->ref();
        }
        if (Dtool_CheckErrorOccurred()) {
          if (return_value != nullptr) {
            unref_delete(return_value);
          }
          return nullptr;
        }
        if (return_value == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
        }
      }
    }
    break;
  case 4:
    {
      // 1-inline DisplayRegion *GraphicsOutput::make_display_region(PN_stdfloat l, PN_stdfloat r, PN_stdfloat b, PN_stdfloat t)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"l", "r", "b", "t", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:make_display_region", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        DisplayRegion *return_value = ((*local_this).make_display_region)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        if (return_value != nullptr) {
          return_value->ref();
        }
        if (Dtool_CheckErrorOccurred()) {
          if (return_value != nullptr) {
            unref_delete(return_value);
          }
          return nullptr;
        }
        if (return_value == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_display_region() takes 1, 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_display_region(const GraphicsOutput self)\n"
      "make_display_region(const GraphicsOutput self, const LVecBase4f dimensions)\n"
      "make_display_region(const GraphicsOutput self, float l, float r, float b, float t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_make_display_region_587_comment =
  "C++ Interface:\n"
  "make_display_region(const GraphicsOutput self)\n"
  "make_display_region(const GraphicsOutput self, const LVecBase4f dimensions)\n"
  "make_display_region(const GraphicsOutput self, float l, float r, float b, float t)\n"
  "\n"
  "/**\n"
  " * Creates a new DisplayRegion that covers the entire window.\n"
  " *\n"
  " * If is_stereo() is true for this window, and default-stereo-camera is\n"
  " * configured true, this actually makes a StereoDisplayRegion.  Call\n"
  " * make_mono_display_region() or make_stereo_display_region() if you want to\n"
  " * insist on one or the other.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Creates a new DisplayRegion that covers the indicated sub-rectangle within\n"
  " * the window.  The range on all parameters is 0..1.\n"
  " *\n"
  " * If is_stereo() is true for this window, and default-stereo-camera is\n"
  " * configured true, this actually makes a StereoDisplayRegion.  Call\n"
  " * make_mono_display_region() or make_stereo_display_region() if you want to\n"
  " * insist on one or the other.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Creates a new DisplayRegion that covers the indicated sub-rectangle within\n"
  " * the window.  The range on all parameters is 0..1.\n"
  " *\n"
  " * If is_stereo() is true for this window, and default-stereo-camera is\n"
  " * configured true, this actually makes a StereoDisplayRegion.  Call\n"
  " * make_mono_display_region() or make_stereo_display_region() if you want to\n"
  " * insist on one or the other.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_make_display_region_587_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DisplayRegion *GraphicsOutput::make_mono_display_region(void)
 * DisplayRegion *GraphicsOutput::make_mono_display_region(LVecBase4 const &dimensions)
 * inline DisplayRegion *GraphicsOutput::make_mono_display_region(PN_stdfloat l, PN_stdfloat r, PN_stdfloat b, PN_stdfloat t)
 */
static PyObject *Dtool_GraphicsOutput_make_mono_display_region_588(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.make_mono_display_region")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline DisplayRegion *GraphicsOutput::make_mono_display_region(void)
      DisplayRegion *return_value = ((*local_this).make_mono_display_region)();
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "dimensions")) {
        // 1-DisplayRegion *GraphicsOutput::make_mono_display_region(LVecBase4 const &dimensions)
        LVecBase4f arg_local;
        LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GraphicsOutput.make_mono_display_region", "LVecBase4f");
        }
        DisplayRegion *return_value = ((*local_this).make_mono_display_region)(*arg_this);
        if (return_value != nullptr) {
          return_value->ref();
        }
        if (Dtool_CheckErrorOccurred()) {
          if (return_value != nullptr) {
            unref_delete(return_value);
          }
          return nullptr;
        }
        if (return_value == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
        }
      }
    }
    break;
  case 4:
    {
      // 1-inline DisplayRegion *GraphicsOutput::make_mono_display_region(PN_stdfloat l, PN_stdfloat r, PN_stdfloat b, PN_stdfloat t)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"l", "r", "b", "t", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:make_mono_display_region", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        DisplayRegion *return_value = ((*local_this).make_mono_display_region)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        if (return_value != nullptr) {
          return_value->ref();
        }
        if (Dtool_CheckErrorOccurred()) {
          if (return_value != nullptr) {
            unref_delete(return_value);
          }
          return nullptr;
        }
        if (return_value == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_mono_display_region() takes 1, 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_mono_display_region(const GraphicsOutput self)\n"
      "make_mono_display_region(const GraphicsOutput self, const LVecBase4f dimensions)\n"
      "make_mono_display_region(const GraphicsOutput self, float l, float r, float b, float t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_make_mono_display_region_588_comment =
  "C++ Interface:\n"
  "make_mono_display_region(const GraphicsOutput self)\n"
  "make_mono_display_region(const GraphicsOutput self, const LVecBase4f dimensions)\n"
  "make_mono_display_region(const GraphicsOutput self, float l, float r, float b, float t)\n"
  "\n"
  "/**\n"
  " * Creates a new DisplayRegion that covers the entire window.\n"
  " *\n"
  " * This generally returns a mono DisplayRegion, even if is_stereo() is true.\n"
  " * However, if side-by-side stereo is enabled, this will return a\n"
  " * StereoDisplayRegion whose two eyes are both set to SC_mono.  (This is\n"
  " * necessary because in side-by-side stereo mode, it is necessary to draw even\n"
  " * mono DisplayRegions twice).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Creates a new DisplayRegion that covers the entire window.\n"
  " *\n"
  " * This generally returns a mono DisplayRegion, even if is_stereo() is true.\n"
  " * However, if side-by-side stereo is enabled, this will return a\n"
  " * StereoDisplayRegion whose two eyes are both set to SC_mono.  (This is\n"
  " * necessary because in side-by-side stereo mode, it is necessary to draw even\n"
  " * mono DisplayRegions twice).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Creates a new DisplayRegion that covers the indicated sub-rectangle within\n"
  " * the window.  The range on all parameters is 0..1.\n"
  " *\n"
  " * This generally returns a mono DisplayRegion, even if is_stereo() is true.\n"
  " * However, if side-by-side stereo is enabled, this will return a\n"
  " * StereoDisplayRegion whose two eyes are both set to SC_mono.  (This is\n"
  " * necessary because in side-by-side stereo mode, it is necessary to draw even\n"
  " * mono DisplayRegions twice).\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_make_mono_display_region_588_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline StereoDisplayRegion *GraphicsOutput::make_stereo_display_region(void)
 * StereoDisplayRegion *GraphicsOutput::make_stereo_display_region(LVecBase4 const &dimensions)
 * inline StereoDisplayRegion *GraphicsOutput::make_stereo_display_region(PN_stdfloat l, PN_stdfloat r, PN_stdfloat b, PN_stdfloat t)
 */
static PyObject *Dtool_GraphicsOutput_make_stereo_display_region_589(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.make_stereo_display_region")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline StereoDisplayRegion *GraphicsOutput::make_stereo_display_region(void)
      StereoDisplayRegion *return_value = ((*local_this).make_stereo_display_region)();
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_StereoDisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "dimensions")) {
        // 1-StereoDisplayRegion *GraphicsOutput::make_stereo_display_region(LVecBase4 const &dimensions)
        LVecBase4f arg_local;
        LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "GraphicsOutput.make_stereo_display_region", "LVecBase4f");
        }
        StereoDisplayRegion *return_value = ((*local_this).make_stereo_display_region)(*arg_this);
        if (return_value != nullptr) {
          return_value->ref();
        }
        if (Dtool_CheckErrorOccurred()) {
          if (return_value != nullptr) {
            unref_delete(return_value);
          }
          return nullptr;
        }
        if (return_value == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_StereoDisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
        }
      }
    }
    break;
  case 4:
    {
      // 1-inline StereoDisplayRegion *GraphicsOutput::make_stereo_display_region(PN_stdfloat l, PN_stdfloat r, PN_stdfloat b, PN_stdfloat t)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"l", "r", "b", "t", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:make_stereo_display_region", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        StereoDisplayRegion *return_value = ((*local_this).make_stereo_display_region)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PN_stdfloat)param4);
        if (return_value != nullptr) {
          return_value->ref();
        }
        if (Dtool_CheckErrorOccurred()) {
          if (return_value != nullptr) {
            unref_delete(return_value);
          }
          return nullptr;
        }
        if (return_value == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_StereoDisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make_stereo_display_region() takes 1, 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_stereo_display_region(const GraphicsOutput self)\n"
      "make_stereo_display_region(const GraphicsOutput self, const LVecBase4f dimensions)\n"
      "make_stereo_display_region(const GraphicsOutput self, float l, float r, float b, float t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_make_stereo_display_region_589_comment =
  "C++ Interface:\n"
  "make_stereo_display_region(const GraphicsOutput self)\n"
  "make_stereo_display_region(const GraphicsOutput self, const LVecBase4f dimensions)\n"
  "make_stereo_display_region(const GraphicsOutput self, float l, float r, float b, float t)\n"
  "\n"
  "/**\n"
  " * Creates a new DisplayRegion that covers the entire window.\n"
  " *\n"
  " * This always returns a stereo DisplayRegion, even if is_stereo() is false.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Creates a new DisplayRegion that covers the entire window.\n"
  " *\n"
  " * This always returns a stereo DisplayRegion, even if is_stereo() is false.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Creates a new DisplayRegion that covers the indicated sub-rectangle within\n"
  " * the window.  The range on all parameters is 0..1.\n"
  " *\n"
  " * This always returns a stereo DisplayRegion, even if is_stereo() is false.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_make_stereo_display_region_589_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GraphicsOutput::remove_display_region(DisplayRegion *display_region)
 */
static PyObject *Dtool_GraphicsOutput_remove_display_region_590(PyObject *self, PyObject *arg) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.remove_display_region")) {
    return nullptr;
  }
  // 1-bool GraphicsOutput::remove_display_region(DisplayRegion *display_region)
  DisplayRegion *arg_this = (DisplayRegion *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DisplayRegion, 1, "GraphicsOutput.remove_display_region", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).remove_display_region)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_display_region(const GraphicsOutput self, DisplayRegion display_region)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_remove_display_region_590_comment =
  "C++ Interface:\n"
  "remove_display_region(const GraphicsOutput self, DisplayRegion display_region)\n"
  "\n"
  "/**\n"
  " * Removes the indicated DisplayRegion from the window, and destructs it if\n"
  " * there are no other references.\n"
  " *\n"
  " * Returns true if the DisplayRegion is found and removed, false if it was not\n"
  " * a part of the window.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_remove_display_region_590_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsOutput::remove_all_display_regions(void)
 */
static PyObject *Dtool_GraphicsOutput_remove_all_display_regions_591(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.remove_all_display_regions")) {
    return nullptr;
  }
  // 1-void GraphicsOutput::remove_all_display_regions(void)
  ((*local_this).remove_all_display_regions)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_remove_all_display_regions_591_comment =
  "C++ Interface:\n"
  "remove_all_display_regions(const GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Removes all display regions from the window, except the default one that is\n"
  " * created with the window.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_remove_all_display_regions_591_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DisplayRegion *GraphicsOutput::get_overlay_display_region(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_overlay_display_region_592(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-inline DisplayRegion *GraphicsOutput::get_overlay_display_region(void) const
  DisplayRegion *return_value = ((*(const GraphicsOutput*)local_this).get_overlay_display_region)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_overlay_display_region_592_comment =
  "C++ Interface:\n"
  "get_overlay_display_region(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the special \"overlay\" DisplayRegion that is created for each window\n"
  " * or buffer.  This DisplayRegion covers the entire window, but cannot be used\n"
  " * for rendering.  It is a placeholder only, to indicate the dimensions of the\n"
  " * window, and is usually used internally for purposes such as clearing the\n"
  " * window, or grabbing a screenshot of the window.\n"
  " *\n"
  " * There are very few applications that require access to this DisplayRegion.\n"
  " * Normally, you should create your own DisplayRegion that covers the window,\n"
  " * if you want to render to the window.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_overlay_display_region_592_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsOutput::set_overlay_display_region(DisplayRegion *display_region)
 */
static PyObject *Dtool_GraphicsOutput_set_overlay_display_region_593(PyObject *self, PyObject *arg) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.set_overlay_display_region")) {
    return nullptr;
  }
  // 1-void GraphicsOutput::set_overlay_display_region(DisplayRegion *display_region)
  DisplayRegion *arg_this = (DisplayRegion *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DisplayRegion, 1, "GraphicsOutput.set_overlay_display_region", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_overlay_display_region)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_overlay_display_region(const GraphicsOutput self, DisplayRegion display_region)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_set_overlay_display_region_593_comment =
  "C++ Interface:\n"
  "set_overlay_display_region(const GraphicsOutput self, DisplayRegion display_region)\n"
  "\n"
  "/**\n"
  " * Replaces the special \"overlay\" DisplayRegion that is created for each\n"
  " * window or buffer.  See get_overlay_display_region().  This must be a new\n"
  " * DisplayRegion that has already been created for this window, for instance\n"
  " * via a call to make_mono_display_region().  You are responsible for ensuring\n"
  " * that the new DisplayRegion covers the entire window.  The previous overlay\n"
  " * display region is not automatically removed; you must explicitly call\n"
  " * remove_display_region() on it after replacing it with this method, if you\n"
  " * wish it to be removed.\n"
  " *\n"
  " * Normally, there is no reason to change the overlay DisplayRegion, so this\n"
  " * method should be used only in very unusual circumstances.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_set_overlay_display_region_593_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GraphicsOutput::get_num_display_regions(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_num_display_regions_594(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-int GraphicsOutput::get_num_display_regions(void) const
  int return_value = ((*(const GraphicsOutput*)local_this).get_num_display_regions)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_num_display_regions_594_comment =
  "C++ Interface:\n"
  "get_num_display_regions(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the number of DisplayRegions that have been created within the\n"
  " * window, active or otherwise.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_num_display_regions_594_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< DisplayRegion > GraphicsOutput::get_display_region(int n) const
 */
static PyObject *Dtool_GraphicsOutput_get_display_region_595(PyObject *self, PyObject *arg) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-PointerTo< DisplayRegion > GraphicsOutput::get_display_region(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< DisplayRegion > return_value = ((*(const GraphicsOutput*)local_this).get_display_region)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    DisplayRegion *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_DisplayRegion, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_display_region(GraphicsOutput self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_display_region_595_comment =
  "C++ Interface:\n"
  "get_display_region(GraphicsOutput self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth DisplayRegion of those that have been created within the\n"
  " * window.  This may return NULL if n is out of bounds; particularly likely if\n"
  " * the number of display regions has changed since the last call to\n"
  " * get_num_display_regions().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_display_region_595_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GraphicsOutput::get_num_active_display_regions(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_num_active_display_regions_599(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-int GraphicsOutput::get_num_active_display_regions(void) const
  int return_value = ((*(const GraphicsOutput*)local_this).get_num_active_display_regions)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_num_active_display_regions_599_comment =
  "C++ Interface:\n"
  "get_num_active_display_regions(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns the number of active DisplayRegions that have been created within\n"
  " * the window.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_num_active_display_regions_599_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< DisplayRegion > GraphicsOutput::get_active_display_region(int n) const
 */
static PyObject *Dtool_GraphicsOutput_get_active_display_region_600(PyObject *self, PyObject *arg) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-PointerTo< DisplayRegion > GraphicsOutput::get_active_display_region(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< DisplayRegion > return_value = ((*(const GraphicsOutput*)local_this).get_active_display_region)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    DisplayRegion *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_DisplayRegion, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_active_display_region(GraphicsOutput self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_active_display_region_600_comment =
  "C++ Interface:\n"
  "get_active_display_region(GraphicsOutput self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth active DisplayRegion of those that have been created within\n"
  " * the window.  This may return NULL if n is out of bounds; particularly\n"
  " * likely if the number of display regions has changed since the last call to\n"
  " * get_num_active_display_regions().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_active_display_region_600_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GraphicsOutput *GraphicsOutput::make_texture_buffer(std::string const &name, int x_size, int y_size, Texture *tex = nullptr, bool to_ram = false, FrameBufferProperties *fbp = nullptr)
 */
static PyObject *Dtool_GraphicsOutput_make_texture_buffer_603(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.make_texture_buffer")) {
    return nullptr;
  }
  // 1-GraphicsOutput *GraphicsOutput::make_texture_buffer(std::string const &name, int x_size, int y_size, Texture *tex = nullptr, bool to_ram = false, FrameBufferProperties *fbp = nullptr)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  int param2;
  int param3;
  PyObject *param4 = nullptr;
  PyObject *param5 = Py_False;
  PyObject *param6 = nullptr;
  static const char *keyword_list[] = {"name", "x_size", "y_size", "tex", "to_ram", "fbp", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#ii|OOO:make_texture_buffer", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3, &param4, &param5, &param6)) {
    Texture *param4_this = nullptr;
    if (param4 != nullptr && param4 != Py_None) {
      param4_this = (Texture *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_Texture, 4, "GraphicsOutput.make_texture_buffer", false, true);
    }
    FrameBufferProperties *param6_this = nullptr;
    if (param6 != nullptr && param6 != Py_None) {
      param6_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(param6, Dtool_Ptr_FrameBufferProperties, 6, "GraphicsOutput.make_texture_buffer", false, true);
    }
    if ((param4 == nullptr || param4 == Py_None || param4_this != nullptr) && (param6 == nullptr || param6 == Py_None || param6_this != nullptr)) {
      GraphicsOutput *return_value = ((*local_this).make_texture_buffer)(std::string(param1_str, param1_len), (int)param2, (int)param3, param4_this, (PyObject_IsTrue(param5) != 0), param6_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutput, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_texture_buffer(const GraphicsOutput self, str name, int x_size, int y_size, Texture tex, bool to_ram, FrameBufferProperties fbp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_make_texture_buffer_603_comment =
  "C++ Interface:\n"
  "make_texture_buffer(const GraphicsOutput self, str name, int x_size, int y_size, Texture tex, bool to_ram, FrameBufferProperties fbp)\n"
  "\n"
  "/**\n"
  " * Creates and returns an offscreen buffer for rendering into, the result of\n"
  " * which will be a texture suitable for applying to geometry within the scene\n"
  " * rendered into this window.\n"
  " *\n"
  " * If tex is not NULL, it is the texture that will be set up for rendering\n"
  " * into; otherwise, a new Texture object will be created.  In either case, the\n"
  " * target texture can be retrieved from the return value with\n"
  " * buffer->get_texture() (assuming the return value is not NULL).\n"
  " *\n"
  " * If to_ram is true, the buffer will be set up to download its contents to\n"
  " * the system RAM memory associated with the Texture object, instead of\n"
  " * keeping it strictly within texture memory; this is much slower, but it\n"
  " * allows using the texture with any GSG.\n"
  " *\n"
  " * This will attempt to be smart about maximizing render performance while\n"
  " * minimizing framebuffer waste.  It might return a GraphicsBuffer set to\n"
  " * render directly into a texture, if possible; or it might return a\n"
  " * ParasiteBuffer that renders into this window.  The return value is NULL if\n"
  " * the buffer could not be created for some reason.\n"
  " *\n"
  " * When you are done using the buffer, you should remove it with a call to\n"
  " * GraphicsEngine::remove_window().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_make_texture_buffer_603_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GraphicsOutput *GraphicsOutput::make_cube_map(std::string const &name, int size, NodePath &camera_rig, DrawMask camera_mask = PandaNode::get_all_camera_mask(), bool to_ram = false, FrameBufferProperties *fbp = nullptr)
 */
static PyObject *Dtool_GraphicsOutput_make_cube_map_604(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.make_cube_map")) {
    return nullptr;
  }
  // 1-GraphicsOutput *GraphicsOutput::make_cube_map(std::string const &name, int size, NodePath &camera_rig, DrawMask camera_mask = PandaNode::get_all_camera_mask(), bool to_ram = false, FrameBufferProperties *fbp = nullptr)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  int param2;
  PyObject *param3;
  PyObject *param4 = nullptr;
  PyObject *param5 = Py_False;
  PyObject *param6 = nullptr;
  static const char *keyword_list[] = {"name", "size", "camera_rig", "camera_mask", "to_ram", "fbp", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#iO|OOO:make_cube_map", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3, &param4, &param5, &param6)) {
    NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "GraphicsOutput.make_cube_map", false, true);
    BitMask< uint32_t, 32 > param4_local;
    DrawMask *param4_this;
    if (param4 != nullptr) {
      param4_this = Dtool_Coerce_BitMask_uint32_t_32(param4, param4_local);
    } else {
      param4_local = PandaNode::get_all_camera_mask();
      param4_this = &param4_local;
    }
    if (param4 != nullptr && !(param4_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "GraphicsOutput.make_cube_map", "BitMask");
    }
    FrameBufferProperties *param6_this = nullptr;
    if (param6 != nullptr && param6 != Py_None) {
      param6_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(param6, Dtool_Ptr_FrameBufferProperties, 6, "GraphicsOutput.make_cube_map", false, true);
    }
    if (param3_this != nullptr && (param6 == nullptr || param6 == Py_None || param6_this != nullptr)) {
      GraphicsOutput *return_value = ((*local_this).make_cube_map)(std::string(param1_str, param1_len), (int)param2, *param3_this, *param4_this, (PyObject_IsTrue(param5) != 0), param6_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutput, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_cube_map(const GraphicsOutput self, str name, int size, NodePath camera_rig, BitMask camera_mask, bool to_ram, FrameBufferProperties fbp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_make_cube_map_604_comment =
  "C++ Interface:\n"
  "make_cube_map(const GraphicsOutput self, str name, int size, NodePath camera_rig, BitMask camera_mask, bool to_ram, FrameBufferProperties fbp)\n"
  "\n"
  "/**\n"
  " * This is similar to make_texture_buffer() in that it allocates a separate\n"
  " * buffer suitable for rendering to a texture that can be assigned to geometry\n"
  " * in this window, but in this case, the buffer is set up to render the six\n"
  " * faces of a cube map.\n"
  " *\n"
  " * The buffer is automatically set up with six display regions and six\n"
  " * cameras, each of which are assigned the indicated draw_mask and parented to\n"
  " * the given camera_rig node (which you should then put in your scene to\n"
  " * render the cube map from the appropriate point of view).\n"
  " *\n"
  " * You may take the texture associated with the buffer and apply it to\n"
  " * geometry, particularly with TexGenAttrib::M_world_cube_map also in effect,\n"
  " * to apply a reflection of everything seen by the camera rig.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_make_cube_map_604_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline Filename GraphicsOutput::make_screenshot_filename(std::string const &prefix = "screenshot")
 */
static PyObject *Dtool_GraphicsOutput_make_screenshot_filename_605(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline Filename GraphicsOutput::make_screenshot_filename(std::string const &prefix = "screenshot")
  const char *param0_str = "screenshot";
  Py_ssize_t param0_len = 10;
  static const char *keyword_list[] = {"prefix", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:make_screenshot_filename", (char **)keyword_list, &param0_str, &param0_len)) {
    Filename *return_value = new Filename((GraphicsOutput::make_screenshot_filename)(std::string(param0_str, param0_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_screenshot_filename(str prefix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_make_screenshot_filename_605_comment =
  "C++ Interface:\n"
  "make_screenshot_filename(str prefix)\n"
  "\n"
  "/**\n"
  " * Saves a screenshot of the region to a default filename, and returns the\n"
  " * filename, or empty string if the screenshot failed.  The default filename\n"
  " * is generated from the supplied prefix and from the Config variable\n"
  " * screenshot-filename, which contains the following strings:\n"
  " *\n"
  " * %~p - the supplied prefix %~f - the frame count %~e - the value of\n"
  " * screenshot-extension All other % strings in strftime().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_make_screenshot_filename_605_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename GraphicsOutput::save_screenshot_default(std::string const &prefix = "screenshot")
 */
static PyObject *Dtool_GraphicsOutput_save_screenshot_default_606(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.save_screenshot_default")) {
    return nullptr;
  }
  // 1-inline Filename GraphicsOutput::save_screenshot_default(std::string const &prefix = "screenshot")
  const char *param1_str = "screenshot";
  Py_ssize_t param1_len = 10;
  static const char *keyword_list[] = {"prefix", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:save_screenshot_default", (char **)keyword_list, &param1_str, &param1_len)) {
    Filename *return_value = new Filename(((*local_this).save_screenshot_default)(std::string(param1_str, param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "save_screenshot_default(const GraphicsOutput self, str prefix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_save_screenshot_default_606_comment =
  "C++ Interface:\n"
  "save_screenshot_default(const GraphicsOutput self, str prefix)\n"
  "\n"
  "/**\n"
  " * Saves a screenshot of the region to a default filename, and returns the\n"
  " * filename, or empty string if the screenshot failed.  The filename is\n"
  " * generated by make_screenshot_filename().\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_save_screenshot_default_606_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsOutput::save_screenshot(Filename const &filename, std::string const &image_comment = "")
 */
static PyObject *Dtool_GraphicsOutput_save_screenshot_607(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.save_screenshot")) {
    return nullptr;
  }
  // 1-inline bool GraphicsOutput::save_screenshot(Filename const &filename, std::string const &image_comment = "")
  PyObject *param1;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  static const char *keyword_list[] = {"filename", "image_comment", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:save_screenshot", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "GraphicsOutput.save_screenshot", "Filename");
    }
    bool return_value = ((*local_this).save_screenshot)(*param1_this, std::string(param2_str, param2_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "save_screenshot(const GraphicsOutput self, const Filename filename, str image_comment)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_save_screenshot_607_comment =
  "C++ Interface:\n"
  "save_screenshot(const GraphicsOutput self, const Filename filename, str image_comment)\n"
  "\n"
  "/**\n"
  " * Saves a screenshot of the region to the indicated filename.  The image\n"
  " * comment is an optional user readable string that will be saved with the\n"
  " * header of the image (if the file format supports embedded data; for example\n"
  " * jpg allows comments).  Returns true on success, false on failure.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_save_screenshot_607_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< Texture > GraphicsOutput::get_screenshot(void)
 * inline bool GraphicsOutput::get_screenshot(PNMImage &image)
 */
static PyObject *Dtool_GraphicsOutput_get_screenshot_608(PyObject *self, PyObject *args) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.get_screenshot")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerTo< Texture > GraphicsOutput::get_screenshot(void)
      PointerTo< Texture > return_value = ((*local_this).get_screenshot)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      Texture *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_Texture, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline bool GraphicsOutput::get_screenshot(PNMImage &image)
      PNMImage *arg_this = (PNMImage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PNMImage, 1, "GraphicsOutput.get_screenshot", false, true);
      if (arg_this != nullptr) {
        bool return_value = ((*local_this).get_screenshot)(*arg_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_screenshot() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_screenshot(const GraphicsOutput self)\n"
      "get_screenshot(const GraphicsOutput self, PNMImage image)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_screenshot_608_comment =
  "C++ Interface:\n"
  "get_screenshot(const GraphicsOutput self)\n"
  "get_screenshot(const GraphicsOutput self, PNMImage image)\n"
  "\n"
  "/**\n"
  " * Captures the most-recently rendered image from the framebuffer into the\n"
  " * indicated PNMImage.  Returns true on success, false on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Captures the most-recently rendered image from the framebuffer and returns\n"
  " * it as Texture, or NULL on failure.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_screenshot_608_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NodePath GraphicsOutput::get_texture_card(void)
 */
static PyObject *Dtool_GraphicsOutput_get_texture_card_609(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.get_texture_card")) {
    return nullptr;
  }
  // 1-NodePath GraphicsOutput::get_texture_card(void)
  NodePath *return_value = new NodePath(((*local_this).get_texture_card)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_texture_card_609_comment =
  "C++ Interface:\n"
  "get_texture_card(const GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns a PandaNode containing a square polygon.  The dimensions are\n"
  " * (-1,0,-1) to (1,0,1). The texture coordinates are such that the texture of\n"
  " * this GraphicsOutput is aligned properly to the polygon.  The GraphicsOutput\n"
  " * promises to surgically update the Geom inside the PandaNode if necessary to\n"
  " * maintain this invariant.\n"
  " *\n"
  " * Each invocation of this function returns a freshly- allocated PandaNode.\n"
  " * You can therefore safely modify the RenderAttribs of the PandaNode.  The\n"
  " * PandaNode is initially textured with the texture of this GraphicOutput.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_texture_card_609_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool GraphicsOutput::share_depth_buffer(GraphicsOutput *graphics_output)
 */
static PyObject *Dtool_GraphicsOutput_share_depth_buffer_610(PyObject *self, PyObject *arg) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.share_depth_buffer")) {
    return nullptr;
  }
  // 1-virtual bool GraphicsOutput::share_depth_buffer(GraphicsOutput *graphics_output)
  GraphicsOutput *arg_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsOutput, 1, "GraphicsOutput.share_depth_buffer", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).share_depth_buffer)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "share_depth_buffer(const GraphicsOutput self, GraphicsOutput graphics_output)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_share_depth_buffer_610_comment =
  "C++ Interface:\n"
  "share_depth_buffer(const GraphicsOutput self, GraphicsOutput graphics_output)\n"
  "\n"
  "/**\n"
  " * Will attempt to use the depth buffer of the input graphics_output.  The\n"
  " * buffer sizes must be exactly the same.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_share_depth_buffer_610_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void GraphicsOutput::unshare_depth_buffer(void)
 */
static PyObject *Dtool_GraphicsOutput_unshare_depth_buffer_611(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.unshare_depth_buffer")) {
    return nullptr;
  }
  // 1-virtual void GraphicsOutput::unshare_depth_buffer(void)
  ((*local_this).unshare_depth_buffer)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_unshare_depth_buffer_611_comment =
  "C++ Interface:\n"
  "unshare_depth_buffer(const GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Discontinue sharing the depth buffer.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_unshare_depth_buffer_611_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool GraphicsOutput::get_supports_render_texture(void) const
 */
static PyObject *Dtool_GraphicsOutput_get_supports_render_texture_612(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-virtual bool GraphicsOutput::get_supports_render_texture(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).get_supports_render_texture)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_supports_render_texture_612_comment =
  "C++ Interface:\n"
  "get_supports_render_texture(GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GraphicsOutput can render directly into a\n"
  " * texture, or false if it must always copy-to-texture at the end of each\n"
  " * frame to achieve this effect.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_supports_render_texture_612_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool GraphicsOutput::flip_ready(void) const
 */
static PyObject *Dtool_GraphicsOutput_flip_ready_614(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsOutput)) {
    return nullptr;
  }
  // 1-virtual bool GraphicsOutput::flip_ready(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).flip_ready)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_flip_ready_614_comment =
  "C++ Interface:\n"
  "flip_ready(GraphicsOutput self)\n"
  "\n"
  "// These are not intended to be called directly by the user, but they're\n"
  "// published anyway since they might occasionally be useful for low-level\n"
  "// debugging.\n"
  "\n"
  "/**\n"
  " * Returns true if a frame has been rendered and needs to be flipped, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_flip_ready_614_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual GraphicsOutput *GraphicsOutput::get_host(void)
 */
static PyObject *Dtool_GraphicsOutput_get_host_615(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.get_host")) {
    return nullptr;
  }
  // 1-virtual GraphicsOutput *GraphicsOutput::get_host(void)
  GraphicsOutput *return_value = ((*local_this).get_host)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutput, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_host_615_comment =
  "C++ Interface:\n"
  "get_host(const GraphicsOutput self)\n"
  "\n"
  "/**\n"
  " * This is normally called only from within make_texture_buffer().  When\n"
  " * called on a ParasiteBuffer, it returns the host of that buffer; but when\n"
  " * called on some other buffer, it returns the buffer itself.\n"
  " */";
#else
static const char *Dtool_GraphicsOutput_get_host_615_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GraphicsOutput::get_class_type(void)
 */
static PyObject *Dtool_GraphicsOutput_get_class_type_616(PyObject *, PyObject *) {
  // 1-static TypeHandle GraphicsOutput::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GraphicsOutput::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_get_class_type_616_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GraphicsOutput_get_class_type_616_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GraphicsOutputBase *GraphicsOutput::upcast_to_GraphicsOutputBase(void)
 */
static PyObject *Dtool_GraphicsOutput_upcast_to_GraphicsOutputBase_268(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.upcast_to_GraphicsOutputBase")) {
    return nullptr;
  }
  // 1-GraphicsOutputBase *GraphicsOutput::upcast_to_GraphicsOutputBase(void)
  GraphicsOutputBase *return_value = (GraphicsOutputBase *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutputBase, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_upcast_to_GraphicsOutputBase_268_comment =
  "C++ Interface:\n"
  "upcast_to_GraphicsOutputBase(const GraphicsOutput self)\n"
  "\n"
  "upcast from GraphicsOutput to GraphicsOutputBase";
#else
static const char *Dtool_GraphicsOutput_upcast_to_GraphicsOutputBase_268_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DrawableRegion *GraphicsOutput::upcast_to_DrawableRegion(void)
 */
static PyObject *Dtool_GraphicsOutput_upcast_to_DrawableRegion_270(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.upcast_to_DrawableRegion")) {
    return nullptr;
  }
  // 1-DrawableRegion *GraphicsOutput::upcast_to_DrawableRegion(void)
  DrawableRegion *return_value = (DrawableRegion *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DrawableRegion, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsOutput_upcast_to_DrawableRegion_270_comment =
  "C++ Interface:\n"
  "upcast_to_DrawableRegion(const GraphicsOutput self)\n"
  "\n"
  "upcast from GraphicsOutput to DrawableRegion";
#else
static const char *Dtool_GraphicsOutput_upcast_to_DrawableRegion_270_comment = nullptr;
#endif

static PyObject *Dtool_GraphicsOutput_gsg_Getter(PyObject *self, void *) {
  const GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GraphicsStateGuardian *GraphicsOutput::get_gsg(void) const
  GraphicsStateGuardian *return_value = ((*(const GraphicsOutput*)local_this).get_gsg)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsStateGuardian, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_GraphicsOutput_pipe_Getter(PyObject *self, void *) {
  const GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GraphicsPipe *GraphicsOutput::get_pipe(void) const
  GraphicsPipe *return_value = ((*(const GraphicsOutput*)local_this).get_pipe)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsPipe, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_GraphicsOutput_engine_Getter(PyObject *self, void *) {
  const GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GraphicsEngine *GraphicsOutput::get_engine(void) const
  GraphicsEngine *return_value = ((*(const GraphicsOutput*)local_this).get_engine)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GraphicsEngine, true, false);
}

static PyObject *Dtool_GraphicsOutput_name_Getter(PyObject *self, void *) {
  const GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &GraphicsOutput::get_name(void) const
  std::string const &return_value = ((*(const GraphicsOutput*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsOutput_size_Getter(PyObject *self, void *) {
  const GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase2i const &GraphicsOutput::get_size(void) const
  LVecBase2i const *return_value = &(((*(const GraphicsOutput*)local_this).get_size)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
}

static PyObject *Dtool_GraphicsOutput_fb_size_Getter(PyObject *self, void *) {
  const GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase2i GraphicsOutput::get_fb_size(void) const
  LVecBase2i *return_value = new LVecBase2i(((*(const GraphicsOutput*)local_this).get_fb_size)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

static PyObject *Dtool_GraphicsOutput_sbs_left_size_Getter(PyObject *self, void *) {
  const GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase2i GraphicsOutput::get_sbs_left_size(void) const
  LVecBase2i *return_value = new LVecBase2i(((*(const GraphicsOutput*)local_this).get_sbs_left_size)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

static PyObject *Dtool_GraphicsOutput_sbs_right_size_Getter(PyObject *self, void *) {
  const GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase2i GraphicsOutput::get_sbs_right_size(void) const
  LVecBase2i *return_value = new LVecBase2i(((*(const GraphicsOutput*)local_this).get_sbs_right_size)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, true, false);
}

static PyObject *Dtool_GraphicsOutput_active_Getter(PyObject *self, void *) {
  const GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual bool GraphicsOutput::is_active(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).is_active)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GraphicsOutput_active_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.active")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete active attribute");
    return -1;
  }
  // 1-void GraphicsOutput::set_active(bool active)
  ((*local_this).set_active)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_active(const GraphicsOutput self, bool active)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsOutput_one_shot_Getter(PyObject *self, void *) {
  const GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }

  // 1-bool GraphicsOutput::get_one_shot(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).get_one_shot)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GraphicsOutput_one_shot_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.one_shot")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete one_shot attribute");
    return -1;
  }
  // 1-void GraphicsOutput::set_one_shot(bool one_shot)
  ((*local_this).set_one_shot)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_one_shot(const GraphicsOutput self, bool one_shot)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsOutput_inverted_Getter(PyObject *self, void *) {
  const GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsOutput::get_inverted(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).get_inverted)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GraphicsOutput_inverted_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.inverted")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete inverted attribute");
    return -1;
  }
  // 1-void GraphicsOutput::set_inverted(bool inverted)
  ((*local_this).set_inverted)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_inverted(const GraphicsOutput self, bool inverted)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsOutput_swap_eyes_Getter(PyObject *self, void *) {
  const GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsOutput::get_swap_eyes(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).get_swap_eyes)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GraphicsOutput_swap_eyes_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.swap_eyes")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete swap_eyes attribute");
    return -1;
  }
  // 1-inline void GraphicsOutput::set_swap_eyes(bool swap_eyes)
  ((*local_this).set_swap_eyes)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_swap_eyes(const GraphicsOutput self, bool swap_eyes)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsOutput_sort_Getter(PyObject *self, void *) {
  const GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GraphicsOutput::get_sort(void) const
  int return_value = ((*(const GraphicsOutput*)local_this).get_sort)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GraphicsOutput_sort_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.sort")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete sort attribute");
    return -1;
  }
  // 1-virtual void GraphicsOutput::set_sort(int sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_sort)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_sort(const GraphicsOutput self, int sort)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsOutput_child_sort_Getter(PyObject *self, void *) {
  const GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GraphicsOutput::get_child_sort(void) const
  int return_value = ((*(const GraphicsOutput*)local_this).get_child_sort)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GraphicsOutput_child_sort_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsOutput, (void **)&local_this, "GraphicsOutput.child_sort")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete child_sort attribute");
    return -1;
  }
  // 1-inline void GraphicsOutput::set_child_sort(int child_sort)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_child_sort)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_child_sort(const GraphicsOutput self, int child_sort)\n");
  }
  return -1;
}

/**
 * sequence length function for property GraphicsOutput::display_regions
 */
static Py_ssize_t Dtool_GraphicsOutput_display_regions_Len(PyObject *self) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_display_regions)();
}

/**
 * sequence getter for property GraphicsOutput::display_regions
 */
static PyObject *Dtool_GraphicsOutput_display_regions_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_display_regions)()) {
    PyErr_SetString(PyExc_IndexError, "GraphicsOutput.display_regions[] index out of range");
    return nullptr;
  }
  // 1-PointerTo< DisplayRegion > GraphicsOutput::get_display_region(int n) const
  PointerTo< DisplayRegion > return_value = ((*(const GraphicsOutput*)local_this).get_display_region)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  DisplayRegion *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_DisplayRegion, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_display_region(GraphicsOutput self, index)\n");
  }
}

static PyObject *Dtool_GraphicsOutput_display_regions_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "GraphicsOutput.display_regions");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_GraphicsOutput_display_regions_Len;
    wrap->_getitem_func = &Dtool_GraphicsOutput_display_regions_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property GraphicsOutput::active_display_regions
 */
static Py_ssize_t Dtool_GraphicsOutput_active_display_regions_Len(PyObject *self) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_active_display_regions)();
}

/**
 * sequence getter for property GraphicsOutput::active_display_regions
 */
static PyObject *Dtool_GraphicsOutput_active_display_regions_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_active_display_regions)()) {
    PyErr_SetString(PyExc_IndexError, "GraphicsOutput.active_display_regions[] index out of range");
    return nullptr;
  }
  // 1-PointerTo< DisplayRegion > GraphicsOutput::get_active_display_region(int n) const
  PointerTo< DisplayRegion > return_value = ((*(const GraphicsOutput*)local_this).get_active_display_region)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  DisplayRegion *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_DisplayRegion, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_active_display_region(GraphicsOutput self, index)\n");
  }
}

static PyObject *Dtool_GraphicsOutput_active_display_regions_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "GraphicsOutput.active_display_regions");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_GraphicsOutput_active_display_regions_Len;
    wrap->_getitem_func = &Dtool_GraphicsOutput_active_display_regions_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_GraphicsOutput_supports_render_texture_Getter(PyObject *self, void *) {
  const GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual bool GraphicsOutput::get_supports_render_texture(void) const
  bool return_value = ((*(const GraphicsOutput*)local_this).get_supports_render_texture)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_GraphicsOutput(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GraphicsOutput_get_display_regions(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_display_regions)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GraphicsOutput_get_display_region_595(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GraphicsOutput_get_active_display_regions(PyObject *self, PyObject *) {
  GraphicsOutput *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsOutput, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_active_display_regions)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GraphicsOutput_get_active_display_region_600(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_GraphicsOutput(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GraphicsOutput) {
    printf("GraphicsOutput ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GraphicsOutput *local_this = (GraphicsOutput *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GraphicsOutput) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DrawableRegion) {
    return (DrawableRegion *) local_this;
  }
  if (requested_type == Dtool_Ptr_GraphicsOutputBase) {
    return (GraphicsOutputBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(GraphicsOutputBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(GraphicsOutputBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(GraphicsOutputBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(GraphicsOutputBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GraphicsOutput(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GraphicsOutput) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DrawableRegion) {
    DrawableRegion* other_this = (DrawableRegion*)from_this;
    return (GraphicsOutput*)other_this;
  }
  if (from_type == Dtool_Ptr_GraphicsOutputBase) {
    GraphicsOutputBase* other_this = (GraphicsOutputBase*)from_this;
    return (GraphicsOutput*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GraphicsOutput*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GraphicsOutput*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GraphicsOutput*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GraphicsOutput*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GraphicsStateGuardian
 */
/**
 * Python function wrapper for:
 * inline void GraphicsStateGuardian::release_all(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_release_all_284(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.release_all")) {
    return nullptr;
  }
  // 1-inline void GraphicsStateGuardian::release_all(void)
  ((*local_this).release_all)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_release_all_284_comment =
  "C++ Interface:\n"
  "release_all(const GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Releases all prepared objects.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_release_all_284_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsStateGuardian::release_all_textures(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_release_all_textures_285(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.release_all_textures")) {
    return nullptr;
  }
  // 1-inline int GraphicsStateGuardian::release_all_textures(void)
  int return_value = ((*local_this).release_all_textures)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_release_all_textures_285_comment =
  "C++ Interface:\n"
  "release_all_textures(const GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Frees the resources for all textures associated with this GSG.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_release_all_textures_285_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsStateGuardian::release_all_samplers(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_release_all_samplers_286(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.release_all_samplers")) {
    return nullptr;
  }
  // 1-inline int GraphicsStateGuardian::release_all_samplers(void)
  int return_value = ((*local_this).release_all_samplers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_release_all_samplers_286_comment =
  "C++ Interface:\n"
  "release_all_samplers(const GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Frees the resources for all samplers associated with this GSG.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_release_all_samplers_286_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsStateGuardian::release_all_geoms(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_release_all_geoms_287(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.release_all_geoms")) {
    return nullptr;
  }
  // 1-inline int GraphicsStateGuardian::release_all_geoms(void)
  int return_value = ((*local_this).release_all_geoms)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_release_all_geoms_287_comment =
  "C++ Interface:\n"
  "release_all_geoms(const GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Frees the resources for all geoms associated with this GSG.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_release_all_geoms_287_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsStateGuardian::release_all_vertex_buffers(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_release_all_vertex_buffers_288(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.release_all_vertex_buffers")) {
    return nullptr;
  }
  // 1-inline int GraphicsStateGuardian::release_all_vertex_buffers(void)
  int return_value = ((*local_this).release_all_vertex_buffers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_release_all_vertex_buffers_288_comment =
  "C++ Interface:\n"
  "release_all_vertex_buffers(const GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Frees the resources for all vertex buffers associated with this GSG.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_release_all_vertex_buffers_288_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsStateGuardian::release_all_index_buffers(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_release_all_index_buffers_289(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.release_all_index_buffers")) {
    return nullptr;
  }
  // 1-inline int GraphicsStateGuardian::release_all_index_buffers(void)
  int return_value = ((*local_this).release_all_index_buffers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_release_all_index_buffers_289_comment =
  "C++ Interface:\n"
  "release_all_index_buffers(const GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Frees the resources for all index buffers associated with this GSG.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_release_all_index_buffers_289_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsStateGuardian::release_all_shader_buffers(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_release_all_shader_buffers_290(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.release_all_shader_buffers")) {
    return nullptr;
  }
  // 1-inline int GraphicsStateGuardian::release_all_shader_buffers(void)
  int return_value = ((*local_this).release_all_shader_buffers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_release_all_shader_buffers_290_comment =
  "C++ Interface:\n"
  "release_all_shader_buffers(const GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Frees the resources for all index buffers associated with this GSG.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_release_all_shader_buffers_290_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsStateGuardian::set_active(bool active)
 */
static PyObject *Dtool_GraphicsStateGuardian_set_active_291(PyObject *self, PyObject *arg) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.set_active")) {
    return nullptr;
  }
  // 1-inline void GraphicsStateGuardian::set_active(bool active)
  ((*local_this).set_active)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active(const GraphicsStateGuardian self, bool active)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_set_active_291_comment =
  "C++ Interface:\n"
  "set_active(const GraphicsStateGuardian self, bool active)\n"
  "\n"
  "/**\n"
  " * Sets the active flag associated with the GraphicsStateGuardian.  If the\n"
  " * GraphicsStateGuardian is marked inactive, nothing is rendered.  This is not\n"
  " * normally turned off unless there is a problem with the rendering detected\n"
  " * at a low level.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_set_active_291_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::is_active(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_is_active_292(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::is_active(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).is_active)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_is_active_292_comment =
  "C++ Interface:\n"
  "is_active(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns the active flag associated with the GraphicsStateGuardian.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_is_active_292_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::is_valid(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_is_valid_293(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::is_valid(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_is_valid_293_comment =
  "C++ Interface:\n"
  "is_valid(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if the GSG has been correctly initialized within a graphics\n"
  " * context, false if there has been some problem or it hasn't been initialized\n"
  " * yet.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_is_valid_293_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::needs_reset(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_needs_reset_294(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::needs_reset(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).needs_reset)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_needs_reset_294_comment =
  "C++ Interface:\n"
  "needs_reset(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if the gsg is marked as needing a reset.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_needs_reset_294_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsStateGuardian::set_incomplete_render(bool incomplete_render)
 */
static PyObject *Dtool_GraphicsStateGuardian_set_incomplete_render_297(PyObject *self, PyObject *arg) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.set_incomplete_render")) {
    return nullptr;
  }
  // 1-inline void GraphicsStateGuardian::set_incomplete_render(bool incomplete_render)
  ((*local_this).set_incomplete_render)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_incomplete_render(const GraphicsStateGuardian self, bool incomplete_render)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_set_incomplete_render_297_comment =
  "C++ Interface:\n"
  "set_incomplete_render(const GraphicsStateGuardian self, bool incomplete_render)\n"
  "\n"
  "/**\n"
  " * Sets the incomplete_render flag.  When this is true, the frame will be\n"
  " * rendered even if some of the geometry or textures in the scene are not\n"
  " * available (e.g.  they have been temporarily paged out).  When this is\n"
  " * false, the frame will be held up while this data is reloaded.\n"
  " *\n"
  " * Setting this true allows for a smoother frame rate, but occasionally parts\n"
  " * of the frame will be invisible or missing (they will generally come in\n"
  " * within a second or two).  Setting this false guarantees that every frame\n"
  " * will be complete, but may cause more chugs as things are loaded up at\n"
  " * runtime.\n"
  " *\n"
  " * You may want to set this false during loading screens, to guarantee that\n"
  " * all of your assets are available by the time you take the loading screen\n"
  " * down.\n"
  " *\n"
  " * This flag may also be set individually on each DisplayRegion.  It will be\n"
  " * considered true for a given DisplayRegion only if it is true on both the\n"
  " * GSG and on the DisplayRegion.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_set_incomplete_render_297_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsStateGuardian::set_loader(Loader *loader)
 */
static PyObject *Dtool_GraphicsStateGuardian_set_loader_302(PyObject *self, PyObject *arg) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.set_loader")) {
    return nullptr;
  }
  // 1-inline void GraphicsStateGuardian::set_loader(Loader *loader)
  Loader *arg_this = (Loader *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Loader, 1, "GraphicsStateGuardian.set_loader", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_loader)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_loader(const GraphicsStateGuardian self, Loader loader)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_set_loader_302_comment =
  "C++ Interface:\n"
  "set_loader(const GraphicsStateGuardian self, Loader loader)\n"
  "\n"
  "/**\n"
  " * Sets the Loader object that will be used by this GSG to load textures when\n"
  " * necessary, if get_incomplete_render() is true.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_set_loader_302_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Loader *GraphicsStateGuardian::get_loader(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_loader_303(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline Loader *GraphicsStateGuardian::get_loader(void) const
  Loader *return_value = ((*(const GraphicsStateGuardian*)local_this).get_loader)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Loader, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_loader_303_comment =
  "C++ Interface:\n"
  "get_loader(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns the Loader object that will be used by this GSG to load textures\n"
  " * when necessary, if get_incomplete_render() is true.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_loader_303_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsStateGuardian::set_shader_generator(ShaderGenerator *shader_generator)
 */
static PyObject *Dtool_GraphicsStateGuardian_set_shader_generator_307(PyObject *self, PyObject *arg) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.set_shader_generator")) {
    return nullptr;
  }
  // 1-inline void GraphicsStateGuardian::set_shader_generator(ShaderGenerator *shader_generator)
  PT(ShaderGenerator) arg_this;
  if (!Dtool_Coerce_ShaderGenerator(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GraphicsStateGuardian.set_shader_generator", "ShaderGenerator");
  }
  ((*local_this).set_shader_generator)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shader_generator(const GraphicsStateGuardian self, ShaderGenerator shader_generator)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_set_shader_generator_307_comment =
  "C++ Interface:\n"
  "set_shader_generator(const GraphicsStateGuardian self, ShaderGenerator shader_generator)\n"
  "\n"
  "/**\n"
  " * Sets the ShaderGenerator object that will be used by this GSG to generate\n"
  " * shaders when necessary.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_set_shader_generator_307_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ShaderGenerator *GraphicsStateGuardian::get_shader_generator(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_shader_generator_308(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline ShaderGenerator *GraphicsStateGuardian::get_shader_generator(void) const
  ShaderGenerator *return_value = ((*(const GraphicsStateGuardian*)local_this).get_shader_generator)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ShaderGenerator, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_shader_generator_308_comment =
  "C++ Interface:\n"
  "get_shader_generator(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns the ShaderGenerator object that will be used by this GSG to\n"
  " * generate shaders when necessary.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_shader_generator_308_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsPipe *GraphicsStateGuardian::get_pipe(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_pipe_312(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline GraphicsPipe *GraphicsStateGuardian::get_pipe(void) const
  GraphicsPipe *return_value = ((*(const GraphicsStateGuardian*)local_this).get_pipe)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsPipe, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_pipe_312_comment =
  "C++ Interface:\n"
  "get_pipe(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns the graphics pipe on which this GSG was created.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_pipe_312_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GraphicsEngine *GraphicsStateGuardian::get_engine(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_engine_313(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-GraphicsEngine *GraphicsStateGuardian::get_engine(void) const
  GraphicsEngine *return_value = ((*(const GraphicsStateGuardian*)local_this).get_engine)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GraphicsEngine, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_engine_313_comment =
  "C++ Interface:\n"
  "get_engine(GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_get_engine_313_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsThreadingModel const &GraphicsStateGuardian::get_threading_model(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_threading_model_314(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline GraphicsThreadingModel const &GraphicsStateGuardian::get_threading_model(void) const
  GraphicsThreadingModel const *return_value = &(((*(const GraphicsStateGuardian*)local_this).get_threading_model)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GraphicsThreadingModel, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_threading_model_314_comment =
  "C++ Interface:\n"
  "get_threading_model(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns the threading model that was used to create this GSG.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_threading_model_314_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::is_hardware(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_is_hardware_317(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::is_hardware(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).is_hardware)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_is_hardware_317_comment =
  "C++ Interface:\n"
  "is_hardware(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this GSG appears to be hardware-accelerated, or false if it\n"
  " * is known to be software only.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_is_hardware_317_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsStateGuardian::get_max_texture_stages(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_max_texture_stages_318(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline int GraphicsStateGuardian::get_max_texture_stages(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_texture_stages)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_max_texture_stages_318_comment =
  "C++ Interface:\n"
  "get_max_texture_stages(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum number of simultaneous textures that may be applied to\n"
  " * geometry with multitexturing, as supported by this particular GSG.  If you\n"
  " * exceed this number, the lowest-priority texture stages will not be applied.\n"
  " * Use TextureStage::set_priority() to adjust the relative importance of the\n"
  " * different texture stages.\n"
  " *\n"
  " * The value returned may not be meaningful until after the graphics context\n"
  " * has been fully created (e.g.  the window has been opened).\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_max_texture_stages_318_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsStateGuardian::get_max_3d_texture_dimension(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_max_3d_texture_dimension_319(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline int GraphicsStateGuardian::get_max_3d_texture_dimension(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_3d_texture_dimension)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_max_3d_texture_dimension_319_comment =
  "C++ Interface:\n"
  "get_max_3d_texture_dimension(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns the largest possible texture size in any one dimension for a 3-d\n"
  " * texture, or -1 if there is no particular limit.  Returns 0 if 3-d textures\n"
  " * are not supported.\n"
  " *\n"
  " * The value returned may not be meaningful until after the graphics context\n"
  " * has been fully created (e.g.  the window has been opened).\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_max_3d_texture_dimension_319_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsStateGuardian::get_max_2d_texture_array_layers(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_max_2d_texture_array_layers_320(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline int GraphicsStateGuardian::get_max_2d_texture_array_layers(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_2d_texture_array_layers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_max_2d_texture_array_layers_320_comment =
  "C++ Interface:\n"
  "get_max_2d_texture_array_layers(GraphicsStateGuardian self)\n"
  "\n"
  "//z axis\n"
  "\n"
  "//z axis\n"
  "\n"
  "/**\n"
  " * Returns the largest possible number of pages, or -1 if there is no\n"
  " * particular limit.  Returns 0 if 2-d texture arrays not supported.\n"
  " *\n"
  " * The value returned may not be meaningful until after the graphics context\n"
  " * has been fully created (e.g.  the window has been opened).\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_max_2d_texture_array_layers_320_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsStateGuardian::get_max_cube_map_dimension(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_max_cube_map_dimension_321(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline int GraphicsStateGuardian::get_max_cube_map_dimension(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_cube_map_dimension)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_max_cube_map_dimension_321_comment =
  "C++ Interface:\n"
  "get_max_cube_map_dimension(GraphicsStateGuardian self)\n"
  "\n"
  "//z axis\n"
  "\n"
  "//z axis\n"
  "\n"
  "/**\n"
  " * Returns the largest possible texture size in any one dimension for a cube\n"
  " * map texture, or -1 if there is no particular limit.  Returns 0 if cube map\n"
  " * textures are not supported.\n"
  " *\n"
  " * The value returned may not be meaningful until after the graphics context\n"
  " * has been fully created (e.g.  the window has been opened).\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_max_cube_map_dimension_321_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsStateGuardian::get_max_buffer_texture_size(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_max_buffer_texture_size_322(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline int GraphicsStateGuardian::get_max_buffer_texture_size(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_buffer_texture_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_max_buffer_texture_size_322_comment =
  "C++ Interface:\n"
  "get_max_buffer_texture_size(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns the largest possible buffer texture size, or -1 if there is no\n"
  " * particular limit.  Returns 0 if cube map textures are not supported.\n"
  " *\n"
  " * The value returned may not be meaningful until after the graphics context\n"
  " * has been fully created (e.g.  the window has been opened).\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_max_buffer_texture_size_322_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_texture_combine(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_texture_combine_323(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_texture_combine(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_texture_combine)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_texture_combine_323_comment =
  "C++ Interface:\n"
  "get_supports_texture_combine(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG can use the TextureStage::M_combine\n"
  " * mode, which includes all of the texture blend modes specified by\n"
  " * set_combine_rgb() and/or set_combine_alpha().  If this is false, you must\n"
  " * limit yourself to using the simpler blend modes.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_texture_combine_323_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_texture_saved_result(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_texture_saved_result_324(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_texture_saved_result(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_texture_saved_result)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_texture_saved_result_324_comment =
  "C++ Interface:\n"
  "get_supports_texture_saved_result(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this GSG can use the TextureStage::CS_last_saved_result\n"
  " * source, which allows you to save the result of a TextureStage and re-use it\n"
  " * for multiple inputs.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_texture_saved_result_324_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_texture_dot3(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_texture_dot3_325(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_texture_dot3(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_texture_dot3)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_texture_dot3_325_comment =
  "C++ Interface:\n"
  "get_supports_texture_dot3(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this GSG can use the TextureStage::CM_dot3_rgb or\n"
  " * CM_dot3_rgba combine modes.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_texture_dot3_325_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_3d_texture(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_3d_texture_326(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_3d_texture(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_3d_texture)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_3d_texture_326_comment =
  "C++ Interface:\n"
  "get_supports_3d_texture(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this GSG can render 3-d (volumetric) textures.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_3d_texture_326_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_2d_texture_array(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_2d_texture_array_327(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_2d_texture_array(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_2d_texture_array)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_2d_texture_array_327_comment =
  "C++ Interface:\n"
  "get_supports_2d_texture_array(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this GSG can render 2-d textures array.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_2d_texture_array_327_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_cube_map(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_cube_map_328(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_cube_map(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_cube_map)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_cube_map_328_comment =
  "C++ Interface:\n"
  "get_supports_cube_map(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this GSG can render cube map textures.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_cube_map_328_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_buffer_texture(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_buffer_texture_329(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_buffer_texture(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_buffer_texture)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_buffer_texture_329_comment =
  "C++ Interface:\n"
  "get_supports_buffer_texture(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this GSG can render buffer textures.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_buffer_texture_329_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_cube_map_array(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_cube_map_array_330(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_cube_map_array(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_cube_map_array)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_cube_map_array_330_comment =
  "C++ Interface:\n"
  "get_supports_cube_map_array(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this GSG can render cube map arrays.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_cube_map_array_330_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_tex_non_pow2(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_tex_non_pow2_331(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_tex_non_pow2(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_tex_non_pow2)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_tex_non_pow2_331_comment =
  "C++ Interface:\n"
  "get_supports_tex_non_pow2(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this GSG can handle non power of two sized textures.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_tex_non_pow2_331_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_compressed_texture(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_compressed_texture_332(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_compressed_texture(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_compressed_texture)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_compressed_texture_332_comment =
  "C++ Interface:\n"
  "get_supports_compressed_texture(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this GSG can compress textures as it loads them into\n"
  " * texture memory, and/or accept pre-compressed textures for storing.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_compressed_texture_332_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsStateGuardian::get_max_lights(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_max_lights_333(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline int GraphicsStateGuardian::get_max_lights(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_lights)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_max_lights_333_comment =
  "C++ Interface:\n"
  "get_max_lights(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum number of simultaneous lights that may be rendered on\n"
  " * geometry, or -1 if there is no particular limit.\n"
  " *\n"
  " * The value returned may not be meaningful until after the graphics context\n"
  " * has been fully created (e.g.  the window has been opened).\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_max_lights_333_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsStateGuardian::get_max_clip_planes(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_max_clip_planes_334(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline int GraphicsStateGuardian::get_max_clip_planes(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_clip_planes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_max_clip_planes_334_comment =
  "C++ Interface:\n"
  "get_max_clip_planes(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum number of simultaneous clip planes that may be applied\n"
  " * to geometry, or -1 if there is no particular limit.\n"
  " *\n"
  " * The value returned may not be meaningful until after the graphics context\n"
  " * has been fully created (e.g.  the window has been opened).\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_max_clip_planes_334_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsStateGuardian::get_max_vertex_transforms(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_max_vertex_transforms_335(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline int GraphicsStateGuardian::get_max_vertex_transforms(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_vertex_transforms)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_max_vertex_transforms_335_comment =
  "C++ Interface:\n"
  "get_max_vertex_transforms(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum number of transform matrices that may be simultaneously\n"
  " * used to transform any one vertex by the graphics hardware.  If this number\n"
  " * is 0, then the hardware (or the graphics backend) doesn't support soft-\n"
  " * skinned vertices (in which case Panda will animate the vertices in\n"
  " * software).\n"
  " *\n"
  " * The value returned may not be meaningful until after the graphics context\n"
  " * has been fully created (e.g.  the window has been opened).\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_max_vertex_transforms_335_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsStateGuardian::get_max_vertex_transform_indices(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_max_vertex_transform_indices_336(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline int GraphicsStateGuardian::get_max_vertex_transform_indices(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_vertex_transform_indices)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_max_vertex_transform_indices_336_comment =
  "C++ Interface:\n"
  "get_max_vertex_transform_indices(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum number of transforms there may be in a single\n"
  " * TransformTable for this graphics hardware.  If this number is 0 (but\n"
  " * get_max_transforms() is nonzero), then the graphics hardware (or API)\n"
  " * doesn't support indexed transforms, but can support direct transform\n"
  " * references.\n"
  " *\n"
  " * The value returned may not be meaningful until after the graphics context\n"
  " * has been fully created (e.g.  the window has been opened).\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_max_vertex_transform_indices_336_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_copy_texture_inverted(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_copy_texture_inverted_337(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_copy_texture_inverted(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_copy_texture_inverted)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_copy_texture_inverted_337_comment =
  "C++ Interface:\n"
  "get_copy_texture_inverted(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG has the property that any framebuffer-\n"
  " * to-texture copy results in a texture that is upside-down and backwards from\n"
  " * Panda's usual convention; that is, it copies into a texture from the bottom\n"
  " * up instead of from the top down.\n"
  " *\n"
  " * If this is true, then on offscreen GraphicsBuffer created for the purposes\n"
  " * of rendering into a texture should be created with the invert flag set\n"
  " * true, to compensate.  Panda will do this automatically if you create an\n"
  " * offscreen buffer using GraphicsOutput::make_texture_buffer().\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_copy_texture_inverted_337_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_generate_mipmap(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_generate_mipmap_338(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_generate_mipmap(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_generate_mipmap)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_generate_mipmap_338_comment =
  "C++ Interface:\n"
  "get_supports_generate_mipmap(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG can generate mipmaps for a texture\n"
  " * automatically, or if they must be generated in software.  If this is true,\n"
  " * then mipmaps can safely be enabled for rendered textures (e.g.  using the\n"
  " * MultitexReducer).\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_generate_mipmap_338_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_depth_texture(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_depth_texture_339(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_depth_texture(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_depth_texture)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_depth_texture_339_comment =
  "C++ Interface:\n"
  "get_supports_depth_texture(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG supports textures whose format is\n"
  " * F_depth_stencil.  This returns true if the GSG supports GL_DEPTH_COMPONENT\n"
  " * textures, which are considered a limited but still valid case of\n"
  " * F_depth_stencil.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_depth_texture_339_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_depth_stencil(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_depth_stencil_340(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_depth_stencil(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_depth_stencil)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_depth_stencil_340_comment =
  "C++ Interface:\n"
  "get_supports_depth_stencil(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG supports textures whose format is\n"
  " * F_depth_stencil.  This only returns true if the GSG supports the full\n"
  " * packed depth-stencil functionality.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_depth_stencil_340_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_luminance_texture(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_luminance_texture_341(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_luminance_texture(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_luminance_texture)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_luminance_texture_341_comment =
  "C++ Interface:\n"
  "get_supports_luminance_texture(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG supports luminance textures.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_luminance_texture_341_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_sampler_objects(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_sampler_objects_342(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_sampler_objects(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_sampler_objects)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_sampler_objects_342_comment =
  "C++ Interface:\n"
  "get_supports_sampler_objects(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG supports the use of sampler objects to\n"
  " * record texture sampling parameters separately from the texture objects.\n"
  " * This doesn't really affect functionality, but if this is false, it may mean\n"
  " * that using the same texture with different SamplerState objects will result\n"
  " * in reduced performance.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_sampler_objects_342_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_basic_shaders(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_basic_shaders_343(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_basic_shaders(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_basic_shaders)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_basic_shaders_343_comment =
  "C++ Interface:\n"
  "get_supports_basic_shaders(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG supports arbfp1+arbvp1 or above.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_basic_shaders_343_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_geometry_shaders(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_geometry_shaders_344(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_geometry_shaders(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_geometry_shaders)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_geometry_shaders_344_comment =
  "C++ Interface:\n"
  "get_supports_geometry_shaders(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG supports geometry shaders.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_geometry_shaders_344_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_tessellation_shaders(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_tessellation_shaders_345(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_tessellation_shaders(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_tessellation_shaders)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_tessellation_shaders_345_comment =
  "C++ Interface:\n"
  "get_supports_tessellation_shaders(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG supports tesselation shaders.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_tessellation_shaders_345_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_compute_shaders(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_compute_shaders_346(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_compute_shaders(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_compute_shaders)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_compute_shaders_346_comment =
  "C++ Interface:\n"
  "get_supports_compute_shaders(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG supports compute shaders.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_compute_shaders_346_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_glsl(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_glsl_347(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_glsl(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_glsl)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_glsl_347_comment =
  "C++ Interface:\n"
  "get_supports_glsl(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG supports GLSL shaders.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_glsl_347_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_stencil(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_stencil_348(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_stencil(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_stencil)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_stencil_348_comment =
  "C++ Interface:\n"
  "get_supports_stencil(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG supports stencil buffers at all.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_stencil_348_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_two_sided_stencil(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_two_sided_stencil_349(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_two_sided_stencil(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_two_sided_stencil)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_two_sided_stencil_349_comment =
  "C++ Interface:\n"
  "get_supports_two_sided_stencil(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG supports two sided stencil: different\n"
  " * stencil settings for the front and back side of the same polygon.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_two_sided_stencil_349_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_geometry_instancing(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_geometry_instancing_350(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_geometry_instancing(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_geometry_instancing)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_geometry_instancing_350_comment =
  "C++ Interface:\n"
  "get_supports_geometry_instancing(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG supports hardware geometry instancing:\n"
  " * the ability to render multiple copies of a model.  In OpenGL, this is done\n"
  " * using the EXT_draw_instanced extension.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_geometry_instancing_350_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_indirect_draw(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_indirect_draw_351(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_indirect_draw(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_indirect_draw)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_indirect_draw_351_comment =
  "C++ Interface:\n"
  "get_supports_indirect_draw(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG supports draw calls for which the\n"
  " * information comes from a buffer.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_indirect_draw_351_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_occlusion_query(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_occlusion_query_352(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_occlusion_query(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_occlusion_query)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_occlusion_query_352_comment =
  "C++ Interface:\n"
  "get_supports_occlusion_query(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this GSG supports an occlusion query.  If this is true,\n"
  " * then begin_occlusion_query() and end_occlusion_query() may be called to\n"
  " * bracket a sequence of draw_triangles() (or whatever) calls to measure\n"
  " * pixels that pass the depth test.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_occlusion_query_352_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_timer_query(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_timer_query_353(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_timer_query(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_timer_query)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_timer_query_353_comment =
  "C++ Interface:\n"
  "get_supports_timer_query(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this GSG supports a timer query.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_timer_query_353_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_timer_queries_active(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_timer_queries_active_354(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_timer_queries_active(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_timer_queries_active)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_timer_queries_active_354_comment =
  "C++ Interface:\n"
  "get_timer_queries_active(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if timer queries are currently enabled on this GSG.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_timer_queries_active_354_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsStateGuardian::get_max_color_targets(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_max_color_targets_355(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline int GraphicsStateGuardian::get_max_color_targets(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_color_targets)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_max_color_targets_355_comment =
  "C++ Interface:\n"
  "get_max_color_targets(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum number of simultaneous color textures that may be\n"
  " * attached for render-to-texture, as supported by this particular GSG.  If\n"
  " * you exceed this number, the lowest-priority render targets will not be\n"
  " * applied.  Use RenderTarget::set_priority() to adjust the relative\n"
  " * importance of the different render targets.\n"
  " *\n"
  " * The value returned may not be meaningful until after the graphics context\n"
  " * has been fully created (e.g.  the window has been opened).\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_max_color_targets_355_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsStateGuardian::get_maximum_simultaneous_render_targets(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_maximum_simultaneous_render_targets_356(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline int GraphicsStateGuardian::get_maximum_simultaneous_render_targets(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_maximum_simultaneous_render_targets)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_maximum_simultaneous_render_targets_356_comment =
  "C++ Interface:\n"
  "get_maximum_simultaneous_render_targets(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Deprecated.  Use get_max_color_targets() instead, which returns the exact\n"
  " * same value.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_maximum_simultaneous_render_targets_356_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_supports_dual_source_blending(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_dual_source_blending_357(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_supports_dual_source_blending(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_dual_source_blending)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_dual_source_blending_357_comment =
  "C++ Interface:\n"
  "get_supports_dual_source_blending(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if dual source (incoming1_color and incoming1_alpha) blend\n"
  " * operands are supported by this GSG.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_dual_source_blending_357_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsStateGuardian::ShaderModel GraphicsStateGuardian::get_shader_model(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_shader_model_411(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline GraphicsStateGuardian::ShaderModel GraphicsStateGuardian::get_shader_model(void) const
  GraphicsStateGuardian::ShaderModel return_value = ((*(const GraphicsStateGuardian*)local_this).get_shader_model)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_shader_model_411_comment =
  "C++ Interface:\n"
  "get_shader_model(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns the ShaderModel\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_shader_model_411_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsStateGuardian::set_shader_model(GraphicsStateGuardian::ShaderModel shader_model)
 */
static PyObject *Dtool_GraphicsStateGuardian_set_shader_model_412(PyObject *self, PyObject *arg) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.set_shader_model")) {
    return nullptr;
  }
  // 1-inline void GraphicsStateGuardian::set_shader_model(GraphicsStateGuardian::ShaderModel shader_model)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_shader_model)((GraphicsStateGuardian::ShaderModel)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_shader_model(const GraphicsStateGuardian self, int shader_model)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_set_shader_model_412_comment =
  "C++ Interface:\n"
  "set_shader_model(const GraphicsStateGuardian self, int shader_model)\n"
  "\n"
  "/**\n"
  " * Sets the ShaderModel.  This will override the auto- detected shader model\n"
  " * during GSG reset.  Useful for testing lower-end shaders.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_set_shader_model_412_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool GraphicsStateGuardian::get_supports_cg_profile(std::string const &name) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_supports_cg_profile_414(PyObject *self, PyObject *arg) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-virtual bool GraphicsStateGuardian::get_supports_cg_profile(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_cg_profile)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_supports_cg_profile(GraphicsStateGuardian self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_supports_cg_profile_414_comment =
  "C++ Interface:\n"
  "get_supports_cg_profile(GraphicsStateGuardian self, str name)\n";
#else
static const char *Dtool_GraphicsStateGuardian_get_supports_cg_profile_414_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_color_scale_via_lighting(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_color_scale_via_lighting_415(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_color_scale_via_lighting(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_color_scale_via_lighting)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_color_scale_via_lighting_415_comment =
  "C++ Interface:\n"
  "get_color_scale_via_lighting(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG can implement (or would prefer to\n"
  " * implement) set color and/or color scale using materials and/or ambient\n"
  " * lights, or false if we need to actually munge the color.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_color_scale_via_lighting_415_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_alpha_scale_via_texture(void) const
 * inline bool GraphicsStateGuardian::get_alpha_scale_via_texture(TextureAttrib const *tex_attrib) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_alpha_scale_via_texture_416(PyObject *self, PyObject *args) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool GraphicsStateGuardian::get_alpha_scale_via_texture(void) const
      bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_alpha_scale_via_texture)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline bool GraphicsStateGuardian::get_alpha_scale_via_texture(TextureAttrib const *tex_attrib) const
      CPT(TextureAttrib) arg_this;
      if (!Dtool_ConstCoerce_TextureAttrib(arg, arg_this)) {
        return Dtool_Raise_ArgTypeError(arg, 1, "GraphicsStateGuardian.get_alpha_scale_via_texture", "TextureAttrib");
      }
      bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_alpha_scale_via_texture)(std::move(arg_this));
      return Dtool_Return_Bool(return_value);
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_alpha_scale_via_texture() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_alpha_scale_via_texture(GraphicsStateGuardian self)\n"
      "get_alpha_scale_via_texture(GraphicsStateGuardian self, const TextureAttrib tex_attrib)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_alpha_scale_via_texture_416_comment =
  "C++ Interface:\n"
  "get_alpha_scale_via_texture(GraphicsStateGuardian self)\n"
  "get_alpha_scale_via_texture(GraphicsStateGuardian self, const TextureAttrib tex_attrib)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG can implement (or would prefer to\n"
  " * implement) an alpha scale via an additional Texture layer, or false if we\n"
  " * need to actually munge the alpha.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This variant of get_alpha_scale_via_texture() answers the question of\n"
  " * whether the GSG can implement an alpha scale via an additional Texture\n"
  " * layer, considering the current TextureAttrib that will be in effect.  This\n"
  " * considers whether there is at least one additional texture slot available\n"
  " * on the GSG.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_alpha_scale_via_texture_416_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsStateGuardian::get_runtime_color_scale(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_runtime_color_scale_417(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline bool GraphicsStateGuardian::get_runtime_color_scale(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_runtime_color_scale)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_runtime_color_scale_417_comment =
  "C++ Interface:\n"
  "get_runtime_color_scale(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns true if this particular GSG can implement (or would prefer to\n"
  " * implement) set color and/or color scale directly, without requiring any\n"
  " * munging of vertices or tricks with lighting.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_runtime_color_scale_417_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline TextureStage *GraphicsStateGuardian::get_alpha_scale_texture_stage(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_get_alpha_scale_texture_stage_418(PyObject *, PyObject *) {
  // 1-static inline TextureStage *GraphicsStateGuardian::get_alpha_scale_texture_stage(void)
  TextureStage *return_value = (GraphicsStateGuardian::get_alpha_scale_texture_stage)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TextureStage, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_alpha_scale_texture_stage_418_comment =
  "C++ Interface:\n"
  "get_alpha_scale_texture_stage()\n"
  "\n"
  "/**\n"
  " * Returns the TextureStage that will be used to apply an alpha scale, if\n"
  " * get_alpha_scale_via_texture() returns true.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_alpha_scale_texture_stage_418_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsStateGuardian::set_coordinate_system(CoordinateSystem cs)
 */
static PyObject *Dtool_GraphicsStateGuardian_set_coordinate_system_419(PyObject *self, PyObject *arg) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.set_coordinate_system")) {
    return nullptr;
  }
  // 1-void GraphicsStateGuardian::set_coordinate_system(CoordinateSystem cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_coordinate_system)((CoordinateSystem)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_coordinate_system(const GraphicsStateGuardian self, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_set_coordinate_system_419_comment =
  "C++ Interface:\n"
  "set_coordinate_system(const GraphicsStateGuardian self, int cs)\n";
#else
static const char *Dtool_GraphicsStateGuardian_set_coordinate_system_419_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem GraphicsStateGuardian::get_coordinate_system(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_coordinate_system_420(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline CoordinateSystem GraphicsStateGuardian::get_coordinate_system(void) const
  CoordinateSystem return_value = ((*(const GraphicsStateGuardian*)local_this).get_coordinate_system)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_coordinate_system_420_comment =
  "C++ Interface:\n"
  "get_coordinate_system(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate system in effect on this particular gsg.  Normally,\n"
  " * this will be the default coordinate system, but it might be set differently\n"
  " * at runtime.\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_coordinate_system_420_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual CoordinateSystem GraphicsStateGuardian::get_internal_coordinate_system(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_internal_coordinate_system_421(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-virtual CoordinateSystem GraphicsStateGuardian::get_internal_coordinate_system(void) const
  CoordinateSystem return_value = ((*(const GraphicsStateGuardian*)local_this).get_internal_coordinate_system)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_internal_coordinate_system_421_comment =
  "C++ Interface:\n"
  "get_internal_coordinate_system(GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_get_internal_coordinate_system_421_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PreparedGraphicsObjects *GraphicsStateGuardian::get_prepared_objects(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_get_prepared_objects_424(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.get_prepared_objects")) {
    return nullptr;
  }
  // 1-virtual PreparedGraphicsObjects *GraphicsStateGuardian::get_prepared_objects(void)
  PreparedGraphicsObjects *return_value = ((*local_this).get_prepared_objects)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PreparedGraphicsObjects, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_prepared_objects_424_comment =
  "C++ Interface:\n"
  "get_prepared_objects(const GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_get_prepared_objects_424_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool GraphicsStateGuardian::set_gamma(PN_stdfloat gamma)
 */
static PyObject *Dtool_GraphicsStateGuardian_set_gamma_428(PyObject *self, PyObject *arg) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.set_gamma")) {
    return nullptr;
  }
  // 1-virtual bool GraphicsStateGuardian::set_gamma(PN_stdfloat gamma)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_gamma)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gamma(const GraphicsStateGuardian self, float gamma)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_set_gamma_428_comment =
  "C++ Interface:\n"
  "set_gamma(const GraphicsStateGuardian self, float gamma)\n";
#else
static const char *Dtool_GraphicsStateGuardian_set_gamma_428_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat GraphicsStateGuardian::get_gamma(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_gamma_429(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-PN_stdfloat GraphicsStateGuardian::get_gamma(void) const
  PN_stdfloat return_value = ((*(const GraphicsStateGuardian*)local_this).get_gamma)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_gamma_429_comment =
  "C++ Interface:\n"
  "get_gamma(GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_get_gamma_429_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void GraphicsStateGuardian::restore_gamma(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_restore_gamma_430(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.restore_gamma")) {
    return nullptr;
  }
  // 1-virtual void GraphicsStateGuardian::restore_gamma(void)
  ((*local_this).restore_gamma)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_restore_gamma_430_comment =
  "C++ Interface:\n"
  "restore_gamma(const GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_restore_gamma_430_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsStateGuardian::set_texture_quality_override(Texture::QualityLevel quality_level)
 */
static PyObject *Dtool_GraphicsStateGuardian_set_texture_quality_override_432(PyObject *self, PyObject *arg) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.set_texture_quality_override")) {
    return nullptr;
  }
  // 1-inline void GraphicsStateGuardian::set_texture_quality_override(Texture::QualityLevel quality_level)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_texture_quality_override)((Texture::QualityLevel)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture_quality_override(const GraphicsStateGuardian self, int quality_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_set_texture_quality_override_432_comment =
  "C++ Interface:\n"
  "set_texture_quality_override(const GraphicsStateGuardian self, int quality_level)\n"
  "\n"
  "/**\n"
  " * Specifies the global quality_level to be imposed for all Textures rendered\n"
  " * by this GSG.  This overrides the value set on individual textures via\n"
  " * Texture::set_quality_level().  Set this to Texture::QL_default in order to\n"
  " * allow the individual texture quality levels to be respected.\n"
  " *\n"
  " * This is mainly useful for the tinydisplay software renderer.  See\n"
  " * Texture::set_quality_level().\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_set_texture_quality_override_432_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture::QualityLevel GraphicsStateGuardian::get_texture_quality_override(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_texture_quality_override_433(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-inline Texture::QualityLevel GraphicsStateGuardian::get_texture_quality_override(void) const
  Texture::QualityLevel return_value = ((*(const GraphicsStateGuardian*)local_this).get_texture_quality_override)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_texture_quality_override_433_comment =
  "C++ Interface:\n"
  "get_texture_quality_override(GraphicsStateGuardian self)\n"
  "\n"
  "/**\n"
  " * Returns the global quality_level override specified by\n"
  " * set_texture_quality_override.\n"
  " *\n"
  " * This is mainly useful for the tinydisplay software renderer.  See\n"
  " * Texture::set_quality_level().\n"
  " */";
#else
static const char *Dtool_GraphicsStateGuardian_get_texture_quality_override_433_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *GraphicsStateGuardian::get_prepared_textures(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_prepared_textures_437(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-PyObject *GraphicsStateGuardian::get_prepared_textures(void) const
  PyObject *return_value = invoke_extension((const GraphicsStateGuardian*)local_this).get_prepared_textures();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_prepared_textures_437_comment =
  "C++ Interface:\n"
  "get_prepared_textures(GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_get_prepared_textures_437_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsStateGuardian::set_flash_texture(Texture *tex)
 */
static PyObject *Dtool_GraphicsStateGuardian_set_flash_texture_439(PyObject *self, PyObject *arg) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.set_flash_texture")) {
    return nullptr;
  }
  // 1-void GraphicsStateGuardian::set_flash_texture(Texture *tex)
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "GraphicsStateGuardian.set_flash_texture", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_flash_texture)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_flash_texture(const GraphicsStateGuardian self, Texture tex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_set_flash_texture_439_comment =
  "C++ Interface:\n"
  "set_flash_texture(const GraphicsStateGuardian self, Texture tex)\n";
#else
static const char *Dtool_GraphicsStateGuardian_set_flash_texture_439_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsStateGuardian::clear_flash_texture(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_clear_flash_texture_440(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.clear_flash_texture")) {
    return nullptr;
  }
  // 1-void GraphicsStateGuardian::clear_flash_texture(void)
  ((*local_this).clear_flash_texture)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_clear_flash_texture_440_comment =
  "C++ Interface:\n"
  "clear_flash_texture(const GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_clear_flash_texture_440_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Texture *GraphicsStateGuardian::get_flash_texture(void) const
 */
static PyObject *Dtool_GraphicsStateGuardian_get_flash_texture_441(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-Texture *GraphicsStateGuardian::get_flash_texture(void) const
  Texture *return_value = ((*(const GraphicsStateGuardian*)local_this).get_flash_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_flash_texture_441_comment =
  "C++ Interface:\n"
  "get_flash_texture(GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_get_flash_texture_441_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool GraphicsStateGuardian::has_extension(std::string const &extension) const
 */
static PyObject *Dtool_GraphicsStateGuardian_has_extension_444(PyObject *self, PyObject *arg) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-virtual bool GraphicsStateGuardian::has_extension(std::string const &extension) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const GraphicsStateGuardian*)local_this).has_extension)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_extension(GraphicsStateGuardian self, str extension)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_has_extension_444_comment =
  "C++ Interface:\n"
  "has_extension(GraphicsStateGuardian self, str extension)\n";
#else
static const char *Dtool_GraphicsStateGuardian_has_extension_444_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::string GraphicsStateGuardian::get_driver_vendor(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_get_driver_vendor_445(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.get_driver_vendor")) {
    return nullptr;
  }
  // 1-virtual std::string GraphicsStateGuardian::get_driver_vendor(void)
  std::string return_value = ((*local_this).get_driver_vendor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_driver_vendor_445_comment =
  "C++ Interface:\n"
  "get_driver_vendor(const GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_get_driver_vendor_445_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::string GraphicsStateGuardian::get_driver_renderer(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_get_driver_renderer_446(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.get_driver_renderer")) {
    return nullptr;
  }
  // 1-virtual std::string GraphicsStateGuardian::get_driver_renderer(void)
  std::string return_value = ((*local_this).get_driver_renderer)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_driver_renderer_446_comment =
  "C++ Interface:\n"
  "get_driver_renderer(const GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_get_driver_renderer_446_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::string GraphicsStateGuardian::get_driver_version(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_get_driver_version_447(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.get_driver_version")) {
    return nullptr;
  }
  // 1-virtual std::string GraphicsStateGuardian::get_driver_version(void)
  std::string return_value = ((*local_this).get_driver_version)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_driver_version_447_comment =
  "C++ Interface:\n"
  "get_driver_version(const GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_get_driver_version_447_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int GraphicsStateGuardian::get_driver_version_major(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_get_driver_version_major_448(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.get_driver_version_major")) {
    return nullptr;
  }
  // 1-virtual int GraphicsStateGuardian::get_driver_version_major(void)
  int return_value = ((*local_this).get_driver_version_major)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_driver_version_major_448_comment =
  "C++ Interface:\n"
  "get_driver_version_major(const GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_get_driver_version_major_448_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int GraphicsStateGuardian::get_driver_version_minor(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_get_driver_version_minor_449(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.get_driver_version_minor")) {
    return nullptr;
  }
  // 1-virtual int GraphicsStateGuardian::get_driver_version_minor(void)
  int return_value = ((*local_this).get_driver_version_minor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_driver_version_minor_449_comment =
  "C++ Interface:\n"
  "get_driver_version_minor(const GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_get_driver_version_minor_449_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int GraphicsStateGuardian::get_driver_shader_version_major(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_get_driver_shader_version_major_450(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.get_driver_shader_version_major")) {
    return nullptr;
  }
  // 1-virtual int GraphicsStateGuardian::get_driver_shader_version_major(void)
  int return_value = ((*local_this).get_driver_shader_version_major)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_driver_shader_version_major_450_comment =
  "C++ Interface:\n"
  "get_driver_shader_version_major(const GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_get_driver_shader_version_major_450_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int GraphicsStateGuardian::get_driver_shader_version_minor(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_get_driver_shader_version_minor_451(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.get_driver_shader_version_minor")) {
    return nullptr;
  }
  // 1-virtual int GraphicsStateGuardian::get_driver_shader_version_minor(void)
  int return_value = ((*local_this).get_driver_shader_version_minor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_driver_shader_version_minor_451_comment =
  "C++ Interface:\n"
  "get_driver_shader_version_minor(const GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_get_driver_shader_version_minor_451_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GraphicsStateGuardian::set_scene(SceneSetup *scene_setup)
 */
static PyObject *Dtool_GraphicsStateGuardian_set_scene_459(PyObject *self, PyObject *arg) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.set_scene")) {
    return nullptr;
  }
  // 1-bool GraphicsStateGuardian::set_scene(SceneSetup *scene_setup)
  SceneSetup *arg_this = (SceneSetup *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SceneSetup, 1, "GraphicsStateGuardian.set_scene", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).set_scene)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scene(const GraphicsStateGuardian self, SceneSetup scene_setup)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_set_scene_459_comment =
  "C++ Interface:\n"
  "set_scene(const GraphicsStateGuardian self, SceneSetup scene_setup)\n";
#else
static const char *Dtool_GraphicsStateGuardian_set_scene_459_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual SceneSetup *GraphicsStateGuardian::get_scene(void) const final
 */
static PyObject *Dtool_GraphicsStateGuardian_get_scene_460(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsStateGuardian)) {
    return nullptr;
  }
  // 1-virtual SceneSetup *GraphicsStateGuardian::get_scene(void) const final
  SceneSetup *return_value = ((*(const GraphicsStateGuardian*)local_this).get_scene)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_SceneSetup, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_scene_460_comment =
  "C++ Interface:\n"
  "get_scene(GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_get_scene_460_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool GraphicsStateGuardian::begin_scene(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_begin_scene_464(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.begin_scene")) {
    return nullptr;
  }
  // 1-virtual bool GraphicsStateGuardian::begin_scene(void)
  bool return_value = ((*local_this).begin_scene)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_begin_scene_464_comment =
  "C++ Interface:\n"
  "begin_scene(const GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_begin_scene_464_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void GraphicsStateGuardian::end_scene(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_end_scene_465(PyObject *self, PyObject *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.end_scene")) {
    return nullptr;
  }
  // 1-virtual void GraphicsStateGuardian::end_scene(void)
  ((*local_this).end_scene)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_end_scene_465_comment =
  "C++ Interface:\n"
  "end_scene(const GraphicsStateGuardian self)\n";
#else
static const char *Dtool_GraphicsStateGuardian_end_scene_465_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GraphicsStateGuardian::get_class_type(void)
 */
static PyObject *Dtool_GraphicsStateGuardian_get_class_type_466(PyObject *, PyObject *) {
  // 1-static TypeHandle GraphicsStateGuardian::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GraphicsStateGuardian::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsStateGuardian_get_class_type_466_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GraphicsStateGuardian_get_class_type_466_comment = nullptr;
#endif

static PyObject *Dtool_GraphicsStateGuardian_active_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::is_active(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).is_active)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GraphicsStateGuardian_active_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.active")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete active attribute");
    return -1;
  }
  // 1-inline void GraphicsStateGuardian::set_active(bool active)
  ((*local_this).set_active)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_active(const GraphicsStateGuardian self, bool active)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsStateGuardian_valid_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::is_valid(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).is_valid)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_incomplete_render_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual inline bool GraphicsStateGuardian::get_incomplete_render(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_incomplete_render)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GraphicsStateGuardian_incomplete_render_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.incomplete_render")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete incomplete_render attribute");
    return -1;
  }
  // 1-inline void GraphicsStateGuardian::set_incomplete_render(bool incomplete_render)
  ((*local_this).set_incomplete_render)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_incomplete_render(const GraphicsStateGuardian self, bool incomplete_render)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsStateGuardian_effective_incomplete_render_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual inline bool GraphicsStateGuardian::get_effective_incomplete_render(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_effective_incomplete_render)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_loader_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Loader *GraphicsStateGuardian::get_loader(void) const
  Loader *return_value = ((*(const GraphicsStateGuardian*)local_this).get_loader)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Loader, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_GraphicsStateGuardian_loader_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.loader")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete loader attribute");
    return -1;
  }
  // 1-inline void GraphicsStateGuardian::set_loader(Loader *loader)
  Loader *arg_this = (Loader *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Loader, 1, "GraphicsStateGuardian.set_loader", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_loader)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_loader(const GraphicsStateGuardian self, Loader loader)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsStateGuardian_shader_generator_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ShaderGenerator *GraphicsStateGuardian::get_shader_generator(void) const
  ShaderGenerator *return_value = ((*(const GraphicsStateGuardian*)local_this).get_shader_generator)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ShaderGenerator, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_GraphicsStateGuardian_shader_generator_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.shader_generator")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete shader_generator attribute");
    return -1;
  }
  // 1-inline void GraphicsStateGuardian::set_shader_generator(ShaderGenerator *shader_generator)
  PT(ShaderGenerator) arg_this;
  if (!Dtool_Coerce_ShaderGenerator(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "GraphicsStateGuardian.set_shader_generator", "ShaderGenerator");
    return -1;
  }
  ((*local_this).set_shader_generator)(std::move(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shader_generator(const GraphicsStateGuardian self, ShaderGenerator shader_generator)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsStateGuardian_pipe_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GraphicsPipe *GraphicsStateGuardian::get_pipe(void) const
  GraphicsPipe *return_value = ((*(const GraphicsStateGuardian*)local_this).get_pipe)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsPipe, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_GraphicsStateGuardian_max_vertices_per_array_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual inline int GraphicsStateGuardian::get_max_vertices_per_array(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_vertices_per_array)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_max_vertices_per_primitive_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual inline int GraphicsStateGuardian::get_max_vertices_per_primitive(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_vertices_per_primitive)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_max_texture_stages_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GraphicsStateGuardian::get_max_texture_stages(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_texture_stages)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_max_texture_dimension_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual inline int GraphicsStateGuardian::get_max_texture_dimension(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_texture_dimension)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_max_3d_texture_dimension_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GraphicsStateGuardian::get_max_3d_texture_dimension(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_3d_texture_dimension)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_max_2d_texture_array_layers_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GraphicsStateGuardian::get_max_2d_texture_array_layers(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_2d_texture_array_layers)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_max_cube_map_dimension_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GraphicsStateGuardian::get_max_cube_map_dimension(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_cube_map_dimension)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_max_buffer_texture_size_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GraphicsStateGuardian::get_max_buffer_texture_size(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_buffer_texture_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_texture_combine_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_texture_combine(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_texture_combine)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_texture_saved_result_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_texture_saved_result(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_texture_saved_result)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_texture_dot3_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_texture_dot3(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_texture_dot3)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_3d_texture_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_3d_texture(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_3d_texture)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_2d_texture_array_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_2d_texture_array(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_2d_texture_array)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_cube_map_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_cube_map(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_cube_map)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_buffer_texture_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_buffer_texture(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_buffer_texture)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_cube_map_array_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_cube_map_array(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_cube_map_array)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_tex_non_pow2_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_tex_non_pow2(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_tex_non_pow2)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_texture_srgb_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual inline bool GraphicsStateGuardian::get_supports_texture_srgb(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_texture_srgb)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_compressed_texture_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_compressed_texture(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_compressed_texture)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_max_lights_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GraphicsStateGuardian::get_max_lights(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_lights)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_max_clip_planes_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GraphicsStateGuardian::get_max_clip_planes(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_clip_planes)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_max_vertex_transforms_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GraphicsStateGuardian::get_max_vertex_transforms(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_vertex_transforms)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_max_vertex_transform_indices_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GraphicsStateGuardian::get_max_vertex_transform_indices(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_vertex_transform_indices)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_copy_texture_inverted_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_copy_texture_inverted(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_copy_texture_inverted)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_multisample_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual bool GraphicsStateGuardian::get_supports_multisample(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_multisample)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_generate_mipmap_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_generate_mipmap(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_generate_mipmap)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_depth_texture_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_depth_texture(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_depth_texture)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_depth_stencil_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_depth_stencil(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_depth_stencil)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_luminance_texture_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_luminance_texture(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_luminance_texture)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_shadow_filter_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual inline bool GraphicsStateGuardian::get_supports_shadow_filter(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_shadow_filter)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_sampler_objects_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_sampler_objects(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_sampler_objects)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_basic_shaders_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_basic_shaders(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_basic_shaders)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_geometry_shaders_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_geometry_shaders(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_geometry_shaders)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_tessellation_shaders_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_tessellation_shaders(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_tessellation_shaders)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_compute_shaders_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_compute_shaders(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_compute_shaders)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_glsl_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_glsl(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_glsl)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_hlsl_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual inline bool GraphicsStateGuardian::get_supports_hlsl(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_hlsl)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_stencil_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_stencil(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_stencil)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_two_sided_stencil_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_two_sided_stencil(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_two_sided_stencil)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_geometry_instancing_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_geometry_instancing(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_geometry_instancing)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_indirect_draw_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_indirect_draw(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_indirect_draw)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_occlusion_query_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_occlusion_query(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_occlusion_query)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_timer_query_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_timer_query(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_timer_query)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_timer_queries_active_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_timer_queries_active(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_timer_queries_active)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_max_color_targets_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int GraphicsStateGuardian::get_max_color_targets(void) const
  int return_value = ((*(const GraphicsStateGuardian*)local_this).get_max_color_targets)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_supports_dual_source_blending_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsStateGuardian::get_supports_dual_source_blending(void) const
  bool return_value = ((*(const GraphicsStateGuardian*)local_this).get_supports_dual_source_blending)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_shader_model_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GraphicsStateGuardian::ShaderModel GraphicsStateGuardian::get_shader_model(void) const
  GraphicsStateGuardian::ShaderModel return_value = ((*(const GraphicsStateGuardian*)local_this).get_shader_model)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GraphicsStateGuardian_shader_model_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.shader_model")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete shader_model attribute");
    return -1;
  }
  // 1-inline void GraphicsStateGuardian::set_shader_model(GraphicsStateGuardian::ShaderModel shader_model)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_shader_model)((GraphicsStateGuardian::ShaderModel)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_shader_model(const GraphicsStateGuardian self, int shader_model)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsStateGuardian_coordinate_system_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CoordinateSystem GraphicsStateGuardian::get_coordinate_system(void) const
  CoordinateSystem return_value = ((*(const GraphicsStateGuardian*)local_this).get_coordinate_system)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GraphicsStateGuardian_coordinate_system_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.coordinate_system")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete coordinate_system attribute");
    return -1;
  }
  // 1-void GraphicsStateGuardian::set_coordinate_system(CoordinateSystem cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_coordinate_system)((CoordinateSystem)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_coordinate_system(const GraphicsStateGuardian self, int cs)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsStateGuardian_prepared_objects_Getter(PyObject *self, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.prepared_objects")) {
    return nullptr;
  }

  // 1-virtual PreparedGraphicsObjects *GraphicsStateGuardian::get_prepared_objects(void)
  PreparedGraphicsObjects *return_value = ((*local_this).get_prepared_objects)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PreparedGraphicsObjects, true, false);
}

static PyObject *Dtool_GraphicsStateGuardian_gamma_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-PN_stdfloat GraphicsStateGuardian::get_gamma(void) const
  PN_stdfloat return_value = ((*(const GraphicsStateGuardian*)local_this).get_gamma)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GraphicsStateGuardian_gamma_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.gamma")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete gamma attribute");
    return -1;
  }
  // 1-virtual bool GraphicsStateGuardian::set_gamma(PN_stdfloat gamma)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).set_gamma)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (return_value) ? 0 : -1;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_gamma(const GraphicsStateGuardian self, float gamma)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsStateGuardian_texture_quality_override_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Texture::QualityLevel GraphicsStateGuardian::get_texture_quality_override(void) const
  Texture::QualityLevel return_value = ((*(const GraphicsStateGuardian*)local_this).get_texture_quality_override)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GraphicsStateGuardian_texture_quality_override_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.texture_quality_override")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete texture_quality_override attribute");
    return -1;
  }
  // 1-inline void GraphicsStateGuardian::set_texture_quality_override(Texture::QualityLevel quality_level)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_texture_quality_override)((Texture::QualityLevel)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_texture_quality_override(const GraphicsStateGuardian self, int quality_level)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsStateGuardian_flash_texture_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-Texture *GraphicsStateGuardian::get_flash_texture(void) const
  Texture *return_value = ((*(const GraphicsStateGuardian*)local_this).get_flash_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_GraphicsStateGuardian_flash_texture_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.flash_texture")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete flash_texture attribute");
    return -1;
  }
  // 1-void GraphicsStateGuardian::set_flash_texture(Texture *tex)
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "GraphicsStateGuardian.set_flash_texture", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_flash_texture)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_flash_texture(const GraphicsStateGuardian self, Texture tex)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsStateGuardian_driver_vendor_Getter(PyObject *self, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.driver_vendor")) {
    return nullptr;
  }

  // 1-virtual std::string GraphicsStateGuardian::get_driver_vendor(void)
  std::string return_value = ((*local_this).get_driver_vendor)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_driver_renderer_Getter(PyObject *self, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.driver_renderer")) {
    return nullptr;
  }

  // 1-virtual std::string GraphicsStateGuardian::get_driver_renderer(void)
  std::string return_value = ((*local_this).get_driver_renderer)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_driver_version_Getter(PyObject *self, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.driver_version")) {
    return nullptr;
  }

  // 1-virtual std::string GraphicsStateGuardian::get_driver_version(void)
  std::string return_value = ((*local_this).get_driver_version)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_driver_version_major_Getter(PyObject *self, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.driver_version_major")) {
    return nullptr;
  }

  // 1-virtual int GraphicsStateGuardian::get_driver_version_major(void)
  int return_value = ((*local_this).get_driver_version_major)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_driver_version_minor_Getter(PyObject *self, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.driver_version_minor")) {
    return nullptr;
  }

  // 1-virtual int GraphicsStateGuardian::get_driver_version_minor(void)
  int return_value = ((*local_this).get_driver_version_minor)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_driver_shader_version_major_Getter(PyObject *self, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.driver_shader_version_major")) {
    return nullptr;
  }

  // 1-virtual int GraphicsStateGuardian::get_driver_shader_version_major(void)
  int return_value = ((*local_this).get_driver_shader_version_major)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_driver_shader_version_minor_Getter(PyObject *self, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.driver_shader_version_minor")) {
    return nullptr;
  }

  // 1-virtual int GraphicsStateGuardian::get_driver_shader_version_minor(void)
  int return_value = ((*local_this).get_driver_shader_version_minor)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsStateGuardian_scene_Getter(PyObject *self, void *) {
  const GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsStateGuardian, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual SceneSetup *GraphicsStateGuardian::get_scene(void) const final
  SceneSetup *return_value = ((*(const GraphicsStateGuardian*)local_this).get_scene)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_SceneSetup, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_GraphicsStateGuardian_scene_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsStateGuardian *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsStateGuardian, (void **)&local_this, "GraphicsStateGuardian.scene")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete scene attribute");
    return -1;
  }
  // 1-bool GraphicsStateGuardian::set_scene(SceneSetup *scene_setup)
  SceneSetup *arg_this = (SceneSetup *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SceneSetup, 1, "GraphicsStateGuardian.set_scene", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).set_scene)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (return_value) ? 0 : -1;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_scene(const GraphicsStateGuardian self, SceneSetup scene_setup)\n");
  }
  return -1;
}

static int Dtool_Init_GraphicsStateGuardian(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_GraphicsStateGuardian(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GraphicsStateGuardian) {
    printf("GraphicsStateGuardian ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GraphicsStateGuardian *local_this = (GraphicsStateGuardian *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GraphicsStateGuardian) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_GraphicsStateGuardianBase) {
    return (GraphicsStateGuardianBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(GraphicsStateGuardianBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(GraphicsStateGuardianBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(GraphicsStateGuardianBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(GraphicsStateGuardianBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GraphicsStateGuardian(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GraphicsStateGuardian) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_GraphicsStateGuardianBase) {
    GraphicsStateGuardianBase* other_this = (GraphicsStateGuardianBase*)from_this;
    return (GraphicsStateGuardian*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GraphicsStateGuardian*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GraphicsStateGuardian*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GraphicsStateGuardian*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GraphicsStateGuardian*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GraphicsEngine
 */
/**
 * Python function wrapper for:
 * void GraphicsEngine::set_threading_model(GraphicsThreadingModel const &threading_model)
 */
static PyObject *Dtool_GraphicsEngine_set_threading_model_473(PyObject *self, PyObject *arg) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.set_threading_model")) {
    return nullptr;
  }
  // 1-void GraphicsEngine::set_threading_model(GraphicsThreadingModel const &threading_model)
  GraphicsThreadingModel arg_local;
  GraphicsThreadingModel const *arg_this = Dtool_Coerce_GraphicsThreadingModel(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GraphicsEngine.set_threading_model", "GraphicsThreadingModel");
  }
  ((*local_this).set_threading_model)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_threading_model(const GraphicsEngine self, const GraphicsThreadingModel threading_model)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_set_threading_model_473_comment =
  "C++ Interface:\n"
  "set_threading_model(const GraphicsEngine self, const GraphicsThreadingModel threading_model)\n"
  "\n"
  "/**\n"
  " * Specifies how future objects created via make_gsg(), make_buffer(), and\n"
  " * make_window() will be threaded.  This does not affect any already-created\n"
  " * objects.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_set_threading_model_473_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GraphicsThreadingModel GraphicsEngine::get_threading_model(void) const
 */
static PyObject *Dtool_GraphicsEngine_get_threading_model_474(PyObject *self, PyObject *) {
  GraphicsEngine *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsEngine)) {
    return nullptr;
  }
  // 1-GraphicsThreadingModel GraphicsEngine::get_threading_model(void) const
  GraphicsThreadingModel *return_value = new GraphicsThreadingModel(((*(const GraphicsEngine*)local_this).get_threading_model)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GraphicsThreadingModel, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_get_threading_model_474_comment =
  "C++ Interface:\n"
  "get_threading_model(GraphicsEngine self)\n"
  "\n"
  "/**\n"
  " * Returns the threading model that will be applied to future objects.  See\n"
  " * set_threading_model().\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_get_threading_model_474_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ReMutex const &GraphicsEngine::get_render_lock(void) const
 */
static PyObject *Dtool_GraphicsEngine_get_render_lock_492(PyObject *self, PyObject *) {
  GraphicsEngine *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsEngine)) {
    return nullptr;
  }
  // 1-inline ReMutex const &GraphicsEngine::get_render_lock(void) const
  ReMutex const *return_value = &(((*(const GraphicsEngine*)local_this).get_render_lock)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReMutex, false, true);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_get_render_lock_492_comment =
  "C++ Interface:\n"
  "get_render_lock(GraphicsEngine self)\n"
  "\n"
  "/**\n"
  " * Returns a ReMutex object that is held by the GraphicsEngine during the\n"
  " * entire call to render_frame().  While you hold this lock you can be\n"
  " * confident that no part of the frame will be rendered (at least by the app\n"
  " * thread).\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_get_render_lock_492_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsEngine::set_auto_flip(bool auto_flip)
 */
static PyObject *Dtool_GraphicsEngine_set_auto_flip_496(PyObject *self, PyObject *arg) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.set_auto_flip")) {
    return nullptr;
  }
  // 1-inline void GraphicsEngine::set_auto_flip(bool auto_flip)
  ((*local_this).set_auto_flip)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_flip(const GraphicsEngine self, bool auto_flip)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_set_auto_flip_496_comment =
  "C++ Interface:\n"
  "set_auto_flip(const GraphicsEngine self, bool auto_flip)\n"
  "\n"
  "/**\n"
  " * Set this flag true to indicate the GraphicsEngine should automatically\n"
  " * cause windows to sync and flip as soon as they have finished drawing,\n"
  " * rather than waiting for all of the windows to finish drawing first so they\n"
  " * can flip together.\n"
  " *\n"
  " * This only affects the timing of when the flip occurs.  If this is true (the\n"
  " * default), the flip occurs before render_frame() returns.  If this is false,\n"
  " * the flip occurs whenever flip_frame() is called, or at the beginning of the\n"
  " * next call to render_frame(), if flip_frame() is never called.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_set_auto_flip_496_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsEngine::get_auto_flip(void) const
 */
static PyObject *Dtool_GraphicsEngine_get_auto_flip_497(PyObject *self, PyObject *) {
  GraphicsEngine *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsEngine)) {
    return nullptr;
  }
  // 1-inline bool GraphicsEngine::get_auto_flip(void) const
  bool return_value = ((*(const GraphicsEngine*)local_this).get_auto_flip)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_get_auto_flip_497_comment =
  "C++ Interface:\n"
  "get_auto_flip(GraphicsEngine self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting for the auto-flip flag.  See set_auto_flip.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_get_auto_flip_497_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsEngine::set_portal_cull(bool value)
 */
static PyObject *Dtool_GraphicsEngine_set_portal_cull_499(PyObject *self, PyObject *arg) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.set_portal_cull")) {
    return nullptr;
  }
  // 1-inline void GraphicsEngine::set_portal_cull(bool value)
  ((*local_this).set_portal_cull)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_portal_cull(const GraphicsEngine self, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_set_portal_cull_499_comment =
  "C++ Interface:\n"
  "set_portal_cull(const GraphicsEngine self, bool value)\n"
  "\n"
  "/**\n"
  " * Set this flag true to indicate the GraphicsEngine should start portal\n"
  " * culling\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_set_portal_cull_499_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsEngine::get_portal_cull(void) const
 */
static PyObject *Dtool_GraphicsEngine_get_portal_cull_500(PyObject *self, PyObject *) {
  GraphicsEngine *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsEngine)) {
    return nullptr;
  }
  // 1-inline bool GraphicsEngine::get_portal_cull(void) const
  bool return_value = ((*(const GraphicsEngine*)local_this).get_portal_cull)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_get_portal_cull_500_comment =
  "C++ Interface:\n"
  "get_portal_cull(GraphicsEngine self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting for the portal culling flag.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_get_portal_cull_500_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsEngine::set_default_loader(Loader *loader)
 */
static PyObject *Dtool_GraphicsEngine_set_default_loader_502(PyObject *self, PyObject *arg) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.set_default_loader")) {
    return nullptr;
  }
  // 1-inline void GraphicsEngine::set_default_loader(Loader *loader)
  Loader *arg_this = (Loader *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Loader, 1, "GraphicsEngine.set_default_loader", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_default_loader)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_default_loader(const GraphicsEngine self, Loader loader)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_set_default_loader_502_comment =
  "C++ Interface:\n"
  "set_default_loader(const GraphicsEngine self, Loader loader)\n"
  "\n"
  "/**\n"
  " * Sets the Loader object that will be assigned to every GSG created with this\n"
  " * GraphicsEngine.  See GraphicsStateGuardian::set_loader().\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_set_default_loader_502_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Loader *GraphicsEngine::get_default_loader(void) const
 */
static PyObject *Dtool_GraphicsEngine_get_default_loader_503(PyObject *self, PyObject *) {
  GraphicsEngine *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsEngine)) {
    return nullptr;
  }
  // 1-inline Loader *GraphicsEngine::get_default_loader(void) const
  Loader *return_value = ((*(const GraphicsEngine*)local_this).get_default_loader)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Loader, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_get_default_loader_503_comment =
  "C++ Interface:\n"
  "get_default_loader(GraphicsEngine self)\n"
  "\n"
  "/**\n"
  " * Returns the Loader object that will be assigned to every GSG created with\n"
  " * this GraphicsEngine.  See GraphicsStateGuardian::set_loader().\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_get_default_loader_503_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GraphicsOutput *GraphicsEngine::make_output(GraphicsPipe *pipe, std::string const &name, int sort, FrameBufferProperties const &fb_prop, WindowProperties const &win_prop, int flags, GraphicsStateGuardian *gsg = nullptr, GraphicsOutput *host = nullptr)
 */
static PyObject *Dtool_GraphicsEngine_make_output_505(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.make_output")) {
    return nullptr;
  }
  // 1-GraphicsOutput *GraphicsEngine::make_output(GraphicsPipe *pipe, std::string const &name, int sort, FrameBufferProperties const &fb_prop, WindowProperties const &win_prop, int flags, GraphicsStateGuardian *gsg = nullptr, GraphicsOutput *host = nullptr)
  PyObject *param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  int param3;
  PyObject *param4;
  PyObject *param5;
  int param6;
  PyObject *param7 = nullptr;
  PyObject *param8 = nullptr;
  static const char *keyword_list[] = {"pipe", "name", "sort", "fb_prop", "win_prop", "flags", "gsg", "host", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#iOOi|OO:make_output", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3, &param4, &param5, &param6, &param7, &param8)) {
    GraphicsPipe *param1_this = (GraphicsPipe *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsPipe, 1, "GraphicsEngine.make_output", false, true);
    FrameBufferProperties const *param4_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_FrameBufferProperties, 4, "GraphicsEngine.make_output", true, true);
    WindowProperties param5_local;
    WindowProperties const *param5_this = Dtool_Coerce_WindowProperties(param5, param5_local);
    if (!(param5_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param5, 5, "GraphicsEngine.make_output", "WindowProperties");
    }
    GraphicsStateGuardian *param7_this = nullptr;
    if (param7 != nullptr && param7 != Py_None) {
      param7_this = (GraphicsStateGuardian *)DTOOL_Call_GetPointerThisClass(param7, Dtool_Ptr_GraphicsStateGuardian, 7, "GraphicsEngine.make_output", false, true);
    }
    GraphicsOutput *param8_this = nullptr;
    if (param8 != nullptr && param8 != Py_None) {
      param8_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param8, Dtool_Ptr_GraphicsOutput, 8, "GraphicsEngine.make_output", false, true);
    }
    if (param1_this != nullptr && param4_this != nullptr && (param7 == nullptr || param7 == Py_None || param7_this != nullptr) && (param8 == nullptr || param8 == Py_None || param8_this != nullptr)) {
      GraphicsOutput *return_value = ((*local_this).make_output)(param1_this, std::string(param2_str, param2_len), (int)param3, *param4_this, *param5_this, (int)param6, param7_this, param8_this);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutput, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_output(const GraphicsEngine self, GraphicsPipe pipe, str name, int sort, const FrameBufferProperties fb_prop, const WindowProperties win_prop, int flags, GraphicsStateGuardian gsg, GraphicsOutput host)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_make_output_505_comment =
  "C++ Interface:\n"
  "make_output(const GraphicsEngine self, GraphicsPipe pipe, str name, int sort, const FrameBufferProperties fb_prop, const WindowProperties win_prop, int flags, GraphicsStateGuardian gsg, GraphicsOutput host)\n";
#else
static const char *Dtool_GraphicsEngine_make_output_505_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsOutput *GraphicsEngine::make_buffer(GraphicsOutput *host, std::string const &name, int sort, int x_size, int y_size)
 * inline GraphicsOutput *GraphicsEngine::make_buffer(GraphicsStateGuardian *gsg, std::string const &name, int sort, int x_size, int y_size)
 */
static PyObject *Dtool_GraphicsEngine_make_buffer_506(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.make_buffer")) {
    return nullptr;
  }
  {
    // -2 inline GraphicsOutput *GraphicsEngine::make_buffer(GraphicsOutput *host, std::string const &name, int sort, int x_size, int y_size)
    PyObject *param1;
    const char *param2_str = nullptr;
    Py_ssize_t param2_len;
    int param3;
    int param4;
    int param5;
    static const char *keyword_list[] = {"host", "name", "sort", "x_size", "y_size", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#iii:make_buffer", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3, &param4, &param5)) {
      GraphicsOutput *param1_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsOutput, 1, "GraphicsEngine.make_buffer", false, false);
      if (param1_this != nullptr) {
        GraphicsOutput *return_value = ((*local_this).make_buffer)(param1_this, std::string(param2_str, param2_len), (int)param3, (int)param4, (int)param5);
        if (return_value != nullptr) {
          return_value->ref();
        }
        if (Dtool_CheckErrorOccurred()) {
          if (return_value != nullptr) {
            unref_delete(return_value);
          }
          return nullptr;
        }
        if (return_value == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutput, true, false, return_value->as_typed_object()->get_type_index());
        }
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline GraphicsOutput *GraphicsEngine::make_buffer(GraphicsStateGuardian *gsg, std::string const &name, int sort, int x_size, int y_size)
    PyObject *param1;
    const char *param2_str = nullptr;
    Py_ssize_t param2_len;
    int param3;
    int param4;
    int param5;
    static const char *keyword_list[] = {"gsg", "name", "sort", "x_size", "y_size", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#iii:make_buffer", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3, &param4, &param5)) {
      GraphicsStateGuardian *param1_this = (GraphicsStateGuardian *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsStateGuardian, 1, "GraphicsEngine.make_buffer", false, false);
      if (param1_this != nullptr) {
        GraphicsOutput *return_value = ((*local_this).make_buffer)(param1_this, std::string(param2_str, param2_len), (int)param3, (int)param4, (int)param5);
        if (return_value != nullptr) {
          return_value->ref();
        }
        if (Dtool_CheckErrorOccurred()) {
          if (return_value != nullptr) {
            unref_delete(return_value);
          }
          return nullptr;
        }
        if (return_value == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutput, true, false, return_value->as_typed_object()->get_type_index());
        }
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: inline GraphicsOutput *GraphicsEngine::make_buffer(GraphicsOutput *host, std::string const &name, int sort, int x_size, int y_size)
  // No coercion possible: inline GraphicsOutput *GraphicsEngine::make_buffer(GraphicsStateGuardian *gsg, std::string const &name, int sort, int x_size, int y_size)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_buffer(const GraphicsEngine self, GraphicsOutput host, str name, int sort, int x_size, int y_size)\n"
      "make_buffer(const GraphicsEngine self, GraphicsStateGuardian gsg, str name, int sort, int x_size, int y_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_make_buffer_506_comment =
  "C++ Interface:\n"
  "make_buffer(const GraphicsEngine self, GraphicsOutput host, str name, int sort, int x_size, int y_size)\n"
  "make_buffer(const GraphicsEngine self, GraphicsStateGuardian gsg, str name, int sort, int x_size, int y_size)\n"
  "\n"
  "// Syntactic shorthand versions of make_output\n"
  "\n"
  "/**\n"
  " * Syntactic shorthand for make_output.  This is the preferred way to create\n"
  " * an offscreen buffer, when you already have an onscreen window or another\n"
  " * buffer to start with.  For the first parameter, pass an existing\n"
  " * GraphicsOutput object, e.g.  the main window; this allows the buffer to\n"
  " * adapt itself to that window's framebuffer properties, and allows maximum\n"
  " * sharing of resources.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Syntactic shorthand for make_output.  This flavor accepts a GSG rather than\n"
  " * a GraphicsOutput as the first parameter, which is too limiting and\n"
  " * disallows the possibility of creating a ParasiteBuffer if the user's\n"
  " * graphics hardware prefers that.  It also attempts to request specific\n"
  " * framebuffer properties and may therefore do a poorer job of sharing the GSG\n"
  " * between the old buffer and the new.\n"
  " *\n"
  " * For these reasons, this variant is a poor choice unless you are creating an\n"
  " * offscreen buffer for the first time, without an onscreen window already in\n"
  " * existence.  If you already have an onscreen window, you should use the\n"
  " * other flavor of make_buffer() instead, which accepts a GraphicsOutput as\n"
  " * the first parameter.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_make_buffer_506_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsOutput *GraphicsEngine::make_parasite(GraphicsOutput *host, std::string const &name, int sort, int x_size, int y_size)
 */
static PyObject *Dtool_GraphicsEngine_make_parasite_507(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.make_parasite")) {
    return nullptr;
  }
  // 1-inline GraphicsOutput *GraphicsEngine::make_parasite(GraphicsOutput *host, std::string const &name, int sort, int x_size, int y_size)
  PyObject *param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  int param3;
  int param4;
  int param5;
  static const char *keyword_list[] = {"host", "name", "sort", "x_size", "y_size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#iii:make_parasite", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3, &param4, &param5)) {
    GraphicsOutput *param1_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsOutput, 1, "GraphicsEngine.make_parasite", false, true);
    if (param1_this != nullptr) {
      GraphicsOutput *return_value = ((*local_this).make_parasite)(param1_this, std::string(param2_str, param2_len), (int)param3, (int)param4, (int)param5);
      if (return_value != nullptr) {
        return_value->ref();
      }
      if (Dtool_CheckErrorOccurred()) {
        if (return_value != nullptr) {
          unref_delete(return_value);
        }
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutput, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_parasite(const GraphicsEngine self, GraphicsOutput host, str name, int sort, int x_size, int y_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_make_parasite_507_comment =
  "C++ Interface:\n"
  "make_parasite(const GraphicsEngine self, GraphicsOutput host, str name, int sort, int x_size, int y_size)\n"
  "\n"
  "/**\n"
  " * Syntactic shorthand for make_buffer.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_make_parasite_507_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GraphicsEngine::add_window(GraphicsOutput *window, int sort)
 */
static PyObject *Dtool_GraphicsEngine_add_window_508(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.add_window")) {
    return nullptr;
  }
  // 1-bool GraphicsEngine::add_window(GraphicsOutput *window, int sort)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"window", "sort", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:add_window", (char **)keyword_list, &param1, &param2)) {
    GraphicsOutput *param1_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsOutput, 1, "GraphicsEngine.add_window", false, true);
    if (param1_this != nullptr) {
      bool return_value = ((*local_this).add_window)(param1_this, (int)param2);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_window(const GraphicsEngine self, GraphicsOutput window, int sort)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_add_window_508_comment =
  "C++ Interface:\n"
  "add_window(const GraphicsEngine self, GraphicsOutput window, int sort)\n"
  "\n"
  "/**\n"
  " * This can be used to add a newly-created GraphicsOutput object (and its GSG)\n"
  " * to the engine's list of windows, and requests that it be opened.  This\n"
  " * shouldn't be called by user code as make_output normally does this under\n"
  " * the hood; it may be useful in esoteric cases in which a custom window\n"
  " * object is used.\n"
  " *\n"
  " * This can be called during the rendering loop, unlike make_output(); the\n"
  " * window will be opened before the next frame begins rendering.  Because it\n"
  " * doesn't call open_windows(), however, it's not guaranteed that the window\n"
  " * will succeed opening even if it returns true.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_add_window_508_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GraphicsEngine::remove_window(GraphicsOutput *window)
 */
static PyObject *Dtool_GraphicsEngine_remove_window_509(PyObject *self, PyObject *arg) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.remove_window")) {
    return nullptr;
  }
  // 1-bool GraphicsEngine::remove_window(GraphicsOutput *window)
  GraphicsOutput *arg_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GraphicsOutput, 1, "GraphicsEngine.remove_window", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).remove_window)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_window(const GraphicsEngine self, GraphicsOutput window)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_remove_window_509_comment =
  "C++ Interface:\n"
  "remove_window(const GraphicsEngine self, GraphicsOutput window)\n"
  "\n"
  "/**\n"
  " * Removes the indicated window or offscreen buffer from the set of windows\n"
  " * that will be processed when render_frame() is called.  This also closes the\n"
  " * window if it is open, and removes the window from its GraphicsPipe,\n"
  " * allowing the window to be destructed if there are no other references to\n"
  " * it.  (However, the window may not be actually closed until next frame, if\n"
  " * it is controlled by a sub-thread.)\n"
  " *\n"
  " * The return value is true if the window was removed, false if it was not\n"
  " * found.\n"
  " *\n"
  " * Unlike remove_all_windows(), this function does not terminate any of the\n"
  " * threads that may have been started to service this window; they are left\n"
  " * running (since you might open a new window later on these threads).  If\n"
  " * your intention is to clean up before shutting down, it is better to call\n"
  " * remove_all_windows() then to call remove_window() one at a time.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_remove_window_509_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsEngine::remove_all_windows(void)
 */
static PyObject *Dtool_GraphicsEngine_remove_all_windows_510(PyObject *self, PyObject *) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.remove_all_windows")) {
    return nullptr;
  }
  // 1-void GraphicsEngine::remove_all_windows(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).remove_all_windows)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_remove_all_windows_510_comment =
  "C++ Interface:\n"
  "remove_all_windows(const GraphicsEngine self)\n"
  "\n"
  "/**\n"
  " * Removes and closes all windows from the engine.  This also cleans up and\n"
  " * terminates any threads that have been started to service those windows.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_remove_all_windows_510_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsEngine::reset_all_windows(bool swapchain)
 */
static PyObject *Dtool_GraphicsEngine_reset_all_windows_511(PyObject *self, PyObject *arg) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.reset_all_windows")) {
    return nullptr;
  }
  // 1-void GraphicsEngine::reset_all_windows(bool swapchain)
  ((*local_this).reset_all_windows)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reset_all_windows(const GraphicsEngine self, bool swapchain)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_reset_all_windows_511_comment =
  "C++ Interface:\n"
  "reset_all_windows(const GraphicsEngine self, bool swapchain)\n"
  "\n"
  "/**\n"
  " * Resets the framebuffer of the current window.  This is currently used by\n"
  " * DirectX 8 only.  It calls a reset_window function on each active window to\n"
  " * release/create old/new framebuffer\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_reset_all_windows_511_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GraphicsEngine::is_empty(void) const
 */
static PyObject *Dtool_GraphicsEngine_is_empty_512(PyObject *self, PyObject *) {
  GraphicsEngine *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsEngine)) {
    return nullptr;
  }
  // 1-bool GraphicsEngine::is_empty(void) const
  bool return_value = ((*(const GraphicsEngine*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_is_empty_512_comment =
  "C++ Interface:\n"
  "is_empty(GraphicsEngine self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are no windows or buffers managed by the engine,\n"
  " * false if there is at least one.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_is_empty_512_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GraphicsEngine::get_num_windows(void) const
 */
static PyObject *Dtool_GraphicsEngine_get_num_windows_513(PyObject *self, PyObject *) {
  GraphicsEngine *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsEngine)) {
    return nullptr;
  }
  // 1-int GraphicsEngine::get_num_windows(void) const
  int return_value = ((*(const GraphicsEngine*)local_this).get_num_windows)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_get_num_windows_513_comment =
  "C++ Interface:\n"
  "get_num_windows(GraphicsEngine self)\n"
  "\n"
  "/**\n"
  " * Returns the number of windows (or buffers) managed by the engine.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_get_num_windows_513_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * GraphicsOutput *GraphicsEngine::get_window(int n) const
 */
static PyObject *Dtool_GraphicsEngine_get_window_514(PyObject *self, PyObject *arg) {
  GraphicsEngine *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsEngine)) {
    return nullptr;
  }
  // 1-GraphicsOutput *GraphicsEngine::get_window(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    GraphicsOutput *return_value = ((*(const GraphicsEngine*)local_this).get_window)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutput, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_window(GraphicsEngine self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_get_window_514_comment =
  "C++ Interface:\n"
  "get_window(GraphicsEngine self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth window or buffers managed by the engine, in sorted order.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_get_window_514_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsEngine::render_frame(void)
 */
static PyObject *Dtool_GraphicsEngine_render_frame_517(PyObject *self, PyObject *) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.render_frame")) {
    return nullptr;
  }
  // 1-void GraphicsEngine::render_frame(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).render_frame)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_render_frame_517_comment =
  "C++ Interface:\n"
  "render_frame(const GraphicsEngine self)\n"
  "\n"
  "/**\n"
  " * Renders the next frame in all the registered windows, and flips all of the\n"
  " * frame buffers.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_render_frame_517_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsEngine::open_windows(void)
 */
static PyObject *Dtool_GraphicsEngine_open_windows_518(PyObject *self, PyObject *) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.open_windows")) {
    return nullptr;
  }
  // 1-void GraphicsEngine::open_windows(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).open_windows)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_open_windows_518_comment =
  "C++ Interface:\n"
  "open_windows(const GraphicsEngine self)\n"
  "\n"
  "/**\n"
  " * Fully opens (or closes) any windows that have recently been requested open\n"
  " * or closed, without rendering any frames.  It is not necessary to call this\n"
  " * explicitly, since windows will be automatically opened or closed when the\n"
  " * next frame is rendered, but you may call this if you want your windows now\n"
  " * without seeing a frame go by.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_open_windows_518_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsEngine::sync_frame(void)
 */
static PyObject *Dtool_GraphicsEngine_sync_frame_519(PyObject *self, PyObject *) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.sync_frame")) {
    return nullptr;
  }
  // 1-void GraphicsEngine::sync_frame(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).sync_frame)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_sync_frame_519_comment =
  "C++ Interface:\n"
  "sync_frame(const GraphicsEngine self)\n"
  "\n"
  "/**\n"
  " * Waits for all the threads that started drawing their last frame to finish\n"
  " * drawing.  The windows are not yet flipped when this returns; see also\n"
  " * flip_frame(). It is not usually necessary to call this explicitly, unless\n"
  " * you need to see the previous frame right away.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_sync_frame_519_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsEngine::ready_flip(void)
 */
static PyObject *Dtool_GraphicsEngine_ready_flip_520(PyObject *self, PyObject *) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.ready_flip")) {
    return nullptr;
  }
  // 1-void GraphicsEngine::ready_flip(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).ready_flip)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_ready_flip_520_comment =
  "C++ Interface:\n"
  "ready_flip(const GraphicsEngine self)\n"
  "\n"
  "/**\n"
  " * Waits for all the threads that started drawing their last frame to finish\n"
  " * drawing.  Returns when all threads have actually finished drawing, as\n"
  " * opposed to 'sync_frame' we seems to return once all draw calls have been\n"
  " * submitted.  Calling 'flip_frame' after this function should immediately\n"
  " * cause a buffer flip.  This function will only work in opengl right now, for\n"
  " * all other graphics pipelines it will simply return immediately.  In opengl\n"
  " * it's a bit of a hack: it will attempt to read a single pixel from the frame\n"
  " * buffer to force the graphics card to finish drawing before it returns\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_ready_flip_520_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsEngine::flip_frame(void)
 */
static PyObject *Dtool_GraphicsEngine_flip_frame_521(PyObject *self, PyObject *) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.flip_frame")) {
    return nullptr;
  }
  // 1-void GraphicsEngine::flip_frame(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).flip_frame)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_flip_frame_521_comment =
  "C++ Interface:\n"
  "flip_frame(const GraphicsEngine self)\n"
  "\n"
  "/**\n"
  " * Waits for all the threads that started drawing their last frame to finish\n"
  " * drawing, and then flips all the windows.  It is not usually necessary to\n"
  " * call this explicitly, unless you need to see the previous frame right away.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_flip_frame_521_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GraphicsEngine::extract_texture_data(Texture *tex, GraphicsStateGuardian *gsg)
 */
static PyObject *Dtool_GraphicsEngine_extract_texture_data_522(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.extract_texture_data")) {
    return nullptr;
  }
  // 1-bool GraphicsEngine::extract_texture_data(Texture *tex, GraphicsStateGuardian *gsg)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"tex", "gsg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:extract_texture_data", (char **)keyword_list, &param1, &param2)) {
    Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "GraphicsEngine.extract_texture_data", false, true);
    GraphicsStateGuardian *param2_this = (GraphicsStateGuardian *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_GraphicsStateGuardian, 2, "GraphicsEngine.extract_texture_data", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      bool return_value = ((*local_this).extract_texture_data)(param1_this, param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract_texture_data(const GraphicsEngine self, Texture tex, GraphicsStateGuardian gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_extract_texture_data_522_comment =
  "C++ Interface:\n"
  "extract_texture_data(const GraphicsEngine self, Texture tex, GraphicsStateGuardian gsg)\n"
  "\n"
  "/**\n"
  " * Asks the indicated GraphicsStateGuardian to retrieve the texture memory\n"
  " * image of the indicated texture and store it in the texture's ram_image\n"
  " * field.  The image can then be written to disk via Texture::write(), or\n"
  " * otherwise manipulated on the CPU.\n"
  " *\n"
  " * This is useful for retrieving the contents of a texture that has been\n"
  " * somehow generated on the graphics card, instead of having been loaded the\n"
  " * normal way via Texture::read() or Texture::load(). It is particularly\n"
  " * useful for getting the data associated with a compressed texture image.\n"
  " *\n"
  " * Since this requires a round-trip to the draw thread, it may require waiting\n"
  " * for the current thread to finish rendering if it is called in a\n"
  " * multithreaded environment.  However, you can call this several consecutive\n"
  " * times on different textures for little additional cost.\n"
  " *\n"
  " * If the texture has not yet been loaded to the GSG in question, it will be\n"
  " * loaded immediately.\n"
  " *\n"
  " * The return value is true if the operation is successful, false otherwise.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_extract_texture_data_522_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsEngine::dispatch_compute(LVecBase3i const &work_groups, ShaderAttrib const *sattr, GraphicsStateGuardian *gsg)
 */
static PyObject *Dtool_GraphicsEngine_dispatch_compute_523(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.dispatch_compute")) {
    return nullptr;
  }
  // 1-void GraphicsEngine::dispatch_compute(LVecBase3i const &work_groups, ShaderAttrib const *sattr, GraphicsStateGuardian *gsg)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"work_groups", "sattr", "gsg", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:dispatch_compute", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3i param1_local;
    LVecBase3i const *param1_this = Dtool_Coerce_LVecBase3i(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "GraphicsEngine.dispatch_compute", "LVecBase3i");
    }
    CPT(ShaderAttrib) param2_this;
    if (!Dtool_ConstCoerce_ShaderAttrib(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "GraphicsEngine.dispatch_compute", "ShaderAttrib");
    }
    GraphicsStateGuardian *param3_this = (GraphicsStateGuardian *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_GraphicsStateGuardian, 3, "GraphicsEngine.dispatch_compute", false, true);
    if (param3_this != nullptr) {
      ((*local_this).dispatch_compute)(*param1_this, std::move(param2_this), param3_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dispatch_compute(const GraphicsEngine self, const LVecBase3i work_groups, const ShaderAttrib sattr, GraphicsStateGuardian gsg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_dispatch_compute_523_comment =
  "C++ Interface:\n"
  "dispatch_compute(const GraphicsEngine self, const LVecBase3i work_groups, const ShaderAttrib sattr, GraphicsStateGuardian gsg)\n"
  "\n"
  "/**\n"
  " * Asks the indicated GraphicsStateGuardian to dispatch the compute shader in\n"
  " * the given ShaderAttrib using the given work group counts.  This can act as\n"
  " * an interface for running a one-off compute shader, without having to store\n"
  " * it in the scene graph using a ComputeNode.\n"
  " *\n"
  " * Since this requires a round-trip to the draw thread, it may require waiting\n"
  " * for the current thread to finish rendering if it is called in a\n"
  " * multithreaded environment.  However, you can call this several consecutive\n"
  " * times on different textures for little additional cost.\n"
  " *\n"
  " * The return value is true if the operation is successful, false otherwise.\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_dispatch_compute_523_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static GraphicsEngine *GraphicsEngine::get_global_ptr(void)
 */
static PyObject *Dtool_GraphicsEngine_get_global_ptr_524(PyObject *, PyObject *) {
  // 1-static GraphicsEngine *GraphicsEngine::get_global_ptr(void)
  GraphicsEngine *return_value = (GraphicsEngine::get_global_ptr)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GraphicsEngine, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsEngine_get_global_ptr_524_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GraphicsEngine_get_global_ptr_524_comment = nullptr;
#endif

static PyObject *Dtool_GraphicsEngine_threading_model_Getter(PyObject *self, void *) {
  const GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsEngine, (void **)&local_this)) {
    return nullptr;
  }

  // 1-GraphicsThreadingModel GraphicsEngine::get_threading_model(void) const
  GraphicsThreadingModel *return_value = new GraphicsThreadingModel(((*(const GraphicsEngine*)local_this).get_threading_model)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GraphicsThreadingModel, true, false);
}

static int Dtool_GraphicsEngine_threading_model_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.threading_model")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete threading_model attribute");
    return -1;
  }
  // 1-void GraphicsEngine::set_threading_model(GraphicsThreadingModel const &threading_model)
  GraphicsThreadingModel arg_local;
  GraphicsThreadingModel const *arg_this = Dtool_Coerce_GraphicsThreadingModel(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "GraphicsEngine.set_threading_model", "GraphicsThreadingModel");
    return -1;
  }
  ((*local_this).set_threading_model)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_threading_model(const GraphicsEngine self, const GraphicsThreadingModel threading_model)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsEngine_render_lock_Getter(PyObject *self, void *) {
  const GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsEngine, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ReMutex const &GraphicsEngine::get_render_lock(void) const
  ReMutex const *return_value = &(((*(const GraphicsEngine*)local_this).get_render_lock)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReMutex, false, true);
}

static PyObject *Dtool_GraphicsEngine_auto_flip_Getter(PyObject *self, void *) {
  const GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsEngine, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsEngine::get_auto_flip(void) const
  bool return_value = ((*(const GraphicsEngine*)local_this).get_auto_flip)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GraphicsEngine_auto_flip_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.auto_flip")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete auto_flip attribute");
    return -1;
  }
  // 1-inline void GraphicsEngine::set_auto_flip(bool auto_flip)
  ((*local_this).set_auto_flip)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_auto_flip(const GraphicsEngine self, bool auto_flip)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsEngine_portal_cull_Getter(PyObject *self, void *) {
  const GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsEngine, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsEngine::get_portal_cull(void) const
  bool return_value = ((*(const GraphicsEngine*)local_this).get_portal_cull)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GraphicsEngine_portal_cull_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.portal_cull")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete portal_cull attribute");
    return -1;
  }
  // 1-inline void GraphicsEngine::set_portal_cull(bool value)
  ((*local_this).set_portal_cull)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_portal_cull(const GraphicsEngine self, bool value)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsEngine_default_loader_Getter(PyObject *self, void *) {
  const GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsEngine, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Loader *GraphicsEngine::get_default_loader(void) const
  Loader *return_value = ((*(const GraphicsEngine*)local_this).get_default_loader)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Loader, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_GraphicsEngine_default_loader_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsEngine, (void **)&local_this, "GraphicsEngine.default_loader")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete default_loader attribute");
    return -1;
  }
  // 1-inline void GraphicsEngine::set_default_loader(Loader *loader)
  Loader *arg_this = (Loader *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Loader, 1, "GraphicsEngine.set_default_loader", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_default_loader)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_default_loader(const GraphicsEngine self, Loader loader)\n");
  }
  return -1;
}

/**
 * sequence length function for property GraphicsEngine::windows
 */
static Py_ssize_t Dtool_GraphicsEngine_windows_Len(PyObject *self) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsEngine, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_windows)();
}

/**
 * sequence getter for property GraphicsEngine::windows
 */
static PyObject *Dtool_GraphicsEngine_windows_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsEngine, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_windows)()) {
    PyErr_SetString(PyExc_IndexError, "GraphicsEngine.windows[] index out of range");
    return nullptr;
  }
  // 1-GraphicsOutput *GraphicsEngine::get_window(int n) const
  GraphicsOutput *return_value = ((*(const GraphicsEngine*)local_this).get_window)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_GraphicsOutput, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_window(GraphicsEngine self, index)\n");
  }
}

static PyObject *Dtool_GraphicsEngine_windows_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "GraphicsEngine.windows");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_GraphicsEngine_windows_Len;
    wrap->_getitem_func = &Dtool_GraphicsEngine_windows_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * explicit GraphicsEngine::GraphicsEngine(Pipeline *pipeline = nullptr)
 */
static int Dtool_Init_GraphicsEngine(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit GraphicsEngine::GraphicsEngine(Pipeline *pipeline = nullptr)
  GraphicsEngine *return_value = new GraphicsEngine();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GraphicsEngine, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GraphicsEngine()\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GraphicsEngine_get_windows(PyObject *self, PyObject *) {
  GraphicsEngine *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsEngine, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_windows)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GraphicsEngine_get_window_514(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_GraphicsEngine(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GraphicsEngine) {
    printf("GraphicsEngine ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GraphicsEngine *local_this = (GraphicsEngine *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GraphicsEngine) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GraphicsEngine(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GraphicsEngine) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GraphicsEngine*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GraphicsThreadingModel
 */
/**
 * Python function wrapper for:
 * inline void GraphicsThreadingModel::operator =(GraphicsThreadingModel const &copy)
 */
static PyObject *Dtool_GraphicsThreadingModel_operator_478(PyObject *self, PyObject *arg) {
  GraphicsThreadingModel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsThreadingModel, (void **)&local_this, "GraphicsThreadingModel.assign")) {
    return nullptr;
  }
  // 1-inline void GraphicsThreadingModel::operator =(GraphicsThreadingModel const &copy)
  GraphicsThreadingModel arg_local;
  GraphicsThreadingModel const *arg_this = Dtool_Coerce_GraphicsThreadingModel(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GraphicsThreadingModel.assign", "GraphicsThreadingModel");
  }
  ((*local_this).operator =)(*arg_this);
  GraphicsThreadingModel *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GraphicsThreadingModel, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const GraphicsThreadingModel self, const GraphicsThreadingModel copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsThreadingModel_operator_478_comment =
  "C++ Interface:\n"
  "assign(const GraphicsThreadingModel self, const GraphicsThreadingModel copy)\n";
#else
static const char *Dtool_GraphicsThreadingModel_operator_478_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string GraphicsThreadingModel::get_model(void) const
 */
static PyObject *Dtool_GraphicsThreadingModel_get_model_479(PyObject *self, PyObject *) {
  GraphicsThreadingModel *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsThreadingModel)) {
    return nullptr;
  }
  // 1-std::string GraphicsThreadingModel::get_model(void) const
  std::string return_value = ((*(const GraphicsThreadingModel*)local_this).get_model)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsThreadingModel_get_model_479_comment =
  "C++ Interface:\n"
  "get_model(GraphicsThreadingModel self)\n"
  "\n"
  "/**\n"
  " * Returns the string that describes the threading model.  See the\n"
  " * constructor.\n"
  " */";
#else
static const char *Dtool_GraphicsThreadingModel_get_model_479_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &GraphicsThreadingModel::get_cull_name(void) const
 */
static PyObject *Dtool_GraphicsThreadingModel_get_cull_name_480(PyObject *self, PyObject *) {
  GraphicsThreadingModel *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsThreadingModel)) {
    return nullptr;
  }
  // 1-inline std::string const &GraphicsThreadingModel::get_cull_name(void) const
  std::string const &return_value = ((*(const GraphicsThreadingModel*)local_this).get_cull_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsThreadingModel_get_cull_name_480_comment =
  "C++ Interface:\n"
  "get_cull_name(GraphicsThreadingModel self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the thread that will handle culling in this model.\n"
  " */";
#else
static const char *Dtool_GraphicsThreadingModel_get_cull_name_480_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsThreadingModel::set_cull_name(std::string const &cull_name)
 */
static PyObject *Dtool_GraphicsThreadingModel_set_cull_name_481(PyObject *self, PyObject *arg) {
  GraphicsThreadingModel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsThreadingModel, (void **)&local_this, "GraphicsThreadingModel.set_cull_name")) {
    return nullptr;
  }
  // 1-inline void GraphicsThreadingModel::set_cull_name(std::string const &cull_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_cull_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cull_name(const GraphicsThreadingModel self, str cull_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsThreadingModel_set_cull_name_481_comment =
  "C++ Interface:\n"
  "set_cull_name(const GraphicsThreadingModel self, str cull_name)\n"
  "\n"
  "/**\n"
  " * Changes the name of the thread that will handle culling in this model.\n"
  " * This won't change any windows that were already created with this model;\n"
  " * this only has an effect on newly-opened windows.\n"
  " */";
#else
static const char *Dtool_GraphicsThreadingModel_set_cull_name_481_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsThreadingModel::get_cull_stage(void) const
 */
static PyObject *Dtool_GraphicsThreadingModel_get_cull_stage_482(PyObject *self, PyObject *) {
  GraphicsThreadingModel *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsThreadingModel)) {
    return nullptr;
  }
  // 1-inline int GraphicsThreadingModel::get_cull_stage(void) const
  int return_value = ((*(const GraphicsThreadingModel*)local_this).get_cull_stage)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsThreadingModel_get_cull_stage_482_comment =
  "C++ Interface:\n"
  "get_cull_stage(GraphicsThreadingModel self)\n"
  "\n"
  "/**\n"
  " * Returns the pipeline stage from which the cull thread should access data.\n"
  " * This will be 0 if the cull is run in the same thread as app, or 1 if it is\n"
  " * its own thread.\n"
  " */";
#else
static const char *Dtool_GraphicsThreadingModel_get_cull_stage_482_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &GraphicsThreadingModel::get_draw_name(void) const
 */
static PyObject *Dtool_GraphicsThreadingModel_get_draw_name_483(PyObject *self, PyObject *) {
  GraphicsThreadingModel *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsThreadingModel)) {
    return nullptr;
  }
  // 1-inline std::string const &GraphicsThreadingModel::get_draw_name(void) const
  std::string const &return_value = ((*(const GraphicsThreadingModel*)local_this).get_draw_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsThreadingModel_get_draw_name_483_comment =
  "C++ Interface:\n"
  "get_draw_name(GraphicsThreadingModel self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the thread that will handle sending the actual graphics\n"
  " * primitives to the graphics API in this model.\n"
  " */";
#else
static const char *Dtool_GraphicsThreadingModel_get_draw_name_483_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsThreadingModel::set_draw_name(std::string const &cull_name)
 */
static PyObject *Dtool_GraphicsThreadingModel_set_draw_name_484(PyObject *self, PyObject *arg) {
  GraphicsThreadingModel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsThreadingModel, (void **)&local_this, "GraphicsThreadingModel.set_draw_name")) {
    return nullptr;
  }
  // 1-inline void GraphicsThreadingModel::set_draw_name(std::string const &cull_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_draw_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_draw_name(const GraphicsThreadingModel self, str cull_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsThreadingModel_set_draw_name_484_comment =
  "C++ Interface:\n"
  "set_draw_name(const GraphicsThreadingModel self, str cull_name)\n"
  "\n"
  "/**\n"
  " * Changes the name of the thread that will handle drawing in this model.\n"
  " * This won't change any windows that were already created with this model;\n"
  " * this only has an effect on newly-opened windows.\n"
  " */";
#else
static const char *Dtool_GraphicsThreadingModel_set_draw_name_484_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsThreadingModel::get_draw_stage(void) const
 */
static PyObject *Dtool_GraphicsThreadingModel_get_draw_stage_485(PyObject *self, PyObject *) {
  GraphicsThreadingModel *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsThreadingModel)) {
    return nullptr;
  }
  // 1-inline int GraphicsThreadingModel::get_draw_stage(void) const
  int return_value = ((*(const GraphicsThreadingModel*)local_this).get_draw_stage)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsThreadingModel_get_draw_stage_485_comment =
  "C++ Interface:\n"
  "get_draw_stage(GraphicsThreadingModel self)\n"
  "\n"
  "/**\n"
  " * Returns the pipeline stage from which the draw thread should access data.\n"
  " * This will be the same value as get_cull_stage() if cull and draw are run in\n"
  " * the same thread, or one more than that value if draw should be in its own\n"
  " * thread.\n"
  " */";
#else
static const char *Dtool_GraphicsThreadingModel_get_draw_stage_485_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsThreadingModel::get_cull_sorting(void) const
 */
static PyObject *Dtool_GraphicsThreadingModel_get_cull_sorting_486(PyObject *self, PyObject *) {
  GraphicsThreadingModel *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsThreadingModel)) {
    return nullptr;
  }
  // 1-inline bool GraphicsThreadingModel::get_cull_sorting(void) const
  bool return_value = ((*(const GraphicsThreadingModel*)local_this).get_cull_sorting)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsThreadingModel_get_cull_sorting_486_comment =
  "C++ Interface:\n"
  "get_cull_sorting(GraphicsThreadingModel self)\n"
  "\n"
  "/**\n"
  " * Returns true if the model involves a separate cull pass, or false if\n"
  " * culling happens implicitly, at the same time as draw.\n"
  " */";
#else
static const char *Dtool_GraphicsThreadingModel_get_cull_sorting_486_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsThreadingModel::set_cull_sorting(bool cull_sorting)
 */
static PyObject *Dtool_GraphicsThreadingModel_set_cull_sorting_487(PyObject *self, PyObject *arg) {
  GraphicsThreadingModel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsThreadingModel, (void **)&local_this, "GraphicsThreadingModel.set_cull_sorting")) {
    return nullptr;
  }
  // 1-inline void GraphicsThreadingModel::set_cull_sorting(bool cull_sorting)
  ((*local_this).set_cull_sorting)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cull_sorting(const GraphicsThreadingModel self, bool cull_sorting)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsThreadingModel_set_cull_sorting_487_comment =
  "C++ Interface:\n"
  "set_cull_sorting(const GraphicsThreadingModel self, bool cull_sorting)\n"
  "\n"
  "/**\n"
  " * Changes the flag that indicates whether the threading model involves a\n"
  " * separate cull pass.  This won't change any windows that were already\n"
  " * created with this model; this only has an effect on newly-opened windows.\n"
  " */";
#else
static const char *Dtool_GraphicsThreadingModel_set_cull_sorting_487_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsThreadingModel::is_single_threaded(void) const
 */
static PyObject *Dtool_GraphicsThreadingModel_is_single_threaded_488(PyObject *self, PyObject *) {
  GraphicsThreadingModel *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsThreadingModel)) {
    return nullptr;
  }
  // 1-inline bool GraphicsThreadingModel::is_single_threaded(void) const
  bool return_value = ((*(const GraphicsThreadingModel*)local_this).is_single_threaded)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsThreadingModel_is_single_threaded_488_comment =
  "C++ Interface:\n"
  "is_single_threaded(GraphicsThreadingModel self)\n"
  "\n"
  "/**\n"
  " * Returns true if the threading model is a single-threaded model, or false if\n"
  " * it involves threads.\n"
  " */";
#else
static const char *Dtool_GraphicsThreadingModel_is_single_threaded_488_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsThreadingModel::is_default(void) const
 */
static PyObject *Dtool_GraphicsThreadingModel_is_default_489(PyObject *self, PyObject *) {
  GraphicsThreadingModel *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsThreadingModel)) {
    return nullptr;
  }
  // 1-inline bool GraphicsThreadingModel::is_default(void) const
  bool return_value = ((*(const GraphicsThreadingModel*)local_this).is_default)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsThreadingModel_is_default_489_comment =
  "C++ Interface:\n"
  "is_default(GraphicsThreadingModel self)\n"
  "\n"
  "/**\n"
  " * Returns true if the threading model is the default, cull-then-draw single-\n"
  " * threaded model, or false otherwise.\n"
  " */";
#else
static const char *Dtool_GraphicsThreadingModel_is_default_489_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsThreadingModel::output(std::ostream &out) const
 */
static PyObject *Dtool_GraphicsThreadingModel_output_490(PyObject *self, PyObject *arg) {
  GraphicsThreadingModel *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsThreadingModel)) {
    return nullptr;
  }
  // 1-inline void GraphicsThreadingModel::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "GraphicsThreadingModel.output", false, true);
  if (arg_this != nullptr) {
    ((*(const GraphicsThreadingModel*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(GraphicsThreadingModel self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsThreadingModel_output_490_comment =
  "C++ Interface:\n"
  "output(GraphicsThreadingModel self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_GraphicsThreadingModel_output_490_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsThreadingModel::GraphicsThreadingModel(GraphicsThreadingModel const &copy)
 * GraphicsThreadingModel::GraphicsThreadingModel(std::string const &model = string())
 */
static int Dtool_Init_GraphicsThreadingModel(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-GraphicsThreadingModel::GraphicsThreadingModel(std::string const &model)
      GraphicsThreadingModel *return_value = new GraphicsThreadingModel();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GraphicsThreadingModel, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline GraphicsThreadingModel::GraphicsThreadingModel(GraphicsThreadingModel const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          GraphicsThreadingModel const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_GraphicsThreadingModel);
          if (param0_this != nullptr) {
            GraphicsThreadingModel *return_value = new GraphicsThreadingModel(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GraphicsThreadingModel, true, false);
          }
        }
      }

      {
        // -2 GraphicsThreadingModel::GraphicsThreadingModel(std::string const &model)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"model", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:GraphicsThreadingModel", (char **)keyword_list, &param0_str, &param0_len)) {
          GraphicsThreadingModel *return_value = new GraphicsThreadingModel(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GraphicsThreadingModel, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline GraphicsThreadingModel::GraphicsThreadingModel(GraphicsThreadingModel const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          GraphicsThreadingModel param0_local;
          GraphicsThreadingModel const *param0_this = Dtool_Coerce_GraphicsThreadingModel(param0, param0_local);
          if ((param0_this != nullptr)) {
            GraphicsThreadingModel *return_value = new GraphicsThreadingModel(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GraphicsThreadingModel, true, false);
          }
        }
      }

      // No coercion possible: GraphicsThreadingModel::GraphicsThreadingModel(std::string const &model)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GraphicsThreadingModel() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GraphicsThreadingModel()\n"
      "GraphicsThreadingModel(const GraphicsThreadingModel copy)\n"
      "GraphicsThreadingModel(str model)\n");
  }
  return -1;
}

GraphicsThreadingModel *Dtool_Coerce_GraphicsThreadingModel(PyObject *args, GraphicsThreadingModel &coerced) {
  GraphicsThreadingModel *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_GraphicsThreadingModel)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const GraphicsThreadingModel *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-GraphicsThreadingModel::GraphicsThreadingModel(std::string const &model)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      coerced = GraphicsThreadingModel(std::string(param0_str, param0_len));
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
    PyErr_Clear();
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_GraphicsThreadingModel(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GraphicsThreadingModel) {
    printf("GraphicsThreadingModel ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GraphicsThreadingModel *local_this = (GraphicsThreadingModel *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GraphicsThreadingModel) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GraphicsThreadingModel(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GraphicsThreadingModel) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class StereoDisplayRegion
 */
/**
 * Python function wrapper for:
 * inline DisplayRegion *StereoDisplayRegion::get_left_eye(void)
 */
static PyObject *Dtool_StereoDisplayRegion_get_left_eye_680(PyObject *self, PyObject *) {
  StereoDisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StereoDisplayRegion, (void **)&local_this, "StereoDisplayRegion.get_left_eye")) {
    return nullptr;
  }
  // 1-inline DisplayRegion *StereoDisplayRegion::get_left_eye(void)
  DisplayRegion *return_value = ((*local_this).get_left_eye)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_StereoDisplayRegion_get_left_eye_680_comment =
  "C++ Interface:\n"
  "get_left_eye(const StereoDisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the left DisplayRegion managed by this stereo object.\n"
  " */";
#else
static const char *Dtool_StereoDisplayRegion_get_left_eye_680_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DisplayRegion *StereoDisplayRegion::get_right_eye(void)
 */
static PyObject *Dtool_StereoDisplayRegion_get_right_eye_681(PyObject *self, PyObject *) {
  StereoDisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StereoDisplayRegion, (void **)&local_this, "StereoDisplayRegion.get_right_eye")) {
    return nullptr;
  }
  // 1-inline DisplayRegion *StereoDisplayRegion::get_right_eye(void)
  DisplayRegion *return_value = ((*local_this).get_right_eye)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_StereoDisplayRegion_get_right_eye_681_comment =
  "C++ Interface:\n"
  "get_right_eye(const StereoDisplayRegion self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the right DisplayRegion managed by this stereo object.\n"
  " */";
#else
static const char *Dtool_StereoDisplayRegion_get_right_eye_681_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle StereoDisplayRegion::get_class_type(void)
 */
static PyObject *Dtool_StereoDisplayRegion_get_class_type_685(PyObject *, PyObject *) {
  // 1-static TypeHandle StereoDisplayRegion::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((StereoDisplayRegion::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_StereoDisplayRegion_get_class_type_685_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_StereoDisplayRegion_get_class_type_685_comment = nullptr;
#endif

static PyObject *Dtool_StereoDisplayRegion_left_eye_Getter(PyObject *self, void *) {
  StereoDisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StereoDisplayRegion, (void **)&local_this, "StereoDisplayRegion.left_eye")) {
    return nullptr;
  }

  // 1-inline DisplayRegion *StereoDisplayRegion::get_left_eye(void)
  DisplayRegion *return_value = ((*local_this).get_left_eye)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_StereoDisplayRegion_right_eye_Getter(PyObject *self, void *) {
  StereoDisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StereoDisplayRegion, (void **)&local_this, "StereoDisplayRegion.right_eye")) {
    return nullptr;
  }

  // 1-inline DisplayRegion *StereoDisplayRegion::get_right_eye(void)
  DisplayRegion *return_value = ((*local_this).get_right_eye)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DisplayRegion, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_Init_StereoDisplayRegion(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_StereoDisplayRegion(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_StereoDisplayRegion) {
    printf("StereoDisplayRegion ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  StereoDisplayRegion *local_this = (StereoDisplayRegion *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_StereoDisplayRegion) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DisplayRegion) {
    return (DisplayRegion *) local_this;
  }
  if (requested_type == Dtool_Ptr_DrawableRegion) {
    return (DrawableRegion *)(DisplayRegion *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(DisplayRegion *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(DisplayRegion *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(DisplayRegion *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_StereoDisplayRegion(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_StereoDisplayRegion) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DisplayRegion) {
    DisplayRegion* other_this = (DisplayRegion*)from_this;
    return (StereoDisplayRegion*)other_this;
  }
  if (from_type == Dtool_Ptr_DrawableRegion) {
    DrawableRegion* other_this = (DrawableRegion*)from_this;
    return (StereoDisplayRegion*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (StereoDisplayRegion*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (StereoDisplayRegion*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (StereoDisplayRegion*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class FrameBufferProperties
 */
/**
 * Python function wrapper for:
 * inline int FrameBufferProperties::get_depth_bits(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_depth_bits_687(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline int FrameBufferProperties::get_depth_bits(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_depth_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_depth_bits_687_comment =
  "C++ Interface:\n"
  "get_depth_bits(FrameBufferProperties self)\n"
  "\n"
  "// Individual queries.\n"
  "\n"
  "// Individual queries.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_depth_bits_687_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int FrameBufferProperties::get_color_bits(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_color_bits_688(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline int FrameBufferProperties::get_color_bits(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_color_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_color_bits_688_comment =
  "C++ Interface:\n"
  "get_color_bits(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_color_bits_688_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int FrameBufferProperties::get_red_bits(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_red_bits_689(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline int FrameBufferProperties::get_red_bits(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_red_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_red_bits_689_comment =
  "C++ Interface:\n"
  "get_red_bits(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_red_bits_689_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int FrameBufferProperties::get_green_bits(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_green_bits_690(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline int FrameBufferProperties::get_green_bits(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_green_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_green_bits_690_comment =
  "C++ Interface:\n"
  "get_green_bits(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_green_bits_690_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int FrameBufferProperties::get_blue_bits(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_blue_bits_691(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline int FrameBufferProperties::get_blue_bits(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_blue_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_blue_bits_691_comment =
  "C++ Interface:\n"
  "get_blue_bits(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_blue_bits_691_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int FrameBufferProperties::get_alpha_bits(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_alpha_bits_692(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline int FrameBufferProperties::get_alpha_bits(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_alpha_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_alpha_bits_692_comment =
  "C++ Interface:\n"
  "get_alpha_bits(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_alpha_bits_692_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int FrameBufferProperties::get_stencil_bits(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_stencil_bits_693(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline int FrameBufferProperties::get_stencil_bits(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_stencil_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_stencil_bits_693_comment =
  "C++ Interface:\n"
  "get_stencil_bits(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_stencil_bits_693_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int FrameBufferProperties::get_accum_bits(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_accum_bits_694(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline int FrameBufferProperties::get_accum_bits(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_accum_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_accum_bits_694_comment =
  "C++ Interface:\n"
  "get_accum_bits(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_accum_bits_694_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int FrameBufferProperties::get_aux_rgba(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_aux_rgba_695(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline int FrameBufferProperties::get_aux_rgba(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_aux_rgba)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_aux_rgba_695_comment =
  "C++ Interface:\n"
  "get_aux_rgba(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_aux_rgba_695_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int FrameBufferProperties::get_aux_hrgba(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_aux_hrgba_696(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline int FrameBufferProperties::get_aux_hrgba(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_aux_hrgba)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_aux_hrgba_696_comment =
  "C++ Interface:\n"
  "get_aux_hrgba(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_aux_hrgba_696_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int FrameBufferProperties::get_aux_float(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_aux_float_697(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline int FrameBufferProperties::get_aux_float(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_aux_float)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_aux_float_697_comment =
  "C++ Interface:\n"
  "get_aux_float(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_aux_float_697_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int FrameBufferProperties::get_multisamples(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_multisamples_698(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline int FrameBufferProperties::get_multisamples(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_multisamples)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_multisamples_698_comment =
  "C++ Interface:\n"
  "get_multisamples(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_multisamples_698_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int FrameBufferProperties::get_coverage_samples(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_coverage_samples_699(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline int FrameBufferProperties::get_coverage_samples(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_coverage_samples)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_coverage_samples_699_comment =
  "C++ Interface:\n"
  "get_coverage_samples(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " * If coverage samples are specified, and there is hardware support, we use\n"
  " * coverage multisampling.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_coverage_samples_699_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int FrameBufferProperties::get_back_buffers(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_back_buffers_700(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline int FrameBufferProperties::get_back_buffers(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_back_buffers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_back_buffers_700_comment =
  "C++ Interface:\n"
  "get_back_buffers(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_back_buffers_700_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool FrameBufferProperties::get_indexed_color(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_indexed_color_701(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline bool FrameBufferProperties::get_indexed_color(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).get_indexed_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_indexed_color_701_comment =
  "C++ Interface:\n"
  "get_indexed_color(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_indexed_color_701_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool FrameBufferProperties::get_rgb_color(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_rgb_color_702(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline bool FrameBufferProperties::get_rgb_color(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).get_rgb_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_rgb_color_702_comment =
  "C++ Interface:\n"
  "get_rgb_color(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_rgb_color_702_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool FrameBufferProperties::get_stereo(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_stereo_703(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline bool FrameBufferProperties::get_stereo(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).get_stereo)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_stereo_703_comment =
  "C++ Interface:\n"
  "get_stereo(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_stereo_703_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool FrameBufferProperties::get_force_hardware(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_force_hardware_704(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline bool FrameBufferProperties::get_force_hardware(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).get_force_hardware)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_force_hardware_704_comment =
  "C++ Interface:\n"
  "get_force_hardware(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_force_hardware_704_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool FrameBufferProperties::get_force_software(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_force_software_705(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline bool FrameBufferProperties::get_force_software(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).get_force_software)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_force_software_705_comment =
  "C++ Interface:\n"
  "get_force_software(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_force_software_705_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool FrameBufferProperties::get_srgb_color(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_srgb_color_706(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline bool FrameBufferProperties::get_srgb_color(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).get_srgb_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_srgb_color_706_comment =
  "C++ Interface:\n"
  "get_srgb_color(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_srgb_color_706_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool FrameBufferProperties::get_float_color(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_float_color_707(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline bool FrameBufferProperties::get_float_color(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).get_float_color)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_float_color_707_comment =
  "C++ Interface:\n"
  "get_float_color(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_float_color_707_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool FrameBufferProperties::get_float_depth(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_float_depth_708(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline bool FrameBufferProperties::get_float_depth(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).get_float_depth)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_float_depth_708_comment =
  "C++ Interface:\n"
  "get_float_depth(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_float_depth_708_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_depth_bits(int n)
 */
static PyObject *Dtool_FrameBufferProperties_set_depth_bits_709(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_depth_bits")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_depth_bits(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_depth_bits)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_depth_bits(const FrameBufferProperties self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_depth_bits_709_comment =
  "C++ Interface:\n"
  "set_depth_bits(const FrameBufferProperties self, int n)\n"
  "\n"
  "// Individual assigners.\n"
  "\n"
  "// Individual assigners.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_depth_bits_709_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_color_bits(int n)
 */
static PyObject *Dtool_FrameBufferProperties_set_color_bits_710(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_color_bits")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_color_bits(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_color_bits)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color_bits(const FrameBufferProperties self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_color_bits_710_comment =
  "C++ Interface:\n"
  "set_color_bits(const FrameBufferProperties self, int n)\n"
  "\n"
  "/**\n"
  " * Sets the number of requested color bits as a single number that represents\n"
  " * the sum of the individual numbers of red, green and blue bits.  Panda won't\n"
  " * care how the individual bits are divided up.\n"
  " *\n"
  " * See also set_rgba_bits, which allows you to specify requirements for the\n"
  " * individual components.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_color_bits_710_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_rgba_bits(int r, int g, int b, int a)
 */
static PyObject *Dtool_FrameBufferProperties_set_rgba_bits_711(PyObject *self, PyObject *args, PyObject *kwds) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_rgba_bits")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_rgba_bits(int r, int g, int b, int a)
  int param1;
  int param2;
  int param3;
  int param4;
  static const char *keyword_list[] = {"r", "g", "b", "a", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiii:set_rgba_bits", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).set_rgba_bits)((int)param1, (int)param2, (int)param3, (int)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rgba_bits(const FrameBufferProperties self, int r, int g, int b, int a)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_rgba_bits_711_comment =
  "C++ Interface:\n"
  "set_rgba_bits(const FrameBufferProperties self, int r, int g, int b, int a)\n"
  "\n"
  "/**\n"
  " * Convenience method for setting the red, green, blue and alpha bits in one\n"
  " * go.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_rgba_bits_711_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_red_bits(int n)
 */
static PyObject *Dtool_FrameBufferProperties_set_red_bits_712(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_red_bits")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_red_bits(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_red_bits)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_red_bits(const FrameBufferProperties self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_red_bits_712_comment =
  "C++ Interface:\n"
  "set_red_bits(const FrameBufferProperties self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_red_bits_712_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_green_bits(int n)
 */
static PyObject *Dtool_FrameBufferProperties_set_green_bits_713(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_green_bits")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_green_bits(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_green_bits)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_green_bits(const FrameBufferProperties self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_green_bits_713_comment =
  "C++ Interface:\n"
  "set_green_bits(const FrameBufferProperties self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_green_bits_713_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_blue_bits(int n)
 */
static PyObject *Dtool_FrameBufferProperties_set_blue_bits_714(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_blue_bits")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_blue_bits(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_blue_bits)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blue_bits(const FrameBufferProperties self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_blue_bits_714_comment =
  "C++ Interface:\n"
  "set_blue_bits(const FrameBufferProperties self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_blue_bits_714_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_alpha_bits(int n)
 */
static PyObject *Dtool_FrameBufferProperties_set_alpha_bits_715(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_alpha_bits")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_alpha_bits(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_alpha_bits)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha_bits(const FrameBufferProperties self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_alpha_bits_715_comment =
  "C++ Interface:\n"
  "set_alpha_bits(const FrameBufferProperties self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_alpha_bits_715_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_stencil_bits(int n)
 */
static PyObject *Dtool_FrameBufferProperties_set_stencil_bits_716(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_stencil_bits")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_stencil_bits(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_stencil_bits)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_stencil_bits(const FrameBufferProperties self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_stencil_bits_716_comment =
  "C++ Interface:\n"
  "set_stencil_bits(const FrameBufferProperties self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_stencil_bits_716_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_accum_bits(int n)
 */
static PyObject *Dtool_FrameBufferProperties_set_accum_bits_717(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_accum_bits")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_accum_bits(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_accum_bits)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_accum_bits(const FrameBufferProperties self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_accum_bits_717_comment =
  "C++ Interface:\n"
  "set_accum_bits(const FrameBufferProperties self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_accum_bits_717_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_aux_rgba(int n)
 */
static PyObject *Dtool_FrameBufferProperties_set_aux_rgba_718(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_aux_rgba")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_aux_rgba(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_aux_rgba)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_aux_rgba(const FrameBufferProperties self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_aux_rgba_718_comment =
  "C++ Interface:\n"
  "set_aux_rgba(const FrameBufferProperties self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_aux_rgba_718_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_aux_hrgba(int n)
 */
static PyObject *Dtool_FrameBufferProperties_set_aux_hrgba_719(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_aux_hrgba")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_aux_hrgba(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_aux_hrgba)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_aux_hrgba(const FrameBufferProperties self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_aux_hrgba_719_comment =
  "C++ Interface:\n"
  "set_aux_hrgba(const FrameBufferProperties self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_aux_hrgba_719_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_aux_float(int n)
 */
static PyObject *Dtool_FrameBufferProperties_set_aux_float_720(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_aux_float")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_aux_float(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_aux_float)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_aux_float(const FrameBufferProperties self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_aux_float_720_comment =
  "C++ Interface:\n"
  "set_aux_float(const FrameBufferProperties self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_aux_float_720_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_multisamples(int n)
 */
static PyObject *Dtool_FrameBufferProperties_set_multisamples_721(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_multisamples")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_multisamples(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_multisamples)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_multisamples(const FrameBufferProperties self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_multisamples_721_comment =
  "C++ Interface:\n"
  "set_multisamples(const FrameBufferProperties self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_multisamples_721_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_coverage_samples(int n)
 */
static PyObject *Dtool_FrameBufferProperties_set_coverage_samples_722(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_coverage_samples")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_coverage_samples(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_coverage_samples)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_coverage_samples(const FrameBufferProperties self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_coverage_samples_722_comment =
  "C++ Interface:\n"
  "set_coverage_samples(const FrameBufferProperties self, int n)\n"
  "\n"
  "/**\n"
  " * If coverage samples are specified, and there is hardware support, we use\n"
  " * coverage multisampling\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_coverage_samples_722_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_back_buffers(int n)
 */
static PyObject *Dtool_FrameBufferProperties_set_back_buffers_723(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_back_buffers")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_back_buffers(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_back_buffers)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_back_buffers(const FrameBufferProperties self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_back_buffers_723_comment =
  "C++ Interface:\n"
  "set_back_buffers(const FrameBufferProperties self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_back_buffers_723_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_indexed_color(bool n)
 */
static PyObject *Dtool_FrameBufferProperties_set_indexed_color_724(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_indexed_color")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_indexed_color(bool n)
  ((*local_this).set_indexed_color)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_indexed_color(const FrameBufferProperties self, bool n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_indexed_color_724_comment =
  "C++ Interface:\n"
  "set_indexed_color(const FrameBufferProperties self, bool n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_indexed_color_724_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_rgb_color(bool n)
 */
static PyObject *Dtool_FrameBufferProperties_set_rgb_color_725(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_rgb_color")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_rgb_color(bool n)
  ((*local_this).set_rgb_color)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rgb_color(const FrameBufferProperties self, bool n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_rgb_color_725_comment =
  "C++ Interface:\n"
  "set_rgb_color(const FrameBufferProperties self, bool n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_rgb_color_725_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_stereo(bool n)
 */
static PyObject *Dtool_FrameBufferProperties_set_stereo_726(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_stereo")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_stereo(bool n)
  ((*local_this).set_stereo)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_stereo(const FrameBufferProperties self, bool n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_stereo_726_comment =
  "C++ Interface:\n"
  "set_stereo(const FrameBufferProperties self, bool n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_stereo_726_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_force_hardware(bool n)
 */
static PyObject *Dtool_FrameBufferProperties_set_force_hardware_727(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_force_hardware")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_force_hardware(bool n)
  ((*local_this).set_force_hardware)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_force_hardware(const FrameBufferProperties self, bool n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_force_hardware_727_comment =
  "C++ Interface:\n"
  "set_force_hardware(const FrameBufferProperties self, bool n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_force_hardware_727_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_force_software(bool n)
 */
static PyObject *Dtool_FrameBufferProperties_set_force_software_728(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_force_software")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_force_software(bool n)
  ((*local_this).set_force_software)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_force_software(const FrameBufferProperties self, bool n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_force_software_728_comment =
  "C++ Interface:\n"
  "set_force_software(const FrameBufferProperties self, bool n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_force_software_728_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_srgb_color(bool n)
 */
static PyObject *Dtool_FrameBufferProperties_set_srgb_color_729(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_srgb_color")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_srgb_color(bool n)
  ((*local_this).set_srgb_color)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_srgb_color(const FrameBufferProperties self, bool n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_srgb_color_729_comment =
  "C++ Interface:\n"
  "set_srgb_color(const FrameBufferProperties self, bool n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_srgb_color_729_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_float_color(bool n)
 */
static PyObject *Dtool_FrameBufferProperties_set_float_color_730(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_float_color")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_float_color(bool n)
  ((*local_this).set_float_color)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_float_color(const FrameBufferProperties self, bool n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_float_color_730_comment =
  "C++ Interface:\n"
  "set_float_color(const FrameBufferProperties self, bool n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_float_color_730_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void FrameBufferProperties::set_float_depth(bool n)
 */
static PyObject *Dtool_FrameBufferProperties_set_float_depth_731(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_float_depth")) {
    return nullptr;
  }
  // 1-inline void FrameBufferProperties::set_float_depth(bool n)
  ((*local_this).set_float_depth)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_float_depth(const FrameBufferProperties self, bool n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_float_depth_731_comment =
  "C++ Interface:\n"
  "set_float_depth(const FrameBufferProperties self, bool n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_float_depth_731_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static FrameBufferProperties const &FrameBufferProperties::get_default(void)
 */
static PyObject *Dtool_FrameBufferProperties_get_default_755(PyObject *, PyObject *) {
  // 1-static FrameBufferProperties const &FrameBufferProperties::get_default(void)
  FrameBufferProperties const *return_value = &((FrameBufferProperties::get_default)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_FrameBufferProperties, false, true);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_default_755_comment =
  "C++ Interface:\n"
  "get_default()\n"
  "\n"
  "/**\n"
  " * Returns a FrameBufferProperties structure with all of the default values\n"
  " * filled in according to the user's config file.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_default_755_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void FrameBufferProperties::clear(void)
 */
static PyObject *Dtool_FrameBufferProperties_clear_758(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.clear")) {
    return nullptr;
  }
  // 1-void FrameBufferProperties::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_clear_758_comment =
  "C++ Interface:\n"
  "clear(const FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " * Unsets all properties that have been specified so far, and resets the\n"
  " * FrameBufferProperties structure to its initial empty state.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_clear_758_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void FrameBufferProperties::set_all_specified(void)
 */
static PyObject *Dtool_FrameBufferProperties_set_all_specified_759(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_all_specified")) {
    return nullptr;
  }
  // 1-void FrameBufferProperties::set_all_specified(void)
  ((*local_this).set_all_specified)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_all_specified_759_comment =
  "C++ Interface:\n"
  "set_all_specified(const FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " * Marks all bits as having been specified.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_all_specified_759_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool FrameBufferProperties::subsumes(FrameBufferProperties const &other) const
 */
static PyObject *Dtool_FrameBufferProperties_subsumes_760(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-bool FrameBufferProperties::subsumes(FrameBufferProperties const &other) const
  FrameBufferProperties const *arg_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_FrameBufferProperties, 1, "FrameBufferProperties.subsumes", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const FrameBufferProperties*)local_this).subsumes)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "subsumes(FrameBufferProperties self, const FrameBufferProperties other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_subsumes_760_comment =
  "C++ Interface:\n"
  "subsumes(FrameBufferProperties self, const FrameBufferProperties other)\n"
  "\n"
  "/**\n"
  " * Returns true if this set of properties makes strictly greater or equal\n"
  " * demands of the framebuffer than the other set of framebuffer properties.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_subsumes_760_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void FrameBufferProperties::add_properties(FrameBufferProperties const &other)
 */
static PyObject *Dtool_FrameBufferProperties_add_properties_761(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.add_properties")) {
    return nullptr;
  }
  // 1-void FrameBufferProperties::add_properties(FrameBufferProperties const &other)
  FrameBufferProperties const *arg_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_FrameBufferProperties, 1, "FrameBufferProperties.add_properties", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_properties)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_properties(const FrameBufferProperties self, const FrameBufferProperties other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_add_properties_761_comment =
  "C++ Interface:\n"
  "add_properties(const FrameBufferProperties self, const FrameBufferProperties other)\n"
  "\n"
  "/**\n"
  " * Sets any properties that are explicitly specified in other on this object.\n"
  " * Leaves other properties unchanged.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_add_properties_761_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void FrameBufferProperties::output(std::ostream &out) const
 */
static PyObject *Dtool_FrameBufferProperties_output_762(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-void FrameBufferProperties::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "FrameBufferProperties.output", false, true);
  if (arg_this != nullptr) {
    ((*(const FrameBufferProperties*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(FrameBufferProperties self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_output_762_comment =
  "C++ Interface:\n"
  "output(FrameBufferProperties self, ostream out)\n"
  "\n"
  "/**\n"
  " * Generates a string representation.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_output_762_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void FrameBufferProperties::set_one_bit_per_channel(void)
 */
static PyObject *Dtool_FrameBufferProperties_set_one_bit_per_channel_763(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.set_one_bit_per_channel")) {
    return nullptr;
  }
  // 1-void FrameBufferProperties::set_one_bit_per_channel(void)
  ((*local_this).set_one_bit_per_channel)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_set_one_bit_per_channel_763_comment =
  "C++ Interface:\n"
  "set_one_bit_per_channel(const FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " * If any of the depth, color, alpha, accum, or stencil properties is set to\n"
  " * more than one, then they are reduced to one.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_set_one_bit_per_channel_763_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool FrameBufferProperties::is_stereo(void) const
 */
static PyObject *Dtool_FrameBufferProperties_is_stereo_764(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline bool FrameBufferProperties::is_stereo(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).is_stereo)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_is_stereo_764_comment =
  "C++ Interface:\n"
  "is_stereo(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_is_stereo_764_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool FrameBufferProperties::is_single_buffered(void) const
 */
static PyObject *Dtool_FrameBufferProperties_is_single_buffered_765(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-inline bool FrameBufferProperties::is_single_buffered(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).is_single_buffered)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_is_single_buffered_765_comment =
  "C++ Interface:\n"
  "is_single_buffered(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_is_single_buffered_765_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int FrameBufferProperties::get_quality(FrameBufferProperties const &reqs) const
 */
static PyObject *Dtool_FrameBufferProperties_get_quality_766(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-int FrameBufferProperties::get_quality(FrameBufferProperties const &reqs) const
  FrameBufferProperties const *arg_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_FrameBufferProperties, 1, "FrameBufferProperties.get_quality", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const FrameBufferProperties*)local_this).get_quality)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_quality(FrameBufferProperties self, const FrameBufferProperties reqs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_quality_766_comment =
  "C++ Interface:\n"
  "get_quality(FrameBufferProperties self, const FrameBufferProperties reqs)\n"
  "\n"
  "/**\n"
  " * Assumes that these properties are a description of a window.\n"
  " *\n"
  " * Measures how well this window satisfies a specified set of requirements.  A\n"
  " * higher quality number means that more requirements were satisfied.  A\n"
  " * quality of zero means that the window is unsuitable.\n"
  " *\n"
  " * The routine deducts a lot if the window fails to provide a requested\n"
  " * feature.  It deducts less if the window provides a feature, but at a\n"
  " * degraded level of functionality (ie, the user asks for rgba8, color, but\n"
  " * the window only provides rgba4).  The routine also deducts a small amount\n"
  " * for unnecessary features.  For example, if the window has an accumulation\n"
  " * buffer when one is not requested will reduce quality slightly.  Maximum\n"
  " * quality is obtained when the window exactly matches the request.\n"
  " *\n"
  " * If you want to know whether the window satisfies all of the requirements,\n"
  " * use the \"subsumes\" function.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_quality_766_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool FrameBufferProperties::is_any_specified(void) const
 */
static PyObject *Dtool_FrameBufferProperties_is_any_specified_767(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-bool FrameBufferProperties::is_any_specified(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).is_any_specified)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_is_any_specified_767_comment =
  "C++ Interface:\n"
  "is_any_specified(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if any properties have been specified, false otherwise.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_is_any_specified_767_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool FrameBufferProperties::is_basic(void) const
 */
static PyObject *Dtool_FrameBufferProperties_is_basic_768(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-bool FrameBufferProperties::is_basic(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).is_basic)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_is_basic_768_comment =
  "C++ Interface:\n"
  "is_basic(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " * Returns true if the properties are extremely basic.  The following count as\n"
  " * basic: rgb or rgba, depth.  If anything else is specified, the properties\n"
  " * are non-basic.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_is_basic_768_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int FrameBufferProperties::get_aux_mask(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_aux_mask_769(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-int FrameBufferProperties::get_aux_mask(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_aux_mask)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_aux_mask_769_comment =
  "C++ Interface:\n"
  "get_aux_mask(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " * Converts the aux bitplanes of the framebuffer into a RenderBuffer::Type.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_aux_mask_769_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int FrameBufferProperties::get_buffer_mask(void) const
 */
static PyObject *Dtool_FrameBufferProperties_get_buffer_mask_770(PyObject *self, PyObject *) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-int FrameBufferProperties::get_buffer_mask(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_buffer_mask)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_get_buffer_mask_770_comment =
  "C++ Interface:\n"
  "get_buffer_mask(FrameBufferProperties self)\n"
  "\n"
  "/**\n"
  " * Converts the non-aux bitplanes of the framebuffer into a\n"
  " * RenderBuffer::Type.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_get_buffer_mask_770_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool FrameBufferProperties::verify_hardware_software(FrameBufferProperties const &props, std::string const &renderer) const
 */
static PyObject *Dtool_FrameBufferProperties_verify_hardware_software_771(PyObject *self, PyObject *args, PyObject *kwds) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-bool FrameBufferProperties::verify_hardware_software(FrameBufferProperties const &props, std::string const &renderer) const
  PyObject *param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"props", "renderer", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:verify_hardware_software", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    FrameBufferProperties const *param1_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_FrameBufferProperties, 1, "FrameBufferProperties.verify_hardware_software", true, true);
    if (param1_this != nullptr) {
      bool return_value = ((*(const FrameBufferProperties*)local_this).verify_hardware_software)(*param1_this, std::string(param2_str, param2_len));
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "verify_hardware_software(FrameBufferProperties self, const FrameBufferProperties props, str renderer)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_verify_hardware_software_771_comment =
  "C++ Interface:\n"
  "verify_hardware_software(FrameBufferProperties self, const FrameBufferProperties props, str renderer)\n"
  "\n"
  "/**\n"
  " * Validates that the properties represent the desired kind of renderer\n"
  " * (hardware or software).  If not, prints out an error message and returns\n"
  " * false.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_verify_hardware_software_771_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool FrameBufferProperties::setup_color_texture(Texture *tex) const
 */
static PyObject *Dtool_FrameBufferProperties_setup_color_texture_772(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-bool FrameBufferProperties::setup_color_texture(Texture *tex) const
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "FrameBufferProperties.setup_color_texture", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const FrameBufferProperties*)local_this).setup_color_texture)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_color_texture(FrameBufferProperties self, Texture tex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_setup_color_texture_772_comment =
  "C++ Interface:\n"
  "setup_color_texture(FrameBufferProperties self, Texture tex)\n"
  "\n"
  "/**\n"
  " * Sets the texture up for render-to-texture matching these framebuffer\n"
  " * properties.\n"
  " *\n"
  " * Returns true if there was a format that had enough bits, false otherwise.\n"
  " * Of course, this is no guarantee that a particular graphics back-end\n"
  " * supports rendering to textures of that format.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_setup_color_texture_772_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool FrameBufferProperties::setup_depth_texture(Texture *tex) const
 */
static PyObject *Dtool_FrameBufferProperties_setup_depth_texture_773(PyObject *self, PyObject *arg) {
  FrameBufferProperties *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FrameBufferProperties)) {
    return nullptr;
  }
  // 1-bool FrameBufferProperties::setup_depth_texture(Texture *tex) const
  Texture *arg_this = (Texture *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Texture, 1, "FrameBufferProperties.setup_depth_texture", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const FrameBufferProperties*)local_this).setup_depth_texture)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_depth_texture(FrameBufferProperties self, Texture tex)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_FrameBufferProperties_setup_depth_texture_773_comment =
  "C++ Interface:\n"
  "setup_depth_texture(FrameBufferProperties self, Texture tex)\n"
  "\n"
  "/**\n"
  " * Sets the texture up for render-to-texture matching these framebuffer\n"
  " * properties.\n"
  " *\n"
  " * Returns true if there was a format that had enough bits, false otherwise.\n"
  " * Of course, this is no guarantee that a particular graphics back-end\n"
  " * supports rendering to textures of that format.\n"
  " */";
#else
static const char *Dtool_FrameBufferProperties_setup_depth_texture_773_comment = nullptr;
#endif

static PyObject *Dtool_FrameBufferProperties_depth_bits_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int FrameBufferProperties::get_depth_bits(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_depth_bits)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_depth_bits_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.depth_bits")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete depth_bits attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_depth_bits(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_depth_bits)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_depth_bits(const FrameBufferProperties self, int n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_color_bits_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int FrameBufferProperties::get_color_bits(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_color_bits)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_color_bits_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.color_bits")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete color_bits attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_color_bits(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_color_bits)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_color_bits(const FrameBufferProperties self, int n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_red_bits_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int FrameBufferProperties::get_red_bits(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_red_bits)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_red_bits_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.red_bits")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete red_bits attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_red_bits(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_red_bits)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_red_bits(const FrameBufferProperties self, int n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_green_bits_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int FrameBufferProperties::get_green_bits(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_green_bits)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_green_bits_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.green_bits")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete green_bits attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_green_bits(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_green_bits)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_green_bits(const FrameBufferProperties self, int n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_blue_bits_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int FrameBufferProperties::get_blue_bits(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_blue_bits)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_blue_bits_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.blue_bits")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete blue_bits attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_blue_bits(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_blue_bits)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_blue_bits(const FrameBufferProperties self, int n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_alpha_bits_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int FrameBufferProperties::get_alpha_bits(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_alpha_bits)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_alpha_bits_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.alpha_bits")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete alpha_bits attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_alpha_bits(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_alpha_bits)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_alpha_bits(const FrameBufferProperties self, int n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_stencil_bits_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int FrameBufferProperties::get_stencil_bits(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_stencil_bits)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_stencil_bits_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.stencil_bits")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete stencil_bits attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_stencil_bits(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_stencil_bits)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_stencil_bits(const FrameBufferProperties self, int n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_accum_bits_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int FrameBufferProperties::get_accum_bits(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_accum_bits)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_accum_bits_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.accum_bits")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete accum_bits attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_accum_bits(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_accum_bits)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_accum_bits(const FrameBufferProperties self, int n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_aux_rgba_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int FrameBufferProperties::get_aux_rgba(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_aux_rgba)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_aux_rgba_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.aux_rgba")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete aux_rgba attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_aux_rgba(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_aux_rgba)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_aux_rgba(const FrameBufferProperties self, int n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_aux_hrgba_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int FrameBufferProperties::get_aux_hrgba(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_aux_hrgba)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_aux_hrgba_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.aux_hrgba")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete aux_hrgba attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_aux_hrgba(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_aux_hrgba)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_aux_hrgba(const FrameBufferProperties self, int n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_aux_float_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int FrameBufferProperties::get_aux_float(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_aux_float)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_aux_float_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.aux_float")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete aux_float attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_aux_float(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_aux_float)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_aux_float(const FrameBufferProperties self, int n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_multisamples_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int FrameBufferProperties::get_multisamples(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_multisamples)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_multisamples_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.multisamples")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete multisamples attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_multisamples(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_multisamples)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_multisamples(const FrameBufferProperties self, int n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_coverage_samples_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int FrameBufferProperties::get_coverage_samples(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_coverage_samples)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_coverage_samples_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.coverage_samples")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete coverage_samples attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_coverage_samples(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_coverage_samples)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_coverage_samples(const FrameBufferProperties self, int n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_back_buffers_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int FrameBufferProperties::get_back_buffers(void) const
  int return_value = ((*(const FrameBufferProperties*)local_this).get_back_buffers)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_back_buffers_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.back_buffers")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete back_buffers attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_back_buffers(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_back_buffers)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_back_buffers(const FrameBufferProperties self, int n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_indexed_color_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool FrameBufferProperties::get_indexed_color(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).get_indexed_color)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_indexed_color_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.indexed_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete indexed_color attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_indexed_color(bool n)
  ((*local_this).set_indexed_color)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_indexed_color(const FrameBufferProperties self, bool n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_rgb_color_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool FrameBufferProperties::get_rgb_color(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).get_rgb_color)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_rgb_color_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.rgb_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete rgb_color attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_rgb_color(bool n)
  ((*local_this).set_rgb_color)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_rgb_color(const FrameBufferProperties self, bool n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_stereo_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool FrameBufferProperties::get_stereo(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).get_stereo)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_stereo_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.stereo")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete stereo attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_stereo(bool n)
  ((*local_this).set_stereo)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_stereo(const FrameBufferProperties self, bool n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_force_hardware_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool FrameBufferProperties::get_force_hardware(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).get_force_hardware)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_force_hardware_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.force_hardware")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete force_hardware attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_force_hardware(bool n)
  ((*local_this).set_force_hardware)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_force_hardware(const FrameBufferProperties self, bool n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_force_software_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool FrameBufferProperties::get_force_software(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).get_force_software)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_force_software_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.force_software")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete force_software attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_force_software(bool n)
  ((*local_this).set_force_software)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_force_software(const FrameBufferProperties self, bool n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_srgb_color_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool FrameBufferProperties::get_srgb_color(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).get_srgb_color)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_srgb_color_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.srgb_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete srgb_color attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_srgb_color(bool n)
  ((*local_this).set_srgb_color)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_srgb_color(const FrameBufferProperties self, bool n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_float_color_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool FrameBufferProperties::get_float_color(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).get_float_color)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_float_color_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.float_color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete float_color attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_float_color(bool n)
  ((*local_this).set_float_color)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_float_color(const FrameBufferProperties self, bool n)\n");
  }
  return -1;
}

static PyObject *Dtool_FrameBufferProperties_float_depth_Getter(PyObject *self, void *) {
  const FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool FrameBufferProperties::get_float_depth(void) const
  bool return_value = ((*(const FrameBufferProperties*)local_this).get_float_depth)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_FrameBufferProperties_float_depth_Setter(PyObject *self, PyObject *arg, void *) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_FrameBufferProperties, (void **)&local_this, "FrameBufferProperties.float_depth")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete float_depth attribute");
    return -1;
  }
  // 1-inline void FrameBufferProperties::set_float_depth(bool n)
  ((*local_this).set_float_depth)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_float_depth(const FrameBufferProperties self, bool n)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * constexpr FrameBufferProperties::FrameBufferProperties(void) = default
 * inline FrameBufferProperties::FrameBufferProperties(FrameBufferProperties const &) = default
 */
static int Dtool_Init_FrameBufferProperties(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("FrameBufferProperties() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-constexpr FrameBufferProperties::FrameBufferProperties(void) = default
      FrameBufferProperties *return_value = new FrameBufferProperties();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FrameBufferProperties, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline FrameBufferProperties::FrameBufferProperties(FrameBufferProperties const &) = default
      FrameBufferProperties const *arg_this = (FrameBufferProperties *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_FrameBufferProperties, 0, "FrameBufferProperties.FrameBufferProperties", true, true);
      if (arg_this != nullptr) {
        FrameBufferProperties *return_value = new FrameBufferProperties(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FrameBufferProperties, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "FrameBufferProperties() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "FrameBufferProperties()\n"
      "FrameBufferProperties(const FrameBufferProperties param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_FrameBufferProperties(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_FrameBufferProperties) {
    printf("FrameBufferProperties ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  FrameBufferProperties *local_this = (FrameBufferProperties *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_FrameBufferProperties) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_FrameBufferProperties(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_FrameBufferProperties) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GraphicsWindowInputDevice
 */
/**
 * Python function wrapper for:
 * void GraphicsWindowInputDevice::button_down(ButtonHandle button, double time = ClockObject::get_global_clock()->get_frame_time())
 */
static PyObject *Dtool_GraphicsWindowInputDevice_button_down_777(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsWindowInputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindowInputDevice, (void **)&local_this, "GraphicsWindowInputDevice.button_down")) {
    return nullptr;
  }
  // 1-void GraphicsWindowInputDevice::button_down(ButtonHandle button, double time = ClockObject::get_global_clock()->get_frame_time())
  PyObject *param1;
  double param2 = ClockObject::get_global_clock()->get_frame_time();
  static const char *keyword_list[] = {"button", "time", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|d:button_down", (char **)keyword_list, &param1, &param2)) {
    ButtonHandle param1_local;
    ButtonHandle *param1_this = Dtool_Coerce_ButtonHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "GraphicsWindowInputDevice.button_down", "ButtonHandle");
    }
    ((*local_this).button_down)(*param1_this, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "button_down(const GraphicsWindowInputDevice self, ButtonHandle button, double time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowInputDevice_button_down_777_comment =
  "C++ Interface:\n"
  "button_down(const GraphicsWindowInputDevice self, ButtonHandle button, double time)\n"
  "\n"
  "// The following interface is for the various kinds of GraphicsWindows to\n"
  "// record the data incoming on the device.\n"
  "\n"
  "/**\n"
  " * Records that the indicated button has been depressed.\n"
  " */";
#else
static const char *Dtool_GraphicsWindowInputDevice_button_down_777_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsWindowInputDevice::button_resume_down(ButtonHandle button, double time = ClockObject::get_global_clock()->get_frame_time())
 */
static PyObject *Dtool_GraphicsWindowInputDevice_button_resume_down_778(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsWindowInputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindowInputDevice, (void **)&local_this, "GraphicsWindowInputDevice.button_resume_down")) {
    return nullptr;
  }
  // 1-void GraphicsWindowInputDevice::button_resume_down(ButtonHandle button, double time = ClockObject::get_global_clock()->get_frame_time())
  PyObject *param1;
  double param2 = ClockObject::get_global_clock()->get_frame_time();
  static const char *keyword_list[] = {"button", "time", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|d:button_resume_down", (char **)keyword_list, &param1, &param2)) {
    ButtonHandle param1_local;
    ButtonHandle *param1_this = Dtool_Coerce_ButtonHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "GraphicsWindowInputDevice.button_resume_down", "ButtonHandle");
    }
    ((*local_this).button_resume_down)(*param1_this, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "button_resume_down(const GraphicsWindowInputDevice self, ButtonHandle button, double time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowInputDevice_button_resume_down_778_comment =
  "C++ Interface:\n"
  "button_resume_down(const GraphicsWindowInputDevice self, ButtonHandle button, double time)\n"
  "\n"
  "/**\n"
  " * Records that the indicated button was depressed earlier, and we only just\n"
  " * detected the event after the fact.  This is mainly useful for tracking the\n"
  " * state of modifier keys.\n"
  " */";
#else
static const char *Dtool_GraphicsWindowInputDevice_button_resume_down_778_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsWindowInputDevice::button_up(ButtonHandle button, double time = ClockObject::get_global_clock()->get_frame_time())
 */
static PyObject *Dtool_GraphicsWindowInputDevice_button_up_779(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsWindowInputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindowInputDevice, (void **)&local_this, "GraphicsWindowInputDevice.button_up")) {
    return nullptr;
  }
  // 1-void GraphicsWindowInputDevice::button_up(ButtonHandle button, double time = ClockObject::get_global_clock()->get_frame_time())
  PyObject *param1;
  double param2 = ClockObject::get_global_clock()->get_frame_time();
  static const char *keyword_list[] = {"button", "time", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|d:button_up", (char **)keyword_list, &param1, &param2)) {
    ButtonHandle param1_local;
    ButtonHandle *param1_this = Dtool_Coerce_ButtonHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "GraphicsWindowInputDevice.button_up", "ButtonHandle");
    }
    ((*local_this).button_up)(*param1_this, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "button_up(const GraphicsWindowInputDevice self, ButtonHandle button, double time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowInputDevice_button_up_779_comment =
  "C++ Interface:\n"
  "button_up(const GraphicsWindowInputDevice self, ButtonHandle button, double time)\n"
  "\n"
  "/**\n"
  " * Records that the indicated button has been released.\n"
  " */";
#else
static const char *Dtool_GraphicsWindowInputDevice_button_up_779_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsWindowInputDevice::keystroke(int keycode, double time = ClockObject::get_global_clock()->get_frame_time())
 */
static PyObject *Dtool_GraphicsWindowInputDevice_keystroke_780(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsWindowInputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindowInputDevice, (void **)&local_this, "GraphicsWindowInputDevice.keystroke")) {
    return nullptr;
  }
  // 1-void GraphicsWindowInputDevice::keystroke(int keycode, double time = ClockObject::get_global_clock()->get_frame_time())
  int param1;
  double param2 = ClockObject::get_global_clock()->get_frame_time();
  static const char *keyword_list[] = {"keycode", "time", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|d:keystroke", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).keystroke)((int)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "keystroke(const GraphicsWindowInputDevice self, int keycode, double time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowInputDevice_keystroke_780_comment =
  "C++ Interface:\n"
  "keystroke(const GraphicsWindowInputDevice self, int keycode, double time)\n"
  "\n"
  "/**\n"
  " * Records that the indicated keystroke has been generated.\n"
  " */";
#else
static const char *Dtool_GraphicsWindowInputDevice_keystroke_780_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsWindowInputDevice::candidate(std::wstring const &candidate_string, std::size_t highlight_start, std::size_t highlight_end, std::size_t cursor_pos)
 */
static PyObject *Dtool_GraphicsWindowInputDevice_candidate_781(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsWindowInputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindowInputDevice, (void **)&local_this, "GraphicsWindowInputDevice.candidate")) {
    return nullptr;
  }
  // 1-void GraphicsWindowInputDevice::candidate(std::wstring const &candidate_string, std::size_t highlight_start, std::size_t highlight_end, std::size_t cursor_pos)
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
#else
  PyUnicodeObject *param1;
#endif
  Py_ssize_t param2;
  Py_ssize_t param3;
  Py_ssize_t param4;
  static const char *keyword_list[] = {"candidate_string", "highlight_start", "highlight_end", "cursor_pos", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Unnn:candidate", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
#ifndef NDEBUG
    if (param3 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param3);
    }
#endif
#ifndef NDEBUG
    if (param4 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param4);
    }
#endif
    ((*local_this).candidate)(std::wstring(param1_str, param1_len), (std::size_t)param2, (std::size_t)param3, (std::size_t)param4);
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "candidate(const GraphicsWindowInputDevice self, unicode candidate_string, int highlight_start, int highlight_end, int cursor_pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowInputDevice_candidate_781_comment =
  "C++ Interface:\n"
  "candidate(const GraphicsWindowInputDevice self, unicode candidate_string, int highlight_start, int highlight_end, int cursor_pos)\n"
  "\n"
  "/**\n"
  " * Records that the indicated candidate string has been highlighted.  This is\n"
  " * used to implement IME support for typing in international languages,\n"
  " * especially Chinese/Japanese/Korean.\n"
  " */";
#else
static const char *Dtool_GraphicsWindowInputDevice_candidate_781_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsWindowInputDevice::focus_lost(double time = ClockObject::get_global_clock()->get_frame_time())
 */
static PyObject *Dtool_GraphicsWindowInputDevice_focus_lost_782(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsWindowInputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindowInputDevice, (void **)&local_this, "GraphicsWindowInputDevice.focus_lost")) {
    return nullptr;
  }
  // 1-void GraphicsWindowInputDevice::focus_lost(double time = ClockObject::get_global_clock()->get_frame_time())
  double param1 = ClockObject::get_global_clock()->get_frame_time();
  static const char *keyword_list[] = {"time", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|d:focus_lost", (char **)keyword_list, &param1)) {
    ((*local_this).focus_lost)((double)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "focus_lost(const GraphicsWindowInputDevice self, double time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowInputDevice_focus_lost_782_comment =
  "C++ Interface:\n"
  "focus_lost(const GraphicsWindowInputDevice self, double time)\n"
  "\n"
  "/**\n"
  " * This should be called when the window focus is lost, so that we may miss\n"
  " * upcoming button events (especially \"up\" events) for the next period of\n"
  " * time.  It generates keyboard and mouse \"up\" events for those buttons that\n"
  " * we previously sent unpaired \"down\" events, so that the Panda application\n"
  " * will believe all buttons are now released.\n"
  " */";
#else
static const char *Dtool_GraphicsWindowInputDevice_focus_lost_782_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsWindowInputDevice::raw_button_down(ButtonHandle button, double time = ClockObject::get_global_clock()->get_frame_time())
 */
static PyObject *Dtool_GraphicsWindowInputDevice_raw_button_down_783(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsWindowInputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindowInputDevice, (void **)&local_this, "GraphicsWindowInputDevice.raw_button_down")) {
    return nullptr;
  }
  // 1-void GraphicsWindowInputDevice::raw_button_down(ButtonHandle button, double time = ClockObject::get_global_clock()->get_frame_time())
  PyObject *param1;
  double param2 = ClockObject::get_global_clock()->get_frame_time();
  static const char *keyword_list[] = {"button", "time", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|d:raw_button_down", (char **)keyword_list, &param1, &param2)) {
    ButtonHandle param1_local;
    ButtonHandle *param1_this = Dtool_Coerce_ButtonHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "GraphicsWindowInputDevice.raw_button_down", "ButtonHandle");
    }
    ((*local_this).raw_button_down)(*param1_this, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_button_down(const GraphicsWindowInputDevice self, ButtonHandle button, double time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowInputDevice_raw_button_down_783_comment =
  "C++ Interface:\n"
  "raw_button_down(const GraphicsWindowInputDevice self, ButtonHandle button, double time)\n"
  "\n"
  "/**\n"
  " * Records that the indicated button has been depressed.\n"
  " */";
#else
static const char *Dtool_GraphicsWindowInputDevice_raw_button_down_783_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsWindowInputDevice::raw_button_up(ButtonHandle button, double time = ClockObject::get_global_clock()->get_frame_time())
 */
static PyObject *Dtool_GraphicsWindowInputDevice_raw_button_up_784(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsWindowInputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindowInputDevice, (void **)&local_this, "GraphicsWindowInputDevice.raw_button_up")) {
    return nullptr;
  }
  // 1-void GraphicsWindowInputDevice::raw_button_up(ButtonHandle button, double time = ClockObject::get_global_clock()->get_frame_time())
  PyObject *param1;
  double param2 = ClockObject::get_global_clock()->get_frame_time();
  static const char *keyword_list[] = {"button", "time", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|d:raw_button_up", (char **)keyword_list, &param1, &param2)) {
    ButtonHandle param1_local;
    ButtonHandle *param1_this = Dtool_Coerce_ButtonHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "GraphicsWindowInputDevice.raw_button_up", "ButtonHandle");
    }
    ((*local_this).raw_button_up)(*param1_this, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "raw_button_up(const GraphicsWindowInputDevice self, ButtonHandle button, double time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowInputDevice_raw_button_up_784_comment =
  "C++ Interface:\n"
  "raw_button_up(const GraphicsWindowInputDevice self, ButtonHandle button, double time)\n"
  "\n"
  "/**\n"
  " * Records that the indicated button has been released.\n"
  " */";
#else
static const char *Dtool_GraphicsWindowInputDevice_raw_button_up_784_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerData GraphicsWindowInputDevice::get_pointer(void) const
 */
static PyObject *Dtool_GraphicsWindowInputDevice_get_pointer_785(PyObject *self, PyObject *) {
  GraphicsWindowInputDevice *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsWindowInputDevice)) {
    return nullptr;
  }
  // 1-inline PointerData GraphicsWindowInputDevice::get_pointer(void) const
  PointerData *return_value = new PointerData(((*(const GraphicsWindowInputDevice*)local_this).get_pointer)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerData, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowInputDevice_get_pointer_785_comment =
  "C++ Interface:\n"
  "get_pointer(GraphicsWindowInputDevice self)\n"
  "\n"
  "/**\n"
  " * Returns the PointerData associated with the input device's pointer.  This\n"
  " * only makes sense if has_pointer() also returns true.\n"
  " */";
#else
static const char *Dtool_GraphicsWindowInputDevice_get_pointer_785_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsWindowInputDevice::set_pointer_in_window(double x, double y, double time = ClockObject::get_global_clock()->get_frame_time())
 */
static PyObject *Dtool_GraphicsWindowInputDevice_set_pointer_in_window_786(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsWindowInputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindowInputDevice, (void **)&local_this, "GraphicsWindowInputDevice.set_pointer_in_window")) {
    return nullptr;
  }
  // 1-void GraphicsWindowInputDevice::set_pointer_in_window(double x, double y, double time = ClockObject::get_global_clock()->get_frame_time())
  double param1;
  double param2;
  double param3 = ClockObject::get_global_clock()->get_frame_time();
  static const char *keyword_list[] = {"x", "y", "time", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dd|d:set_pointer_in_window", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_pointer_in_window)((double)param1, (double)param2, (double)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pointer_in_window(const GraphicsWindowInputDevice self, double x, double y, double time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowInputDevice_set_pointer_in_window_786_comment =
  "C++ Interface:\n"
  "set_pointer_in_window(const GraphicsWindowInputDevice self, double x, double y, double time)\n"
  "\n"
  "/**\n"
  " * To be called by a particular kind of GraphicsWindow to indicate that the\n"
  " * pointer is within the window, at the given pixel coordinates.\n"
  " */";
#else
static const char *Dtool_GraphicsWindowInputDevice_set_pointer_in_window_786_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsWindowInputDevice::set_pointer_out_of_window(double time = ClockObject::get_global_clock()->get_frame_time())
 */
static PyObject *Dtool_GraphicsWindowInputDevice_set_pointer_out_of_window_787(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsWindowInputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindowInputDevice, (void **)&local_this, "GraphicsWindowInputDevice.set_pointer_out_of_window")) {
    return nullptr;
  }
  // 1-void GraphicsWindowInputDevice::set_pointer_out_of_window(double time = ClockObject::get_global_clock()->get_frame_time())
  double param1 = ClockObject::get_global_clock()->get_frame_time();
  static const char *keyword_list[] = {"time", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|d:set_pointer_out_of_window", (char **)keyword_list, &param1)) {
    ((*local_this).set_pointer_out_of_window)((double)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pointer_out_of_window(const GraphicsWindowInputDevice self, double time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowInputDevice_set_pointer_out_of_window_787_comment =
  "C++ Interface:\n"
  "set_pointer_out_of_window(const GraphicsWindowInputDevice self, double time)\n"
  "\n"
  "/**\n"
  " * To be called by a particular kind of GraphicsWindow to indicate that the\n"
  " * pointer is no longer within the window.\n"
  " */";
#else
static const char *Dtool_GraphicsWindowInputDevice_set_pointer_out_of_window_787_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsWindowInputDevice::update_pointer(PointerData data, double time = ClockObject::get_global_clock()->get_frame_time())
 */
static PyObject *Dtool_GraphicsWindowInputDevice_update_pointer_788(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsWindowInputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindowInputDevice, (void **)&local_this, "GraphicsWindowInputDevice.update_pointer")) {
    return nullptr;
  }
  // 1-inline void GraphicsWindowInputDevice::update_pointer(PointerData data, double time = ClockObject::get_global_clock()->get_frame_time())
  PyObject *param1;
  double param2 = ClockObject::get_global_clock()->get_frame_time();
  static const char *keyword_list[] = {"data", "time", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|d:update_pointer", (char **)keyword_list, &param1, &param2)) {
    PointerData *param1_this = (PointerData *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PointerData, 1, "GraphicsWindowInputDevice.update_pointer", true, true);
    if (param1_this != nullptr) {
      ((*local_this).update_pointer)(*param1_this, (double)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "update_pointer(const GraphicsWindowInputDevice self, PointerData data, double time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowInputDevice_update_pointer_788_comment =
  "C++ Interface:\n"
  "update_pointer(const GraphicsWindowInputDevice self, PointerData data, double time)\n"
  "\n"
  "/**\n"
  " * To be called by a particular kind of GraphicsWindow to indicate that the\n"
  " * pointer data has changed.\n"
  " */";
#else
static const char *Dtool_GraphicsWindowInputDevice_update_pointer_788_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsWindowInputDevice::pointer_moved(double x, double y, double time = ClockObject::get_global_clock()->get_frame_time())
 */
static PyObject *Dtool_GraphicsWindowInputDevice_pointer_moved_789(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsWindowInputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindowInputDevice, (void **)&local_this, "GraphicsWindowInputDevice.pointer_moved")) {
    return nullptr;
  }
  // 1-inline void GraphicsWindowInputDevice::pointer_moved(double x, double y, double time = ClockObject::get_global_clock()->get_frame_time())
  double param1;
  double param2;
  double param3 = ClockObject::get_global_clock()->get_frame_time();
  static const char *keyword_list[] = {"x", "y", "time", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dd|d:pointer_moved", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).pointer_moved)((double)param1, (double)param2, (double)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pointer_moved(const GraphicsWindowInputDevice self, double x, double y, double time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowInputDevice_pointer_moved_789_comment =
  "C++ Interface:\n"
  "pointer_moved(const GraphicsWindowInputDevice self, double x, double y, double time)\n"
  "\n"
  "/**\n"
  " * To be called by a particular kind of GraphicsWindow to indicate that the\n"
  " * pointer has moved by the given relative amount.\n"
  " */";
#else
static const char *Dtool_GraphicsWindowInputDevice_pointer_moved_789_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsWindowInputDevice::remove_pointer(int id)
 */
static PyObject *Dtool_GraphicsWindowInputDevice_remove_pointer_790(PyObject *self, PyObject *arg) {
  GraphicsWindowInputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindowInputDevice, (void **)&local_this, "GraphicsWindowInputDevice.remove_pointer")) {
    return nullptr;
  }
  // 1-inline void GraphicsWindowInputDevice::remove_pointer(int id)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).remove_pointer)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_pointer(const GraphicsWindowInputDevice self, int id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowInputDevice_remove_pointer_790_comment =
  "C++ Interface:\n"
  "remove_pointer(const GraphicsWindowInputDevice self, int id)\n"
  "\n"
  "/**\n"
  " * To be called by a particular kind of GraphicsWindow to indicate that the\n"
  " * pointer no longer exists.\n"
  " */";
#else
static const char *Dtool_GraphicsWindowInputDevice_remove_pointer_790_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GraphicsWindowInputDevice::get_class_type(void)
 */
static PyObject *Dtool_GraphicsWindowInputDevice_get_class_type_791(PyObject *, PyObject *) {
  // 1-static TypeHandle GraphicsWindowInputDevice::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GraphicsWindowInputDevice::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowInputDevice_get_class_type_791_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GraphicsWindowInputDevice_get_class_type_791_comment = nullptr;
#endif

static int Dtool_Init_GraphicsWindowInputDevice(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_GraphicsWindowInputDevice(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GraphicsWindowInputDevice) {
    printf("GraphicsWindowInputDevice ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GraphicsWindowInputDevice *local_this = (GraphicsWindowInputDevice *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GraphicsWindowInputDevice) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_InputDevice) {
    return (InputDevice *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(InputDevice *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(InputDevice *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(InputDevice *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GraphicsWindowInputDevice(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GraphicsWindowInputDevice) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_InputDevice) {
    InputDevice* other_this = (InputDevice*)from_this;
    return (GraphicsWindowInputDevice*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GraphicsWindowInputDevice*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GraphicsWindowInputDevice*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (GraphicsWindowInputDevice*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TouchInfo
 */
/**
 * Python function wrapper for:
 * int TouchInfo::get_x(void)
 */
static PyObject *Dtool_TouchInfo_get_x_795(PyObject *self, PyObject *) {
  TouchInfo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TouchInfo, (void **)&local_this, "TouchInfo.get_x")) {
    return nullptr;
  }
  // 1-int TouchInfo::get_x(void)
  int return_value = ((*local_this).get_x)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TouchInfo_get_x_795_comment =
  "C++ Interface:\n"
  "get_x(const TouchInfo self)\n";
#else
static const char *Dtool_TouchInfo_get_x_795_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TouchInfo::get_y(void)
 */
static PyObject *Dtool_TouchInfo_get_y_796(PyObject *self, PyObject *) {
  TouchInfo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TouchInfo, (void **)&local_this, "TouchInfo.get_y")) {
    return nullptr;
  }
  // 1-int TouchInfo::get_y(void)
  int return_value = ((*local_this).get_y)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TouchInfo_get_y_796_comment =
  "C++ Interface:\n"
  "get_y(const TouchInfo self)\n";
#else
static const char *Dtool_TouchInfo_get_y_796_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TouchInfo::get_id(void)
 */
static PyObject *Dtool_TouchInfo_get_id_797(PyObject *self, PyObject *) {
  TouchInfo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TouchInfo, (void **)&local_this, "TouchInfo.get_id")) {
    return nullptr;
  }
  // 1-int TouchInfo::get_id(void)
  int return_value = ((*local_this).get_id)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TouchInfo_get_id_797_comment =
  "C++ Interface:\n"
  "get_id(const TouchInfo self)\n";
#else
static const char *Dtool_TouchInfo_get_id_797_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int TouchInfo::get_flags(void)
 */
static PyObject *Dtool_TouchInfo_get_flags_798(PyObject *self, PyObject *) {
  TouchInfo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TouchInfo, (void **)&local_this, "TouchInfo.get_flags")) {
    return nullptr;
  }
  // 1-int TouchInfo::get_flags(void)
  int return_value = ((*local_this).get_flags)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TouchInfo_get_flags_798_comment =
  "C++ Interface:\n"
  "get_flags(const TouchInfo self)\n";
#else
static const char *Dtool_TouchInfo_get_flags_798_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TouchInfo::TouchInfo(TouchInfo const &) = default
 */
static int Dtool_Init_TouchInfo(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("TouchInfo() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline TouchInfo::TouchInfo(TouchInfo const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    TouchInfo const *param0_this = (TouchInfo *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_TouchInfo, 0, "TouchInfo.TouchInfo", true, true);
    if (param0_this != nullptr) {
      TouchInfo *return_value = new TouchInfo(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TouchInfo, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TouchInfo(const TouchInfo param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TouchInfo(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TouchInfo) {
    printf("TouchInfo ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TouchInfo *local_this = (TouchInfo *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TouchInfo) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TouchInfo(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TouchInfo) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GraphicsWindowProcCallbackData
 */
/**
 * Python function wrapper for:
 * bool GraphicsWindowProcCallbackData::is_touch_event(void)
 */
static PyObject *Dtool_GraphicsWindowProcCallbackData_is_touch_event_803(PyObject *self, PyObject *) {
  GraphicsWindowProcCallbackData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindowProcCallbackData, (void **)&local_this, "GraphicsWindowProcCallbackData.is_touch_event")) {
    return nullptr;
  }
  // 1-bool GraphicsWindowProcCallbackData::is_touch_event(void)
  bool return_value = ((*local_this).is_touch_event)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowProcCallbackData_is_touch_event_803_comment =
  "C++ Interface:\n"
  "is_touch_event(const GraphicsWindowProcCallbackData self)\n"
  "\n"
  "/**\n"
  " * Returns whether the event is a touch event.\n"
  " *\n"
  " */";
#else
static const char *Dtool_GraphicsWindowProcCallbackData_is_touch_event_803_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GraphicsWindowProcCallbackData::get_num_touches(void)
 */
static PyObject *Dtool_GraphicsWindowProcCallbackData_get_num_touches_804(PyObject *self, PyObject *) {
  GraphicsWindowProcCallbackData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindowProcCallbackData, (void **)&local_this, "GraphicsWindowProcCallbackData.get_num_touches")) {
    return nullptr;
  }
  // 1-int GraphicsWindowProcCallbackData::get_num_touches(void)
  int return_value = ((*local_this).get_num_touches)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowProcCallbackData_get_num_touches_804_comment =
  "C++ Interface:\n"
  "get_num_touches(const GraphicsWindowProcCallbackData self)\n"
  "\n"
  "/**\n"
  " * Returns the current number of touches on the window.\n"
  " *\n"
  " */";
#else
static const char *Dtool_GraphicsWindowProcCallbackData_get_num_touches_804_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TouchInfo GraphicsWindowProcCallbackData::get_touch_info(int index)
 */
static PyObject *Dtool_GraphicsWindowProcCallbackData_get_touch_info_805(PyObject *self, PyObject *arg) {
  GraphicsWindowProcCallbackData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindowProcCallbackData, (void **)&local_this, "GraphicsWindowProcCallbackData.get_touch_info")) {
    return nullptr;
  }
  // 1-TouchInfo GraphicsWindowProcCallbackData::get_touch_info(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TouchInfo *return_value = new TouchInfo(((*local_this).get_touch_info)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TouchInfo, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_touch_info(const GraphicsWindowProcCallbackData self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowProcCallbackData_get_touch_info_805_comment =
  "C++ Interface:\n"
  "get_touch_info(const GraphicsWindowProcCallbackData self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the TouchInfo object describing the specified touch.\n"
  " *\n"
  " */";
#else
static const char *Dtool_GraphicsWindowProcCallbackData_get_touch_info_805_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GraphicsWindowProcCallbackData::get_class_type(void)
 */
static PyObject *Dtool_GraphicsWindowProcCallbackData_get_class_type_806(PyObject *, PyObject *) {
  // 1-static TypeHandle GraphicsWindowProcCallbackData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GraphicsWindowProcCallbackData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindowProcCallbackData_get_class_type_806_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GraphicsWindowProcCallbackData_get_class_type_806_comment = nullptr;
#endif

static int Dtool_Init_GraphicsWindowProcCallbackData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_GraphicsWindowProcCallbackData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GraphicsWindowProcCallbackData) {
    printf("GraphicsWindowProcCallbackData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GraphicsWindowProcCallbackData *local_this = (GraphicsWindowProcCallbackData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GraphicsWindowProcCallbackData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CallbackData) {
    return (CallbackData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(CallbackData *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GraphicsWindowProcCallbackData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GraphicsWindowProcCallbackData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CallbackData) {
    CallbackData* other_this = (CallbackData*)from_this;
    return (GraphicsWindowProcCallbackData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GraphicsWindowProcCallbackData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GraphicsWindow
 */
/**
 * Python function wrapper for:
 * WindowProperties const GraphicsWindow::get_properties(void) const
 */
static PyObject *Dtool_GraphicsWindow_get_properties_809(PyObject *self, PyObject *) {
  GraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsWindow)) {
    return nullptr;
  }
  // 1-WindowProperties const GraphicsWindow::get_properties(void) const
  WindowProperties const *return_value = new WindowProperties const(((*(const GraphicsWindow*)local_this).get_properties)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_WindowProperties, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_get_properties_809_comment =
  "C++ Interface:\n"
  "get_properties(GraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * Returns the current properties of the window.\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_get_properties_809_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * WindowProperties const GraphicsWindow::get_requested_properties(void) const
 */
static PyObject *Dtool_GraphicsWindow_get_requested_properties_810(PyObject *self, PyObject *) {
  GraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsWindow)) {
    return nullptr;
  }
  // 1-WindowProperties const GraphicsWindow::get_requested_properties(void) const
  WindowProperties const *return_value = new WindowProperties const(((*(const GraphicsWindow*)local_this).get_requested_properties)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_WindowProperties, true, true);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_get_requested_properties_810_comment =
  "C++ Interface:\n"
  "get_requested_properties(GraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * Returns the properties of the window that are currently requested.  These\n"
  " * properties will be applied to the window (if valid) at the next execution\n"
  " * of process_events().\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_get_requested_properties_810_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsWindow::clear_rejected_properties(void)
 */
static PyObject *Dtool_GraphicsWindow_clear_rejected_properties_811(PyObject *self, PyObject *) {
  GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindow, (void **)&local_this, "GraphicsWindow.clear_rejected_properties")) {
    return nullptr;
  }
  // 1-void GraphicsWindow::clear_rejected_properties(void)
  ((*local_this).clear_rejected_properties)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_clear_rejected_properties_811_comment =
  "C++ Interface:\n"
  "clear_rejected_properties(const GraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * Empties the set of failed properties that will be returned by\n"
  " * get_rejected_properties().\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_clear_rejected_properties_811_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * WindowProperties GraphicsWindow::get_rejected_properties(void) const
 */
static PyObject *Dtool_GraphicsWindow_get_rejected_properties_812(PyObject *self, PyObject *) {
  GraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsWindow)) {
    return nullptr;
  }
  // 1-WindowProperties GraphicsWindow::get_rejected_properties(void) const
  WindowProperties *return_value = new WindowProperties(((*(const GraphicsWindow*)local_this).get_rejected_properties)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_WindowProperties, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_get_rejected_properties_812_comment =
  "C++ Interface:\n"
  "get_rejected_properties(GraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * Returns the set of properties that have recently been requested, but could\n"
  " * not be applied to the window for some reason.  This set of properties will\n"
  " * remain unchanged until they are changed by a new failed request, or\n"
  " * clear_rejected_properties() is called.\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_get_rejected_properties_812_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsWindow::request_properties(WindowProperties const &requested_properties)
 */
static PyObject *Dtool_GraphicsWindow_request_properties_813(PyObject *self, PyObject *arg) {
  GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindow, (void **)&local_this, "GraphicsWindow.request_properties")) {
    return nullptr;
  }
  // 1-void GraphicsWindow::request_properties(WindowProperties const &requested_properties)
  WindowProperties arg_local;
  WindowProperties const *arg_this = Dtool_Coerce_WindowProperties(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "GraphicsWindow.request_properties", "WindowProperties");
  }
  ((*local_this).request_properties)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "request_properties(const GraphicsWindow self, const WindowProperties requested_properties)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_request_properties_813_comment =
  "C++ Interface:\n"
  "request_properties(const GraphicsWindow self, const WindowProperties requested_properties)\n"
  "\n"
  "/**\n"
  " * Requests a property change on the window.  For example, use this method to\n"
  " * request a window change size or minimize or something.\n"
  " *\n"
  " * The change is not made immediately; rather, the request is saved and will\n"
  " * be applied the next time the window task is run (probably at the next\n"
  " * frame).\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_request_properties_813_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsWindow::is_closed(void) const
 */
static PyObject *Dtool_GraphicsWindow_is_closed_814(PyObject *self, PyObject *) {
  GraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsWindow)) {
    return nullptr;
  }
  // 1-inline bool GraphicsWindow::is_closed(void) const
  bool return_value = ((*(const GraphicsWindow*)local_this).is_closed)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_is_closed_814_comment =
  "C++ Interface:\n"
  "is_closed(GraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * Returns true if the window has not yet been opened, or has been fully\n"
  " * closed, false if it is open.  The window is not opened immediately after\n"
  " * GraphicsEngine::make_window() is called; nor is it closed immediately after\n"
  " * GraphicsEngine::remove_window() is called.  Either operation may take a\n"
  " * frame or two.\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_is_closed_814_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsWindow::is_fullscreen(void) const
 */
static PyObject *Dtool_GraphicsWindow_is_fullscreen_815(PyObject *self, PyObject *) {
  GraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsWindow)) {
    return nullptr;
  }
  // 1-inline bool GraphicsWindow::is_fullscreen(void) const
  bool return_value = ((*(const GraphicsWindow*)local_this).is_fullscreen)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_is_fullscreen_815_comment =
  "C++ Interface:\n"
  "is_fullscreen(GraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * Returns true if the window has been opened as a fullscreen window, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_is_fullscreen_815_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsWindow::set_window_event(std::string const &window_event)
 */
static PyObject *Dtool_GraphicsWindow_set_window_event_820(PyObject *self, PyObject *arg) {
  GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindow, (void **)&local_this, "GraphicsWindow.set_window_event")) {
    return nullptr;
  }
  // 1-void GraphicsWindow::set_window_event(std::string const &window_event)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_window_event)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_window_event(const GraphicsWindow self, str window_event)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_set_window_event_820_comment =
  "C++ Interface:\n"
  "set_window_event(const GraphicsWindow self, str window_event)\n"
  "\n"
  "/**\n"
  " * Changes the name of the event that is generated when this window is\n"
  " * modified externally, e.g.  to be resized or closed by the user.\n"
  " *\n"
  " * By default, all windows have the same window event unless they are\n"
  " * explicitly changed.  When the event is generated, it includes one\n"
  " * parameter: the window itself.\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_set_window_event_820_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string GraphicsWindow::get_window_event(void) const
 */
static PyObject *Dtool_GraphicsWindow_get_window_event_821(PyObject *self, PyObject *) {
  GraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsWindow)) {
    return nullptr;
  }
  // 1-std::string GraphicsWindow::get_window_event(void) const
  std::string return_value = ((*(const GraphicsWindow*)local_this).get_window_event)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_get_window_event_821_comment =
  "C++ Interface:\n"
  "get_window_event(GraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the event that is generated when this window is\n"
  " * modified externally, e.g.  to be resized or closed by the user.  See\n"
  " * set_window_event().\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_get_window_event_821_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsWindow::set_close_request_event(std::string const &close_request_event)
 */
static PyObject *Dtool_GraphicsWindow_set_close_request_event_823(PyObject *self, PyObject *arg) {
  GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindow, (void **)&local_this, "GraphicsWindow.set_close_request_event")) {
    return nullptr;
  }
  // 1-void GraphicsWindow::set_close_request_event(std::string const &close_request_event)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_close_request_event)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_close_request_event(const GraphicsWindow self, str close_request_event)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_set_close_request_event_823_comment =
  "C++ Interface:\n"
  "set_close_request_event(const GraphicsWindow self, str close_request_event)\n"
  "\n"
  "/**\n"
  " * Sets the event that is triggered when the user requests to close the\n"
  " * window, e.g.  via alt-F4, or clicking on the close box.\n"
  " *\n"
  " * The default for each window is for this event to be the empty string, which\n"
  " * means the window-close request is handled immediately by Panda (and the\n"
  " * window will be closed without the app getting a chance to intervene).  If\n"
  " * you set this to a nonempty string, then the window is not closed, but\n"
  " * instead the event is thrown.  It is then up to the app to respond\n"
  " * appropriately, for instance by presenting an \"are you sure?\"  dialog box,\n"
  " * and eventually calling close_window() when the user is sure.\n"
  " *\n"
  " * It is considered poor form to set this string and then not handle the\n"
  " * event.  This can frustrate the user by making it difficult for him to\n"
  " * cleanly shut down the application (and may force the user to hard-kill the\n"
  " * app, or reboot the machine).\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_set_close_request_event_823_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string GraphicsWindow::get_close_request_event(void) const
 */
static PyObject *Dtool_GraphicsWindow_get_close_request_event_824(PyObject *self, PyObject *) {
  GraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsWindow)) {
    return nullptr;
  }
  // 1-std::string GraphicsWindow::get_close_request_event(void) const
  std::string return_value = ((*(const GraphicsWindow*)local_this).get_close_request_event)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_get_close_request_event_824_comment =
  "C++ Interface:\n"
  "get_close_request_event(GraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the event set via set_close_request_event().  If this\n"
  " * string is nonempty, then when the user requests to close window, this event\n"
  " * will be generated instead.  See set_close_request_event().\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_get_close_request_event_824_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void GraphicsWindow::set_unexposed_draw(bool unexposed_draw)
 */
static PyObject *Dtool_GraphicsWindow_set_unexposed_draw_826(PyObject *self, PyObject *arg) {
  GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindow, (void **)&local_this, "GraphicsWindow.set_unexposed_draw")) {
    return nullptr;
  }
  // 1-inline void GraphicsWindow::set_unexposed_draw(bool unexposed_draw)
  ((*local_this).set_unexposed_draw)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_unexposed_draw(const GraphicsWindow self, bool unexposed_draw)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_set_unexposed_draw_826_comment =
  "C++ Interface:\n"
  "set_unexposed_draw(const GraphicsWindow self, bool unexposed_draw)\n"
  "\n"
  "/**\n"
  " * If this flag is false, the window is redrawn only after it has received a\n"
  " * recent \"unexpose\" or \"draw\" event from the underlying windowing systme.  If\n"
  " * this flag is true, the window is redrawn every frame regardless.  Setting\n"
  " * this false may prevent the window from redrawing unnecessarily when it is\n"
  " * hidden, and may play nicer with other windows on the desktop, but may\n"
  " * adversely affect frame rate even when the window is fully visible; setting\n"
  " * it true will ensure that the window contents are always current.\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_set_unexposed_draw_826_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool GraphicsWindow::get_unexposed_draw(void) const
 */
static PyObject *Dtool_GraphicsWindow_get_unexposed_draw_827(PyObject *self, PyObject *) {
  GraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsWindow)) {
    return nullptr;
  }
  // 1-inline bool GraphicsWindow::get_unexposed_draw(void) const
  bool return_value = ((*(const GraphicsWindow*)local_this).get_unexposed_draw)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_get_unexposed_draw_827_comment =
  "C++ Interface:\n"
  "get_unexposed_draw(GraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * See set_unexposed_draw().\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_get_unexposed_draw_827_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline WindowHandle *GraphicsWindow::get_window_handle(void) const
 */
static PyObject *Dtool_GraphicsWindow_get_window_handle_829(PyObject *self, PyObject *) {
  GraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsWindow)) {
    return nullptr;
  }
  // 1-inline WindowHandle *GraphicsWindow::get_window_handle(void) const
  WindowHandle *return_value = ((*(const GraphicsWindow*)local_this).get_window_handle)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_WindowHandle, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_get_window_handle_829_comment =
  "C++ Interface:\n"
  "get_window_handle(GraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * Returns the WindowHandle corresponding to this window on the desktop.  This\n"
  " * is mainly useful for communicating with external libraries.  Use\n"
  " * window_handle->get_os_handle()->get_handle(), or\n"
  " * window_handle->get_string_handle(), to get the actual OS-specific window\n"
  " * handle object, whatever type that might be.\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_get_window_handle_829_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int GraphicsWindow::get_num_input_devices(void) const
 */
static PyObject *Dtool_GraphicsWindow_get_num_input_devices_831(PyObject *self, PyObject *) {
  GraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsWindow)) {
    return nullptr;
  }
  // 1-int GraphicsWindow::get_num_input_devices(void) const
  int return_value = ((*(const GraphicsWindow*)local_this).get_num_input_devices)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_get_num_input_devices_831_comment =
  "C++ Interface:\n"
  "get_num_input_devices(GraphicsWindow self)\n"
  "\n"
  "// Mouse and keyboard routines\n"
  "\n"
  "// Mouse and keyboard routines\n"
  "\n"
  "// Mouse and keyboard routines\n"
  "\n"
  "/**\n"
  " * Returns the number of separate input devices associated with the window.\n"
  " * Typically, a window will have exactly one input device: the keyboard/mouse\n"
  " * pair.  However, some windows may have no input devices, and others may add\n"
  " * additional devices, for instance for a joystick.\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_get_num_input_devices_831_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * InputDevice *GraphicsWindow::get_input_device(int i) const
 */
static PyObject *Dtool_GraphicsWindow_get_input_device_832(PyObject *self, PyObject *arg) {
  GraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsWindow)) {
    return nullptr;
  }
  // 1-InputDevice *GraphicsWindow::get_input_device(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    InputDevice *return_value = ((*(const GraphicsWindow*)local_this).get_input_device)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_InputDevice, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_input_device(GraphicsWindow self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_get_input_device_832_comment =
  "C++ Interface:\n"
  "get_input_device(GraphicsWindow self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the nth input device associated with the window.  Typically, a\n"
  " * window will have exactly one input device: the keyboard/mouse pair.\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_get_input_device_832_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string GraphicsWindow::get_input_device_name(int device) const
 */
static PyObject *Dtool_GraphicsWindow_get_input_device_name_833(PyObject *self, PyObject *arg) {
  GraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsWindow)) {
    return nullptr;
  }
  // 1-std::string GraphicsWindow::get_input_device_name(int device) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const GraphicsWindow*)local_this).get_input_device_name)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_input_device_name(GraphicsWindow self, int device)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_get_input_device_name_833_comment =
  "C++ Interface:\n"
  "get_input_device_name(GraphicsWindow self, int device)\n"
  "\n"
  "/**\n"
  " * Returns the name of the nth input device.\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_get_input_device_name_833_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GraphicsWindow::has_pointer(int device) const
 */
static PyObject *Dtool_GraphicsWindow_has_pointer_836(PyObject *self, PyObject *arg) {
  GraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsWindow)) {
    return nullptr;
  }
  // 1-bool GraphicsWindow::has_pointer(int device) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const GraphicsWindow*)local_this).has_pointer)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_pointer(GraphicsWindow self, int device)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_has_pointer_836_comment =
  "C++ Interface:\n"
  "has_pointer(GraphicsWindow self, int device)\n"
  "\n"
  "/**\n"
  " * Returns true if the nth input device has a screen-space pointer (for\n"
  " * instance, a mouse), false otherwise.\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_has_pointer_836_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool GraphicsWindow::has_keyboard(int device) const
 */
static PyObject *Dtool_GraphicsWindow_has_keyboard_837(PyObject *self, PyObject *arg) {
  GraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsWindow)) {
    return nullptr;
  }
  // 1-bool GraphicsWindow::has_keyboard(int device) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const GraphicsWindow*)local_this).has_keyboard)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_keyboard(GraphicsWindow self, int device)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_has_keyboard_837_comment =
  "C++ Interface:\n"
  "has_keyboard(GraphicsWindow self, int device)\n"
  "\n"
  "/**\n"
  " * Returns true if the nth input device has a keyboard, false otherwise.\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_has_keyboard_837_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual ButtonMap *GraphicsWindow::get_keyboard_map(void) const
 */
static PyObject *Dtool_GraphicsWindow_get_keyboard_map_838(PyObject *self, PyObject *) {
  GraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsWindow)) {
    return nullptr;
  }
  // 1-virtual ButtonMap *GraphicsWindow::get_keyboard_map(void) const
  ButtonMap *return_value = ((*(const GraphicsWindow*)local_this).get_keyboard_map)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ButtonMap, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_get_keyboard_map_838_comment =
  "C++ Interface:\n"
  "get_keyboard_map(GraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * Returns a ButtonMap containing the association between raw buttons and\n"
  " * virtual buttons.\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_get_keyboard_map_838_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsWindow::enable_pointer_events(int device)
 */
static PyObject *Dtool_GraphicsWindow_enable_pointer_events_839(PyObject *self, PyObject *arg) {
  GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindow, (void **)&local_this, "GraphicsWindow.enable_pointer_events")) {
    return nullptr;
  }
  // 1-void GraphicsWindow::enable_pointer_events(int device)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).enable_pointer_events)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "enable_pointer_events(const GraphicsWindow self, int device)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_enable_pointer_events_839_comment =
  "C++ Interface:\n"
  "enable_pointer_events(const GraphicsWindow self, int device)\n"
  "\n"
  "/**\n"
  " * Turn on the generation of pointer events.\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_enable_pointer_events_839_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsWindow::disable_pointer_events(int device)
 */
static PyObject *Dtool_GraphicsWindow_disable_pointer_events_840(PyObject *self, PyObject *arg) {
  GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindow, (void **)&local_this, "GraphicsWindow.disable_pointer_events")) {
    return nullptr;
  }
  // 1-void GraphicsWindow::disable_pointer_events(int device)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).disable_pointer_events)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "disable_pointer_events(const GraphicsWindow self, int device)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_disable_pointer_events_840_comment =
  "C++ Interface:\n"
  "disable_pointer_events(const GraphicsWindow self, int device)\n"
  "\n"
  "/**\n"
  " * Turn off the generation of pointer events.\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_disable_pointer_events_840_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual MouseData GraphicsWindow::get_pointer(int device) const
 */
static PyObject *Dtool_GraphicsWindow_get_pointer_841(PyObject *self, PyObject *arg) {
  GraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsWindow)) {
    return nullptr;
  }
  // 1-virtual MouseData GraphicsWindow::get_pointer(int device) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    MouseData *return_value = new MouseData(((*(const GraphicsWindow*)local_this).get_pointer)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerData, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pointer(GraphicsWindow self, int device)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_get_pointer_841_comment =
  "C++ Interface:\n"
  "get_pointer(GraphicsWindow self, int device)\n"
  "\n"
  "/**\n"
  " * Returns the MouseData associated with the nth input device's pointer.  This\n"
  " * is deprecated; use get_pointer_device().get_pointer() instead, or for raw\n"
  " * mice, use the InputDeviceManager interface.\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_get_pointer_841_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool GraphicsWindow::move_pointer(int device, int x, int y)
 */
static PyObject *Dtool_GraphicsWindow_move_pointer_842(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindow, (void **)&local_this, "GraphicsWindow.move_pointer")) {
    return nullptr;
  }
  // 1-virtual bool GraphicsWindow::move_pointer(int device, int x, int y)
  int param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"device", "x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iii:move_pointer", (char **)keyword_list, &param1, &param2, &param3)) {
    bool return_value = ((*local_this).move_pointer)((int)param1, (int)param2, (int)param3);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "move_pointer(const GraphicsWindow self, int device, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_move_pointer_842_comment =
  "C++ Interface:\n"
  "move_pointer(const GraphicsWindow self, int device, int x, int y)\n"
  "\n"
  "/**\n"
  " * Forces the pointer to the indicated position within the window, if\n"
  " * possible.\n"
  " *\n"
  " * Returns true if successful, false on failure.  This may fail if the mouse\n"
  " * is not currently within the window, or if the API doesn't support this\n"
  " * operation.\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_move_pointer_842_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void GraphicsWindow::close_ime(void)
 */
static PyObject *Dtool_GraphicsWindow_close_ime_843(PyObject *self, PyObject *) {
  GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindow, (void **)&local_this, "GraphicsWindow.close_ime")) {
    return nullptr;
  }
  // 1-virtual void GraphicsWindow::close_ime(void)
  ((*local_this).close_ime)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_close_ime_843_comment =
  "C++ Interface:\n"
  "close_ime(const GraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * Forces the ime window to close if any\n"
  " *\n"
  " */";
#else
static const char *Dtool_GraphicsWindow_close_ime_843_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GraphicsWindow::get_class_type(void)
 */
static PyObject *Dtool_GraphicsWindow_get_class_type_844(PyObject *, PyObject *) {
  // 1-static TypeHandle GraphicsWindow::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GraphicsWindow::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsWindow_get_class_type_844_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GraphicsWindow_get_class_type_844_comment = nullptr;
#endif

static PyObject *Dtool_GraphicsWindow_properties_Getter(PyObject *self, void *) {
  const GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsWindow, (void **)&local_this)) {
    return nullptr;
  }

  // 1-WindowProperties const GraphicsWindow::get_properties(void) const
  WindowProperties const *return_value = new WindowProperties const(((*(const GraphicsWindow*)local_this).get_properties)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_WindowProperties, true, true);
}

static PyObject *Dtool_GraphicsWindow_requested_properties_Getter(PyObject *self, void *) {
  const GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsWindow, (void **)&local_this)) {
    return nullptr;
  }

  // 1-WindowProperties const GraphicsWindow::get_requested_properties(void) const
  WindowProperties const *return_value = new WindowProperties const(((*(const GraphicsWindow*)local_this).get_requested_properties)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_WindowProperties, true, true);
}

static PyObject *Dtool_GraphicsWindow_rejected_properties_Getter(PyObject *self, void *) {
  const GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsWindow, (void **)&local_this)) {
    return nullptr;
  }

  // 1-WindowProperties GraphicsWindow::get_rejected_properties(void) const
  WindowProperties *return_value = new WindowProperties(((*(const GraphicsWindow*)local_this).get_rejected_properties)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_WindowProperties, true, false);
}

static PyObject *Dtool_GraphicsWindow_closed_Getter(PyObject *self, void *) {
  const GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsWindow, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsWindow::is_closed(void) const
  bool return_value = ((*(const GraphicsWindow*)local_this).is_closed)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_GraphicsWindow_window_event_Getter(PyObject *self, void *) {
  const GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsWindow, (void **)&local_this)) {
    return nullptr;
  }

  // 1-std::string GraphicsWindow::get_window_event(void) const
  std::string return_value = ((*(const GraphicsWindow*)local_this).get_window_event)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GraphicsWindow_window_event_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindow, (void **)&local_this, "GraphicsWindow.window_event")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete window_event attribute");
    return -1;
  }
  // 1-void GraphicsWindow::set_window_event(std::string const &window_event)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_window_event)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_window_event(const GraphicsWindow self, str window_event)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsWindow_close_request_event_Getter(PyObject *self, void *) {
  const GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsWindow, (void **)&local_this)) {
    return nullptr;
  }

  // 1-std::string GraphicsWindow::get_close_request_event(void) const
  std::string return_value = ((*(const GraphicsWindow*)local_this).get_close_request_event)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GraphicsWindow_close_request_event_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindow, (void **)&local_this, "GraphicsWindow.close_request_event")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete close_request_event attribute");
    return -1;
  }
  // 1-void GraphicsWindow::set_close_request_event(std::string const &close_request_event)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_close_request_event)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_close_request_event(const GraphicsWindow self, str close_request_event)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsWindow_unexposed_draw_Getter(PyObject *self, void *) {
  const GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsWindow, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool GraphicsWindow::get_unexposed_draw(void) const
  bool return_value = ((*(const GraphicsWindow*)local_this).get_unexposed_draw)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_GraphicsWindow_unexposed_draw_Setter(PyObject *self, PyObject *arg, void *) {
  GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsWindow, (void **)&local_this, "GraphicsWindow.unexposed_draw")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete unexposed_draw attribute");
    return -1;
  }
  // 1-inline void GraphicsWindow::set_unexposed_draw(bool unexposed_draw)
  ((*local_this).set_unexposed_draw)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_unexposed_draw(const GraphicsWindow self, bool unexposed_draw)\n");
  }
  return -1;
}

static PyObject *Dtool_GraphicsWindow_window_handle_Getter(PyObject *self, void *) {
  const GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsWindow, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline WindowHandle *GraphicsWindow::get_window_handle(void) const
  WindowHandle *return_value = ((*(const GraphicsWindow*)local_this).get_window_handle)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_WindowHandle, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_Init_GraphicsWindow(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GraphicsWindow_get_input_devices(PyObject *self, PyObject *) {
  GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsWindow, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_input_devices)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GraphicsWindow_get_input_device_832(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GraphicsWindow_get_input_device_names(PyObject *self, PyObject *) {
  GraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsWindow, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_input_devices)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GraphicsWindow_get_input_device_name_833(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_GraphicsWindow(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GraphicsWindow) {
    printf("GraphicsWindow ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GraphicsWindow *local_this = (GraphicsWindow *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GraphicsWindow) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DrawableRegion) {
    return (DrawableRegion *)(GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_GraphicsOutput) {
    return (GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_GraphicsOutputBase) {
    return (GraphicsOutputBase *)(GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(GraphicsOutputBase *)(GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(GraphicsOutputBase *)(GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(GraphicsOutputBase *)(GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(GraphicsOutputBase *)(GraphicsOutput *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GraphicsWindow(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GraphicsWindow) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DrawableRegion) {
    DrawableRegion* other_this = (DrawableRegion*)from_this;
    return (GraphicsWindow*)other_this;
  }
  if (from_type == Dtool_Ptr_GraphicsOutput) {
    GraphicsOutput* other_this = (GraphicsOutput*)from_this;
    return (GraphicsWindow*)other_this;
  }
  if (from_type == Dtool_Ptr_GraphicsOutputBase) {
    GraphicsOutputBase* other_this = (GraphicsOutputBase*)from_this;
    return (GraphicsWindow*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GraphicsWindow*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GraphicsWindow*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GraphicsWindow*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GraphicsWindow*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CallbackGraphicsWindow
 */
/**
 * Python function wrapper for:
 * inline void CallbackGraphicsWindow::set_events_callback(CallbackObject *object)
 */
static PyObject *Dtool_CallbackGraphicsWindow_set_events_callback_869(PyObject *self, PyObject *arg) {
  CallbackGraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackGraphicsWindow, (void **)&local_this, "CallbackGraphicsWindow.set_events_callback")) {
    return nullptr;
  }
  // 1-inline void CallbackGraphicsWindow::set_events_callback(CallbackObject *object)
  PT(CallbackObject) arg_this;
  if (!Dtool_Coerce_CallbackObject(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CallbackGraphicsWindow.set_events_callback", "CallbackObject");
  }
  ((*local_this).set_events_callback)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_events_callback(const CallbackGraphicsWindow self, CallbackObject object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_set_events_callback_869_comment =
  "C++ Interface:\n"
  "set_events_callback(const CallbackGraphicsWindow self, CallbackObject object)\n"
  "\n"
  "/**\n"
  " * Sets the CallbackObject that will be notified when this window is polled\n"
  " * for window events, including mouse and keyboard events, as well as window\n"
  " * resize events and other system-generated events.\n"
  " *\n"
  " * This callback will receive a CallbackGraphicsWindow::EventsCallbackData.\n"
  " *\n"
  " * This callback should process any system-generated events, and call\n"
  " * data->upcall() to process requested property change requests made via\n"
  " * request_properties().\n"
  " */";
#else
static const char *Dtool_CallbackGraphicsWindow_set_events_callback_869_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CallbackGraphicsWindow::clear_events_callback(void)
 */
static PyObject *Dtool_CallbackGraphicsWindow_clear_events_callback_870(PyObject *self, PyObject *) {
  CallbackGraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackGraphicsWindow, (void **)&local_this, "CallbackGraphicsWindow.clear_events_callback")) {
    return nullptr;
  }
  // 1-inline void CallbackGraphicsWindow::clear_events_callback(void)
  ((*local_this).clear_events_callback)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_clear_events_callback_870_comment =
  "C++ Interface:\n"
  "clear_events_callback(const CallbackGraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * Removes the callback set by an earlier call to set_events_callback().\n"
  " */";
#else
static const char *Dtool_CallbackGraphicsWindow_clear_events_callback_870_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CallbackObject *CallbackGraphicsWindow::get_events_callback(void) const
 */
static PyObject *Dtool_CallbackGraphicsWindow_get_events_callback_871(PyObject *self, PyObject *) {
  CallbackGraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CallbackGraphicsWindow)) {
    return nullptr;
  }
  // 1-inline CallbackObject *CallbackGraphicsWindow::get_events_callback(void) const
  CallbackObject *return_value = ((*(const CallbackGraphicsWindow*)local_this).get_events_callback)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_get_events_callback_871_comment =
  "C++ Interface:\n"
  "get_events_callback(CallbackGraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * Returns the CallbackObject set by set_events_callback().\n"
  " */";
#else
static const char *Dtool_CallbackGraphicsWindow_get_events_callback_871_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CallbackGraphicsWindow::set_properties_callback(CallbackObject *object)
 */
static PyObject *Dtool_CallbackGraphicsWindow_set_properties_callback_872(PyObject *self, PyObject *arg) {
  CallbackGraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackGraphicsWindow, (void **)&local_this, "CallbackGraphicsWindow.set_properties_callback")) {
    return nullptr;
  }
  // 1-inline void CallbackGraphicsWindow::set_properties_callback(CallbackObject *object)
  PT(CallbackObject) arg_this;
  if (!Dtool_Coerce_CallbackObject(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CallbackGraphicsWindow.set_properties_callback", "CallbackObject");
  }
  ((*local_this).set_properties_callback)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_properties_callback(const CallbackGraphicsWindow self, CallbackObject object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_set_properties_callback_872_comment =
  "C++ Interface:\n"
  "set_properties_callback(const CallbackGraphicsWindow self, CallbackObject object)\n"
  "\n"
  "/**\n"
  " * Sets the CallbackObject that will be notified when this window receives a\n"
  " * property change request from user code (e.g.  via request_properties).\n"
  " *\n"
  " * This callback will receive a\n"
  " * CallbackGraphicsWindow::PropertiesCallbackData, which provides a\n"
  " * get_properties() method that returns a modifiable reference to a\n"
  " * WindowsProperties object.  This object will contain only those properties\n"
  " * requested by user code.  The callback should handle any of the requests it\n"
  " * finds, including and especially set_open(), and remove them from the object\n"
  " * when it has handled them.  Any unhandled properties should be left\n"
  " * unchanged in the properties object.\n"
  " */";
#else
static const char *Dtool_CallbackGraphicsWindow_set_properties_callback_872_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CallbackGraphicsWindow::clear_properties_callback(void)
 */
static PyObject *Dtool_CallbackGraphicsWindow_clear_properties_callback_873(PyObject *self, PyObject *) {
  CallbackGraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackGraphicsWindow, (void **)&local_this, "CallbackGraphicsWindow.clear_properties_callback")) {
    return nullptr;
  }
  // 1-inline void CallbackGraphicsWindow::clear_properties_callback(void)
  ((*local_this).clear_properties_callback)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_clear_properties_callback_873_comment =
  "C++ Interface:\n"
  "clear_properties_callback(const CallbackGraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * Removes the callback set by an earlier call to set_properties_callback().\n"
  " */";
#else
static const char *Dtool_CallbackGraphicsWindow_clear_properties_callback_873_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CallbackObject *CallbackGraphicsWindow::get_properties_callback(void) const
 */
static PyObject *Dtool_CallbackGraphicsWindow_get_properties_callback_874(PyObject *self, PyObject *) {
  CallbackGraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CallbackGraphicsWindow)) {
    return nullptr;
  }
  // 1-inline CallbackObject *CallbackGraphicsWindow::get_properties_callback(void) const
  CallbackObject *return_value = ((*(const CallbackGraphicsWindow*)local_this).get_properties_callback)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_get_properties_callback_874_comment =
  "C++ Interface:\n"
  "get_properties_callback(CallbackGraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * Returns the CallbackObject set by set_properties_callback().\n"
  " */";
#else
static const char *Dtool_CallbackGraphicsWindow_get_properties_callback_874_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CallbackGraphicsWindow::set_render_callback(CallbackObject *object)
 */
static PyObject *Dtool_CallbackGraphicsWindow_set_render_callback_875(PyObject *self, PyObject *arg) {
  CallbackGraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackGraphicsWindow, (void **)&local_this, "CallbackGraphicsWindow.set_render_callback")) {
    return nullptr;
  }
  // 1-inline void CallbackGraphicsWindow::set_render_callback(CallbackObject *object)
  PT(CallbackObject) arg_this;
  if (!Dtool_Coerce_CallbackObject(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CallbackGraphicsWindow.set_render_callback", "CallbackObject");
  }
  ((*local_this).set_render_callback)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render_callback(const CallbackGraphicsWindow self, CallbackObject object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_set_render_callback_875_comment =
  "C++ Interface:\n"
  "set_render_callback(const CallbackGraphicsWindow self, CallbackObject object)\n"
  "\n"
  "/**\n"
  " * Sets the CallbackObject that will be notified when this window is invoked\n"
  " * (in the draw thread) to render its contents, and/or flip the graphics\n"
  " * buffers.\n"
  " *\n"
  " * This callback will actually serve several different functions.  It\n"
  " * receivces a RenderCallbackData, and you can query data->get_callback_type()\n"
  " * to return the actual function of each particular callback.\n"
  " */";
#else
static const char *Dtool_CallbackGraphicsWindow_set_render_callback_875_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CallbackGraphicsWindow::clear_render_callback(void)
 */
static PyObject *Dtool_CallbackGraphicsWindow_clear_render_callback_876(PyObject *self, PyObject *) {
  CallbackGraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackGraphicsWindow, (void **)&local_this, "CallbackGraphicsWindow.clear_render_callback")) {
    return nullptr;
  }
  // 1-inline void CallbackGraphicsWindow::clear_render_callback(void)
  ((*local_this).clear_render_callback)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_clear_render_callback_876_comment =
  "C++ Interface:\n"
  "clear_render_callback(const CallbackGraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * Removes the callback set by an earlier call to set_render_callback().\n"
  " */";
#else
static const char *Dtool_CallbackGraphicsWindow_clear_render_callback_876_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CallbackObject *CallbackGraphicsWindow::get_render_callback(void) const
 */
static PyObject *Dtool_CallbackGraphicsWindow_get_render_callback_877(PyObject *self, PyObject *) {
  CallbackGraphicsWindow *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CallbackGraphicsWindow)) {
    return nullptr;
  }
  // 1-inline CallbackObject *CallbackGraphicsWindow::get_render_callback(void) const
  CallbackObject *return_value = ((*(const CallbackGraphicsWindow*)local_this).get_render_callback)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_get_render_callback_877_comment =
  "C++ Interface:\n"
  "get_render_callback(CallbackGraphicsWindow self)\n"
  "\n"
  "/**\n"
  " * Returns the CallbackObject set by set_render_callback().\n"
  " */";
#else
static const char *Dtool_CallbackGraphicsWindow_get_render_callback_877_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CallbackGraphicsWindow::create_input_device(std::string const &name)
 */
static PyObject *Dtool_CallbackGraphicsWindow_create_input_device_878(PyObject *self, PyObject *arg) {
  CallbackGraphicsWindow *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackGraphicsWindow, (void **)&local_this, "CallbackGraphicsWindow.create_input_device")) {
    return nullptr;
  }
  // 1-int CallbackGraphicsWindow::create_input_device(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    int return_value = ((*local_this).create_input_device)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "create_input_device(const CallbackGraphicsWindow self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_create_input_device_878_comment =
  "C++ Interface:\n"
  "create_input_device(const CallbackGraphicsWindow self, str name)\n"
  "\n"
  "/**\n"
  " * Adds a new input device (mouse) to the window with the indicated name.\n"
  " * Returns the index of the new device.\n"
  " */";
#else
static const char *Dtool_CallbackGraphicsWindow_create_input_device_878_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CallbackGraphicsWindow::get_class_type(void)
 */
static PyObject *Dtool_CallbackGraphicsWindow_get_class_type_879(PyObject *, PyObject *) {
  // 1-static TypeHandle CallbackGraphicsWindow::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CallbackGraphicsWindow::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_get_class_type_879_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CallbackGraphicsWindow_get_class_type_879_comment = nullptr;
#endif

static int Dtool_Init_CallbackGraphicsWindow(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CallbackGraphicsWindow(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CallbackGraphicsWindow) {
    printf("CallbackGraphicsWindow ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CallbackGraphicsWindow *local_this = (CallbackGraphicsWindow *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CallbackGraphicsWindow) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DrawableRegion) {
    return (DrawableRegion *)(GraphicsOutput *)(GraphicsWindow *) local_this;
  }
  if (requested_type == Dtool_Ptr_GraphicsOutput) {
    return (GraphicsOutput *)(GraphicsWindow *) local_this;
  }
  if (requested_type == Dtool_Ptr_GraphicsOutputBase) {
    return (GraphicsOutputBase *)(GraphicsOutput *)(GraphicsWindow *) local_this;
  }
  if (requested_type == Dtool_Ptr_GraphicsWindow) {
    return (GraphicsWindow *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(GraphicsOutputBase *)(GraphicsOutput *)(GraphicsWindow *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(GraphicsOutputBase *)(GraphicsOutput *)(GraphicsWindow *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(GraphicsOutputBase *)(GraphicsOutput *)(GraphicsWindow *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(GraphicsOutputBase *)(GraphicsOutput *)(GraphicsWindow *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CallbackGraphicsWindow(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CallbackGraphicsWindow) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DrawableRegion) {
    DrawableRegion* other_this = (DrawableRegion*)from_this;
    return (CallbackGraphicsWindow*)other_this;
  }
  if (from_type == Dtool_Ptr_GraphicsOutput) {
    GraphicsOutput* other_this = (GraphicsOutput*)from_this;
    return (CallbackGraphicsWindow*)other_this;
  }
  if (from_type == Dtool_Ptr_GraphicsOutputBase) {
    GraphicsOutputBase* other_this = (GraphicsOutputBase*)from_this;
    return (CallbackGraphicsWindow*)other_this;
  }
  if (from_type == Dtool_Ptr_GraphicsWindow) {
    GraphicsWindow* other_this = (GraphicsWindow*)from_this;
    return (CallbackGraphicsWindow*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CallbackGraphicsWindow*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CallbackGraphicsWindow*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CallbackGraphicsWindow*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CallbackGraphicsWindow*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CallbackGraphicsWindow::WindowCallbackData
 */
/**
 * Python function wrapper for:
 * inline CallbackGraphicsWindow *CallbackGraphicsWindow::WindowCallbackData::get_window(void) const
 */
static PyObject *Dtool_CallbackGraphicsWindow_WindowCallbackData_get_window_847(PyObject *self, PyObject *) {
  CallbackGraphicsWindow::WindowCallbackData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CallbackGraphicsWindow_WindowCallbackData)) {
    return nullptr;
  }
  // 1-inline CallbackGraphicsWindow *CallbackGraphicsWindow::WindowCallbackData::get_window(void) const
  CallbackGraphicsWindow *return_value = ((*(const CallbackGraphicsWindow::WindowCallbackData*)local_this).get_window)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackGraphicsWindow, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_WindowCallbackData_get_window_847_comment =
  "C++ Interface:\n"
  "get_window(WindowCallbackData self)\n"
  "\n"
  "/**\n"
  " * Returns the window this callback was triggered from.\n"
  " */";
#else
static const char *Dtool_CallbackGraphicsWindow_WindowCallbackData_get_window_847_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CallbackGraphicsWindow::WindowCallbackData::get_class_type(void)
 */
static PyObject *Dtool_CallbackGraphicsWindow_WindowCallbackData_get_class_type_850(PyObject *, PyObject *) {
  // 1-static TypeHandle CallbackGraphicsWindow::WindowCallbackData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CallbackGraphicsWindow::WindowCallbackData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_WindowCallbackData_get_class_type_850_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CallbackGraphicsWindow_WindowCallbackData_get_class_type_850_comment = nullptr;
#endif

static PyObject *Dtool_CallbackGraphicsWindow_WindowCallbackData_window_Getter(PyObject *self, void *) {
  const CallbackGraphicsWindow::WindowCallbackData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CallbackGraphicsWindow_WindowCallbackData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CallbackGraphicsWindow *CallbackGraphicsWindow::WindowCallbackData::get_window(void) const
  CallbackGraphicsWindow *return_value = ((*(const CallbackGraphicsWindow::WindowCallbackData*)local_this).get_window)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackGraphicsWindow, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_Init_CallbackGraphicsWindow_WindowCallbackData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CallbackGraphicsWindow_WindowCallbackData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CallbackGraphicsWindow_WindowCallbackData) {
    printf("CallbackGraphicsWindow_WindowCallbackData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CallbackGraphicsWindow::WindowCallbackData *local_this = (CallbackGraphicsWindow::WindowCallbackData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CallbackGraphicsWindow_WindowCallbackData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CallbackData) {
    return (CallbackData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(CallbackData *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CallbackGraphicsWindow_WindowCallbackData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CallbackGraphicsWindow_WindowCallbackData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CallbackData) {
    CallbackData* other_this = (CallbackData*)from_this;
    return (CallbackGraphicsWindow::WindowCallbackData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CallbackGraphicsWindow::WindowCallbackData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CallbackGraphicsWindow::EventsCallbackData
 */
/**
 * Python function wrapper for:
 * static TypeHandle CallbackGraphicsWindow::EventsCallbackData::get_class_type(void)
 */
static PyObject *Dtool_CallbackGraphicsWindow_EventsCallbackData_get_class_type_853(PyObject *, PyObject *) {
  // 1-static TypeHandle CallbackGraphicsWindow::EventsCallbackData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CallbackGraphicsWindow::EventsCallbackData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_EventsCallbackData_get_class_type_853_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CallbackGraphicsWindow_EventsCallbackData_get_class_type_853_comment = nullptr;
#endif

static int Dtool_Init_CallbackGraphicsWindow_EventsCallbackData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CallbackGraphicsWindow_EventsCallbackData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CallbackGraphicsWindow_EventsCallbackData) {
    printf("CallbackGraphicsWindow_EventsCallbackData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CallbackGraphicsWindow::EventsCallbackData *local_this = (CallbackGraphicsWindow::EventsCallbackData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CallbackGraphicsWindow_EventsCallbackData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CallbackData) {
    return (CallbackData *)(CallbackGraphicsWindow::WindowCallbackData *) local_this;
  }
  if (requested_type == Dtool_Ptr_CallbackGraphicsWindow_WindowCallbackData) {
    return (CallbackGraphicsWindow::WindowCallbackData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(CallbackData *)(CallbackGraphicsWindow::WindowCallbackData *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CallbackGraphicsWindow_EventsCallbackData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CallbackGraphicsWindow_EventsCallbackData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CallbackData) {
    CallbackData* other_this = (CallbackData*)from_this;
    return (CallbackGraphicsWindow::EventsCallbackData*)other_this;
  }
  if (from_type == Dtool_Ptr_CallbackGraphicsWindow_WindowCallbackData) {
    CallbackGraphicsWindow::WindowCallbackData* other_this = (CallbackGraphicsWindow::WindowCallbackData*)from_this;
    return (CallbackGraphicsWindow::EventsCallbackData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CallbackGraphicsWindow::EventsCallbackData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CallbackGraphicsWindow::PropertiesCallbackData
 */
/**
 * Python function wrapper for:
 * inline WindowProperties &CallbackGraphicsWindow::PropertiesCallbackData::get_properties(void) const
 */
static PyObject *Dtool_CallbackGraphicsWindow_PropertiesCallbackData_get_properties_856(PyObject *self, PyObject *) {
  CallbackGraphicsWindow::PropertiesCallbackData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CallbackGraphicsWindow_PropertiesCallbackData)) {
    return nullptr;
  }
  // 1-inline WindowProperties &CallbackGraphicsWindow::PropertiesCallbackData::get_properties(void) const
  WindowProperties *return_value = &(((*(const CallbackGraphicsWindow::PropertiesCallbackData*)local_this).get_properties)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_WindowProperties, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_PropertiesCallbackData_get_properties_856_comment =
  "C++ Interface:\n"
  "get_properties(PropertiesCallbackData self)\n"
  "\n"
  "/**\n"
  " * Returns the WindowProperties object that this callback should process.  Any\n"
  " * properties that are handled should be removed from this object; properties\n"
  " * that are unhandled should be left alone.\n"
  " */";
#else
static const char *Dtool_CallbackGraphicsWindow_PropertiesCallbackData_get_properties_856_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CallbackGraphicsWindow::PropertiesCallbackData::get_class_type(void)
 */
static PyObject *Dtool_CallbackGraphicsWindow_PropertiesCallbackData_get_class_type_857(PyObject *, PyObject *) {
  // 1-static TypeHandle CallbackGraphicsWindow::PropertiesCallbackData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CallbackGraphicsWindow::PropertiesCallbackData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_PropertiesCallbackData_get_class_type_857_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CallbackGraphicsWindow_PropertiesCallbackData_get_class_type_857_comment = nullptr;
#endif

static int Dtool_Init_CallbackGraphicsWindow_PropertiesCallbackData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CallbackGraphicsWindow_PropertiesCallbackData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CallbackGraphicsWindow_PropertiesCallbackData) {
    printf("CallbackGraphicsWindow_PropertiesCallbackData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CallbackGraphicsWindow::PropertiesCallbackData *local_this = (CallbackGraphicsWindow::PropertiesCallbackData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CallbackGraphicsWindow_PropertiesCallbackData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CallbackData) {
    return (CallbackData *)(CallbackGraphicsWindow::WindowCallbackData *) local_this;
  }
  if (requested_type == Dtool_Ptr_CallbackGraphicsWindow_WindowCallbackData) {
    return (CallbackGraphicsWindow::WindowCallbackData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(CallbackData *)(CallbackGraphicsWindow::WindowCallbackData *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CallbackGraphicsWindow_PropertiesCallbackData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CallbackGraphicsWindow_PropertiesCallbackData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CallbackData) {
    CallbackData* other_this = (CallbackData*)from_this;
    return (CallbackGraphicsWindow::PropertiesCallbackData*)other_this;
  }
  if (from_type == Dtool_Ptr_CallbackGraphicsWindow_WindowCallbackData) {
    CallbackGraphicsWindow::WindowCallbackData* other_this = (CallbackGraphicsWindow::WindowCallbackData*)from_this;
    return (CallbackGraphicsWindow::PropertiesCallbackData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CallbackGraphicsWindow::PropertiesCallbackData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CallbackGraphicsWindow::RenderCallbackData
 */
/**
 * Python function wrapper for:
 * inline CallbackGraphicsWindow::RenderCallbackType CallbackGraphicsWindow::RenderCallbackData::get_callback_type(void) const
 */
static PyObject *Dtool_CallbackGraphicsWindow_RenderCallbackData_get_callback_type_860(PyObject *self, PyObject *) {
  CallbackGraphicsWindow::RenderCallbackData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CallbackGraphicsWindow_RenderCallbackData)) {
    return nullptr;
  }
  // 1-inline CallbackGraphicsWindow::RenderCallbackType CallbackGraphicsWindow::RenderCallbackData::get_callback_type(void) const
  CallbackGraphicsWindow::RenderCallbackType return_value = ((*(const CallbackGraphicsWindow::RenderCallbackData*)local_this).get_callback_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_RenderCallbackData_get_callback_type_860_comment =
  "C++ Interface:\n"
  "get_callback_type(RenderCallbackData self)\n"
  "\n"
  "/**\n"
  " * Since the render callback is shared for several functions, this method is\n"
  " * needed to indicate which particular function is being invoked with this\n"
  " * callback.\n"
  " */";
#else
static const char *Dtool_CallbackGraphicsWindow_RenderCallbackData_get_callback_type_860_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GraphicsOutput::FrameMode CallbackGraphicsWindow::RenderCallbackData::get_frame_mode(void) const
 */
static PyObject *Dtool_CallbackGraphicsWindow_RenderCallbackData_get_frame_mode_861(PyObject *self, PyObject *) {
  CallbackGraphicsWindow::RenderCallbackData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CallbackGraphicsWindow_RenderCallbackData)) {
    return nullptr;
  }
  // 1-inline GraphicsOutput::FrameMode CallbackGraphicsWindow::RenderCallbackData::get_frame_mode(void) const
  GraphicsOutput::FrameMode return_value = ((*(const CallbackGraphicsWindow::RenderCallbackData*)local_this).get_frame_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_RenderCallbackData_get_frame_mode_861_comment =
  "C++ Interface:\n"
  "get_frame_mode(RenderCallbackData self)\n"
  "\n"
  "/**\n"
  " * If the callback type (returned by get_callback_type) is RCT_begin_frame or\n"
  " * RCT_end_frame, then this method will return the particular frame mode\n"
  " * indicating what, precisely, we want to do this frame.\n"
  " */";
#else
static const char *Dtool_CallbackGraphicsWindow_RenderCallbackData_get_frame_mode_861_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CallbackGraphicsWindow::RenderCallbackData::set_render_flag(bool render_flag)
 */
static PyObject *Dtool_CallbackGraphicsWindow_RenderCallbackData_set_render_flag_864(PyObject *self, PyObject *arg) {
  CallbackGraphicsWindow::RenderCallbackData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackGraphicsWindow_RenderCallbackData, (void **)&local_this, "CallbackGraphicsWindow::RenderCallbackData.set_render_flag")) {
    return nullptr;
  }
  // 1-inline void CallbackGraphicsWindow::RenderCallbackData::set_render_flag(bool render_flag)
  ((*local_this).set_render_flag)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render_flag(const RenderCallbackData self, bool render_flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_RenderCallbackData_set_render_flag_864_comment =
  "C++ Interface:\n"
  "set_render_flag(const RenderCallbackData self, bool render_flag)\n"
  "\n"
  "/**\n"
  " * If the callback type is RCT_begin_frame, this call is available to specify\n"
  " * the return value from the begin_frame() call.  If this is true (the\n"
  " * default), the frame is rendered normally; if it is false, the frame is\n"
  " * omitted.\n"
  " */";
#else
static const char *Dtool_CallbackGraphicsWindow_RenderCallbackData_set_render_flag_864_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CallbackGraphicsWindow::RenderCallbackData::get_render_flag(void) const
 */
static PyObject *Dtool_CallbackGraphicsWindow_RenderCallbackData_get_render_flag_865(PyObject *self, PyObject *) {
  CallbackGraphicsWindow::RenderCallbackData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CallbackGraphicsWindow_RenderCallbackData)) {
    return nullptr;
  }
  // 1-inline bool CallbackGraphicsWindow::RenderCallbackData::get_render_flag(void) const
  bool return_value = ((*(const CallbackGraphicsWindow::RenderCallbackData*)local_this).get_render_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_RenderCallbackData_get_render_flag_865_comment =
  "C++ Interface:\n"
  "get_render_flag(RenderCallbackData self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the render flag.  See set_render_flag().\n"
  " */";
#else
static const char *Dtool_CallbackGraphicsWindow_RenderCallbackData_get_render_flag_865_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CallbackGraphicsWindow::RenderCallbackData::get_class_type(void)
 */
static PyObject *Dtool_CallbackGraphicsWindow_RenderCallbackData_get_class_type_867(PyObject *, PyObject *) {
  // 1-static TypeHandle CallbackGraphicsWindow::RenderCallbackData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CallbackGraphicsWindow::RenderCallbackData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CallbackGraphicsWindow_RenderCallbackData_get_class_type_867_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CallbackGraphicsWindow_RenderCallbackData_get_class_type_867_comment = nullptr;
#endif

static PyObject *Dtool_CallbackGraphicsWindow_RenderCallbackData_callback_type_Getter(PyObject *self, void *) {
  const CallbackGraphicsWindow::RenderCallbackData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CallbackGraphicsWindow_RenderCallbackData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CallbackGraphicsWindow::RenderCallbackType CallbackGraphicsWindow::RenderCallbackData::get_callback_type(void) const
  CallbackGraphicsWindow::RenderCallbackType return_value = ((*(const CallbackGraphicsWindow::RenderCallbackData*)local_this).get_callback_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CallbackGraphicsWindow_RenderCallbackData_frame_mode_Getter(PyObject *self, void *) {
  const CallbackGraphicsWindow::RenderCallbackData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CallbackGraphicsWindow_RenderCallbackData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline GraphicsOutput::FrameMode CallbackGraphicsWindow::RenderCallbackData::get_frame_mode(void) const
  GraphicsOutput::FrameMode return_value = ((*(const CallbackGraphicsWindow::RenderCallbackData*)local_this).get_frame_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CallbackGraphicsWindow_RenderCallbackData_render_flag_Getter(PyObject *self, void *) {
  const CallbackGraphicsWindow::RenderCallbackData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CallbackGraphicsWindow_RenderCallbackData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool CallbackGraphicsWindow::RenderCallbackData::get_render_flag(void) const
  bool return_value = ((*(const CallbackGraphicsWindow::RenderCallbackData*)local_this).get_render_flag)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CallbackGraphicsWindow_RenderCallbackData_render_flag_Setter(PyObject *self, PyObject *arg, void *) {
  CallbackGraphicsWindow::RenderCallbackData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackGraphicsWindow_RenderCallbackData, (void **)&local_this, "CallbackGraphicsWindow::RenderCallbackData.render_flag")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete render_flag attribute");
    return -1;
  }
  // 1-inline void CallbackGraphicsWindow::RenderCallbackData::set_render_flag(bool render_flag)
  ((*local_this).set_render_flag)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_render_flag(const RenderCallbackData self, bool render_flag)\n");
  }
  return -1;
}

static int Dtool_Init_CallbackGraphicsWindow_RenderCallbackData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CallbackGraphicsWindow_RenderCallbackData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CallbackGraphicsWindow_RenderCallbackData) {
    printf("CallbackGraphicsWindow_RenderCallbackData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CallbackGraphicsWindow::RenderCallbackData *local_this = (CallbackGraphicsWindow::RenderCallbackData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CallbackGraphicsWindow_RenderCallbackData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CallbackData) {
    return (CallbackData *)(CallbackGraphicsWindow::WindowCallbackData *) local_this;
  }
  if (requested_type == Dtool_Ptr_CallbackGraphicsWindow_WindowCallbackData) {
    return (CallbackGraphicsWindow::WindowCallbackData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(CallbackData *)(CallbackGraphicsWindow::WindowCallbackData *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CallbackGraphicsWindow_RenderCallbackData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CallbackGraphicsWindow_RenderCallbackData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CallbackData) {
    CallbackData* other_this = (CallbackData*)from_this;
    return (CallbackGraphicsWindow::RenderCallbackData*)other_this;
  }
  if (from_type == Dtool_Ptr_CallbackGraphicsWindow_WindowCallbackData) {
    CallbackGraphicsWindow::WindowCallbackData* other_this = (CallbackGraphicsWindow::WindowCallbackData*)from_this;
    return (CallbackGraphicsWindow::RenderCallbackData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CallbackGraphicsWindow::RenderCallbackData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DisplayMode
 */
/**
 * Python function wrapper for:
 * void DisplayMode::output(std::ostream &out) const
 */
static PyObject *Dtool_DisplayMode_output_898(PyObject *self, PyObject *arg) {
  DisplayMode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayMode)) {
    return nullptr;
  }
  // 1-void DisplayMode::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "DisplayMode.output", false, true);
  if (arg_this != nullptr) {
    ((*(const DisplayMode*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DisplayMode self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplayMode_output_898_comment =
  "C++ Interface:\n"
  "output(DisplayMode self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplayMode_output_898_comment = nullptr;
#endif

static PyObject *Dtool_DisplayMode_width_Getter(PyObject *self, void *) {
  const DisplayMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayMode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-int DisplayMode::get_width(void) const
  int return_value = ((const DisplayMode*)local_this)->width;
  return Dtool_WrapValue(return_value);
}

static int Dtool_DisplayMode_width_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayMode, (void **)&local_this, "DisplayMode.width")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete width attribute");
    return -1;
  }
  // 1-void DisplayMode::set_width(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (local_this)->width = (int)arg_val;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_width(const DisplayMode self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayMode_height_Getter(PyObject *self, void *) {
  const DisplayMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayMode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-int DisplayMode::get_height(void) const
  int return_value = ((const DisplayMode*)local_this)->height;
  return Dtool_WrapValue(return_value);
}

static int Dtool_DisplayMode_height_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayMode, (void **)&local_this, "DisplayMode.height")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete height attribute");
    return -1;
  }
  // 1-void DisplayMode::set_height(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (local_this)->height = (int)arg_val;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_height(const DisplayMode self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayMode_bits_per_pixel_Getter(PyObject *self, void *) {
  const DisplayMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayMode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-int DisplayMode::get_bits_per_pixel(void) const
  int return_value = ((const DisplayMode*)local_this)->bits_per_pixel;
  return Dtool_WrapValue(return_value);
}

static int Dtool_DisplayMode_bits_per_pixel_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayMode, (void **)&local_this, "DisplayMode.bits_per_pixel")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete bits_per_pixel attribute");
    return -1;
  }
  // 1-void DisplayMode::set_bits_per_pixel(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (local_this)->bits_per_pixel = (int)arg_val;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bits_per_pixel(const DisplayMode self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayMode_refresh_rate_Getter(PyObject *self, void *) {
  const DisplayMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayMode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-int DisplayMode::get_refresh_rate(void) const
  int return_value = ((const DisplayMode*)local_this)->refresh_rate;
  return Dtool_WrapValue(return_value);
}

static int Dtool_DisplayMode_refresh_rate_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayMode, (void **)&local_this, "DisplayMode.refresh_rate")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete refresh_rate attribute");
    return -1;
  }
  // 1-void DisplayMode::set_refresh_rate(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (local_this)->refresh_rate = (int)arg_val;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_refresh_rate(const DisplayMode self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_DisplayMode_fullscreen_only_Getter(PyObject *self, void *) {
  const DisplayMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayMode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-int DisplayMode::get_fullscreen_only(void) const
  int return_value = ((const DisplayMode*)local_this)->fullscreen_only;
  return Dtool_WrapValue(return_value);
}

static int Dtool_DisplayMode_fullscreen_only_Setter(PyObject *self, PyObject *arg, void *) {
  DisplayMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplayMode, (void **)&local_this, "DisplayMode.fullscreen_only")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete fullscreen_only attribute");
    return -1;
  }
  // 1-void DisplayMode::set_fullscreen_only(int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    (local_this)->fullscreen_only = (int)arg_val;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_fullscreen_only(const DisplayMode self, int value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline DisplayMode::DisplayMode(void) = default
 * inline DisplayMode::DisplayMode(DisplayMode const &) = default
 */
static int Dtool_Init_DisplayMode(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("DisplayMode() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline DisplayMode::DisplayMode(void) = default
      DisplayMode *return_value = new DisplayMode();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DisplayMode, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline DisplayMode::DisplayMode(DisplayMode const &) = default
      DisplayMode const *arg_this = (DisplayMode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DisplayMode, 0, "DisplayMode.DisplayMode", true, true);
      if (arg_this != nullptr) {
        DisplayMode *return_value = new DisplayMode(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DisplayMode, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DisplayMode() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DisplayMode()\n"
      "DisplayMode(const DisplayMode param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DisplayMode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DisplayMode) {
    printf("DisplayMode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DisplayMode *local_this = (DisplayMode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DisplayMode) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DisplayMode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DisplayMode) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DisplayRegionCullCallbackData
 */
/**
 * Python function wrapper for:
 * inline SceneSetup *DisplayRegionCullCallbackData::get_scene_setup(void) const
 */
static PyObject *Dtool_DisplayRegionCullCallbackData_get_scene_setup_903(PyObject *self, PyObject *) {
  DisplayRegionCullCallbackData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegionCullCallbackData)) {
    return nullptr;
  }
  // 1-inline SceneSetup *DisplayRegionCullCallbackData::get_scene_setup(void) const
  SceneSetup *return_value = ((*(const DisplayRegionCullCallbackData*)local_this).get_scene_setup)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_SceneSetup, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegionCullCallbackData_get_scene_setup_903_comment =
  "C++ Interface:\n"
  "get_scene_setup(DisplayRegionCullCallbackData self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the SceneSetup object, which contains information\n"
  " * about the camera and such.\n"
  " */";
#else
static const char *Dtool_DisplayRegionCullCallbackData_get_scene_setup_903_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DisplayRegionCullCallbackData::get_class_type(void)
 */
static PyObject *Dtool_DisplayRegionCullCallbackData_get_class_type_904(PyObject *, PyObject *) {
  // 1-static TypeHandle DisplayRegionCullCallbackData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((DisplayRegionCullCallbackData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegionCullCallbackData_get_class_type_904_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DisplayRegionCullCallbackData_get_class_type_904_comment = nullptr;
#endif

static int Dtool_Init_DisplayRegionCullCallbackData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DisplayRegionCullCallbackData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DisplayRegionCullCallbackData) {
    printf("DisplayRegionCullCallbackData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DisplayRegionCullCallbackData *local_this = (DisplayRegionCullCallbackData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DisplayRegionCullCallbackData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CallbackData) {
    return (CallbackData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(CallbackData *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DisplayRegionCullCallbackData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DisplayRegionCullCallbackData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CallbackData) {
    CallbackData* other_this = (CallbackData*)from_this;
    return (DisplayRegionCullCallbackData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DisplayRegionCullCallbackData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DisplayRegionDrawCallbackData
 */
/**
 * Python function wrapper for:
 * inline CullResult *DisplayRegionDrawCallbackData::get_cull_result(void) const
 */
static PyObject *Dtool_DisplayRegionDrawCallbackData_get_cull_result_907(PyObject *self, PyObject *) {
  DisplayRegionDrawCallbackData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegionDrawCallbackData)) {
    return nullptr;
  }
  // 1-inline CullResult *DisplayRegionDrawCallbackData::get_cull_result(void) const
  CullResult *return_value = ((*(const DisplayRegionDrawCallbackData*)local_this).get_cull_result)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_CullResult, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegionDrawCallbackData_get_cull_result_907_comment =
  "C++ Interface:\n"
  "get_cull_result(DisplayRegionDrawCallbackData self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the CullResult, the list of CullableObjects that\n"
  " * should be drawn in this DisplayRegion.\n"
  " */";
#else
static const char *Dtool_DisplayRegionDrawCallbackData_get_cull_result_907_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SceneSetup *DisplayRegionDrawCallbackData::get_scene_setup(void) const
 */
static PyObject *Dtool_DisplayRegionDrawCallbackData_get_scene_setup_908(PyObject *self, PyObject *) {
  DisplayRegionDrawCallbackData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DisplayRegionDrawCallbackData)) {
    return nullptr;
  }
  // 1-inline SceneSetup *DisplayRegionDrawCallbackData::get_scene_setup(void) const
  SceneSetup *return_value = ((*(const DisplayRegionDrawCallbackData*)local_this).get_scene_setup)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_SceneSetup, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegionDrawCallbackData_get_scene_setup_908_comment =
  "C++ Interface:\n"
  "get_scene_setup(DisplayRegionDrawCallbackData self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the SceneSetup object, which contains information\n"
  " * about the camera and such.\n"
  " */";
#else
static const char *Dtool_DisplayRegionDrawCallbackData_get_scene_setup_908_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DisplayRegionDrawCallbackData::get_class_type(void)
 */
static PyObject *Dtool_DisplayRegionDrawCallbackData_get_class_type_909(PyObject *, PyObject *) {
  // 1-static TypeHandle DisplayRegionDrawCallbackData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((DisplayRegionDrawCallbackData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DisplayRegionDrawCallbackData_get_class_type_909_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DisplayRegionDrawCallbackData_get_class_type_909_comment = nullptr;
#endif

static int Dtool_Init_DisplayRegionDrawCallbackData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DisplayRegionDrawCallbackData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DisplayRegionDrawCallbackData) {
    printf("DisplayRegionDrawCallbackData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DisplayRegionDrawCallbackData *local_this = (DisplayRegionDrawCallbackData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DisplayRegionDrawCallbackData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CallbackData) {
    return (CallbackData *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(CallbackData *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DisplayRegionDrawCallbackData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DisplayRegionDrawCallbackData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CallbackData) {
    CallbackData* other_this = (CallbackData*)from_this;
    return (DisplayRegionDrawCallbackData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DisplayRegionDrawCallbackData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DisplaySearchParameters
 */
/**
 * Python function wrapper for:
 * void DisplaySearchParameters::set_minimum_width(int minimum_width)
 */
static PyObject *Dtool_DisplaySearchParameters_set_minimum_width_914(PyObject *self, PyObject *arg) {
  DisplaySearchParameters *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplaySearchParameters, (void **)&local_this, "DisplaySearchParameters.set_minimum_width")) {
    return nullptr;
  }
  // 1-void DisplaySearchParameters::set_minimum_width(int minimum_width)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_minimum_width)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_minimum_width(const DisplaySearchParameters self, int minimum_width)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplaySearchParameters_set_minimum_width_914_comment =
  "C++ Interface:\n"
  "set_minimum_width(const DisplaySearchParameters self, int minimum_width)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplaySearchParameters_set_minimum_width_914_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DisplaySearchParameters::set_maximum_width(int maximum_width)
 */
static PyObject *Dtool_DisplaySearchParameters_set_maximum_width_915(PyObject *self, PyObject *arg) {
  DisplaySearchParameters *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplaySearchParameters, (void **)&local_this, "DisplaySearchParameters.set_maximum_width")) {
    return nullptr;
  }
  // 1-void DisplaySearchParameters::set_maximum_width(int maximum_width)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_maximum_width)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_maximum_width(const DisplaySearchParameters self, int maximum_width)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplaySearchParameters_set_maximum_width_915_comment =
  "C++ Interface:\n"
  "set_maximum_width(const DisplaySearchParameters self, int maximum_width)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplaySearchParameters_set_maximum_width_915_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DisplaySearchParameters::set_minimum_height(int minimum_height)
 */
static PyObject *Dtool_DisplaySearchParameters_set_minimum_height_916(PyObject *self, PyObject *arg) {
  DisplaySearchParameters *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplaySearchParameters, (void **)&local_this, "DisplaySearchParameters.set_minimum_height")) {
    return nullptr;
  }
  // 1-void DisplaySearchParameters::set_minimum_height(int minimum_height)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_minimum_height)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_minimum_height(const DisplaySearchParameters self, int minimum_height)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplaySearchParameters_set_minimum_height_916_comment =
  "C++ Interface:\n"
  "set_minimum_height(const DisplaySearchParameters self, int minimum_height)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplaySearchParameters_set_minimum_height_916_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DisplaySearchParameters::set_maximum_height(int maximum_height)
 */
static PyObject *Dtool_DisplaySearchParameters_set_maximum_height_917(PyObject *self, PyObject *arg) {
  DisplaySearchParameters *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplaySearchParameters, (void **)&local_this, "DisplaySearchParameters.set_maximum_height")) {
    return nullptr;
  }
  // 1-void DisplaySearchParameters::set_maximum_height(int maximum_height)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_maximum_height)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_maximum_height(const DisplaySearchParameters self, int maximum_height)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplaySearchParameters_set_maximum_height_917_comment =
  "C++ Interface:\n"
  "set_maximum_height(const DisplaySearchParameters self, int maximum_height)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplaySearchParameters_set_maximum_height_917_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DisplaySearchParameters::set_minimum_bits_per_pixel(int minimum_bits_per_pixel)
 */
static PyObject *Dtool_DisplaySearchParameters_set_minimum_bits_per_pixel_918(PyObject *self, PyObject *arg) {
  DisplaySearchParameters *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplaySearchParameters, (void **)&local_this, "DisplaySearchParameters.set_minimum_bits_per_pixel")) {
    return nullptr;
  }
  // 1-void DisplaySearchParameters::set_minimum_bits_per_pixel(int minimum_bits_per_pixel)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_minimum_bits_per_pixel)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_minimum_bits_per_pixel(const DisplaySearchParameters self, int minimum_bits_per_pixel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplaySearchParameters_set_minimum_bits_per_pixel_918_comment =
  "C++ Interface:\n"
  "set_minimum_bits_per_pixel(const DisplaySearchParameters self, int minimum_bits_per_pixel)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplaySearchParameters_set_minimum_bits_per_pixel_918_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DisplaySearchParameters::set_maximum_bits_per_pixel(int maximum_bits_per_pixel)
 */
static PyObject *Dtool_DisplaySearchParameters_set_maximum_bits_per_pixel_919(PyObject *self, PyObject *arg) {
  DisplaySearchParameters *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DisplaySearchParameters, (void **)&local_this, "DisplaySearchParameters.set_maximum_bits_per_pixel")) {
    return nullptr;
  }
  // 1-void DisplaySearchParameters::set_maximum_bits_per_pixel(int maximum_bits_per_pixel)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_maximum_bits_per_pixel)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_maximum_bits_per_pixel(const DisplaySearchParameters self, int maximum_bits_per_pixel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DisplaySearchParameters_set_maximum_bits_per_pixel_919_comment =
  "C++ Interface:\n"
  "set_maximum_bits_per_pixel(const DisplaySearchParameters self, int maximum_bits_per_pixel)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_DisplaySearchParameters_set_maximum_bits_per_pixel_919_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DisplaySearchParameters::DisplaySearchParameters(void)
 * inline DisplaySearchParameters::DisplaySearchParameters(DisplaySearchParameters const &) = default
 */
static int Dtool_Init_DisplaySearchParameters(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("DisplaySearchParameters() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-DisplaySearchParameters::DisplaySearchParameters(void)
      DisplaySearchParameters *return_value = new DisplaySearchParameters();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DisplaySearchParameters, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline DisplaySearchParameters::DisplaySearchParameters(DisplaySearchParameters const &) = default
      DisplaySearchParameters const *arg_this = (DisplaySearchParameters *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DisplaySearchParameters, 0, "DisplaySearchParameters.DisplaySearchParameters", true, true);
      if (arg_this != nullptr) {
        DisplaySearchParameters *return_value = new DisplaySearchParameters(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DisplaySearchParameters, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DisplaySearchParameters() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DisplaySearchParameters()\n"
      "DisplaySearchParameters(const DisplaySearchParameters param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DisplaySearchParameters(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DisplaySearchParameters) {
    printf("DisplaySearchParameters ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DisplaySearchParameters *local_this = (DisplaySearchParameters *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DisplaySearchParameters) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DisplaySearchParameters(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DisplaySearchParameters) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GraphicsBuffer
 */
/**
 * Python function wrapper for:
 * virtual void GraphicsBuffer::set_size(int x, int y)
 */
static PyObject *Dtool_GraphicsBuffer_set_size_921(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsBuffer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsBuffer, (void **)&local_this, "GraphicsBuffer.set_size")) {
    return nullptr;
  }
  // 1-virtual void GraphicsBuffer::set_size(int x, int y)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_size", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_size)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_size(const GraphicsBuffer self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsBuffer_set_size_921_comment =
  "C++ Interface:\n"
  "set_size(const GraphicsBuffer self, int x, int y)\n"
  "\n"
  "/**\n"
  " * This is called by the GraphicsEngine to request that the buffer resize\n"
  " * itself.  Although calls to get the size will return the new value, much of\n"
  " * the actual resizing work doesn't take place until the next begin_frame.\n"
  " * Not all buffers are resizeable.\n"
  " */";
#else
static const char *Dtool_GraphicsBuffer_set_size_921_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle GraphicsBuffer::get_class_type(void)
 */
static PyObject *Dtool_GraphicsBuffer_get_class_type_922(PyObject *, PyObject *) {
  // 1-static TypeHandle GraphicsBuffer::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((GraphicsBuffer::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsBuffer_get_class_type_922_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_GraphicsBuffer_get_class_type_922_comment = nullptr;
#endif

static int Dtool_Init_GraphicsBuffer(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_GraphicsBuffer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GraphicsBuffer) {
    printf("GraphicsBuffer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GraphicsBuffer *local_this = (GraphicsBuffer *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GraphicsBuffer) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DrawableRegion) {
    return (DrawableRegion *)(GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_GraphicsOutput) {
    return (GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_GraphicsOutputBase) {
    return (GraphicsOutputBase *)(GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(GraphicsOutputBase *)(GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(GraphicsOutputBase *)(GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(GraphicsOutputBase *)(GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(GraphicsOutputBase *)(GraphicsOutput *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GraphicsBuffer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GraphicsBuffer) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DrawableRegion) {
    DrawableRegion* other_this = (DrawableRegion*)from_this;
    return (GraphicsBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_GraphicsOutput) {
    GraphicsOutput* other_this = (GraphicsOutput*)from_this;
    return (GraphicsBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_GraphicsOutputBase) {
    GraphicsOutputBase* other_this = (GraphicsOutputBase*)from_this;
    return (GraphicsBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (GraphicsBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (GraphicsBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (GraphicsBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (GraphicsBuffer*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GraphicsPipeSelection
 */
/**
 * Python function wrapper for:
 * int GraphicsPipeSelection::get_num_pipe_types(void) const
 */
static PyObject *Dtool_GraphicsPipeSelection_get_num_pipe_types_924(PyObject *self, PyObject *) {
  GraphicsPipeSelection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsPipeSelection)) {
    return nullptr;
  }
  // 1-int GraphicsPipeSelection::get_num_pipe_types(void) const
  int return_value = ((*(const GraphicsPipeSelection*)local_this).get_num_pipe_types)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipeSelection_get_num_pipe_types_924_comment =
  "C++ Interface:\n"
  "get_num_pipe_types(GraphicsPipeSelection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of different types of GraphicsPipes that are available\n"
  " * to create through this interface.\n"
  " */";
#else
static const char *Dtool_GraphicsPipeSelection_get_num_pipe_types_924_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypeHandle GraphicsPipeSelection::get_pipe_type(int n) const
 */
static PyObject *Dtool_GraphicsPipeSelection_get_pipe_type_925(PyObject *self, PyObject *arg) {
  GraphicsPipeSelection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsPipeSelection)) {
    return nullptr;
  }
  // 1-TypeHandle GraphicsPipeSelection::get_pipe_type(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    TypeHandle *return_value = new TypeHandle(((*(const GraphicsPipeSelection*)local_this).get_pipe_type)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pipe_type(GraphicsPipeSelection self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipeSelection_get_pipe_type_925_comment =
  "C++ Interface:\n"
  "get_pipe_type(GraphicsPipeSelection self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth type of GraphicsPipe available through this interface.\n"
  " */";
#else
static const char *Dtool_GraphicsPipeSelection_get_pipe_type_925_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsPipeSelection::print_pipe_types(void) const
 */
static PyObject *Dtool_GraphicsPipeSelection_print_pipe_types_929(PyObject *self, PyObject *) {
  GraphicsPipeSelection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsPipeSelection)) {
    return nullptr;
  }
  // 1-void GraphicsPipeSelection::print_pipe_types(void) const
  ((*(const GraphicsPipeSelection*)local_this).print_pipe_types)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipeSelection_print_pipe_types_929_comment =
  "C++ Interface:\n"
  "print_pipe_types(GraphicsPipeSelection self)\n"
  "\n"
  "/**\n"
  " * Writes a list of the currently known GraphicsPipe types to nout, for the\n"
  " * user's information.\n"
  " */";
#else
static const char *Dtool_GraphicsPipeSelection_print_pipe_types_929_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< GraphicsPipe > GraphicsPipeSelection::make_pipe(TypeHandle type)
 * PointerTo< GraphicsPipe > GraphicsPipeSelection::make_pipe(std::string const &type_name, std::string const &module_name = string())
 */
static PyObject *Dtool_GraphicsPipeSelection_make_pipe_930(PyObject *self, PyObject *args, PyObject *kwds) {
  GraphicsPipeSelection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsPipeSelection, (void **)&local_this, "GraphicsPipeSelection.make_pipe")) {
    return nullptr;
  }
  {
    // -2 PointerTo< GraphicsPipe > GraphicsPipeSelection::make_pipe(std::string const &type_name, std::string const &module_name = string())
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    const char *param2_str = "";
    Py_ssize_t param2_len = 0;
    static const char *keyword_list[] = {"type_name", "module_name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|s#:make_pipe", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
      PointerTo< GraphicsPipe > return_value = ((*local_this).make_pipe)(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      GraphicsPipe *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GraphicsPipe, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: PointerTo< GraphicsPipe > GraphicsPipeSelection::make_pipe(std::string const &type_name, std::string const &module_name = string())
  {
    // -2 PointerTo< GraphicsPipe > GraphicsPipeSelection::make_pipe(TypeHandle type)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "type")) {
      TypeHandle param1_local;
      TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
      if ((param1_this != nullptr)) {
        PointerTo< GraphicsPipe > return_value = ((*local_this).make_pipe)(*param1_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        GraphicsPipe *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        if (return_ptr == nullptr) {
          Py_INCREF(Py_None);
          return Py_None;
        } else {
          return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GraphicsPipe, true, false, return_ptr->as_typed_object()->get_type_index());
        }
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_pipe(const GraphicsPipeSelection self, str type_name, str module_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipeSelection_make_pipe_930_comment =
  "C++ Interface:\n"
  "make_pipe(const GraphicsPipeSelection self, str type_name, str module_name)\n"
  "\n"
  "/**\n"
  " * Creates a new GraphicsPipe of the indicated type (or a type more specific\n"
  " * than the indicated type, if necessary) and returns it.  Returns NULL if the\n"
  " * type cannot be matched.\n"
  " *\n"
  " * If the type is not already defined, this will implicitly load the named\n"
  " * module, or if module_name is empty, it will call load_aux_modules().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Creates a new GraphicsPipe of the indicated type (or a type more specific\n"
  " * than the indicated type, if necessary) and returns it.  Returns NULL if the\n"
  " * type cannot be matched.\n"
  " */";
#else
static const char *Dtool_GraphicsPipeSelection_make_pipe_930_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< GraphicsPipe > GraphicsPipeSelection::make_module_pipe(std::string const &module_name)
 */
static PyObject *Dtool_GraphicsPipeSelection_make_module_pipe_931(PyObject *self, PyObject *arg) {
  GraphicsPipeSelection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsPipeSelection, (void **)&local_this, "GraphicsPipeSelection.make_module_pipe")) {
    return nullptr;
  }
  // 1-PointerTo< GraphicsPipe > GraphicsPipeSelection::make_module_pipe(std::string const &module_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    PointerTo< GraphicsPipe > return_value = ((*local_this).make_module_pipe)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    GraphicsPipe *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GraphicsPipe, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_module_pipe(const GraphicsPipeSelection self, str module_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipeSelection_make_module_pipe_931_comment =
  "C++ Interface:\n"
  "make_module_pipe(const GraphicsPipeSelection self, str module_name)\n"
  "\n"
  "/**\n"
  " * Returns a new GraphicsPipe of a type defined by the indicated module.\n"
  " * Returns NULL if the module is not found or does not properly recommend a\n"
  " * GraphicsPipe.\n"
  " */";
#else
static const char *Dtool_GraphicsPipeSelection_make_module_pipe_931_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< GraphicsPipe > GraphicsPipeSelection::make_default_pipe(void)
 */
static PyObject *Dtool_GraphicsPipeSelection_make_default_pipe_932(PyObject *self, PyObject *) {
  GraphicsPipeSelection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsPipeSelection, (void **)&local_this, "GraphicsPipeSelection.make_default_pipe")) {
    return nullptr;
  }
  // 1-PointerTo< GraphicsPipe > GraphicsPipeSelection::make_default_pipe(void)
  PointerTo< GraphicsPipe > return_value = ((*local_this).make_default_pipe)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  GraphicsPipe *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_GraphicsPipe, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipeSelection_make_default_pipe_932_comment =
  "C++ Interface:\n"
  "make_default_pipe(const GraphicsPipeSelection self)\n"
  "\n"
  "/**\n"
  " * Creates a new GraphicsPipe of some arbitrary type.  The user may specify a\n"
  " * preference using the Configrc file; otherwise, one will be chosen\n"
  " * arbitrarily.\n"
  " */";
#else
static const char *Dtool_GraphicsPipeSelection_make_default_pipe_932_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int GraphicsPipeSelection::get_num_aux_modules(void) const
 */
static PyObject *Dtool_GraphicsPipeSelection_get_num_aux_modules_933(PyObject *self, PyObject *) {
  GraphicsPipeSelection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_GraphicsPipeSelection)) {
    return nullptr;
  }
  // 1-inline int GraphicsPipeSelection::get_num_aux_modules(void) const
  int return_value = ((*(const GraphicsPipeSelection*)local_this).get_num_aux_modules)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipeSelection_get_num_aux_modules_933_comment =
  "C++ Interface:\n"
  "get_num_aux_modules(GraphicsPipeSelection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of display modules that are still to be loaded.  If this\n"
  " * is nonzero, then calling load_aux_modules() will likely increase the number\n"
  " * of GraphicsPipes available.\n"
  " */";
#else
static const char *Dtool_GraphicsPipeSelection_get_num_aux_modules_933_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void GraphicsPipeSelection::load_aux_modules(void)
 */
static PyObject *Dtool_GraphicsPipeSelection_load_aux_modules_934(PyObject *self, PyObject *) {
  GraphicsPipeSelection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_GraphicsPipeSelection, (void **)&local_this, "GraphicsPipeSelection.load_aux_modules")) {
    return nullptr;
  }
  // 1-void GraphicsPipeSelection::load_aux_modules(void)
  ((*local_this).load_aux_modules)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipeSelection_load_aux_modules_934_comment =
  "C++ Interface:\n"
  "load_aux_modules(const GraphicsPipeSelection self)\n"
  "\n"
  "/**\n"
  " * Loads all the modules named in the aux-display Configrc variable, making as\n"
  " * many graphics pipes as possible available.\n"
  " */";
#else
static const char *Dtool_GraphicsPipeSelection_load_aux_modules_934_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline GraphicsPipeSelection *GraphicsPipeSelection::get_global_ptr(void)
 */
static PyObject *Dtool_GraphicsPipeSelection_get_global_ptr_935(PyObject *, PyObject *) {
  // 1-static inline GraphicsPipeSelection *GraphicsPipeSelection::get_global_ptr(void)
  GraphicsPipeSelection *return_value = (GraphicsPipeSelection::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_GraphicsPipeSelection, false, false);
}

#ifndef NDEBUG
static const char *Dtool_GraphicsPipeSelection_get_global_ptr_935_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the one global GraphicsPipeSelection object.\n"
  " */";
#else
static const char *Dtool_GraphicsPipeSelection_get_global_ptr_935_comment = nullptr;
#endif

/**
 * sequence length function for property GraphicsPipeSelection::pipe_types
 */
static Py_ssize_t Dtool_GraphicsPipeSelection_pipe_types_Len(PyObject *self) {
  GraphicsPipeSelection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsPipeSelection, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_pipe_types)();
}

/**
 * sequence getter for property GraphicsPipeSelection::pipe_types
 */
static PyObject *Dtool_GraphicsPipeSelection_pipe_types_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  GraphicsPipeSelection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsPipeSelection, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_pipe_types)()) {
    PyErr_SetString(PyExc_IndexError, "GraphicsPipeSelection.pipe_types[] index out of range");
    return nullptr;
  }
  // 1-TypeHandle GraphicsPipeSelection::get_pipe_type(int n) const
  TypeHandle *return_value = new TypeHandle(((*(const GraphicsPipeSelection*)local_this).get_pipe_type)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pipe_type(GraphicsPipeSelection self, index)\n");
  }
}

static PyObject *Dtool_GraphicsPipeSelection_pipe_types_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "GraphicsPipeSelection.pipe_types");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_GraphicsPipeSelection_pipe_types_Len;
    wrap->_getitem_func = &Dtool_GraphicsPipeSelection_pipe_types_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static int Dtool_Init_GraphicsPipeSelection(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_GraphicsPipeSelection_get_pipe_types(PyObject *self, PyObject *) {
  GraphicsPipeSelection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsPipeSelection, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_pipe_types)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_GraphicsPipeSelection_get_pipe_type_925(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_GraphicsPipeSelection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GraphicsPipeSelection) {
    printf("GraphicsPipeSelection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GraphicsPipeSelection *local_this = (GraphicsPipeSelection *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GraphicsPipeSelection) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GraphicsPipeSelection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GraphicsPipeSelection) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MouseAndKeyboard
 */
/**
 * Python function wrapper for:
 * void MouseAndKeyboard::set_source(GraphicsWindow *window, int device)
 */
static PyObject *Dtool_MouseAndKeyboard_set_source_939(PyObject *self, PyObject *args, PyObject *kwds) {
  MouseAndKeyboard *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MouseAndKeyboard, (void **)&local_this, "MouseAndKeyboard.set_source")) {
    return nullptr;
  }
  // 1-void MouseAndKeyboard::set_source(GraphicsWindow *window, int device)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"window", "device", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_source", (char **)keyword_list, &param1, &param2)) {
    GraphicsWindow *param1_this = (GraphicsWindow *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsWindow, 1, "MouseAndKeyboard.set_source", false, true);
    if (param1_this != nullptr) {
      ((*local_this).set_source)(param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_source(const MouseAndKeyboard self, GraphicsWindow window, int device)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MouseAndKeyboard_set_source_939_comment =
  "C++ Interface:\n"
  "set_source(const MouseAndKeyboard self, GraphicsWindow window, int device)\n"
  "\n"
  "/**\n"
  " * Redirects the class to get the data from the mouse and keyboard associated\n"
  " * with a different window and/or device number.\n"
  " */";
#else
static const char *Dtool_MouseAndKeyboard_set_source_939_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MouseAndKeyboard::get_class_type(void)
 */
static PyObject *Dtool_MouseAndKeyboard_get_class_type_940(PyObject *, PyObject *) {
  // 1-static TypeHandle MouseAndKeyboard::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((MouseAndKeyboard::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseAndKeyboard_get_class_type_940_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MouseAndKeyboard_get_class_type_940_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit MouseAndKeyboard::MouseAndKeyboard(GraphicsWindow *window, int device, std::string const &name)
 * inline MouseAndKeyboard::MouseAndKeyboard(MouseAndKeyboard const &) = default
 */
static int Dtool_Init_MouseAndKeyboard(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline MouseAndKeyboard::MouseAndKeyboard(MouseAndKeyboard const &) = default
      MouseAndKeyboard const *arg_this = (MouseAndKeyboard *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MouseAndKeyboard, 0, "MouseAndKeyboard.MouseAndKeyboard", true, true);
      if (arg_this != nullptr) {
        MouseAndKeyboard *return_value = new MouseAndKeyboard(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseAndKeyboard, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-explicit MouseAndKeyboard::MouseAndKeyboard(GraphicsWindow *window, int device, std::string const &name)
      PyObject *param0;
      int param1;
      const char *param2_str = nullptr;
      Py_ssize_t param2_len;
      static const char *keyword_list[] = {"window", "device", "name", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Ois#:MouseAndKeyboard", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len)) {
        GraphicsWindow *param0_this = (GraphicsWindow *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_GraphicsWindow, 0, "MouseAndKeyboard.MouseAndKeyboard", false, true);
        if (param0_this != nullptr) {
          MouseAndKeyboard *return_value = new MouseAndKeyboard(param0_this, (int)param1, std::string(param2_str, param2_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseAndKeyboard, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "MouseAndKeyboard() takes 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MouseAndKeyboard(const MouseAndKeyboard param0)\n"
      "MouseAndKeyboard(GraphicsWindow window, int device, str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MouseAndKeyboard(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MouseAndKeyboard) {
    printf("MouseAndKeyboard ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MouseAndKeyboard *local_this = (MouseAndKeyboard *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MouseAndKeyboard) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MouseAndKeyboard(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MouseAndKeyboard) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (MouseAndKeyboard*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MouseAndKeyboard*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (MouseAndKeyboard*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MouseAndKeyboard*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MouseAndKeyboard*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MouseAndKeyboard*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MouseAndKeyboard*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NativeWindowHandle
 */
/**
 * Python function wrapper for:
 * static PointerTo< WindowHandle > NativeWindowHandle::make_int(std::size_t window)
 */
static PyObject *Dtool_NativeWindowHandle_make_int_943(PyObject *, PyObject *arg) {
  // 1-static PointerTo< WindowHandle > NativeWindowHandle::make_int(std::size_t window)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    PointerTo< WindowHandle > return_value = (NativeWindowHandle::make_int)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    WindowHandle *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_WindowHandle, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_int(int window)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NativeWindowHandle_make_int_943_comment =
  "C++ Interface:\n"
  "make_int(int window)\n"
  "\n"
  "/**\n"
  " * Constructs a new WindowHandle with an int value, which is understood to be\n"
  " * either an HWND or a Window, cast to int.  This method exists for the\n"
  " * convenience of Python, which likes to deal with ints; C++ code should use\n"
  " * one of the more specific make_x11() or make_win32() methods instead.\n"
  " */";
#else
static const char *Dtool_NativeWindowHandle_make_int_943_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< WindowHandle > NativeWindowHandle::make_subprocess(Filename const &filename)
 */
static PyObject *Dtool_NativeWindowHandle_make_subprocess_944(PyObject *, PyObject *arg) {
  // 1-static PointerTo< WindowHandle > NativeWindowHandle::make_subprocess(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "NativeWindowHandle.make_subprocess", "Filename");
  }
  PointerTo< WindowHandle > return_value = (NativeWindowHandle::make_subprocess)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  WindowHandle *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_WindowHandle, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_subprocess(const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NativeWindowHandle_make_subprocess_944_comment =
  "C++ Interface:\n"
  "make_subprocess(const Filename filename)\n"
  "\n"
  "/**\n"
  " * Constructs a new WindowHandle that references a SubprocessWindowBuffer read\n"
  " * in another process, with the named pipe filename that it uses for\n"
  " * communication.\n"
  " *\n"
  " * This is (at present, and maybe always) useful only on the OS X platform,\n"
  " * where parenting child windows is particularly problematic.\n"
  " */";
#else
static const char *Dtool_NativeWindowHandle_make_subprocess_944_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle NativeWindowHandle::get_class_type(void)
 */
static PyObject *Dtool_NativeWindowHandle_get_class_type_945(PyObject *, PyObject *) {
  // 1-static TypeHandle NativeWindowHandle::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((NativeWindowHandle::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NativeWindowHandle_get_class_type_945_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_NativeWindowHandle_get_class_type_945_comment = nullptr;
#endif

static int Dtool_Init_NativeWindowHandle(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_NativeWindowHandle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NativeWindowHandle) {
    printf("NativeWindowHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NativeWindowHandle *local_this = (NativeWindowHandle *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NativeWindowHandle) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(WindowHandle *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(WindowHandle *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(WindowHandle *) local_this;
  }
  if (requested_type == Dtool_Ptr_WindowHandle) {
    return (WindowHandle *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NativeWindowHandle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NativeWindowHandle) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NativeWindowHandle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (NativeWindowHandle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (NativeWindowHandle*)other_this;
  }
  if (from_type == Dtool_Ptr_WindowHandle) {
    WindowHandle* other_this = (WindowHandle*)from_this;
    return (NativeWindowHandle*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParasiteBuffer
 */
/**
 * Python function wrapper for:
 * void ParasiteBuffer::set_size(int x, int y)
 */
static PyObject *Dtool_ParasiteBuffer_set_size_948(PyObject *self, PyObject *args, PyObject *kwds) {
  ParasiteBuffer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParasiteBuffer, (void **)&local_this, "ParasiteBuffer.set_size")) {
    return nullptr;
  }
  // 1-void ParasiteBuffer::set_size(int x, int y)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_size", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_size)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_size(const ParasiteBuffer self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParasiteBuffer_set_size_948_comment =
  "C++ Interface:\n"
  "set_size(const ParasiteBuffer self, int x, int y)\n"
  "\n"
  "/**\n"
  " * This is called by the GraphicsEngine to request that the buffer resize\n"
  " * itself.  Although calls to get the size will return the new value, much of\n"
  " * the actual resizing work doesn't take place until the next begin_frame.\n"
  " * Not all buffers are resizeable.\n"
  " */";
#else
static const char *Dtool_ParasiteBuffer_set_size_948_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParasiteBuffer::get_class_type(void)
 */
static PyObject *Dtool_ParasiteBuffer_get_class_type_949(PyObject *, PyObject *) {
  // 1-static TypeHandle ParasiteBuffer::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParasiteBuffer::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParasiteBuffer_get_class_type_949_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParasiteBuffer_get_class_type_949_comment = nullptr;
#endif

static int Dtool_Init_ParasiteBuffer(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ParasiteBuffer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParasiteBuffer) {
    printf("ParasiteBuffer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParasiteBuffer *local_this = (ParasiteBuffer *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParasiteBuffer) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DrawableRegion) {
    return (DrawableRegion *)(GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_GraphicsOutput) {
    return (GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_GraphicsOutputBase) {
    return (GraphicsOutputBase *)(GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(GraphicsOutputBase *)(GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(GraphicsOutputBase *)(GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(GraphicsOutputBase *)(GraphicsOutput *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(GraphicsOutputBase *)(GraphicsOutput *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParasiteBuffer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParasiteBuffer) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DrawableRegion) {
    DrawableRegion* other_this = (DrawableRegion*)from_this;
    return (ParasiteBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_GraphicsOutput) {
    GraphicsOutput* other_this = (GraphicsOutput*)from_this;
    return (ParasiteBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_GraphicsOutputBase) {
    GraphicsOutputBase* other_this = (GraphicsOutputBase*)from_this;
    return (ParasiteBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParasiteBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParasiteBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParasiteBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParasiteBuffer*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for GraphicsDevice (GraphicsDevice)
 */
static PyMethodDef Dtool_Methods_GraphicsDevice[] = {
  {"get_pipe", &Dtool_GraphicsDevice_get_pipe_3, METH_NOARGS, (const char *)Dtool_GraphicsDevice_get_pipe_3_comment},
  {"getPipe", &Dtool_GraphicsDevice_get_pipe_3, METH_NOARGS, (const char *)Dtool_GraphicsDevice_get_pipe_3_comment},
  {"get_class_type", &Dtool_GraphicsDevice_get_class_type_4, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsDevice_get_class_type_4_comment},
  {"getClassType", &Dtool_GraphicsDevice_get_class_type_4, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsDevice_get_class_type_4_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GraphicsDevice = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GraphicsDevice = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GraphicsDevice = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GraphicsDevice = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GraphicsDevice = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GraphicsDevice = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GraphicsDevice",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GraphicsDevice,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GraphicsDevice,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GraphicsDevice,
    &Dtool_SequenceMethods_GraphicsDevice,
    &Dtool_MappingMethods_GraphicsDevice,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GraphicsDevice,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An abstract device object that is part of Graphics Pipe.  This device is\n"
    " * set to NULL for OpenGL. But DirectX uses it to take control of multiple\n"
    " * windows under single device or multiple devices (i.e.  more than one\n"
    " * adapters in the machine).\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GraphicsDevice,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GraphicsDevice,
    PyType_GenericAlloc,
    Dtool_new_GraphicsDevice,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GraphicsDevice,
  Dtool_UpcastInterface_GraphicsDevice,
  Dtool_DowncastInterface_GraphicsDevice,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GraphicsDevice(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_GraphicsDevice._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_GraphicsDevice._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GraphicsDevice._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GraphicsDevice) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GraphicsDevice)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GraphicsDevice);
  }
}

/**
 * Python method tables for GraphicsPipe (GraphicsPipe)
 */
static PyMethodDef Dtool_Methods_GraphicsPipe[] = {
  {"is_valid", &Dtool_GraphicsPipe_is_valid_8, METH_NOARGS, (const char *)Dtool_GraphicsPipe_is_valid_8_comment},
  {"isValid", &Dtool_GraphicsPipe_is_valid_8, METH_NOARGS, (const char *)Dtool_GraphicsPipe_is_valid_8_comment},
  {"get_supported_types", &Dtool_GraphicsPipe_get_supported_types_9, METH_NOARGS, (const char *)Dtool_GraphicsPipe_get_supported_types_9_comment},
  {"getSupportedTypes", &Dtool_GraphicsPipe_get_supported_types_9, METH_NOARGS, (const char *)Dtool_GraphicsPipe_get_supported_types_9_comment},
  {"supports_type", &Dtool_GraphicsPipe_supports_type_10, METH_O, (const char *)Dtool_GraphicsPipe_supports_type_10_comment},
  {"supportsType", &Dtool_GraphicsPipe_supports_type_10, METH_O, (const char *)Dtool_GraphicsPipe_supports_type_10_comment},
  {"get_display_width", &Dtool_GraphicsPipe_get_display_width_11, METH_NOARGS, (const char *)Dtool_GraphicsPipe_get_display_width_11_comment},
  {"getDisplayWidth", &Dtool_GraphicsPipe_get_display_width_11, METH_NOARGS, (const char *)Dtool_GraphicsPipe_get_display_width_11_comment},
  {"get_display_height", &Dtool_GraphicsPipe_get_display_height_12, METH_NOARGS, (const char *)Dtool_GraphicsPipe_get_display_height_12_comment},
  {"getDisplayHeight", &Dtool_GraphicsPipe_get_display_height_12, METH_NOARGS, (const char *)Dtool_GraphicsPipe_get_display_height_12_comment},
  {"get_display_information", &Dtool_GraphicsPipe_get_display_information_16, METH_NOARGS, (const char *)Dtool_GraphicsPipe_get_display_information_16_comment},
  {"getDisplayInformation", &Dtool_GraphicsPipe_get_display_information_16, METH_NOARGS, (const char *)Dtool_GraphicsPipe_get_display_information_16_comment},
  {"lookup_cpu_data", &Dtool_GraphicsPipe_lookup_cpu_data_75, METH_NOARGS, (const char *)Dtool_GraphicsPipe_lookup_cpu_data_75_comment},
  {"lookupCpuData", &Dtool_GraphicsPipe_lookup_cpu_data_75, METH_NOARGS, (const char *)Dtool_GraphicsPipe_lookup_cpu_data_75_comment},
  {"get_interface_name", &Dtool_GraphicsPipe_get_interface_name_76, METH_NOARGS, (const char *)Dtool_GraphicsPipe_get_interface_name_76_comment},
  {"getInterfaceName", &Dtool_GraphicsPipe_get_interface_name_76, METH_NOARGS, (const char *)Dtool_GraphicsPipe_get_interface_name_76_comment},
  {"get_class_type", &Dtool_GraphicsPipe_get_class_type_80, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsPipe_get_class_type_80_comment},
  {"getClassType", &Dtool_GraphicsPipe_get_class_type_80, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsPipe_get_class_type_80_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_GraphicsPipe[] = {
  {(char *)"display_width", &Dtool_GraphicsPipe_display_width_Getter, nullptr, nullptr, nullptr},
  {(char *)"display_height", &Dtool_GraphicsPipe_display_height_Getter, nullptr, nullptr, nullptr},
  {(char *)"display_information", &Dtool_GraphicsPipe_display_information_Getter, nullptr, nullptr, nullptr},
  {(char *)"interface_name", &Dtool_GraphicsPipe_interface_name_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_GraphicsPipe = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GraphicsPipe = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GraphicsPipe = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GraphicsPipe = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GraphicsPipe = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GraphicsPipe = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GraphicsPipe",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GraphicsPipe,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GraphicsPipe,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GraphicsPipe,
    &Dtool_SequenceMethods_GraphicsPipe,
    &Dtool_MappingMethods_GraphicsPipe,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GraphicsPipe,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An object to create GraphicsOutputs that share a particular 3-D API.\n"
    " * Normally, there will only be one GraphicsPipe in an application, although\n"
    " * it is possible to have multiple of these at once if there are multiple\n"
    " * different API's available in the same machine.\n"
    " *\n"
    " * Often, the GraphicsPipe corresponds to a physical output device, hence the\n"
    " * term \"pipe\", but this is not necessarily the case.\n"
    " *\n"
    " * The GraphicsPipe is used by the GraphicsEngine object to create and destroy\n"
    " * windows; it keeps ownership of the windows it creates.\n"
    " *\n"
    " * M. Asad added new/interim functionality where GraphicsPipe now contains a\n"
    " * device interface to directx/opengl which will be used to handle multiple\n"
    " * windows from same device.\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GraphicsPipe,
    nullptr, // tp_members
    Dtool_Properties_GraphicsPipe,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GraphicsPipe,
    PyType_GenericAlloc,
    Dtool_new_GraphicsPipe,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GraphicsPipe,
  Dtool_UpcastInterface_GraphicsPipe,
  Dtool_DowncastInterface_GraphicsPipe,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GraphicsPipe(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_GraphicsPipe._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_GraphicsPipe._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(37);
    Dtool_GraphicsPipe._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum GraphicsPipe::OutputTypes;
    PyDict_SetItemString(dict, "OT_window", Dtool_WrapValue(GraphicsPipe::OT_window));
    PyDict_SetItemString(dict, "OTWindow", Dtool_WrapValue(GraphicsPipe::OT_window));
    PyDict_SetItemString(dict, "OT_fullscreen_window", Dtool_WrapValue(GraphicsPipe::OT_fullscreen_window));
    PyDict_SetItemString(dict, "OTFullscreenWindow", Dtool_WrapValue(GraphicsPipe::OT_fullscreen_window));
    PyDict_SetItemString(dict, "OT_buffer", Dtool_WrapValue(GraphicsPipe::OT_buffer));
    PyDict_SetItemString(dict, "OTBuffer", Dtool_WrapValue(GraphicsPipe::OT_buffer));
    PyDict_SetItemString(dict, "OT_texture_buffer", Dtool_WrapValue(GraphicsPipe::OT_texture_buffer));
    PyDict_SetItemString(dict, "OTTextureBuffer", Dtool_WrapValue(GraphicsPipe::OT_texture_buffer));
    // enum GraphicsPipe::BufferCreationFlags;
    PyDict_SetItemString(dict, "BF_refuse_parasite", Dtool_WrapValue(GraphicsPipe::BF_refuse_parasite));
    PyDict_SetItemString(dict, "BFRefuseParasite", Dtool_WrapValue(GraphicsPipe::BF_refuse_parasite));
    PyDict_SetItemString(dict, "BF_require_parasite", Dtool_WrapValue(GraphicsPipe::BF_require_parasite));
    PyDict_SetItemString(dict, "BFRequireParasite", Dtool_WrapValue(GraphicsPipe::BF_require_parasite));
    PyDict_SetItemString(dict, "BF_refuse_window", Dtool_WrapValue(GraphicsPipe::BF_refuse_window));
    PyDict_SetItemString(dict, "BFRefuseWindow", Dtool_WrapValue(GraphicsPipe::BF_refuse_window));
    PyDict_SetItemString(dict, "BF_require_window", Dtool_WrapValue(GraphicsPipe::BF_require_window));
    PyDict_SetItemString(dict, "BFRequireWindow", Dtool_WrapValue(GraphicsPipe::BF_require_window));
    PyDict_SetItemString(dict, "BF_require_callback_window", Dtool_WrapValue(GraphicsPipe::BF_require_callback_window));
    PyDict_SetItemString(dict, "BFRequireCallbackWindow", Dtool_WrapValue(GraphicsPipe::BF_require_callback_window));
    PyDict_SetItemString(dict, "BF_can_bind_color", Dtool_WrapValue(GraphicsPipe::BF_can_bind_color));
    PyDict_SetItemString(dict, "BFCanBindColor", Dtool_WrapValue(GraphicsPipe::BF_can_bind_color));
    PyDict_SetItemString(dict, "BF_can_bind_every", Dtool_WrapValue(GraphicsPipe::BF_can_bind_every));
    PyDict_SetItemString(dict, "BFCanBindEvery", Dtool_WrapValue(GraphicsPipe::BF_can_bind_every));
    PyDict_SetItemString(dict, "BF_resizeable", Dtool_WrapValue(GraphicsPipe::BF_resizeable));
    PyDict_SetItemString(dict, "BFResizeable", Dtool_WrapValue(GraphicsPipe::BF_resizeable));
    PyDict_SetItemString(dict, "BF_size_track_host", Dtool_WrapValue(GraphicsPipe::BF_size_track_host));
    PyDict_SetItemString(dict, "BFSizeTrackHost", Dtool_WrapValue(GraphicsPipe::BF_size_track_host));
    PyDict_SetItemString(dict, "BF_rtt_cumulative", Dtool_WrapValue(GraphicsPipe::BF_rtt_cumulative));
    PyDict_SetItemString(dict, "BFRttCumulative", Dtool_WrapValue(GraphicsPipe::BF_rtt_cumulative));
    PyDict_SetItemString(dict, "BF_fb_props_optional", Dtool_WrapValue(GraphicsPipe::BF_fb_props_optional));
    PyDict_SetItemString(dict, "BFFbPropsOptional", Dtool_WrapValue(GraphicsPipe::BF_fb_props_optional));
    PyDict_SetItemString(dict, "BF_size_square", Dtool_WrapValue(GraphicsPipe::BF_size_square));
    PyDict_SetItemString(dict, "BFSizeSquare", Dtool_WrapValue(GraphicsPipe::BF_size_square));
    PyDict_SetItemString(dict, "BF_size_power_2", Dtool_WrapValue(GraphicsPipe::BF_size_power_2));
    PyDict_SetItemString(dict, "BFSizePower2", Dtool_WrapValue(GraphicsPipe::BF_size_power_2));
    PyDict_SetItemString(dict, "BF_can_bind_layered", Dtool_WrapValue(GraphicsPipe::BF_can_bind_layered));
    PyDict_SetItemString(dict, "BFCanBindLayered", Dtool_WrapValue(GraphicsPipe::BF_can_bind_layered));
    if (PyType_Ready((PyTypeObject *)&Dtool_GraphicsPipe) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GraphicsPipe)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GraphicsPipe);
  }
}

/**
 * Python method tables for DisplayInformation (DisplayInformation)
 */
static PyMethodDef Dtool_Methods_DisplayInformation[] = {
  {"get_display_state", &Dtool_DisplayInformation_get_display_state_23, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_display_state_23_comment},
  {"getDisplayState", &Dtool_DisplayInformation_get_display_state_23, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_display_state_23_comment},
  {"get_maximum_window_width", &Dtool_DisplayInformation_get_maximum_window_width_24, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_maximum_window_width_24_comment},
  {"getMaximumWindowWidth", &Dtool_DisplayInformation_get_maximum_window_width_24, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_maximum_window_width_24_comment},
  {"get_maximum_window_height", &Dtool_DisplayInformation_get_maximum_window_height_25, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_maximum_window_height_25_comment},
  {"getMaximumWindowHeight", &Dtool_DisplayInformation_get_maximum_window_height_25, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_maximum_window_height_25_comment},
  {"get_window_bits_per_pixel", &Dtool_DisplayInformation_get_window_bits_per_pixel_26, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_window_bits_per_pixel_26_comment},
  {"getWindowBitsPerPixel", &Dtool_DisplayInformation_get_window_bits_per_pixel_26, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_window_bits_per_pixel_26_comment},
  {"get_total_display_modes", &Dtool_DisplayInformation_get_total_display_modes_27, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_total_display_modes_27_comment},
  {"getTotalDisplayModes", &Dtool_DisplayInformation_get_total_display_modes_27, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_total_display_modes_27_comment},
  {"get_display_mode", &Dtool_DisplayInformation_get_display_mode_28, METH_O, (const char *)Dtool_DisplayInformation_get_display_mode_28_comment},
  {"getDisplayMode", &Dtool_DisplayInformation_get_display_mode_28, METH_O, (const char *)Dtool_DisplayInformation_get_display_mode_28_comment},
  {"get_display_mode_width", &Dtool_DisplayInformation_get_display_mode_width_30, METH_O, (const char *)Dtool_DisplayInformation_get_display_mode_width_30_comment},
  {"getDisplayModeWidth", &Dtool_DisplayInformation_get_display_mode_width_30, METH_O, (const char *)Dtool_DisplayInformation_get_display_mode_width_30_comment},
  {"get_display_mode_height", &Dtool_DisplayInformation_get_display_mode_height_31, METH_O, (const char *)Dtool_DisplayInformation_get_display_mode_height_31_comment},
  {"getDisplayModeHeight", &Dtool_DisplayInformation_get_display_mode_height_31, METH_O, (const char *)Dtool_DisplayInformation_get_display_mode_height_31_comment},
  {"get_display_mode_bits_per_pixel", &Dtool_DisplayInformation_get_display_mode_bits_per_pixel_32, METH_O, (const char *)Dtool_DisplayInformation_get_display_mode_bits_per_pixel_32_comment},
  {"getDisplayModeBitsPerPixel", &Dtool_DisplayInformation_get_display_mode_bits_per_pixel_32, METH_O, (const char *)Dtool_DisplayInformation_get_display_mode_bits_per_pixel_32_comment},
  {"get_display_mode_refresh_rate", &Dtool_DisplayInformation_get_display_mode_refresh_rate_33, METH_O, (const char *)Dtool_DisplayInformation_get_display_mode_refresh_rate_33_comment},
  {"getDisplayModeRefreshRate", &Dtool_DisplayInformation_get_display_mode_refresh_rate_33, METH_O, (const char *)Dtool_DisplayInformation_get_display_mode_refresh_rate_33_comment},
  {"get_display_mode_fullscreen_only", &Dtool_DisplayInformation_get_display_mode_fullscreen_only_34, METH_O, (const char *)Dtool_DisplayInformation_get_display_mode_fullscreen_only_34_comment},
  {"getDisplayModeFullscreenOnly", &Dtool_DisplayInformation_get_display_mode_fullscreen_only_34, METH_O, (const char *)Dtool_DisplayInformation_get_display_mode_fullscreen_only_34_comment},
  {"get_shader_model", &Dtool_DisplayInformation_get_shader_model_35, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_shader_model_35_comment},
  {"getShaderModel", &Dtool_DisplayInformation_get_shader_model_35, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_shader_model_35_comment},
  {"get_video_memory", &Dtool_DisplayInformation_get_video_memory_36, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_video_memory_36_comment},
  {"getVideoMemory", &Dtool_DisplayInformation_get_video_memory_36, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_video_memory_36_comment},
  {"get_texture_memory", &Dtool_DisplayInformation_get_texture_memory_37, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_texture_memory_37_comment},
  {"getTextureMemory", &Dtool_DisplayInformation_get_texture_memory_37, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_texture_memory_37_comment},
  {"update_memory_information", &Dtool_DisplayInformation_update_memory_information_38, METH_NOARGS, (const char *)Dtool_DisplayInformation_update_memory_information_38_comment},
  {"updateMemoryInformation", &Dtool_DisplayInformation_update_memory_information_38, METH_NOARGS, (const char *)Dtool_DisplayInformation_update_memory_information_38_comment},
  {"get_physical_memory", &Dtool_DisplayInformation_get_physical_memory_39, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_physical_memory_39_comment},
  {"getPhysicalMemory", &Dtool_DisplayInformation_get_physical_memory_39, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_physical_memory_39_comment},
  {"get_available_physical_memory", &Dtool_DisplayInformation_get_available_physical_memory_40, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_available_physical_memory_40_comment},
  {"getAvailablePhysicalMemory", &Dtool_DisplayInformation_get_available_physical_memory_40, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_available_physical_memory_40_comment},
  {"get_page_file_size", &Dtool_DisplayInformation_get_page_file_size_41, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_page_file_size_41_comment},
  {"getPageFileSize", &Dtool_DisplayInformation_get_page_file_size_41, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_page_file_size_41_comment},
  {"get_available_page_file_size", &Dtool_DisplayInformation_get_available_page_file_size_42, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_available_page_file_size_42_comment},
  {"getAvailablePageFileSize", &Dtool_DisplayInformation_get_available_page_file_size_42, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_available_page_file_size_42_comment},
  {"get_process_virtual_memory", &Dtool_DisplayInformation_get_process_virtual_memory_43, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_process_virtual_memory_43_comment},
  {"getProcessVirtualMemory", &Dtool_DisplayInformation_get_process_virtual_memory_43, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_process_virtual_memory_43_comment},
  {"get_available_process_virtual_memory", &Dtool_DisplayInformation_get_available_process_virtual_memory_44, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_available_process_virtual_memory_44_comment},
  {"getAvailableProcessVirtualMemory", &Dtool_DisplayInformation_get_available_process_virtual_memory_44, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_available_process_virtual_memory_44_comment},
  {"get_memory_load", &Dtool_DisplayInformation_get_memory_load_45, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_memory_load_45_comment},
  {"getMemoryLoad", &Dtool_DisplayInformation_get_memory_load_45, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_memory_load_45_comment},
  {"get_page_fault_count", &Dtool_DisplayInformation_get_page_fault_count_46, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_page_fault_count_46_comment},
  {"getPageFaultCount", &Dtool_DisplayInformation_get_page_fault_count_46, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_page_fault_count_46_comment},
  {"get_process_memory", &Dtool_DisplayInformation_get_process_memory_47, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_process_memory_47_comment},
  {"getProcessMemory", &Dtool_DisplayInformation_get_process_memory_47, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_process_memory_47_comment},
  {"get_peak_process_memory", &Dtool_DisplayInformation_get_peak_process_memory_48, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_peak_process_memory_48_comment},
  {"getPeakProcessMemory", &Dtool_DisplayInformation_get_peak_process_memory_48, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_peak_process_memory_48_comment},
  {"get_page_file_usage", &Dtool_DisplayInformation_get_page_file_usage_49, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_page_file_usage_49_comment},
  {"getPageFileUsage", &Dtool_DisplayInformation_get_page_file_usage_49, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_page_file_usage_49_comment},
  {"get_peak_page_file_usage", &Dtool_DisplayInformation_get_peak_page_file_usage_50, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_peak_page_file_usage_50_comment},
  {"getPeakPageFileUsage", &Dtool_DisplayInformation_get_peak_page_file_usage_50, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_peak_page_file_usage_50_comment},
  {"get_vendor_id", &Dtool_DisplayInformation_get_vendor_id_51, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_vendor_id_51_comment},
  {"getVendorId", &Dtool_DisplayInformation_get_vendor_id_51, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_vendor_id_51_comment},
  {"get_device_id", &Dtool_DisplayInformation_get_device_id_52, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_device_id_52_comment},
  {"getDeviceId", &Dtool_DisplayInformation_get_device_id_52, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_device_id_52_comment},
  {"get_driver_product", &Dtool_DisplayInformation_get_driver_product_53, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_driver_product_53_comment},
  {"getDriverProduct", &Dtool_DisplayInformation_get_driver_product_53, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_driver_product_53_comment},
  {"get_driver_version", &Dtool_DisplayInformation_get_driver_version_54, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_driver_version_54_comment},
  {"getDriverVersion", &Dtool_DisplayInformation_get_driver_version_54, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_driver_version_54_comment},
  {"get_driver_sub_version", &Dtool_DisplayInformation_get_driver_sub_version_55, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_driver_sub_version_55_comment},
  {"getDriverSubVersion", &Dtool_DisplayInformation_get_driver_sub_version_55, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_driver_sub_version_55_comment},
  {"get_driver_build", &Dtool_DisplayInformation_get_driver_build_56, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_driver_build_56_comment},
  {"getDriverBuild", &Dtool_DisplayInformation_get_driver_build_56, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_driver_build_56_comment},
  {"get_driver_date_month", &Dtool_DisplayInformation_get_driver_date_month_57, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_driver_date_month_57_comment},
  {"getDriverDateMonth", &Dtool_DisplayInformation_get_driver_date_month_57, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_driver_date_month_57_comment},
  {"get_driver_date_day", &Dtool_DisplayInformation_get_driver_date_day_58, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_driver_date_day_58_comment},
  {"getDriverDateDay", &Dtool_DisplayInformation_get_driver_date_day_58, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_driver_date_day_58_comment},
  {"get_driver_date_year", &Dtool_DisplayInformation_get_driver_date_year_59, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_driver_date_year_59_comment},
  {"getDriverDateYear", &Dtool_DisplayInformation_get_driver_date_year_59, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_driver_date_year_59_comment},
  {"get_cpu_vendor_string", &Dtool_DisplayInformation_get_cpu_vendor_string_60, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_cpu_vendor_string_60_comment},
  {"getCpuVendorString", &Dtool_DisplayInformation_get_cpu_vendor_string_60, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_cpu_vendor_string_60_comment},
  {"get_cpu_brand_string", &Dtool_DisplayInformation_get_cpu_brand_string_61, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_cpu_brand_string_61_comment},
  {"getCpuBrandString", &Dtool_DisplayInformation_get_cpu_brand_string_61, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_cpu_brand_string_61_comment},
  {"get_cpu_version_information", &Dtool_DisplayInformation_get_cpu_version_information_62, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_cpu_version_information_62_comment},
  {"getCpuVersionInformation", &Dtool_DisplayInformation_get_cpu_version_information_62, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_cpu_version_information_62_comment},
  {"get_cpu_brand_index", &Dtool_DisplayInformation_get_cpu_brand_index_63, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_cpu_brand_index_63_comment},
  {"getCpuBrandIndex", &Dtool_DisplayInformation_get_cpu_brand_index_63, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_cpu_brand_index_63_comment},
  {"get_cpu_frequency", &Dtool_DisplayInformation_get_cpu_frequency_64, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_cpu_frequency_64_comment},
  {"getCpuFrequency", &Dtool_DisplayInformation_get_cpu_frequency_64, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_cpu_frequency_64_comment},
  {"get_cpu_time", &Dtool_DisplayInformation_get_cpu_time_65, METH_NOARGS | METH_STATIC, (const char *)Dtool_DisplayInformation_get_cpu_time_65_comment},
  {"getCpuTime", &Dtool_DisplayInformation_get_cpu_time_65, METH_NOARGS | METH_STATIC, (const char *)Dtool_DisplayInformation_get_cpu_time_65_comment},
  {"get_maximum_cpu_frequency", &Dtool_DisplayInformation_get_maximum_cpu_frequency_66, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_maximum_cpu_frequency_66_comment},
  {"getMaximumCpuFrequency", &Dtool_DisplayInformation_get_maximum_cpu_frequency_66, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_maximum_cpu_frequency_66_comment},
  {"get_current_cpu_frequency", &Dtool_DisplayInformation_get_current_cpu_frequency_67, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_current_cpu_frequency_67_comment},
  {"getCurrentCpuFrequency", &Dtool_DisplayInformation_get_current_cpu_frequency_67, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_current_cpu_frequency_67_comment},
  {"update_cpu_frequency", &Dtool_DisplayInformation_update_cpu_frequency_68, METH_O, (const char *)Dtool_DisplayInformation_update_cpu_frequency_68_comment},
  {"updateCpuFrequency", &Dtool_DisplayInformation_update_cpu_frequency_68, METH_O, (const char *)Dtool_DisplayInformation_update_cpu_frequency_68_comment},
  {"get_num_cpu_cores", &Dtool_DisplayInformation_get_num_cpu_cores_69, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_num_cpu_cores_69_comment},
  {"getNumCpuCores", &Dtool_DisplayInformation_get_num_cpu_cores_69, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_num_cpu_cores_69_comment},
  {"get_num_logical_cpus", &Dtool_DisplayInformation_get_num_logical_cpus_70, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_num_logical_cpus_70_comment},
  {"getNumLogicalCpus", &Dtool_DisplayInformation_get_num_logical_cpus_70, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_num_logical_cpus_70_comment},
  {"get_os_version_major", &Dtool_DisplayInformation_get_os_version_major_71, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_os_version_major_71_comment},
  {"getOsVersionMajor", &Dtool_DisplayInformation_get_os_version_major_71, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_os_version_major_71_comment},
  {"get_os_version_minor", &Dtool_DisplayInformation_get_os_version_minor_72, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_os_version_minor_72_comment},
  {"getOsVersionMinor", &Dtool_DisplayInformation_get_os_version_minor_72, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_os_version_minor_72_comment},
  {"get_os_version_build", &Dtool_DisplayInformation_get_os_version_build_73, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_os_version_build_73_comment},
  {"getOsVersionBuild", &Dtool_DisplayInformation_get_os_version_build_73, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_os_version_build_73_comment},
  {"get_os_platform_id", &Dtool_DisplayInformation_get_os_platform_id_74, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_os_platform_id_74_comment},
  {"getOsPlatformId", &Dtool_DisplayInformation_get_os_platform_id_74, METH_NOARGS, (const char *)Dtool_DisplayInformation_get_os_platform_id_74_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_display_modes", (PyCFunction) &MakeSeq_DisplayInformation_get_display_modes, METH_NOARGS, nullptr},
  { "getDisplayModes", (PyCFunction) &MakeSeq_DisplayInformation_get_display_modes, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DisplayInformation = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_DisplayInformation = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DisplayInformation",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DisplayInformation,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DisplayInformation,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class contains various display information.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DisplayInformation,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DisplayInformation,
    PyType_GenericAlloc,
    Dtool_new_DisplayInformation,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DisplayInformation,
  Dtool_UpcastInterface_DisplayInformation,
  Dtool_DowncastInterface_DisplayInformation,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DisplayInformation(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DisplayInformation._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_DisplayInformation._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum DisplayInformation::DetectionState;
    PyDict_SetItemString(dict, "DS_unknown", Dtool_WrapValue(DisplayInformation::DS_unknown));
    PyDict_SetItemString(dict, "DSUnknown", Dtool_WrapValue(DisplayInformation::DS_unknown));
    PyDict_SetItemString(dict, "DS_success", Dtool_WrapValue(DisplayInformation::DS_success));
    PyDict_SetItemString(dict, "DSSuccess", Dtool_WrapValue(DisplayInformation::DS_success));
    PyDict_SetItemString(dict, "DS_direct_3d_create_error", Dtool_WrapValue(DisplayInformation::DS_direct_3d_create_error));
    PyDict_SetItemString(dict, "DSDirect3dCreateError", Dtool_WrapValue(DisplayInformation::DS_direct_3d_create_error));
    PyDict_SetItemString(dict, "DS_create_window_error", Dtool_WrapValue(DisplayInformation::DS_create_window_error));
    PyDict_SetItemString(dict, "DSCreateWindowError", Dtool_WrapValue(DisplayInformation::DS_create_window_error));
    PyDict_SetItemString(dict, "DS_create_device_error", Dtool_WrapValue(DisplayInformation::DS_create_device_error));
    PyDict_SetItemString(dict, "DSCreateDeviceError", Dtool_WrapValue(DisplayInformation::DS_create_device_error));
    if (PyType_Ready((PyTypeObject *)&Dtool_DisplayInformation) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DisplayInformation)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DisplayInformation);
  }
}

/**
 * Python method tables for DrawableRegion (DrawableRegion)
 */
static PyMethodDef Dtool_Methods_DrawableRegion[] = {
  {"set_clear_color_active", &Dtool_DrawableRegion_set_clear_color_active_84, METH_O, (const char *)Dtool_DrawableRegion_set_clear_color_active_84_comment},
  {"setClearColorActive", &Dtool_DrawableRegion_set_clear_color_active_84, METH_O, (const char *)Dtool_DrawableRegion_set_clear_color_active_84_comment},
  {"get_clear_color_active", &Dtool_DrawableRegion_get_clear_color_active_85, METH_NOARGS, (const char *)Dtool_DrawableRegion_get_clear_color_active_85_comment},
  {"getClearColorActive", &Dtool_DrawableRegion_get_clear_color_active_85, METH_NOARGS, (const char *)Dtool_DrawableRegion_get_clear_color_active_85_comment},
  {"set_clear_depth_active", &Dtool_DrawableRegion_set_clear_depth_active_86, METH_O, (const char *)Dtool_DrawableRegion_set_clear_depth_active_86_comment},
  {"setClearDepthActive", &Dtool_DrawableRegion_set_clear_depth_active_86, METH_O, (const char *)Dtool_DrawableRegion_set_clear_depth_active_86_comment},
  {"get_clear_depth_active", &Dtool_DrawableRegion_get_clear_depth_active_87, METH_NOARGS, (const char *)Dtool_DrawableRegion_get_clear_depth_active_87_comment},
  {"getClearDepthActive", &Dtool_DrawableRegion_get_clear_depth_active_87, METH_NOARGS, (const char *)Dtool_DrawableRegion_get_clear_depth_active_87_comment},
  {"set_clear_stencil_active", &Dtool_DrawableRegion_set_clear_stencil_active_88, METH_O, (const char *)Dtool_DrawableRegion_set_clear_stencil_active_88_comment},
  {"setClearStencilActive", &Dtool_DrawableRegion_set_clear_stencil_active_88, METH_O, (const char *)Dtool_DrawableRegion_set_clear_stencil_active_88_comment},
  {"get_clear_stencil_active", &Dtool_DrawableRegion_get_clear_stencil_active_89, METH_NOARGS, (const char *)Dtool_DrawableRegion_get_clear_stencil_active_89_comment},
  {"getClearStencilActive", &Dtool_DrawableRegion_get_clear_stencil_active_89, METH_NOARGS, (const char *)Dtool_DrawableRegion_get_clear_stencil_active_89_comment},
  {"set_clear_color", &Dtool_DrawableRegion_set_clear_color_90, METH_O, (const char *)Dtool_DrawableRegion_set_clear_color_90_comment},
  {"setClearColor", &Dtool_DrawableRegion_set_clear_color_90, METH_O, (const char *)Dtool_DrawableRegion_set_clear_color_90_comment},
  {"get_clear_color", &Dtool_DrawableRegion_get_clear_color_91, METH_NOARGS, (const char *)Dtool_DrawableRegion_get_clear_color_91_comment},
  {"getClearColor", &Dtool_DrawableRegion_get_clear_color_91, METH_NOARGS, (const char *)Dtool_DrawableRegion_get_clear_color_91_comment},
  {"set_clear_depth", &Dtool_DrawableRegion_set_clear_depth_97, METH_O, (const char *)Dtool_DrawableRegion_set_clear_depth_97_comment},
  {"setClearDepth", &Dtool_DrawableRegion_set_clear_depth_97, METH_O, (const char *)Dtool_DrawableRegion_set_clear_depth_97_comment},
  {"get_clear_depth", &Dtool_DrawableRegion_get_clear_depth_98, METH_NOARGS, (const char *)Dtool_DrawableRegion_get_clear_depth_98_comment},
  {"getClearDepth", &Dtool_DrawableRegion_get_clear_depth_98, METH_NOARGS, (const char *)Dtool_DrawableRegion_get_clear_depth_98_comment},
  {"set_clear_stencil", &Dtool_DrawableRegion_set_clear_stencil_102, METH_O, (const char *)Dtool_DrawableRegion_set_clear_stencil_102_comment},
  {"setClearStencil", &Dtool_DrawableRegion_set_clear_stencil_102, METH_O, (const char *)Dtool_DrawableRegion_set_clear_stencil_102_comment},
  {"get_clear_stencil", &Dtool_DrawableRegion_get_clear_stencil_103, METH_NOARGS, (const char *)Dtool_DrawableRegion_get_clear_stencil_103_comment},
  {"getClearStencil", &Dtool_DrawableRegion_get_clear_stencil_103, METH_NOARGS, (const char *)Dtool_DrawableRegion_get_clear_stencil_103_comment},
  {"set_clear_active", (PyCFunction) &Dtool_DrawableRegion_set_clear_active_106, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DrawableRegion_set_clear_active_106_comment},
  {"setClearActive", (PyCFunction) &Dtool_DrawableRegion_set_clear_active_106, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DrawableRegion_set_clear_active_106_comment},
  {"get_clear_active", &Dtool_DrawableRegion_get_clear_active_107, METH_O, (const char *)Dtool_DrawableRegion_get_clear_active_107_comment},
  {"getClearActive", &Dtool_DrawableRegion_get_clear_active_107, METH_O, (const char *)Dtool_DrawableRegion_get_clear_active_107_comment},
  {"set_clear_value", (PyCFunction) &Dtool_DrawableRegion_set_clear_value_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DrawableRegion_set_clear_value_108_comment},
  {"setClearValue", (PyCFunction) &Dtool_DrawableRegion_set_clear_value_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DrawableRegion_set_clear_value_108_comment},
  {"get_clear_value", &Dtool_DrawableRegion_get_clear_value_109, METH_O, (const char *)Dtool_DrawableRegion_get_clear_value_109_comment},
  {"getClearValue", &Dtool_DrawableRegion_get_clear_value_109, METH_O, (const char *)Dtool_DrawableRegion_get_clear_value_109_comment},
  {"disable_clears", &Dtool_DrawableRegion_disable_clears_110, METH_NOARGS, (const char *)Dtool_DrawableRegion_disable_clears_110_comment},
  {"disableClears", &Dtool_DrawableRegion_disable_clears_110, METH_NOARGS, (const char *)Dtool_DrawableRegion_disable_clears_110_comment},
  {"is_any_clear_active", &Dtool_DrawableRegion_is_any_clear_active_111, METH_NOARGS, (const char *)Dtool_DrawableRegion_is_any_clear_active_111_comment},
  {"isAnyClearActive", &Dtool_DrawableRegion_is_any_clear_active_111, METH_NOARGS, (const char *)Dtool_DrawableRegion_is_any_clear_active_111_comment},
  {"set_pixel_zoom", &Dtool_DrawableRegion_set_pixel_zoom_112, METH_O, (const char *)Dtool_DrawableRegion_set_pixel_zoom_112_comment},
  {"setPixelZoom", &Dtool_DrawableRegion_set_pixel_zoom_112, METH_O, (const char *)Dtool_DrawableRegion_set_pixel_zoom_112_comment},
  {"get_pixel_zoom", &Dtool_DrawableRegion_get_pixel_zoom_113, METH_NOARGS, (const char *)Dtool_DrawableRegion_get_pixel_zoom_113_comment},
  {"getPixelZoom", &Dtool_DrawableRegion_get_pixel_zoom_113, METH_NOARGS, (const char *)Dtool_DrawableRegion_get_pixel_zoom_113_comment},
  {"get_pixel_factor", &Dtool_DrawableRegion_get_pixel_factor_114, METH_NOARGS, (const char *)Dtool_DrawableRegion_get_pixel_factor_114_comment},
  {"getPixelFactor", &Dtool_DrawableRegion_get_pixel_factor_114, METH_NOARGS, (const char *)Dtool_DrawableRegion_get_pixel_factor_114_comment},
  {"supports_pixel_zoom", &Dtool_DrawableRegion_supports_pixel_zoom_115, METH_NOARGS, (const char *)Dtool_DrawableRegion_supports_pixel_zoom_115_comment},
  {"supportsPixelZoom", &Dtool_DrawableRegion_supports_pixel_zoom_115, METH_NOARGS, (const char *)Dtool_DrawableRegion_supports_pixel_zoom_115_comment},
  {"get_renderbuffer_type", &Dtool_DrawableRegion_get_renderbuffer_type_118, METH_O | METH_STATIC, (const char *)Dtool_DrawableRegion_get_renderbuffer_type_118_comment},
  {"getRenderbufferType", &Dtool_DrawableRegion_get_renderbuffer_type_118, METH_O | METH_STATIC, (const char *)Dtool_DrawableRegion_get_renderbuffer_type_118_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_DrawableRegion[] = {
  {(char *)"clear_color", &Dtool_DrawableRegion_clear_color_Getter, &Dtool_DrawableRegion_clear_color_Setter, nullptr, nullptr},
  {(char *)"clear_depth", &Dtool_DrawableRegion_clear_depth_Getter, &Dtool_DrawableRegion_clear_depth_Setter, nullptr, nullptr},
  {(char *)"clear_stencil", &Dtool_DrawableRegion_clear_stencil_Getter, &Dtool_DrawableRegion_clear_stencil_Setter, nullptr, nullptr},
  {(char *)"pixel_zoom", &Dtool_DrawableRegion_pixel_zoom_Getter, &Dtool_DrawableRegion_pixel_zoom_Setter, nullptr, nullptr},
  {(char *)"pixel_factor", &Dtool_DrawableRegion_pixel_factor_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_DrawableRegion = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_DrawableRegion = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DrawableRegion",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DrawableRegion,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DrawableRegion,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a base class for GraphicsWindow (actually, GraphicsOutput) and\n"
    " * DisplayRegion, both of which are conceptually rectangular regions into\n"
    " * which drawing commands may be issued.  Sometimes you want to deal with a\n"
    " * single display region, and sometimes you want to deal with the whole window\n"
    " * at once, particularly for issuing clear commands and capturing screenshots.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DrawableRegion,
    nullptr, // tp_members
    Dtool_Properties_DrawableRegion,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DrawableRegion,
    PyType_GenericAlloc,
    Dtool_new_DrawableRegion,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DrawableRegion,
  Dtool_UpcastInterface_DrawableRegion,
  Dtool_DowncastInterface_DrawableRegion,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DrawableRegion(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DrawableRegion._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(35);
    Dtool_DrawableRegion._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum DrawableRegion::RenderTexturePlane;
    PyDict_SetItemString(dict, "RTP_stencil", Dtool_WrapValue(DrawableRegion::RTP_stencil));
    PyDict_SetItemString(dict, "RTPStencil", Dtool_WrapValue(DrawableRegion::RTP_stencil));
    PyDict_SetItemString(dict, "RTP_depth_stencil", Dtool_WrapValue(DrawableRegion::RTP_depth_stencil));
    PyDict_SetItemString(dict, "RTPDepthStencil", Dtool_WrapValue(DrawableRegion::RTP_depth_stencil));
    PyDict_SetItemString(dict, "RTP_color", Dtool_WrapValue(DrawableRegion::RTP_color));
    PyDict_SetItemString(dict, "RTPColor", Dtool_WrapValue(DrawableRegion::RTP_color));
    PyDict_SetItemString(dict, "RTP_aux_rgba_0", Dtool_WrapValue(DrawableRegion::RTP_aux_rgba_0));
    PyDict_SetItemString(dict, "RTPAuxRgba0", Dtool_WrapValue(DrawableRegion::RTP_aux_rgba_0));
    PyDict_SetItemString(dict, "RTP_aux_rgba_1", Dtool_WrapValue(DrawableRegion::RTP_aux_rgba_1));
    PyDict_SetItemString(dict, "RTPAuxRgba1", Dtool_WrapValue(DrawableRegion::RTP_aux_rgba_1));
    PyDict_SetItemString(dict, "RTP_aux_rgba_2", Dtool_WrapValue(DrawableRegion::RTP_aux_rgba_2));
    PyDict_SetItemString(dict, "RTPAuxRgba2", Dtool_WrapValue(DrawableRegion::RTP_aux_rgba_2));
    PyDict_SetItemString(dict, "RTP_aux_rgba_3", Dtool_WrapValue(DrawableRegion::RTP_aux_rgba_3));
    PyDict_SetItemString(dict, "RTPAuxRgba3", Dtool_WrapValue(DrawableRegion::RTP_aux_rgba_3));
    PyDict_SetItemString(dict, "RTP_aux_hrgba_0", Dtool_WrapValue(DrawableRegion::RTP_aux_hrgba_0));
    PyDict_SetItemString(dict, "RTPAuxHrgba0", Dtool_WrapValue(DrawableRegion::RTP_aux_hrgba_0));
    PyDict_SetItemString(dict, "RTP_aux_hrgba_1", Dtool_WrapValue(DrawableRegion::RTP_aux_hrgba_1));
    PyDict_SetItemString(dict, "RTPAuxHrgba1", Dtool_WrapValue(DrawableRegion::RTP_aux_hrgba_1));
    PyDict_SetItemString(dict, "RTP_aux_hrgba_2", Dtool_WrapValue(DrawableRegion::RTP_aux_hrgba_2));
    PyDict_SetItemString(dict, "RTPAuxHrgba2", Dtool_WrapValue(DrawableRegion::RTP_aux_hrgba_2));
    PyDict_SetItemString(dict, "RTP_aux_hrgba_3", Dtool_WrapValue(DrawableRegion::RTP_aux_hrgba_3));
    PyDict_SetItemString(dict, "RTPAuxHrgba3", Dtool_WrapValue(DrawableRegion::RTP_aux_hrgba_3));
    PyDict_SetItemString(dict, "RTP_aux_float_0", Dtool_WrapValue(DrawableRegion::RTP_aux_float_0));
    PyDict_SetItemString(dict, "RTPAuxFloat0", Dtool_WrapValue(DrawableRegion::RTP_aux_float_0));
    PyDict_SetItemString(dict, "RTP_aux_float_1", Dtool_WrapValue(DrawableRegion::RTP_aux_float_1));
    PyDict_SetItemString(dict, "RTPAuxFloat1", Dtool_WrapValue(DrawableRegion::RTP_aux_float_1));
    PyDict_SetItemString(dict, "RTP_aux_float_2", Dtool_WrapValue(DrawableRegion::RTP_aux_float_2));
    PyDict_SetItemString(dict, "RTPAuxFloat2", Dtool_WrapValue(DrawableRegion::RTP_aux_float_2));
    PyDict_SetItemString(dict, "RTP_aux_float_3", Dtool_WrapValue(DrawableRegion::RTP_aux_float_3));
    PyDict_SetItemString(dict, "RTPAuxFloat3", Dtool_WrapValue(DrawableRegion::RTP_aux_float_3));
    PyDict_SetItemString(dict, "RTP_depth", Dtool_WrapValue(DrawableRegion::RTP_depth));
    PyDict_SetItemString(dict, "RTPDepth", Dtool_WrapValue(DrawableRegion::RTP_depth));
    PyDict_SetItemString(dict, "RTP_COUNT", Dtool_WrapValue(DrawableRegion::RTP_COUNT));
    PyDict_SetItemString(dict, "RTPCOUNT", Dtool_WrapValue(DrawableRegion::RTP_COUNT));
    if (PyType_Ready((PyTypeObject *)&Dtool_DrawableRegion) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DrawableRegion)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DrawableRegion);
  }
}

/**
 * Python method tables for WindowHandle_OSHandle (OSHandle)
 */
static PyMethodDef Dtool_Methods_WindowHandle_OSHandle[] = {
  {"get_int_handle", &Dtool_WindowHandle_OSHandle_get_int_handle_126, METH_NOARGS, (const char *)Dtool_WindowHandle_OSHandle_get_int_handle_126_comment},
  {"getIntHandle", &Dtool_WindowHandle_OSHandle_get_int_handle_126, METH_NOARGS, (const char *)Dtool_WindowHandle_OSHandle_get_int_handle_126_comment},
  {"output", &Dtool_WindowHandle_OSHandle_output_127, METH_O, (const char *)Dtool_WindowHandle_OSHandle_output_127_comment},
  {"get_class_type", &Dtool_WindowHandle_OSHandle_get_class_type_128, METH_NOARGS | METH_STATIC, (const char *)Dtool_WindowHandle_OSHandle_get_class_type_128_comment},
  {"getClassType", &Dtool_WindowHandle_OSHandle_get_class_type_128, METH_NOARGS | METH_STATIC, (const char *)Dtool_WindowHandle_OSHandle_get_class_type_128_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     WindowHandle_OSHandle
//////////////////
static PyObject *Dtool_Repr_WindowHandle_OSHandle(PyObject *self) {
  WindowHandle::OSHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowHandle_OSHandle, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_WindowHandle_OSHandle = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_WindowHandle_OSHandle = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_WindowHandle_OSHandle = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_WindowHandle_OSHandle = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_WindowHandle_OSHandle = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_WindowHandle_OSHandle = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.OSHandle",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_WindowHandle_OSHandle,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_WindowHandle_OSHandle,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_WindowHandle_OSHandle,
    &Dtool_NumberMethods_WindowHandle_OSHandle,
    &Dtool_SequenceMethods_WindowHandle_OSHandle,
    &Dtool_MappingMethods_WindowHandle_OSHandle,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_WindowHandle_OSHandle,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_WindowHandle_OSHandle,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "// This internal pointer within WindowHandle stores the actual OS-specific\n"
    "// window handle type, whatever type that is.  It is subclassed for each OS.",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_WindowHandle_OSHandle,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_WindowHandle_OSHandle,
    PyType_GenericAlloc,
    Dtool_new_WindowHandle_OSHandle,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_WindowHandle_OSHandle,
  Dtool_UpcastInterface_WindowHandle_OSHandle,
  Dtool_DowncastInterface_WindowHandle_OSHandle,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_WindowHandle_OSHandle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_WindowHandle_OSHandle._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_WindowHandle_OSHandle._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_WindowHandle_OSHandle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_WindowHandle_OSHandle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(WindowHandle_OSHandle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_WindowHandle_OSHandle);
  }
}

/**
 * Python method tables for WindowHandle (WindowHandle)
 */
static PyMethodDef Dtool_Methods_WindowHandle[] = {
  {"get_os_handle", &Dtool_WindowHandle_get_os_handle_121, METH_NOARGS, (const char *)Dtool_WindowHandle_get_os_handle_121_comment},
  {"getOsHandle", &Dtool_WindowHandle_get_os_handle_121, METH_NOARGS, (const char *)Dtool_WindowHandle_get_os_handle_121_comment},
  {"set_os_handle", &Dtool_WindowHandle_set_os_handle_122, METH_O, (const char *)Dtool_WindowHandle_set_os_handle_122_comment},
  {"setOsHandle", &Dtool_WindowHandle_set_os_handle_122, METH_O, (const char *)Dtool_WindowHandle_set_os_handle_122_comment},
  {"send_windows_message", (PyCFunction) &Dtool_WindowHandle_send_windows_message_130, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_WindowHandle_send_windows_message_130_comment},
  {"sendWindowsMessage", (PyCFunction) &Dtool_WindowHandle_send_windows_message_130, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_WindowHandle_send_windows_message_130_comment},
  {"get_int_handle", &Dtool_WindowHandle_get_int_handle_131, METH_NOARGS, (const char *)Dtool_WindowHandle_get_int_handle_131_comment},
  {"getIntHandle", &Dtool_WindowHandle_get_int_handle_131, METH_NOARGS, (const char *)Dtool_WindowHandle_get_int_handle_131_comment},
  {"output", &Dtool_WindowHandle_output_132, METH_O, (const char *)Dtool_WindowHandle_output_132_comment},
  {"get_class_type", &Dtool_WindowHandle_get_class_type_133, METH_NOARGS | METH_STATIC, (const char *)Dtool_WindowHandle_get_class_type_133_comment},
  {"getClassType", &Dtool_WindowHandle_get_class_type_133, METH_NOARGS | METH_STATIC, (const char *)Dtool_WindowHandle_get_class_type_133_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     WindowHandle
//////////////////
static PyObject *Dtool_Repr_WindowHandle(PyObject *self) {
  WindowHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowHandle, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_WindowHandle[] = {
  {(char *)"os_handle", &Dtool_WindowHandle_os_handle_Getter, &Dtool_WindowHandle_os_handle_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_WindowHandle = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_WindowHandle = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_WindowHandle = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_WindowHandle = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_WindowHandle = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_WindowHandle = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.WindowHandle",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_WindowHandle,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_WindowHandle,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_WindowHandle,
    &Dtool_NumberMethods_WindowHandle,
    &Dtool_SequenceMethods_WindowHandle,
    &Dtool_MappingMethods_WindowHandle,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_WindowHandle,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_WindowHandle,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This object represents a window on the desktop, not necessarily a Panda\n"
    " * window.  This structure can be assigned to a WindowProperties to indicate a\n"
    " * parent window.\n"
    " *\n"
    " * It also has callbacks so the Panda window can communicate with its parent\n"
    " * window, which is particularly important when running embedded in a browser.\n"
    " *\n"
    " * To create a WindowHandle, you would usually call one of the\n"
    " * NativeWindowHandle::make_*() methods, depending on the kind of native\n"
    " * window handle object you already have.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_WindowHandle,
    nullptr, // tp_members
    Dtool_Properties_WindowHandle,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_WindowHandle,
    PyType_GenericAlloc,
    Dtool_new_WindowHandle,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_WindowHandle,
  Dtool_UpcastInterface_WindowHandle,
  Dtool_DowncastInterface_WindowHandle,
  (CoerceFunction)Dtool_ConstCoerce_WindowHandle,
  (CoerceFunction)Dtool_Coerce_WindowHandle,
};

static void Dtool_PyModuleClassInit_WindowHandle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_WindowHandle._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_WindowHandle._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_WindowHandle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // Nested Object   WindowHandle_OSHandle;
    Dtool_PyModuleClassInit_WindowHandle_OSHandle(nullptr);
    PyDict_SetItemString(dict, "OSHandle", (PyObject *)&Dtool_WindowHandle_OSHandle);
    if (PyType_Ready((PyTypeObject *)&Dtool_WindowHandle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(WindowHandle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_WindowHandle);
  }
}

/**
 * Python method tables for WindowProperties (WindowProperties)
 */
static PyMethodDef Dtool_Methods_WindowProperties[] = {
  {"assign", &Dtool_WindowProperties_operator_138, METH_O, (const char *)Dtool_WindowProperties_operator_138_comment},
  {"get_config_properties", &Dtool_WindowProperties_get_config_properties_140, METH_NOARGS | METH_STATIC, (const char *)Dtool_WindowProperties_get_config_properties_140_comment},
  {"getConfigProperties", &Dtool_WindowProperties_get_config_properties_140, METH_NOARGS | METH_STATIC, (const char *)Dtool_WindowProperties_get_config_properties_140_comment},
  {"get_default", &Dtool_WindowProperties_get_default_141, METH_NOARGS | METH_STATIC, (const char *)Dtool_WindowProperties_get_default_141_comment},
  {"getDefault", &Dtool_WindowProperties_get_default_141, METH_NOARGS | METH_STATIC, (const char *)Dtool_WindowProperties_get_default_141_comment},
  {"set_default", &Dtool_WindowProperties_set_default_142, METH_O | METH_STATIC, (const char *)Dtool_WindowProperties_set_default_142_comment},
  {"setDefault", &Dtool_WindowProperties_set_default_142, METH_O | METH_STATIC, (const char *)Dtool_WindowProperties_set_default_142_comment},
  {"clear_default", &Dtool_WindowProperties_clear_default_143, METH_NOARGS | METH_STATIC, (const char *)Dtool_WindowProperties_clear_default_143_comment},
  {"clearDefault", &Dtool_WindowProperties_clear_default_143, METH_NOARGS | METH_STATIC, (const char *)Dtool_WindowProperties_clear_default_143_comment},
  {"size", &Dtool_WindowProperties_size_146, METH_VARARGS | METH_STATIC, (const char *)Dtool_WindowProperties_size_146_comment},
  {"clear", &Dtool_WindowProperties_clear_149, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_149_comment},
  {"is_any_specified", &Dtool_WindowProperties_is_any_specified_150, METH_NOARGS, (const char *)Dtool_WindowProperties_is_any_specified_150_comment},
  {"isAnySpecified", &Dtool_WindowProperties_is_any_specified_150, METH_NOARGS, (const char *)Dtool_WindowProperties_is_any_specified_150_comment},
  {"set_origin", (PyCFunction) &Dtool_WindowProperties_set_origin_151, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_WindowProperties_set_origin_151_comment},
  {"setOrigin", (PyCFunction) &Dtool_WindowProperties_set_origin_151, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_WindowProperties_set_origin_151_comment},
  {"get_origin", &Dtool_WindowProperties_get_origin_152, METH_NOARGS, (const char *)Dtool_WindowProperties_get_origin_152_comment},
  {"getOrigin", &Dtool_WindowProperties_get_origin_152, METH_NOARGS, (const char *)Dtool_WindowProperties_get_origin_152_comment},
  {"get_x_origin", &Dtool_WindowProperties_get_x_origin_153, METH_NOARGS, (const char *)Dtool_WindowProperties_get_x_origin_153_comment},
  {"getXOrigin", &Dtool_WindowProperties_get_x_origin_153, METH_NOARGS, (const char *)Dtool_WindowProperties_get_x_origin_153_comment},
  {"get_y_origin", &Dtool_WindowProperties_get_y_origin_154, METH_NOARGS, (const char *)Dtool_WindowProperties_get_y_origin_154_comment},
  {"getYOrigin", &Dtool_WindowProperties_get_y_origin_154, METH_NOARGS, (const char *)Dtool_WindowProperties_get_y_origin_154_comment},
  {"has_origin", &Dtool_WindowProperties_has_origin_155, METH_NOARGS, (const char *)Dtool_WindowProperties_has_origin_155_comment},
  {"hasOrigin", &Dtool_WindowProperties_has_origin_155, METH_NOARGS, (const char *)Dtool_WindowProperties_has_origin_155_comment},
  {"clear_origin", &Dtool_WindowProperties_clear_origin_156, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_origin_156_comment},
  {"clearOrigin", &Dtool_WindowProperties_clear_origin_156, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_origin_156_comment},
  {"set_size", (PyCFunction) &Dtool_WindowProperties_set_size_160, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_WindowProperties_set_size_160_comment},
  {"setSize", (PyCFunction) &Dtool_WindowProperties_set_size_160, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_WindowProperties_set_size_160_comment},
  {"get_size", &Dtool_WindowProperties_get_size_161, METH_NOARGS, (const char *)Dtool_WindowProperties_get_size_161_comment},
  {"getSize", &Dtool_WindowProperties_get_size_161, METH_NOARGS, (const char *)Dtool_WindowProperties_get_size_161_comment},
  {"get_x_size", &Dtool_WindowProperties_get_x_size_162, METH_NOARGS, (const char *)Dtool_WindowProperties_get_x_size_162_comment},
  {"getXSize", &Dtool_WindowProperties_get_x_size_162, METH_NOARGS, (const char *)Dtool_WindowProperties_get_x_size_162_comment},
  {"get_y_size", &Dtool_WindowProperties_get_y_size_163, METH_NOARGS, (const char *)Dtool_WindowProperties_get_y_size_163_comment},
  {"getYSize", &Dtool_WindowProperties_get_y_size_163, METH_NOARGS, (const char *)Dtool_WindowProperties_get_y_size_163_comment},
  {"has_size", &Dtool_WindowProperties_has_size_164, METH_NOARGS, (const char *)Dtool_WindowProperties_has_size_164_comment},
  {"hasSize", &Dtool_WindowProperties_has_size_164, METH_NOARGS, (const char *)Dtool_WindowProperties_has_size_164_comment},
  {"clear_size", &Dtool_WindowProperties_clear_size_165, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_size_165_comment},
  {"clearSize", &Dtool_WindowProperties_clear_size_165, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_size_165_comment},
  {"has_mouse_mode", &Dtool_WindowProperties_has_mouse_mode_169, METH_NOARGS, (const char *)Dtool_WindowProperties_has_mouse_mode_169_comment},
  {"hasMouseMode", &Dtool_WindowProperties_has_mouse_mode_169, METH_NOARGS, (const char *)Dtool_WindowProperties_has_mouse_mode_169_comment},
  {"set_mouse_mode", &Dtool_WindowProperties_set_mouse_mode_170, METH_O, (const char *)Dtool_WindowProperties_set_mouse_mode_170_comment},
  {"setMouseMode", &Dtool_WindowProperties_set_mouse_mode_170, METH_O, (const char *)Dtool_WindowProperties_set_mouse_mode_170_comment},
  {"get_mouse_mode", &Dtool_WindowProperties_get_mouse_mode_171, METH_NOARGS, (const char *)Dtool_WindowProperties_get_mouse_mode_171_comment},
  {"getMouseMode", &Dtool_WindowProperties_get_mouse_mode_171, METH_NOARGS, (const char *)Dtool_WindowProperties_get_mouse_mode_171_comment},
  {"clear_mouse_mode", &Dtool_WindowProperties_clear_mouse_mode_172, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_mouse_mode_172_comment},
  {"clearMouseMode", &Dtool_WindowProperties_clear_mouse_mode_172, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_mouse_mode_172_comment},
  {"set_title", &Dtool_WindowProperties_set_title_174, METH_O, (const char *)Dtool_WindowProperties_set_title_174_comment},
  {"setTitle", &Dtool_WindowProperties_set_title_174, METH_O, (const char *)Dtool_WindowProperties_set_title_174_comment},
  {"get_title", &Dtool_WindowProperties_get_title_175, METH_NOARGS, (const char *)Dtool_WindowProperties_get_title_175_comment},
  {"getTitle", &Dtool_WindowProperties_get_title_175, METH_NOARGS, (const char *)Dtool_WindowProperties_get_title_175_comment},
  {"has_title", &Dtool_WindowProperties_has_title_176, METH_NOARGS, (const char *)Dtool_WindowProperties_has_title_176_comment},
  {"hasTitle", &Dtool_WindowProperties_has_title_176, METH_NOARGS, (const char *)Dtool_WindowProperties_has_title_176_comment},
  {"clear_title", &Dtool_WindowProperties_clear_title_177, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_title_177_comment},
  {"clearTitle", &Dtool_WindowProperties_clear_title_177, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_title_177_comment},
  {"set_undecorated", &Dtool_WindowProperties_set_undecorated_180, METH_O, (const char *)Dtool_WindowProperties_set_undecorated_180_comment},
  {"setUndecorated", &Dtool_WindowProperties_set_undecorated_180, METH_O, (const char *)Dtool_WindowProperties_set_undecorated_180_comment},
  {"get_undecorated", &Dtool_WindowProperties_get_undecorated_181, METH_NOARGS, (const char *)Dtool_WindowProperties_get_undecorated_181_comment},
  {"getUndecorated", &Dtool_WindowProperties_get_undecorated_181, METH_NOARGS, (const char *)Dtool_WindowProperties_get_undecorated_181_comment},
  {"has_undecorated", &Dtool_WindowProperties_has_undecorated_182, METH_NOARGS, (const char *)Dtool_WindowProperties_has_undecorated_182_comment},
  {"hasUndecorated", &Dtool_WindowProperties_has_undecorated_182, METH_NOARGS, (const char *)Dtool_WindowProperties_has_undecorated_182_comment},
  {"clear_undecorated", &Dtool_WindowProperties_clear_undecorated_183, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_undecorated_183_comment},
  {"clearUndecorated", &Dtool_WindowProperties_clear_undecorated_183, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_undecorated_183_comment},
  {"set_fixed_size", &Dtool_WindowProperties_set_fixed_size_186, METH_O, (const char *)Dtool_WindowProperties_set_fixed_size_186_comment},
  {"setFixedSize", &Dtool_WindowProperties_set_fixed_size_186, METH_O, (const char *)Dtool_WindowProperties_set_fixed_size_186_comment},
  {"get_fixed_size", &Dtool_WindowProperties_get_fixed_size_187, METH_NOARGS, (const char *)Dtool_WindowProperties_get_fixed_size_187_comment},
  {"getFixedSize", &Dtool_WindowProperties_get_fixed_size_187, METH_NOARGS, (const char *)Dtool_WindowProperties_get_fixed_size_187_comment},
  {"has_fixed_size", &Dtool_WindowProperties_has_fixed_size_188, METH_NOARGS, (const char *)Dtool_WindowProperties_has_fixed_size_188_comment},
  {"hasFixedSize", &Dtool_WindowProperties_has_fixed_size_188, METH_NOARGS, (const char *)Dtool_WindowProperties_has_fixed_size_188_comment},
  {"clear_fixed_size", &Dtool_WindowProperties_clear_fixed_size_189, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_fixed_size_189_comment},
  {"clearFixedSize", &Dtool_WindowProperties_clear_fixed_size_189, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_fixed_size_189_comment},
  {"set_fullscreen", &Dtool_WindowProperties_set_fullscreen_191, METH_O, (const char *)Dtool_WindowProperties_set_fullscreen_191_comment},
  {"setFullscreen", &Dtool_WindowProperties_set_fullscreen_191, METH_O, (const char *)Dtool_WindowProperties_set_fullscreen_191_comment},
  {"get_fullscreen", &Dtool_WindowProperties_get_fullscreen_192, METH_NOARGS, (const char *)Dtool_WindowProperties_get_fullscreen_192_comment},
  {"getFullscreen", &Dtool_WindowProperties_get_fullscreen_192, METH_NOARGS, (const char *)Dtool_WindowProperties_get_fullscreen_192_comment},
  {"has_fullscreen", &Dtool_WindowProperties_has_fullscreen_193, METH_NOARGS, (const char *)Dtool_WindowProperties_has_fullscreen_193_comment},
  {"hasFullscreen", &Dtool_WindowProperties_has_fullscreen_193, METH_NOARGS, (const char *)Dtool_WindowProperties_has_fullscreen_193_comment},
  {"clear_fullscreen", &Dtool_WindowProperties_clear_fullscreen_194, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_fullscreen_194_comment},
  {"clearFullscreen", &Dtool_WindowProperties_clear_fullscreen_194, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_fullscreen_194_comment},
  {"set_foreground", &Dtool_WindowProperties_set_foreground_196, METH_O, (const char *)Dtool_WindowProperties_set_foreground_196_comment},
  {"setForeground", &Dtool_WindowProperties_set_foreground_196, METH_O, (const char *)Dtool_WindowProperties_set_foreground_196_comment},
  {"get_foreground", &Dtool_WindowProperties_get_foreground_197, METH_NOARGS, (const char *)Dtool_WindowProperties_get_foreground_197_comment},
  {"getForeground", &Dtool_WindowProperties_get_foreground_197, METH_NOARGS, (const char *)Dtool_WindowProperties_get_foreground_197_comment},
  {"has_foreground", &Dtool_WindowProperties_has_foreground_198, METH_NOARGS, (const char *)Dtool_WindowProperties_has_foreground_198_comment},
  {"hasForeground", &Dtool_WindowProperties_has_foreground_198, METH_NOARGS, (const char *)Dtool_WindowProperties_has_foreground_198_comment},
  {"clear_foreground", &Dtool_WindowProperties_clear_foreground_199, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_foreground_199_comment},
  {"clearForeground", &Dtool_WindowProperties_clear_foreground_199, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_foreground_199_comment},
  {"set_minimized", &Dtool_WindowProperties_set_minimized_201, METH_O, (const char *)Dtool_WindowProperties_set_minimized_201_comment},
  {"setMinimized", &Dtool_WindowProperties_set_minimized_201, METH_O, (const char *)Dtool_WindowProperties_set_minimized_201_comment},
  {"get_minimized", &Dtool_WindowProperties_get_minimized_202, METH_NOARGS, (const char *)Dtool_WindowProperties_get_minimized_202_comment},
  {"getMinimized", &Dtool_WindowProperties_get_minimized_202, METH_NOARGS, (const char *)Dtool_WindowProperties_get_minimized_202_comment},
  {"has_minimized", &Dtool_WindowProperties_has_minimized_203, METH_NOARGS, (const char *)Dtool_WindowProperties_has_minimized_203_comment},
  {"hasMinimized", &Dtool_WindowProperties_has_minimized_203, METH_NOARGS, (const char *)Dtool_WindowProperties_has_minimized_203_comment},
  {"clear_minimized", &Dtool_WindowProperties_clear_minimized_204, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_minimized_204_comment},
  {"clearMinimized", &Dtool_WindowProperties_clear_minimized_204, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_minimized_204_comment},
  {"set_raw_mice", &Dtool_WindowProperties_set_raw_mice_206, METH_O, (const char *)Dtool_WindowProperties_set_raw_mice_206_comment},
  {"setRawMice", &Dtool_WindowProperties_set_raw_mice_206, METH_O, (const char *)Dtool_WindowProperties_set_raw_mice_206_comment},
  {"get_raw_mice", &Dtool_WindowProperties_get_raw_mice_207, METH_NOARGS, (const char *)Dtool_WindowProperties_get_raw_mice_207_comment},
  {"getRawMice", &Dtool_WindowProperties_get_raw_mice_207, METH_NOARGS, (const char *)Dtool_WindowProperties_get_raw_mice_207_comment},
  {"has_raw_mice", &Dtool_WindowProperties_has_raw_mice_208, METH_NOARGS, (const char *)Dtool_WindowProperties_has_raw_mice_208_comment},
  {"hasRawMice", &Dtool_WindowProperties_has_raw_mice_208, METH_NOARGS, (const char *)Dtool_WindowProperties_has_raw_mice_208_comment},
  {"clear_raw_mice", &Dtool_WindowProperties_clear_raw_mice_209, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_raw_mice_209_comment},
  {"clearRawMice", &Dtool_WindowProperties_clear_raw_mice_209, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_raw_mice_209_comment},
  {"set_open", &Dtool_WindowProperties_set_open_210, METH_O, (const char *)Dtool_WindowProperties_set_open_210_comment},
  {"setOpen", &Dtool_WindowProperties_set_open_210, METH_O, (const char *)Dtool_WindowProperties_set_open_210_comment},
  {"get_open", &Dtool_WindowProperties_get_open_211, METH_NOARGS, (const char *)Dtool_WindowProperties_get_open_211_comment},
  {"getOpen", &Dtool_WindowProperties_get_open_211, METH_NOARGS, (const char *)Dtool_WindowProperties_get_open_211_comment},
  {"has_open", &Dtool_WindowProperties_has_open_212, METH_NOARGS, (const char *)Dtool_WindowProperties_has_open_212_comment},
  {"hasOpen", &Dtool_WindowProperties_has_open_212, METH_NOARGS, (const char *)Dtool_WindowProperties_has_open_212_comment},
  {"clear_open", &Dtool_WindowProperties_clear_open_213, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_open_213_comment},
  {"clearOpen", &Dtool_WindowProperties_clear_open_213, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_open_213_comment},
  {"set_cursor_hidden", &Dtool_WindowProperties_set_cursor_hidden_215, METH_O, (const char *)Dtool_WindowProperties_set_cursor_hidden_215_comment},
  {"setCursorHidden", &Dtool_WindowProperties_set_cursor_hidden_215, METH_O, (const char *)Dtool_WindowProperties_set_cursor_hidden_215_comment},
  {"get_cursor_hidden", &Dtool_WindowProperties_get_cursor_hidden_216, METH_NOARGS, (const char *)Dtool_WindowProperties_get_cursor_hidden_216_comment},
  {"getCursorHidden", &Dtool_WindowProperties_get_cursor_hidden_216, METH_NOARGS, (const char *)Dtool_WindowProperties_get_cursor_hidden_216_comment},
  {"has_cursor_hidden", &Dtool_WindowProperties_has_cursor_hidden_217, METH_NOARGS, (const char *)Dtool_WindowProperties_has_cursor_hidden_217_comment},
  {"hasCursorHidden", &Dtool_WindowProperties_has_cursor_hidden_217, METH_NOARGS, (const char *)Dtool_WindowProperties_has_cursor_hidden_217_comment},
  {"clear_cursor_hidden", &Dtool_WindowProperties_clear_cursor_hidden_218, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_cursor_hidden_218_comment},
  {"clearCursorHidden", &Dtool_WindowProperties_clear_cursor_hidden_218, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_cursor_hidden_218_comment},
  {"set_icon_filename", &Dtool_WindowProperties_set_icon_filename_220, METH_O, (const char *)Dtool_WindowProperties_set_icon_filename_220_comment},
  {"setIconFilename", &Dtool_WindowProperties_set_icon_filename_220, METH_O, (const char *)Dtool_WindowProperties_set_icon_filename_220_comment},
  {"get_icon_filename", &Dtool_WindowProperties_get_icon_filename_221, METH_NOARGS, (const char *)Dtool_WindowProperties_get_icon_filename_221_comment},
  {"getIconFilename", &Dtool_WindowProperties_get_icon_filename_221, METH_NOARGS, (const char *)Dtool_WindowProperties_get_icon_filename_221_comment},
  {"has_icon_filename", &Dtool_WindowProperties_has_icon_filename_222, METH_NOARGS, (const char *)Dtool_WindowProperties_has_icon_filename_222_comment},
  {"hasIconFilename", &Dtool_WindowProperties_has_icon_filename_222, METH_NOARGS, (const char *)Dtool_WindowProperties_has_icon_filename_222_comment},
  {"clear_icon_filename", &Dtool_WindowProperties_clear_icon_filename_223, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_icon_filename_223_comment},
  {"clearIconFilename", &Dtool_WindowProperties_clear_icon_filename_223, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_icon_filename_223_comment},
  {"set_cursor_filename", &Dtool_WindowProperties_set_cursor_filename_227, METH_O, (const char *)Dtool_WindowProperties_set_cursor_filename_227_comment},
  {"setCursorFilename", &Dtool_WindowProperties_set_cursor_filename_227, METH_O, (const char *)Dtool_WindowProperties_set_cursor_filename_227_comment},
  {"get_cursor_filename", &Dtool_WindowProperties_get_cursor_filename_228, METH_NOARGS, (const char *)Dtool_WindowProperties_get_cursor_filename_228_comment},
  {"getCursorFilename", &Dtool_WindowProperties_get_cursor_filename_228, METH_NOARGS, (const char *)Dtool_WindowProperties_get_cursor_filename_228_comment},
  {"has_cursor_filename", &Dtool_WindowProperties_has_cursor_filename_229, METH_NOARGS, (const char *)Dtool_WindowProperties_has_cursor_filename_229_comment},
  {"hasCursorFilename", &Dtool_WindowProperties_has_cursor_filename_229, METH_NOARGS, (const char *)Dtool_WindowProperties_has_cursor_filename_229_comment},
  {"clear_cursor_filename", &Dtool_WindowProperties_clear_cursor_filename_230, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_cursor_filename_230_comment},
  {"clearCursorFilename", &Dtool_WindowProperties_clear_cursor_filename_230, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_cursor_filename_230_comment},
  {"set_z_order", &Dtool_WindowProperties_set_z_order_232, METH_O, (const char *)Dtool_WindowProperties_set_z_order_232_comment},
  {"setZOrder", &Dtool_WindowProperties_set_z_order_232, METH_O, (const char *)Dtool_WindowProperties_set_z_order_232_comment},
  {"get_z_order", &Dtool_WindowProperties_get_z_order_233, METH_NOARGS, (const char *)Dtool_WindowProperties_get_z_order_233_comment},
  {"getZOrder", &Dtool_WindowProperties_get_z_order_233, METH_NOARGS, (const char *)Dtool_WindowProperties_get_z_order_233_comment},
  {"has_z_order", &Dtool_WindowProperties_has_z_order_234, METH_NOARGS, (const char *)Dtool_WindowProperties_has_z_order_234_comment},
  {"hasZOrder", &Dtool_WindowProperties_has_z_order_234, METH_NOARGS, (const char *)Dtool_WindowProperties_has_z_order_234_comment},
  {"clear_z_order", &Dtool_WindowProperties_clear_z_order_235, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_z_order_235_comment},
  {"clearZOrder", &Dtool_WindowProperties_clear_z_order_235, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_z_order_235_comment},
  {"set_parent_window", (PyCFunction) &Dtool_WindowProperties_set_parent_window_237, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_WindowProperties_set_parent_window_237_comment},
  {"setParentWindow", (PyCFunction) &Dtool_WindowProperties_set_parent_window_237, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_WindowProperties_set_parent_window_237_comment},
  {"get_parent_window", &Dtool_WindowProperties_get_parent_window_238, METH_NOARGS, (const char *)Dtool_WindowProperties_get_parent_window_238_comment},
  {"getParentWindow", &Dtool_WindowProperties_get_parent_window_238, METH_NOARGS, (const char *)Dtool_WindowProperties_get_parent_window_238_comment},
  {"has_parent_window", &Dtool_WindowProperties_has_parent_window_239, METH_NOARGS, (const char *)Dtool_WindowProperties_has_parent_window_239_comment},
  {"hasParentWindow", &Dtool_WindowProperties_has_parent_window_239, METH_NOARGS, (const char *)Dtool_WindowProperties_has_parent_window_239_comment},
  {"clear_parent_window", &Dtool_WindowProperties_clear_parent_window_240, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_parent_window_240_comment},
  {"clearParentWindow", &Dtool_WindowProperties_clear_parent_window_240, METH_NOARGS, (const char *)Dtool_WindowProperties_clear_parent_window_240_comment},
  {"add_properties", &Dtool_WindowProperties_add_properties_243, METH_O, (const char *)Dtool_WindowProperties_add_properties_243_comment},
  {"addProperties", &Dtool_WindowProperties_add_properties_243, METH_O, (const char *)Dtool_WindowProperties_add_properties_243_comment},
  {"output", &Dtool_WindowProperties_output_244, METH_O, (const char *)Dtool_WindowProperties_output_244_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     WindowProperties
//////////////////
static PyObject *Dtool_Repr_WindowProperties(PyObject *self) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowProperties, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     WindowProperties
//////////////////
static PyObject *Dtool_RichCompare_WindowProperties(PyObject *self, PyObject *arg, int op) {
  WindowProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WindowProperties, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-bool WindowProperties::operator ==(WindowProperties const &other) const
      WindowProperties arg_local;
      WindowProperties const *arg_this = Dtool_Coerce_WindowProperties(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const WindowProperties*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool WindowProperties::operator !=(WindowProperties const &other) const
      WindowProperties arg_local;
      WindowProperties const *arg_this = Dtool_Coerce_WindowProperties(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const WindowProperties*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_WindowProperties[] = {
  {(char *)"origin", &Dtool_WindowProperties_origin_Getter, &Dtool_WindowProperties_origin_Setter, nullptr, nullptr},
  {(char *)"size", &Dtool_WindowProperties_size_Getter, &Dtool_WindowProperties_size_Setter, nullptr, nullptr},
  {(char *)"mouse_mode", &Dtool_WindowProperties_mouse_mode_Getter, &Dtool_WindowProperties_mouse_mode_Setter, nullptr, nullptr},
  {(char *)"title", &Dtool_WindowProperties_title_Getter, &Dtool_WindowProperties_title_Setter, nullptr, nullptr},
  {(char *)"undecorated", &Dtool_WindowProperties_undecorated_Getter, &Dtool_WindowProperties_undecorated_Setter, nullptr, nullptr},
  {(char *)"fixed_size", &Dtool_WindowProperties_fixed_size_Getter, &Dtool_WindowProperties_fixed_size_Setter, nullptr, nullptr},
  {(char *)"fullscreen", &Dtool_WindowProperties_fullscreen_Getter, &Dtool_WindowProperties_fullscreen_Setter, nullptr, nullptr},
  {(char *)"foreground", &Dtool_WindowProperties_foreground_Getter, &Dtool_WindowProperties_foreground_Setter, nullptr, nullptr},
  {(char *)"minimized", &Dtool_WindowProperties_minimized_Getter, &Dtool_WindowProperties_minimized_Setter, nullptr, nullptr},
  {(char *)"open", &Dtool_WindowProperties_open_Getter, &Dtool_WindowProperties_open_Setter, nullptr, nullptr},
  {(char *)"cursor_hidden", &Dtool_WindowProperties_cursor_hidden_Getter, &Dtool_WindowProperties_cursor_hidden_Setter, nullptr, nullptr},
  {(char *)"icon_filename", &Dtool_WindowProperties_icon_filename_Getter, &Dtool_WindowProperties_icon_filename_Setter, nullptr, nullptr},
  {(char *)"cursor_filename", &Dtool_WindowProperties_cursor_filename_Getter, &Dtool_WindowProperties_cursor_filename_Setter, nullptr, nullptr},
  {(char *)"z_order", &Dtool_WindowProperties_z_order_Getter, &Dtool_WindowProperties_z_order_Setter, nullptr, nullptr},
  {(char *)"parent_window", &Dtool_WindowProperties_parent_window_Getter, &Dtool_WindowProperties_parent_window_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_WindowProperties = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_WindowProperties = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.WindowProperties",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_WindowProperties,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    &Dtool_Repr_WindowProperties,
    &Dtool_NumberMethods_WindowProperties,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Repr_WindowProperties,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A container for the various kinds of properties we might ask to have on a\n"
    " * graphics window before we open it.  This also serves to hold the current\n"
    " * properties for a window after it has been opened.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_WindowProperties,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_WindowProperties,
    nullptr, // tp_members
    Dtool_Properties_WindowProperties,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_WindowProperties,
    PyType_GenericAlloc,
    Dtool_new_WindowProperties,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_WindowProperties,
  Dtool_UpcastInterface_WindowProperties,
  Dtool_DowncastInterface_WindowProperties,
  nullptr,
  (CoerceFunction)Dtool_Coerce_WindowProperties,
};

static void Dtool_PyModuleClassInit_WindowProperties(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_WindowProperties._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(13);
    Dtool_WindowProperties._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum WindowProperties::ZOrder;
    PyDict_SetItemString(dict, "Z_bottom", Dtool_WrapValue(WindowProperties::Z_bottom));
    PyDict_SetItemString(dict, "ZBottom", Dtool_WrapValue(WindowProperties::Z_bottom));
    PyDict_SetItemString(dict, "Z_normal", Dtool_WrapValue(WindowProperties::Z_normal));
    PyDict_SetItemString(dict, "ZNormal", Dtool_WrapValue(WindowProperties::Z_normal));
    PyDict_SetItemString(dict, "Z_top", Dtool_WrapValue(WindowProperties::Z_top));
    PyDict_SetItemString(dict, "ZTop", Dtool_WrapValue(WindowProperties::Z_top));
    // enum WindowProperties::MouseMode;
    PyDict_SetItemString(dict, "M_absolute", Dtool_WrapValue(WindowProperties::M_absolute));
    PyDict_SetItemString(dict, "MAbsolute", Dtool_WrapValue(WindowProperties::M_absolute));
    PyDict_SetItemString(dict, "M_relative", Dtool_WrapValue(WindowProperties::M_relative));
    PyDict_SetItemString(dict, "MRelative", Dtool_WrapValue(WindowProperties::M_relative));
    PyDict_SetItemString(dict, "M_confined", Dtool_WrapValue(WindowProperties::M_confined));
    PyDict_SetItemString(dict, "MConfined", Dtool_WrapValue(WindowProperties::M_confined));
    static const PyGetSetDef def_config_properties = {(char *)"config_properties", &Dtool_WindowProperties_config_properties_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "config_properties", Dtool_NewStaticProperty(&Dtool_WindowProperties._PyType, &def_config_properties));
    static const PyGetSetDef def_default = {(char *)"default", &Dtool_WindowProperties_default_Getter, &Dtool_WindowProperties_default_Setter, nullptr, nullptr};
    PyDict_SetItemString(dict, "default", Dtool_NewStaticProperty(&Dtool_WindowProperties._PyType, &def_default));
    static const PyGetSetDef def_size = {(char *)"size", &Dtool_WindowProperties_size_Getter, &Dtool_WindowProperties_size_Setter, nullptr, nullptr};
    PyDict_SetItemString(dict, "size", Dtool_NewStaticProperty(&Dtool_WindowProperties._PyType, &def_size));
    if (PyType_Ready((PyTypeObject *)&Dtool_WindowProperties) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(WindowProperties)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_WindowProperties);
  }
}

/**
 * Python method tables for DisplayRegion (DisplayRegion)
 */
static PyMethodDef Dtool_Methods_DisplayRegion[] = {
  {"get_num_regions", &Dtool_DisplayRegion_get_num_regions_251, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_num_regions_251_comment},
  {"getNumRegions", &Dtool_DisplayRegion_get_num_regions_251, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_num_regions_251_comment},
  {"set_num_regions", &Dtool_DisplayRegion_set_num_regions_252, METH_O, (const char *)Dtool_DisplayRegion_set_num_regions_252_comment},
  {"setNumRegions", &Dtool_DisplayRegion_set_num_regions_252, METH_O, (const char *)Dtool_DisplayRegion_set_num_regions_252_comment},
  {"get_dimensions", (PyCFunction) &Dtool_DisplayRegion_get_dimensions_253, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_dimensions_253_comment},
  {"getDimensions", (PyCFunction) &Dtool_DisplayRegion_get_dimensions_253, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_dimensions_253_comment},
  {"get_left", (PyCFunction) &Dtool_DisplayRegion_get_left_254, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_left_254_comment},
  {"getLeft", (PyCFunction) &Dtool_DisplayRegion_get_left_254, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_left_254_comment},
  {"get_right", (PyCFunction) &Dtool_DisplayRegion_get_right_255, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_right_255_comment},
  {"getRight", (PyCFunction) &Dtool_DisplayRegion_get_right_255, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_right_255_comment},
  {"get_bottom", (PyCFunction) &Dtool_DisplayRegion_get_bottom_256, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_bottom_256_comment},
  {"getBottom", (PyCFunction) &Dtool_DisplayRegion_get_bottom_256, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_bottom_256_comment},
  {"get_top", (PyCFunction) &Dtool_DisplayRegion_get_top_257, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_top_257_comment},
  {"getTop", (PyCFunction) &Dtool_DisplayRegion_get_top_257, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_top_257_comment},
  {"set_dimensions", (PyCFunction) &Dtool_DisplayRegion_set_dimensions_258, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_set_dimensions_258_comment},
  {"setDimensions", (PyCFunction) &Dtool_DisplayRegion_set_dimensions_258, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_set_dimensions_258_comment},
  {"get_window", &Dtool_DisplayRegion_get_window_261, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_window_261_comment},
  {"getWindow", &Dtool_DisplayRegion_get_window_261, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_window_261_comment},
  {"get_pipe", &Dtool_DisplayRegion_get_pipe_262, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_pipe_262_comment},
  {"getPipe", &Dtool_DisplayRegion_get_pipe_262, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_pipe_262_comment},
  {"is_stereo", &Dtool_DisplayRegion_is_stereo_263, METH_NOARGS, (const char *)Dtool_DisplayRegion_is_stereo_263_comment},
  {"isStereo", &Dtool_DisplayRegion_is_stereo_263, METH_NOARGS, (const char *)Dtool_DisplayRegion_is_stereo_263_comment},
  {"set_camera", &Dtool_DisplayRegion_set_camera_619, METH_O, (const char *)Dtool_DisplayRegion_set_camera_619_comment},
  {"setCamera", &Dtool_DisplayRegion_set_camera_619, METH_O, (const char *)Dtool_DisplayRegion_set_camera_619_comment},
  {"get_camera", (PyCFunction) &Dtool_DisplayRegion_get_camera_620, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_camera_620_comment},
  {"getCamera", (PyCFunction) &Dtool_DisplayRegion_get_camera_620, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_camera_620_comment},
  {"set_active", &Dtool_DisplayRegion_set_active_623, METH_O, (const char *)Dtool_DisplayRegion_set_active_623_comment},
  {"setActive", &Dtool_DisplayRegion_set_active_623, METH_O, (const char *)Dtool_DisplayRegion_set_active_623_comment},
  {"is_active", &Dtool_DisplayRegion_is_active_624, METH_NOARGS, (const char *)Dtool_DisplayRegion_is_active_624_comment},
  {"isActive", &Dtool_DisplayRegion_is_active_624, METH_NOARGS, (const char *)Dtool_DisplayRegion_is_active_624_comment},
  {"set_sort", &Dtool_DisplayRegion_set_sort_626, METH_O, (const char *)Dtool_DisplayRegion_set_sort_626_comment},
  {"setSort", &Dtool_DisplayRegion_set_sort_626, METH_O, (const char *)Dtool_DisplayRegion_set_sort_626_comment},
  {"get_sort", &Dtool_DisplayRegion_get_sort_627, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_sort_627_comment},
  {"getSort", &Dtool_DisplayRegion_get_sort_627, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_sort_627_comment},
  {"set_stereo_channel", &Dtool_DisplayRegion_set_stereo_channel_629, METH_O, (const char *)Dtool_DisplayRegion_set_stereo_channel_629_comment},
  {"setStereoChannel", &Dtool_DisplayRegion_set_stereo_channel_629, METH_O, (const char *)Dtool_DisplayRegion_set_stereo_channel_629_comment},
  {"get_stereo_channel", &Dtool_DisplayRegion_get_stereo_channel_630, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_stereo_channel_630_comment},
  {"getStereoChannel", &Dtool_DisplayRegion_get_stereo_channel_630, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_stereo_channel_630_comment},
  {"set_tex_view_offset", &Dtool_DisplayRegion_set_tex_view_offset_634, METH_O, (const char *)Dtool_DisplayRegion_set_tex_view_offset_634_comment},
  {"setTexViewOffset", &Dtool_DisplayRegion_set_tex_view_offset_634, METH_O, (const char *)Dtool_DisplayRegion_set_tex_view_offset_634_comment},
  {"get_tex_view_offset", &Dtool_DisplayRegion_get_tex_view_offset_635, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_tex_view_offset_635_comment},
  {"getTexViewOffset", &Dtool_DisplayRegion_get_tex_view_offset_635, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_tex_view_offset_635_comment},
  {"set_incomplete_render", &Dtool_DisplayRegion_set_incomplete_render_637, METH_O, (const char *)Dtool_DisplayRegion_set_incomplete_render_637_comment},
  {"setIncompleteRender", &Dtool_DisplayRegion_set_incomplete_render_637, METH_O, (const char *)Dtool_DisplayRegion_set_incomplete_render_637_comment},
  {"get_incomplete_render", &Dtool_DisplayRegion_get_incomplete_render_638, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_incomplete_render_638_comment},
  {"getIncompleteRender", &Dtool_DisplayRegion_get_incomplete_render_638, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_incomplete_render_638_comment},
  {"set_texture_reload_priority", &Dtool_DisplayRegion_set_texture_reload_priority_640, METH_O, (const char *)Dtool_DisplayRegion_set_texture_reload_priority_640_comment},
  {"setTextureReloadPriority", &Dtool_DisplayRegion_set_texture_reload_priority_640, METH_O, (const char *)Dtool_DisplayRegion_set_texture_reload_priority_640_comment},
  {"get_texture_reload_priority", &Dtool_DisplayRegion_get_texture_reload_priority_641, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_texture_reload_priority_641_comment},
  {"getTextureReloadPriority", &Dtool_DisplayRegion_get_texture_reload_priority_641, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_texture_reload_priority_641_comment},
  {"set_lens_index", &Dtool_DisplayRegion_set_lens_index_643, METH_O, (const char *)Dtool_DisplayRegion_set_lens_index_643_comment},
  {"setLensIndex", &Dtool_DisplayRegion_set_lens_index_643, METH_O, (const char *)Dtool_DisplayRegion_set_lens_index_643_comment},
  {"get_lens_index", &Dtool_DisplayRegion_get_lens_index_644, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_lens_index_644_comment},
  {"getLensIndex", &Dtool_DisplayRegion_get_lens_index_644, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_lens_index_644_comment},
  {"set_cull_traverser", &Dtool_DisplayRegion_set_cull_traverser_646, METH_O, (const char *)Dtool_DisplayRegion_set_cull_traverser_646_comment},
  {"setCullTraverser", &Dtool_DisplayRegion_set_cull_traverser_646, METH_O, (const char *)Dtool_DisplayRegion_set_cull_traverser_646_comment},
  {"get_cull_traverser", &Dtool_DisplayRegion_get_cull_traverser_647, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_cull_traverser_647_comment},
  {"getCullTraverser", &Dtool_DisplayRegion_get_cull_traverser_647, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_cull_traverser_647_comment},
  {"set_cube_map_index", &Dtool_DisplayRegion_set_cube_map_index_651, METH_O, (const char *)Dtool_DisplayRegion_set_cube_map_index_651_comment},
  {"setCubeMapIndex", &Dtool_DisplayRegion_set_cube_map_index_651, METH_O, (const char *)Dtool_DisplayRegion_set_cube_map_index_651_comment},
  {"set_target_tex_page", &Dtool_DisplayRegion_set_target_tex_page_652, METH_O, (const char *)Dtool_DisplayRegion_set_target_tex_page_652_comment},
  {"setTargetTexPage", &Dtool_DisplayRegion_set_target_tex_page_652, METH_O, (const char *)Dtool_DisplayRegion_set_target_tex_page_652_comment},
  {"get_target_tex_page", &Dtool_DisplayRegion_get_target_tex_page_653, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_target_tex_page_653_comment},
  {"getTargetTexPage", &Dtool_DisplayRegion_get_target_tex_page_653, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_target_tex_page_653_comment},
  {"set_scissor_enabled", &Dtool_DisplayRegion_set_scissor_enabled_655, METH_O, (const char *)Dtool_DisplayRegion_set_scissor_enabled_655_comment},
  {"setScissorEnabled", &Dtool_DisplayRegion_set_scissor_enabled_655, METH_O, (const char *)Dtool_DisplayRegion_set_scissor_enabled_655_comment},
  {"get_scissor_enabled", &Dtool_DisplayRegion_get_scissor_enabled_656, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_scissor_enabled_656_comment},
  {"getScissorEnabled", &Dtool_DisplayRegion_get_scissor_enabled_656, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_scissor_enabled_656_comment},
  {"set_cull_callback", &Dtool_DisplayRegion_set_cull_callback_658, METH_O, (const char *)Dtool_DisplayRegion_set_cull_callback_658_comment},
  {"setCullCallback", &Dtool_DisplayRegion_set_cull_callback_658, METH_O, (const char *)Dtool_DisplayRegion_set_cull_callback_658_comment},
  {"clear_cull_callback", &Dtool_DisplayRegion_clear_cull_callback_659, METH_NOARGS, (const char *)Dtool_DisplayRegion_clear_cull_callback_659_comment},
  {"clearCullCallback", &Dtool_DisplayRegion_clear_cull_callback_659, METH_NOARGS, (const char *)Dtool_DisplayRegion_clear_cull_callback_659_comment},
  {"get_cull_callback", &Dtool_DisplayRegion_get_cull_callback_660, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_cull_callback_660_comment},
  {"getCullCallback", &Dtool_DisplayRegion_get_cull_callback_660, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_cull_callback_660_comment},
  {"set_draw_callback", &Dtool_DisplayRegion_set_draw_callback_664, METH_O, (const char *)Dtool_DisplayRegion_set_draw_callback_664_comment},
  {"setDrawCallback", &Dtool_DisplayRegion_set_draw_callback_664, METH_O, (const char *)Dtool_DisplayRegion_set_draw_callback_664_comment},
  {"clear_draw_callback", &Dtool_DisplayRegion_clear_draw_callback_665, METH_NOARGS, (const char *)Dtool_DisplayRegion_clear_draw_callback_665_comment},
  {"clearDrawCallback", &Dtool_DisplayRegion_clear_draw_callback_665, METH_NOARGS, (const char *)Dtool_DisplayRegion_clear_draw_callback_665_comment},
  {"get_draw_callback", &Dtool_DisplayRegion_get_draw_callback_666, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_draw_callback_666_comment},
  {"getDrawCallback", &Dtool_DisplayRegion_get_draw_callback_666, METH_NOARGS, (const char *)Dtool_DisplayRegion_get_draw_callback_666_comment},
  {"get_pixel_width", (PyCFunction) &Dtool_DisplayRegion_get_pixel_width_668, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_pixel_width_668_comment},
  {"getPixelWidth", (PyCFunction) &Dtool_DisplayRegion_get_pixel_width_668, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_pixel_width_668_comment},
  {"get_pixel_height", (PyCFunction) &Dtool_DisplayRegion_get_pixel_height_669, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_pixel_height_669_comment},
  {"getPixelHeight", (PyCFunction) &Dtool_DisplayRegion_get_pixel_height_669, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_pixel_height_669_comment},
  {"get_pixel_size", (PyCFunction) &Dtool_DisplayRegion_get_pixel_size_670, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_pixel_size_670_comment},
  {"getPixelSize", (PyCFunction) &Dtool_DisplayRegion_get_pixel_size_670, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_get_pixel_size_670_comment},
  {"output", &Dtool_DisplayRegion_output_672, METH_O, (const char *)Dtool_DisplayRegion_output_672_comment},
  {"make_screenshot_filename", (PyCFunction) &Dtool_DisplayRegion_make_screenshot_filename_673, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_DisplayRegion_make_screenshot_filename_673_comment},
  {"makeScreenshotFilename", (PyCFunction) &Dtool_DisplayRegion_make_screenshot_filename_673, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_DisplayRegion_make_screenshot_filename_673_comment},
  {"save_screenshot_default", (PyCFunction) &Dtool_DisplayRegion_save_screenshot_default_674, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_save_screenshot_default_674_comment},
  {"saveScreenshotDefault", (PyCFunction) &Dtool_DisplayRegion_save_screenshot_default_674, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_save_screenshot_default_674_comment},
  {"save_screenshot", (PyCFunction) &Dtool_DisplayRegion_save_screenshot_675, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_save_screenshot_675_comment},
  {"saveScreenshot", (PyCFunction) &Dtool_DisplayRegion_save_screenshot_675, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DisplayRegion_save_screenshot_675_comment},
  {"get_screenshot", &Dtool_DisplayRegion_get_screenshot_676, METH_VARARGS, (const char *)Dtool_DisplayRegion_get_screenshot_676_comment},
  {"getScreenshot", &Dtool_DisplayRegion_get_screenshot_676, METH_VARARGS, (const char *)Dtool_DisplayRegion_get_screenshot_676_comment},
  {"make_cull_result_graph", &Dtool_DisplayRegion_make_cull_result_graph_677, METH_NOARGS, (const char *)Dtool_DisplayRegion_make_cull_result_graph_677_comment},
  {"makeCullResultGraph", &Dtool_DisplayRegion_make_cull_result_graph_677, METH_NOARGS, (const char *)Dtool_DisplayRegion_make_cull_result_graph_677_comment},
  {"get_class_type", &Dtool_DisplayRegion_get_class_type_678, METH_NOARGS | METH_STATIC, (const char *)Dtool_DisplayRegion_get_class_type_678_comment},
  {"getClassType", &Dtool_DisplayRegion_get_class_type_678, METH_NOARGS | METH_STATIC, (const char *)Dtool_DisplayRegion_get_class_type_678_comment},
  {"upcast_to_TypedReferenceCount", &Dtool_DisplayRegion_upcast_to_TypedReferenceCount_246, METH_NOARGS, (const char *)Dtool_DisplayRegion_upcast_to_TypedReferenceCount_246_comment},
  {"upcastToTypedReferenceCount", &Dtool_DisplayRegion_upcast_to_TypedReferenceCount_246, METH_NOARGS, (const char *)Dtool_DisplayRegion_upcast_to_TypedReferenceCount_246_comment},
  {"upcast_to_DrawableRegion", &Dtool_DisplayRegion_upcast_to_DrawableRegion_248, METH_NOARGS, (const char *)Dtool_DisplayRegion_upcast_to_DrawableRegion_248_comment},
  {"upcastToDrawableRegion", &Dtool_DisplayRegion_upcast_to_DrawableRegion_248, METH_NOARGS, (const char *)Dtool_DisplayRegion_upcast_to_DrawableRegion_248_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     DisplayRegion
//////////////////
static PyObject *Dtool_Repr_DisplayRegion(PyObject *self) {
  DisplayRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayRegion, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_DisplayRegion[] = {
  {(char *)"dimensions", &Dtool_DisplayRegion_dimensions_Getter, &Dtool_DisplayRegion_dimensions_Setter, nullptr, nullptr},
  {(char *)"window", &Dtool_DisplayRegion_window_Getter, nullptr, nullptr, nullptr},
  {(char *)"pipe", &Dtool_DisplayRegion_pipe_Getter, nullptr, nullptr, nullptr},
  {(char *)"stereo", &Dtool_DisplayRegion_stereo_Getter, nullptr, nullptr, nullptr},
  {(char *)"camera", &Dtool_DisplayRegion_camera_Getter, &Dtool_DisplayRegion_camera_Setter, nullptr, nullptr},
  {(char *)"active", &Dtool_DisplayRegion_active_Getter, &Dtool_DisplayRegion_active_Setter, nullptr, nullptr},
  {(char *)"sort", &Dtool_DisplayRegion_sort_Getter, &Dtool_DisplayRegion_sort_Setter, nullptr, nullptr},
  {(char *)"stereo_channel", &Dtool_DisplayRegion_stereo_channel_Getter, &Dtool_DisplayRegion_stereo_channel_Setter, nullptr, nullptr},
  {(char *)"tex_view_offset", &Dtool_DisplayRegion_tex_view_offset_Getter, &Dtool_DisplayRegion_tex_view_offset_Setter, nullptr, nullptr},
  {(char *)"incomplete_render", &Dtool_DisplayRegion_incomplete_render_Getter, &Dtool_DisplayRegion_incomplete_render_Setter, nullptr, nullptr},
  {(char *)"texture_reload_priority", &Dtool_DisplayRegion_texture_reload_priority_Getter, &Dtool_DisplayRegion_texture_reload_priority_Setter, nullptr, nullptr},
  {(char *)"lens_index", &Dtool_DisplayRegion_lens_index_Getter, &Dtool_DisplayRegion_lens_index_Setter, nullptr, nullptr},
  {(char *)"cull_traverser", &Dtool_DisplayRegion_cull_traverser_Getter, &Dtool_DisplayRegion_cull_traverser_Setter, nullptr, nullptr},
  {(char *)"target_tex_page", &Dtool_DisplayRegion_target_tex_page_Getter, &Dtool_DisplayRegion_target_tex_page_Setter, nullptr, nullptr},
  {(char *)"scissor_enabled", &Dtool_DisplayRegion_scissor_enabled_Getter, &Dtool_DisplayRegion_scissor_enabled_Setter, nullptr, nullptr},
  {(char *)"cull_callback", &Dtool_DisplayRegion_cull_callback_Getter, &Dtool_DisplayRegion_cull_callback_Setter, nullptr, nullptr},
  {(char *)"draw_callback", &Dtool_DisplayRegion_draw_callback_Getter, &Dtool_DisplayRegion_draw_callback_Setter, nullptr, nullptr},
  {(char *)"pixel_size", &Dtool_DisplayRegion_pixel_size_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_DisplayRegion = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DisplayRegion = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DisplayRegion = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DisplayRegion = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DisplayRegion = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DisplayRegion = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DisplayRegion",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DisplayRegion,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DisplayRegion,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_DisplayRegion,
    &Dtool_NumberMethods_DisplayRegion,
    &Dtool_SequenceMethods_DisplayRegion,
    &Dtool_MappingMethods_DisplayRegion,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_DisplayRegion,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DisplayRegion,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A rectangular subregion within a window for rendering into.  Typically,\n"
    " * there is one DisplayRegion that covers the whole window, but you may also\n"
    " * create smaller DisplayRegions for having different regions within the\n"
    " * window that represent different scenes.  You may also stack up\n"
    " * DisplayRegions like panes of glass, usually for layering 2-d interfaces on\n"
    " * top of a 3-d scene.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DisplayRegion,
    nullptr, // tp_members
    Dtool_Properties_DisplayRegion,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DisplayRegion,
    PyType_GenericAlloc,
    Dtool_new_DisplayRegion,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DisplayRegion,
  Dtool_UpcastInterface_DisplayRegion,
  Dtool_DowncastInterface_DisplayRegion,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DisplayRegion(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_PyModuleClassInit_DrawableRegion(nullptr);
    Dtool_DisplayRegion._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount, (PyTypeObject *)&Dtool_DrawableRegion);
    Dtool_DisplayRegion._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DisplayRegion._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DisplayRegion) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DisplayRegion)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DisplayRegion);
  }
}

/**
 * Python method tables for GraphicsOutput (GraphicsOutput)
 */
static PyMethodDef Dtool_Methods_GraphicsOutput[] = {
  {"get_gsg", &Dtool_GraphicsOutput_get_gsg_275, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_gsg_275_comment},
  {"getGsg", &Dtool_GraphicsOutput_get_gsg_275, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_gsg_275_comment},
  {"get_pipe", &Dtool_GraphicsOutput_get_pipe_276, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_pipe_276_comment},
  {"getPipe", &Dtool_GraphicsOutput_get_pipe_276, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_pipe_276_comment},
  {"get_engine", &Dtool_GraphicsOutput_get_engine_277, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_engine_277_comment},
  {"getEngine", &Dtool_GraphicsOutput_get_engine_277, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_engine_277_comment},
  {"get_name", &Dtool_GraphicsOutput_get_name_278, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_name_278_comment},
  {"getName", &Dtool_GraphicsOutput_get_name_278, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_name_278_comment},
  {"count_textures", &Dtool_GraphicsOutput_count_textures_526, METH_NOARGS, (const char *)Dtool_GraphicsOutput_count_textures_526_comment},
  {"countTextures", &Dtool_GraphicsOutput_count_textures_526, METH_NOARGS, (const char *)Dtool_GraphicsOutput_count_textures_526_comment},
  {"has_texture", &Dtool_GraphicsOutput_has_texture_527, METH_NOARGS, (const char *)Dtool_GraphicsOutput_has_texture_527_comment},
  {"hasTexture", &Dtool_GraphicsOutput_has_texture_527, METH_NOARGS, (const char *)Dtool_GraphicsOutput_has_texture_527_comment},
  {"get_texture", (PyCFunction) &Dtool_GraphicsOutput_get_texture_528, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_get_texture_528_comment},
  {"getTexture", (PyCFunction) &Dtool_GraphicsOutput_get_texture_528, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_get_texture_528_comment},
  {"get_texture_plane", (PyCFunction) &Dtool_GraphicsOutput_get_texture_plane_529, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_get_texture_plane_529_comment},
  {"getTexturePlane", (PyCFunction) &Dtool_GraphicsOutput_get_texture_plane_529, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_get_texture_plane_529_comment},
  {"get_rtm_mode", (PyCFunction) &Dtool_GraphicsOutput_get_rtm_mode_530, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_get_rtm_mode_530_comment},
  {"getRtmMode", (PyCFunction) &Dtool_GraphicsOutput_get_rtm_mode_530, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_get_rtm_mode_530_comment},
  {"clear_render_textures", &Dtool_GraphicsOutput_clear_render_textures_531, METH_NOARGS, (const char *)Dtool_GraphicsOutput_clear_render_textures_531_comment},
  {"clearRenderTextures", &Dtool_GraphicsOutput_clear_render_textures_531, METH_NOARGS, (const char *)Dtool_GraphicsOutput_clear_render_textures_531_comment},
  {"add_render_texture", (PyCFunction) &Dtool_GraphicsOutput_add_render_texture_532, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_add_render_texture_532_comment},
  {"addRenderTexture", (PyCFunction) &Dtool_GraphicsOutput_add_render_texture_532, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_add_render_texture_532_comment},
  {"setup_render_texture", (PyCFunction) &Dtool_GraphicsOutput_setup_render_texture_533, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_setup_render_texture_533_comment},
  {"setupRenderTexture", (PyCFunction) &Dtool_GraphicsOutput_setup_render_texture_533, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_setup_render_texture_533_comment},
  {"get_size", &Dtool_GraphicsOutput_get_size_534, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_size_534_comment},
  {"getSize", &Dtool_GraphicsOutput_get_size_534, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_size_534_comment},
  {"get_x_size", &Dtool_GraphicsOutput_get_x_size_535, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_x_size_535_comment},
  {"getXSize", &Dtool_GraphicsOutput_get_x_size_535, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_x_size_535_comment},
  {"get_y_size", &Dtool_GraphicsOutput_get_y_size_536, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_y_size_536_comment},
  {"getYSize", &Dtool_GraphicsOutput_get_y_size_536, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_y_size_536_comment},
  {"get_fb_size", &Dtool_GraphicsOutput_get_fb_size_537, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_fb_size_537_comment},
  {"getFbSize", &Dtool_GraphicsOutput_get_fb_size_537, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_fb_size_537_comment},
  {"get_fb_x_size", &Dtool_GraphicsOutput_get_fb_x_size_538, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_fb_x_size_538_comment},
  {"getFbXSize", &Dtool_GraphicsOutput_get_fb_x_size_538, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_fb_x_size_538_comment},
  {"get_fb_y_size", &Dtool_GraphicsOutput_get_fb_y_size_539, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_fb_y_size_539_comment},
  {"getFbYSize", &Dtool_GraphicsOutput_get_fb_y_size_539, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_fb_y_size_539_comment},
  {"get_sbs_left_size", &Dtool_GraphicsOutput_get_sbs_left_size_540, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sbs_left_size_540_comment},
  {"getSbsLeftSize", &Dtool_GraphicsOutput_get_sbs_left_size_540, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sbs_left_size_540_comment},
  {"get_sbs_left_x_size", &Dtool_GraphicsOutput_get_sbs_left_x_size_541, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sbs_left_x_size_541_comment},
  {"getSbsLeftXSize", &Dtool_GraphicsOutput_get_sbs_left_x_size_541, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sbs_left_x_size_541_comment},
  {"get_sbs_left_y_size", &Dtool_GraphicsOutput_get_sbs_left_y_size_542, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sbs_left_y_size_542_comment},
  {"getSbsLeftYSize", &Dtool_GraphicsOutput_get_sbs_left_y_size_542, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sbs_left_y_size_542_comment},
  {"get_sbs_right_size", &Dtool_GraphicsOutput_get_sbs_right_size_543, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sbs_right_size_543_comment},
  {"getSbsRightSize", &Dtool_GraphicsOutput_get_sbs_right_size_543, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sbs_right_size_543_comment},
  {"get_sbs_right_x_size", &Dtool_GraphicsOutput_get_sbs_right_x_size_544, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sbs_right_x_size_544_comment},
  {"getSbsRightXSize", &Dtool_GraphicsOutput_get_sbs_right_x_size_544, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sbs_right_x_size_544_comment},
  {"get_sbs_right_y_size", &Dtool_GraphicsOutput_get_sbs_right_y_size_545, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sbs_right_y_size_545_comment},
  {"getSbsRightYSize", &Dtool_GraphicsOutput_get_sbs_right_y_size_545, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sbs_right_y_size_545_comment},
  {"has_size", &Dtool_GraphicsOutput_has_size_546, METH_NOARGS, (const char *)Dtool_GraphicsOutput_has_size_546_comment},
  {"hasSize", &Dtool_GraphicsOutput_has_size_546, METH_NOARGS, (const char *)Dtool_GraphicsOutput_has_size_546_comment},
  {"is_valid", &Dtool_GraphicsOutput_is_valid_547, METH_NOARGS, (const char *)Dtool_GraphicsOutput_is_valid_547_comment},
  {"isValid", &Dtool_GraphicsOutput_is_valid_547, METH_NOARGS, (const char *)Dtool_GraphicsOutput_is_valid_547_comment},
  {"is_nonzero_size", &Dtool_GraphicsOutput_is_nonzero_size_548, METH_NOARGS, (const char *)Dtool_GraphicsOutput_is_nonzero_size_548_comment},
  {"isNonzeroSize", &Dtool_GraphicsOutput_is_nonzero_size_548, METH_NOARGS, (const char *)Dtool_GraphicsOutput_is_nonzero_size_548_comment},
  {"set_active", &Dtool_GraphicsOutput_set_active_555, METH_O, (const char *)Dtool_GraphicsOutput_set_active_555_comment},
  {"setActive", &Dtool_GraphicsOutput_set_active_555, METH_O, (const char *)Dtool_GraphicsOutput_set_active_555_comment},
  {"is_active", &Dtool_GraphicsOutput_is_active_556, METH_NOARGS, (const char *)Dtool_GraphicsOutput_is_active_556_comment},
  {"isActive", &Dtool_GraphicsOutput_is_active_556, METH_NOARGS, (const char *)Dtool_GraphicsOutput_is_active_556_comment},
  {"set_one_shot", &Dtool_GraphicsOutput_set_one_shot_558, METH_O, (const char *)Dtool_GraphicsOutput_set_one_shot_558_comment},
  {"setOneShot", &Dtool_GraphicsOutput_set_one_shot_558, METH_O, (const char *)Dtool_GraphicsOutput_set_one_shot_558_comment},
  {"get_one_shot", &Dtool_GraphicsOutput_get_one_shot_559, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_one_shot_559_comment},
  {"getOneShot", &Dtool_GraphicsOutput_get_one_shot_559, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_one_shot_559_comment},
  {"set_inverted", &Dtool_GraphicsOutput_set_inverted_561, METH_O, (const char *)Dtool_GraphicsOutput_set_inverted_561_comment},
  {"setInverted", &Dtool_GraphicsOutput_set_inverted_561, METH_O, (const char *)Dtool_GraphicsOutput_set_inverted_561_comment},
  {"get_inverted", &Dtool_GraphicsOutput_get_inverted_562, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_inverted_562_comment},
  {"getInverted", &Dtool_GraphicsOutput_get_inverted_562, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_inverted_562_comment},
  {"set_swap_eyes", &Dtool_GraphicsOutput_set_swap_eyes_564, METH_O, (const char *)Dtool_GraphicsOutput_set_swap_eyes_564_comment},
  {"setSwapEyes", &Dtool_GraphicsOutput_set_swap_eyes_564, METH_O, (const char *)Dtool_GraphicsOutput_set_swap_eyes_564_comment},
  {"get_swap_eyes", &Dtool_GraphicsOutput_get_swap_eyes_565, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_swap_eyes_565_comment},
  {"getSwapEyes", &Dtool_GraphicsOutput_get_swap_eyes_565, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_swap_eyes_565_comment},
  {"set_red_blue_stereo", (PyCFunction) &Dtool_GraphicsOutput_set_red_blue_stereo_567, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_set_red_blue_stereo_567_comment},
  {"setRedBlueStereo", (PyCFunction) &Dtool_GraphicsOutput_set_red_blue_stereo_567, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_set_red_blue_stereo_567_comment},
  {"get_red_blue_stereo", &Dtool_GraphicsOutput_get_red_blue_stereo_568, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_red_blue_stereo_568_comment},
  {"getRedBlueStereo", &Dtool_GraphicsOutput_get_red_blue_stereo_568, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_red_blue_stereo_568_comment},
  {"get_left_eye_color_mask", &Dtool_GraphicsOutput_get_left_eye_color_mask_569, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_left_eye_color_mask_569_comment},
  {"getLeftEyeColorMask", &Dtool_GraphicsOutput_get_left_eye_color_mask_569, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_left_eye_color_mask_569_comment},
  {"get_right_eye_color_mask", &Dtool_GraphicsOutput_get_right_eye_color_mask_570, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_right_eye_color_mask_570_comment},
  {"getRightEyeColorMask", &Dtool_GraphicsOutput_get_right_eye_color_mask_570, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_right_eye_color_mask_570_comment},
  {"set_side_by_side_stereo", (PyCFunction) &Dtool_GraphicsOutput_set_side_by_side_stereo_571, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_set_side_by_side_stereo_571_comment},
  {"setSideBySideStereo", (PyCFunction) &Dtool_GraphicsOutput_set_side_by_side_stereo_571, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_set_side_by_side_stereo_571_comment},
  {"get_side_by_side_stereo", &Dtool_GraphicsOutput_get_side_by_side_stereo_572, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_side_by_side_stereo_572_comment},
  {"getSideBySideStereo", &Dtool_GraphicsOutput_get_side_by_side_stereo_572, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_side_by_side_stereo_572_comment},
  {"get_sbs_left_dimensions", &Dtool_GraphicsOutput_get_sbs_left_dimensions_573, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sbs_left_dimensions_573_comment},
  {"getSbsLeftDimensions", &Dtool_GraphicsOutput_get_sbs_left_dimensions_573, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sbs_left_dimensions_573_comment},
  {"get_sbs_right_dimensions", &Dtool_GraphicsOutput_get_sbs_right_dimensions_574, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sbs_right_dimensions_574_comment},
  {"getSbsRightDimensions", &Dtool_GraphicsOutput_get_sbs_right_dimensions_574, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sbs_right_dimensions_574_comment},
  {"get_fb_properties", &Dtool_GraphicsOutput_get_fb_properties_575, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_fb_properties_575_comment},
  {"getFbProperties", &Dtool_GraphicsOutput_get_fb_properties_575, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_fb_properties_575_comment},
  {"is_stereo", &Dtool_GraphicsOutput_is_stereo_576, METH_NOARGS, (const char *)Dtool_GraphicsOutput_is_stereo_576_comment},
  {"isStereo", &Dtool_GraphicsOutput_is_stereo_576, METH_NOARGS, (const char *)Dtool_GraphicsOutput_is_stereo_576_comment},
  {"clear_delete_flag", &Dtool_GraphicsOutput_clear_delete_flag_577, METH_NOARGS, (const char *)Dtool_GraphicsOutput_clear_delete_flag_577_comment},
  {"clearDeleteFlag", &Dtool_GraphicsOutput_clear_delete_flag_577, METH_NOARGS, (const char *)Dtool_GraphicsOutput_clear_delete_flag_577_comment},
  {"get_delete_flag", &Dtool_GraphicsOutput_get_delete_flag_578, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_delete_flag_578_comment},
  {"getDeleteFlag", &Dtool_GraphicsOutput_get_delete_flag_578, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_delete_flag_578_comment},
  {"set_sort", &Dtool_GraphicsOutput_set_sort_579, METH_O, (const char *)Dtool_GraphicsOutput_set_sort_579_comment},
  {"setSort", &Dtool_GraphicsOutput_set_sort_579, METH_O, (const char *)Dtool_GraphicsOutput_set_sort_579_comment},
  {"get_sort", &Dtool_GraphicsOutput_get_sort_580, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sort_580_comment},
  {"getSort", &Dtool_GraphicsOutput_get_sort_580, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_sort_580_comment},
  {"set_child_sort", &Dtool_GraphicsOutput_set_child_sort_582, METH_O, (const char *)Dtool_GraphicsOutput_set_child_sort_582_comment},
  {"setChildSort", &Dtool_GraphicsOutput_set_child_sort_582, METH_O, (const char *)Dtool_GraphicsOutput_set_child_sort_582_comment},
  {"clear_child_sort", &Dtool_GraphicsOutput_clear_child_sort_583, METH_NOARGS, (const char *)Dtool_GraphicsOutput_clear_child_sort_583_comment},
  {"clearChildSort", &Dtool_GraphicsOutput_clear_child_sort_583, METH_NOARGS, (const char *)Dtool_GraphicsOutput_clear_child_sort_583_comment},
  {"get_child_sort", &Dtool_GraphicsOutput_get_child_sort_584, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_child_sort_584_comment},
  {"getChildSort", &Dtool_GraphicsOutput_get_child_sort_584, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_child_sort_584_comment},
  {"trigger_copy", &Dtool_GraphicsOutput_trigger_copy_586, METH_NOARGS, (const char *)Dtool_GraphicsOutput_trigger_copy_586_comment},
  {"triggerCopy", &Dtool_GraphicsOutput_trigger_copy_586, METH_NOARGS, (const char *)Dtool_GraphicsOutput_trigger_copy_586_comment},
  {"make_display_region", (PyCFunction) &Dtool_GraphicsOutput_make_display_region_587, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_make_display_region_587_comment},
  {"makeDisplayRegion", (PyCFunction) &Dtool_GraphicsOutput_make_display_region_587, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_make_display_region_587_comment},
  {"make_mono_display_region", (PyCFunction) &Dtool_GraphicsOutput_make_mono_display_region_588, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_make_mono_display_region_588_comment},
  {"makeMonoDisplayRegion", (PyCFunction) &Dtool_GraphicsOutput_make_mono_display_region_588, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_make_mono_display_region_588_comment},
  {"make_stereo_display_region", (PyCFunction) &Dtool_GraphicsOutput_make_stereo_display_region_589, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_make_stereo_display_region_589_comment},
  {"makeStereoDisplayRegion", (PyCFunction) &Dtool_GraphicsOutput_make_stereo_display_region_589, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_make_stereo_display_region_589_comment},
  {"remove_display_region", &Dtool_GraphicsOutput_remove_display_region_590, METH_O, (const char *)Dtool_GraphicsOutput_remove_display_region_590_comment},
  {"removeDisplayRegion", &Dtool_GraphicsOutput_remove_display_region_590, METH_O, (const char *)Dtool_GraphicsOutput_remove_display_region_590_comment},
  {"remove_all_display_regions", &Dtool_GraphicsOutput_remove_all_display_regions_591, METH_NOARGS, (const char *)Dtool_GraphicsOutput_remove_all_display_regions_591_comment},
  {"removeAllDisplayRegions", &Dtool_GraphicsOutput_remove_all_display_regions_591, METH_NOARGS, (const char *)Dtool_GraphicsOutput_remove_all_display_regions_591_comment},
  {"get_overlay_display_region", &Dtool_GraphicsOutput_get_overlay_display_region_592, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_overlay_display_region_592_comment},
  {"getOverlayDisplayRegion", &Dtool_GraphicsOutput_get_overlay_display_region_592, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_overlay_display_region_592_comment},
  {"set_overlay_display_region", &Dtool_GraphicsOutput_set_overlay_display_region_593, METH_O, (const char *)Dtool_GraphicsOutput_set_overlay_display_region_593_comment},
  {"setOverlayDisplayRegion", &Dtool_GraphicsOutput_set_overlay_display_region_593, METH_O, (const char *)Dtool_GraphicsOutput_set_overlay_display_region_593_comment},
  {"get_num_display_regions", &Dtool_GraphicsOutput_get_num_display_regions_594, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_num_display_regions_594_comment},
  {"getNumDisplayRegions", &Dtool_GraphicsOutput_get_num_display_regions_594, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_num_display_regions_594_comment},
  {"get_display_region", &Dtool_GraphicsOutput_get_display_region_595, METH_O, (const char *)Dtool_GraphicsOutput_get_display_region_595_comment},
  {"getDisplayRegion", &Dtool_GraphicsOutput_get_display_region_595, METH_O, (const char *)Dtool_GraphicsOutput_get_display_region_595_comment},
  {"get_num_active_display_regions", &Dtool_GraphicsOutput_get_num_active_display_regions_599, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_num_active_display_regions_599_comment},
  {"getNumActiveDisplayRegions", &Dtool_GraphicsOutput_get_num_active_display_regions_599, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_num_active_display_regions_599_comment},
  {"get_active_display_region", &Dtool_GraphicsOutput_get_active_display_region_600, METH_O, (const char *)Dtool_GraphicsOutput_get_active_display_region_600_comment},
  {"getActiveDisplayRegion", &Dtool_GraphicsOutput_get_active_display_region_600, METH_O, (const char *)Dtool_GraphicsOutput_get_active_display_region_600_comment},
  {"make_texture_buffer", (PyCFunction) &Dtool_GraphicsOutput_make_texture_buffer_603, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_make_texture_buffer_603_comment},
  {"makeTextureBuffer", (PyCFunction) &Dtool_GraphicsOutput_make_texture_buffer_603, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_make_texture_buffer_603_comment},
  {"make_cube_map", (PyCFunction) &Dtool_GraphicsOutput_make_cube_map_604, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_make_cube_map_604_comment},
  {"makeCubeMap", (PyCFunction) &Dtool_GraphicsOutput_make_cube_map_604, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_make_cube_map_604_comment},
  {"make_screenshot_filename", (PyCFunction) &Dtool_GraphicsOutput_make_screenshot_filename_605, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_GraphicsOutput_make_screenshot_filename_605_comment},
  {"makeScreenshotFilename", (PyCFunction) &Dtool_GraphicsOutput_make_screenshot_filename_605, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_GraphicsOutput_make_screenshot_filename_605_comment},
  {"save_screenshot_default", (PyCFunction) &Dtool_GraphicsOutput_save_screenshot_default_606, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_save_screenshot_default_606_comment},
  {"saveScreenshotDefault", (PyCFunction) &Dtool_GraphicsOutput_save_screenshot_default_606, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_save_screenshot_default_606_comment},
  {"save_screenshot", (PyCFunction) &Dtool_GraphicsOutput_save_screenshot_607, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_save_screenshot_607_comment},
  {"saveScreenshot", (PyCFunction) &Dtool_GraphicsOutput_save_screenshot_607, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsOutput_save_screenshot_607_comment},
  {"get_screenshot", &Dtool_GraphicsOutput_get_screenshot_608, METH_VARARGS, (const char *)Dtool_GraphicsOutput_get_screenshot_608_comment},
  {"getScreenshot", &Dtool_GraphicsOutput_get_screenshot_608, METH_VARARGS, (const char *)Dtool_GraphicsOutput_get_screenshot_608_comment},
  {"get_texture_card", &Dtool_GraphicsOutput_get_texture_card_609, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_texture_card_609_comment},
  {"getTextureCard", &Dtool_GraphicsOutput_get_texture_card_609, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_texture_card_609_comment},
  {"share_depth_buffer", &Dtool_GraphicsOutput_share_depth_buffer_610, METH_O, (const char *)Dtool_GraphicsOutput_share_depth_buffer_610_comment},
  {"shareDepthBuffer", &Dtool_GraphicsOutput_share_depth_buffer_610, METH_O, (const char *)Dtool_GraphicsOutput_share_depth_buffer_610_comment},
  {"unshare_depth_buffer", &Dtool_GraphicsOutput_unshare_depth_buffer_611, METH_NOARGS, (const char *)Dtool_GraphicsOutput_unshare_depth_buffer_611_comment},
  {"unshareDepthBuffer", &Dtool_GraphicsOutput_unshare_depth_buffer_611, METH_NOARGS, (const char *)Dtool_GraphicsOutput_unshare_depth_buffer_611_comment},
  {"get_supports_render_texture", &Dtool_GraphicsOutput_get_supports_render_texture_612, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_supports_render_texture_612_comment},
  {"getSupportsRenderTexture", &Dtool_GraphicsOutput_get_supports_render_texture_612, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_supports_render_texture_612_comment},
  {"flip_ready", &Dtool_GraphicsOutput_flip_ready_614, METH_NOARGS, (const char *)Dtool_GraphicsOutput_flip_ready_614_comment},
  {"flipReady", &Dtool_GraphicsOutput_flip_ready_614, METH_NOARGS, (const char *)Dtool_GraphicsOutput_flip_ready_614_comment},
  {"get_host", &Dtool_GraphicsOutput_get_host_615, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_host_615_comment},
  {"getHost", &Dtool_GraphicsOutput_get_host_615, METH_NOARGS, (const char *)Dtool_GraphicsOutput_get_host_615_comment},
  {"get_class_type", &Dtool_GraphicsOutput_get_class_type_616, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsOutput_get_class_type_616_comment},
  {"getClassType", &Dtool_GraphicsOutput_get_class_type_616, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsOutput_get_class_type_616_comment},
  {"upcast_to_GraphicsOutputBase", &Dtool_GraphicsOutput_upcast_to_GraphicsOutputBase_268, METH_NOARGS, (const char *)Dtool_GraphicsOutput_upcast_to_GraphicsOutputBase_268_comment},
  {"upcastToGraphicsOutputBase", &Dtool_GraphicsOutput_upcast_to_GraphicsOutputBase_268, METH_NOARGS, (const char *)Dtool_GraphicsOutput_upcast_to_GraphicsOutputBase_268_comment},
  {"upcast_to_DrawableRegion", &Dtool_GraphicsOutput_upcast_to_DrawableRegion_270, METH_NOARGS, (const char *)Dtool_GraphicsOutput_upcast_to_DrawableRegion_270_comment},
  {"upcastToDrawableRegion", &Dtool_GraphicsOutput_upcast_to_DrawableRegion_270, METH_NOARGS, (const char *)Dtool_GraphicsOutput_upcast_to_DrawableRegion_270_comment},
  {"get_display_regions", (PyCFunction) &MakeSeq_GraphicsOutput_get_display_regions, METH_NOARGS, nullptr},
  { "getDisplayRegions", (PyCFunction) &MakeSeq_GraphicsOutput_get_display_regions, METH_NOARGS, nullptr},
  {"get_active_display_regions", (PyCFunction) &MakeSeq_GraphicsOutput_get_active_display_regions, METH_NOARGS, nullptr},
  { "getActiveDisplayRegions", (PyCFunction) &MakeSeq_GraphicsOutput_get_active_display_regions, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_GraphicsOutput[] = {
  {(char *)"gsg", &Dtool_GraphicsOutput_gsg_Getter, nullptr, nullptr, nullptr},
  {(char *)"pipe", &Dtool_GraphicsOutput_pipe_Getter, nullptr, nullptr, nullptr},
  {(char *)"engine", &Dtool_GraphicsOutput_engine_Getter, nullptr, nullptr, nullptr},
  {(char *)"name", &Dtool_GraphicsOutput_name_Getter, nullptr, nullptr, nullptr},
  {(char *)"size", &Dtool_GraphicsOutput_size_Getter, nullptr, nullptr, nullptr},
  {(char *)"fb_size", &Dtool_GraphicsOutput_fb_size_Getter, nullptr, nullptr, nullptr},
  {(char *)"sbs_left_size", &Dtool_GraphicsOutput_sbs_left_size_Getter, nullptr, nullptr, nullptr},
  {(char *)"sbs_right_size", &Dtool_GraphicsOutput_sbs_right_size_Getter, nullptr, nullptr, nullptr},
  {(char *)"active", &Dtool_GraphicsOutput_active_Getter, &Dtool_GraphicsOutput_active_Setter, nullptr, nullptr},
  {(char *)"one_shot", &Dtool_GraphicsOutput_one_shot_Getter, &Dtool_GraphicsOutput_one_shot_Setter, nullptr, nullptr},
  {(char *)"inverted", &Dtool_GraphicsOutput_inverted_Getter, &Dtool_GraphicsOutput_inverted_Setter, nullptr, nullptr},
  {(char *)"swap_eyes", &Dtool_GraphicsOutput_swap_eyes_Getter, &Dtool_GraphicsOutput_swap_eyes_Setter, nullptr, nullptr},
  {(char *)"sort", &Dtool_GraphicsOutput_sort_Getter, &Dtool_GraphicsOutput_sort_Setter, nullptr, nullptr},
  {(char *)"child_sort", &Dtool_GraphicsOutput_child_sort_Getter, &Dtool_GraphicsOutput_child_sort_Setter, nullptr, nullptr},
  {(char *)"display_regions", &Dtool_GraphicsOutput_display_regions_Getter, nullptr, nullptr, nullptr},
  {(char *)"active_display_regions", &Dtool_GraphicsOutput_active_display_regions_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_render_texture", &Dtool_GraphicsOutput_supports_render_texture_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_GraphicsOutput = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GraphicsOutput = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GraphicsOutput = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GraphicsOutput = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GraphicsOutput = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GraphicsOutput = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GraphicsOutput",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GraphicsOutput,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GraphicsOutput,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GraphicsOutput,
    &Dtool_SequenceMethods_GraphicsOutput,
    &Dtool_MappingMethods_GraphicsOutput,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GraphicsOutput,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a base class for the various different classes that represent the\n"
    " * result of a frame of rendering.  The most common kind of GraphicsOutput is\n"
    " * a GraphicsWindow, which is a real-time window on the desktop, but another\n"
    " * example is GraphicsBuffer, which is an offscreen buffer.\n"
    " *\n"
    " * The actual rendering, and anything associated with the graphics context\n"
    " * itself, is managed by the associated GraphicsStateGuardian (which might\n"
    " * output to multiple GraphicsOutput objects).\n"
    " *\n"
    " * GraphicsOutputs are not actually writable to bam files, of course, but they\n"
    " * may be passed as event parameters, so they inherit from\n"
    " * TypedWritableReferenceCount instead of TypedReferenceCount for that\n"
    " * convenience.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GraphicsOutput,
    nullptr, // tp_members
    Dtool_Properties_GraphicsOutput,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GraphicsOutput,
    PyType_GenericAlloc,
    Dtool_new_GraphicsOutput,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GraphicsOutput,
  Dtool_UpcastInterface_GraphicsOutput,
  Dtool_DowncastInterface_GraphicsOutput,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GraphicsOutput(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_GraphicsOutputBase != nullptr);
    assert(Dtool_Ptr_GraphicsOutputBase->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_GraphicsOutputBase->_Dtool_ModuleClassInit(nullptr);
    Dtool_PyModuleClassInit_DrawableRegion(nullptr);
    Dtool_GraphicsOutput._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_GraphicsOutputBase, (PyTypeObject *)&Dtool_DrawableRegion);
    Dtool_GraphicsOutput._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(21);
    Dtool_GraphicsOutput._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum GraphicsOutput::RenderTextureMode;
    PyDict_SetItemString(dict, "RTM_none", Dtool_WrapValue(GraphicsOutput::RTM_none));
    PyDict_SetItemString(dict, "RTMNone", Dtool_WrapValue(GraphicsOutput::RTM_none));
    PyDict_SetItemString(dict, "RTM_bind_or_copy", Dtool_WrapValue(GraphicsOutput::RTM_bind_or_copy));
    PyDict_SetItemString(dict, "RTMBindOrCopy", Dtool_WrapValue(GraphicsOutput::RTM_bind_or_copy));
    PyDict_SetItemString(dict, "RTM_copy_texture", Dtool_WrapValue(GraphicsOutput::RTM_copy_texture));
    PyDict_SetItemString(dict, "RTMCopyTexture", Dtool_WrapValue(GraphicsOutput::RTM_copy_texture));
    PyDict_SetItemString(dict, "RTM_copy_ram", Dtool_WrapValue(GraphicsOutput::RTM_copy_ram));
    PyDict_SetItemString(dict, "RTMCopyRam", Dtool_WrapValue(GraphicsOutput::RTM_copy_ram));
    PyDict_SetItemString(dict, "RTM_triggered_copy_texture", Dtool_WrapValue(GraphicsOutput::RTM_triggered_copy_texture));
    PyDict_SetItemString(dict, "RTMTriggeredCopyTexture", Dtool_WrapValue(GraphicsOutput::RTM_triggered_copy_texture));
    PyDict_SetItemString(dict, "RTM_triggered_copy_ram", Dtool_WrapValue(GraphicsOutput::RTM_triggered_copy_ram));
    PyDict_SetItemString(dict, "RTMTriggeredCopyRam", Dtool_WrapValue(GraphicsOutput::RTM_triggered_copy_ram));
    PyDict_SetItemString(dict, "RTM_bind_layered", Dtool_WrapValue(GraphicsOutput::RTM_bind_layered));
    PyDict_SetItemString(dict, "RTMBindLayered", Dtool_WrapValue(GraphicsOutput::RTM_bind_layered));
    // enum GraphicsOutput::FrameMode;
    PyDict_SetItemString(dict, "FM_render", Dtool_WrapValue(GraphicsOutput::FM_render));
    PyDict_SetItemString(dict, "FMRender", Dtool_WrapValue(GraphicsOutput::FM_render));
    PyDict_SetItemString(dict, "FM_parasite", Dtool_WrapValue(GraphicsOutput::FM_parasite));
    PyDict_SetItemString(dict, "FMParasite", Dtool_WrapValue(GraphicsOutput::FM_parasite));
    PyDict_SetItemString(dict, "FM_refresh", Dtool_WrapValue(GraphicsOutput::FM_refresh));
    PyDict_SetItemString(dict, "FMRefresh", Dtool_WrapValue(GraphicsOutput::FM_refresh));
    if (PyType_Ready((PyTypeObject *)&Dtool_GraphicsOutput) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GraphicsOutput)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GraphicsOutput);
  }
}

/**
 * Python method tables for GraphicsStateGuardian (GraphicsStateGuardian)
 */
static PyMethodDef Dtool_Methods_GraphicsStateGuardian[] = {
  {"release_all", &Dtool_GraphicsStateGuardian_release_all_284, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_release_all_284_comment},
  {"releaseAll", &Dtool_GraphicsStateGuardian_release_all_284, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_release_all_284_comment},
  {"release_all_textures", &Dtool_GraphicsStateGuardian_release_all_textures_285, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_release_all_textures_285_comment},
  {"releaseAllTextures", &Dtool_GraphicsStateGuardian_release_all_textures_285, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_release_all_textures_285_comment},
  {"release_all_samplers", &Dtool_GraphicsStateGuardian_release_all_samplers_286, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_release_all_samplers_286_comment},
  {"releaseAllSamplers", &Dtool_GraphicsStateGuardian_release_all_samplers_286, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_release_all_samplers_286_comment},
  {"release_all_geoms", &Dtool_GraphicsStateGuardian_release_all_geoms_287, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_release_all_geoms_287_comment},
  {"releaseAllGeoms", &Dtool_GraphicsStateGuardian_release_all_geoms_287, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_release_all_geoms_287_comment},
  {"release_all_vertex_buffers", &Dtool_GraphicsStateGuardian_release_all_vertex_buffers_288, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_release_all_vertex_buffers_288_comment},
  {"releaseAllVertexBuffers", &Dtool_GraphicsStateGuardian_release_all_vertex_buffers_288, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_release_all_vertex_buffers_288_comment},
  {"release_all_index_buffers", &Dtool_GraphicsStateGuardian_release_all_index_buffers_289, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_release_all_index_buffers_289_comment},
  {"releaseAllIndexBuffers", &Dtool_GraphicsStateGuardian_release_all_index_buffers_289, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_release_all_index_buffers_289_comment},
  {"release_all_shader_buffers", &Dtool_GraphicsStateGuardian_release_all_shader_buffers_290, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_release_all_shader_buffers_290_comment},
  {"releaseAllShaderBuffers", &Dtool_GraphicsStateGuardian_release_all_shader_buffers_290, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_release_all_shader_buffers_290_comment},
  {"set_active", &Dtool_GraphicsStateGuardian_set_active_291, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_active_291_comment},
  {"setActive", &Dtool_GraphicsStateGuardian_set_active_291, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_active_291_comment},
  {"is_active", &Dtool_GraphicsStateGuardian_is_active_292, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_is_active_292_comment},
  {"isActive", &Dtool_GraphicsStateGuardian_is_active_292, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_is_active_292_comment},
  {"is_valid", &Dtool_GraphicsStateGuardian_is_valid_293, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_is_valid_293_comment},
  {"isValid", &Dtool_GraphicsStateGuardian_is_valid_293, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_is_valid_293_comment},
  {"needs_reset", &Dtool_GraphicsStateGuardian_needs_reset_294, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_needs_reset_294_comment},
  {"needsReset", &Dtool_GraphicsStateGuardian_needs_reset_294, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_needs_reset_294_comment},
  {"set_incomplete_render", &Dtool_GraphicsStateGuardian_set_incomplete_render_297, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_incomplete_render_297_comment},
  {"setIncompleteRender", &Dtool_GraphicsStateGuardian_set_incomplete_render_297, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_incomplete_render_297_comment},
  {"set_loader", &Dtool_GraphicsStateGuardian_set_loader_302, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_loader_302_comment},
  {"setLoader", &Dtool_GraphicsStateGuardian_set_loader_302, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_loader_302_comment},
  {"get_loader", &Dtool_GraphicsStateGuardian_get_loader_303, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_loader_303_comment},
  {"getLoader", &Dtool_GraphicsStateGuardian_get_loader_303, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_loader_303_comment},
  {"set_shader_generator", &Dtool_GraphicsStateGuardian_set_shader_generator_307, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_shader_generator_307_comment},
  {"setShaderGenerator", &Dtool_GraphicsStateGuardian_set_shader_generator_307, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_shader_generator_307_comment},
  {"get_shader_generator", &Dtool_GraphicsStateGuardian_get_shader_generator_308, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_shader_generator_308_comment},
  {"getShaderGenerator", &Dtool_GraphicsStateGuardian_get_shader_generator_308, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_shader_generator_308_comment},
  {"get_pipe", &Dtool_GraphicsStateGuardian_get_pipe_312, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_pipe_312_comment},
  {"getPipe", &Dtool_GraphicsStateGuardian_get_pipe_312, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_pipe_312_comment},
  {"get_engine", &Dtool_GraphicsStateGuardian_get_engine_313, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_engine_313_comment},
  {"getEngine", &Dtool_GraphicsStateGuardian_get_engine_313, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_engine_313_comment},
  {"get_threading_model", &Dtool_GraphicsStateGuardian_get_threading_model_314, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_threading_model_314_comment},
  {"getThreadingModel", &Dtool_GraphicsStateGuardian_get_threading_model_314, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_threading_model_314_comment},
  {"is_hardware", &Dtool_GraphicsStateGuardian_is_hardware_317, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_is_hardware_317_comment},
  {"isHardware", &Dtool_GraphicsStateGuardian_is_hardware_317, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_is_hardware_317_comment},
  {"get_max_texture_stages", &Dtool_GraphicsStateGuardian_get_max_texture_stages_318, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_texture_stages_318_comment},
  {"getMaxTextureStages", &Dtool_GraphicsStateGuardian_get_max_texture_stages_318, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_texture_stages_318_comment},
  {"get_max_3d_texture_dimension", &Dtool_GraphicsStateGuardian_get_max_3d_texture_dimension_319, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_3d_texture_dimension_319_comment},
  {"getMax3dTextureDimension", &Dtool_GraphicsStateGuardian_get_max_3d_texture_dimension_319, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_3d_texture_dimension_319_comment},
  {"get_max_2d_texture_array_layers", &Dtool_GraphicsStateGuardian_get_max_2d_texture_array_layers_320, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_2d_texture_array_layers_320_comment},
  {"getMax2dTextureArrayLayers", &Dtool_GraphicsStateGuardian_get_max_2d_texture_array_layers_320, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_2d_texture_array_layers_320_comment},
  {"get_max_cube_map_dimension", &Dtool_GraphicsStateGuardian_get_max_cube_map_dimension_321, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_cube_map_dimension_321_comment},
  {"getMaxCubeMapDimension", &Dtool_GraphicsStateGuardian_get_max_cube_map_dimension_321, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_cube_map_dimension_321_comment},
  {"get_max_buffer_texture_size", &Dtool_GraphicsStateGuardian_get_max_buffer_texture_size_322, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_buffer_texture_size_322_comment},
  {"getMaxBufferTextureSize", &Dtool_GraphicsStateGuardian_get_max_buffer_texture_size_322, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_buffer_texture_size_322_comment},
  {"get_supports_texture_combine", &Dtool_GraphicsStateGuardian_get_supports_texture_combine_323, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_texture_combine_323_comment},
  {"getSupportsTextureCombine", &Dtool_GraphicsStateGuardian_get_supports_texture_combine_323, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_texture_combine_323_comment},
  {"get_supports_texture_saved_result", &Dtool_GraphicsStateGuardian_get_supports_texture_saved_result_324, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_texture_saved_result_324_comment},
  {"getSupportsTextureSavedResult", &Dtool_GraphicsStateGuardian_get_supports_texture_saved_result_324, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_texture_saved_result_324_comment},
  {"get_supports_texture_dot3", &Dtool_GraphicsStateGuardian_get_supports_texture_dot3_325, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_texture_dot3_325_comment},
  {"getSupportsTextureDot3", &Dtool_GraphicsStateGuardian_get_supports_texture_dot3_325, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_texture_dot3_325_comment},
  {"get_supports_3d_texture", &Dtool_GraphicsStateGuardian_get_supports_3d_texture_326, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_3d_texture_326_comment},
  {"getSupports3dTexture", &Dtool_GraphicsStateGuardian_get_supports_3d_texture_326, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_3d_texture_326_comment},
  {"get_supports_2d_texture_array", &Dtool_GraphicsStateGuardian_get_supports_2d_texture_array_327, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_2d_texture_array_327_comment},
  {"getSupports2dTextureArray", &Dtool_GraphicsStateGuardian_get_supports_2d_texture_array_327, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_2d_texture_array_327_comment},
  {"get_supports_cube_map", &Dtool_GraphicsStateGuardian_get_supports_cube_map_328, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_cube_map_328_comment},
  {"getSupportsCubeMap", &Dtool_GraphicsStateGuardian_get_supports_cube_map_328, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_cube_map_328_comment},
  {"get_supports_buffer_texture", &Dtool_GraphicsStateGuardian_get_supports_buffer_texture_329, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_buffer_texture_329_comment},
  {"getSupportsBufferTexture", &Dtool_GraphicsStateGuardian_get_supports_buffer_texture_329, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_buffer_texture_329_comment},
  {"get_supports_cube_map_array", &Dtool_GraphicsStateGuardian_get_supports_cube_map_array_330, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_cube_map_array_330_comment},
  {"getSupportsCubeMapArray", &Dtool_GraphicsStateGuardian_get_supports_cube_map_array_330, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_cube_map_array_330_comment},
  {"get_supports_tex_non_pow2", &Dtool_GraphicsStateGuardian_get_supports_tex_non_pow2_331, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_tex_non_pow2_331_comment},
  {"getSupportsTexNonPow2", &Dtool_GraphicsStateGuardian_get_supports_tex_non_pow2_331, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_tex_non_pow2_331_comment},
  {"get_supports_compressed_texture", &Dtool_GraphicsStateGuardian_get_supports_compressed_texture_332, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_compressed_texture_332_comment},
  {"getSupportsCompressedTexture", &Dtool_GraphicsStateGuardian_get_supports_compressed_texture_332, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_compressed_texture_332_comment},
  {"get_max_lights", &Dtool_GraphicsStateGuardian_get_max_lights_333, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_lights_333_comment},
  {"getMaxLights", &Dtool_GraphicsStateGuardian_get_max_lights_333, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_lights_333_comment},
  {"get_max_clip_planes", &Dtool_GraphicsStateGuardian_get_max_clip_planes_334, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_clip_planes_334_comment},
  {"getMaxClipPlanes", &Dtool_GraphicsStateGuardian_get_max_clip_planes_334, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_clip_planes_334_comment},
  {"get_max_vertex_transforms", &Dtool_GraphicsStateGuardian_get_max_vertex_transforms_335, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_vertex_transforms_335_comment},
  {"getMaxVertexTransforms", &Dtool_GraphicsStateGuardian_get_max_vertex_transforms_335, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_vertex_transforms_335_comment},
  {"get_max_vertex_transform_indices", &Dtool_GraphicsStateGuardian_get_max_vertex_transform_indices_336, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_vertex_transform_indices_336_comment},
  {"getMaxVertexTransformIndices", &Dtool_GraphicsStateGuardian_get_max_vertex_transform_indices_336, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_vertex_transform_indices_336_comment},
  {"get_copy_texture_inverted", &Dtool_GraphicsStateGuardian_get_copy_texture_inverted_337, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_copy_texture_inverted_337_comment},
  {"getCopyTextureInverted", &Dtool_GraphicsStateGuardian_get_copy_texture_inverted_337, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_copy_texture_inverted_337_comment},
  {"get_supports_generate_mipmap", &Dtool_GraphicsStateGuardian_get_supports_generate_mipmap_338, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_generate_mipmap_338_comment},
  {"getSupportsGenerateMipmap", &Dtool_GraphicsStateGuardian_get_supports_generate_mipmap_338, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_generate_mipmap_338_comment},
  {"get_supports_depth_texture", &Dtool_GraphicsStateGuardian_get_supports_depth_texture_339, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_depth_texture_339_comment},
  {"getSupportsDepthTexture", &Dtool_GraphicsStateGuardian_get_supports_depth_texture_339, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_depth_texture_339_comment},
  {"get_supports_depth_stencil", &Dtool_GraphicsStateGuardian_get_supports_depth_stencil_340, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_depth_stencil_340_comment},
  {"getSupportsDepthStencil", &Dtool_GraphicsStateGuardian_get_supports_depth_stencil_340, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_depth_stencil_340_comment},
  {"get_supports_luminance_texture", &Dtool_GraphicsStateGuardian_get_supports_luminance_texture_341, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_luminance_texture_341_comment},
  {"getSupportsLuminanceTexture", &Dtool_GraphicsStateGuardian_get_supports_luminance_texture_341, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_luminance_texture_341_comment},
  {"get_supports_sampler_objects", &Dtool_GraphicsStateGuardian_get_supports_sampler_objects_342, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_sampler_objects_342_comment},
  {"getSupportsSamplerObjects", &Dtool_GraphicsStateGuardian_get_supports_sampler_objects_342, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_sampler_objects_342_comment},
  {"get_supports_basic_shaders", &Dtool_GraphicsStateGuardian_get_supports_basic_shaders_343, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_basic_shaders_343_comment},
  {"getSupportsBasicShaders", &Dtool_GraphicsStateGuardian_get_supports_basic_shaders_343, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_basic_shaders_343_comment},
  {"get_supports_geometry_shaders", &Dtool_GraphicsStateGuardian_get_supports_geometry_shaders_344, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_geometry_shaders_344_comment},
  {"getSupportsGeometryShaders", &Dtool_GraphicsStateGuardian_get_supports_geometry_shaders_344, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_geometry_shaders_344_comment},
  {"get_supports_tessellation_shaders", &Dtool_GraphicsStateGuardian_get_supports_tessellation_shaders_345, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_tessellation_shaders_345_comment},
  {"getSupportsTessellationShaders", &Dtool_GraphicsStateGuardian_get_supports_tessellation_shaders_345, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_tessellation_shaders_345_comment},
  {"get_supports_compute_shaders", &Dtool_GraphicsStateGuardian_get_supports_compute_shaders_346, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_compute_shaders_346_comment},
  {"getSupportsComputeShaders", &Dtool_GraphicsStateGuardian_get_supports_compute_shaders_346, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_compute_shaders_346_comment},
  {"get_supports_glsl", &Dtool_GraphicsStateGuardian_get_supports_glsl_347, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_glsl_347_comment},
  {"getSupportsGlsl", &Dtool_GraphicsStateGuardian_get_supports_glsl_347, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_glsl_347_comment},
  {"get_supports_stencil", &Dtool_GraphicsStateGuardian_get_supports_stencil_348, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_stencil_348_comment},
  {"getSupportsStencil", &Dtool_GraphicsStateGuardian_get_supports_stencil_348, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_stencil_348_comment},
  {"get_supports_two_sided_stencil", &Dtool_GraphicsStateGuardian_get_supports_two_sided_stencil_349, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_two_sided_stencil_349_comment},
  {"getSupportsTwoSidedStencil", &Dtool_GraphicsStateGuardian_get_supports_two_sided_stencil_349, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_two_sided_stencil_349_comment},
  {"get_supports_geometry_instancing", &Dtool_GraphicsStateGuardian_get_supports_geometry_instancing_350, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_geometry_instancing_350_comment},
  {"getSupportsGeometryInstancing", &Dtool_GraphicsStateGuardian_get_supports_geometry_instancing_350, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_geometry_instancing_350_comment},
  {"get_supports_indirect_draw", &Dtool_GraphicsStateGuardian_get_supports_indirect_draw_351, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_indirect_draw_351_comment},
  {"getSupportsIndirectDraw", &Dtool_GraphicsStateGuardian_get_supports_indirect_draw_351, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_indirect_draw_351_comment},
  {"get_supports_occlusion_query", &Dtool_GraphicsStateGuardian_get_supports_occlusion_query_352, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_occlusion_query_352_comment},
  {"getSupportsOcclusionQuery", &Dtool_GraphicsStateGuardian_get_supports_occlusion_query_352, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_occlusion_query_352_comment},
  {"get_supports_timer_query", &Dtool_GraphicsStateGuardian_get_supports_timer_query_353, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_timer_query_353_comment},
  {"getSupportsTimerQuery", &Dtool_GraphicsStateGuardian_get_supports_timer_query_353, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_timer_query_353_comment},
  {"get_timer_queries_active", &Dtool_GraphicsStateGuardian_get_timer_queries_active_354, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_timer_queries_active_354_comment},
  {"getTimerQueriesActive", &Dtool_GraphicsStateGuardian_get_timer_queries_active_354, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_timer_queries_active_354_comment},
  {"get_max_color_targets", &Dtool_GraphicsStateGuardian_get_max_color_targets_355, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_color_targets_355_comment},
  {"getMaxColorTargets", &Dtool_GraphicsStateGuardian_get_max_color_targets_355, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_max_color_targets_355_comment},
  {"get_maximum_simultaneous_render_targets", &Dtool_GraphicsStateGuardian_get_maximum_simultaneous_render_targets_356, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_maximum_simultaneous_render_targets_356_comment},
  {"getMaximumSimultaneousRenderTargets", &Dtool_GraphicsStateGuardian_get_maximum_simultaneous_render_targets_356, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_maximum_simultaneous_render_targets_356_comment},
  {"get_supports_dual_source_blending", &Dtool_GraphicsStateGuardian_get_supports_dual_source_blending_357, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_dual_source_blending_357_comment},
  {"getSupportsDualSourceBlending", &Dtool_GraphicsStateGuardian_get_supports_dual_source_blending_357, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_supports_dual_source_blending_357_comment},
  {"get_shader_model", &Dtool_GraphicsStateGuardian_get_shader_model_411, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_shader_model_411_comment},
  {"getShaderModel", &Dtool_GraphicsStateGuardian_get_shader_model_411, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_shader_model_411_comment},
  {"set_shader_model", &Dtool_GraphicsStateGuardian_set_shader_model_412, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_shader_model_412_comment},
  {"setShaderModel", &Dtool_GraphicsStateGuardian_set_shader_model_412, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_shader_model_412_comment},
  {"get_supports_cg_profile", &Dtool_GraphicsStateGuardian_get_supports_cg_profile_414, METH_O, (const char *)Dtool_GraphicsStateGuardian_get_supports_cg_profile_414_comment},
  {"getSupportsCgProfile", &Dtool_GraphicsStateGuardian_get_supports_cg_profile_414, METH_O, (const char *)Dtool_GraphicsStateGuardian_get_supports_cg_profile_414_comment},
  {"get_color_scale_via_lighting", &Dtool_GraphicsStateGuardian_get_color_scale_via_lighting_415, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_color_scale_via_lighting_415_comment},
  {"getColorScaleViaLighting", &Dtool_GraphicsStateGuardian_get_color_scale_via_lighting_415, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_color_scale_via_lighting_415_comment},
  {"get_alpha_scale_via_texture", &Dtool_GraphicsStateGuardian_get_alpha_scale_via_texture_416, METH_VARARGS, (const char *)Dtool_GraphicsStateGuardian_get_alpha_scale_via_texture_416_comment},
  {"getAlphaScaleViaTexture", &Dtool_GraphicsStateGuardian_get_alpha_scale_via_texture_416, METH_VARARGS, (const char *)Dtool_GraphicsStateGuardian_get_alpha_scale_via_texture_416_comment},
  {"get_runtime_color_scale", &Dtool_GraphicsStateGuardian_get_runtime_color_scale_417, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_runtime_color_scale_417_comment},
  {"getRuntimeColorScale", &Dtool_GraphicsStateGuardian_get_runtime_color_scale_417, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_runtime_color_scale_417_comment},
  {"get_alpha_scale_texture_stage", &Dtool_GraphicsStateGuardian_get_alpha_scale_texture_stage_418, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsStateGuardian_get_alpha_scale_texture_stage_418_comment},
  {"getAlphaScaleTextureStage", &Dtool_GraphicsStateGuardian_get_alpha_scale_texture_stage_418, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsStateGuardian_get_alpha_scale_texture_stage_418_comment},
  {"set_coordinate_system", &Dtool_GraphicsStateGuardian_set_coordinate_system_419, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_coordinate_system_419_comment},
  {"setCoordinateSystem", &Dtool_GraphicsStateGuardian_set_coordinate_system_419, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_coordinate_system_419_comment},
  {"get_coordinate_system", &Dtool_GraphicsStateGuardian_get_coordinate_system_420, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_coordinate_system_420_comment},
  {"getCoordinateSystem", &Dtool_GraphicsStateGuardian_get_coordinate_system_420, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_coordinate_system_420_comment},
  {"get_internal_coordinate_system", &Dtool_GraphicsStateGuardian_get_internal_coordinate_system_421, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_internal_coordinate_system_421_comment},
  {"getInternalCoordinateSystem", &Dtool_GraphicsStateGuardian_get_internal_coordinate_system_421, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_internal_coordinate_system_421_comment},
  {"get_prepared_objects", &Dtool_GraphicsStateGuardian_get_prepared_objects_424, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_prepared_objects_424_comment},
  {"getPreparedObjects", &Dtool_GraphicsStateGuardian_get_prepared_objects_424, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_prepared_objects_424_comment},
  {"set_gamma", &Dtool_GraphicsStateGuardian_set_gamma_428, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_gamma_428_comment},
  {"setGamma", &Dtool_GraphicsStateGuardian_set_gamma_428, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_gamma_428_comment},
  {"get_gamma", &Dtool_GraphicsStateGuardian_get_gamma_429, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_gamma_429_comment},
  {"getGamma", &Dtool_GraphicsStateGuardian_get_gamma_429, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_gamma_429_comment},
  {"restore_gamma", &Dtool_GraphicsStateGuardian_restore_gamma_430, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_restore_gamma_430_comment},
  {"restoreGamma", &Dtool_GraphicsStateGuardian_restore_gamma_430, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_restore_gamma_430_comment},
  {"set_texture_quality_override", &Dtool_GraphicsStateGuardian_set_texture_quality_override_432, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_texture_quality_override_432_comment},
  {"setTextureQualityOverride", &Dtool_GraphicsStateGuardian_set_texture_quality_override_432, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_texture_quality_override_432_comment},
  {"get_texture_quality_override", &Dtool_GraphicsStateGuardian_get_texture_quality_override_433, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_texture_quality_override_433_comment},
  {"getTextureQualityOverride", &Dtool_GraphicsStateGuardian_get_texture_quality_override_433, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_texture_quality_override_433_comment},
  {"get_prepared_textures", &Dtool_GraphicsStateGuardian_get_prepared_textures_437, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_prepared_textures_437_comment},
  {"getPreparedTextures", &Dtool_GraphicsStateGuardian_get_prepared_textures_437, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_prepared_textures_437_comment},
  {"set_flash_texture", &Dtool_GraphicsStateGuardian_set_flash_texture_439, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_flash_texture_439_comment},
  {"setFlashTexture", &Dtool_GraphicsStateGuardian_set_flash_texture_439, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_flash_texture_439_comment},
  {"clear_flash_texture", &Dtool_GraphicsStateGuardian_clear_flash_texture_440, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_clear_flash_texture_440_comment},
  {"clearFlashTexture", &Dtool_GraphicsStateGuardian_clear_flash_texture_440, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_clear_flash_texture_440_comment},
  {"get_flash_texture", &Dtool_GraphicsStateGuardian_get_flash_texture_441, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_flash_texture_441_comment},
  {"getFlashTexture", &Dtool_GraphicsStateGuardian_get_flash_texture_441, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_flash_texture_441_comment},
  {"has_extension", &Dtool_GraphicsStateGuardian_has_extension_444, METH_O, (const char *)Dtool_GraphicsStateGuardian_has_extension_444_comment},
  {"hasExtension", &Dtool_GraphicsStateGuardian_has_extension_444, METH_O, (const char *)Dtool_GraphicsStateGuardian_has_extension_444_comment},
  {"get_driver_vendor", &Dtool_GraphicsStateGuardian_get_driver_vendor_445, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_driver_vendor_445_comment},
  {"getDriverVendor", &Dtool_GraphicsStateGuardian_get_driver_vendor_445, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_driver_vendor_445_comment},
  {"get_driver_renderer", &Dtool_GraphicsStateGuardian_get_driver_renderer_446, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_driver_renderer_446_comment},
  {"getDriverRenderer", &Dtool_GraphicsStateGuardian_get_driver_renderer_446, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_driver_renderer_446_comment},
  {"get_driver_version", &Dtool_GraphicsStateGuardian_get_driver_version_447, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_driver_version_447_comment},
  {"getDriverVersion", &Dtool_GraphicsStateGuardian_get_driver_version_447, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_driver_version_447_comment},
  {"get_driver_version_major", &Dtool_GraphicsStateGuardian_get_driver_version_major_448, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_driver_version_major_448_comment},
  {"getDriverVersionMajor", &Dtool_GraphicsStateGuardian_get_driver_version_major_448, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_driver_version_major_448_comment},
  {"get_driver_version_minor", &Dtool_GraphicsStateGuardian_get_driver_version_minor_449, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_driver_version_minor_449_comment},
  {"getDriverVersionMinor", &Dtool_GraphicsStateGuardian_get_driver_version_minor_449, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_driver_version_minor_449_comment},
  {"get_driver_shader_version_major", &Dtool_GraphicsStateGuardian_get_driver_shader_version_major_450, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_driver_shader_version_major_450_comment},
  {"getDriverShaderVersionMajor", &Dtool_GraphicsStateGuardian_get_driver_shader_version_major_450, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_driver_shader_version_major_450_comment},
  {"get_driver_shader_version_minor", &Dtool_GraphicsStateGuardian_get_driver_shader_version_minor_451, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_driver_shader_version_minor_451_comment},
  {"getDriverShaderVersionMinor", &Dtool_GraphicsStateGuardian_get_driver_shader_version_minor_451, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_driver_shader_version_minor_451_comment},
  {"set_scene", &Dtool_GraphicsStateGuardian_set_scene_459, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_scene_459_comment},
  {"setScene", &Dtool_GraphicsStateGuardian_set_scene_459, METH_O, (const char *)Dtool_GraphicsStateGuardian_set_scene_459_comment},
  {"get_scene", &Dtool_GraphicsStateGuardian_get_scene_460, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_scene_460_comment},
  {"getScene", &Dtool_GraphicsStateGuardian_get_scene_460, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_get_scene_460_comment},
  {"begin_scene", &Dtool_GraphicsStateGuardian_begin_scene_464, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_begin_scene_464_comment},
  {"beginScene", &Dtool_GraphicsStateGuardian_begin_scene_464, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_begin_scene_464_comment},
  {"end_scene", &Dtool_GraphicsStateGuardian_end_scene_465, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_end_scene_465_comment},
  {"endScene", &Dtool_GraphicsStateGuardian_end_scene_465, METH_NOARGS, (const char *)Dtool_GraphicsStateGuardian_end_scene_465_comment},
  {"get_class_type", &Dtool_GraphicsStateGuardian_get_class_type_466, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsStateGuardian_get_class_type_466_comment},
  {"getClassType", &Dtool_GraphicsStateGuardian_get_class_type_466, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsStateGuardian_get_class_type_466_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_GraphicsStateGuardian[] = {
  {(char *)"active", &Dtool_GraphicsStateGuardian_active_Getter, &Dtool_GraphicsStateGuardian_active_Setter, nullptr, nullptr},
  {(char *)"valid", &Dtool_GraphicsStateGuardian_valid_Getter, nullptr, nullptr, nullptr},
  {(char *)"incomplete_render", &Dtool_GraphicsStateGuardian_incomplete_render_Getter, &Dtool_GraphicsStateGuardian_incomplete_render_Setter, nullptr, nullptr},
  {(char *)"effective_incomplete_render", &Dtool_GraphicsStateGuardian_effective_incomplete_render_Getter, nullptr, nullptr, nullptr},
  {(char *)"loader", &Dtool_GraphicsStateGuardian_loader_Getter, &Dtool_GraphicsStateGuardian_loader_Setter, nullptr, nullptr},
  {(char *)"shader_generator", &Dtool_GraphicsStateGuardian_shader_generator_Getter, &Dtool_GraphicsStateGuardian_shader_generator_Setter, nullptr, nullptr},
  {(char *)"pipe", &Dtool_GraphicsStateGuardian_pipe_Getter, nullptr, nullptr, nullptr},
  {(char *)"max_vertices_per_array", &Dtool_GraphicsStateGuardian_max_vertices_per_array_Getter, nullptr, nullptr, nullptr},
  {(char *)"max_vertices_per_primitive", &Dtool_GraphicsStateGuardian_max_vertices_per_primitive_Getter, nullptr, nullptr, nullptr},
  {(char *)"max_texture_stages", &Dtool_GraphicsStateGuardian_max_texture_stages_Getter, nullptr, nullptr, nullptr},
  {(char *)"max_texture_dimension", &Dtool_GraphicsStateGuardian_max_texture_dimension_Getter, nullptr, nullptr, nullptr},
  {(char *)"max_3d_texture_dimension", &Dtool_GraphicsStateGuardian_max_3d_texture_dimension_Getter, nullptr, nullptr, nullptr},
  {(char *)"max_2d_texture_array_layers", &Dtool_GraphicsStateGuardian_max_2d_texture_array_layers_Getter, nullptr, (char *)
    "//z axis",
    nullptr},
  {(char *)"max_cube_map_dimension", &Dtool_GraphicsStateGuardian_max_cube_map_dimension_Getter, nullptr, (char *)
    "//z axis",
    nullptr},
  {(char *)"max_buffer_texture_size", &Dtool_GraphicsStateGuardian_max_buffer_texture_size_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_texture_combine", &Dtool_GraphicsStateGuardian_supports_texture_combine_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_texture_saved_result", &Dtool_GraphicsStateGuardian_supports_texture_saved_result_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_texture_dot3", &Dtool_GraphicsStateGuardian_supports_texture_dot3_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_3d_texture", &Dtool_GraphicsStateGuardian_supports_3d_texture_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_2d_texture_array", &Dtool_GraphicsStateGuardian_supports_2d_texture_array_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_cube_map", &Dtool_GraphicsStateGuardian_supports_cube_map_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_buffer_texture", &Dtool_GraphicsStateGuardian_supports_buffer_texture_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_cube_map_array", &Dtool_GraphicsStateGuardian_supports_cube_map_array_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_tex_non_pow2", &Dtool_GraphicsStateGuardian_supports_tex_non_pow2_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_texture_srgb", &Dtool_GraphicsStateGuardian_supports_texture_srgb_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_compressed_texture", &Dtool_GraphicsStateGuardian_supports_compressed_texture_Getter, nullptr, nullptr, nullptr},
  {(char *)"max_lights", &Dtool_GraphicsStateGuardian_max_lights_Getter, nullptr, nullptr, nullptr},
  {(char *)"max_clip_planes", &Dtool_GraphicsStateGuardian_max_clip_planes_Getter, nullptr, nullptr, nullptr},
  {(char *)"max_vertex_transforms", &Dtool_GraphicsStateGuardian_max_vertex_transforms_Getter, nullptr, nullptr, nullptr},
  {(char *)"max_vertex_transform_indices", &Dtool_GraphicsStateGuardian_max_vertex_transform_indices_Getter, nullptr, nullptr, nullptr},
  {(char *)"copy_texture_inverted", &Dtool_GraphicsStateGuardian_copy_texture_inverted_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_multisample", &Dtool_GraphicsStateGuardian_supports_multisample_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_generate_mipmap", &Dtool_GraphicsStateGuardian_supports_generate_mipmap_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_depth_texture", &Dtool_GraphicsStateGuardian_supports_depth_texture_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_depth_stencil", &Dtool_GraphicsStateGuardian_supports_depth_stencil_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_luminance_texture", &Dtool_GraphicsStateGuardian_supports_luminance_texture_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_shadow_filter", &Dtool_GraphicsStateGuardian_supports_shadow_filter_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_sampler_objects", &Dtool_GraphicsStateGuardian_supports_sampler_objects_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_basic_shaders", &Dtool_GraphicsStateGuardian_supports_basic_shaders_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_geometry_shaders", &Dtool_GraphicsStateGuardian_supports_geometry_shaders_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_tessellation_shaders", &Dtool_GraphicsStateGuardian_supports_tessellation_shaders_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_compute_shaders", &Dtool_GraphicsStateGuardian_supports_compute_shaders_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_glsl", &Dtool_GraphicsStateGuardian_supports_glsl_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_hlsl", &Dtool_GraphicsStateGuardian_supports_hlsl_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_stencil", &Dtool_GraphicsStateGuardian_supports_stencil_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_two_sided_stencil", &Dtool_GraphicsStateGuardian_supports_two_sided_stencil_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_geometry_instancing", &Dtool_GraphicsStateGuardian_supports_geometry_instancing_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_indirect_draw", &Dtool_GraphicsStateGuardian_supports_indirect_draw_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_occlusion_query", &Dtool_GraphicsStateGuardian_supports_occlusion_query_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_timer_query", &Dtool_GraphicsStateGuardian_supports_timer_query_Getter, nullptr, nullptr, nullptr},
  {(char *)"timer_queries_active", &Dtool_GraphicsStateGuardian_timer_queries_active_Getter, nullptr, nullptr, nullptr},
  {(char *)"max_color_targets", &Dtool_GraphicsStateGuardian_max_color_targets_Getter, nullptr, nullptr, nullptr},
  {(char *)"supports_dual_source_blending", &Dtool_GraphicsStateGuardian_supports_dual_source_blending_Getter, nullptr, nullptr, nullptr},
  {(char *)"shader_model", &Dtool_GraphicsStateGuardian_shader_model_Getter, &Dtool_GraphicsStateGuardian_shader_model_Setter, nullptr, nullptr},
  {(char *)"coordinate_system", &Dtool_GraphicsStateGuardian_coordinate_system_Getter, &Dtool_GraphicsStateGuardian_coordinate_system_Setter, nullptr, nullptr},
  {(char *)"prepared_objects", &Dtool_GraphicsStateGuardian_prepared_objects_Getter, nullptr, nullptr, nullptr},
  {(char *)"gamma", &Dtool_GraphicsStateGuardian_gamma_Getter, &Dtool_GraphicsStateGuardian_gamma_Setter, nullptr, nullptr},
  {(char *)"texture_quality_override", &Dtool_GraphicsStateGuardian_texture_quality_override_Getter, &Dtool_GraphicsStateGuardian_texture_quality_override_Setter, nullptr, nullptr},
  {(char *)"flash_texture", &Dtool_GraphicsStateGuardian_flash_texture_Getter, &Dtool_GraphicsStateGuardian_flash_texture_Setter, nullptr, nullptr},
  {(char *)"driver_vendor", &Dtool_GraphicsStateGuardian_driver_vendor_Getter, nullptr, nullptr, nullptr},
  {(char *)"driver_renderer", &Dtool_GraphicsStateGuardian_driver_renderer_Getter, nullptr, nullptr, nullptr},
  {(char *)"driver_version", &Dtool_GraphicsStateGuardian_driver_version_Getter, nullptr, nullptr, nullptr},
  {(char *)"driver_version_major", &Dtool_GraphicsStateGuardian_driver_version_major_Getter, nullptr, nullptr, nullptr},
  {(char *)"driver_version_minor", &Dtool_GraphicsStateGuardian_driver_version_minor_Getter, nullptr, nullptr, nullptr},
  {(char *)"driver_shader_version_major", &Dtool_GraphicsStateGuardian_driver_shader_version_major_Getter, nullptr, nullptr, nullptr},
  {(char *)"driver_shader_version_minor", &Dtool_GraphicsStateGuardian_driver_shader_version_minor_Getter, nullptr, nullptr, nullptr},
  {(char *)"scene", &Dtool_GraphicsStateGuardian_scene_Getter, &Dtool_GraphicsStateGuardian_scene_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_GraphicsStateGuardian = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GraphicsStateGuardian = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GraphicsStateGuardian = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GraphicsStateGuardian = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GraphicsStateGuardian = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GraphicsStateGuardian = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GraphicsStateGuardian",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GraphicsStateGuardian,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GraphicsStateGuardian,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GraphicsStateGuardian,
    &Dtool_SequenceMethods_GraphicsStateGuardian,
    &Dtool_MappingMethods_GraphicsStateGuardian,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GraphicsStateGuardian,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Encapsulates all the communication with a particular instance of a given\n"
    " * rendering backend.  Tries to guarantee that redundant state-change requests\n"
    " * are not issued (hence \"state guardian\").\n"
    " *\n"
    " * There will be one of these objects for each different graphics context\n"
    " * active in the system.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GraphicsStateGuardian,
    nullptr, // tp_members
    Dtool_Properties_GraphicsStateGuardian,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GraphicsStateGuardian,
    PyType_GenericAlloc,
    Dtool_new_GraphicsStateGuardian,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GraphicsStateGuardian,
  Dtool_UpcastInterface_GraphicsStateGuardian,
  Dtool_DowncastInterface_GraphicsStateGuardian,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GraphicsStateGuardian(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_GraphicsStateGuardianBase != nullptr);
    assert(Dtool_Ptr_GraphicsStateGuardianBase->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_GraphicsStateGuardianBase->_Dtool_ModuleClassInit(nullptr);
    Dtool_GraphicsStateGuardian._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_GraphicsStateGuardianBase);
    Dtool_GraphicsStateGuardian._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(17);
    Dtool_GraphicsStateGuardian._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum GraphicsStateGuardian::ShaderModel;
    PyDict_SetItemString(dict, "SM_00", Dtool_WrapValue(GraphicsStateGuardian::SM_00));
    PyDict_SetItemString(dict, "SM00", Dtool_WrapValue(GraphicsStateGuardian::SM_00));
    PyDict_SetItemString(dict, "SM_11", Dtool_WrapValue(GraphicsStateGuardian::SM_11));
    PyDict_SetItemString(dict, "SM11", Dtool_WrapValue(GraphicsStateGuardian::SM_11));
    PyDict_SetItemString(dict, "SM_20", Dtool_WrapValue(GraphicsStateGuardian::SM_20));
    PyDict_SetItemString(dict, "SM20", Dtool_WrapValue(GraphicsStateGuardian::SM_20));
    PyDict_SetItemString(dict, "SM_2X", Dtool_WrapValue(GraphicsStateGuardian::SM_2X));
    PyDict_SetItemString(dict, "SM2X", Dtool_WrapValue(GraphicsStateGuardian::SM_2X));
    PyDict_SetItemString(dict, "SM_30", Dtool_WrapValue(GraphicsStateGuardian::SM_30));
    PyDict_SetItemString(dict, "SM30", Dtool_WrapValue(GraphicsStateGuardian::SM_30));
    PyDict_SetItemString(dict, "SM_40", Dtool_WrapValue(GraphicsStateGuardian::SM_40));
    PyDict_SetItemString(dict, "SM40", Dtool_WrapValue(GraphicsStateGuardian::SM_40));
    PyDict_SetItemString(dict, "SM_50", Dtool_WrapValue(GraphicsStateGuardian::SM_50));
    PyDict_SetItemString(dict, "SM50", Dtool_WrapValue(GraphicsStateGuardian::SM_50));
    PyDict_SetItemString(dict, "SM_51", Dtool_WrapValue(GraphicsStateGuardian::SM_51));
    PyDict_SetItemString(dict, "SM51", Dtool_WrapValue(GraphicsStateGuardian::SM_51));
    if (PyType_Ready((PyTypeObject *)&Dtool_GraphicsStateGuardian) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GraphicsStateGuardian)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GraphicsStateGuardian);
  }
}

/**
 * Python method tables for GraphicsEngine (GraphicsEngine)
 */
static PyMethodDef Dtool_Methods_GraphicsEngine[] = {
  {"set_threading_model", &Dtool_GraphicsEngine_set_threading_model_473, METH_O, (const char *)Dtool_GraphicsEngine_set_threading_model_473_comment},
  {"setThreadingModel", &Dtool_GraphicsEngine_set_threading_model_473, METH_O, (const char *)Dtool_GraphicsEngine_set_threading_model_473_comment},
  {"get_threading_model", &Dtool_GraphicsEngine_get_threading_model_474, METH_NOARGS, (const char *)Dtool_GraphicsEngine_get_threading_model_474_comment},
  {"getThreadingModel", &Dtool_GraphicsEngine_get_threading_model_474, METH_NOARGS, (const char *)Dtool_GraphicsEngine_get_threading_model_474_comment},
  {"get_render_lock", &Dtool_GraphicsEngine_get_render_lock_492, METH_NOARGS, (const char *)Dtool_GraphicsEngine_get_render_lock_492_comment},
  {"getRenderLock", &Dtool_GraphicsEngine_get_render_lock_492, METH_NOARGS, (const char *)Dtool_GraphicsEngine_get_render_lock_492_comment},
  {"set_auto_flip", &Dtool_GraphicsEngine_set_auto_flip_496, METH_O, (const char *)Dtool_GraphicsEngine_set_auto_flip_496_comment},
  {"setAutoFlip", &Dtool_GraphicsEngine_set_auto_flip_496, METH_O, (const char *)Dtool_GraphicsEngine_set_auto_flip_496_comment},
  {"get_auto_flip", &Dtool_GraphicsEngine_get_auto_flip_497, METH_NOARGS, (const char *)Dtool_GraphicsEngine_get_auto_flip_497_comment},
  {"getAutoFlip", &Dtool_GraphicsEngine_get_auto_flip_497, METH_NOARGS, (const char *)Dtool_GraphicsEngine_get_auto_flip_497_comment},
  {"set_portal_cull", &Dtool_GraphicsEngine_set_portal_cull_499, METH_O, (const char *)Dtool_GraphicsEngine_set_portal_cull_499_comment},
  {"setPortalCull", &Dtool_GraphicsEngine_set_portal_cull_499, METH_O, (const char *)Dtool_GraphicsEngine_set_portal_cull_499_comment},
  {"get_portal_cull", &Dtool_GraphicsEngine_get_portal_cull_500, METH_NOARGS, (const char *)Dtool_GraphicsEngine_get_portal_cull_500_comment},
  {"getPortalCull", &Dtool_GraphicsEngine_get_portal_cull_500, METH_NOARGS, (const char *)Dtool_GraphicsEngine_get_portal_cull_500_comment},
  {"set_default_loader", &Dtool_GraphicsEngine_set_default_loader_502, METH_O, (const char *)Dtool_GraphicsEngine_set_default_loader_502_comment},
  {"setDefaultLoader", &Dtool_GraphicsEngine_set_default_loader_502, METH_O, (const char *)Dtool_GraphicsEngine_set_default_loader_502_comment},
  {"get_default_loader", &Dtool_GraphicsEngine_get_default_loader_503, METH_NOARGS, (const char *)Dtool_GraphicsEngine_get_default_loader_503_comment},
  {"getDefaultLoader", &Dtool_GraphicsEngine_get_default_loader_503, METH_NOARGS, (const char *)Dtool_GraphicsEngine_get_default_loader_503_comment},
  {"make_output", (PyCFunction) &Dtool_GraphicsEngine_make_output_505, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsEngine_make_output_505_comment},
  {"makeOutput", (PyCFunction) &Dtool_GraphicsEngine_make_output_505, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsEngine_make_output_505_comment},
  {"make_buffer", (PyCFunction) &Dtool_GraphicsEngine_make_buffer_506, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsEngine_make_buffer_506_comment},
  {"makeBuffer", (PyCFunction) &Dtool_GraphicsEngine_make_buffer_506, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsEngine_make_buffer_506_comment},
  {"make_parasite", (PyCFunction) &Dtool_GraphicsEngine_make_parasite_507, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsEngine_make_parasite_507_comment},
  {"makeParasite", (PyCFunction) &Dtool_GraphicsEngine_make_parasite_507, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsEngine_make_parasite_507_comment},
  {"add_window", (PyCFunction) &Dtool_GraphicsEngine_add_window_508, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsEngine_add_window_508_comment},
  {"addWindow", (PyCFunction) &Dtool_GraphicsEngine_add_window_508, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsEngine_add_window_508_comment},
  {"remove_window", &Dtool_GraphicsEngine_remove_window_509, METH_O, (const char *)Dtool_GraphicsEngine_remove_window_509_comment},
  {"removeWindow", &Dtool_GraphicsEngine_remove_window_509, METH_O, (const char *)Dtool_GraphicsEngine_remove_window_509_comment},
  {"remove_all_windows", &Dtool_GraphicsEngine_remove_all_windows_510, METH_NOARGS, (const char *)Dtool_GraphicsEngine_remove_all_windows_510_comment},
  {"removeAllWindows", &Dtool_GraphicsEngine_remove_all_windows_510, METH_NOARGS, (const char *)Dtool_GraphicsEngine_remove_all_windows_510_comment},
  {"reset_all_windows", &Dtool_GraphicsEngine_reset_all_windows_511, METH_O, (const char *)Dtool_GraphicsEngine_reset_all_windows_511_comment},
  {"resetAllWindows", &Dtool_GraphicsEngine_reset_all_windows_511, METH_O, (const char *)Dtool_GraphicsEngine_reset_all_windows_511_comment},
  {"is_empty", &Dtool_GraphicsEngine_is_empty_512, METH_NOARGS, (const char *)Dtool_GraphicsEngine_is_empty_512_comment},
  {"isEmpty", &Dtool_GraphicsEngine_is_empty_512, METH_NOARGS, (const char *)Dtool_GraphicsEngine_is_empty_512_comment},
  {"get_num_windows", &Dtool_GraphicsEngine_get_num_windows_513, METH_NOARGS, (const char *)Dtool_GraphicsEngine_get_num_windows_513_comment},
  {"getNumWindows", &Dtool_GraphicsEngine_get_num_windows_513, METH_NOARGS, (const char *)Dtool_GraphicsEngine_get_num_windows_513_comment},
  {"get_window", &Dtool_GraphicsEngine_get_window_514, METH_O, (const char *)Dtool_GraphicsEngine_get_window_514_comment},
  {"getWindow", &Dtool_GraphicsEngine_get_window_514, METH_O, (const char *)Dtool_GraphicsEngine_get_window_514_comment},
  {"render_frame", &Dtool_GraphicsEngine_render_frame_517, METH_NOARGS, (const char *)Dtool_GraphicsEngine_render_frame_517_comment},
  {"renderFrame", &Dtool_GraphicsEngine_render_frame_517, METH_NOARGS, (const char *)Dtool_GraphicsEngine_render_frame_517_comment},
  {"open_windows", &Dtool_GraphicsEngine_open_windows_518, METH_NOARGS, (const char *)Dtool_GraphicsEngine_open_windows_518_comment},
  {"openWindows", &Dtool_GraphicsEngine_open_windows_518, METH_NOARGS, (const char *)Dtool_GraphicsEngine_open_windows_518_comment},
  {"sync_frame", &Dtool_GraphicsEngine_sync_frame_519, METH_NOARGS, (const char *)Dtool_GraphicsEngine_sync_frame_519_comment},
  {"syncFrame", &Dtool_GraphicsEngine_sync_frame_519, METH_NOARGS, (const char *)Dtool_GraphicsEngine_sync_frame_519_comment},
  {"ready_flip", &Dtool_GraphicsEngine_ready_flip_520, METH_NOARGS, (const char *)Dtool_GraphicsEngine_ready_flip_520_comment},
  {"readyFlip", &Dtool_GraphicsEngine_ready_flip_520, METH_NOARGS, (const char *)Dtool_GraphicsEngine_ready_flip_520_comment},
  {"flip_frame", &Dtool_GraphicsEngine_flip_frame_521, METH_NOARGS, (const char *)Dtool_GraphicsEngine_flip_frame_521_comment},
  {"flipFrame", &Dtool_GraphicsEngine_flip_frame_521, METH_NOARGS, (const char *)Dtool_GraphicsEngine_flip_frame_521_comment},
  {"extract_texture_data", (PyCFunction) &Dtool_GraphicsEngine_extract_texture_data_522, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsEngine_extract_texture_data_522_comment},
  {"extractTextureData", (PyCFunction) &Dtool_GraphicsEngine_extract_texture_data_522, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsEngine_extract_texture_data_522_comment},
  {"dispatch_compute", (PyCFunction) &Dtool_GraphicsEngine_dispatch_compute_523, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsEngine_dispatch_compute_523_comment},
  {"dispatchCompute", (PyCFunction) &Dtool_GraphicsEngine_dispatch_compute_523, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsEngine_dispatch_compute_523_comment},
  {"get_global_ptr", &Dtool_GraphicsEngine_get_global_ptr_524, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsEngine_get_global_ptr_524_comment},
  {"getGlobalPtr", &Dtool_GraphicsEngine_get_global_ptr_524, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsEngine_get_global_ptr_524_comment},
  {"get_windows", (PyCFunction) &MakeSeq_GraphicsEngine_get_windows, METH_NOARGS, nullptr},
  { "getWindows", (PyCFunction) &MakeSeq_GraphicsEngine_get_windows, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_GraphicsEngine[] = {
  {(char *)"threading_model", &Dtool_GraphicsEngine_threading_model_Getter, &Dtool_GraphicsEngine_threading_model_Setter, nullptr, nullptr},
  {(char *)"render_lock", &Dtool_GraphicsEngine_render_lock_Getter, nullptr, nullptr, nullptr},
  {(char *)"auto_flip", &Dtool_GraphicsEngine_auto_flip_Getter, &Dtool_GraphicsEngine_auto_flip_Setter, nullptr, nullptr},
  {(char *)"portal_cull", &Dtool_GraphicsEngine_portal_cull_Getter, &Dtool_GraphicsEngine_portal_cull_Setter, nullptr, nullptr},
  {(char *)"default_loader", &Dtool_GraphicsEngine_default_loader_Getter, &Dtool_GraphicsEngine_default_loader_Setter, nullptr, nullptr},
  {(char *)"windows", &Dtool_GraphicsEngine_windows_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_GraphicsEngine = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GraphicsEngine = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GraphicsEngine = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GraphicsEngine = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GraphicsEngine = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GraphicsEngine = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GraphicsEngine",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GraphicsEngine,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GraphicsEngine,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GraphicsEngine,
    &Dtool_SequenceMethods_GraphicsEngine,
    &Dtool_MappingMethods_GraphicsEngine,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GraphicsEngine,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is the main interface to controlling the render process.  There\n"
    " * is typically only one GraphicsEngine in an application, and it synchronizes\n"
    " * rendering to all all of the active windows; although it is possible to have\n"
    " * multiple GraphicsEngine objects if multiple synchronicity groups are\n"
    " * required.\n"
    " *\n"
    " * The GraphicsEngine is responsible for managing the various cull and draw\n"
    " * threads.  The application simply calls engine->render_frame() and considers\n"
    " * it done.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GraphicsEngine,
    nullptr, // tp_members
    Dtool_Properties_GraphicsEngine,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GraphicsEngine,
    PyType_GenericAlloc,
    Dtool_new_GraphicsEngine,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GraphicsEngine,
  Dtool_UpcastInterface_GraphicsEngine,
  Dtool_DowncastInterface_GraphicsEngine,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GraphicsEngine(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_GraphicsEngine._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_GraphicsEngine._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GraphicsEngine._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GraphicsEngine) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GraphicsEngine)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GraphicsEngine);
  }
}

/**
 * Python method tables for GraphicsThreadingModel (GraphicsThreadingModel)
 */
static PyMethodDef Dtool_Methods_GraphicsThreadingModel[] = {
  {"assign", &Dtool_GraphicsThreadingModel_operator_478, METH_O, (const char *)Dtool_GraphicsThreadingModel_operator_478_comment},
  {"get_model", &Dtool_GraphicsThreadingModel_get_model_479, METH_NOARGS, (const char *)Dtool_GraphicsThreadingModel_get_model_479_comment},
  {"getModel", &Dtool_GraphicsThreadingModel_get_model_479, METH_NOARGS, (const char *)Dtool_GraphicsThreadingModel_get_model_479_comment},
  {"get_cull_name", &Dtool_GraphicsThreadingModel_get_cull_name_480, METH_NOARGS, (const char *)Dtool_GraphicsThreadingModel_get_cull_name_480_comment},
  {"getCullName", &Dtool_GraphicsThreadingModel_get_cull_name_480, METH_NOARGS, (const char *)Dtool_GraphicsThreadingModel_get_cull_name_480_comment},
  {"set_cull_name", &Dtool_GraphicsThreadingModel_set_cull_name_481, METH_O, (const char *)Dtool_GraphicsThreadingModel_set_cull_name_481_comment},
  {"setCullName", &Dtool_GraphicsThreadingModel_set_cull_name_481, METH_O, (const char *)Dtool_GraphicsThreadingModel_set_cull_name_481_comment},
  {"get_cull_stage", &Dtool_GraphicsThreadingModel_get_cull_stage_482, METH_NOARGS, (const char *)Dtool_GraphicsThreadingModel_get_cull_stage_482_comment},
  {"getCullStage", &Dtool_GraphicsThreadingModel_get_cull_stage_482, METH_NOARGS, (const char *)Dtool_GraphicsThreadingModel_get_cull_stage_482_comment},
  {"get_draw_name", &Dtool_GraphicsThreadingModel_get_draw_name_483, METH_NOARGS, (const char *)Dtool_GraphicsThreadingModel_get_draw_name_483_comment},
  {"getDrawName", &Dtool_GraphicsThreadingModel_get_draw_name_483, METH_NOARGS, (const char *)Dtool_GraphicsThreadingModel_get_draw_name_483_comment},
  {"set_draw_name", &Dtool_GraphicsThreadingModel_set_draw_name_484, METH_O, (const char *)Dtool_GraphicsThreadingModel_set_draw_name_484_comment},
  {"setDrawName", &Dtool_GraphicsThreadingModel_set_draw_name_484, METH_O, (const char *)Dtool_GraphicsThreadingModel_set_draw_name_484_comment},
  {"get_draw_stage", &Dtool_GraphicsThreadingModel_get_draw_stage_485, METH_NOARGS, (const char *)Dtool_GraphicsThreadingModel_get_draw_stage_485_comment},
  {"getDrawStage", &Dtool_GraphicsThreadingModel_get_draw_stage_485, METH_NOARGS, (const char *)Dtool_GraphicsThreadingModel_get_draw_stage_485_comment},
  {"get_cull_sorting", &Dtool_GraphicsThreadingModel_get_cull_sorting_486, METH_NOARGS, (const char *)Dtool_GraphicsThreadingModel_get_cull_sorting_486_comment},
  {"getCullSorting", &Dtool_GraphicsThreadingModel_get_cull_sorting_486, METH_NOARGS, (const char *)Dtool_GraphicsThreadingModel_get_cull_sorting_486_comment},
  {"set_cull_sorting", &Dtool_GraphicsThreadingModel_set_cull_sorting_487, METH_O, (const char *)Dtool_GraphicsThreadingModel_set_cull_sorting_487_comment},
  {"setCullSorting", &Dtool_GraphicsThreadingModel_set_cull_sorting_487, METH_O, (const char *)Dtool_GraphicsThreadingModel_set_cull_sorting_487_comment},
  {"is_single_threaded", &Dtool_GraphicsThreadingModel_is_single_threaded_488, METH_NOARGS, (const char *)Dtool_GraphicsThreadingModel_is_single_threaded_488_comment},
  {"isSingleThreaded", &Dtool_GraphicsThreadingModel_is_single_threaded_488, METH_NOARGS, (const char *)Dtool_GraphicsThreadingModel_is_single_threaded_488_comment},
  {"is_default", &Dtool_GraphicsThreadingModel_is_default_489, METH_NOARGS, (const char *)Dtool_GraphicsThreadingModel_is_default_489_comment},
  {"isDefault", &Dtool_GraphicsThreadingModel_is_default_489, METH_NOARGS, (const char *)Dtool_GraphicsThreadingModel_is_default_489_comment},
  {"output", &Dtool_GraphicsThreadingModel_output_490, METH_O, (const char *)Dtool_GraphicsThreadingModel_output_490_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     GraphicsThreadingModel
//////////////////
static PyObject *Dtool_Repr_GraphicsThreadingModel(PyObject *self) {
  GraphicsThreadingModel *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_GraphicsThreadingModel, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_GraphicsThreadingModel = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_GraphicsThreadingModel = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GraphicsThreadingModel",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GraphicsThreadingModel,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_GraphicsThreadingModel,
    &Dtool_NumberMethods_GraphicsThreadingModel,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_GraphicsThreadingModel,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This represents the user's specification of how a particular frame is\n"
    " * handled by the various threads.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GraphicsThreadingModel,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GraphicsThreadingModel,
    PyType_GenericAlloc,
    Dtool_new_GraphicsThreadingModel,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GraphicsThreadingModel,
  Dtool_UpcastInterface_GraphicsThreadingModel,
  Dtool_DowncastInterface_GraphicsThreadingModel,
  nullptr,
  (CoerceFunction)Dtool_Coerce_GraphicsThreadingModel,
};

static void Dtool_PyModuleClassInit_GraphicsThreadingModel(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_GraphicsThreadingModel._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GraphicsThreadingModel._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GraphicsThreadingModel) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GraphicsThreadingModel)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GraphicsThreadingModel);
  }
}

/**
 * Python method tables for StereoDisplayRegion (StereoDisplayRegion)
 */
static PyMethodDef Dtool_Methods_StereoDisplayRegion[] = {
  {"get_left_eye", &Dtool_StereoDisplayRegion_get_left_eye_680, METH_NOARGS, (const char *)Dtool_StereoDisplayRegion_get_left_eye_680_comment},
  {"getLeftEye", &Dtool_StereoDisplayRegion_get_left_eye_680, METH_NOARGS, (const char *)Dtool_StereoDisplayRegion_get_left_eye_680_comment},
  {"get_right_eye", &Dtool_StereoDisplayRegion_get_right_eye_681, METH_NOARGS, (const char *)Dtool_StereoDisplayRegion_get_right_eye_681_comment},
  {"getRightEye", &Dtool_StereoDisplayRegion_get_right_eye_681, METH_NOARGS, (const char *)Dtool_StereoDisplayRegion_get_right_eye_681_comment},
  {"get_class_type", &Dtool_StereoDisplayRegion_get_class_type_685, METH_NOARGS | METH_STATIC, (const char *)Dtool_StereoDisplayRegion_get_class_type_685_comment},
  {"getClassType", &Dtool_StereoDisplayRegion_get_class_type_685, METH_NOARGS | METH_STATIC, (const char *)Dtool_StereoDisplayRegion_get_class_type_685_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_StereoDisplayRegion[] = {
  {(char *)"left_eye", &Dtool_StereoDisplayRegion_left_eye_Getter, nullptr, nullptr, nullptr},
  {(char *)"right_eye", &Dtool_StereoDisplayRegion_right_eye_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_StereoDisplayRegion = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_StereoDisplayRegion = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_StereoDisplayRegion = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_StereoDisplayRegion = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_StereoDisplayRegion = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_StereoDisplayRegion = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.StereoDisplayRegion",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_StereoDisplayRegion,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_StereoDisplayRegion,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_StereoDisplayRegion,
    &Dtool_SequenceMethods_StereoDisplayRegion,
    &Dtool_MappingMethods_StereoDisplayRegion,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_StereoDisplayRegion,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special DisplayRegion wrapper that actually includes a pair of\n"
    " * DisplayRegions internally: the left and right eyes.  The DisplayRegion\n"
    " * represented here does not have a physical association with the window, but\n"
    " * it pretends it does.  Instead, it maintains a pointer to the left and right\n"
    " * DisplayRegions separately.\n"
    " *\n"
    " * Operations on the StereoDisplayRegion object affect both left and right\n"
    " * eyes together.  To access the left or right eyes independently, use\n"
    " * get_left_eye() and get_right_eye().\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_StereoDisplayRegion,
    nullptr, // tp_members
    Dtool_Properties_StereoDisplayRegion,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_StereoDisplayRegion,
    PyType_GenericAlloc,
    Dtool_new_StereoDisplayRegion,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StereoDisplayRegion,
  Dtool_UpcastInterface_StereoDisplayRegion,
  Dtool_DowncastInterface_StereoDisplayRegion,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_StereoDisplayRegion(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_DisplayRegion(nullptr);
    Dtool_StereoDisplayRegion._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_DisplayRegion);
    Dtool_StereoDisplayRegion._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_StereoDisplayRegion._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StereoDisplayRegion) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StereoDisplayRegion)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StereoDisplayRegion);
  }
}

/**
 * Python method tables for FrameBufferProperties (FrameBufferProperties)
 */
static PyMethodDef Dtool_Methods_FrameBufferProperties[] = {
  {"get_depth_bits", &Dtool_FrameBufferProperties_get_depth_bits_687, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_depth_bits_687_comment},
  {"getDepthBits", &Dtool_FrameBufferProperties_get_depth_bits_687, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_depth_bits_687_comment},
  {"get_color_bits", &Dtool_FrameBufferProperties_get_color_bits_688, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_color_bits_688_comment},
  {"getColorBits", &Dtool_FrameBufferProperties_get_color_bits_688, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_color_bits_688_comment},
  {"get_red_bits", &Dtool_FrameBufferProperties_get_red_bits_689, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_red_bits_689_comment},
  {"getRedBits", &Dtool_FrameBufferProperties_get_red_bits_689, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_red_bits_689_comment},
  {"get_green_bits", &Dtool_FrameBufferProperties_get_green_bits_690, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_green_bits_690_comment},
  {"getGreenBits", &Dtool_FrameBufferProperties_get_green_bits_690, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_green_bits_690_comment},
  {"get_blue_bits", &Dtool_FrameBufferProperties_get_blue_bits_691, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_blue_bits_691_comment},
  {"getBlueBits", &Dtool_FrameBufferProperties_get_blue_bits_691, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_blue_bits_691_comment},
  {"get_alpha_bits", &Dtool_FrameBufferProperties_get_alpha_bits_692, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_alpha_bits_692_comment},
  {"getAlphaBits", &Dtool_FrameBufferProperties_get_alpha_bits_692, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_alpha_bits_692_comment},
  {"get_stencil_bits", &Dtool_FrameBufferProperties_get_stencil_bits_693, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_stencil_bits_693_comment},
  {"getStencilBits", &Dtool_FrameBufferProperties_get_stencil_bits_693, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_stencil_bits_693_comment},
  {"get_accum_bits", &Dtool_FrameBufferProperties_get_accum_bits_694, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_accum_bits_694_comment},
  {"getAccumBits", &Dtool_FrameBufferProperties_get_accum_bits_694, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_accum_bits_694_comment},
  {"get_aux_rgba", &Dtool_FrameBufferProperties_get_aux_rgba_695, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_aux_rgba_695_comment},
  {"getAuxRgba", &Dtool_FrameBufferProperties_get_aux_rgba_695, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_aux_rgba_695_comment},
  {"get_aux_hrgba", &Dtool_FrameBufferProperties_get_aux_hrgba_696, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_aux_hrgba_696_comment},
  {"getAuxHrgba", &Dtool_FrameBufferProperties_get_aux_hrgba_696, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_aux_hrgba_696_comment},
  {"get_aux_float", &Dtool_FrameBufferProperties_get_aux_float_697, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_aux_float_697_comment},
  {"getAuxFloat", &Dtool_FrameBufferProperties_get_aux_float_697, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_aux_float_697_comment},
  {"get_multisamples", &Dtool_FrameBufferProperties_get_multisamples_698, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_multisamples_698_comment},
  {"getMultisamples", &Dtool_FrameBufferProperties_get_multisamples_698, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_multisamples_698_comment},
  {"get_coverage_samples", &Dtool_FrameBufferProperties_get_coverage_samples_699, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_coverage_samples_699_comment},
  {"getCoverageSamples", &Dtool_FrameBufferProperties_get_coverage_samples_699, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_coverage_samples_699_comment},
  {"get_back_buffers", &Dtool_FrameBufferProperties_get_back_buffers_700, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_back_buffers_700_comment},
  {"getBackBuffers", &Dtool_FrameBufferProperties_get_back_buffers_700, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_back_buffers_700_comment},
  {"get_indexed_color", &Dtool_FrameBufferProperties_get_indexed_color_701, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_indexed_color_701_comment},
  {"getIndexedColor", &Dtool_FrameBufferProperties_get_indexed_color_701, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_indexed_color_701_comment},
  {"get_rgb_color", &Dtool_FrameBufferProperties_get_rgb_color_702, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_rgb_color_702_comment},
  {"getRgbColor", &Dtool_FrameBufferProperties_get_rgb_color_702, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_rgb_color_702_comment},
  {"get_stereo", &Dtool_FrameBufferProperties_get_stereo_703, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_stereo_703_comment},
  {"getStereo", &Dtool_FrameBufferProperties_get_stereo_703, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_stereo_703_comment},
  {"get_force_hardware", &Dtool_FrameBufferProperties_get_force_hardware_704, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_force_hardware_704_comment},
  {"getForceHardware", &Dtool_FrameBufferProperties_get_force_hardware_704, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_force_hardware_704_comment},
  {"get_force_software", &Dtool_FrameBufferProperties_get_force_software_705, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_force_software_705_comment},
  {"getForceSoftware", &Dtool_FrameBufferProperties_get_force_software_705, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_force_software_705_comment},
  {"get_srgb_color", &Dtool_FrameBufferProperties_get_srgb_color_706, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_srgb_color_706_comment},
  {"getSrgbColor", &Dtool_FrameBufferProperties_get_srgb_color_706, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_srgb_color_706_comment},
  {"get_float_color", &Dtool_FrameBufferProperties_get_float_color_707, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_float_color_707_comment},
  {"getFloatColor", &Dtool_FrameBufferProperties_get_float_color_707, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_float_color_707_comment},
  {"get_float_depth", &Dtool_FrameBufferProperties_get_float_depth_708, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_float_depth_708_comment},
  {"getFloatDepth", &Dtool_FrameBufferProperties_get_float_depth_708, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_float_depth_708_comment},
  {"set_depth_bits", &Dtool_FrameBufferProperties_set_depth_bits_709, METH_O, (const char *)Dtool_FrameBufferProperties_set_depth_bits_709_comment},
  {"setDepthBits", &Dtool_FrameBufferProperties_set_depth_bits_709, METH_O, (const char *)Dtool_FrameBufferProperties_set_depth_bits_709_comment},
  {"set_color_bits", &Dtool_FrameBufferProperties_set_color_bits_710, METH_O, (const char *)Dtool_FrameBufferProperties_set_color_bits_710_comment},
  {"setColorBits", &Dtool_FrameBufferProperties_set_color_bits_710, METH_O, (const char *)Dtool_FrameBufferProperties_set_color_bits_710_comment},
  {"set_rgba_bits", (PyCFunction) &Dtool_FrameBufferProperties_set_rgba_bits_711, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FrameBufferProperties_set_rgba_bits_711_comment},
  {"setRgbaBits", (PyCFunction) &Dtool_FrameBufferProperties_set_rgba_bits_711, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FrameBufferProperties_set_rgba_bits_711_comment},
  {"set_red_bits", &Dtool_FrameBufferProperties_set_red_bits_712, METH_O, (const char *)Dtool_FrameBufferProperties_set_red_bits_712_comment},
  {"setRedBits", &Dtool_FrameBufferProperties_set_red_bits_712, METH_O, (const char *)Dtool_FrameBufferProperties_set_red_bits_712_comment},
  {"set_green_bits", &Dtool_FrameBufferProperties_set_green_bits_713, METH_O, (const char *)Dtool_FrameBufferProperties_set_green_bits_713_comment},
  {"setGreenBits", &Dtool_FrameBufferProperties_set_green_bits_713, METH_O, (const char *)Dtool_FrameBufferProperties_set_green_bits_713_comment},
  {"set_blue_bits", &Dtool_FrameBufferProperties_set_blue_bits_714, METH_O, (const char *)Dtool_FrameBufferProperties_set_blue_bits_714_comment},
  {"setBlueBits", &Dtool_FrameBufferProperties_set_blue_bits_714, METH_O, (const char *)Dtool_FrameBufferProperties_set_blue_bits_714_comment},
  {"set_alpha_bits", &Dtool_FrameBufferProperties_set_alpha_bits_715, METH_O, (const char *)Dtool_FrameBufferProperties_set_alpha_bits_715_comment},
  {"setAlphaBits", &Dtool_FrameBufferProperties_set_alpha_bits_715, METH_O, (const char *)Dtool_FrameBufferProperties_set_alpha_bits_715_comment},
  {"set_stencil_bits", &Dtool_FrameBufferProperties_set_stencil_bits_716, METH_O, (const char *)Dtool_FrameBufferProperties_set_stencil_bits_716_comment},
  {"setStencilBits", &Dtool_FrameBufferProperties_set_stencil_bits_716, METH_O, (const char *)Dtool_FrameBufferProperties_set_stencil_bits_716_comment},
  {"set_accum_bits", &Dtool_FrameBufferProperties_set_accum_bits_717, METH_O, (const char *)Dtool_FrameBufferProperties_set_accum_bits_717_comment},
  {"setAccumBits", &Dtool_FrameBufferProperties_set_accum_bits_717, METH_O, (const char *)Dtool_FrameBufferProperties_set_accum_bits_717_comment},
  {"set_aux_rgba", &Dtool_FrameBufferProperties_set_aux_rgba_718, METH_O, (const char *)Dtool_FrameBufferProperties_set_aux_rgba_718_comment},
  {"setAuxRgba", &Dtool_FrameBufferProperties_set_aux_rgba_718, METH_O, (const char *)Dtool_FrameBufferProperties_set_aux_rgba_718_comment},
  {"set_aux_hrgba", &Dtool_FrameBufferProperties_set_aux_hrgba_719, METH_O, (const char *)Dtool_FrameBufferProperties_set_aux_hrgba_719_comment},
  {"setAuxHrgba", &Dtool_FrameBufferProperties_set_aux_hrgba_719, METH_O, (const char *)Dtool_FrameBufferProperties_set_aux_hrgba_719_comment},
  {"set_aux_float", &Dtool_FrameBufferProperties_set_aux_float_720, METH_O, (const char *)Dtool_FrameBufferProperties_set_aux_float_720_comment},
  {"setAuxFloat", &Dtool_FrameBufferProperties_set_aux_float_720, METH_O, (const char *)Dtool_FrameBufferProperties_set_aux_float_720_comment},
  {"set_multisamples", &Dtool_FrameBufferProperties_set_multisamples_721, METH_O, (const char *)Dtool_FrameBufferProperties_set_multisamples_721_comment},
  {"setMultisamples", &Dtool_FrameBufferProperties_set_multisamples_721, METH_O, (const char *)Dtool_FrameBufferProperties_set_multisamples_721_comment},
  {"set_coverage_samples", &Dtool_FrameBufferProperties_set_coverage_samples_722, METH_O, (const char *)Dtool_FrameBufferProperties_set_coverage_samples_722_comment},
  {"setCoverageSamples", &Dtool_FrameBufferProperties_set_coverage_samples_722, METH_O, (const char *)Dtool_FrameBufferProperties_set_coverage_samples_722_comment},
  {"set_back_buffers", &Dtool_FrameBufferProperties_set_back_buffers_723, METH_O, (const char *)Dtool_FrameBufferProperties_set_back_buffers_723_comment},
  {"setBackBuffers", &Dtool_FrameBufferProperties_set_back_buffers_723, METH_O, (const char *)Dtool_FrameBufferProperties_set_back_buffers_723_comment},
  {"set_indexed_color", &Dtool_FrameBufferProperties_set_indexed_color_724, METH_O, (const char *)Dtool_FrameBufferProperties_set_indexed_color_724_comment},
  {"setIndexedColor", &Dtool_FrameBufferProperties_set_indexed_color_724, METH_O, (const char *)Dtool_FrameBufferProperties_set_indexed_color_724_comment},
  {"set_rgb_color", &Dtool_FrameBufferProperties_set_rgb_color_725, METH_O, (const char *)Dtool_FrameBufferProperties_set_rgb_color_725_comment},
  {"setRgbColor", &Dtool_FrameBufferProperties_set_rgb_color_725, METH_O, (const char *)Dtool_FrameBufferProperties_set_rgb_color_725_comment},
  {"set_stereo", &Dtool_FrameBufferProperties_set_stereo_726, METH_O, (const char *)Dtool_FrameBufferProperties_set_stereo_726_comment},
  {"setStereo", &Dtool_FrameBufferProperties_set_stereo_726, METH_O, (const char *)Dtool_FrameBufferProperties_set_stereo_726_comment},
  {"set_force_hardware", &Dtool_FrameBufferProperties_set_force_hardware_727, METH_O, (const char *)Dtool_FrameBufferProperties_set_force_hardware_727_comment},
  {"setForceHardware", &Dtool_FrameBufferProperties_set_force_hardware_727, METH_O, (const char *)Dtool_FrameBufferProperties_set_force_hardware_727_comment},
  {"set_force_software", &Dtool_FrameBufferProperties_set_force_software_728, METH_O, (const char *)Dtool_FrameBufferProperties_set_force_software_728_comment},
  {"setForceSoftware", &Dtool_FrameBufferProperties_set_force_software_728, METH_O, (const char *)Dtool_FrameBufferProperties_set_force_software_728_comment},
  {"set_srgb_color", &Dtool_FrameBufferProperties_set_srgb_color_729, METH_O, (const char *)Dtool_FrameBufferProperties_set_srgb_color_729_comment},
  {"setSrgbColor", &Dtool_FrameBufferProperties_set_srgb_color_729, METH_O, (const char *)Dtool_FrameBufferProperties_set_srgb_color_729_comment},
  {"set_float_color", &Dtool_FrameBufferProperties_set_float_color_730, METH_O, (const char *)Dtool_FrameBufferProperties_set_float_color_730_comment},
  {"setFloatColor", &Dtool_FrameBufferProperties_set_float_color_730, METH_O, (const char *)Dtool_FrameBufferProperties_set_float_color_730_comment},
  {"set_float_depth", &Dtool_FrameBufferProperties_set_float_depth_731, METH_O, (const char *)Dtool_FrameBufferProperties_set_float_depth_731_comment},
  {"setFloatDepth", &Dtool_FrameBufferProperties_set_float_depth_731, METH_O, (const char *)Dtool_FrameBufferProperties_set_float_depth_731_comment},
  {"get_default", &Dtool_FrameBufferProperties_get_default_755, METH_NOARGS | METH_STATIC, (const char *)Dtool_FrameBufferProperties_get_default_755_comment},
  {"getDefault", &Dtool_FrameBufferProperties_get_default_755, METH_NOARGS | METH_STATIC, (const char *)Dtool_FrameBufferProperties_get_default_755_comment},
  {"clear", &Dtool_FrameBufferProperties_clear_758, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_clear_758_comment},
  {"set_all_specified", &Dtool_FrameBufferProperties_set_all_specified_759, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_set_all_specified_759_comment},
  {"setAllSpecified", &Dtool_FrameBufferProperties_set_all_specified_759, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_set_all_specified_759_comment},
  {"subsumes", &Dtool_FrameBufferProperties_subsumes_760, METH_O, (const char *)Dtool_FrameBufferProperties_subsumes_760_comment},
  {"add_properties", &Dtool_FrameBufferProperties_add_properties_761, METH_O, (const char *)Dtool_FrameBufferProperties_add_properties_761_comment},
  {"addProperties", &Dtool_FrameBufferProperties_add_properties_761, METH_O, (const char *)Dtool_FrameBufferProperties_add_properties_761_comment},
  {"output", &Dtool_FrameBufferProperties_output_762, METH_O, (const char *)Dtool_FrameBufferProperties_output_762_comment},
  {"set_one_bit_per_channel", &Dtool_FrameBufferProperties_set_one_bit_per_channel_763, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_set_one_bit_per_channel_763_comment},
  {"setOneBitPerChannel", &Dtool_FrameBufferProperties_set_one_bit_per_channel_763, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_set_one_bit_per_channel_763_comment},
  {"is_stereo", &Dtool_FrameBufferProperties_is_stereo_764, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_is_stereo_764_comment},
  {"isStereo", &Dtool_FrameBufferProperties_is_stereo_764, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_is_stereo_764_comment},
  {"is_single_buffered", &Dtool_FrameBufferProperties_is_single_buffered_765, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_is_single_buffered_765_comment},
  {"isSingleBuffered", &Dtool_FrameBufferProperties_is_single_buffered_765, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_is_single_buffered_765_comment},
  {"get_quality", &Dtool_FrameBufferProperties_get_quality_766, METH_O, (const char *)Dtool_FrameBufferProperties_get_quality_766_comment},
  {"getQuality", &Dtool_FrameBufferProperties_get_quality_766, METH_O, (const char *)Dtool_FrameBufferProperties_get_quality_766_comment},
  {"is_any_specified", &Dtool_FrameBufferProperties_is_any_specified_767, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_is_any_specified_767_comment},
  {"isAnySpecified", &Dtool_FrameBufferProperties_is_any_specified_767, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_is_any_specified_767_comment},
  {"is_basic", &Dtool_FrameBufferProperties_is_basic_768, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_is_basic_768_comment},
  {"isBasic", &Dtool_FrameBufferProperties_is_basic_768, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_is_basic_768_comment},
  {"get_aux_mask", &Dtool_FrameBufferProperties_get_aux_mask_769, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_aux_mask_769_comment},
  {"getAuxMask", &Dtool_FrameBufferProperties_get_aux_mask_769, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_aux_mask_769_comment},
  {"get_buffer_mask", &Dtool_FrameBufferProperties_get_buffer_mask_770, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_buffer_mask_770_comment},
  {"getBufferMask", &Dtool_FrameBufferProperties_get_buffer_mask_770, METH_NOARGS, (const char *)Dtool_FrameBufferProperties_get_buffer_mask_770_comment},
  {"verify_hardware_software", (PyCFunction) &Dtool_FrameBufferProperties_verify_hardware_software_771, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FrameBufferProperties_verify_hardware_software_771_comment},
  {"verifyHardwareSoftware", (PyCFunction) &Dtool_FrameBufferProperties_verify_hardware_software_771, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_FrameBufferProperties_verify_hardware_software_771_comment},
  {"setup_color_texture", &Dtool_FrameBufferProperties_setup_color_texture_772, METH_O, (const char *)Dtool_FrameBufferProperties_setup_color_texture_772_comment},
  {"setupColorTexture", &Dtool_FrameBufferProperties_setup_color_texture_772, METH_O, (const char *)Dtool_FrameBufferProperties_setup_color_texture_772_comment},
  {"setup_depth_texture", &Dtool_FrameBufferProperties_setup_depth_texture_773, METH_O, (const char *)Dtool_FrameBufferProperties_setup_depth_texture_773_comment},
  {"setupDepthTexture", &Dtool_FrameBufferProperties_setup_depth_texture_773, METH_O, (const char *)Dtool_FrameBufferProperties_setup_depth_texture_773_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     FrameBufferProperties
//////////////////
static PyObject *Dtool_Repr_FrameBufferProperties(PyObject *self) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     FrameBufferProperties
//////////////////
static PyObject *Dtool_RichCompare_FrameBufferProperties(PyObject *self, PyObject *arg, int op) {
  FrameBufferProperties *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_FrameBufferProperties, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-bool FrameBufferProperties::operator ==(FrameBufferProperties const &other) const
      FrameBufferProperties const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_FrameBufferProperties);
      if (arg_this != nullptr) {
        bool return_value = ((*(const FrameBufferProperties*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool FrameBufferProperties::operator !=(FrameBufferProperties const &other) const
      FrameBufferProperties const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_FrameBufferProperties);
      if (arg_this != nullptr) {
        bool return_value = ((*(const FrameBufferProperties*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_FrameBufferProperties[] = {
  {(char *)"depth_bits", &Dtool_FrameBufferProperties_depth_bits_Getter, &Dtool_FrameBufferProperties_depth_bits_Setter, (char *)
    "// Individual queries.",
    nullptr},
  {(char *)"color_bits", &Dtool_FrameBufferProperties_color_bits_Getter, &Dtool_FrameBufferProperties_color_bits_Setter, nullptr, nullptr},
  {(char *)"red_bits", &Dtool_FrameBufferProperties_red_bits_Getter, &Dtool_FrameBufferProperties_red_bits_Setter, nullptr, nullptr},
  {(char *)"green_bits", &Dtool_FrameBufferProperties_green_bits_Getter, &Dtool_FrameBufferProperties_green_bits_Setter, nullptr, nullptr},
  {(char *)"blue_bits", &Dtool_FrameBufferProperties_blue_bits_Getter, &Dtool_FrameBufferProperties_blue_bits_Setter, nullptr, nullptr},
  {(char *)"alpha_bits", &Dtool_FrameBufferProperties_alpha_bits_Getter, &Dtool_FrameBufferProperties_alpha_bits_Setter, nullptr, nullptr},
  {(char *)"stencil_bits", &Dtool_FrameBufferProperties_stencil_bits_Getter, &Dtool_FrameBufferProperties_stencil_bits_Setter, nullptr, nullptr},
  {(char *)"accum_bits", &Dtool_FrameBufferProperties_accum_bits_Getter, &Dtool_FrameBufferProperties_accum_bits_Setter, nullptr, nullptr},
  {(char *)"aux_rgba", &Dtool_FrameBufferProperties_aux_rgba_Getter, &Dtool_FrameBufferProperties_aux_rgba_Setter, nullptr, nullptr},
  {(char *)"aux_hrgba", &Dtool_FrameBufferProperties_aux_hrgba_Getter, &Dtool_FrameBufferProperties_aux_hrgba_Setter, nullptr, nullptr},
  {(char *)"aux_float", &Dtool_FrameBufferProperties_aux_float_Getter, &Dtool_FrameBufferProperties_aux_float_Setter, nullptr, nullptr},
  {(char *)"multisamples", &Dtool_FrameBufferProperties_multisamples_Getter, &Dtool_FrameBufferProperties_multisamples_Setter, nullptr, nullptr},
  {(char *)"coverage_samples", &Dtool_FrameBufferProperties_coverage_samples_Getter, &Dtool_FrameBufferProperties_coverage_samples_Setter, nullptr, nullptr},
  {(char *)"back_buffers", &Dtool_FrameBufferProperties_back_buffers_Getter, &Dtool_FrameBufferProperties_back_buffers_Setter, nullptr, nullptr},
  {(char *)"indexed_color", &Dtool_FrameBufferProperties_indexed_color_Getter, &Dtool_FrameBufferProperties_indexed_color_Setter, nullptr, nullptr},
  {(char *)"rgb_color", &Dtool_FrameBufferProperties_rgb_color_Getter, &Dtool_FrameBufferProperties_rgb_color_Setter, nullptr, nullptr},
  {(char *)"stereo", &Dtool_FrameBufferProperties_stereo_Getter, &Dtool_FrameBufferProperties_stereo_Setter, nullptr, nullptr},
  {(char *)"force_hardware", &Dtool_FrameBufferProperties_force_hardware_Getter, &Dtool_FrameBufferProperties_force_hardware_Setter, nullptr, nullptr},
  {(char *)"force_software", &Dtool_FrameBufferProperties_force_software_Getter, &Dtool_FrameBufferProperties_force_software_Setter, nullptr, nullptr},
  {(char *)"srgb_color", &Dtool_FrameBufferProperties_srgb_color_Getter, &Dtool_FrameBufferProperties_srgb_color_Setter, nullptr, nullptr},
  {(char *)"float_color", &Dtool_FrameBufferProperties_float_color_Getter, &Dtool_FrameBufferProperties_float_color_Setter, nullptr, nullptr},
  {(char *)"float_depth", &Dtool_FrameBufferProperties_float_depth_Getter, &Dtool_FrameBufferProperties_float_depth_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_FrameBufferProperties = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_FrameBufferProperties = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.FrameBufferProperties",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_FrameBufferProperties,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    &Dtool_Repr_FrameBufferProperties,
    &Dtool_NumberMethods_FrameBufferProperties,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Repr_FrameBufferProperties,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A container for the various kinds of properties we might ask to have on a\n"
    " * graphics frameBuffer before we create a GSG.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_FrameBufferProperties,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_FrameBufferProperties,
    nullptr, // tp_members
    Dtool_Properties_FrameBufferProperties,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_FrameBufferProperties,
    PyType_GenericAlloc,
    Dtool_new_FrameBufferProperties,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FrameBufferProperties,
  Dtool_UpcastInterface_FrameBufferProperties,
  Dtool_DowncastInterface_FrameBufferProperties,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_FrameBufferProperties(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_FrameBufferProperties._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_FrameBufferProperties._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FrameBufferProperties) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FrameBufferProperties)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FrameBufferProperties);
  }
}

/**
 * Python method tables for GraphicsWindowInputDevice (GraphicsWindowInputDevice)
 */
static PyMethodDef Dtool_Methods_GraphicsWindowInputDevice[] = {
  {"button_down", (PyCFunction) &Dtool_GraphicsWindowInputDevice_button_down_777, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_button_down_777_comment},
  {"buttonDown", (PyCFunction) &Dtool_GraphicsWindowInputDevice_button_down_777, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_button_down_777_comment},
  {"button_resume_down", (PyCFunction) &Dtool_GraphicsWindowInputDevice_button_resume_down_778, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_button_resume_down_778_comment},
  {"buttonResumeDown", (PyCFunction) &Dtool_GraphicsWindowInputDevice_button_resume_down_778, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_button_resume_down_778_comment},
  {"button_up", (PyCFunction) &Dtool_GraphicsWindowInputDevice_button_up_779, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_button_up_779_comment},
  {"buttonUp", (PyCFunction) &Dtool_GraphicsWindowInputDevice_button_up_779, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_button_up_779_comment},
  {"keystroke", (PyCFunction) &Dtool_GraphicsWindowInputDevice_keystroke_780, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_keystroke_780_comment},
  {"candidate", (PyCFunction) &Dtool_GraphicsWindowInputDevice_candidate_781, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_candidate_781_comment},
  {"focus_lost", (PyCFunction) &Dtool_GraphicsWindowInputDevice_focus_lost_782, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_focus_lost_782_comment},
  {"focusLost", (PyCFunction) &Dtool_GraphicsWindowInputDevice_focus_lost_782, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_focus_lost_782_comment},
  {"raw_button_down", (PyCFunction) &Dtool_GraphicsWindowInputDevice_raw_button_down_783, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_raw_button_down_783_comment},
  {"rawButtonDown", (PyCFunction) &Dtool_GraphicsWindowInputDevice_raw_button_down_783, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_raw_button_down_783_comment},
  {"raw_button_up", (PyCFunction) &Dtool_GraphicsWindowInputDevice_raw_button_up_784, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_raw_button_up_784_comment},
  {"rawButtonUp", (PyCFunction) &Dtool_GraphicsWindowInputDevice_raw_button_up_784, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_raw_button_up_784_comment},
  {"get_pointer", &Dtool_GraphicsWindowInputDevice_get_pointer_785, METH_NOARGS, (const char *)Dtool_GraphicsWindowInputDevice_get_pointer_785_comment},
  {"getPointer", &Dtool_GraphicsWindowInputDevice_get_pointer_785, METH_NOARGS, (const char *)Dtool_GraphicsWindowInputDevice_get_pointer_785_comment},
  {"set_pointer_in_window", (PyCFunction) &Dtool_GraphicsWindowInputDevice_set_pointer_in_window_786, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_set_pointer_in_window_786_comment},
  {"setPointerInWindow", (PyCFunction) &Dtool_GraphicsWindowInputDevice_set_pointer_in_window_786, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_set_pointer_in_window_786_comment},
  {"set_pointer_out_of_window", (PyCFunction) &Dtool_GraphicsWindowInputDevice_set_pointer_out_of_window_787, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_set_pointer_out_of_window_787_comment},
  {"setPointerOutOfWindow", (PyCFunction) &Dtool_GraphicsWindowInputDevice_set_pointer_out_of_window_787, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_set_pointer_out_of_window_787_comment},
  {"update_pointer", (PyCFunction) &Dtool_GraphicsWindowInputDevice_update_pointer_788, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_update_pointer_788_comment},
  {"updatePointer", (PyCFunction) &Dtool_GraphicsWindowInputDevice_update_pointer_788, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_update_pointer_788_comment},
  {"pointer_moved", (PyCFunction) &Dtool_GraphicsWindowInputDevice_pointer_moved_789, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_pointer_moved_789_comment},
  {"pointerMoved", (PyCFunction) &Dtool_GraphicsWindowInputDevice_pointer_moved_789, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindowInputDevice_pointer_moved_789_comment},
  {"remove_pointer", &Dtool_GraphicsWindowInputDevice_remove_pointer_790, METH_O, (const char *)Dtool_GraphicsWindowInputDevice_remove_pointer_790_comment},
  {"removePointer", &Dtool_GraphicsWindowInputDevice_remove_pointer_790, METH_O, (const char *)Dtool_GraphicsWindowInputDevice_remove_pointer_790_comment},
  {"get_class_type", &Dtool_GraphicsWindowInputDevice_get_class_type_791, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsWindowInputDevice_get_class_type_791_comment},
  {"getClassType", &Dtool_GraphicsWindowInputDevice_get_class_type_791, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsWindowInputDevice_get_class_type_791_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GraphicsWindowInputDevice = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GraphicsWindowInputDevice = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GraphicsWindowInputDevice = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GraphicsWindowInputDevice = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GraphicsWindowInputDevice = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GraphicsWindowInputDevice = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GraphicsWindowInputDevice",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GraphicsWindowInputDevice,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GraphicsWindowInputDevice,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GraphicsWindowInputDevice,
    &Dtool_SequenceMethods_GraphicsWindowInputDevice,
    &Dtool_MappingMethods_GraphicsWindowInputDevice,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GraphicsWindowInputDevice,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a virtual input device that represents the keyboard and mouse pair\n"
    " * that is associated with a particular window.  It collects mouse and\n"
    " * keyboard events from the windowing system while the window is in focus.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GraphicsWindowInputDevice,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GraphicsWindowInputDevice,
    PyType_GenericAlloc,
    Dtool_new_GraphicsWindowInputDevice,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GraphicsWindowInputDevice,
  Dtool_UpcastInterface_GraphicsWindowInputDevice,
  Dtool_DowncastInterface_GraphicsWindowInputDevice,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GraphicsWindowInputDevice(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_InputDevice != nullptr);
    assert(Dtool_Ptr_InputDevice->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_InputDevice->_Dtool_ModuleClassInit(nullptr);
    Dtool_GraphicsWindowInputDevice._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_InputDevice);
    Dtool_GraphicsWindowInputDevice._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GraphicsWindowInputDevice._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GraphicsWindowInputDevice) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GraphicsWindowInputDevice)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GraphicsWindowInputDevice);
  }
}

/**
 * Python method tables for TouchInfo (TouchInfo)
 */
static PyMethodDef Dtool_Methods_TouchInfo[] = {
  {"get_x", &Dtool_TouchInfo_get_x_795, METH_NOARGS, (const char *)Dtool_TouchInfo_get_x_795_comment},
  {"getX", &Dtool_TouchInfo_get_x_795, METH_NOARGS, (const char *)Dtool_TouchInfo_get_x_795_comment},
  {"get_y", &Dtool_TouchInfo_get_y_796, METH_NOARGS, (const char *)Dtool_TouchInfo_get_y_796_comment},
  {"getY", &Dtool_TouchInfo_get_y_796, METH_NOARGS, (const char *)Dtool_TouchInfo_get_y_796_comment},
  {"get_id", &Dtool_TouchInfo_get_id_797, METH_NOARGS, (const char *)Dtool_TouchInfo_get_id_797_comment},
  {"getId", &Dtool_TouchInfo_get_id_797, METH_NOARGS, (const char *)Dtool_TouchInfo_get_id_797_comment},
  {"get_flags", &Dtool_TouchInfo_get_flags_798, METH_NOARGS, (const char *)Dtool_TouchInfo_get_flags_798_comment},
  {"getFlags", &Dtool_TouchInfo_get_flags_798, METH_NOARGS, (const char *)Dtool_TouchInfo_get_flags_798_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TouchInfo = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TouchInfo = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TouchInfo",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TouchInfo,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TouchInfo,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Stores information for a single touch event.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TouchInfo,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TouchInfo,
    PyType_GenericAlloc,
    Dtool_new_TouchInfo,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TouchInfo,
  Dtool_UpcastInterface_TouchInfo,
  Dtool_DowncastInterface_TouchInfo,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TouchInfo(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TouchInfo._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_TouchInfo._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum TouchInfo::TouchInfoFlags;
    PyDict_SetItemString(dict, "TIF_move", Dtool_WrapValue(TouchInfo::TIF_move));
    PyDict_SetItemString(dict, "TIFMove", Dtool_WrapValue(TouchInfo::TIF_move));
    PyDict_SetItemString(dict, "TIF_down", Dtool_WrapValue(TouchInfo::TIF_down));
    PyDict_SetItemString(dict, "TIFDown", Dtool_WrapValue(TouchInfo::TIF_down));
    PyDict_SetItemString(dict, "TIF_up", Dtool_WrapValue(TouchInfo::TIF_up));
    PyDict_SetItemString(dict, "TIFUp", Dtool_WrapValue(TouchInfo::TIF_up));
    if (PyType_Ready((PyTypeObject *)&Dtool_TouchInfo) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TouchInfo)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TouchInfo);
  }
}

/**
 * Python method tables for GraphicsWindowProcCallbackData (GraphicsWindowProcCallbackData)
 */
static PyMethodDef Dtool_Methods_GraphicsWindowProcCallbackData[] = {
  {"is_touch_event", &Dtool_GraphicsWindowProcCallbackData_is_touch_event_803, METH_NOARGS, (const char *)Dtool_GraphicsWindowProcCallbackData_is_touch_event_803_comment},
  {"isTouchEvent", &Dtool_GraphicsWindowProcCallbackData_is_touch_event_803, METH_NOARGS, (const char *)Dtool_GraphicsWindowProcCallbackData_is_touch_event_803_comment},
  {"get_num_touches", &Dtool_GraphicsWindowProcCallbackData_get_num_touches_804, METH_NOARGS, (const char *)Dtool_GraphicsWindowProcCallbackData_get_num_touches_804_comment},
  {"getNumTouches", &Dtool_GraphicsWindowProcCallbackData_get_num_touches_804, METH_NOARGS, (const char *)Dtool_GraphicsWindowProcCallbackData_get_num_touches_804_comment},
  {"get_touch_info", &Dtool_GraphicsWindowProcCallbackData_get_touch_info_805, METH_O, (const char *)Dtool_GraphicsWindowProcCallbackData_get_touch_info_805_comment},
  {"getTouchInfo", &Dtool_GraphicsWindowProcCallbackData_get_touch_info_805, METH_O, (const char *)Dtool_GraphicsWindowProcCallbackData_get_touch_info_805_comment},
  {"get_class_type", &Dtool_GraphicsWindowProcCallbackData_get_class_type_806, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsWindowProcCallbackData_get_class_type_806_comment},
  {"getClassType", &Dtool_GraphicsWindowProcCallbackData_get_class_type_806, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsWindowProcCallbackData_get_class_type_806_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GraphicsWindowProcCallbackData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GraphicsWindowProcCallbackData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GraphicsWindowProcCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GraphicsWindowProcCallbackData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GraphicsWindowProcCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GraphicsWindowProcCallbackData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GraphicsWindowProcCallbackData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GraphicsWindowProcCallbackData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GraphicsWindowProcCallbackData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GraphicsWindowProcCallbackData,
    &Dtool_SequenceMethods_GraphicsWindowProcCallbackData,
    &Dtool_MappingMethods_GraphicsWindowProcCallbackData,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GraphicsWindowProcCallbackData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This specialization on CallbackData is passed when the callback is\n"
    " * initiated from from an implementation of the GraphicsWindowProc class, such\n"
    " * as PythonGraphicsWindowProc.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GraphicsWindowProcCallbackData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GraphicsWindowProcCallbackData,
    PyType_GenericAlloc,
    Dtool_new_GraphicsWindowProcCallbackData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GraphicsWindowProcCallbackData,
  Dtool_UpcastInterface_GraphicsWindowProcCallbackData,
  Dtool_DowncastInterface_GraphicsWindowProcCallbackData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GraphicsWindowProcCallbackData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CallbackData != nullptr);
    assert(Dtool_Ptr_CallbackData->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_CallbackData->_Dtool_ModuleClassInit(nullptr);
    Dtool_GraphicsWindowProcCallbackData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_CallbackData);
    Dtool_GraphicsWindowProcCallbackData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GraphicsWindowProcCallbackData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GraphicsWindowProcCallbackData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GraphicsWindowProcCallbackData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GraphicsWindowProcCallbackData);
  }
}

/**
 * Python method tables for GraphicsWindow (GraphicsWindow)
 */
static PyMethodDef Dtool_Methods_GraphicsWindow[] = {
  {"get_properties", &Dtool_GraphicsWindow_get_properties_809, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_properties_809_comment},
  {"getProperties", &Dtool_GraphicsWindow_get_properties_809, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_properties_809_comment},
  {"get_requested_properties", &Dtool_GraphicsWindow_get_requested_properties_810, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_requested_properties_810_comment},
  {"getRequestedProperties", &Dtool_GraphicsWindow_get_requested_properties_810, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_requested_properties_810_comment},
  {"clear_rejected_properties", &Dtool_GraphicsWindow_clear_rejected_properties_811, METH_NOARGS, (const char *)Dtool_GraphicsWindow_clear_rejected_properties_811_comment},
  {"clearRejectedProperties", &Dtool_GraphicsWindow_clear_rejected_properties_811, METH_NOARGS, (const char *)Dtool_GraphicsWindow_clear_rejected_properties_811_comment},
  {"get_rejected_properties", &Dtool_GraphicsWindow_get_rejected_properties_812, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_rejected_properties_812_comment},
  {"getRejectedProperties", &Dtool_GraphicsWindow_get_rejected_properties_812, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_rejected_properties_812_comment},
  {"request_properties", &Dtool_GraphicsWindow_request_properties_813, METH_O, (const char *)Dtool_GraphicsWindow_request_properties_813_comment},
  {"requestProperties", &Dtool_GraphicsWindow_request_properties_813, METH_O, (const char *)Dtool_GraphicsWindow_request_properties_813_comment},
  {"is_closed", &Dtool_GraphicsWindow_is_closed_814, METH_NOARGS, (const char *)Dtool_GraphicsWindow_is_closed_814_comment},
  {"isClosed", &Dtool_GraphicsWindow_is_closed_814, METH_NOARGS, (const char *)Dtool_GraphicsWindow_is_closed_814_comment},
  {"is_fullscreen", &Dtool_GraphicsWindow_is_fullscreen_815, METH_NOARGS, (const char *)Dtool_GraphicsWindow_is_fullscreen_815_comment},
  {"isFullscreen", &Dtool_GraphicsWindow_is_fullscreen_815, METH_NOARGS, (const char *)Dtool_GraphicsWindow_is_fullscreen_815_comment},
  {"set_window_event", &Dtool_GraphicsWindow_set_window_event_820, METH_O, (const char *)Dtool_GraphicsWindow_set_window_event_820_comment},
  {"setWindowEvent", &Dtool_GraphicsWindow_set_window_event_820, METH_O, (const char *)Dtool_GraphicsWindow_set_window_event_820_comment},
  {"get_window_event", &Dtool_GraphicsWindow_get_window_event_821, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_window_event_821_comment},
  {"getWindowEvent", &Dtool_GraphicsWindow_get_window_event_821, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_window_event_821_comment},
  {"set_close_request_event", &Dtool_GraphicsWindow_set_close_request_event_823, METH_O, (const char *)Dtool_GraphicsWindow_set_close_request_event_823_comment},
  {"setCloseRequestEvent", &Dtool_GraphicsWindow_set_close_request_event_823, METH_O, (const char *)Dtool_GraphicsWindow_set_close_request_event_823_comment},
  {"get_close_request_event", &Dtool_GraphicsWindow_get_close_request_event_824, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_close_request_event_824_comment},
  {"getCloseRequestEvent", &Dtool_GraphicsWindow_get_close_request_event_824, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_close_request_event_824_comment},
  {"set_unexposed_draw", &Dtool_GraphicsWindow_set_unexposed_draw_826, METH_O, (const char *)Dtool_GraphicsWindow_set_unexposed_draw_826_comment},
  {"setUnexposedDraw", &Dtool_GraphicsWindow_set_unexposed_draw_826, METH_O, (const char *)Dtool_GraphicsWindow_set_unexposed_draw_826_comment},
  {"get_unexposed_draw", &Dtool_GraphicsWindow_get_unexposed_draw_827, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_unexposed_draw_827_comment},
  {"getUnexposedDraw", &Dtool_GraphicsWindow_get_unexposed_draw_827, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_unexposed_draw_827_comment},
  {"get_window_handle", &Dtool_GraphicsWindow_get_window_handle_829, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_window_handle_829_comment},
  {"getWindowHandle", &Dtool_GraphicsWindow_get_window_handle_829, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_window_handle_829_comment},
  {"get_num_input_devices", &Dtool_GraphicsWindow_get_num_input_devices_831, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_num_input_devices_831_comment},
  {"getNumInputDevices", &Dtool_GraphicsWindow_get_num_input_devices_831, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_num_input_devices_831_comment},
  {"get_input_device", &Dtool_GraphicsWindow_get_input_device_832, METH_O, (const char *)Dtool_GraphicsWindow_get_input_device_832_comment},
  {"getInputDevice", &Dtool_GraphicsWindow_get_input_device_832, METH_O, (const char *)Dtool_GraphicsWindow_get_input_device_832_comment},
  {"get_input_device_name", &Dtool_GraphicsWindow_get_input_device_name_833, METH_O, (const char *)Dtool_GraphicsWindow_get_input_device_name_833_comment},
  {"getInputDeviceName", &Dtool_GraphicsWindow_get_input_device_name_833, METH_O, (const char *)Dtool_GraphicsWindow_get_input_device_name_833_comment},
  {"has_pointer", &Dtool_GraphicsWindow_has_pointer_836, METH_O, (const char *)Dtool_GraphicsWindow_has_pointer_836_comment},
  {"hasPointer", &Dtool_GraphicsWindow_has_pointer_836, METH_O, (const char *)Dtool_GraphicsWindow_has_pointer_836_comment},
  {"has_keyboard", &Dtool_GraphicsWindow_has_keyboard_837, METH_O, (const char *)Dtool_GraphicsWindow_has_keyboard_837_comment},
  {"hasKeyboard", &Dtool_GraphicsWindow_has_keyboard_837, METH_O, (const char *)Dtool_GraphicsWindow_has_keyboard_837_comment},
  {"get_keyboard_map", &Dtool_GraphicsWindow_get_keyboard_map_838, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_keyboard_map_838_comment},
  {"getKeyboardMap", &Dtool_GraphicsWindow_get_keyboard_map_838, METH_NOARGS, (const char *)Dtool_GraphicsWindow_get_keyboard_map_838_comment},
  {"enable_pointer_events", &Dtool_GraphicsWindow_enable_pointer_events_839, METH_O, (const char *)Dtool_GraphicsWindow_enable_pointer_events_839_comment},
  {"enablePointerEvents", &Dtool_GraphicsWindow_enable_pointer_events_839, METH_O, (const char *)Dtool_GraphicsWindow_enable_pointer_events_839_comment},
  {"disable_pointer_events", &Dtool_GraphicsWindow_disable_pointer_events_840, METH_O, (const char *)Dtool_GraphicsWindow_disable_pointer_events_840_comment},
  {"disablePointerEvents", &Dtool_GraphicsWindow_disable_pointer_events_840, METH_O, (const char *)Dtool_GraphicsWindow_disable_pointer_events_840_comment},
  {"get_pointer", &Dtool_GraphicsWindow_get_pointer_841, METH_O, (const char *)Dtool_GraphicsWindow_get_pointer_841_comment},
  {"getPointer", &Dtool_GraphicsWindow_get_pointer_841, METH_O, (const char *)Dtool_GraphicsWindow_get_pointer_841_comment},
  {"move_pointer", (PyCFunction) &Dtool_GraphicsWindow_move_pointer_842, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindow_move_pointer_842_comment},
  {"movePointer", (PyCFunction) &Dtool_GraphicsWindow_move_pointer_842, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsWindow_move_pointer_842_comment},
  {"close_ime", &Dtool_GraphicsWindow_close_ime_843, METH_NOARGS, (const char *)Dtool_GraphicsWindow_close_ime_843_comment},
  {"closeIme", &Dtool_GraphicsWindow_close_ime_843, METH_NOARGS, (const char *)Dtool_GraphicsWindow_close_ime_843_comment},
  {"get_class_type", &Dtool_GraphicsWindow_get_class_type_844, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsWindow_get_class_type_844_comment},
  {"getClassType", &Dtool_GraphicsWindow_get_class_type_844, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsWindow_get_class_type_844_comment},
  {"get_input_devices", (PyCFunction) &MakeSeq_GraphicsWindow_get_input_devices, METH_NOARGS, nullptr},
  { "getInputDevices", (PyCFunction) &MakeSeq_GraphicsWindow_get_input_devices, METH_NOARGS, nullptr},
  {"get_input_device_names", (PyCFunction) &MakeSeq_GraphicsWindow_get_input_device_names, METH_NOARGS, nullptr},
  { "getInputDeviceNames", (PyCFunction) &MakeSeq_GraphicsWindow_get_input_device_names, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_GraphicsWindow[] = {
  {(char *)"properties", &Dtool_GraphicsWindow_properties_Getter, nullptr, nullptr, nullptr},
  {(char *)"requested_properties", &Dtool_GraphicsWindow_requested_properties_Getter, nullptr, nullptr, nullptr},
  {(char *)"rejected_properties", &Dtool_GraphicsWindow_rejected_properties_Getter, nullptr, nullptr, nullptr},
  {(char *)"closed", &Dtool_GraphicsWindow_closed_Getter, nullptr, nullptr, nullptr},
  {(char *)"window_event", &Dtool_GraphicsWindow_window_event_Getter, &Dtool_GraphicsWindow_window_event_Setter, nullptr, nullptr},
  {(char *)"close_request_event", &Dtool_GraphicsWindow_close_request_event_Getter, &Dtool_GraphicsWindow_close_request_event_Setter, nullptr, nullptr},
  {(char *)"unexposed_draw", &Dtool_GraphicsWindow_unexposed_draw_Getter, &Dtool_GraphicsWindow_unexposed_draw_Setter, nullptr, nullptr},
  {(char *)"window_handle", &Dtool_GraphicsWindow_window_handle_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_GraphicsWindow = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GraphicsWindow = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GraphicsWindow = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GraphicsWindow = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GraphicsWindow = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GraphicsWindow = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GraphicsWindow",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GraphicsWindow,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GraphicsWindow,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GraphicsWindow,
    &Dtool_SequenceMethods_GraphicsWindow,
    &Dtool_MappingMethods_GraphicsWindow,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GraphicsWindow,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A window, fullscreen or on a desktop, into which a graphics device sends\n"
    " * its output for interactive display.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GraphicsWindow,
    nullptr, // tp_members
    Dtool_Properties_GraphicsWindow,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GraphicsWindow,
    PyType_GenericAlloc,
    Dtool_new_GraphicsWindow,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GraphicsWindow,
  Dtool_UpcastInterface_GraphicsWindow,
  Dtool_DowncastInterface_GraphicsWindow,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GraphicsWindow(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GraphicsOutput(nullptr);
    Dtool_GraphicsWindow._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GraphicsOutput);
    Dtool_GraphicsWindow._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GraphicsWindow._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GraphicsWindow) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GraphicsWindow)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GraphicsWindow);
  }
}

/**
 * Python method tables for CallbackGraphicsWindow_WindowCallbackData (WindowCallbackData)
 */
static PyMethodDef Dtool_Methods_CallbackGraphicsWindow_WindowCallbackData[] = {
  {"get_window", &Dtool_CallbackGraphicsWindow_WindowCallbackData_get_window_847, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_WindowCallbackData_get_window_847_comment},
  {"getWindow", &Dtool_CallbackGraphicsWindow_WindowCallbackData_get_window_847, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_WindowCallbackData_get_window_847_comment},
  {"get_class_type", &Dtool_CallbackGraphicsWindow_WindowCallbackData_get_class_type_850, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackGraphicsWindow_WindowCallbackData_get_class_type_850_comment},
  {"getClassType", &Dtool_CallbackGraphicsWindow_WindowCallbackData_get_class_type_850, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackGraphicsWindow_WindowCallbackData_get_class_type_850_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CallbackGraphicsWindow_WindowCallbackData[] = {
  {(char *)"window", &Dtool_CallbackGraphicsWindow_WindowCallbackData_window_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CallbackGraphicsWindow_WindowCallbackData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CallbackGraphicsWindow_WindowCallbackData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CallbackGraphicsWindow_WindowCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CallbackGraphicsWindow_WindowCallbackData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CallbackGraphicsWindow_WindowCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CallbackGraphicsWindow_WindowCallbackData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.WindowCallbackData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CallbackGraphicsWindow_WindowCallbackData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CallbackGraphicsWindow_WindowCallbackData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CallbackGraphicsWindow_WindowCallbackData,
    &Dtool_SequenceMethods_CallbackGraphicsWindow_WindowCallbackData,
    &Dtool_MappingMethods_CallbackGraphicsWindow_WindowCallbackData,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CallbackGraphicsWindow_WindowCallbackData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CallbackGraphicsWindow_WindowCallbackData,
    nullptr, // tp_members
    Dtool_Properties_CallbackGraphicsWindow_WindowCallbackData,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CallbackGraphicsWindow_WindowCallbackData,
    PyType_GenericAlloc,
    Dtool_new_CallbackGraphicsWindow_WindowCallbackData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CallbackGraphicsWindow_WindowCallbackData,
  Dtool_UpcastInterface_CallbackGraphicsWindow_WindowCallbackData,
  Dtool_DowncastInterface_CallbackGraphicsWindow_WindowCallbackData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CallbackGraphicsWindow_WindowCallbackData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CallbackData != nullptr);
    assert(Dtool_Ptr_CallbackData->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_CallbackData->_Dtool_ModuleClassInit(nullptr);
    Dtool_CallbackGraphicsWindow_WindowCallbackData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_CallbackData);
    Dtool_CallbackGraphicsWindow_WindowCallbackData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CallbackGraphicsWindow_WindowCallbackData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CallbackGraphicsWindow_WindowCallbackData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CallbackGraphicsWindow_WindowCallbackData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CallbackGraphicsWindow_WindowCallbackData);
  }
}

/**
 * Python method tables for CallbackGraphicsWindow_EventsCallbackData (EventsCallbackData)
 */
static PyMethodDef Dtool_Methods_CallbackGraphicsWindow_EventsCallbackData[] = {
  {"get_class_type", &Dtool_CallbackGraphicsWindow_EventsCallbackData_get_class_type_853, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackGraphicsWindow_EventsCallbackData_get_class_type_853_comment},
  {"getClassType", &Dtool_CallbackGraphicsWindow_EventsCallbackData_get_class_type_853, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackGraphicsWindow_EventsCallbackData_get_class_type_853_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CallbackGraphicsWindow_EventsCallbackData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CallbackGraphicsWindow_EventsCallbackData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CallbackGraphicsWindow_EventsCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CallbackGraphicsWindow_EventsCallbackData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CallbackGraphicsWindow_EventsCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CallbackGraphicsWindow_EventsCallbackData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.EventsCallbackData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CallbackGraphicsWindow_EventsCallbackData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CallbackGraphicsWindow_EventsCallbackData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CallbackGraphicsWindow_EventsCallbackData,
    &Dtool_SequenceMethods_CallbackGraphicsWindow_EventsCallbackData,
    &Dtool_MappingMethods_CallbackGraphicsWindow_EventsCallbackData,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CallbackGraphicsWindow_EventsCallbackData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CallbackGraphicsWindow_EventsCallbackData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CallbackGraphicsWindow_EventsCallbackData,
    PyType_GenericAlloc,
    Dtool_new_CallbackGraphicsWindow_EventsCallbackData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CallbackGraphicsWindow_EventsCallbackData,
  Dtool_UpcastInterface_CallbackGraphicsWindow_EventsCallbackData,
  Dtool_DowncastInterface_CallbackGraphicsWindow_EventsCallbackData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CallbackGraphicsWindow_EventsCallbackData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CallbackGraphicsWindow_WindowCallbackData(nullptr);
    Dtool_CallbackGraphicsWindow_EventsCallbackData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CallbackGraphicsWindow_WindowCallbackData);
    Dtool_CallbackGraphicsWindow_EventsCallbackData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CallbackGraphicsWindow_EventsCallbackData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CallbackGraphicsWindow_EventsCallbackData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CallbackGraphicsWindow_EventsCallbackData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CallbackGraphicsWindow_EventsCallbackData);
  }
}

/**
 * Python method tables for CallbackGraphicsWindow_PropertiesCallbackData (PropertiesCallbackData)
 */
static PyMethodDef Dtool_Methods_CallbackGraphicsWindow_PropertiesCallbackData[] = {
  {"get_properties", &Dtool_CallbackGraphicsWindow_PropertiesCallbackData_get_properties_856, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_PropertiesCallbackData_get_properties_856_comment},
  {"getProperties", &Dtool_CallbackGraphicsWindow_PropertiesCallbackData_get_properties_856, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_PropertiesCallbackData_get_properties_856_comment},
  {"get_class_type", &Dtool_CallbackGraphicsWindow_PropertiesCallbackData_get_class_type_857, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackGraphicsWindow_PropertiesCallbackData_get_class_type_857_comment},
  {"getClassType", &Dtool_CallbackGraphicsWindow_PropertiesCallbackData_get_class_type_857, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackGraphicsWindow_PropertiesCallbackData_get_class_type_857_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CallbackGraphicsWindow_PropertiesCallbackData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CallbackGraphicsWindow_PropertiesCallbackData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CallbackGraphicsWindow_PropertiesCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CallbackGraphicsWindow_PropertiesCallbackData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CallbackGraphicsWindow_PropertiesCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CallbackGraphicsWindow_PropertiesCallbackData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PropertiesCallbackData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CallbackGraphicsWindow_PropertiesCallbackData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CallbackGraphicsWindow_PropertiesCallbackData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CallbackGraphicsWindow_PropertiesCallbackData,
    &Dtool_SequenceMethods_CallbackGraphicsWindow_PropertiesCallbackData,
    &Dtool_MappingMethods_CallbackGraphicsWindow_PropertiesCallbackData,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CallbackGraphicsWindow_PropertiesCallbackData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CallbackGraphicsWindow_PropertiesCallbackData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CallbackGraphicsWindow_PropertiesCallbackData,
    PyType_GenericAlloc,
    Dtool_new_CallbackGraphicsWindow_PropertiesCallbackData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CallbackGraphicsWindow_PropertiesCallbackData,
  Dtool_UpcastInterface_CallbackGraphicsWindow_PropertiesCallbackData,
  Dtool_DowncastInterface_CallbackGraphicsWindow_PropertiesCallbackData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CallbackGraphicsWindow_PropertiesCallbackData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CallbackGraphicsWindow_WindowCallbackData(nullptr);
    Dtool_CallbackGraphicsWindow_PropertiesCallbackData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CallbackGraphicsWindow_WindowCallbackData);
    Dtool_CallbackGraphicsWindow_PropertiesCallbackData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CallbackGraphicsWindow_PropertiesCallbackData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CallbackGraphicsWindow_PropertiesCallbackData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CallbackGraphicsWindow_PropertiesCallbackData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CallbackGraphicsWindow_PropertiesCallbackData);
  }
}

/**
 * Python method tables for CallbackGraphicsWindow_RenderCallbackData (RenderCallbackData)
 */
static PyMethodDef Dtool_Methods_CallbackGraphicsWindow_RenderCallbackData[] = {
  {"get_callback_type", &Dtool_CallbackGraphicsWindow_RenderCallbackData_get_callback_type_860, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_RenderCallbackData_get_callback_type_860_comment},
  {"getCallbackType", &Dtool_CallbackGraphicsWindow_RenderCallbackData_get_callback_type_860, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_RenderCallbackData_get_callback_type_860_comment},
  {"get_frame_mode", &Dtool_CallbackGraphicsWindow_RenderCallbackData_get_frame_mode_861, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_RenderCallbackData_get_frame_mode_861_comment},
  {"getFrameMode", &Dtool_CallbackGraphicsWindow_RenderCallbackData_get_frame_mode_861, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_RenderCallbackData_get_frame_mode_861_comment},
  {"set_render_flag", &Dtool_CallbackGraphicsWindow_RenderCallbackData_set_render_flag_864, METH_O, (const char *)Dtool_CallbackGraphicsWindow_RenderCallbackData_set_render_flag_864_comment},
  {"setRenderFlag", &Dtool_CallbackGraphicsWindow_RenderCallbackData_set_render_flag_864, METH_O, (const char *)Dtool_CallbackGraphicsWindow_RenderCallbackData_set_render_flag_864_comment},
  {"get_render_flag", &Dtool_CallbackGraphicsWindow_RenderCallbackData_get_render_flag_865, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_RenderCallbackData_get_render_flag_865_comment},
  {"getRenderFlag", &Dtool_CallbackGraphicsWindow_RenderCallbackData_get_render_flag_865, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_RenderCallbackData_get_render_flag_865_comment},
  {"get_class_type", &Dtool_CallbackGraphicsWindow_RenderCallbackData_get_class_type_867, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackGraphicsWindow_RenderCallbackData_get_class_type_867_comment},
  {"getClassType", &Dtool_CallbackGraphicsWindow_RenderCallbackData_get_class_type_867, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackGraphicsWindow_RenderCallbackData_get_class_type_867_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CallbackGraphicsWindow_RenderCallbackData[] = {
  {(char *)"callback_type", &Dtool_CallbackGraphicsWindow_RenderCallbackData_callback_type_Getter, nullptr, nullptr, nullptr},
  {(char *)"frame_mode", &Dtool_CallbackGraphicsWindow_RenderCallbackData_frame_mode_Getter, nullptr, nullptr, nullptr},
  {(char *)"render_flag", &Dtool_CallbackGraphicsWindow_RenderCallbackData_render_flag_Getter, &Dtool_CallbackGraphicsWindow_RenderCallbackData_render_flag_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CallbackGraphicsWindow_RenderCallbackData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CallbackGraphicsWindow_RenderCallbackData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CallbackGraphicsWindow_RenderCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CallbackGraphicsWindow_RenderCallbackData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CallbackGraphicsWindow_RenderCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CallbackGraphicsWindow_RenderCallbackData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.RenderCallbackData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CallbackGraphicsWindow_RenderCallbackData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CallbackGraphicsWindow_RenderCallbackData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CallbackGraphicsWindow_RenderCallbackData,
    &Dtool_SequenceMethods_CallbackGraphicsWindow_RenderCallbackData,
    &Dtool_MappingMethods_CallbackGraphicsWindow_RenderCallbackData,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CallbackGraphicsWindow_RenderCallbackData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CallbackGraphicsWindow_RenderCallbackData,
    nullptr, // tp_members
    Dtool_Properties_CallbackGraphicsWindow_RenderCallbackData,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CallbackGraphicsWindow_RenderCallbackData,
    PyType_GenericAlloc,
    Dtool_new_CallbackGraphicsWindow_RenderCallbackData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CallbackGraphicsWindow_RenderCallbackData,
  Dtool_UpcastInterface_CallbackGraphicsWindow_RenderCallbackData,
  Dtool_DowncastInterface_CallbackGraphicsWindow_RenderCallbackData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CallbackGraphicsWindow_RenderCallbackData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CallbackGraphicsWindow_WindowCallbackData(nullptr);
    Dtool_CallbackGraphicsWindow_RenderCallbackData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CallbackGraphicsWindow_WindowCallbackData);
    Dtool_CallbackGraphicsWindow_RenderCallbackData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CallbackGraphicsWindow_RenderCallbackData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CallbackGraphicsWindow_RenderCallbackData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CallbackGraphicsWindow_RenderCallbackData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CallbackGraphicsWindow_RenderCallbackData);
  }
}

/**
 * Python method tables for CallbackGraphicsWindow (CallbackGraphicsWindow)
 */
static PyMethodDef Dtool_Methods_CallbackGraphicsWindow[] = {
  {"set_events_callback", &Dtool_CallbackGraphicsWindow_set_events_callback_869, METH_O, (const char *)Dtool_CallbackGraphicsWindow_set_events_callback_869_comment},
  {"setEventsCallback", &Dtool_CallbackGraphicsWindow_set_events_callback_869, METH_O, (const char *)Dtool_CallbackGraphicsWindow_set_events_callback_869_comment},
  {"clear_events_callback", &Dtool_CallbackGraphicsWindow_clear_events_callback_870, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_clear_events_callback_870_comment},
  {"clearEventsCallback", &Dtool_CallbackGraphicsWindow_clear_events_callback_870, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_clear_events_callback_870_comment},
  {"get_events_callback", &Dtool_CallbackGraphicsWindow_get_events_callback_871, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_get_events_callback_871_comment},
  {"getEventsCallback", &Dtool_CallbackGraphicsWindow_get_events_callback_871, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_get_events_callback_871_comment},
  {"set_properties_callback", &Dtool_CallbackGraphicsWindow_set_properties_callback_872, METH_O, (const char *)Dtool_CallbackGraphicsWindow_set_properties_callback_872_comment},
  {"setPropertiesCallback", &Dtool_CallbackGraphicsWindow_set_properties_callback_872, METH_O, (const char *)Dtool_CallbackGraphicsWindow_set_properties_callback_872_comment},
  {"clear_properties_callback", &Dtool_CallbackGraphicsWindow_clear_properties_callback_873, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_clear_properties_callback_873_comment},
  {"clearPropertiesCallback", &Dtool_CallbackGraphicsWindow_clear_properties_callback_873, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_clear_properties_callback_873_comment},
  {"get_properties_callback", &Dtool_CallbackGraphicsWindow_get_properties_callback_874, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_get_properties_callback_874_comment},
  {"getPropertiesCallback", &Dtool_CallbackGraphicsWindow_get_properties_callback_874, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_get_properties_callback_874_comment},
  {"set_render_callback", &Dtool_CallbackGraphicsWindow_set_render_callback_875, METH_O, (const char *)Dtool_CallbackGraphicsWindow_set_render_callback_875_comment},
  {"setRenderCallback", &Dtool_CallbackGraphicsWindow_set_render_callback_875, METH_O, (const char *)Dtool_CallbackGraphicsWindow_set_render_callback_875_comment},
  {"clear_render_callback", &Dtool_CallbackGraphicsWindow_clear_render_callback_876, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_clear_render_callback_876_comment},
  {"clearRenderCallback", &Dtool_CallbackGraphicsWindow_clear_render_callback_876, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_clear_render_callback_876_comment},
  {"get_render_callback", &Dtool_CallbackGraphicsWindow_get_render_callback_877, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_get_render_callback_877_comment},
  {"getRenderCallback", &Dtool_CallbackGraphicsWindow_get_render_callback_877, METH_NOARGS, (const char *)Dtool_CallbackGraphicsWindow_get_render_callback_877_comment},
  {"create_input_device", &Dtool_CallbackGraphicsWindow_create_input_device_878, METH_O, (const char *)Dtool_CallbackGraphicsWindow_create_input_device_878_comment},
  {"createInputDevice", &Dtool_CallbackGraphicsWindow_create_input_device_878, METH_O, (const char *)Dtool_CallbackGraphicsWindow_create_input_device_878_comment},
  {"get_class_type", &Dtool_CallbackGraphicsWindow_get_class_type_879, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackGraphicsWindow_get_class_type_879_comment},
  {"getClassType", &Dtool_CallbackGraphicsWindow_get_class_type_879, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackGraphicsWindow_get_class_type_879_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CallbackGraphicsWindow = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CallbackGraphicsWindow = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CallbackGraphicsWindow = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CallbackGraphicsWindow = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CallbackGraphicsWindow = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CallbackGraphicsWindow = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CallbackGraphicsWindow",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CallbackGraphicsWindow,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CallbackGraphicsWindow,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CallbackGraphicsWindow,
    &Dtool_SequenceMethods_CallbackGraphicsWindow,
    &Dtool_MappingMethods_CallbackGraphicsWindow,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CallbackGraphicsWindow,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This special window object doesn't represent a window in its own right, but\n"
    " * instead hooks into some third-party API for creating and rendering to\n"
    " * windows via callbacks.  This can be used to allow Panda to render into an\n"
    " * already-created OpenGL context, for instance.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CallbackGraphicsWindow,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CallbackGraphicsWindow,
    PyType_GenericAlloc,
    Dtool_new_CallbackGraphicsWindow,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CallbackGraphicsWindow,
  Dtool_UpcastInterface_CallbackGraphicsWindow,
  Dtool_DowncastInterface_CallbackGraphicsWindow,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CallbackGraphicsWindow(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GraphicsWindow(nullptr);
    Dtool_CallbackGraphicsWindow._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GraphicsWindow);
    Dtool_CallbackGraphicsWindow._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(17);
    Dtool_CallbackGraphicsWindow._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // Nested Object   CallbackGraphicsWindow_WindowCallbackData;
    Dtool_PyModuleClassInit_CallbackGraphicsWindow_WindowCallbackData(nullptr);
    PyDict_SetItemString(dict, "WindowCallbackData", (PyObject *)&Dtool_CallbackGraphicsWindow_WindowCallbackData);
    // Nested Object   CallbackGraphicsWindow_EventsCallbackData;
    Dtool_PyModuleClassInit_CallbackGraphicsWindow_EventsCallbackData(nullptr);
    PyDict_SetItemString(dict, "EventsCallbackData", (PyObject *)&Dtool_CallbackGraphicsWindow_EventsCallbackData);
    // Nested Object   CallbackGraphicsWindow_PropertiesCallbackData;
    Dtool_PyModuleClassInit_CallbackGraphicsWindow_PropertiesCallbackData(nullptr);
    PyDict_SetItemString(dict, "PropertiesCallbackData", (PyObject *)&Dtool_CallbackGraphicsWindow_PropertiesCallbackData);
    // enum CallbackGraphicsWindow::RenderCallbackType;
    PyDict_SetItemString(dict, "RCT_begin_frame", Dtool_WrapValue(CallbackGraphicsWindow::RCT_begin_frame));
    PyDict_SetItemString(dict, "RCTBeginFrame", Dtool_WrapValue(CallbackGraphicsWindow::RCT_begin_frame));
    PyDict_SetItemString(dict, "RCT_end_frame", Dtool_WrapValue(CallbackGraphicsWindow::RCT_end_frame));
    PyDict_SetItemString(dict, "RCTEndFrame", Dtool_WrapValue(CallbackGraphicsWindow::RCT_end_frame));
    PyDict_SetItemString(dict, "RCT_begin_flip", Dtool_WrapValue(CallbackGraphicsWindow::RCT_begin_flip));
    PyDict_SetItemString(dict, "RCTBeginFlip", Dtool_WrapValue(CallbackGraphicsWindow::RCT_begin_flip));
    PyDict_SetItemString(dict, "RCT_end_flip", Dtool_WrapValue(CallbackGraphicsWindow::RCT_end_flip));
    PyDict_SetItemString(dict, "RCTEndFlip", Dtool_WrapValue(CallbackGraphicsWindow::RCT_end_flip));
    // Nested Object   CallbackGraphicsWindow_RenderCallbackData;
    Dtool_PyModuleClassInit_CallbackGraphicsWindow_RenderCallbackData(nullptr);
    PyDict_SetItemString(dict, "RenderCallbackData", (PyObject *)&Dtool_CallbackGraphicsWindow_RenderCallbackData);
    if (PyType_Ready((PyTypeObject *)&Dtool_CallbackGraphicsWindow) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CallbackGraphicsWindow)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CallbackGraphicsWindow);
  }
}

/**
 * Python method tables for DisplayMode (DisplayMode)
 */
static PyMethodDef Dtool_Methods_DisplayMode[] = {
  {"output", &Dtool_DisplayMode_output_898, METH_O, (const char *)Dtool_DisplayMode_output_898_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     DisplayMode
//////////////////
static PyObject *Dtool_Repr_DisplayMode(PyObject *self) {
  DisplayMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayMode, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     DisplayMode
//////////////////
static PyObject *Dtool_RichCompare_DisplayMode(PyObject *self, PyObject *arg, int op) {
  DisplayMode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DisplayMode, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-bool DisplayMode::operator ==(DisplayMode const &other) const
      DisplayMode const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_DisplayMode);
      if (arg_this != nullptr) {
        bool return_value = ((*(const DisplayMode*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-bool DisplayMode::operator !=(DisplayMode const &other) const
      DisplayMode const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_DisplayMode);
      if (arg_this != nullptr) {
        bool return_value = ((*(const DisplayMode*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_DisplayMode[] = {
  {(char *)"width", &Dtool_DisplayMode_width_Getter, &Dtool_DisplayMode_width_Setter, nullptr, nullptr},
  {(char *)"height", &Dtool_DisplayMode_height_Getter, &Dtool_DisplayMode_height_Setter, nullptr, nullptr},
  {(char *)"bits_per_pixel", &Dtool_DisplayMode_bits_per_pixel_Getter, &Dtool_DisplayMode_bits_per_pixel_Setter, nullptr, nullptr},
  {(char *)"refresh_rate", &Dtool_DisplayMode_refresh_rate_Getter, &Dtool_DisplayMode_refresh_rate_Setter, nullptr, nullptr},
  {(char *)"fullscreen_only", &Dtool_DisplayMode_fullscreen_only_Getter, &Dtool_DisplayMode_fullscreen_only_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_DisplayMode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_DisplayMode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DisplayMode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DisplayMode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    &Dtool_Repr_DisplayMode,
    &Dtool_NumberMethods_DisplayMode,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Repr_DisplayMode,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_DisplayMode,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DisplayMode,
    nullptr, // tp_members
    Dtool_Properties_DisplayMode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DisplayMode,
    PyType_GenericAlloc,
    Dtool_new_DisplayMode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DisplayMode,
  Dtool_UpcastInterface_DisplayMode,
  Dtool_DowncastInterface_DisplayMode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DisplayMode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DisplayMode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DisplayMode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DisplayMode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DisplayMode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DisplayMode);
  }
}

/**
 * Python method tables for DisplayRegionCullCallbackData (DisplayRegionCullCallbackData)
 */
static PyMethodDef Dtool_Methods_DisplayRegionCullCallbackData[] = {
  {"get_scene_setup", &Dtool_DisplayRegionCullCallbackData_get_scene_setup_903, METH_NOARGS, (const char *)Dtool_DisplayRegionCullCallbackData_get_scene_setup_903_comment},
  {"getSceneSetup", &Dtool_DisplayRegionCullCallbackData_get_scene_setup_903, METH_NOARGS, (const char *)Dtool_DisplayRegionCullCallbackData_get_scene_setup_903_comment},
  {"get_class_type", &Dtool_DisplayRegionCullCallbackData_get_class_type_904, METH_NOARGS | METH_STATIC, (const char *)Dtool_DisplayRegionCullCallbackData_get_class_type_904_comment},
  {"getClassType", &Dtool_DisplayRegionCullCallbackData_get_class_type_904, METH_NOARGS | METH_STATIC, (const char *)Dtool_DisplayRegionCullCallbackData_get_class_type_904_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DisplayRegionCullCallbackData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DisplayRegionCullCallbackData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DisplayRegionCullCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DisplayRegionCullCallbackData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DisplayRegionCullCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DisplayRegionCullCallbackData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DisplayRegionCullCallbackData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DisplayRegionCullCallbackData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DisplayRegionCullCallbackData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DisplayRegionCullCallbackData,
    &Dtool_SequenceMethods_DisplayRegionCullCallbackData,
    &Dtool_MappingMethods_DisplayRegionCullCallbackData,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DisplayRegionCullCallbackData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This specialization on CallbackData is passed when the callback is\n"
    " * initiated from the cull traversal, for a DisplayRegion.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DisplayRegionCullCallbackData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DisplayRegionCullCallbackData,
    PyType_GenericAlloc,
    Dtool_new_DisplayRegionCullCallbackData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DisplayRegionCullCallbackData,
  Dtool_UpcastInterface_DisplayRegionCullCallbackData,
  Dtool_DowncastInterface_DisplayRegionCullCallbackData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DisplayRegionCullCallbackData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CallbackData != nullptr);
    assert(Dtool_Ptr_CallbackData->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_CallbackData->_Dtool_ModuleClassInit(nullptr);
    Dtool_DisplayRegionCullCallbackData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_CallbackData);
    Dtool_DisplayRegionCullCallbackData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DisplayRegionCullCallbackData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DisplayRegionCullCallbackData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DisplayRegionCullCallbackData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DisplayRegionCullCallbackData);
  }
}

/**
 * Python method tables for DisplayRegionDrawCallbackData (DisplayRegionDrawCallbackData)
 */
static PyMethodDef Dtool_Methods_DisplayRegionDrawCallbackData[] = {
  {"get_cull_result", &Dtool_DisplayRegionDrawCallbackData_get_cull_result_907, METH_NOARGS, (const char *)Dtool_DisplayRegionDrawCallbackData_get_cull_result_907_comment},
  {"getCullResult", &Dtool_DisplayRegionDrawCallbackData_get_cull_result_907, METH_NOARGS, (const char *)Dtool_DisplayRegionDrawCallbackData_get_cull_result_907_comment},
  {"get_scene_setup", &Dtool_DisplayRegionDrawCallbackData_get_scene_setup_908, METH_NOARGS, (const char *)Dtool_DisplayRegionDrawCallbackData_get_scene_setup_908_comment},
  {"getSceneSetup", &Dtool_DisplayRegionDrawCallbackData_get_scene_setup_908, METH_NOARGS, (const char *)Dtool_DisplayRegionDrawCallbackData_get_scene_setup_908_comment},
  {"get_class_type", &Dtool_DisplayRegionDrawCallbackData_get_class_type_909, METH_NOARGS | METH_STATIC, (const char *)Dtool_DisplayRegionDrawCallbackData_get_class_type_909_comment},
  {"getClassType", &Dtool_DisplayRegionDrawCallbackData_get_class_type_909, METH_NOARGS | METH_STATIC, (const char *)Dtool_DisplayRegionDrawCallbackData_get_class_type_909_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DisplayRegionDrawCallbackData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DisplayRegionDrawCallbackData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DisplayRegionDrawCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DisplayRegionDrawCallbackData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DisplayRegionDrawCallbackData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DisplayRegionDrawCallbackData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DisplayRegionDrawCallbackData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DisplayRegionDrawCallbackData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DisplayRegionDrawCallbackData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DisplayRegionDrawCallbackData,
    &Dtool_SequenceMethods_DisplayRegionDrawCallbackData,
    &Dtool_MappingMethods_DisplayRegionDrawCallbackData,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DisplayRegionDrawCallbackData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This specialization on CallbackData is passed when the callback is\n"
    " * initiated from the draw traversal, for a DisplayRegion.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DisplayRegionDrawCallbackData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DisplayRegionDrawCallbackData,
    PyType_GenericAlloc,
    Dtool_new_DisplayRegionDrawCallbackData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DisplayRegionDrawCallbackData,
  Dtool_UpcastInterface_DisplayRegionDrawCallbackData,
  Dtool_DowncastInterface_DisplayRegionDrawCallbackData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DisplayRegionDrawCallbackData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CallbackData != nullptr);
    assert(Dtool_Ptr_CallbackData->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_CallbackData->_Dtool_ModuleClassInit(nullptr);
    Dtool_DisplayRegionDrawCallbackData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_CallbackData);
    Dtool_DisplayRegionDrawCallbackData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DisplayRegionDrawCallbackData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DisplayRegionDrawCallbackData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DisplayRegionDrawCallbackData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DisplayRegionDrawCallbackData);
  }
}

/**
 * Python method tables for DisplaySearchParameters (DisplaySearchParameters)
 */
static PyMethodDef Dtool_Methods_DisplaySearchParameters[] = {
  {"set_minimum_width", &Dtool_DisplaySearchParameters_set_minimum_width_914, METH_O, (const char *)Dtool_DisplaySearchParameters_set_minimum_width_914_comment},
  {"setMinimumWidth", &Dtool_DisplaySearchParameters_set_minimum_width_914, METH_O, (const char *)Dtool_DisplaySearchParameters_set_minimum_width_914_comment},
  {"set_maximum_width", &Dtool_DisplaySearchParameters_set_maximum_width_915, METH_O, (const char *)Dtool_DisplaySearchParameters_set_maximum_width_915_comment},
  {"setMaximumWidth", &Dtool_DisplaySearchParameters_set_maximum_width_915, METH_O, (const char *)Dtool_DisplaySearchParameters_set_maximum_width_915_comment},
  {"set_minimum_height", &Dtool_DisplaySearchParameters_set_minimum_height_916, METH_O, (const char *)Dtool_DisplaySearchParameters_set_minimum_height_916_comment},
  {"setMinimumHeight", &Dtool_DisplaySearchParameters_set_minimum_height_916, METH_O, (const char *)Dtool_DisplaySearchParameters_set_minimum_height_916_comment},
  {"set_maximum_height", &Dtool_DisplaySearchParameters_set_maximum_height_917, METH_O, (const char *)Dtool_DisplaySearchParameters_set_maximum_height_917_comment},
  {"setMaximumHeight", &Dtool_DisplaySearchParameters_set_maximum_height_917, METH_O, (const char *)Dtool_DisplaySearchParameters_set_maximum_height_917_comment},
  {"set_minimum_bits_per_pixel", &Dtool_DisplaySearchParameters_set_minimum_bits_per_pixel_918, METH_O, (const char *)Dtool_DisplaySearchParameters_set_minimum_bits_per_pixel_918_comment},
  {"setMinimumBitsPerPixel", &Dtool_DisplaySearchParameters_set_minimum_bits_per_pixel_918, METH_O, (const char *)Dtool_DisplaySearchParameters_set_minimum_bits_per_pixel_918_comment},
  {"set_maximum_bits_per_pixel", &Dtool_DisplaySearchParameters_set_maximum_bits_per_pixel_919, METH_O, (const char *)Dtool_DisplaySearchParameters_set_maximum_bits_per_pixel_919_comment},
  {"setMaximumBitsPerPixel", &Dtool_DisplaySearchParameters_set_maximum_bits_per_pixel_919, METH_O, (const char *)Dtool_DisplaySearchParameters_set_maximum_bits_per_pixel_919_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DisplaySearchParameters = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_DisplaySearchParameters = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DisplaySearchParameters",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DisplaySearchParameters,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DisplaySearchParameters,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Parameters used for searching display capabilities.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DisplaySearchParameters,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DisplaySearchParameters,
    PyType_GenericAlloc,
    Dtool_new_DisplaySearchParameters,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DisplaySearchParameters,
  Dtool_UpcastInterface_DisplaySearchParameters,
  Dtool_DowncastInterface_DisplaySearchParameters,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DisplaySearchParameters(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DisplaySearchParameters._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DisplaySearchParameters._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DisplaySearchParameters) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DisplaySearchParameters)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DisplaySearchParameters);
  }
}

/**
 * Python method tables for GraphicsBuffer (GraphicsBuffer)
 */
static PyMethodDef Dtool_Methods_GraphicsBuffer[] = {
  {"set_size", (PyCFunction) &Dtool_GraphicsBuffer_set_size_921, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsBuffer_set_size_921_comment},
  {"setSize", (PyCFunction) &Dtool_GraphicsBuffer_set_size_921, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsBuffer_set_size_921_comment},
  {"get_class_type", &Dtool_GraphicsBuffer_get_class_type_922, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsBuffer_get_class_type_922_comment},
  {"getClassType", &Dtool_GraphicsBuffer_get_class_type_922, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsBuffer_get_class_type_922_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GraphicsBuffer = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_GraphicsBuffer = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_GraphicsBuffer = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_GraphicsBuffer = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_GraphicsBuffer = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_GraphicsBuffer = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GraphicsBuffer",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GraphicsBuffer,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_GraphicsBuffer,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GraphicsBuffer,
    &Dtool_SequenceMethods_GraphicsBuffer,
    &Dtool_MappingMethods_GraphicsBuffer,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_GraphicsBuffer,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An offscreen buffer for rendering into.  This is similar in function to a\n"
    " * GraphicsWindow, except that the output is not visible to the user.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GraphicsBuffer,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GraphicsBuffer,
    PyType_GenericAlloc,
    Dtool_new_GraphicsBuffer,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GraphicsBuffer,
  Dtool_UpcastInterface_GraphicsBuffer,
  Dtool_DowncastInterface_GraphicsBuffer,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GraphicsBuffer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GraphicsOutput(nullptr);
    Dtool_GraphicsBuffer._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GraphicsOutput);
    Dtool_GraphicsBuffer._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GraphicsBuffer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GraphicsBuffer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GraphicsBuffer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GraphicsBuffer);
  }
}

/**
 * Python method tables for GraphicsPipeSelection (GraphicsPipeSelection)
 */
static PyMethodDef Dtool_Methods_GraphicsPipeSelection[] = {
  {"get_num_pipe_types", &Dtool_GraphicsPipeSelection_get_num_pipe_types_924, METH_NOARGS, (const char *)Dtool_GraphicsPipeSelection_get_num_pipe_types_924_comment},
  {"getNumPipeTypes", &Dtool_GraphicsPipeSelection_get_num_pipe_types_924, METH_NOARGS, (const char *)Dtool_GraphicsPipeSelection_get_num_pipe_types_924_comment},
  {"get_pipe_type", &Dtool_GraphicsPipeSelection_get_pipe_type_925, METH_O, (const char *)Dtool_GraphicsPipeSelection_get_pipe_type_925_comment},
  {"getPipeType", &Dtool_GraphicsPipeSelection_get_pipe_type_925, METH_O, (const char *)Dtool_GraphicsPipeSelection_get_pipe_type_925_comment},
  {"print_pipe_types", &Dtool_GraphicsPipeSelection_print_pipe_types_929, METH_NOARGS, (const char *)Dtool_GraphicsPipeSelection_print_pipe_types_929_comment},
  {"printPipeTypes", &Dtool_GraphicsPipeSelection_print_pipe_types_929, METH_NOARGS, (const char *)Dtool_GraphicsPipeSelection_print_pipe_types_929_comment},
  {"make_pipe", (PyCFunction) &Dtool_GraphicsPipeSelection_make_pipe_930, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsPipeSelection_make_pipe_930_comment},
  {"makePipe", (PyCFunction) &Dtool_GraphicsPipeSelection_make_pipe_930, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_GraphicsPipeSelection_make_pipe_930_comment},
  {"make_module_pipe", &Dtool_GraphicsPipeSelection_make_module_pipe_931, METH_O, (const char *)Dtool_GraphicsPipeSelection_make_module_pipe_931_comment},
  {"makeModulePipe", &Dtool_GraphicsPipeSelection_make_module_pipe_931, METH_O, (const char *)Dtool_GraphicsPipeSelection_make_module_pipe_931_comment},
  {"make_default_pipe", &Dtool_GraphicsPipeSelection_make_default_pipe_932, METH_NOARGS, (const char *)Dtool_GraphicsPipeSelection_make_default_pipe_932_comment},
  {"makeDefaultPipe", &Dtool_GraphicsPipeSelection_make_default_pipe_932, METH_NOARGS, (const char *)Dtool_GraphicsPipeSelection_make_default_pipe_932_comment},
  {"get_num_aux_modules", &Dtool_GraphicsPipeSelection_get_num_aux_modules_933, METH_NOARGS, (const char *)Dtool_GraphicsPipeSelection_get_num_aux_modules_933_comment},
  {"getNumAuxModules", &Dtool_GraphicsPipeSelection_get_num_aux_modules_933, METH_NOARGS, (const char *)Dtool_GraphicsPipeSelection_get_num_aux_modules_933_comment},
  {"load_aux_modules", &Dtool_GraphicsPipeSelection_load_aux_modules_934, METH_NOARGS, (const char *)Dtool_GraphicsPipeSelection_load_aux_modules_934_comment},
  {"loadAuxModules", &Dtool_GraphicsPipeSelection_load_aux_modules_934, METH_NOARGS, (const char *)Dtool_GraphicsPipeSelection_load_aux_modules_934_comment},
  {"get_global_ptr", &Dtool_GraphicsPipeSelection_get_global_ptr_935, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsPipeSelection_get_global_ptr_935_comment},
  {"getGlobalPtr", &Dtool_GraphicsPipeSelection_get_global_ptr_935, METH_NOARGS | METH_STATIC, (const char *)Dtool_GraphicsPipeSelection_get_global_ptr_935_comment},
  {"get_pipe_types", (PyCFunction) &MakeSeq_GraphicsPipeSelection_get_pipe_types, METH_NOARGS, nullptr},
  { "getPipeTypes", (PyCFunction) &MakeSeq_GraphicsPipeSelection_get_pipe_types, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_GraphicsPipeSelection[] = {
  {(char *)"pipe_types", &Dtool_GraphicsPipeSelection_pipe_types_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_GraphicsPipeSelection = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_GraphicsPipeSelection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GraphicsPipeSelection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GraphicsPipeSelection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GraphicsPipeSelection,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This maintains a list of GraphicsPipes by type that are available for\n"
    " * creation.  Normally there is one default interactive GraphicsPipe, and\n"
    " * possibly other types available as well.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GraphicsPipeSelection,
    nullptr, // tp_members
    Dtool_Properties_GraphicsPipeSelection,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GraphicsPipeSelection,
    PyType_GenericAlloc,
    Dtool_new_GraphicsPipeSelection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GraphicsPipeSelection,
  Dtool_UpcastInterface_GraphicsPipeSelection,
  Dtool_DowncastInterface_GraphicsPipeSelection,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GraphicsPipeSelection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_GraphicsPipeSelection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GraphicsPipeSelection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GraphicsPipeSelection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GraphicsPipeSelection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GraphicsPipeSelection);
  }
}

/**
 * Python method tables for MouseAndKeyboard (MouseAndKeyboard)
 */
static PyMethodDef Dtool_Methods_MouseAndKeyboard[] = {
  {"set_source", (PyCFunction) &Dtool_MouseAndKeyboard_set_source_939, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseAndKeyboard_set_source_939_comment},
  {"setSource", (PyCFunction) &Dtool_MouseAndKeyboard_set_source_939, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_MouseAndKeyboard_set_source_939_comment},
  {"get_class_type", &Dtool_MouseAndKeyboard_get_class_type_940, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseAndKeyboard_get_class_type_940_comment},
  {"getClassType", &Dtool_MouseAndKeyboard_get_class_type_940, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseAndKeyboard_get_class_type_940_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_MouseAndKeyboard = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MouseAndKeyboard = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_MouseAndKeyboard = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_MouseAndKeyboard = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_MouseAndKeyboard = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_MouseAndKeyboard = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MouseAndKeyboard",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MouseAndKeyboard,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_MouseAndKeyboard,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MouseAndKeyboard,
    &Dtool_SequenceMethods_MouseAndKeyboard,
    &Dtool_MappingMethods_MouseAndKeyboard,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_MouseAndKeyboard,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Reads the mouse and/or keyboard data sent from a GraphicsWindow, and\n"
    " * transmits it down the data graph.\n"
    " *\n"
    " * The mouse and keyboard devices are bundled together into one device here,\n"
    " * because they interrelate so much.  A mouse might be constrained by the\n"
    " * holding down of the shift key, for instance, or the clicking of the mouse\n"
    " * button might be handled in much the same way as a keyboard key.\n"
    " *\n"
    " * Mouse data is sent down the data graph as an x,y position as well as the\n"
    " * set of buttons currently being held down; keyboard data is sent down as a\n"
    " * set of keypress events in an EventDataTransition.  To throw these events to\n"
    " * the system, you must attach an EventThrower to the MouseAndKeyboard object;\n"
    " * otherwise, the events will be discarded.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MouseAndKeyboard,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MouseAndKeyboard,
    PyType_GenericAlloc,
    Dtool_new_MouseAndKeyboard,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MouseAndKeyboard,
  Dtool_UpcastInterface_MouseAndKeyboard,
  Dtool_DowncastInterface_MouseAndKeyboard,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MouseAndKeyboard(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != nullptr);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_MouseAndKeyboard._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DataNode);
    Dtool_MouseAndKeyboard._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MouseAndKeyboard._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MouseAndKeyboard) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MouseAndKeyboard)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MouseAndKeyboard);
  }
}

/**
 * Python method tables for NativeWindowHandle (NativeWindowHandle)
 */
static PyMethodDef Dtool_Methods_NativeWindowHandle[] = {
  {"make_int", &Dtool_NativeWindowHandle_make_int_943, METH_O | METH_STATIC, (const char *)Dtool_NativeWindowHandle_make_int_943_comment},
  {"makeInt", &Dtool_NativeWindowHandle_make_int_943, METH_O | METH_STATIC, (const char *)Dtool_NativeWindowHandle_make_int_943_comment},
  {"make_subprocess", &Dtool_NativeWindowHandle_make_subprocess_944, METH_O | METH_STATIC, (const char *)Dtool_NativeWindowHandle_make_subprocess_944_comment},
  {"makeSubprocess", &Dtool_NativeWindowHandle_make_subprocess_944, METH_O | METH_STATIC, (const char *)Dtool_NativeWindowHandle_make_subprocess_944_comment},
  {"get_class_type", &Dtool_NativeWindowHandle_get_class_type_945, METH_NOARGS | METH_STATIC, (const char *)Dtool_NativeWindowHandle_get_class_type_945_comment},
  {"getClassType", &Dtool_NativeWindowHandle_get_class_type_945, METH_NOARGS | METH_STATIC, (const char *)Dtool_NativeWindowHandle_get_class_type_945_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_NativeWindowHandle = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NativeWindowHandle = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_NativeWindowHandle = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_NativeWindowHandle = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_NativeWindowHandle = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_NativeWindowHandle = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.NativeWindowHandle",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NativeWindowHandle,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_NativeWindowHandle,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_NativeWindowHandle,
    &Dtool_SequenceMethods_NativeWindowHandle,
    &Dtool_MappingMethods_NativeWindowHandle,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_NativeWindowHandle,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This subclass of WindowHandle exists to allow simple creation of a\n"
    " * WindowHandle of the appropriate type to the current OS.\n"
    " *\n"
    " * This class exists for name scoping only.  Don't use the constructor\n"
    " * directly; use one of the make_* methods.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NativeWindowHandle,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NativeWindowHandle,
    PyType_GenericAlloc,
    Dtool_new_NativeWindowHandle,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NativeWindowHandle,
  Dtool_UpcastInterface_NativeWindowHandle,
  Dtool_DowncastInterface_NativeWindowHandle,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_NativeWindowHandle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_WindowHandle(nullptr);
    Dtool_NativeWindowHandle._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_WindowHandle);
    Dtool_NativeWindowHandle._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NativeWindowHandle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NativeWindowHandle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NativeWindowHandle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NativeWindowHandle);
  }
}

/**
 * Python method tables for ParasiteBuffer (ParasiteBuffer)
 */
static PyMethodDef Dtool_Methods_ParasiteBuffer[] = {
  {"set_size", (PyCFunction) &Dtool_ParasiteBuffer_set_size_948, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParasiteBuffer_set_size_948_comment},
  {"setSize", (PyCFunction) &Dtool_ParasiteBuffer_set_size_948, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ParasiteBuffer_set_size_948_comment},
  {"get_class_type", &Dtool_ParasiteBuffer_get_class_type_949, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParasiteBuffer_get_class_type_949_comment},
  {"getClassType", &Dtool_ParasiteBuffer_get_class_type_949, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParasiteBuffer_get_class_type_949_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ParasiteBuffer = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParasiteBuffer = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParasiteBuffer = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParasiteBuffer = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParasiteBuffer = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParasiteBuffer = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParasiteBuffer",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParasiteBuffer,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParasiteBuffer,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParasiteBuffer,
    &Dtool_SequenceMethods_ParasiteBuffer,
    &Dtool_MappingMethods_ParasiteBuffer,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParasiteBuffer,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special GraphicsOutput type that acts a lot like a\n"
    " * GraphicsBuffer, effectively allowing rendering to an offscreen buffer,\n"
    " * except it does not create any framebuffer space for itself.  Instead, it\n"
    " * renders into the framebuffer owned by some other GraphicsOutput.\n"
    " *\n"
    " * The x_size and y_size must therefore fit within the bounds of the source\n"
    " * GraphicsOutput.\n"
    " *\n"
    " * Since the framebuffer will be subsequently cleared when the actual owner\n"
    " * draws in it later, this only makes sense if we are going to copy the\n"
    " * contents of the framebuffer to a texture immediately after we draw it.\n"
    " * Thus, has_texture() is implicitly true for a ParasiteBuffer.\n"
    " *\n"
    " * This class is useful to render offscreen to a texture while preventing the\n"
    " * waste of framebuffer memory for API's that are unable to render directly\n"
    " * into a texture (and must render into a separate framebuffer first and then\n"
    " * copy to texture).  It is also the only way to render to a texture on API's\n"
    " * that do not support offscreen rendering.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParasiteBuffer,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParasiteBuffer,
    PyType_GenericAlloc,
    Dtool_new_ParasiteBuffer,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParasiteBuffer,
  Dtool_UpcastInterface_ParasiteBuffer,
  Dtool_DowncastInterface_ParasiteBuffer,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ParasiteBuffer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_GraphicsOutput(nullptr);
    Dtool_ParasiteBuffer._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_GraphicsOutput);
    Dtool_ParasiteBuffer._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParasiteBuffer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParasiteBuffer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParasiteBuffer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParasiteBuffer);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3display_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    GraphicsDevice::init_type();
    TypeHandle handle = GraphicsDevice::get_class_type();
    Dtool_GraphicsDevice._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GraphicsDevice);
  }
  {
    GraphicsPipe::init_type();
    TypeHandle handle = GraphicsPipe::get_class_type();
    Dtool_GraphicsPipe._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GraphicsPipe);
  }
  {
    WindowHandle::init_type();
    TypeHandle handle = WindowHandle::get_class_type();
    Dtool_WindowHandle._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_WindowHandle);
  }
  {
    WindowHandle::OSHandle::init_type();
    TypeHandle handle = WindowHandle::OSHandle::get_class_type();
    Dtool_WindowHandle_OSHandle._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_WindowHandle_OSHandle);
  }
  {
    DisplayRegion::init_type();
    TypeHandle handle = DisplayRegion::get_class_type();
    Dtool_DisplayRegion._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_DisplayRegion);
  }
  {
    GraphicsOutput::init_type();
    TypeHandle handle = GraphicsOutput::get_class_type();
    Dtool_GraphicsOutput._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GraphicsOutput);
  }
  {
    GraphicsStateGuardian::init_type();
    TypeHandle handle = GraphicsStateGuardian::get_class_type();
    Dtool_GraphicsStateGuardian._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GraphicsStateGuardian);
  }
  {
    StereoDisplayRegion::init_type();
    TypeHandle handle = StereoDisplayRegion::get_class_type();
    Dtool_StereoDisplayRegion._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_StereoDisplayRegion);
  }
  {
    GraphicsWindowInputDevice::init_type();
    TypeHandle handle = GraphicsWindowInputDevice::get_class_type();
    Dtool_GraphicsWindowInputDevice._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GraphicsWindowInputDevice);
  }
  {
    GraphicsWindowProcCallbackData::init_type();
    TypeHandle handle = GraphicsWindowProcCallbackData::get_class_type();
    Dtool_GraphicsWindowProcCallbackData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GraphicsWindowProcCallbackData);
  }
  {
    GraphicsWindow::init_type();
    TypeHandle handle = GraphicsWindow::get_class_type();
    Dtool_GraphicsWindow._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GraphicsWindow);
  }
  {
    CallbackGraphicsWindow::init_type();
    TypeHandle handle = CallbackGraphicsWindow::get_class_type();
    Dtool_CallbackGraphicsWindow._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CallbackGraphicsWindow);
  }
  {
    CallbackGraphicsWindow::WindowCallbackData::init_type();
    TypeHandle handle = CallbackGraphicsWindow::WindowCallbackData::get_class_type();
    Dtool_CallbackGraphicsWindow_WindowCallbackData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CallbackGraphicsWindow_WindowCallbackData);
  }
  {
    CallbackGraphicsWindow::EventsCallbackData::init_type();
    TypeHandle handle = CallbackGraphicsWindow::EventsCallbackData::get_class_type();
    Dtool_CallbackGraphicsWindow_EventsCallbackData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CallbackGraphicsWindow_EventsCallbackData);
  }
  {
    CallbackGraphicsWindow::PropertiesCallbackData::init_type();
    TypeHandle handle = CallbackGraphicsWindow::PropertiesCallbackData::get_class_type();
    Dtool_CallbackGraphicsWindow_PropertiesCallbackData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CallbackGraphicsWindow_PropertiesCallbackData);
  }
  {
    CallbackGraphicsWindow::RenderCallbackData::init_type();
    TypeHandle handle = CallbackGraphicsWindow::RenderCallbackData::get_class_type();
    Dtool_CallbackGraphicsWindow_RenderCallbackData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CallbackGraphicsWindow_RenderCallbackData);
  }
  {
    DisplayRegionCullCallbackData::init_type();
    TypeHandle handle = DisplayRegionCullCallbackData::get_class_type();
    Dtool_DisplayRegionCullCallbackData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_DisplayRegionCullCallbackData);
  }
  {
    DisplayRegionDrawCallbackData::init_type();
    TypeHandle handle = DisplayRegionDrawCallbackData::get_class_type();
    Dtool_DisplayRegionDrawCallbackData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_DisplayRegionDrawCallbackData);
  }
  {
    GraphicsBuffer::init_type();
    TypeHandle handle = GraphicsBuffer::get_class_type();
    Dtool_GraphicsBuffer._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_GraphicsBuffer);
  }
  {
    MouseAndKeyboard::init_type();
    TypeHandle handle = MouseAndKeyboard::get_class_type();
    Dtool_MouseAndKeyboard._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_MouseAndKeyboard);
  }
  {
    NativeWindowHandle::init_type();
    TypeHandle handle = NativeWindowHandle::get_class_type();
    Dtool_NativeWindowHandle._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_NativeWindowHandle);
  }
  {
    ParasiteBuffer::init_type();
    TypeHandle handle = ParasiteBuffer::get_class_type();
    Dtool_ParasiteBuffer._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParasiteBuffer);
  }
}

void Dtool_libp3display_BuildInstants(PyObject *module) {
  (void) module;
  // GraphicsDevice
  Dtool_PyModuleClassInit_GraphicsDevice(module);
  PyModule_AddObject(module, "GraphicsDevice", (PyObject *)&Dtool_GraphicsDevice);
  // GraphicsPipe
  Dtool_PyModuleClassInit_GraphicsPipe(module);
  PyModule_AddObject(module, "GraphicsPipe", (PyObject *)&Dtool_GraphicsPipe);
  // DisplayInformation
  Dtool_PyModuleClassInit_DisplayInformation(module);
  PyModule_AddObject(module, "DisplayInformation", (PyObject *)&Dtool_DisplayInformation);
  // DrawableRegion
  Dtool_PyModuleClassInit_DrawableRegion(module);
  PyModule_AddObject(module, "DrawableRegion", (PyObject *)&Dtool_DrawableRegion);
  // WindowHandle
  Dtool_PyModuleClassInit_WindowHandle(module);
  PyModule_AddObject(module, "WindowHandle", (PyObject *)&Dtool_WindowHandle);
  // WindowProperties
  Dtool_PyModuleClassInit_WindowProperties(module);
  PyModule_AddObject(module, "WindowProperties", (PyObject *)&Dtool_WindowProperties);
  // DisplayRegion
  Dtool_PyModuleClassInit_DisplayRegion(module);
  PyModule_AddObject(module, "DisplayRegion", (PyObject *)&Dtool_DisplayRegion);
  // GraphicsOutput
  Dtool_PyModuleClassInit_GraphicsOutput(module);
  PyModule_AddObject(module, "GraphicsOutput", (PyObject *)&Dtool_GraphicsOutput);
  // GraphicsStateGuardian
  Dtool_PyModuleClassInit_GraphicsStateGuardian(module);
  PyModule_AddObject(module, "GraphicsStateGuardian", (PyObject *)&Dtool_GraphicsStateGuardian);
  // GraphicsEngine
  Dtool_PyModuleClassInit_GraphicsEngine(module);
  PyModule_AddObject(module, "GraphicsEngine", (PyObject *)&Dtool_GraphicsEngine);
  // GraphicsThreadingModel
  Dtool_PyModuleClassInit_GraphicsThreadingModel(module);
  PyModule_AddObject(module, "GraphicsThreadingModel", (PyObject *)&Dtool_GraphicsThreadingModel);
  // StereoDisplayRegion
  Dtool_PyModuleClassInit_StereoDisplayRegion(module);
  PyModule_AddObject(module, "StereoDisplayRegion", (PyObject *)&Dtool_StereoDisplayRegion);
  // FrameBufferProperties
  Dtool_PyModuleClassInit_FrameBufferProperties(module);
  PyModule_AddObject(module, "FrameBufferProperties", (PyObject *)&Dtool_FrameBufferProperties);
  // GraphicsWindowInputDevice
  Dtool_PyModuleClassInit_GraphicsWindowInputDevice(module);
  PyModule_AddObject(module, "GraphicsWindowInputDevice", (PyObject *)&Dtool_GraphicsWindowInputDevice);
  // TouchInfo
  Dtool_PyModuleClassInit_TouchInfo(module);
  PyModule_AddObject(module, "TouchInfo", (PyObject *)&Dtool_TouchInfo);
  // GraphicsWindowProcCallbackData
  Dtool_PyModuleClassInit_GraphicsWindowProcCallbackData(module);
  PyModule_AddObject(module, "GraphicsWindowProcCallbackData", (PyObject *)&Dtool_GraphicsWindowProcCallbackData);
  // GraphicsWindow
  Dtool_PyModuleClassInit_GraphicsWindow(module);
  PyModule_AddObject(module, "GraphicsWindow", (PyObject *)&Dtool_GraphicsWindow);
  // CallbackGraphicsWindow
  Dtool_PyModuleClassInit_CallbackGraphicsWindow(module);
  PyModule_AddObject(module, "CallbackGraphicsWindow", (PyObject *)&Dtool_CallbackGraphicsWindow);
  // DisplayMode
  Dtool_PyModuleClassInit_DisplayMode(module);
  PyModule_AddObject(module, "DisplayMode", (PyObject *)&Dtool_DisplayMode);
  // DisplayRegionCullCallbackData
  Dtool_PyModuleClassInit_DisplayRegionCullCallbackData(module);
  PyModule_AddObject(module, "DisplayRegionCullCallbackData", (PyObject *)&Dtool_DisplayRegionCullCallbackData);
  // DisplayRegionDrawCallbackData
  Dtool_PyModuleClassInit_DisplayRegionDrawCallbackData(module);
  PyModule_AddObject(module, "DisplayRegionDrawCallbackData", (PyObject *)&Dtool_DisplayRegionDrawCallbackData);
  // DisplaySearchParameters
  Dtool_PyModuleClassInit_DisplaySearchParameters(module);
  PyModule_AddObject(module, "DisplaySearchParameters", (PyObject *)&Dtool_DisplaySearchParameters);
  // GraphicsBuffer
  Dtool_PyModuleClassInit_GraphicsBuffer(module);
  PyModule_AddObject(module, "GraphicsBuffer", (PyObject *)&Dtool_GraphicsBuffer);
  // GraphicsPipeSelection
  Dtool_PyModuleClassInit_GraphicsPipeSelection(module);
  PyModule_AddObject(module, "GraphicsPipeSelection", (PyObject *)&Dtool_GraphicsPipeSelection);
  // MouseAndKeyboard
  Dtool_PyModuleClassInit_MouseAndKeyboard(module);
  PyModule_AddObject(module, "MouseAndKeyboard", (PyObject *)&Dtool_MouseAndKeyboard);
  // NativeWindowHandle
  Dtool_PyModuleClassInit_NativeWindowHandle(module);
  PyModule_AddObject(module, "NativeWindowHandle", (PyObject *)&Dtool_NativeWindowHandle);
  // ParasiteBuffer
  Dtool_PyModuleClassInit_ParasiteBuffer(module);
  PyModule_AddObject(module, "ParasiteBuffer", (PyObject *)&Dtool_ParasiteBuffer);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3display_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3display_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613538,  /* file_identifier */
  "libp3display",  /* library_name */
  "62HU",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3display.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  1730  /* next_index */
};

Configure(_in_configure_libp3display);
ConfigureFn(_in_configure_libp3display) {
  interrogate_request_module(&_in_module_def);
}

