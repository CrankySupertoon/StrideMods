/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/vision -Ipanda/src/vision -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3vision_igate.cxx -od built/pandac/input/libp3vision.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/vision -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -DHAVE_FFMPEG= -module panda3d.vision -library libp3vision arToolKit.h config_vision.h openCVTexture.h p3vision_composite1.cxx webcamVideo.h webcamVideoCursorOpenCV.h webcamVideoCursorV4L.h webcamVideoOpenCV.h webcamVideoV4L.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "arToolKit.h"
#include "configVariableBool.h"
#include "config_vision.h"
#include "notifyCategoryProxy.h"
#include "openCVTexture.h"
#include "pandabase.h"
#include "webcamVideo.h"
#include "webcamVideoCursorOpenCV.h"
#include "webcamVideoCursorV4L.h"
#include "webcamVideoOpenCV.h"
#include "webcamVideoV4L.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class WebcamVideo
 */
typedef WebcamVideo WebcamVideo_localtype;
Define_Module_ClassRef(panda3d.vision, WebcamVideo, WebcamVideo_localtype, WebcamVideo);
static struct Dtool_PyTypedObject *const Dtool_Ptr_WebcamVideo = &Dtool_WebcamVideo;
static void Dtool_PyModuleClassInit_WebcamVideo(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"WebcamVideo", &Dtool_WebcamVideo},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[1].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[2].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[3].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[4].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[5].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[6].type)
  {"MovieVideo", nullptr},
#define Dtool_Ptr_MovieVideo (imports[7].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// MovieVideo
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_MovieVideo(PyObject *args, CPT(MovieVideo) &coerced) {
  nassertr(Dtool_Ptr_MovieVideo != nullptr, false);
  nassertr(Dtool_Ptr_MovieVideo->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(MovieVideo) &))Dtool_Ptr_MovieVideo->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_MovieVideo(PyObject *args, PT(MovieVideo) &coerced) {
  nassertr(Dtool_Ptr_MovieVideo != nullptr, false);
  nassertr(Dtool_Ptr_MovieVideo->_Dtool_Coerce != nullptr, false);
  return ((bool (*)(PyObject *, PT(MovieVideo) &))Dtool_Ptr_MovieVideo->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_MovieVideo;
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovieVideo = &Dtool_MovieVideo;
extern bool Dtool_ConstCoerce_MovieVideo(PyObject *args, CPT(MovieVideo) &coerced);
extern bool Dtool_Coerce_MovieVideo(PyObject *args, PT(MovieVideo) &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class WebcamVideo
 */
/**
 * Python function wrapper for:
 * static int WebcamVideo::get_num_options(void)
 */
static PyObject *Dtool_WebcamVideo_get_num_options_3(PyObject *, PyObject *) {
  // 1-static int WebcamVideo::get_num_options(void)
  int return_value = (WebcamVideo::get_num_options)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WebcamVideo_get_num_options_3_comment =
  "C++ Interface:\n"
  "get_num_options()\n"
  "\n"
  "/**\n"
  " * Returns the number of webcam options.  An \"option\" consists of a device\n"
  " * plus a set of configuration parameters.  For example, \"Creative Webcam Live\n"
  " * at 640x480, 30 fps\" is an option.\n"
  " */";
#else
static const char *Dtool_WebcamVideo_get_num_options_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< WebcamVideo > WebcamVideo::get_option(int n)
 */
static PyObject *Dtool_WebcamVideo_get_option_4(PyObject *, PyObject *arg) {
  // 1-static PointerTo< WebcamVideo > WebcamVideo::get_option(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< WebcamVideo > return_value = (WebcamVideo::get_option)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    WebcamVideo *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_WebcamVideo, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_option(int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WebcamVideo_get_option_4_comment =
  "C++ Interface:\n"
  "get_option(int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth webcam option.\n"
  " */";
#else
static const char *Dtool_WebcamVideo_get_option_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int WebcamVideo::get_size_x(void) const
 */
static PyObject *Dtool_WebcamVideo_get_size_x_8(PyObject *self, PyObject *) {
  WebcamVideo *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WebcamVideo)) {
    return nullptr;
  }
  // 1-inline int WebcamVideo::get_size_x(void) const
  int return_value = ((*(const WebcamVideo*)local_this).get_size_x)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WebcamVideo_get_size_x_8_comment =
  "C++ Interface:\n"
  "get_size_x(WebcamVideo self)\n"
  "\n"
  "/**\n"
  " * Returns the camera's size_x.\n"
  " */";
#else
static const char *Dtool_WebcamVideo_get_size_x_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int WebcamVideo::get_size_y(void) const
 */
static PyObject *Dtool_WebcamVideo_get_size_y_9(PyObject *self, PyObject *) {
  WebcamVideo *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WebcamVideo)) {
    return nullptr;
  }
  // 1-inline int WebcamVideo::get_size_y(void) const
  int return_value = ((*(const WebcamVideo*)local_this).get_size_y)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WebcamVideo_get_size_y_9_comment =
  "C++ Interface:\n"
  "get_size_y(WebcamVideo self)\n"
  "\n"
  "/**\n"
  " * Returns the camera's size_y.\n"
  " */";
#else
static const char *Dtool_WebcamVideo_get_size_y_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double WebcamVideo::get_fps(void) const
 */
static PyObject *Dtool_WebcamVideo_get_fps_10(PyObject *self, PyObject *) {
  WebcamVideo *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WebcamVideo)) {
    return nullptr;
  }
  // 1-inline double WebcamVideo::get_fps(void) const
  double return_value = ((*(const WebcamVideo*)local_this).get_fps)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WebcamVideo_get_fps_10_comment =
  "C++ Interface:\n"
  "get_fps(WebcamVideo self)\n"
  "\n"
  "/**\n"
  " * Returns the camera's framerate.  This is a maximum theoretical: the actual\n"
  " * performance will depend on the speed of the hardware.\n"
  " */";
#else
static const char *Dtool_WebcamVideo_get_fps_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &WebcamVideo::get_pixel_format(void) const
 */
static PyObject *Dtool_WebcamVideo_get_pixel_format_11(PyObject *self, PyObject *) {
  WebcamVideo *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WebcamVideo)) {
    return nullptr;
  }
  // 1-inline std::string const &WebcamVideo::get_pixel_format(void) const
  std::string const &return_value = ((*(const WebcamVideo*)local_this).get_pixel_format)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WebcamVideo_get_pixel_format_11_comment =
  "C++ Interface:\n"
  "get_pixel_format(WebcamVideo self)\n"
  "\n"
  "/**\n"
  " * Returns the camera's pixel format, as a FourCC code, if known.\n"
  " */";
#else
static const char *Dtool_WebcamVideo_get_pixel_format_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void WebcamVideo::output(std::ostream &out) const
 */
static PyObject *Dtool_WebcamVideo_output_12(PyObject *self, PyObject *arg) {
  WebcamVideo *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WebcamVideo)) {
    return nullptr;
  }
  // 1-inline void WebcamVideo::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "WebcamVideo.output", false, true);
  if (arg_this != nullptr) {
    ((*(const WebcamVideo*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(WebcamVideo self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_WebcamVideo_output_12_comment =
  "C++ Interface:\n"
  "output(WebcamVideo self, ostream out)\n"
  "\n"
  "/**\n"
  " * Outputs the WebcamVideo.  This function simply writes the name, size and\n"
  " * FPS to the output stream.\n"
  " */";
#else
static const char *Dtool_WebcamVideo_output_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle WebcamVideo::get_class_type(void)
 */
static PyObject *Dtool_WebcamVideo_get_class_type_13(PyObject *, PyObject *) {
  // 1-static TypeHandle WebcamVideo::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((WebcamVideo::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_WebcamVideo_get_class_type_13_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_WebcamVideo_get_class_type_13_comment = nullptr;
#endif

/**
 * sequence length function for property WebcamVideo::options
 */
static Py_ssize_t Dtool_WebcamVideo_options_Len(PyObject *self) {
  return (Py_ssize_t)(WebcamVideo::get_num_options)();
}

/**
 * sequence getter for property WebcamVideo::options
 */
static PyObject *Dtool_WebcamVideo_options_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  if (index < 0 || index >= (Py_ssize_t)(WebcamVideo::get_num_options)()) {
    PyErr_SetString(PyExc_IndexError, "WebcamVideo.options[] index out of range");
    return nullptr;
  }
  // 1-static PointerTo< WebcamVideo > WebcamVideo::get_option(int n)
  PointerTo< WebcamVideo > return_value = (WebcamVideo::get_option)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  WebcamVideo *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_WebcamVideo, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_option(index)\n");
  }
}

static PyObject *Dtool_WebcamVideo_options_Getter(PyObject *self, void *) {
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "WebcamVideo.options");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_WebcamVideo_options_Len;
    wrap->_getitem_func = &Dtool_WebcamVideo_options_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static int Dtool_Init_WebcamVideo(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_WebcamVideo_get_options(PyObject *self, PyObject *) {
  Py_ssize_t count = (Py_ssize_t)(WebcamVideo::get_num_options)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_WebcamVideo_get_option_4(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_WebcamVideo(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_WebcamVideo) {
    printf("WebcamVideo ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  WebcamVideo *local_this = (WebcamVideo *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_WebcamVideo) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovieVideo) {
    return (MovieVideo *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(MovieVideo *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(MovieVideo *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(MovieVideo *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(MovieVideo *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(MovieVideo *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_WebcamVideo(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_WebcamVideo) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovieVideo) {
    MovieVideo* other_this = (MovieVideo*)from_this;
    return (WebcamVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (WebcamVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (WebcamVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (WebcamVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (WebcamVideo*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (WebcamVideo*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for WebcamVideo (WebcamVideo)
 */
static PyMethodDef Dtool_Methods_WebcamVideo[] = {
  {"get_num_options", &Dtool_WebcamVideo_get_num_options_3, METH_NOARGS | METH_STATIC, (const char *)Dtool_WebcamVideo_get_num_options_3_comment},
  {"getNumOptions", &Dtool_WebcamVideo_get_num_options_3, METH_NOARGS | METH_STATIC, (const char *)Dtool_WebcamVideo_get_num_options_3_comment},
  {"get_option", &Dtool_WebcamVideo_get_option_4, METH_O | METH_STATIC, (const char *)Dtool_WebcamVideo_get_option_4_comment},
  {"getOption", &Dtool_WebcamVideo_get_option_4, METH_O | METH_STATIC, (const char *)Dtool_WebcamVideo_get_option_4_comment},
  {"get_size_x", &Dtool_WebcamVideo_get_size_x_8, METH_NOARGS, (const char *)Dtool_WebcamVideo_get_size_x_8_comment},
  {"getSizeX", &Dtool_WebcamVideo_get_size_x_8, METH_NOARGS, (const char *)Dtool_WebcamVideo_get_size_x_8_comment},
  {"get_size_y", &Dtool_WebcamVideo_get_size_y_9, METH_NOARGS, (const char *)Dtool_WebcamVideo_get_size_y_9_comment},
  {"getSizeY", &Dtool_WebcamVideo_get_size_y_9, METH_NOARGS, (const char *)Dtool_WebcamVideo_get_size_y_9_comment},
  {"get_fps", &Dtool_WebcamVideo_get_fps_10, METH_NOARGS, (const char *)Dtool_WebcamVideo_get_fps_10_comment},
  {"getFps", &Dtool_WebcamVideo_get_fps_10, METH_NOARGS, (const char *)Dtool_WebcamVideo_get_fps_10_comment},
  {"get_pixel_format", &Dtool_WebcamVideo_get_pixel_format_11, METH_NOARGS, (const char *)Dtool_WebcamVideo_get_pixel_format_11_comment},
  {"getPixelFormat", &Dtool_WebcamVideo_get_pixel_format_11, METH_NOARGS, (const char *)Dtool_WebcamVideo_get_pixel_format_11_comment},
  {"output", &Dtool_WebcamVideo_output_12, METH_O, (const char *)Dtool_WebcamVideo_output_12_comment},
  {"get_class_type", &Dtool_WebcamVideo_get_class_type_13, METH_NOARGS | METH_STATIC, (const char *)Dtool_WebcamVideo_get_class_type_13_comment},
  {"getClassType", &Dtool_WebcamVideo_get_class_type_13, METH_NOARGS | METH_STATIC, (const char *)Dtool_WebcamVideo_get_class_type_13_comment},
  {"get_options", (PyCFunction) &MakeSeq_WebcamVideo_get_options, METH_NOARGS | METH_STATIC, nullptr},
  { "getOptions", (PyCFunction) &MakeSeq_WebcamVideo_get_options, METH_NOARGS | METH_STATIC, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     WebcamVideo
//////////////////
static PyObject *Dtool_Repr_WebcamVideo(PyObject *self) {
  WebcamVideo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_WebcamVideo, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_WebcamVideo = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_WebcamVideo = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_WebcamVideo = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_WebcamVideo = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_WebcamVideo = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_WebcamVideo = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.vision.WebcamVideo",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_WebcamVideo,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_WebcamVideo,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_WebcamVideo,
    &Dtool_NumberMethods_WebcamVideo,
    &Dtool_SequenceMethods_WebcamVideo,
    &Dtool_MappingMethods_WebcamVideo,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_WebcamVideo,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_WebcamVideo,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Allows you to open a webcam or other video capture device as a video\n"
    " * stream.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_WebcamVideo,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_WebcamVideo,
    PyType_GenericAlloc,
    Dtool_new_WebcamVideo,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_WebcamVideo,
  Dtool_UpcastInterface_WebcamVideo,
  Dtool_DowncastInterface_WebcamVideo,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_WebcamVideo(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_MovieVideo != nullptr);
    assert(Dtool_Ptr_MovieVideo->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_MovieVideo->_Dtool_ModuleClassInit(nullptr);
    Dtool_WebcamVideo._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_MovieVideo);
    Dtool_WebcamVideo._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_WebcamVideo._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_options = {(char *)"options", &Dtool_WebcamVideo_options_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "options", Dtool_NewStaticProperty(&Dtool_WebcamVideo._PyType, &def_options));
    if (PyType_Ready((PyTypeObject *)&Dtool_WebcamVideo) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(WebcamVideo)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_WebcamVideo);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3vision_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    WebcamVideo::init_type();
    TypeHandle handle = WebcamVideo::get_class_type();
    Dtool_WebcamVideo._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_WebcamVideo);
  }
}

void Dtool_libp3vision_BuildInstants(PyObject *module) {
  (void) module;
  // WebcamVideo
  Dtool_PyModuleClassInit_WebcamVideo(module);
  PyModule_AddObject(module, "WebcamVideo", (PyObject *)&Dtool_WebcamVideo);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3vision_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3vision_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613975,  /* file_identifier */
  "libp3vision",  /* library_name */
  "nRMq",  /* library_hash_name */
  "panda3d.vision",  /* module_name */
  "libp3vision.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  33  /* next_index */
};

Configure(_in_configure_libp3vision);
ConfigureFn(_in_configure_libp3vision) {
  interrogate_request_module(&_in_module_def);
}

