/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/device -Ipanda/src/device -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3device_igate.cxx -od built/pandac/input/libp3device.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/device -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3device analogNode.h buttonNode.h clientAnalogDevice.h clientBase.h clientButtonDevice.h clientDevice.h clientDialDevice.h clientTrackerDevice.h config_device.h dialNode.h evdevInputDevice.h inputDevice.h inputDeviceManager.h inputDeviceNode.h inputDeviceSet.h ioKitInputDevice.h ioKitInputDeviceManager.h linuxInputDeviceManager.h linuxJoystickDevice.h p3device_composite1.cxx p3device_composite2.cxx phidsdi.h trackerData.h trackerNode.h virtualMouse.h winInputDeviceManager.h winRawInputDevice.h xInputDevice.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "analogNode.h"
#include "buttonNode.h"
#include "clientAnalogDevice.h"
#include "clientBase.h"
#include "clientButtonDevice.h"
#include "clientDevice.h"
#include "clientDialDevice.h"
#include "clientTrackerDevice.h"
#include "config_device.h"
#include "dataNode.h"
#include "dialNode.h"
#include "evdevInputDevice.h"
#include "inputDevice.h"
#include "inputDeviceManager.h"
#include "inputDeviceNode.h"
#include "inputDeviceSet.h"
#include "ioKitInputDevice.h"
#include "ioKitInputDeviceManager.h"
#include "lightMutex.h"
#include "linmath_events.h"
#include "linuxInputDeviceManager.h"
#include "linuxJoystickDevice.h"
#include "pandabase.h"
#include "phidsdi.h"
#include "trackerData.h"
#include "trackerNode.h"
#include "virtualMouse.h"
#include "winInputDeviceManager.h"
#include "winRawInputDevice.h"
#include "xInputDevice.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class TrackerData
 */
typedef TrackerData TrackerData_localtype;
Define_Module_Class(panda3d.core, TrackerData, TrackerData_localtype, TrackerData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TrackerData = &Dtool_TrackerData;
static void Dtool_PyModuleClassInit_TrackerData(PyObject *module);

/**
 * Forward declarations for top-level class InputDevice
 */
typedef InputDevice InputDevice_localtype;
Define_Module_ClassRef(panda3d.core, InputDevice, InputDevice_localtype, InputDevice);
static struct Dtool_PyTypedObject *const Dtool_Ptr_InputDevice = &Dtool_InputDevice;
static void Dtool_PyModuleClassInit_InputDevice(PyObject *module);

static PyTypeObject *Dtool_Ptr_InputDevice_DeviceClass = nullptr;
static PyTypeObject *Dtool_Ptr_InputDevice_Feature = nullptr;
static PyTypeObject *Dtool_Ptr_InputDevice_Axis = nullptr;
/**
 * Forward declarations for top-level class InputDevice_ButtonState
 */
typedef InputDevice::ButtonState InputDevice_ButtonState_localtype;
Define_Module_Class(panda3d.core, InputDevice_ButtonState, InputDevice_ButtonState_localtype, ButtonState);
static struct Dtool_PyTypedObject *const Dtool_Ptr_InputDevice_ButtonState = &Dtool_InputDevice_ButtonState;
static void Dtool_PyModuleClassInit_InputDevice_ButtonState(PyObject *module);

/**
 * Forward declarations for top-level class InputDevice_AxisState
 */
typedef InputDevice::AxisState InputDevice_AxisState_localtype;
Define_Module_Class(panda3d.core, InputDevice_AxisState, InputDevice_AxisState_localtype, AxisState);
static struct Dtool_PyTypedObject *const Dtool_Ptr_InputDevice_AxisState = &Dtool_InputDevice_AxisState;
static void Dtool_PyModuleClassInit_InputDevice_AxisState(PyObject *module);

/**
 * Forward declarations for top-level class InputDevice_BatteryData
 */
typedef InputDevice::BatteryData InputDevice_BatteryData_localtype;
Define_Module_Class(panda3d.core, InputDevice_BatteryData, InputDevice_BatteryData_localtype, BatteryData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_InputDevice_BatteryData = &Dtool_InputDevice_BatteryData;
static void Dtool_PyModuleClassInit_InputDevice_BatteryData(PyObject *module);

/**
 * Forward declarations for top-level class ClientBase
 */
typedef ClientBase ClientBase_localtype;
Define_Module_ClassRef(panda3d.core, ClientBase, ClientBase_localtype, ClientBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ClientBase = &Dtool_ClientBase;
static void Dtool_PyModuleClassInit_ClientBase(PyObject *module);

/**
 * Forward declarations for top-level class AnalogNode
 */
typedef AnalogNode AnalogNode_localtype;
Define_Module_ClassRef(panda3d.core, AnalogNode, AnalogNode_localtype, AnalogNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnalogNode = &Dtool_AnalogNode;
static void Dtool_PyModuleClassInit_AnalogNode(PyObject *module);

/**
 * Forward declarations for top-level class ButtonNode
 */
typedef ButtonNode ButtonNode_localtype;
Define_Module_ClassRef(panda3d.core, ButtonNode, ButtonNode_localtype, ButtonNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ButtonNode = &Dtool_ButtonNode;
static void Dtool_PyModuleClassInit_ButtonNode(PyObject *module);

/**
 * Forward declarations for top-level class DialNode
 */
typedef DialNode DialNode_localtype;
Define_Module_ClassRef(panda3d.core, DialNode, DialNode_localtype, DialNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DialNode = &Dtool_DialNode;
static void Dtool_PyModuleClassInit_DialNode(PyObject *module);

/**
 * Forward declarations for top-level class InputDeviceSet
 */
typedef InputDeviceSet InputDeviceSet_localtype;
Define_Module_Class(panda3d.core, InputDeviceSet, InputDeviceSet_localtype, InputDeviceSet);
static struct Dtool_PyTypedObject *const Dtool_Ptr_InputDeviceSet = &Dtool_InputDeviceSet;
static void Dtool_PyModuleClassInit_InputDeviceSet(PyObject *module);

/**
 * Forward declarations for top-level class InputDeviceManager
 */
typedef InputDeviceManager InputDeviceManager_localtype;
Define_Module_Class_Private(panda3d.core, InputDeviceManager, InputDeviceManager_localtype, InputDeviceManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_InputDeviceManager = &Dtool_InputDeviceManager;
static void Dtool_PyModuleClassInit_InputDeviceManager(PyObject *module);

/**
 * Forward declarations for top-level class InputDeviceNode
 */
typedef InputDeviceNode InputDeviceNode_localtype;
Define_Module_ClassRef(panda3d.core, InputDeviceNode, InputDeviceNode_localtype, InputDeviceNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_InputDeviceNode = &Dtool_InputDeviceNode;
static void Dtool_PyModuleClassInit_InputDeviceNode(PyObject *module);
bool Dtool_ConstCoerce_InputDeviceNode(PyObject *args, CPT(InputDeviceNode) &coerced);
bool Dtool_Coerce_InputDeviceNode(PyObject *args, PT(InputDeviceNode) &coerced);

/**
 * Forward declarations for top-level class LinuxJoystickDevice
 */
typedef LinuxJoystickDevice LinuxJoystickDevice_localtype;
Define_Module_ClassRef(panda3d.core, LinuxJoystickDevice, LinuxJoystickDevice_localtype, LinuxJoystickDevice);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinuxJoystickDevice = &Dtool_LinuxJoystickDevice;
static void Dtool_PyModuleClassInit_LinuxJoystickDevice(PyObject *module);
bool Dtool_ConstCoerce_LinuxJoystickDevice(PyObject *args, CPT(LinuxJoystickDevice) &coerced);
bool Dtool_Coerce_LinuxJoystickDevice(PyObject *args, PT(LinuxJoystickDevice) &coerced);

/**
 * Forward declarations for top-level class TrackerNode
 */
typedef TrackerNode TrackerNode_localtype;
Define_Module_ClassRef(panda3d.core, TrackerNode, TrackerNode_localtype, TrackerNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TrackerNode = &Dtool_TrackerNode;
static void Dtool_PyModuleClassInit_TrackerNode(PyObject *module);

/**
 * Forward declarations for top-level class VirtualMouse
 */
typedef VirtualMouse VirtualMouse_localtype;
Define_Module_ClassRef(panda3d.core, VirtualMouse, VirtualMouse_localtype, VirtualMouse);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualMouse = &Dtool_VirtualMouse;
static void Dtool_PyModuleClassInit_VirtualMouse(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"TrackerData", &Dtool_TrackerData},
  {"InputDevice", &Dtool_InputDevice},
  {"InputDevice::ButtonState", &Dtool_InputDevice_ButtonState},
  {"InputDevice::AxisState", &Dtool_InputDevice_AxisState},
  {"InputDevice::BatteryData", &Dtool_InputDevice_BatteryData},
  {"ClientBase", &Dtool_ClientBase},
  {"AnalogNode", &Dtool_AnalogNode},
  {"ButtonNode", &Dtool_ButtonNode},
  {"DialNode", &Dtool_DialNode},
  {"InputDeviceSet", &Dtool_InputDeviceSet},
  {"InputDeviceManager", &Dtool_InputDeviceManager},
  {"InputDeviceNode", &Dtool_InputDeviceNode},
  {"LinuxJoystickDevice", &Dtool_LinuxJoystickDevice},
  {"TrackerNode", &Dtool_TrackerNode},
  {"VirtualMouse", &Dtool_VirtualMouse},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[1].type)
  {"ButtonHandle", nullptr},
#define Dtool_Ptr_ButtonHandle (imports[2].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[3].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[4].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[5].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[6].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[7].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[8].type)
  {"LPoint3f", nullptr},
#define Dtool_Ptr_LPoint3f (imports[9].type)
  {"LMatrix4f", nullptr},
#define Dtool_Ptr_LMatrix4f (imports[10].type)
  {"LOrientationf", nullptr},
#define Dtool_Ptr_LOrientationf (imports[11].type)
  {"PointerData", nullptr},
#define Dtool_Ptr_PointerData (imports[12].type)
  {"PointerEventList", nullptr},
#define Dtool_Ptr_PointerEventList (imports[13].type)
  {"ButtonEventList", nullptr},
#define Dtool_Ptr_ButtonEventList (imports[14].type)
  {"PandaNode", nullptr},
#define Dtool_Ptr_PandaNode (imports[15].type)
  {"DataNode", nullptr},
#define Dtool_Ptr_DataNode (imports[16].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// ButtonHandle
#ifndef LINK_ALL_STATIC
inline static ButtonHandle *Dtool_Coerce_ButtonHandle(PyObject *args, ButtonHandle &coerced) {
  nassertr(Dtool_Ptr_ButtonHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_ButtonHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((ButtonHandle *(*)(PyObject *, ButtonHandle &))Dtool_Ptr_ButtonHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_ButtonHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ButtonHandle = &Dtool_ButtonHandle;
extern ButtonHandle *Dtool_Coerce_ButtonHandle(PyObject *args, ButtonHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// LOrientationf
#ifndef LINK_ALL_STATIC
inline static LOrientationf *Dtool_Coerce_LOrientationf(PyObject *args, LOrientationf &coerced) {
  nassertr(Dtool_Ptr_LOrientationf != nullptr, nullptr);
  nassertr(Dtool_Ptr_LOrientationf->_Dtool_Coerce != nullptr, nullptr);
  return ((LOrientationf *(*)(PyObject *, LOrientationf &))Dtool_Ptr_LOrientationf->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LOrientationf;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LOrientationf = &Dtool_LOrientationf;
extern LOrientationf *Dtool_Coerce_LOrientationf(PyObject *args, LOrientationf &coerced);
#endif
// PointerData
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PointerData;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerData = &Dtool_PointerData;
#endif
// PointerEventList
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PointerEventList;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerEventList = &Dtool_PointerEventList;
#endif
// ButtonEventList
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ButtonEventList;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ButtonEventList = &Dtool_ButtonEventList;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// DataNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DataNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DataNode = &Dtool_DataNode;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class TrackerData
 */
static PyObject *Dtool_TrackerData_time_Getter(PyObject *self, void *) {
  const TrackerData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrackerData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double TrackerData::get_time(void) const
  double return_value = ((*(const TrackerData*)local_this).get_time)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TrackerData_time_Setter(PyObject *self, PyObject *arg, void *) {
  TrackerData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrackerData, (void **)&local_this, "TrackerData.time")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete time attribute");
    return -1;
  }
  // 1-inline void TrackerData::set_time(double time)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_time)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_time(const TrackerData self, double time)\n");
  }
  return -1;
}

static PyObject *Dtool_TrackerData_pos_Getter(PyObject *self, void *) {
  const TrackerData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrackerData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint3 const &TrackerData::get_pos(void) const
  LPoint3 const *return_value = &(((*(const TrackerData*)local_this).get_pos)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

static int Dtool_TrackerData_pos_Setter(PyObject *self, PyObject *arg, void *) {
  TrackerData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrackerData, (void **)&local_this, "TrackerData.pos")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete pos attribute");
    return -1;
  }
  // 1-inline void TrackerData::set_pos(LPoint3 const &pos)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TrackerData.set_pos", "LPoint3f");
    return -1;
  }
  ((*local_this).set_pos)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_pos(const TrackerData self, const LPoint3f pos)\n");
  }
  return -1;
}

static PyObject *Dtool_TrackerData_orient_Getter(PyObject *self, void *) {
  const TrackerData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrackerData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LOrientation const &TrackerData::get_orient(void) const
  LOrientation const *return_value = &(((*(const TrackerData*)local_this).get_orient)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LOrientationf, false, true);
}

static int Dtool_TrackerData_orient_Setter(PyObject *self, PyObject *arg, void *) {
  TrackerData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrackerData, (void **)&local_this, "TrackerData.orient")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete orient attribute");
    return -1;
  }
  // 1-inline void TrackerData::set_orient(LOrientation const &orient)
  LOrientationf arg_local;
  LOrientation const *arg_this = Dtool_Coerce_LOrientationf(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "TrackerData.set_orient", "LOrientationf");
    return -1;
  }
  ((*local_this).set_orient)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_orient(const TrackerData self, const LOrientationf orient)\n");
  }
  return -1;
}

static PyObject *Dtool_TrackerData_dt_Getter(PyObject *self, void *) {
  const TrackerData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrackerData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double TrackerData::get_dt(void) const
  double return_value = ((*(const TrackerData*)local_this).get_dt)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_TrackerData_dt_Setter(PyObject *self, PyObject *arg, void *) {
  TrackerData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrackerData, (void **)&local_this, "TrackerData.dt")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete dt attribute");
    return -1;
  }
  // 1-inline void TrackerData::set_dt(double dt)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_dt)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_dt(const TrackerData self, double dt)\n");
  }
  return -1;
}

static int Dtool_Init_TrackerData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TrackerData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TrackerData) {
    printf("TrackerData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TrackerData *local_this = (TrackerData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TrackerData) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TrackerData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TrackerData) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class InputDevice
 */
/**
 * Python function wrapper for:
 * inline bool InputDevice::has_feature(InputDevice::Feature feature) const
 */
static PyObject *Dtool_InputDevice_has_feature_80(PyObject *self, PyObject *arg) {
  InputDevice *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InputDevice)) {
    return nullptr;
  }
  // 1-inline bool InputDevice::has_feature(InputDevice::Feature feature) const
  long arg_val;
  arg_val = Dtool_EnumValue_AsLong(arg);
  if (arg_val != -1) {
    bool return_value = ((*(const InputDevice*)local_this).has_feature)((InputDevice::Feature)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_feature(InputDevice self, Feature feature)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InputDevice_has_feature_80_comment =
  "C++ Interface:\n"
  "has_feature(InputDevice self, Feature feature)\n"
  "\n"
  "// Determine supported features\n"
  "\n"
  "/**\n"
  " * Returns true if the device supports the indicated feature.\n"
  " */";
#else
static const char *Dtool_InputDevice_has_feature_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void InputDevice::map_button(std::size_t index, ButtonHandle handle)
 */
static PyObject *Dtool_InputDevice_map_button_93(PyObject *self, PyObject *args, PyObject *kwds) {
  InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDevice, (void **)&local_this, "InputDevice.map_button")) {
    return nullptr;
  }
  // 1-inline void InputDevice::map_button(std::size_t index, ButtonHandle handle)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:map_button", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ButtonHandle param2_local;
    ButtonHandle *param2_this = Dtool_Coerce_ButtonHandle(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "InputDevice.map_button", "ButtonHandle");
    }
    ((*local_this).map_button)((std::size_t)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "map_button(const InputDevice self, int index, ButtonHandle handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InputDevice_map_button_93_comment =
  "C++ Interface:\n"
  "map_button(const InputDevice self, int index, ButtonHandle handle)\n"
  "\n"
  "// Associate buttons/axes with symbolic handles.\n"
  "\n"
  "/**\n"
  " * Associates the indicated ButtonHandle with the button of the indicated index\n"
  " * number.  When the given button index changes state, a corresponding\n"
  " * ButtonEvent will be generated with the given ButtonHandle.  Pass\n"
  " * ButtonHandle::none() to turn off any association.\n"
  " *\n"
  " * It is not necessary to call this if you simply want to query the state of\n"
  " * the various buttons by index number; this is only necessary in order to\n"
  " * generate ButtonEvents when the buttons change state.\n"
  " */";
#else
static const char *Dtool_InputDevice_map_button_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void InputDevice::map_axis(std::size_t index, InputDevice::Axis axis)
 */
static PyObject *Dtool_InputDevice_map_axis_94(PyObject *self, PyObject *args, PyObject *kwds) {
  InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDevice, (void **)&local_this, "InputDevice.map_axis")) {
    return nullptr;
  }
  // 1-inline void InputDevice::map_axis(std::size_t index, InputDevice::Axis axis)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "axis", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:map_axis", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    long param2_val;
    param2_val = Dtool_EnumValue_AsLong(param2);
    if (param2_val != -1) {
      ((*local_this).map_axis)((std::size_t)param1, (InputDevice::Axis)param2_val);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "map_axis(const InputDevice self, int index, Axis axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InputDevice_map_axis_94_comment =
  "C++ Interface:\n"
  "map_axis(const InputDevice self, int index, Axis axis)\n"
  "\n"
  "/**\n"
  " * Associates the indicated Axis with the axis of the indicated index\n"
  " * number.  Pass Axis::none to turn off any association.\n"
  " *\n"
  " * It is not necessary to call this if you simply want to query the state of\n"
  " * the various axes by index number.\n"
  " */";
#else
static const char *Dtool_InputDevice_map_axis_94_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline InputDevice::ButtonState InputDevice::find_button(ButtonHandle handle) const
 */
static PyObject *Dtool_InputDevice_find_button_95(PyObject *self, PyObject *arg) {
  InputDevice *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InputDevice)) {
    return nullptr;
  }
  // 1-inline InputDevice::ButtonState InputDevice::find_button(ButtonHandle handle) const
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "InputDevice.find_button", "ButtonHandle");
  }
  InputDevice::ButtonState *return_value = new InputDevice::ButtonState(((*(const InputDevice*)local_this).find_button)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InputDevice_ButtonState, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_button(InputDevice self, ButtonHandle handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InputDevice_find_button_95_comment =
  "C++ Interface:\n"
  "find_button(InputDevice self, ButtonHandle handle)\n"
  "\n"
  "/**\n"
  " * Returns the first ButtonState found with the given axis, or throw an assert\n"
  " * if the button handle was not found in the list.\n"
  " */";
#else
static const char *Dtool_InputDevice_find_button_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline InputDevice::AxisState InputDevice::find_axis(InputDevice::Axis axis) const
 */
static PyObject *Dtool_InputDevice_find_axis_96(PyObject *self, PyObject *arg) {
  InputDevice *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InputDevice)) {
    return nullptr;
  }
  // 1-inline InputDevice::AxisState InputDevice::find_axis(InputDevice::Axis axis) const
  long arg_val;
  arg_val = Dtool_EnumValue_AsLong(arg);
  if (arg_val != -1) {
    InputDevice::AxisState *return_value = new InputDevice::AxisState(((*(const InputDevice*)local_this).find_axis)((InputDevice::Axis)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InputDevice_AxisState, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_axis(InputDevice self, Axis axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InputDevice_find_axis_96_comment =
  "C++ Interface:\n"
  "find_axis(InputDevice self, Axis axis)\n"
  "\n"
  "/**\n"
  " * Returns the first AnalogAxis found with the given axis, or throw an assert\n"
  " * if the axis was not found in the list.\n"
  " */";
#else
static const char *Dtool_InputDevice_find_axis_96_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void InputDevice::set_vibration(double strong, double weak)
 */
static PyObject *Dtool_InputDevice_set_vibration_97(PyObject *self, PyObject *args, PyObject *kwds) {
  InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDevice, (void **)&local_this, "InputDevice.set_vibration")) {
    return nullptr;
  }
  // 1-inline void InputDevice::set_vibration(double strong, double weak)
  double param1;
  double param2;
  static const char *keyword_list[] = {"strong", "weak", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:set_vibration", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_vibration)((double)param1, (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vibration(const InputDevice self, double strong, double weak)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InputDevice_set_vibration_97_comment =
  "C++ Interface:\n"
  "set_vibration(const InputDevice self, double strong, double weak)\n"
  "\n"
  "// Enable rumble force-feedback effects\n"
  "\n"
  "/**\n"
  " * Sets the strength of the vibration effect, if supported.  The values are\n"
  " * clamped to 0-1 range. The first value axes the low-frequency rumble\n"
  " * motor, whereas the second axes the high-frequency motor, if present.\n"
  " */";
#else
static const char *Dtool_InputDevice_set_vibration_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void InputDevice::enable_pointer_events(void)
 */
static PyObject *Dtool_InputDevice_enable_pointer_events_98(PyObject *self, PyObject *) {
  InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDevice, (void **)&local_this, "InputDevice.enable_pointer_events")) {
    return nullptr;
  }
  // 1-inline void InputDevice::enable_pointer_events(void)
  ((*local_this).enable_pointer_events)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_InputDevice_enable_pointer_events_98_comment =
  "C++ Interface:\n"
  "enable_pointer_events(const InputDevice self)\n"
  "\n"
  "/**\n"
  " * Enables the generation of mouse-movement events.\n"
  " */";
#else
static const char *Dtool_InputDevice_enable_pointer_events_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void InputDevice::disable_pointer_events(void)
 */
static PyObject *Dtool_InputDevice_disable_pointer_events_99(PyObject *self, PyObject *) {
  InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDevice, (void **)&local_this, "InputDevice.disable_pointer_events")) {
    return nullptr;
  }
  // 1-inline void InputDevice::disable_pointer_events(void)
  ((*local_this).disable_pointer_events)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_InputDevice_disable_pointer_events_99_comment =
  "C++ Interface:\n"
  "disable_pointer_events(const InputDevice self)\n"
  "\n"
  "/**\n"
  " * Disables the generation of mouse-movement events.\n"
  " */";
#else
static const char *Dtool_InputDevice_disable_pointer_events_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void InputDevice::poll(void)
 */
static PyObject *Dtool_InputDevice_poll_100(PyObject *self, PyObject *) {
  InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDevice, (void **)&local_this, "InputDevice.poll")) {
    return nullptr;
  }
  // 1-void InputDevice::poll(void)
  ((*local_this).poll)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_InputDevice_poll_100_comment =
  "C++ Interface:\n"
  "poll(const InputDevice self)\n"
  "\n"
  "/**\n"
  " * Polls the input device for new activity, to ensure it contains the latest\n"
  " * events.  This will only have any effect for some types of input devices;\n"
  " * others may be updated automatically, and this method will be a no-op.\n"
  " */";
#else
static const char *Dtool_InputDevice_poll_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool InputDevice::has_button_event(void) const
 */
static PyObject *Dtool_InputDevice_has_button_event_101(PyObject *self, PyObject *) {
  InputDevice *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InputDevice)) {
    return nullptr;
  }
  // 1-bool InputDevice::has_button_event(void) const
  bool return_value = ((*(const InputDevice*)local_this).has_button_event)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_InputDevice_has_button_event_101_comment =
  "C++ Interface:\n"
  "has_button_event(InputDevice self)\n"
  "\n"
  "/**\n"
  " * Returns true if this device has a pending button event (a mouse button or\n"
  " * keyboard button down/up), false otherwise.  If this returns true, the\n"
  " * particular event may be extracted via get_button_event().\n"
  " */";
#else
static const char *Dtool_InputDevice_has_button_event_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< ButtonEventList > InputDevice::get_button_events(void)
 */
static PyObject *Dtool_InputDevice_get_button_events_102(PyObject *self, PyObject *) {
  InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDevice, (void **)&local_this, "InputDevice.get_button_events")) {
    return nullptr;
  }
  // 1-PointerTo< ButtonEventList > InputDevice::get_button_events(void)
  PointerTo< ButtonEventList > return_value = ((*local_this).get_button_events)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  ButtonEventList *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_ButtonEventList, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_InputDevice_get_button_events_102_comment =
  "C++ Interface:\n"
  "get_button_events(const InputDevice self)\n"
  "\n"
  "/**\n"
  " * Returns the list of recently-generated ButtonEvents.\n"
  " * The list is also cleared.\n"
  " */";
#else
static const char *Dtool_InputDevice_get_button_events_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool InputDevice::has_pointer_event(void) const
 */
static PyObject *Dtool_InputDevice_has_pointer_event_103(PyObject *self, PyObject *) {
  InputDevice *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InputDevice)) {
    return nullptr;
  }
  // 1-bool InputDevice::has_pointer_event(void) const
  bool return_value = ((*(const InputDevice*)local_this).has_pointer_event)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_InputDevice_has_pointer_event_103_comment =
  "C++ Interface:\n"
  "has_pointer_event(InputDevice self)\n"
  "\n"
  "/**\n"
  " * Returns true if this device has a pending pointer event (a mouse movement),\n"
  " * or false otherwise.  If this returns true, the particular event may be\n"
  " * extracted via get_pointer_event().\n"
  " */";
#else
static const char *Dtool_InputDevice_has_pointer_event_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PointerEventList > InputDevice::get_pointer_events(void)
 */
static PyObject *Dtool_InputDevice_get_pointer_events_104(PyObject *self, PyObject *) {
  InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDevice, (void **)&local_this, "InputDevice.get_pointer_events")) {
    return nullptr;
  }
  // 1-PointerTo< PointerEventList > InputDevice::get_pointer_events(void)
  PointerTo< PointerEventList > return_value = ((*local_this).get_pointer_events)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  PointerEventList *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PointerEventList, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_InputDevice_get_pointer_events_104_comment =
  "C++ Interface:\n"
  "get_pointer_events(const InputDevice self)\n"
  "\n"
  "/**\n"
  " * Returns a PointerEventList containing all the recent pointer events.\n"
  " * Clears the list.\n"
  " */";
#else
static const char *Dtool_InputDevice_get_pointer_events_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void InputDevice::output(std::ostream &out) const
 */
static PyObject *Dtool_InputDevice_output_105(PyObject *self, PyObject *arg) {
  InputDevice *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InputDevice)) {
    return nullptr;
  }
  // 1-virtual void InputDevice::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "InputDevice.output", false, true);
  if (arg_this != nullptr) {
    ((*(const InputDevice*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(InputDevice self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InputDevice_output_105_comment =
  "C++ Interface:\n"
  "output(InputDevice self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a one-line string describing the device.\n"
  " */";
#else
static const char *Dtool_InputDevice_output_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle InputDevice::get_class_type(void)
 */
static PyObject *Dtool_InputDevice_get_class_type_121(PyObject *, PyObject *) {
  // 1-static TypeHandle InputDevice::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((InputDevice::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InputDevice_get_class_type_121_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_InputDevice_get_class_type_121_comment = nullptr;
#endif

static PyObject *Dtool_InputDevice_name_Getter(PyObject *self, void *) {
  const InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string InputDevice::get_name(void) const
  std::string return_value = ((*(const InputDevice*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_InputDevice_manufacturer_Getter(PyObject *self, void *) {
  const InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string InputDevice::get_manufacturer(void) const
  std::string return_value = ((*(const InputDevice*)local_this).get_manufacturer)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_InputDevice_serial_number_Getter(PyObject *self, void *) {
  const InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string InputDevice::get_serial_number(void) const
  std::string return_value = ((*(const InputDevice*)local_this).get_serial_number)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_InputDevice_vendor_id_Getter(PyObject *self, void *) {
  const InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline unsigned short int InputDevice::get_vendor_id(void) const
  unsigned short int return_value = ((*(const InputDevice*)local_this).get_vendor_id)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_InputDevice_product_id_Getter(PyObject *self, void *) {
  const InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline unsigned short int InputDevice::get_product_id(void) const
  unsigned short int return_value = ((*(const InputDevice*)local_this).get_product_id)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_InputDevice_connected_Getter(PyObject *self, void *) {
  const InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool InputDevice::is_connected(void) const
  bool return_value = ((*(const InputDevice*)local_this).is_connected)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_InputDevice_device_class_Getter(PyObject *self, void *) {
  const InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline InputDevice::DeviceClass InputDevice::get_device_class(void) const
  InputDevice::DeviceClass return_value = ((*(const InputDevice*)local_this).get_device_class)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return PyObject_CallFunction((PyObject *)Dtool_Ptr_InputDevice_DeviceClass, "l", (long)(return_value));
}

static PyObject *Dtool_InputDevice_tracker_Getter(PyObject *self, void *) {
  const InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_tracker()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline TrackerData InputDevice::get_tracker(void) const
  TrackerData *return_value = new TrackerData(((*(const InputDevice*)local_this).get_tracker)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TrackerData, true, false);
}

static PyObject *Dtool_InputDevice_battery_Getter(PyObject *self, void *) {
  const InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_battery()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline InputDevice::BatteryData InputDevice::get_battery(void) const
  InputDevice::BatteryData *return_value = new InputDevice::BatteryData(((*(const InputDevice*)local_this).get_battery)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InputDevice_BatteryData, true, false);
}

/**
 * sequence length function for property InputDevice::buttons
 */
static Py_ssize_t Dtool_InputDevice_buttons_Len(PyObject *self) {
  InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_buttons)();
}

/**
 * sequence getter for property InputDevice::buttons
 */
static PyObject *Dtool_InputDevice_buttons_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_buttons)()) {
    PyErr_SetString(PyExc_IndexError, "InputDevice.buttons[] index out of range");
    return nullptr;
  }
  // 1-inline InputDevice::ButtonState InputDevice::get_button(std::size_t index) const
  InputDevice::ButtonState *return_value = new InputDevice::ButtonState(((*(const InputDevice*)local_this).get_button)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InputDevice_ButtonState, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_button(InputDevice self, index)\n");
  }
}

static PyObject *Dtool_InputDevice_buttons_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "InputDevice.buttons");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_InputDevice_buttons_Len;
    wrap->_getitem_func = &Dtool_InputDevice_buttons_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property InputDevice::axes
 */
static Py_ssize_t Dtool_InputDevice_axes_Len(PyObject *self) {
  InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_axes)();
}

/**
 * sequence getter for property InputDevice::axes
 */
static PyObject *Dtool_InputDevice_axes_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_axes)()) {
    PyErr_SetString(PyExc_IndexError, "InputDevice.axes[] index out of range");
    return nullptr;
  }
  // 1-inline InputDevice::AxisState InputDevice::get_axis(std::size_t index) const
  InputDevice::AxisState *return_value = new InputDevice::AxisState(((*(const InputDevice*)local_this).get_axis)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InputDevice_AxisState, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_axis(InputDevice self, index)\n");
  }
}

static PyObject *Dtool_InputDevice_axes_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "InputDevice.axes");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_InputDevice_axes_Len;
    wrap->_getitem_func = &Dtool_InputDevice_axes_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

static PyObject *Dtool_InputDevice__pointer_data_Getter(PyObject *self, void *) {
  const InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice, (void **)&local_this)) {
    return nullptr;
  }

  // 1-PointerData const &InputDevice::get_pointer_data(void) const
  PointerData const *return_value = &(((const InputDevice*)local_this)->_pointer_data);
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerData, false, true);
}

static PyObject *Dtool_InputDevice__battery_data_Getter(PyObject *self, void *) {
  const InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice, (void **)&local_this)) {
    return nullptr;
  }

  // 1-InputDevice::BatteryData InputDevice::get_battery_data(void) const
  InputDevice::BatteryData *return_value = new InputDevice::BatteryData(((const InputDevice*)local_this)->_battery_data);
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InputDevice_BatteryData, true, false);
}

static PyObject *Dtool_InputDevice__tracker_data_Getter(PyObject *self, void *) {
  const InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice, (void **)&local_this)) {
    return nullptr;
  }

  // 1-TrackerData const &InputDevice::get_tracker_data(void) const
  TrackerData const *return_value = &(((const InputDevice*)local_this)->_tracker_data);
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TrackerData, false, true);
}

static int Dtool_Init_InputDevice(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_InputDevice(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_InputDevice) {
    printf("InputDevice ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  InputDevice *local_this = (InputDevice *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_InputDevice) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_InputDevice(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_InputDevice) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (InputDevice*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (InputDevice*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (InputDevice*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class InputDevice::ButtonState
 */
static PyObject *Dtool_InputDevice_ButtonState_known_Getter(PyObject *self, void *) {
  const InputDevice::ButtonState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice_ButtonState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool InputDevice::ButtonState::is_known(void) const
  bool return_value = ((*(const InputDevice::ButtonState*)local_this).is_known)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_InputDevice_ButtonState_pressed_Getter(PyObject *self, void *) {
  const InputDevice::ButtonState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice_ButtonState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool InputDevice::ButtonState::is_pressed(void) const
  bool return_value = ((*(const InputDevice::ButtonState*)local_this).is_pressed)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_InputDevice_ButtonState_handle_Getter(PyObject *self, void *) {
  const InputDevice::ButtonState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice_ButtonState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-ButtonHandle InputDevice::ButtonState::get_handle(void) const
  ButtonHandle *return_value = new ButtonHandle(((const InputDevice::ButtonState*)local_this)->handle);
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

/**
 * Python function wrapper for:
 * inline InputDevice::ButtonState::ButtonState(InputDevice::ButtonState const &) = default
 */
static int Dtool_Init_InputDevice_ButtonState(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("ButtonState() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline InputDevice::ButtonState::ButtonState(InputDevice::ButtonState const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    InputDevice::ButtonState const *param0_this = (InputDevice::ButtonState *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_InputDevice_ButtonState, 0, "ButtonState.ButtonState", true, true);
    if (param0_this != nullptr) {
      InputDevice::ButtonState *return_value = new InputDevice::ButtonState(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InputDevice_ButtonState, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ButtonState(const ButtonState param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_InputDevice_ButtonState(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_InputDevice_ButtonState) {
    printf("InputDevice_ButtonState ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  InputDevice::ButtonState *local_this = (InputDevice::ButtonState *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_InputDevice_ButtonState) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_InputDevice_ButtonState(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_InputDevice_ButtonState) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class InputDevice::AxisState
 */
static PyObject *Dtool_InputDevice_AxisState_axis_Getter(PyObject *self, void *) {
  const InputDevice::AxisState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice_AxisState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-InputDevice::Axis InputDevice::AxisState::get_axis(void) const
  InputDevice::Axis return_value = ((const InputDevice::AxisState*)local_this)->axis;
  return PyObject_CallFunction((PyObject *)Dtool_Ptr_InputDevice_Axis, "l", (long)(return_value));
}

static int Dtool_InputDevice_AxisState_axis_Setter(PyObject *self, PyObject *arg, void *) {
  InputDevice::AxisState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDevice_AxisState, (void **)&local_this, "InputDevice::AxisState.axis")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete axis attribute");
    return -1;
  }
  // 1-void InputDevice::AxisState::set_axis(InputDevice::Axis value)
  long arg_val;
  arg_val = Dtool_EnumValue_AsLong(arg);
  if (arg_val != -1) {
    (local_this)->axis = (InputDevice::Axis)arg_val;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_axis(const AxisState self, Axis value)\n");
  }
  return -1;
}

static PyObject *Dtool_InputDevice_AxisState_value_Getter(PyObject *self, void *) {
  const InputDevice::AxisState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice_AxisState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-double InputDevice::AxisState::get_value(void) const
  double return_value = ((const InputDevice::AxisState*)local_this)->value;
  return Dtool_WrapValue(return_value);
}

static int Dtool_InputDevice_AxisState_value_Setter(PyObject *self, PyObject *arg, void *) {
  InputDevice::AxisState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDevice_AxisState, (void **)&local_this, "InputDevice::AxisState.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-void InputDevice::AxisState::set_value(double value)
  if (PyNumber_Check(arg)) {
    (local_this)->value = PyFloat_AsDouble(arg);
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const AxisState self, double value)\n");
  }
  return -1;
}

static PyObject *Dtool_InputDevice_AxisState_known_Getter(PyObject *self, void *) {
  const InputDevice::AxisState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice_AxisState, (void **)&local_this)) {
    return nullptr;
  }

  // 1-bool InputDevice::AxisState::get_known(void) const
  bool return_value = ((const InputDevice::AxisState*)local_this)->known;
  return Dtool_WrapValue(return_value);
}

static int Dtool_InputDevice_AxisState_known_Setter(PyObject *self, PyObject *arg, void *) {
  InputDevice::AxisState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDevice_AxisState, (void **)&local_this, "InputDevice::AxisState.known")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete known attribute");
    return -1;
  }
  // 1-void InputDevice::AxisState::set_known(bool value)
  (local_this)->known = (PyObject_IsTrue(arg) != 0);
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_known(const AxisState self, bool value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline InputDevice::AxisState::AxisState(InputDevice::AxisState const &) = default
 */
static int Dtool_Init_InputDevice_AxisState(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("AxisState() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline InputDevice::AxisState::AxisState(InputDevice::AxisState const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    InputDevice::AxisState const *param0_this = (InputDevice::AxisState *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_InputDevice_AxisState, 0, "AxisState.AxisState", true, true);
    if (param0_this != nullptr) {
      InputDevice::AxisState *return_value = new InputDevice::AxisState(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InputDevice_AxisState, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AxisState(const AxisState param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_InputDevice_AxisState(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_InputDevice_AxisState) {
    printf("InputDevice_AxisState ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  InputDevice::AxisState *local_this = (InputDevice::AxisState *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_InputDevice_AxisState) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_InputDevice_AxisState(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_InputDevice_AxisState) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class InputDevice::BatteryData
 */
static PyObject *Dtool_InputDevice_BatteryData_level_Getter(PyObject *self, void *) {
  const InputDevice::BatteryData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice_BatteryData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-short int InputDevice::BatteryData::get_level(void) const
  short int return_value = ((const InputDevice::BatteryData*)local_this)->level;
  return Dtool_WrapValue(return_value);
}

static int Dtool_InputDevice_BatteryData_level_Setter(PyObject *self, PyObject *arg, void *) {
  InputDevice::BatteryData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDevice_BatteryData, (void **)&local_this, "InputDevice::BatteryData.level")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete level attribute");
    return -1;
  }
  // 1-void InputDevice::BatteryData::set_level(short int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (arg_val < SHRT_MIN || arg_val > SHRT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed short integer",
                   arg_val);
      return -1;
    }
#endif
    (local_this)->level = (short int)arg_val;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_level(const BatteryData self, int value)\n");
  }
  return -1;
}

static PyObject *Dtool_InputDevice_BatteryData_max_level_Getter(PyObject *self, void *) {
  const InputDevice::BatteryData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice_BatteryData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-short int InputDevice::BatteryData::get_max_level(void) const
  short int return_value = ((const InputDevice::BatteryData*)local_this)->max_level;
  return Dtool_WrapValue(return_value);
}

static int Dtool_InputDevice_BatteryData_max_level_Setter(PyObject *self, PyObject *arg, void *) {
  InputDevice::BatteryData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDevice_BatteryData, (void **)&local_this, "InputDevice::BatteryData.max_level")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete max_level attribute");
    return -1;
  }
  // 1-void InputDevice::BatteryData::set_max_level(short int value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (arg_val < SHRT_MIN || arg_val > SHRT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed short integer",
                   arg_val);
      return -1;
    }
#endif
    (local_this)->max_level = (short int)arg_val;
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_level(const BatteryData self, int value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline InputDevice::BatteryData::BatteryData(void) = default
 * inline InputDevice::BatteryData::BatteryData(InputDevice::BatteryData const &) = default
 */
static int Dtool_Init_InputDevice_BatteryData(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("BatteryData() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline InputDevice::BatteryData::BatteryData(void) = default
      InputDevice::BatteryData *return_value = new InputDevice::BatteryData();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InputDevice_BatteryData, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline InputDevice::BatteryData::BatteryData(InputDevice::BatteryData const &) = default
      InputDevice::BatteryData const *arg_this = (InputDevice::BatteryData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InputDevice_BatteryData, 0, "BatteryData.BatteryData", true, true);
      if (arg_this != nullptr) {
        InputDevice::BatteryData *return_value = new InputDevice::BatteryData(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InputDevice_BatteryData, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BatteryData() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BatteryData()\n"
      "BatteryData(const BatteryData param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_InputDevice_BatteryData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_InputDevice_BatteryData) {
    printf("InputDevice_BatteryData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  InputDevice::BatteryData *local_this = (InputDevice::BatteryData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_InputDevice_BatteryData) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_InputDevice_BatteryData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_InputDevice_BatteryData) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ClientBase
 */
/**
 * Python function wrapper for:
 * bool ClientBase::fork_asynchronous_thread(double poll_time)
 */
static PyObject *Dtool_ClientBase_fork_asynchronous_thread_123(PyObject *self, PyObject *arg) {
  ClientBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClientBase, (void **)&local_this, "ClientBase.fork_asynchronous_thread")) {
    return nullptr;
  }
  // 1-bool ClientBase::fork_asynchronous_thread(double poll_time)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).fork_asynchronous_thread)(PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fork_asynchronous_thread(const ClientBase self, double poll_time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClientBase_fork_asynchronous_thread_123_comment =
  "C++ Interface:\n"
  "fork_asynchronous_thread(const ClientBase self, double poll_time)\n"
  "\n"
  "/**\n"
  " * Forks a separate thread to do all the polling of connected devices.  The\n"
  " * forked thread will poll after every poll_time seconds has elapsed.  Returns\n"
  " * true if the fork was successful, or false otherwise (for instance, because\n"
  " * we were already forked, or because asynchronous threads are disabled).\n"
  " */";
#else
static const char *Dtool_ClientBase_fork_asynchronous_thread_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ClientBase::is_forked(void) const
 */
static PyObject *Dtool_ClientBase_is_forked_124(PyObject *self, PyObject *) {
  ClientBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClientBase)) {
    return nullptr;
  }
  // 1-inline bool ClientBase::is_forked(void) const
  bool return_value = ((*(const ClientBase*)local_this).is_forked)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClientBase_is_forked_124_comment =
  "C++ Interface:\n"
  "is_forked(ClientBase self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ClientBase has been forked (and, therefore, poll() does\n"
  " * not need to be called), false otherwise.\n"
  " */";
#else
static const char *Dtool_ClientBase_is_forked_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ClientBase::poll(void)
 */
static PyObject *Dtool_ClientBase_poll_125(PyObject *self, PyObject *) {
  ClientBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClientBase, (void **)&local_this, "ClientBase.poll")) {
    return nullptr;
  }
  // 1-inline bool ClientBase::poll(void)
  bool return_value = ((*local_this).poll)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClientBase_poll_125_comment =
  "C++ Interface:\n"
  "poll(const ClientBase self)\n"
  "\n"
  "/**\n"
  " * Initiates a poll of the client devices, if we are not forked and if we have\n"
  " * not already polled this frame.  Returns true if the poll occurred, or false\n"
  " * if it did not.\n"
  " */";
#else
static const char *Dtool_ClientBase_poll_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double ClientBase::get_last_poll_time(void) const
 */
static PyObject *Dtool_ClientBase_get_last_poll_time_126(PyObject *self, PyObject *) {
  ClientBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClientBase)) {
    return nullptr;
  }
  // 1-inline double ClientBase::get_last_poll_time(void) const
  double return_value = ((*(const ClientBase*)local_this).get_last_poll_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClientBase_get_last_poll_time_126_comment =
  "C++ Interface:\n"
  "get_last_poll_time(ClientBase self)\n"
  "\n"
  "/**\n"
  " * Returns the time (according to the global ClockObject's get_real_time()\n"
  " * method) of the last device poll.\n"
  " */";
#else
static const char *Dtool_ClientBase_get_last_poll_time_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ClientBase::set_coordinate_system(CoordinateSystem cs)
 */
static PyObject *Dtool_ClientBase_set_coordinate_system_127(PyObject *self, PyObject *arg) {
  ClientBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClientBase, (void **)&local_this, "ClientBase.set_coordinate_system")) {
    return nullptr;
  }
  // 1-inline void ClientBase::set_coordinate_system(CoordinateSystem cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_coordinate_system)((CoordinateSystem)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_coordinate_system(const ClientBase self, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClientBase_set_coordinate_system_127_comment =
  "C++ Interface:\n"
  "set_coordinate_system(const ClientBase self, int cs)\n"
  "\n"
  "/**\n"
  " * Specifies the coordinate system that all devices associated with this\n"
  " * client will operate in.  Normally, this is CS_default.\n"
  " */";
#else
static const char *Dtool_ClientBase_set_coordinate_system_127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem ClientBase::get_coordinate_system(void) const
 */
static PyObject *Dtool_ClientBase_get_coordinate_system_128(PyObject *self, PyObject *) {
  ClientBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClientBase)) {
    return nullptr;
  }
  // 1-inline CoordinateSystem ClientBase::get_coordinate_system(void) const
  CoordinateSystem return_value = ((*(const ClientBase*)local_this).get_coordinate_system)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClientBase_get_coordinate_system_128_comment =
  "C++ Interface:\n"
  "get_coordinate_system(ClientBase self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate system that all devices associated with this client\n"
  " * will operate in.  Normally, this is CS_default.\n"
  " */";
#else
static const char *Dtool_ClientBase_get_coordinate_system_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ClientBase::get_class_type(void)
 */
static PyObject *Dtool_ClientBase_get_class_type_129(PyObject *, PyObject *) {
  // 1-static TypeHandle ClientBase::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ClientBase::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ClientBase_get_class_type_129_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ClientBase_get_class_type_129_comment = nullptr;
#endif

static int Dtool_Init_ClientBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ClientBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ClientBase) {
    printf("ClientBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ClientBase *local_this = (ClientBase *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ClientBase) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ClientBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ClientBase) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ClientBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ClientBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ClientBase*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AnalogNode
 */
/**
 * Python function wrapper for:
 * inline bool AnalogNode::is_valid(void) const
 */
static PyObject *Dtool_AnalogNode_is_valid_133(PyObject *self, PyObject *) {
  AnalogNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnalogNode)) {
    return nullptr;
  }
  // 1-inline bool AnalogNode::is_valid(void) const
  bool return_value = ((*(const AnalogNode*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_is_valid_133_comment =
  "C++ Interface:\n"
  "is_valid(AnalogNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the AnalogNode is valid and connected to a server, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_AnalogNode_is_valid_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int AnalogNode::get_num_controls(void) const
 */
static PyObject *Dtool_AnalogNode_get_num_controls_134(PyObject *self, PyObject *) {
  AnalogNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnalogNode)) {
    return nullptr;
  }
  // 1-inline int AnalogNode::get_num_controls(void) const
  int return_value = ((*(const AnalogNode*)local_this).get_num_controls)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_get_num_controls_134_comment =
  "C++ Interface:\n"
  "get_num_controls(AnalogNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of analog controls known to the AnalogNode.  This number\n"
  " * may change as more controls are discovered.\n"
  " */";
#else
static const char *Dtool_AnalogNode_get_num_controls_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double AnalogNode::get_control_state(int index) const
 */
static PyObject *Dtool_AnalogNode_get_control_state_135(PyObject *self, PyObject *arg) {
  AnalogNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnalogNode)) {
    return nullptr;
  }
  // 1-inline double AnalogNode::get_control_state(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = ((*(const AnalogNode*)local_this).get_control_state)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_control_state(AnalogNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_get_control_state_135_comment =
  "C++ Interface:\n"
  "get_control_state(AnalogNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the current position of indicated analog control identified by its\n"
  " * index number, or 0.0 if the control is unknown.  The normal range of a\n"
  " * single control is -1.0 to 1.0.\n"
  " */";
#else
static const char *Dtool_AnalogNode_get_control_state_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AnalogNode::is_control_known(int index) const
 */
static PyObject *Dtool_AnalogNode_is_control_known_136(PyObject *self, PyObject *arg) {
  AnalogNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnalogNode)) {
    return nullptr;
  }
  // 1-inline bool AnalogNode::is_control_known(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const AnalogNode*)local_this).is_control_known)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_control_known(AnalogNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_is_control_known_136_comment =
  "C++ Interface:\n"
  "is_control_known(AnalogNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the state of the indicated analog control is known, or\n"
  " * false if we have never heard anything about this particular control.\n"
  " */";
#else
static const char *Dtool_AnalogNode_is_control_known_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AnalogNode::set_output(int channel, int index, bool flip)
 */
static PyObject *Dtool_AnalogNode_set_output_137(PyObject *self, PyObject *args, PyObject *kwds) {
  AnalogNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnalogNode, (void **)&local_this, "AnalogNode.set_output")) {
    return nullptr;
  }
  // 1-inline void AnalogNode::set_output(int channel, int index, bool flip)
  int param1;
  int param2;
  PyObject *param3;
  static const char *keyword_list[] = {"channel", "index", "flip", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_output", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_output)((int)param1, (int)param2, (PyObject_IsTrue(param3) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_output(const AnalogNode self, int channel, int index, bool flip)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_set_output_137_comment =
  "C++ Interface:\n"
  "set_output(const AnalogNode self, int channel, int index, bool flip)\n"
  "\n"
  "/**\n"
  " * Causes a particular analog control to be placed in the data graph for the\n"
  " * indicated channel.  Normally, a mouse uses channels 0 and 1 for the X and Y\n"
  " * information, respectively; channels 0, 1, and 2 are available.  If flip is\n"
  " * true, the analog control value will be reversed before outputting it.\n"
  " */";
#else
static const char *Dtool_AnalogNode_set_output_137_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AnalogNode::clear_output(int channel)
 */
static PyObject *Dtool_AnalogNode_clear_output_138(PyObject *self, PyObject *arg) {
  AnalogNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnalogNode, (void **)&local_this, "AnalogNode.clear_output")) {
    return nullptr;
  }
  // 1-inline void AnalogNode::clear_output(int channel)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).clear_output)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_output(const AnalogNode self, int channel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_clear_output_138_comment =
  "C++ Interface:\n"
  "clear_output(const AnalogNode self, int channel)\n"
  "\n"
  "/**\n"
  " * Removes the output to the data graph associated with the indicated channel.\n"
  " * See set_output().\n"
  " */";
#else
static const char *Dtool_AnalogNode_clear_output_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int AnalogNode::get_output(int channel) const
 */
static PyObject *Dtool_AnalogNode_get_output_139(PyObject *self, PyObject *arg) {
  AnalogNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnalogNode)) {
    return nullptr;
  }
  // 1-inline int AnalogNode::get_output(int channel) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const AnalogNode*)local_this).get_output)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_output(AnalogNode self, int channel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_get_output_139_comment =
  "C++ Interface:\n"
  "get_output(AnalogNode self, int channel)\n"
  "\n"
  "/**\n"
  " * Returns the analog control index that is output to the data graph on the\n"
  " * indicated channel, or -1 if no control is output on that channel.  See\n"
  " * set_output().\n"
  " */";
#else
static const char *Dtool_AnalogNode_get_output_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AnalogNode::is_output_flipped(int channel) const
 */
static PyObject *Dtool_AnalogNode_is_output_flipped_140(PyObject *self, PyObject *arg) {
  AnalogNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnalogNode)) {
    return nullptr;
  }
  // 1-inline bool AnalogNode::is_output_flipped(int channel) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const AnalogNode*)local_this).is_output_flipped)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_output_flipped(AnalogNode self, int channel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_is_output_flipped_140_comment =
  "C++ Interface:\n"
  "is_output_flipped(AnalogNode self, int channel)\n"
  "\n"
  "/**\n"
  " * Returns true if the analog control index that is output to the data graph\n"
  " * on the indicated channel is flipped.  See set_output().\n"
  " */";
#else
static const char *Dtool_AnalogNode_is_output_flipped_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnalogNode::get_class_type(void)
 */
static PyObject *Dtool_AnalogNode_get_class_type_141(PyObject *, PyObject *) {
  // 1-static TypeHandle AnalogNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AnalogNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnalogNode_get_class_type_141_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnalogNode_get_class_type_141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AnalogNode::AnalogNode(AnalogNode const &) = default
 * explicit AnalogNode::AnalogNode(ClientBase *client, std::string const &device_name)
 * explicit AnalogNode::AnalogNode(InputDevice *device)
 */
static int Dtool_Init_AnalogNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline AnalogNode::AnalogNode(AnalogNode const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          AnalogNode const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_AnalogNode);
          if (param0_this != nullptr) {
            AnalogNode *return_value = new AnalogNode(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnalogNode, true, false);
          }
        }
      }

      {
        // -2 explicit AnalogNode::AnalogNode(InputDevice *device)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "device")) {
          InputDevice *param0_this = (InputDevice *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_InputDevice, 0, "AnalogNode.AnalogNode", false, false);
          if (param0_this != nullptr) {
            AnalogNode *return_value = new AnalogNode(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnalogNode, true, false);
          }
        }
      }

      // No coercion possible: inline AnalogNode::AnalogNode(AnalogNode const &) = default
      // No coercion possible: explicit AnalogNode::AnalogNode(InputDevice *device)
    }
    break;
  case 2:
    {
      // 1-explicit AnalogNode::AnalogNode(ClientBase *client, std::string const &device_name)
      PyObject *param0;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"client", "device_name", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:AnalogNode", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
        ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ClientBase, 0, "AnalogNode.AnalogNode", false, true);
        if (param0_this != nullptr) {
          AnalogNode *return_value = new AnalogNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnalogNode, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AnalogNode() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AnalogNode(const AnalogNode param0)\n"
      "AnalogNode(InputDevice device)\n"
      "AnalogNode(ClientBase client, str device_name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AnalogNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AnalogNode) {
    printf("AnalogNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AnalogNode *local_this = (AnalogNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AnalogNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AnalogNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AnalogNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (AnalogNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnalogNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (AnalogNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnalogNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnalogNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnalogNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnalogNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ButtonNode
 */
/**
 * Python function wrapper for:
 * inline bool ButtonNode::is_valid(void) const
 */
static PyObject *Dtool_ButtonNode_is_valid_144(PyObject *self, PyObject *) {
  ButtonNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonNode)) {
    return nullptr;
  }
  // 1-inline bool ButtonNode::is_valid(void) const
  bool return_value = ((*(const ButtonNode*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonNode_is_valid_144_comment =
  "C++ Interface:\n"
  "is_valid(ButtonNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ButtonNode is valid and connected to a server, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_ButtonNode_is_valid_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ButtonNode::get_num_buttons(void) const
 */
static PyObject *Dtool_ButtonNode_get_num_buttons_145(PyObject *self, PyObject *) {
  ButtonNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonNode)) {
    return nullptr;
  }
  // 1-inline int ButtonNode::get_num_buttons(void) const
  int return_value = ((*(const ButtonNode*)local_this).get_num_buttons)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonNode_get_num_buttons_145_comment =
  "C++ Interface:\n"
  "get_num_buttons(ButtonNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of buttons known to the ButtonNode.  This includes those\n"
  " * buttons whose state has been seen, as well as buttons that have been\n"
  " * associated with a ButtonHandle even if their state is unknown.  This number\n"
  " * may change as more buttons are discovered.\n"
  " */";
#else
static const char *Dtool_ButtonNode_get_num_buttons_145_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ButtonNode::set_button_map(int index, ButtonHandle button)
 */
static PyObject *Dtool_ButtonNode_set_button_map_146(PyObject *self, PyObject *args, PyObject *kwds) {
  ButtonNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonNode, (void **)&local_this, "ButtonNode.set_button_map")) {
    return nullptr;
  }
  // 1-inline void ButtonNode::set_button_map(int index, ButtonHandle button)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "button", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_button_map", (char **)keyword_list, &param1, &param2)) {
    ButtonHandle param2_local;
    ButtonHandle *param2_this = Dtool_Coerce_ButtonHandle(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "ButtonNode.set_button_map", "ButtonHandle");
    }
    ((*local_this).set_button_map)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_button_map(const ButtonNode self, int index, ButtonHandle button)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonNode_set_button_map_146_comment =
  "C++ Interface:\n"
  "set_button_map(const ButtonNode self, int index, ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Associates the indicated ButtonHandle with the button of the indicated\n"
  " * index number.  When the given button index changes state, a corresponding\n"
  " * ButtonEvent will be generated with the given ButtonHandle.  Pass\n"
  " * ButtonHandle::none() to turn off any association.\n"
  " *\n"
  " * It is not necessary to call this if you simply want to query the state of\n"
  " * the various buttons by index number; this is only necessary in order to\n"
  " * generate ButtonEvents when the buttons change state.\n"
  " */";
#else
static const char *Dtool_ButtonNode_set_button_map_146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ButtonHandle ButtonNode::get_button_map(int index) const
 */
static PyObject *Dtool_ButtonNode_get_button_map_147(PyObject *self, PyObject *arg) {
  ButtonNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonNode)) {
    return nullptr;
  }
  // 1-inline ButtonHandle ButtonNode::get_button_map(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ButtonHandle *return_value = new ButtonHandle(((*(const ButtonNode*)local_this).get_button_map)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_button_map(ButtonNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonNode_get_button_map_147_comment =
  "C++ Interface:\n"
  "get_button_map(ButtonNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle that was previously associated with the given\n"
  " * index number by a call to set_button_map(), or ButtonHandle::none() if no\n"
  " * button was associated.\n"
  " */";
#else
static const char *Dtool_ButtonNode_get_button_map_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ButtonNode::get_button_state(int index) const
 */
static PyObject *Dtool_ButtonNode_get_button_state_148(PyObject *self, PyObject *arg) {
  ButtonNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonNode)) {
    return nullptr;
  }
  // 1-inline bool ButtonNode::get_button_state(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const ButtonNode*)local_this).get_button_state)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_button_state(ButtonNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonNode_get_button_state_148_comment =
  "C++ Interface:\n"
  "get_button_state(ButtonNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated button (identified by its index number) is\n"
  " * currently known to be down, or false if it is up or unknown.\n"
  " */";
#else
static const char *Dtool_ButtonNode_get_button_state_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ButtonNode::is_button_known(int index) const
 */
static PyObject *Dtool_ButtonNode_is_button_known_149(PyObject *self, PyObject *arg) {
  ButtonNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonNode)) {
    return nullptr;
  }
  // 1-inline bool ButtonNode::is_button_known(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const ButtonNode*)local_this).is_button_known)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_button_known(ButtonNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonNode_is_button_known_149_comment =
  "C++ Interface:\n"
  "is_button_known(ButtonNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the state of the indicated button is known, or false if we\n"
  " * have never heard anything about this particular button.\n"
  " */";
#else
static const char *Dtool_ButtonNode_is_button_known_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ButtonNode::get_class_type(void)
 */
static PyObject *Dtool_ButtonNode_get_class_type_150(PyObject *, PyObject *) {
  // 1-static TypeHandle ButtonNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ButtonNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ButtonNode_get_class_type_150_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ButtonNode_get_class_type_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ButtonNode::ButtonNode(ButtonNode const &) = default
 * explicit ButtonNode::ButtonNode(ClientBase *client, std::string const &device_name)
 * explicit ButtonNode::ButtonNode(InputDevice *device)
 */
static int Dtool_Init_ButtonNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline ButtonNode::ButtonNode(ButtonNode const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          ButtonNode const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_ButtonNode);
          if (param0_this != nullptr) {
            ButtonNode *return_value = new ButtonNode(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonNode, true, false);
          }
        }
      }

      {
        // -2 explicit ButtonNode::ButtonNode(InputDevice *device)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "device")) {
          InputDevice *param0_this = (InputDevice *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_InputDevice, 0, "ButtonNode.ButtonNode", false, false);
          if (param0_this != nullptr) {
            ButtonNode *return_value = new ButtonNode(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonNode, true, false);
          }
        }
      }

      // No coercion possible: inline ButtonNode::ButtonNode(ButtonNode const &) = default
      // No coercion possible: explicit ButtonNode::ButtonNode(InputDevice *device)
    }
    break;
  case 2:
    {
      // 1-explicit ButtonNode::ButtonNode(ClientBase *client, std::string const &device_name)
      PyObject *param0;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"client", "device_name", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:ButtonNode", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
        ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ClientBase, 0, "ButtonNode.ButtonNode", false, true);
        if (param0_this != nullptr) {
          ButtonNode *return_value = new ButtonNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonNode, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ButtonNode() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ButtonNode(const ButtonNode param0)\n"
      "ButtonNode(InputDevice device)\n"
      "ButtonNode(ClientBase client, str device_name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ButtonNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ButtonNode) {
    printf("ButtonNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ButtonNode *local_this = (ButtonNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ButtonNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ButtonNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ButtonNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (ButtonNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ButtonNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (ButtonNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ButtonNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ButtonNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ButtonNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ButtonNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DialNode
 */
/**
 * Python function wrapper for:
 * inline bool DialNode::is_valid(void) const
 */
static PyObject *Dtool_DialNode_is_valid_153(PyObject *self, PyObject *) {
  DialNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DialNode)) {
    return nullptr;
  }
  // 1-inline bool DialNode::is_valid(void) const
  bool return_value = ((*(const DialNode*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DialNode_is_valid_153_comment =
  "C++ Interface:\n"
  "is_valid(DialNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the DialNode is valid and connected to a server, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_DialNode_is_valid_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DialNode::get_num_dials(void) const
 */
static PyObject *Dtool_DialNode_get_num_dials_154(PyObject *self, PyObject *) {
  DialNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DialNode)) {
    return nullptr;
  }
  // 1-inline int DialNode::get_num_dials(void) const
  int return_value = ((*(const DialNode*)local_this).get_num_dials)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DialNode_get_num_dials_154_comment =
  "C++ Interface:\n"
  "get_num_dials(DialNode self)\n"
  "\n"
  "/**\n"
  " * Returns the number of dial dials known to the DialNode.  This number may\n"
  " * change as more dials are discovered.\n"
  " */";
#else
static const char *Dtool_DialNode_get_num_dials_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double DialNode::read_dial(int index)
 */
static PyObject *Dtool_DialNode_read_dial_155(PyObject *self, PyObject *arg) {
  DialNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DialNode, (void **)&local_this, "DialNode.read_dial")) {
    return nullptr;
  }
  // 1-inline double DialNode::read_dial(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    double return_value = ((*local_this).read_dial)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_dial(const DialNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DialNode_read_dial_155_comment =
  "C++ Interface:\n"
  "read_dial(const DialNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the number of complete revolutions of the dial since the last time\n"
  " * read_dial() was called.  This is a destructive operation; it is not\n"
  " * possible to read the dial without resetting the counter.\n"
  " */";
#else
static const char *Dtool_DialNode_read_dial_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DialNode::is_dial_known(int index) const
 */
static PyObject *Dtool_DialNode_is_dial_known_156(PyObject *self, PyObject *arg) {
  DialNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DialNode)) {
    return nullptr;
  }
  // 1-inline bool DialNode::is_dial_known(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const DialNode*)local_this).is_dial_known)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_dial_known(DialNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DialNode_is_dial_known_156_comment =
  "C++ Interface:\n"
  "is_dial_known(DialNode self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the state of the indicated dial dial is known, or false if\n"
  " * we have never heard anything about this particular dial.\n"
  " */";
#else
static const char *Dtool_DialNode_is_dial_known_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DialNode::get_class_type(void)
 */
static PyObject *Dtool_DialNode_get_class_type_157(PyObject *, PyObject *) {
  // 1-static TypeHandle DialNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((DialNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DialNode_get_class_type_157_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DialNode_get_class_type_157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit DialNode::DialNode(ClientBase *client, std::string const &device_name)
 * inline DialNode::DialNode(DialNode const &) = default
 */
static int Dtool_Init_DialNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline DialNode::DialNode(DialNode const &) = default
      DialNode const *arg_this = (DialNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DialNode, 0, "DialNode.DialNode", true, true);
      if (arg_this != nullptr) {
        DialNode *return_value = new DialNode(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DialNode, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-explicit DialNode::DialNode(ClientBase *client, std::string const &device_name)
      PyObject *param0;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"client", "device_name", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:DialNode", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
        ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ClientBase, 0, "DialNode.DialNode", false, true);
        if (param0_this != nullptr) {
          DialNode *return_value = new DialNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DialNode, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DialNode() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DialNode(const DialNode param0)\n"
      "DialNode(ClientBase client, str device_name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DialNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DialNode) {
    printf("DialNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DialNode *local_this = (DialNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DialNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DialNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DialNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (DialNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (DialNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (DialNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (DialNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (DialNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (DialNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (DialNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class InputDeviceSet
 */
/**
 * Python function wrapper for:
 * void InputDeviceSet::operator =(InputDeviceSet const &copy)
 */
static PyObject *Dtool_InputDeviceSet_operator_160(PyObject *self, PyObject *arg) {
  InputDeviceSet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDeviceSet, (void **)&local_this, "InputDeviceSet.assign")) {
    return nullptr;
  }
  // 1-void InputDeviceSet::operator =(InputDeviceSet const &copy)
  InputDeviceSet const *arg_this = (InputDeviceSet *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InputDeviceSet, 1, "InputDeviceSet.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    InputDeviceSet *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InputDeviceSet, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const InputDeviceSet self, const InputDeviceSet copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InputDeviceSet_operator_160_comment =
  "C++ Interface:\n"
  "assign(const InputDeviceSet self, const InputDeviceSet copy)\n";
#else
static const char *Dtool_InputDeviceSet_operator_160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void InputDeviceSet::clear(void)
 */
static PyObject *Dtool_InputDeviceSet_clear_162(PyObject *self, PyObject *) {
  InputDeviceSet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDeviceSet, (void **)&local_this, "InputDeviceSet.clear")) {
    return nullptr;
  }
  // 1-void InputDeviceSet::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_InputDeviceSet_clear_162_comment =
  "C++ Interface:\n"
  "clear(const InputDeviceSet self)\n"
  "\n"
  "/**\n"
  " * Removes all InputDevices from the collection.\n"
  " */";
#else
static const char *Dtool_InputDeviceSet_clear_162_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void InputDeviceSet::reserve(std::size_t num)
 */
static PyObject *Dtool_InputDeviceSet_reserve_163(PyObject *self, PyObject *arg) {
  InputDeviceSet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDeviceSet, (void **)&local_this, "InputDeviceSet.reserve")) {
    return nullptr;
  }
  // 1-void InputDeviceSet::reserve(std::size_t num)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).reserve)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reserve(const InputDeviceSet self, int num)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InputDeviceSet_reserve_163_comment =
  "C++ Interface:\n"
  "reserve(const InputDeviceSet self, int num)\n"
  "\n"
  "/**\n"
  " * This is a hint to Panda to allocate enough memory to hold the given number\n"
  " * of InputDevices, if you know ahead of time how many you will be adding.\n"
  " */";
#else
static const char *Dtool_InputDeviceSet_reserve_163_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void InputDeviceSet::output(std::ostream &out) const
 */
static PyObject *Dtool_InputDeviceSet_output_166(PyObject *self, PyObject *arg) {
  InputDeviceSet *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InputDeviceSet)) {
    return nullptr;
  }
  // 1-void InputDeviceSet::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "InputDeviceSet.output", false, true);
  if (arg_this != nullptr) {
    ((*(const InputDeviceSet*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(InputDeviceSet self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InputDeviceSet_output_166_comment =
  "C++ Interface:\n"
  "output(InputDeviceSet self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a brief one-line description of the InputDeviceSet to the indicated\n"
  " * output stream.\n"
  " */";
#else
static const char *Dtool_InputDeviceSet_output_166_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void InputDeviceSet::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_InputDeviceSet_write_167(PyObject *self, PyObject *args, PyObject *kwds) {
  InputDeviceSet *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InputDeviceSet)) {
    return nullptr;
  }
  // 1-void InputDeviceSet::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "InputDeviceSet.write", false, true);
    if (param1_this != nullptr) {
      ((*(const InputDeviceSet*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(InputDeviceSet self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InputDeviceSet_write_167_comment =
  "C++ Interface:\n"
  "write(InputDeviceSet self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a complete multi-line description of the InputDeviceSet to the\n"
  " * indicated output stream.\n"
  " */";
#else
static const char *Dtool_InputDeviceSet_write_167_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * InputDeviceSet::InputDeviceSet(void)
 * InputDeviceSet::InputDeviceSet(InputDeviceSet const &copy)
 */
static int Dtool_Init_InputDeviceSet(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-InputDeviceSet::InputDeviceSet(void)
      InputDeviceSet *return_value = new InputDeviceSet();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InputDeviceSet, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-InputDeviceSet::InputDeviceSet(InputDeviceSet const &copy)
        InputDeviceSet const *arg_this = (InputDeviceSet *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InputDeviceSet, 0, "InputDeviceSet.InputDeviceSet", true, true);
        if (arg_this != nullptr) {
          InputDeviceSet *return_value = new InputDeviceSet(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InputDeviceSet, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "InputDeviceSet() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "InputDeviceSet()\n"
      "InputDeviceSet(const InputDeviceSet copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_InputDeviceSet(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_InputDeviceSet) {
    printf("InputDeviceSet ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  InputDeviceSet *local_this = (InputDeviceSet *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_InputDeviceSet) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_InputDeviceSet(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_InputDeviceSet) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class InputDeviceManager
 */
/**
 * Python function wrapper for:
 * InputDeviceSet InputDeviceManager::get_devices(void) const
 * InputDeviceSet InputDeviceManager::get_devices(InputDevice::DeviceClass device_class) const
 */
static PyObject *Dtool_InputDeviceManager_get_devices_169(PyObject *self, PyObject *args) {
  InputDeviceManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_InputDeviceManager)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-InputDeviceSet InputDeviceManager::get_devices(void) const
      InputDeviceSet *return_value = new InputDeviceSet(((*(const InputDeviceManager*)local_this).get_devices)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InputDeviceSet, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-InputDeviceSet InputDeviceManager::get_devices(InputDevice::DeviceClass device_class) const
      long arg_val;
      arg_val = Dtool_EnumValue_AsLong(arg);
      if (arg_val != -1) {
        InputDeviceSet *return_value = new InputDeviceSet(((*(const InputDeviceManager*)local_this).get_devices)((InputDevice::DeviceClass)arg_val));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InputDeviceSet, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_devices() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_devices(InputDeviceManager self)\n"
      "get_devices(InputDeviceManager self, DeviceClass device_class)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InputDeviceManager_get_devices_169_comment =
  "C++ Interface:\n"
  "get_devices(InputDeviceManager self)\n"
  "get_devices(InputDeviceManager self, DeviceClass device_class)\n"
  "\n"
  "/**\n"
  " * Description: Returns all currently connected devices.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Description: Returns all currently connected devices of the given device class.\n"
  " */";
#else
static const char *Dtool_InputDeviceManager_get_devices_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void InputDeviceManager::add_device(InputDevice *device)
 */
static PyObject *Dtool_InputDeviceManager_add_device_170(PyObject *self, PyObject *arg) {
  InputDeviceManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDeviceManager, (void **)&local_this, "InputDeviceManager.add_device")) {
    return nullptr;
  }
  // 1-void InputDeviceManager::add_device(InputDevice *device)
  InputDevice *arg_this = (InputDevice *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InputDevice, 1, "InputDeviceManager.add_device", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_device)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_device(const InputDeviceManager self, InputDevice device)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InputDeviceManager_add_device_170_comment =
  "C++ Interface:\n"
  "add_device(const InputDeviceManager self, InputDevice device)\n"
  "\n"
  "/**\n"
  " * Called when a new device has been discovered.  This may also be used to\n"
  " * register virtual devices.\n"
  " *\n"
  " * This causes a connect-device event to be thrown.\n"
  " */";
#else
static const char *Dtool_InputDeviceManager_add_device_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void InputDeviceManager::remove_device(InputDevice *device)
 */
static PyObject *Dtool_InputDeviceManager_remove_device_171(PyObject *self, PyObject *arg) {
  InputDeviceManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDeviceManager, (void **)&local_this, "InputDeviceManager.remove_device")) {
    return nullptr;
  }
  // 1-void InputDeviceManager::remove_device(InputDevice *device)
  InputDevice *arg_this = (InputDevice *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InputDevice, 1, "InputDeviceManager.remove_device", false, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_device)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_device(const InputDeviceManager self, InputDevice device)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_InputDeviceManager_remove_device_171_comment =
  "C++ Interface:\n"
  "remove_device(const InputDeviceManager self, InputDevice device)\n"
  "\n"
  "/**\n"
  " * Called when a device has been removed, or when a device should otherwise no\n"
  " * longer be tracked.\n"
  " *\n"
  " * This causes a disconnect-device event to be thrown.\n"
  " */";
#else
static const char *Dtool_InputDeviceManager_remove_device_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void InputDeviceManager::update(void)
 */
static PyObject *Dtool_InputDeviceManager_update_172(PyObject *self, PyObject *) {
  InputDeviceManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDeviceManager, (void **)&local_this, "InputDeviceManager.update")) {
    return nullptr;
  }
  // 1-virtual void InputDeviceManager::update(void)
  ((*local_this).update)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_InputDeviceManager_update_172_comment =
  "C++ Interface:\n"
  "update(const InputDeviceManager self)\n"
  "\n"
  "/**\n"
  " * Polls the system to see if there are any new devices.  In some\n"
  " * implementations this is a no-op.\n"
  " */";
#else
static const char *Dtool_InputDeviceManager_update_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline InputDeviceManager *InputDeviceManager::get_global_ptr(void)
 */
static PyObject *Dtool_InputDeviceManager_get_global_ptr_173(PyObject *, PyObject *) {
  // 1-static inline InputDeviceManager *InputDeviceManager::get_global_ptr(void)
  InputDeviceManager *return_value = (InputDeviceManager::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_InputDeviceManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_InputDeviceManager_get_global_ptr_173_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns the singleton InputDeviceManager instance.\n"
  " */";
#else
static const char *Dtool_InputDeviceManager_get_global_ptr_173_comment = nullptr;
#endif

static int Dtool_Init_InputDeviceManager(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_InputDeviceManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_InputDeviceManager) {
    printf("InputDeviceManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  InputDeviceManager *local_this = (InputDeviceManager *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_InputDeviceManager) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_InputDeviceManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_InputDeviceManager) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class InputDeviceNode
 */
/**
 * Python function wrapper for:
 * static TypeHandle InputDeviceNode::get_class_type(void)
 */
static PyObject *Dtool_InputDeviceNode_get_class_type_180(PyObject *, PyObject *) {
  // 1-static TypeHandle InputDeviceNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((InputDeviceNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_InputDeviceNode_get_class_type_180_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_InputDeviceNode_get_class_type_180_comment = nullptr;
#endif

static PyObject *Dtool_InputDeviceNode_device_Getter(PyObject *self, void *) {
  const InputDeviceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDeviceNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-PointerTo< InputDevice > InputDeviceNode::get_device(void) const
  PointerTo< InputDevice > return_value = ((*(const InputDeviceNode*)local_this).get_device)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  InputDevice *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_InputDevice, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

static int Dtool_InputDeviceNode_device_Setter(PyObject *self, PyObject *arg, void *) {
  InputDeviceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_InputDeviceNode, (void **)&local_this, "InputDeviceNode.device")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete device attribute");
    return -1;
  }
  // 1-void InputDeviceNode::set_device(InputDevice *device)
  InputDevice *arg_this = (InputDevice *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_InputDevice, 1, "InputDeviceNode.set_device", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_device)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_device(const InputDeviceNode self, InputDevice device)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * InputDeviceNode::InputDeviceNode(InputDevice *device, std::string const &name)
 * inline InputDeviceNode::InputDeviceNode(InputDeviceNode const &) = default
 */
static int Dtool_Init_InputDeviceNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline InputDeviceNode::InputDeviceNode(InputDeviceNode const &) = default
      CPT(InputDeviceNode) arg_this;
      if (!Dtool_ConstCoerce_InputDeviceNode(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "InputDeviceNode.InputDeviceNode", "InputDeviceNode");
        return -1;
      }
      InputDeviceNode *return_value = new InputDeviceNode(*std::move(arg_this));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InputDeviceNode, true, false);
    }
    break;
  case 2:
    {
      // 1-InputDeviceNode::InputDeviceNode(InputDevice *device, std::string const &name)
      PyObject *param0;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"device", "name", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:InputDeviceNode", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
        InputDevice *param0_this = (InputDevice *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_InputDevice, 0, "InputDeviceNode.InputDeviceNode", false, true);
        if (param0_this != nullptr) {
          InputDeviceNode *return_value = new InputDeviceNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_InputDeviceNode, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "InputDeviceNode() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "InputDeviceNode(const InputDeviceNode param0)\n"
      "InputDeviceNode(InputDevice device, str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_InputDeviceNode(PyObject *args, CPT(InputDeviceNode) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_InputDeviceNode)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-InputDeviceNode::InputDeviceNode(InputDevice *device, std::string const &name)
      PyObject *param0;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:InputDeviceNode", &param0, &param1_str, &param1_len)) {
        InputDevice *param0_this = (InputDevice *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_InputDevice, 0, "InputDeviceNode.InputDeviceNode", false, false);
        if (param0_this != nullptr) {
          InputDeviceNode *return_value = new InputDeviceNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_InputDeviceNode(PyObject *args, PT(InputDeviceNode) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_InputDeviceNode)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-InputDeviceNode::InputDeviceNode(InputDevice *device, std::string const &name)
      PyObject *param0;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:InputDeviceNode", &param0, &param1_str, &param1_len)) {
        InputDevice *param0_this = (InputDevice *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_InputDevice, 0, "InputDeviceNode.InputDeviceNode", false, false);
        if (param0_this != nullptr) {
          InputDeviceNode *return_value = new InputDeviceNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_InputDeviceNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_InputDeviceNode) {
    printf("InputDeviceNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  InputDeviceNode *local_this = (InputDeviceNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_InputDeviceNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_InputDeviceNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_InputDeviceNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (InputDeviceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (InputDeviceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (InputDeviceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (InputDeviceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (InputDeviceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (InputDeviceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (InputDeviceNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LinuxJoystickDevice
 */
/**
 * Python function wrapper for:
 * bool LinuxJoystickDevice::check_events(void) const
 */
static PyObject *Dtool_LinuxJoystickDevice_check_events_184(PyObject *self, PyObject *) {
  LinuxJoystickDevice *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LinuxJoystickDevice)) {
    return nullptr;
  }
  // 1-bool LinuxJoystickDevice::check_events(void) const
  bool return_value = ((*(const LinuxJoystickDevice*)local_this).check_events)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinuxJoystickDevice_check_events_184_comment =
  "C++ Interface:\n"
  "check_events(LinuxJoystickDevice self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are pending events.\n"
  " */";
#else
static const char *Dtool_LinuxJoystickDevice_check_events_184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LinuxJoystickDevice::get_class_type(void)
 */
static PyObject *Dtool_LinuxJoystickDevice_get_class_type_185(PyObject *, PyObject *) {
  // 1-static TypeHandle LinuxJoystickDevice::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LinuxJoystickDevice::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinuxJoystickDevice_get_class_type_185_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinuxJoystickDevice_get_class_type_185_comment = nullptr;
#endif

static int Dtool_Init_LinuxJoystickDevice(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_LinuxJoystickDevice(PyObject *args, CPT(LinuxJoystickDevice) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LinuxJoystickDevice)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_LinuxJoystickDevice(PyObject *args, PT(LinuxJoystickDevice) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LinuxJoystickDevice)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LinuxJoystickDevice(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LinuxJoystickDevice) {
    printf("LinuxJoystickDevice ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LinuxJoystickDevice *local_this = (LinuxJoystickDevice *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LinuxJoystickDevice) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_InputDevice) {
    return (InputDevice *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(InputDevice *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(InputDevice *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(InputDevice *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LinuxJoystickDevice(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LinuxJoystickDevice) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_InputDevice) {
    InputDevice* other_this = (InputDevice*)from_this;
    return (LinuxJoystickDevice*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinuxJoystickDevice*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinuxJoystickDevice*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinuxJoystickDevice*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TrackerNode
 */
/**
 * Python function wrapper for:
 * inline bool TrackerNode::is_valid(void) const
 */
static PyObject *Dtool_TrackerNode_is_valid_188(PyObject *self, PyObject *) {
  TrackerNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TrackerNode)) {
    return nullptr;
  }
  // 1-inline bool TrackerNode::is_valid(void) const
  bool return_value = ((*(const TrackerNode*)local_this).is_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_is_valid_188_comment =
  "C++ Interface:\n"
  "is_valid(TrackerNode self)\n"
  "\n"
  "/**\n"
  " * Returns true if the TrackerNode is valid and connected to a server, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_TrackerNode_is_valid_188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 const &TrackerNode::get_pos(void) const
 */
static PyObject *Dtool_TrackerNode_get_pos_189(PyObject *self, PyObject *) {
  TrackerNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TrackerNode)) {
    return nullptr;
  }
  // 1-inline LPoint3 const &TrackerNode::get_pos(void) const
  LPoint3 const *return_value = &(((*(const TrackerNode*)local_this).get_pos)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_get_pos_189_comment =
  "C++ Interface:\n"
  "get_pos(TrackerNode self)\n"
  "\n"
  "/**\n"
  " * Returns the current position of the tracker, if it is available.\n"
  " */";
#else
static const char *Dtool_TrackerNode_get_pos_189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LOrientation const &TrackerNode::get_orient(void) const
 */
static PyObject *Dtool_TrackerNode_get_orient_190(PyObject *self, PyObject *) {
  TrackerNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TrackerNode)) {
    return nullptr;
  }
  // 1-inline LOrientation const &TrackerNode::get_orient(void) const
  LOrientation const *return_value = &(((*(const TrackerNode*)local_this).get_orient)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LOrientationf, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_get_orient_190_comment =
  "C++ Interface:\n"
  "get_orient(TrackerNode self)\n"
  "\n"
  "/**\n"
  " * Returns the current orientation of the tracker, if it is available.\n"
  " */";
#else
static const char *Dtool_TrackerNode_get_orient_190_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &TrackerNode::get_transform(void) const
 */
static PyObject *Dtool_TrackerNode_get_transform_191(PyObject *self, PyObject *) {
  TrackerNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TrackerNode)) {
    return nullptr;
  }
  // 1-inline LMatrix4 const &TrackerNode::get_transform(void) const
  LMatrix4 const *return_value = &(((*(const TrackerNode*)local_this).get_transform)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_get_transform_191_comment =
  "C++ Interface:\n"
  "get_transform(TrackerNode self)\n"
  "\n"
  "/**\n"
  " * Returns the current position and orientation of the tracker, as a combined\n"
  " * matrix.\n"
  " */";
#else
static const char *Dtool_TrackerNode_get_transform_191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double TrackerNode::get_time(void) const
 */
static PyObject *Dtool_TrackerNode_get_time_192(PyObject *self, PyObject *) {
  TrackerNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TrackerNode)) {
    return nullptr;
  }
  // 1-inline double TrackerNode::get_time(void) const
  double return_value = ((*(const TrackerNode*)local_this).get_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_get_time_192_comment =
  "C++ Interface:\n"
  "get_time(TrackerNode self)\n"
  "\n"
  "/**\n"
  " * Returns the time of the tracker's last update.\n"
  " */";
#else
static const char *Dtool_TrackerNode_get_time_192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool TrackerNode::has_time(void) const
 */
static PyObject *Dtool_TrackerNode_has_time_193(PyObject *self, PyObject *) {
  TrackerNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TrackerNode)) {
    return nullptr;
  }
  // 1-inline bool TrackerNode::has_time(void) const
  bool return_value = ((*(const TrackerNode*)local_this).has_time)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_has_time_193_comment =
  "C++ Interface:\n"
  "has_time(TrackerNode self)\n"
  "\n"
  "/**\n"
  " * True if this data comes with timestamps.\n"
  " */";
#else
static const char *Dtool_TrackerNode_has_time_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TrackerNode::set_tracker_coordinate_system(CoordinateSystem cs)
 */
static PyObject *Dtool_TrackerNode_set_tracker_coordinate_system_194(PyObject *self, PyObject *arg) {
  TrackerNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrackerNode, (void **)&local_this, "TrackerNode.set_tracker_coordinate_system")) {
    return nullptr;
  }
  // 1-inline void TrackerNode::set_tracker_coordinate_system(CoordinateSystem cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_tracker_coordinate_system)((CoordinateSystem)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tracker_coordinate_system(const TrackerNode self, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_set_tracker_coordinate_system_194_comment =
  "C++ Interface:\n"
  "set_tracker_coordinate_system(const TrackerNode self, int cs)\n"
  "\n"
  "/**\n"
  " * Specifies the coordinate system that the tracker associated with this node\n"
  " * will operate in.  Normally, this is set from the ClientBase that's used to\n"
  " * create the TrackerNode, so it should not need to be set on an individual\n"
  " * tracker basis.\n"
  " */";
#else
static const char *Dtool_TrackerNode_set_tracker_coordinate_system_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem TrackerNode::get_tracker_coordinate_system(void) const
 */
static PyObject *Dtool_TrackerNode_get_tracker_coordinate_system_195(PyObject *self, PyObject *) {
  TrackerNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TrackerNode)) {
    return nullptr;
  }
  // 1-inline CoordinateSystem TrackerNode::get_tracker_coordinate_system(void) const
  CoordinateSystem return_value = ((*(const TrackerNode*)local_this).get_tracker_coordinate_system)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_get_tracker_coordinate_system_195_comment =
  "C++ Interface:\n"
  "get_tracker_coordinate_system(TrackerNode self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate system that the tracker associated with this node\n"
  " * will operate in.\n"
  " */";
#else
static const char *Dtool_TrackerNode_get_tracker_coordinate_system_195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TrackerNode::set_graph_coordinate_system(CoordinateSystem cs)
 */
static PyObject *Dtool_TrackerNode_set_graph_coordinate_system_196(PyObject *self, PyObject *arg) {
  TrackerNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrackerNode, (void **)&local_this, "TrackerNode.set_graph_coordinate_system")) {
    return nullptr;
  }
  // 1-inline void TrackerNode::set_graph_coordinate_system(CoordinateSystem cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_graph_coordinate_system)((CoordinateSystem)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_graph_coordinate_system(const TrackerNode self, int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_set_graph_coordinate_system_196_comment =
  "C++ Interface:\n"
  "set_graph_coordinate_system(const TrackerNode self, int cs)\n"
  "\n"
  "/**\n"
  " * Specifies the coordinate system that the TrackerNode will convert its\n"
  " * transform into for passing down the data graph.  Normally, this is\n"
  " * CS_default.\n"
  " */";
#else
static const char *Dtool_TrackerNode_set_graph_coordinate_system_196_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CoordinateSystem TrackerNode::get_graph_coordinate_system(void) const
 */
static PyObject *Dtool_TrackerNode_get_graph_coordinate_system_197(PyObject *self, PyObject *) {
  TrackerNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TrackerNode)) {
    return nullptr;
  }
  // 1-inline CoordinateSystem TrackerNode::get_graph_coordinate_system(void) const
  CoordinateSystem return_value = ((*(const TrackerNode*)local_this).get_graph_coordinate_system)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_get_graph_coordinate_system_197_comment =
  "C++ Interface:\n"
  "get_graph_coordinate_system(TrackerNode self)\n"
  "\n"
  "/**\n"
  " * Returns the coordinate system that the TrackerNode will convert its\n"
  " * transform into for passing down the data graph.  Normally, this is\n"
  " * CS_default.\n"
  " */";
#else
static const char *Dtool_TrackerNode_get_graph_coordinate_system_197_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TrackerNode::get_class_type(void)
 */
static PyObject *Dtool_TrackerNode_get_class_type_198(PyObject *, PyObject *) {
  // 1-static TypeHandle TrackerNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TrackerNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TrackerNode_get_class_type_198_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TrackerNode_get_class_type_198_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit TrackerNode::TrackerNode(ClientBase *client, std::string const &device_name)
 * explicit TrackerNode::TrackerNode(InputDevice *device)
 * inline TrackerNode::TrackerNode(TrackerNode const &) = default
 */
static int Dtool_Init_TrackerNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 explicit TrackerNode::TrackerNode(InputDevice *device)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "device")) {
          InputDevice *param0_this = (InputDevice *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_InputDevice, 0, "TrackerNode.TrackerNode", false, false);
          if (param0_this != nullptr) {
            TrackerNode *return_value = new TrackerNode(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TrackerNode, true, false);
          }
        }
      }

      {
        // -2 inline TrackerNode::TrackerNode(TrackerNode const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          TrackerNode const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TrackerNode);
          if (param0_this != nullptr) {
            TrackerNode *return_value = new TrackerNode(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TrackerNode, true, false);
          }
        }
      }

      // No coercion possible: explicit TrackerNode::TrackerNode(InputDevice *device)
      // No coercion possible: inline TrackerNode::TrackerNode(TrackerNode const &) = default
    }
    break;
  case 2:
    {
      // 1-explicit TrackerNode::TrackerNode(ClientBase *client, std::string const &device_name)
      PyObject *param0;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"client", "device_name", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:TrackerNode", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
        ClientBase *param0_this = (ClientBase *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ClientBase, 0, "TrackerNode.TrackerNode", false, true);
        if (param0_this != nullptr) {
          TrackerNode *return_value = new TrackerNode(param0_this, std::string(param1_str, param1_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TrackerNode, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TrackerNode() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TrackerNode(InputDevice device)\n"
      "TrackerNode(const TrackerNode param0)\n"
      "TrackerNode(ClientBase client, str device_name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TrackerNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TrackerNode) {
    printf("TrackerNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TrackerNode *local_this = (TrackerNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TrackerNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TrackerNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TrackerNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (TrackerNode*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (TrackerNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (TrackerNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TrackerNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TrackerNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (TrackerNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (TrackerNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VirtualMouse
 */
/**
 * Python function wrapper for:
 * void VirtualMouse::set_mouse_pos(int x, int y)
 */
static PyObject *Dtool_VirtualMouse_set_mouse_pos_201(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualMouse *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualMouse, (void **)&local_this, "VirtualMouse.set_mouse_pos")) {
    return nullptr;
  }
  // 1-void VirtualMouse::set_mouse_pos(int x, int y)
  int param1;
  int param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_mouse_pos", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_mouse_pos)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mouse_pos(const VirtualMouse self, int x, int y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualMouse_set_mouse_pos_201_comment =
  "C++ Interface:\n"
  "set_mouse_pos(const VirtualMouse self, int x, int y)\n"
  "\n"
  "/**\n"
  " * Sets the current mouse pixel location, where (0,0) is the upper left, and\n"
  " * (width-1, height-1) is the lower right pixel of the virtual window.\n"
  " */";
#else
static const char *Dtool_VirtualMouse_set_mouse_pos_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void VirtualMouse::set_window_size(int width, int height)
 */
static PyObject *Dtool_VirtualMouse_set_window_size_202(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualMouse *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualMouse, (void **)&local_this, "VirtualMouse.set_window_size")) {
    return nullptr;
  }
  // 1-void VirtualMouse::set_window_size(int width, int height)
  int param1;
  int param2;
  static const char *keyword_list[] = {"width", "height", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_window_size", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_window_size)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_window_size(const VirtualMouse self, int width, int height)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualMouse_set_window_size_202_comment =
  "C++ Interface:\n"
  "set_window_size(const VirtualMouse self, int width, int height)\n"
  "\n"
  "/**\n"
  " * Sets the size of the \"window\" in which the mouse rolls.  This changes the\n"
  " * meaning of the values passed to set_mouse_pos().\n"
  " */";
#else
static const char *Dtool_VirtualMouse_set_window_size_202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void VirtualMouse::set_mouse_on(bool flag)
 */
static PyObject *Dtool_VirtualMouse_set_mouse_on_203(PyObject *self, PyObject *arg) {
  VirtualMouse *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualMouse, (void **)&local_this, "VirtualMouse.set_mouse_on")) {
    return nullptr;
  }
  // 1-void VirtualMouse::set_mouse_on(bool flag)
  ((*local_this).set_mouse_on)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mouse_on(const VirtualMouse self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualMouse_set_mouse_on_203_comment =
  "C++ Interface:\n"
  "set_mouse_on(const VirtualMouse self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets whether the mouse should appear to be within the window or not.  If\n"
  " * this is true, the mouse is within the window; if false, the mouse is not\n"
  " * within the window (and set_mouse_pos() means nothing).\n"
  " */";
#else
static const char *Dtool_VirtualMouse_set_mouse_on_203_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void VirtualMouse::press_button(ButtonHandle button)
 */
static PyObject *Dtool_VirtualMouse_press_button_204(PyObject *self, PyObject *arg) {
  VirtualMouse *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualMouse, (void **)&local_this, "VirtualMouse.press_button")) {
    return nullptr;
  }
  // 1-void VirtualMouse::press_button(ButtonHandle button)
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualMouse.press_button", "ButtonHandle");
  }
  ((*local_this).press_button)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "press_button(const VirtualMouse self, ButtonHandle button)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualMouse_press_button_204_comment =
  "C++ Interface:\n"
  "press_button(const VirtualMouse self, ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Simulates a mouse or keyboard button being depressed.  This should be\n"
  " * followed up by a call to release_button() sometime later (possibly\n"
  " * immediately).\n"
  " */";
#else
static const char *Dtool_VirtualMouse_press_button_204_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void VirtualMouse::release_button(ButtonHandle button)
 */
static PyObject *Dtool_VirtualMouse_release_button_205(PyObject *self, PyObject *arg) {
  VirtualMouse *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualMouse, (void **)&local_this, "VirtualMouse.release_button")) {
    return nullptr;
  }
  // 1-void VirtualMouse::release_button(ButtonHandle button)
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualMouse.release_button", "ButtonHandle");
  }
  ((*local_this).release_button)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_button(const VirtualMouse self, ButtonHandle button)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualMouse_release_button_205_comment =
  "C++ Interface:\n"
  "release_button(const VirtualMouse self, ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Simulates the button being released.  This should follow a previous call to\n"
  " * press_button().\n"
  " */";
#else
static const char *Dtool_VirtualMouse_release_button_205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VirtualMouse::get_class_type(void)
 */
static PyObject *Dtool_VirtualMouse_get_class_type_206(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualMouse::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((VirtualMouse::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualMouse_get_class_type_206_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualMouse_get_class_type_206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline VirtualMouse::VirtualMouse(VirtualMouse const &) = default
 * explicit VirtualMouse::VirtualMouse(std::string const &name)
 */
static int Dtool_Init_VirtualMouse(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "VirtualMouse() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline VirtualMouse::VirtualMouse(VirtualMouse const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      VirtualMouse const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_VirtualMouse);
      if (param0_this != nullptr) {
        VirtualMouse *return_value = new VirtualMouse(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualMouse, true, false);
      }
    }
  }

  {
    // -2 explicit VirtualMouse::VirtualMouse(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:VirtualMouse", (char **)keyword_list, &param0_str, &param0_len)) {
      VirtualMouse *return_value = new VirtualMouse(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualMouse, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline VirtualMouse::VirtualMouse(VirtualMouse const &) = default
  // No coercion possible: explicit VirtualMouse::VirtualMouse(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VirtualMouse(const VirtualMouse param0)\n"
      "VirtualMouse(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_VirtualMouse(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VirtualMouse) {
    printf("VirtualMouse ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VirtualMouse *local_this = (VirtualMouse *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VirtualMouse) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VirtualMouse(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VirtualMouse) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (VirtualMouse*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (VirtualMouse*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (VirtualMouse*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualMouse*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualMouse*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (VirtualMouse*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (VirtualMouse*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for TrackerData (TrackerData)
 */
static PyMethodDef Dtool_Methods_TrackerData[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_TrackerData[] = {
  {(char *)"time", &Dtool_TrackerData_time_Getter, &Dtool_TrackerData_time_Setter, nullptr, nullptr},
  {(char *)"pos", &Dtool_TrackerData_pos_Getter, &Dtool_TrackerData_pos_Setter, nullptr, nullptr},
  {(char *)"orient", &Dtool_TrackerData_orient_Getter, &Dtool_TrackerData_orient_Setter, nullptr, nullptr},
  {(char *)"dt", &Dtool_TrackerData_dt_Getter, &Dtool_TrackerData_dt_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TrackerData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TrackerData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TrackerData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TrackerData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TrackerData,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Stores the kinds of data that a tracker might output.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TrackerData,
    nullptr, // tp_members
    Dtool_Properties_TrackerData,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TrackerData,
    PyType_GenericAlloc,
    Dtool_new_TrackerData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TrackerData,
  Dtool_UpcastInterface_TrackerData,
  Dtool_DowncastInterface_TrackerData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TrackerData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TrackerData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TrackerData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TrackerData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TrackerData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TrackerData);
  }
}

/**
 * Python method tables for InputDevice_ButtonState (ButtonState)
 */
static PyMethodDef Dtool_Methods_InputDevice_ButtonState[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// InputDevice_ButtonState slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_InputDevice_ButtonState_operator_typecast_bool_29_nb_bool(PyObject *self) {
  InputDevice::ButtonState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice_ButtonState, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

static PyGetSetDef Dtool_Properties_InputDevice_ButtonState[] = {
  {(char *)"known", &Dtool_InputDevice_ButtonState_known_Getter, nullptr, nullptr, nullptr},
  {(char *)"pressed", &Dtool_InputDevice_ButtonState_pressed_Getter, nullptr, nullptr, nullptr},
  {(char *)"handle", &Dtool_InputDevice_ButtonState_handle_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_InputDevice_ButtonState = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_InputDevice_ButtonState_operator_typecast_bool_29_nb_bool,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_InputDevice_ButtonState = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ButtonState",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_InputDevice_ButtonState,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_InputDevice_ButtonState,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_InputDevice_ButtonState,
    nullptr, // tp_members
    Dtool_Properties_InputDevice_ButtonState,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_InputDevice_ButtonState,
    PyType_GenericAlloc,
    Dtool_new_InputDevice_ButtonState,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_InputDevice_ButtonState,
  Dtool_UpcastInterface_InputDevice_ButtonState,
  Dtool_DowncastInterface_InputDevice_ButtonState,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_InputDevice_ButtonState(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_InputDevice_ButtonState._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_InputDevice_ButtonState._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_InputDevice_ButtonState) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(InputDevice_ButtonState)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_InputDevice_ButtonState);
  }
}

/**
 * Python method tables for InputDevice_AxisState (AxisState)
 */
static PyMethodDef Dtool_Methods_InputDevice_AxisState[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// InputDevice_AxisState slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_InputDevice_AxisState_operator_typecast_bool_41_nb_bool(PyObject *self) {
  InputDevice::AxisState *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice_AxisState, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

static PyGetSetDef Dtool_Properties_InputDevice_AxisState[] = {
  {(char *)"axis", &Dtool_InputDevice_AxisState_axis_Getter, &Dtool_InputDevice_AxisState_axis_Setter, nullptr, nullptr},
  {(char *)"value", &Dtool_InputDevice_AxisState_value_Getter, &Dtool_InputDevice_AxisState_value_Setter, nullptr, nullptr},
  {(char *)"known", &Dtool_InputDevice_AxisState_known_Getter, &Dtool_InputDevice_AxisState_known_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_InputDevice_AxisState = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_InputDevice_AxisState_operator_typecast_bool_41_nb_bool,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_InputDevice_AxisState = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AxisState",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_InputDevice_AxisState,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_InputDevice_AxisState,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_InputDevice_AxisState,
    nullptr, // tp_members
    Dtool_Properties_InputDevice_AxisState,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_InputDevice_AxisState,
    PyType_GenericAlloc,
    Dtool_new_InputDevice_AxisState,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_InputDevice_AxisState,
  Dtool_UpcastInterface_InputDevice_AxisState,
  Dtool_DowncastInterface_InputDevice_AxisState,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_InputDevice_AxisState(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_InputDevice_AxisState._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_InputDevice_AxisState._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_InputDevice_AxisState) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(InputDevice_AxisState)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_InputDevice_AxisState);
  }
}

/**
 * Python method tables for InputDevice_BatteryData (BatteryData)
 */
static PyMethodDef Dtool_Methods_InputDevice_BatteryData[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_InputDevice_BatteryData[] = {
  {(char *)"level", &Dtool_InputDevice_BatteryData_level_Getter, &Dtool_InputDevice_BatteryData_level_Setter, (char *)
    "// Ranges from 0 through max_level.",
    nullptr},
  {(char *)"max_level", &Dtool_InputDevice_BatteryData_max_level_Getter, &Dtool_InputDevice_BatteryData_max_level_Setter, (char *)
    "// Maximum value of 'level' field.",
    nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_InputDevice_BatteryData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_InputDevice_BatteryData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BatteryData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_InputDevice_BatteryData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_InputDevice_BatteryData,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_InputDevice_BatteryData,
    nullptr, // tp_members
    Dtool_Properties_InputDevice_BatteryData,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_InputDevice_BatteryData,
    PyType_GenericAlloc,
    Dtool_new_InputDevice_BatteryData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_InputDevice_BatteryData,
  Dtool_UpcastInterface_InputDevice_BatteryData,
  Dtool_DowncastInterface_InputDevice_BatteryData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_InputDevice_BatteryData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_InputDevice_BatteryData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_InputDevice_BatteryData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_InputDevice_BatteryData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(InputDevice_BatteryData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_InputDevice_BatteryData);
  }
}

/**
 * Python method tables for InputDevice (InputDevice)
 */
static PyMethodDef Dtool_Methods_InputDevice[] = {
  {"has_feature", &Dtool_InputDevice_has_feature_80, METH_O, (const char *)Dtool_InputDevice_has_feature_80_comment},
  {"hasFeature", &Dtool_InputDevice_has_feature_80, METH_O, (const char *)Dtool_InputDevice_has_feature_80_comment},
  {"map_button", (PyCFunction) &Dtool_InputDevice_map_button_93, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_InputDevice_map_button_93_comment},
  {"mapButton", (PyCFunction) &Dtool_InputDevice_map_button_93, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_InputDevice_map_button_93_comment},
  {"map_axis", (PyCFunction) &Dtool_InputDevice_map_axis_94, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_InputDevice_map_axis_94_comment},
  {"mapAxis", (PyCFunction) &Dtool_InputDevice_map_axis_94, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_InputDevice_map_axis_94_comment},
  {"find_button", &Dtool_InputDevice_find_button_95, METH_O, (const char *)Dtool_InputDevice_find_button_95_comment},
  {"findButton", &Dtool_InputDevice_find_button_95, METH_O, (const char *)Dtool_InputDevice_find_button_95_comment},
  {"find_axis", &Dtool_InputDevice_find_axis_96, METH_O, (const char *)Dtool_InputDevice_find_axis_96_comment},
  {"findAxis", &Dtool_InputDevice_find_axis_96, METH_O, (const char *)Dtool_InputDevice_find_axis_96_comment},
  {"set_vibration", (PyCFunction) &Dtool_InputDevice_set_vibration_97, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_InputDevice_set_vibration_97_comment},
  {"setVibration", (PyCFunction) &Dtool_InputDevice_set_vibration_97, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_InputDevice_set_vibration_97_comment},
  {"enable_pointer_events", &Dtool_InputDevice_enable_pointer_events_98, METH_NOARGS, (const char *)Dtool_InputDevice_enable_pointer_events_98_comment},
  {"enablePointerEvents", &Dtool_InputDevice_enable_pointer_events_98, METH_NOARGS, (const char *)Dtool_InputDevice_enable_pointer_events_98_comment},
  {"disable_pointer_events", &Dtool_InputDevice_disable_pointer_events_99, METH_NOARGS, (const char *)Dtool_InputDevice_disable_pointer_events_99_comment},
  {"disablePointerEvents", &Dtool_InputDevice_disable_pointer_events_99, METH_NOARGS, (const char *)Dtool_InputDevice_disable_pointer_events_99_comment},
  {"poll", &Dtool_InputDevice_poll_100, METH_NOARGS, (const char *)Dtool_InputDevice_poll_100_comment},
  {"has_button_event", &Dtool_InputDevice_has_button_event_101, METH_NOARGS, (const char *)Dtool_InputDevice_has_button_event_101_comment},
  {"hasButtonEvent", &Dtool_InputDevice_has_button_event_101, METH_NOARGS, (const char *)Dtool_InputDevice_has_button_event_101_comment},
  {"get_button_events", &Dtool_InputDevice_get_button_events_102, METH_NOARGS, (const char *)Dtool_InputDevice_get_button_events_102_comment},
  {"getButtonEvents", &Dtool_InputDevice_get_button_events_102, METH_NOARGS, (const char *)Dtool_InputDevice_get_button_events_102_comment},
  {"has_pointer_event", &Dtool_InputDevice_has_pointer_event_103, METH_NOARGS, (const char *)Dtool_InputDevice_has_pointer_event_103_comment},
  {"hasPointerEvent", &Dtool_InputDevice_has_pointer_event_103, METH_NOARGS, (const char *)Dtool_InputDevice_has_pointer_event_103_comment},
  {"get_pointer_events", &Dtool_InputDevice_get_pointer_events_104, METH_NOARGS, (const char *)Dtool_InputDevice_get_pointer_events_104_comment},
  {"getPointerEvents", &Dtool_InputDevice_get_pointer_events_104, METH_NOARGS, (const char *)Dtool_InputDevice_get_pointer_events_104_comment},
  {"output", &Dtool_InputDevice_output_105, METH_O, (const char *)Dtool_InputDevice_output_105_comment},
  {"get_class_type", &Dtool_InputDevice_get_class_type_121, METH_NOARGS | METH_STATIC, (const char *)Dtool_InputDevice_get_class_type_121_comment},
  {"getClassType", &Dtool_InputDevice_get_class_type_121, METH_NOARGS | METH_STATIC, (const char *)Dtool_InputDevice_get_class_type_121_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     InputDevice
//////////////////
static PyObject *Dtool_Repr_InputDevice(PyObject *self) {
  InputDevice *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDevice, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_InputDevice[] = {
  {(char *)"name", &Dtool_InputDevice_name_Getter, nullptr, (char *)
    "// The human-readable name of this input device.",
    nullptr},
  {(char *)"manufacturer", &Dtool_InputDevice_manufacturer_Getter, nullptr, (char *)
    "// The device's manufacturer, or the empty string if not known.",
    nullptr},
  {(char *)"serial_number", &Dtool_InputDevice_serial_number_Getter, nullptr, (char *)
    "// The device's serial number, or the empty string if not known.",
    nullptr},
  {(char *)"vendor_id", &Dtool_InputDevice_vendor_id_Getter, nullptr, (char *)
    "// USB vendor ID of the device, or 0 if not known.",
    nullptr},
  {(char *)"product_id", &Dtool_InputDevice_product_id_Getter, nullptr, (char *)
    "// USB product ID of the device, or 0 if not known.",
    nullptr},
  {(char *)"connected", &Dtool_InputDevice_connected_Getter, nullptr, (char *)
    "// This is false if we know that the device is not currently connected.\n"
    "// May report false positives if we can't know this with certainty.",
    nullptr},
  {(char *)"device_class", &Dtool_InputDevice_device_class_Getter, nullptr, (char *)
    "// This contains an identification of the general type of device.  If\n"
    "// this could not be determined, it is set to DC_unknown.",
    nullptr},
  {(char *)"tracker", &Dtool_InputDevice_tracker_Getter, nullptr, (char *)
    "// Getters for the various types of device data.",
    nullptr},
  {(char *)"battery", &Dtool_InputDevice_battery_Getter, nullptr, nullptr, nullptr},
  {(char *)"buttons", &Dtool_InputDevice_buttons_Getter, nullptr, (char *)
    "// Make device buttons and axes iterable",
    nullptr},
  {(char *)"axes", &Dtool_InputDevice_axes_Getter, nullptr, nullptr, nullptr},
  {(char *)"_pointer_data", &Dtool_InputDevice__pointer_data_Getter, nullptr, nullptr, nullptr},
  {(char *)"_battery_data", &Dtool_InputDevice__battery_data_Getter, nullptr, nullptr, nullptr},
  {(char *)"_tracker_data", &Dtool_InputDevice__tracker_data_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_InputDevice = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_InputDevice = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_InputDevice = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_InputDevice = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_InputDevice = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_InputDevice = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.InputDevice",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_InputDevice,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_InputDevice,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_InputDevice,
    &Dtool_NumberMethods_InputDevice,
    &Dtool_SequenceMethods_InputDevice,
    &Dtool_MappingMethods_InputDevice,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_InputDevice,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_InputDevice,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a structure representing a single input device.  Input devices may\n"
    " * have zero or more buttons, pointers, or axes associated with them, and\n"
    " * optionally a motion tracker.\n"
    " *\n"
    " * These devices are brought under a common interface because there is such a\n"
    " * large range of devices out there that may support any number of these types\n"
    " * of axes, we couldn't even begin to cover them with type-specific\n"
    " * subclasses.\n"
    " *\n"
    " * Use the various has_() and get_num_() methods to determine information about\n"
    " * the device capabilities. For instance, has_keyboard() will give an\n"
    " * indication that you can receive keystroke events from this device, and\n"
    " * get_num_buttons() will tell you that the device may send button events.\n"
    " *\n"
    " * There is the DeviceType enumeration, however, which will (if known) contain\n"
    " * identification of the general category of devices this fits in, such as\n"
    " * keyboard, mouse, gamepad, or flight stick.\n"
    " *\n"
    " * @since 1.10.0\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_InputDevice,
    nullptr, // tp_members
    Dtool_Properties_InputDevice,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_InputDevice,
    PyType_GenericAlloc,
    Dtool_new_InputDevice,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_InputDevice,
  Dtool_UpcastInterface_InputDevice,
  Dtool_DowncastInterface_InputDevice,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_InputDevice(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_InputDevice._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_InputDevice._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(13);
    Dtool_InputDevice._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum class InputDevice::DeviceClass;
    {
      PyObject *members = PyTuple_New(12);
      PyObject *member;
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("unknown"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("unknown"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::DeviceClass::unknown));
      PyTuple_SET_ITEM(members, 0, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("virtual_device"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("virtual_device"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::DeviceClass::virtual_device));
      PyTuple_SET_ITEM(members, 1, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("keyboard"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("keyboard"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::DeviceClass::keyboard));
      PyTuple_SET_ITEM(members, 2, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("mouse"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("mouse"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::DeviceClass::mouse));
      PyTuple_SET_ITEM(members, 3, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("touch"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("touch"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::DeviceClass::touch));
      PyTuple_SET_ITEM(members, 4, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("gamepad"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("gamepad"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::DeviceClass::gamepad));
      PyTuple_SET_ITEM(members, 5, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("flight_stick"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("flight_stick"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::DeviceClass::flight_stick));
      PyTuple_SET_ITEM(members, 6, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("steering_wheel"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("steering_wheel"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::DeviceClass::steering_wheel));
      PyTuple_SET_ITEM(members, 7, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("dance_pad"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("dance_pad"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::DeviceClass::dance_pad));
      PyTuple_SET_ITEM(members, 8, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("hmd"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("hmd"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::DeviceClass::hmd));
      PyTuple_SET_ITEM(members, 9, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("spatial_mouse"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("spatial_mouse"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::DeviceClass::spatial_mouse));
      PyTuple_SET_ITEM(members, 10, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("digitizer"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("digitizer"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::DeviceClass::digitizer));
      PyTuple_SET_ITEM(members, 11, member);
      Dtool_Ptr_InputDevice_DeviceClass = Dtool_EnumType_Create("DeviceClass", members, "panda3d.core");
      PyDict_SetItemString(dict, "DeviceClass", (PyObject *)Dtool_Ptr_InputDevice_DeviceClass);
    }
    // enum class InputDevice::Feature;
    {
      PyObject *members = PyTuple_New(5);
      PyObject *member;
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("pointer"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("pointer"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Feature::pointer));
      PyTuple_SET_ITEM(members, 0, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("keyboard"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("keyboard"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Feature::keyboard));
      PyTuple_SET_ITEM(members, 1, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("tracker"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("tracker"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Feature::tracker));
      PyTuple_SET_ITEM(members, 2, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("vibration"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("vibration"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Feature::vibration));
      PyTuple_SET_ITEM(members, 3, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("battery"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("battery"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Feature::battery));
      PyTuple_SET_ITEM(members, 4, member);
      Dtool_Ptr_InputDevice_Feature = Dtool_EnumType_Create("Feature", members, "panda3d.core");
      PyDict_SetItemString(dict, "Feature", (PyObject *)Dtool_Ptr_InputDevice_Feature);
    }
    // enum class InputDevice::Axis;
    {
      PyObject *members = PyTuple_New(19);
      PyObject *member;
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("none"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("none"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::none));
      PyTuple_SET_ITEM(members, 0, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("x"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("x"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::x));
      PyTuple_SET_ITEM(members, 1, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("y"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("y"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::y));
      PyTuple_SET_ITEM(members, 2, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("z"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("z"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::z));
      PyTuple_SET_ITEM(members, 3, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("yaw"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("yaw"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::yaw));
      PyTuple_SET_ITEM(members, 4, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("pitch"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("pitch"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::pitch));
      PyTuple_SET_ITEM(members, 5, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("roll"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("roll"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::roll));
      PyTuple_SET_ITEM(members, 6, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("left_x"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("left_x"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::left_x));
      PyTuple_SET_ITEM(members, 7, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("left_y"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("left_y"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::left_y));
      PyTuple_SET_ITEM(members, 8, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("left_trigger"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("left_trigger"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::left_trigger));
      PyTuple_SET_ITEM(members, 9, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("right_x"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("right_x"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::right_x));
      PyTuple_SET_ITEM(members, 10, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("right_y"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("right_y"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::right_y));
      PyTuple_SET_ITEM(members, 11, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("right_trigger"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("right_trigger"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::right_trigger));
      PyTuple_SET_ITEM(members, 12, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("throttle"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("throttle"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::throttle));
      PyTuple_SET_ITEM(members, 13, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("rudder"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("rudder"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::rudder));
      PyTuple_SET_ITEM(members, 14, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("wheel"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("wheel"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::wheel));
      PyTuple_SET_ITEM(members, 15, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("accelerator"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("accelerator"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::accelerator));
      PyTuple_SET_ITEM(members, 16, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("brake"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("brake"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::brake));
      PyTuple_SET_ITEM(members, 17, member);
      member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("pressure"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("pressure"));
#endif
      PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)InputDevice::Axis::pressure));
      PyTuple_SET_ITEM(members, 18, member);
      Dtool_Ptr_InputDevice_Axis = Dtool_EnumType_Create("Axis", members, "panda3d.core");
      PyDict_SetItemString(dict, "Axis", (PyObject *)Dtool_Ptr_InputDevice_Axis);
    }
    // enum InputDevice::State;
    PyDict_SetItemString(dict, "S_unknown", Dtool_WrapValue(InputDevice::S_unknown));
    PyDict_SetItemString(dict, "SUnknown", Dtool_WrapValue(InputDevice::S_unknown));
    PyDict_SetItemString(dict, "S_up", Dtool_WrapValue(InputDevice::S_up));
    PyDict_SetItemString(dict, "SUp", Dtool_WrapValue(InputDevice::S_up));
    PyDict_SetItemString(dict, "S_down", Dtool_WrapValue(InputDevice::S_down));
    PyDict_SetItemString(dict, "SDown", Dtool_WrapValue(InputDevice::S_down));
    // Nested Object   InputDevice_ButtonState;
    Dtool_PyModuleClassInit_InputDevice_ButtonState(nullptr);
    PyDict_SetItemString(dict, "ButtonState", (PyObject *)&Dtool_InputDevice_ButtonState);
    // Nested Object   InputDevice_AxisState;
    Dtool_PyModuleClassInit_InputDevice_AxisState(nullptr);
    PyDict_SetItemString(dict, "AxisState", (PyObject *)&Dtool_InputDevice_AxisState);
    // Nested Object   InputDevice_BatteryData;
    Dtool_PyModuleClassInit_InputDevice_BatteryData(nullptr);
    PyDict_SetItemString(dict, "BatteryData", (PyObject *)&Dtool_InputDevice_BatteryData);
    if (PyType_Ready((PyTypeObject *)&Dtool_InputDevice) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(InputDevice)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_InputDevice);
  }
}

/**
 * Python method tables for ClientBase (ClientBase)
 */
static PyMethodDef Dtool_Methods_ClientBase[] = {
  {"fork_asynchronous_thread", &Dtool_ClientBase_fork_asynchronous_thread_123, METH_O, (const char *)Dtool_ClientBase_fork_asynchronous_thread_123_comment},
  {"forkAsynchronousThread", &Dtool_ClientBase_fork_asynchronous_thread_123, METH_O, (const char *)Dtool_ClientBase_fork_asynchronous_thread_123_comment},
  {"is_forked", &Dtool_ClientBase_is_forked_124, METH_NOARGS, (const char *)Dtool_ClientBase_is_forked_124_comment},
  {"isForked", &Dtool_ClientBase_is_forked_124, METH_NOARGS, (const char *)Dtool_ClientBase_is_forked_124_comment},
  {"poll", &Dtool_ClientBase_poll_125, METH_NOARGS, (const char *)Dtool_ClientBase_poll_125_comment},
  {"get_last_poll_time", &Dtool_ClientBase_get_last_poll_time_126, METH_NOARGS, (const char *)Dtool_ClientBase_get_last_poll_time_126_comment},
  {"getLastPollTime", &Dtool_ClientBase_get_last_poll_time_126, METH_NOARGS, (const char *)Dtool_ClientBase_get_last_poll_time_126_comment},
  {"set_coordinate_system", &Dtool_ClientBase_set_coordinate_system_127, METH_O, (const char *)Dtool_ClientBase_set_coordinate_system_127_comment},
  {"setCoordinateSystem", &Dtool_ClientBase_set_coordinate_system_127, METH_O, (const char *)Dtool_ClientBase_set_coordinate_system_127_comment},
  {"get_coordinate_system", &Dtool_ClientBase_get_coordinate_system_128, METH_NOARGS, (const char *)Dtool_ClientBase_get_coordinate_system_128_comment},
  {"getCoordinateSystem", &Dtool_ClientBase_get_coordinate_system_128, METH_NOARGS, (const char *)Dtool_ClientBase_get_coordinate_system_128_comment},
  {"get_class_type", &Dtool_ClientBase_get_class_type_129, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClientBase_get_class_type_129_comment},
  {"getClassType", &Dtool_ClientBase_get_class_type_129, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClientBase_get_class_type_129_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ClientBase = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ClientBase = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ClientBase = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ClientBase = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ClientBase = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ClientBase = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ClientBase",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ClientBase,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ClientBase,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ClientBase,
    &Dtool_SequenceMethods_ClientBase,
    &Dtool_MappingMethods_ClientBase,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ClientBase,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An abstract base class for a family of client device interfaces--including\n"
    " * trackers, buttons, dials, and other analog inputs.\n"
    " *\n"
    " * This provides a common interface to connect to such devices and extract\n"
    " * their data; it is used by TrackerNode etc.  to put these devices in the\n"
    " * data graph.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ClientBase,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ClientBase,
    PyType_GenericAlloc,
    Dtool_new_ClientBase,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ClientBase,
  Dtool_UpcastInterface_ClientBase,
  Dtool_DowncastInterface_ClientBase,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ClientBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_ClientBase._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_ClientBase._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ClientBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ClientBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ClientBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ClientBase);
  }
}

/**
 * Python method tables for AnalogNode (AnalogNode)
 */
static PyMethodDef Dtool_Methods_AnalogNode[] = {
  {"is_valid", &Dtool_AnalogNode_is_valid_133, METH_NOARGS, (const char *)Dtool_AnalogNode_is_valid_133_comment},
  {"isValid", &Dtool_AnalogNode_is_valid_133, METH_NOARGS, (const char *)Dtool_AnalogNode_is_valid_133_comment},
  {"get_num_controls", &Dtool_AnalogNode_get_num_controls_134, METH_NOARGS, (const char *)Dtool_AnalogNode_get_num_controls_134_comment},
  {"getNumControls", &Dtool_AnalogNode_get_num_controls_134, METH_NOARGS, (const char *)Dtool_AnalogNode_get_num_controls_134_comment},
  {"get_control_state", &Dtool_AnalogNode_get_control_state_135, METH_O, (const char *)Dtool_AnalogNode_get_control_state_135_comment},
  {"getControlState", &Dtool_AnalogNode_get_control_state_135, METH_O, (const char *)Dtool_AnalogNode_get_control_state_135_comment},
  {"is_control_known", &Dtool_AnalogNode_is_control_known_136, METH_O, (const char *)Dtool_AnalogNode_is_control_known_136_comment},
  {"isControlKnown", &Dtool_AnalogNode_is_control_known_136, METH_O, (const char *)Dtool_AnalogNode_is_control_known_136_comment},
  {"set_output", (PyCFunction) &Dtool_AnalogNode_set_output_137, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnalogNode_set_output_137_comment},
  {"setOutput", (PyCFunction) &Dtool_AnalogNode_set_output_137, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnalogNode_set_output_137_comment},
  {"clear_output", &Dtool_AnalogNode_clear_output_138, METH_O, (const char *)Dtool_AnalogNode_clear_output_138_comment},
  {"clearOutput", &Dtool_AnalogNode_clear_output_138, METH_O, (const char *)Dtool_AnalogNode_clear_output_138_comment},
  {"get_output", &Dtool_AnalogNode_get_output_139, METH_O, (const char *)Dtool_AnalogNode_get_output_139_comment},
  {"getOutput", &Dtool_AnalogNode_get_output_139, METH_O, (const char *)Dtool_AnalogNode_get_output_139_comment},
  {"is_output_flipped", &Dtool_AnalogNode_is_output_flipped_140, METH_O, (const char *)Dtool_AnalogNode_is_output_flipped_140_comment},
  {"isOutputFlipped", &Dtool_AnalogNode_is_output_flipped_140, METH_O, (const char *)Dtool_AnalogNode_is_output_flipped_140_comment},
  {"get_class_type", &Dtool_AnalogNode_get_class_type_141, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnalogNode_get_class_type_141_comment},
  {"getClassType", &Dtool_AnalogNode_get_class_type_141, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnalogNode_get_class_type_141_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AnalogNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnalogNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AnalogNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AnalogNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AnalogNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AnalogNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AnalogNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AnalogNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AnalogNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AnalogNode,
    &Dtool_SequenceMethods_AnalogNode,
    &Dtool_MappingMethods_AnalogNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AnalogNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the primary interface to analog controls like sliders and joysticks\n"
    " * associated with a ClientBase.  This creates a node that connects to the\n"
    " * named analog device, if it exists, and provides hooks to the user to read\n"
    " * the state of any of the sequentially numbered controls associated with that\n"
    " * device.\n"
    " *\n"
    " * Each control can return a value ranging from -1 to 1, reflecting the\n"
    " * current position of the control within its total range of motion.\n"
    " *\n"
    " * The user may choose up to two analog controls to place on the data graph as\n"
    " * the two channels of an xy datagram, similarly to the way a mouse places its\n"
    " * position data.  In this way, an AnalogNode may be used in place of a mouse.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AnalogNode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AnalogNode,
    PyType_GenericAlloc,
    Dtool_new_AnalogNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnalogNode,
  Dtool_UpcastInterface_AnalogNode,
  Dtool_DowncastInterface_AnalogNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AnalogNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != nullptr);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_AnalogNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DataNode);
    Dtool_AnalogNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AnalogNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnalogNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnalogNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnalogNode);
  }
}

/**
 * Python method tables for ButtonNode (ButtonNode)
 */
static PyMethodDef Dtool_Methods_ButtonNode[] = {
  {"is_valid", &Dtool_ButtonNode_is_valid_144, METH_NOARGS, (const char *)Dtool_ButtonNode_is_valid_144_comment},
  {"isValid", &Dtool_ButtonNode_is_valid_144, METH_NOARGS, (const char *)Dtool_ButtonNode_is_valid_144_comment},
  {"get_num_buttons", &Dtool_ButtonNode_get_num_buttons_145, METH_NOARGS, (const char *)Dtool_ButtonNode_get_num_buttons_145_comment},
  {"getNumButtons", &Dtool_ButtonNode_get_num_buttons_145, METH_NOARGS, (const char *)Dtool_ButtonNode_get_num_buttons_145_comment},
  {"set_button_map", (PyCFunction) &Dtool_ButtonNode_set_button_map_146, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ButtonNode_set_button_map_146_comment},
  {"setButtonMap", (PyCFunction) &Dtool_ButtonNode_set_button_map_146, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ButtonNode_set_button_map_146_comment},
  {"get_button_map", &Dtool_ButtonNode_get_button_map_147, METH_O, (const char *)Dtool_ButtonNode_get_button_map_147_comment},
  {"getButtonMap", &Dtool_ButtonNode_get_button_map_147, METH_O, (const char *)Dtool_ButtonNode_get_button_map_147_comment},
  {"get_button_state", &Dtool_ButtonNode_get_button_state_148, METH_O, (const char *)Dtool_ButtonNode_get_button_state_148_comment},
  {"getButtonState", &Dtool_ButtonNode_get_button_state_148, METH_O, (const char *)Dtool_ButtonNode_get_button_state_148_comment},
  {"is_button_known", &Dtool_ButtonNode_is_button_known_149, METH_O, (const char *)Dtool_ButtonNode_is_button_known_149_comment},
  {"isButtonKnown", &Dtool_ButtonNode_is_button_known_149, METH_O, (const char *)Dtool_ButtonNode_is_button_known_149_comment},
  {"get_class_type", &Dtool_ButtonNode_get_class_type_150, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonNode_get_class_type_150_comment},
  {"getClassType", &Dtool_ButtonNode_get_class_type_150, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonNode_get_class_type_150_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ButtonNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ButtonNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ButtonNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ButtonNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ButtonNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ButtonNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ButtonNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ButtonNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ButtonNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ButtonNode,
    &Dtool_SequenceMethods_ButtonNode,
    &Dtool_MappingMethods_ButtonNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ButtonNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the primary interface to on/off button devices associated with a\n"
    " * ClientBase.  This creates a node that connects to the named button device,\n"
    " * if it exists, and provides hooks to the user to read the state of any of\n"
    " * the sequentially numbered buttons associated with that device.\n"
    " *\n"
    " * It also can associate an arbitrary ButtonHandle with each button; when\n"
    " * buttons are associated with ButtonHandles, this node will put appropriate\n"
    " * up and down events on the data graph for each button state change.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ButtonNode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ButtonNode,
    PyType_GenericAlloc,
    Dtool_new_ButtonNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ButtonNode,
  Dtool_UpcastInterface_ButtonNode,
  Dtool_DowncastInterface_ButtonNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ButtonNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != nullptr);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_ButtonNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DataNode);
    Dtool_ButtonNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ButtonNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ButtonNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ButtonNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ButtonNode);
  }
}

/**
 * Python method tables for DialNode (DialNode)
 */
static PyMethodDef Dtool_Methods_DialNode[] = {
  {"is_valid", &Dtool_DialNode_is_valid_153, METH_NOARGS, (const char *)Dtool_DialNode_is_valid_153_comment},
  {"isValid", &Dtool_DialNode_is_valid_153, METH_NOARGS, (const char *)Dtool_DialNode_is_valid_153_comment},
  {"get_num_dials", &Dtool_DialNode_get_num_dials_154, METH_NOARGS, (const char *)Dtool_DialNode_get_num_dials_154_comment},
  {"getNumDials", &Dtool_DialNode_get_num_dials_154, METH_NOARGS, (const char *)Dtool_DialNode_get_num_dials_154_comment},
  {"read_dial", &Dtool_DialNode_read_dial_155, METH_O, (const char *)Dtool_DialNode_read_dial_155_comment},
  {"readDial", &Dtool_DialNode_read_dial_155, METH_O, (const char *)Dtool_DialNode_read_dial_155_comment},
  {"is_dial_known", &Dtool_DialNode_is_dial_known_156, METH_O, (const char *)Dtool_DialNode_is_dial_known_156_comment},
  {"isDialKnown", &Dtool_DialNode_is_dial_known_156, METH_O, (const char *)Dtool_DialNode_is_dial_known_156_comment},
  {"get_class_type", &Dtool_DialNode_get_class_type_157, METH_NOARGS | METH_STATIC, (const char *)Dtool_DialNode_get_class_type_157_comment},
  {"getClassType", &Dtool_DialNode_get_class_type_157, METH_NOARGS | METH_STATIC, (const char *)Dtool_DialNode_get_class_type_157_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DialNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DialNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DialNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DialNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DialNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DialNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DialNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DialNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DialNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DialNode,
    &Dtool_SequenceMethods_DialNode,
    &Dtool_MappingMethods_DialNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DialNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the primary interface to infinite dial type devices associated with\n"
    " * a ClientBase.  This creates a node that connects to the named dial device,\n"
    " * if it exists, and provides hooks to the user to read the state of any of\n"
    " * the sequentially numbered dial controls associated with that device.\n"
    " *\n"
    " * A dial is a rotating device that does not have stops--it can keep rotating\n"
    " * any number of times.  Therefore it does not have a specific position at any\n"
    " * given time, unlike an AnalogDevice.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DialNode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DialNode,
    PyType_GenericAlloc,
    Dtool_new_DialNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DialNode,
  Dtool_UpcastInterface_DialNode,
  Dtool_DowncastInterface_DialNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DialNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != nullptr);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_DialNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DataNode);
    Dtool_DialNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DialNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DialNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DialNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DialNode);
  }
}

/**
 * Python method tables for InputDeviceSet (InputDeviceSet)
 */
static PyMethodDef Dtool_Methods_InputDeviceSet[] = {
  {"assign", &Dtool_InputDeviceSet_operator_160, METH_O, (const char *)Dtool_InputDeviceSet_operator_160_comment},
  {"clear", &Dtool_InputDeviceSet_clear_162, METH_NOARGS, (const char *)Dtool_InputDeviceSet_clear_162_comment},
  {"reserve", &Dtool_InputDeviceSet_reserve_163, METH_O, (const char *)Dtool_InputDeviceSet_reserve_163_comment},
  {"output", &Dtool_InputDeviceSet_output_166, METH_O, (const char *)Dtool_InputDeviceSet_output_166_comment},
  {"write", (PyCFunction) &Dtool_InputDeviceSet_write_167, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_InputDeviceSet_write_167_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// InputDeviceSet slot sq_item -> operator []
//////////////////
static PyObject *Dtool_InputDeviceSet_operator_164_sq_item(PyObject *self, Py_ssize_t index) {
  InputDeviceSet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDeviceSet, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "InputDeviceSet index out of range");
    return nullptr;
  }
  // 1-inline InputDevice *InputDeviceSet::operator [](std::size_t index) const
  InputDevice *return_value = ((*(const InputDeviceSet*)local_this).operator [])(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_InputDevice, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(InputDeviceSet self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// InputDeviceSet slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_InputDeviceSet_size_165_sq_length(PyObject *self) {
  InputDeviceSet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDeviceSet, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
//  A __repr__ function
//     InputDeviceSet
//////////////////
static PyObject *Dtool_Repr_InputDeviceSet(PyObject *self) {
  InputDeviceSet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDeviceSet, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     InputDeviceSet
//////////////////
static PyObject *Dtool_Str_InputDeviceSet(PyObject *self) {
  InputDeviceSet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_InputDeviceSet, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_InputDeviceSet = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_InputDeviceSet = {
  &Dtool_InputDeviceSet_size_165_sq_length,
  nullptr,
  nullptr,
  &Dtool_InputDeviceSet_operator_164_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_InputDeviceSet = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.InputDeviceSet",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_InputDeviceSet,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_InputDeviceSet,
    &Dtool_NumberMethods_InputDeviceSet,
    &Dtool_SequenceMethods_InputDeviceSet,
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_InputDeviceSet,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Manages a list of InputDevice objects, as returned by various\n"
    " * InputDeviceManager methods.  This is implemented like a set, meaning the\n"
    " * same device cannot occur more than once.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_InputDeviceSet,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_InputDeviceSet,
    PyType_GenericAlloc,
    Dtool_new_InputDeviceSet,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_InputDeviceSet,
  Dtool_UpcastInterface_InputDeviceSet,
  Dtool_DowncastInterface_InputDeviceSet,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_InputDeviceSet(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_InputDeviceSet._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_InputDeviceSet._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_InputDeviceSet) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(InputDeviceSet)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_InputDeviceSet);
  }
}

/**
 * Python method tables for InputDeviceManager (InputDeviceManager)
 */
static PyMethodDef Dtool_Methods_InputDeviceManager[] = {
  {"get_devices", &Dtool_InputDeviceManager_get_devices_169, METH_VARARGS, (const char *)Dtool_InputDeviceManager_get_devices_169_comment},
  {"getDevices", &Dtool_InputDeviceManager_get_devices_169, METH_VARARGS, (const char *)Dtool_InputDeviceManager_get_devices_169_comment},
  {"add_device", &Dtool_InputDeviceManager_add_device_170, METH_O, (const char *)Dtool_InputDeviceManager_add_device_170_comment},
  {"addDevice", &Dtool_InputDeviceManager_add_device_170, METH_O, (const char *)Dtool_InputDeviceManager_add_device_170_comment},
  {"remove_device", &Dtool_InputDeviceManager_remove_device_171, METH_O, (const char *)Dtool_InputDeviceManager_remove_device_171_comment},
  {"removeDevice", &Dtool_InputDeviceManager_remove_device_171, METH_O, (const char *)Dtool_InputDeviceManager_remove_device_171_comment},
  {"update", &Dtool_InputDeviceManager_update_172, METH_NOARGS, (const char *)Dtool_InputDeviceManager_update_172_comment},
  {"get_global_ptr", &Dtool_InputDeviceManager_get_global_ptr_173, METH_NOARGS | METH_STATIC, (const char *)Dtool_InputDeviceManager_get_global_ptr_173_comment},
  {"getGlobalPtr", &Dtool_InputDeviceManager_get_global_ptr_173, METH_NOARGS | METH_STATIC, (const char *)Dtool_InputDeviceManager_get_global_ptr_173_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_InputDeviceManager = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_InputDeviceManager = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.InputDeviceManager",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_InputDeviceManager,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_InputDeviceManager,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class keeps track of all the devices on a system, and sends out events\n"
    " * when a device has been hot-plugged.\n"
    " *\n"
    " * @since 1.10.0\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_InputDeviceManager,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_InputDeviceManager,
    PyType_GenericAlloc,
    Dtool_new_InputDeviceManager,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_InputDeviceManager,
  Dtool_UpcastInterface_InputDeviceManager,
  Dtool_DowncastInterface_InputDeviceManager,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_InputDeviceManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_InputDeviceManager._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_InputDeviceManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_InputDeviceManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(InputDeviceManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_InputDeviceManager);
  }
}

/**
 * Python method tables for InputDeviceNode (InputDeviceNode)
 */
static PyMethodDef Dtool_Methods_InputDeviceNode[] = {
  {"get_class_type", &Dtool_InputDeviceNode_get_class_type_180, METH_NOARGS | METH_STATIC, (const char *)Dtool_InputDeviceNode_get_class_type_180_comment},
  {"getClassType", &Dtool_InputDeviceNode_get_class_type_180, METH_NOARGS | METH_STATIC, (const char *)Dtool_InputDeviceNode_get_class_type_180_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_InputDeviceNode[] = {
  {(char *)"device", &Dtool_InputDeviceNode_device_Getter, &Dtool_InputDeviceNode_device_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_InputDeviceNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_InputDeviceNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_InputDeviceNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_InputDeviceNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_InputDeviceNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_InputDeviceNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.InputDeviceNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_InputDeviceNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_InputDeviceNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_InputDeviceNode,
    &Dtool_SequenceMethods_InputDeviceNode,
    &Dtool_MappingMethods_InputDeviceNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_InputDeviceNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Reads the controller data sent from the InputDeviceManager, and transmits\n"
    " * it down the data graph.\n"
    " *\n"
    " * This is intended to only be accessed from the app thread.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_InputDeviceNode,
    nullptr, // tp_members
    Dtool_Properties_InputDeviceNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_InputDeviceNode,
    PyType_GenericAlloc,
    Dtool_new_InputDeviceNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_InputDeviceNode,
  Dtool_UpcastInterface_InputDeviceNode,
  Dtool_DowncastInterface_InputDeviceNode,
  (CoerceFunction)Dtool_ConstCoerce_InputDeviceNode,
  (CoerceFunction)Dtool_Coerce_InputDeviceNode,
};

static void Dtool_PyModuleClassInit_InputDeviceNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != nullptr);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_InputDeviceNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DataNode);
    Dtool_InputDeviceNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_InputDeviceNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_InputDeviceNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(InputDeviceNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_InputDeviceNode);
  }
}

/**
 * Python method tables for LinuxJoystickDevice (LinuxJoystickDevice)
 */
static PyMethodDef Dtool_Methods_LinuxJoystickDevice[] = {
  {"check_events", &Dtool_LinuxJoystickDevice_check_events_184, METH_NOARGS, (const char *)Dtool_LinuxJoystickDevice_check_events_184_comment},
  {"checkEvents", &Dtool_LinuxJoystickDevice_check_events_184, METH_NOARGS, (const char *)Dtool_LinuxJoystickDevice_check_events_184_comment},
  {"get_class_type", &Dtool_LinuxJoystickDevice_get_class_type_185, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinuxJoystickDevice_get_class_type_185_comment},
  {"getClassType", &Dtool_LinuxJoystickDevice_get_class_type_185, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinuxJoystickDevice_get_class_type_185_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LinuxJoystickDevice = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinuxJoystickDevice = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LinuxJoystickDevice = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LinuxJoystickDevice = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LinuxJoystickDevice = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LinuxJoystickDevice = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LinuxJoystickDevice",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LinuxJoystickDevice,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LinuxJoystickDevice,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LinuxJoystickDevice,
    &Dtool_SequenceMethods_LinuxJoystickDevice,
    &Dtool_MappingMethods_LinuxJoystickDevice,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LinuxJoystickDevice,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a type of device that uses the Linux /dev/input/js# API to read\n"
    " * data from a game controller.\n"
    " *\n"
    " * @since 1.10.0\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LinuxJoystickDevice,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LinuxJoystickDevice,
    PyType_GenericAlloc,
    Dtool_new_LinuxJoystickDevice,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinuxJoystickDevice,
  Dtool_UpcastInterface_LinuxJoystickDevice,
  Dtool_DowncastInterface_LinuxJoystickDevice,
  (CoerceFunction)Dtool_ConstCoerce_LinuxJoystickDevice,
  (CoerceFunction)Dtool_Coerce_LinuxJoystickDevice,
};

static void Dtool_PyModuleClassInit_LinuxJoystickDevice(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_InputDevice(nullptr);
    Dtool_LinuxJoystickDevice._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_InputDevice);
    Dtool_LinuxJoystickDevice._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LinuxJoystickDevice._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinuxJoystickDevice) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinuxJoystickDevice)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinuxJoystickDevice);
  }
}

/**
 * Python method tables for TrackerNode (TrackerNode)
 */
static PyMethodDef Dtool_Methods_TrackerNode[] = {
  {"is_valid", &Dtool_TrackerNode_is_valid_188, METH_NOARGS, (const char *)Dtool_TrackerNode_is_valid_188_comment},
  {"isValid", &Dtool_TrackerNode_is_valid_188, METH_NOARGS, (const char *)Dtool_TrackerNode_is_valid_188_comment},
  {"get_pos", &Dtool_TrackerNode_get_pos_189, METH_NOARGS, (const char *)Dtool_TrackerNode_get_pos_189_comment},
  {"getPos", &Dtool_TrackerNode_get_pos_189, METH_NOARGS, (const char *)Dtool_TrackerNode_get_pos_189_comment},
  {"get_orient", &Dtool_TrackerNode_get_orient_190, METH_NOARGS, (const char *)Dtool_TrackerNode_get_orient_190_comment},
  {"getOrient", &Dtool_TrackerNode_get_orient_190, METH_NOARGS, (const char *)Dtool_TrackerNode_get_orient_190_comment},
  {"get_transform", &Dtool_TrackerNode_get_transform_191, METH_NOARGS, (const char *)Dtool_TrackerNode_get_transform_191_comment},
  {"getTransform", &Dtool_TrackerNode_get_transform_191, METH_NOARGS, (const char *)Dtool_TrackerNode_get_transform_191_comment},
  {"get_time", &Dtool_TrackerNode_get_time_192, METH_NOARGS, (const char *)Dtool_TrackerNode_get_time_192_comment},
  {"getTime", &Dtool_TrackerNode_get_time_192, METH_NOARGS, (const char *)Dtool_TrackerNode_get_time_192_comment},
  {"has_time", &Dtool_TrackerNode_has_time_193, METH_NOARGS, (const char *)Dtool_TrackerNode_has_time_193_comment},
  {"hasTime", &Dtool_TrackerNode_has_time_193, METH_NOARGS, (const char *)Dtool_TrackerNode_has_time_193_comment},
  {"set_tracker_coordinate_system", &Dtool_TrackerNode_set_tracker_coordinate_system_194, METH_O, (const char *)Dtool_TrackerNode_set_tracker_coordinate_system_194_comment},
  {"setTrackerCoordinateSystem", &Dtool_TrackerNode_set_tracker_coordinate_system_194, METH_O, (const char *)Dtool_TrackerNode_set_tracker_coordinate_system_194_comment},
  {"get_tracker_coordinate_system", &Dtool_TrackerNode_get_tracker_coordinate_system_195, METH_NOARGS, (const char *)Dtool_TrackerNode_get_tracker_coordinate_system_195_comment},
  {"getTrackerCoordinateSystem", &Dtool_TrackerNode_get_tracker_coordinate_system_195, METH_NOARGS, (const char *)Dtool_TrackerNode_get_tracker_coordinate_system_195_comment},
  {"set_graph_coordinate_system", &Dtool_TrackerNode_set_graph_coordinate_system_196, METH_O, (const char *)Dtool_TrackerNode_set_graph_coordinate_system_196_comment},
  {"setGraphCoordinateSystem", &Dtool_TrackerNode_set_graph_coordinate_system_196, METH_O, (const char *)Dtool_TrackerNode_set_graph_coordinate_system_196_comment},
  {"get_graph_coordinate_system", &Dtool_TrackerNode_get_graph_coordinate_system_197, METH_NOARGS, (const char *)Dtool_TrackerNode_get_graph_coordinate_system_197_comment},
  {"getGraphCoordinateSystem", &Dtool_TrackerNode_get_graph_coordinate_system_197, METH_NOARGS, (const char *)Dtool_TrackerNode_get_graph_coordinate_system_197_comment},
  {"get_class_type", &Dtool_TrackerNode_get_class_type_198, METH_NOARGS | METH_STATIC, (const char *)Dtool_TrackerNode_get_class_type_198_comment},
  {"getClassType", &Dtool_TrackerNode_get_class_type_198, METH_NOARGS | METH_STATIC, (const char *)Dtool_TrackerNode_get_class_type_198_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TrackerNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TrackerNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TrackerNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TrackerNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TrackerNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TrackerNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TrackerNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TrackerNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TrackerNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TrackerNode,
    &Dtool_SequenceMethods_TrackerNode,
    &Dtool_MappingMethods_TrackerNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TrackerNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class reads the position and orientation information from a tracker\n"
    " * device and makes it available as a transformation on the data graph.\n"
    " * It is also the primary interface to a Tracker object associated with a\n"
    " * ClientBase.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TrackerNode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TrackerNode,
    PyType_GenericAlloc,
    Dtool_new_TrackerNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TrackerNode,
  Dtool_UpcastInterface_TrackerNode,
  Dtool_DowncastInterface_TrackerNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TrackerNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != nullptr);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_TrackerNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DataNode);
    Dtool_TrackerNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TrackerNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TrackerNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TrackerNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TrackerNode);
  }
}

/**
 * Python method tables for VirtualMouse (VirtualMouse)
 */
static PyMethodDef Dtool_Methods_VirtualMouse[] = {
  {"set_mouse_pos", (PyCFunction) &Dtool_VirtualMouse_set_mouse_pos_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualMouse_set_mouse_pos_201_comment},
  {"setMousePos", (PyCFunction) &Dtool_VirtualMouse_set_mouse_pos_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualMouse_set_mouse_pos_201_comment},
  {"set_window_size", (PyCFunction) &Dtool_VirtualMouse_set_window_size_202, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualMouse_set_window_size_202_comment},
  {"setWindowSize", (PyCFunction) &Dtool_VirtualMouse_set_window_size_202, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualMouse_set_window_size_202_comment},
  {"set_mouse_on", &Dtool_VirtualMouse_set_mouse_on_203, METH_O, (const char *)Dtool_VirtualMouse_set_mouse_on_203_comment},
  {"setMouseOn", &Dtool_VirtualMouse_set_mouse_on_203, METH_O, (const char *)Dtool_VirtualMouse_set_mouse_on_203_comment},
  {"press_button", &Dtool_VirtualMouse_press_button_204, METH_O, (const char *)Dtool_VirtualMouse_press_button_204_comment},
  {"pressButton", &Dtool_VirtualMouse_press_button_204, METH_O, (const char *)Dtool_VirtualMouse_press_button_204_comment},
  {"release_button", &Dtool_VirtualMouse_release_button_205, METH_O, (const char *)Dtool_VirtualMouse_release_button_205_comment},
  {"releaseButton", &Dtool_VirtualMouse_release_button_205, METH_O, (const char *)Dtool_VirtualMouse_release_button_205_comment},
  {"get_class_type", &Dtool_VirtualMouse_get_class_type_206, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualMouse_get_class_type_206_comment},
  {"getClassType", &Dtool_VirtualMouse_get_class_type_206, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualMouse_get_class_type_206_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_VirtualMouse = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualMouse = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VirtualMouse = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VirtualMouse = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VirtualMouse = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VirtualMouse = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VirtualMouse",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualMouse,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VirtualMouse,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_VirtualMouse,
    &Dtool_SequenceMethods_VirtualMouse,
    &Dtool_MappingMethods_VirtualMouse,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VirtualMouse,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Poses as a MouseAndKeyboard object in the datagraph, but accepts input from\n"
    " * user calls, rather than reading the actual mouse and keyboard from an input\n"
    " * device.  The user can write high-level code to put the mouse wherever\n"
    " * he/she wants, and to insert keypresses on demand.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VirtualMouse,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VirtualMouse,
    PyType_GenericAlloc,
    Dtool_new_VirtualMouse,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualMouse,
  Dtool_UpcastInterface_VirtualMouse,
  Dtool_DowncastInterface_VirtualMouse,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VirtualMouse(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != nullptr);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_VirtualMouse._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DataNode);
    Dtool_VirtualMouse._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VirtualMouse._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualMouse) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualMouse)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualMouse);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3device_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    InputDevice::init_type();
    TypeHandle handle = InputDevice::get_class_type();
    Dtool_InputDevice._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_InputDevice);
  }
  {
    ClientBase::init_type();
    TypeHandle handle = ClientBase::get_class_type();
    Dtool_ClientBase._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ClientBase);
  }
  {
    AnalogNode::init_type();
    TypeHandle handle = AnalogNode::get_class_type();
    Dtool_AnalogNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AnalogNode);
  }
  {
    ButtonNode::init_type();
    TypeHandle handle = ButtonNode::get_class_type();
    Dtool_ButtonNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ButtonNode);
  }
  {
    DialNode::init_type();
    TypeHandle handle = DialNode::get_class_type();
    Dtool_DialNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_DialNode);
  }
  {
    InputDeviceNode::init_type();
    TypeHandle handle = InputDeviceNode::get_class_type();
    Dtool_InputDeviceNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_InputDeviceNode);
  }
  {
    LinuxJoystickDevice::init_type();
    TypeHandle handle = LinuxJoystickDevice::get_class_type();
    Dtool_LinuxJoystickDevice._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LinuxJoystickDevice);
  }
  {
    TrackerNode::init_type();
    TypeHandle handle = TrackerNode::get_class_type();
    Dtool_TrackerNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TrackerNode);
  }
  {
    VirtualMouse::init_type();
    TypeHandle handle = VirtualMouse::get_class_type();
    Dtool_VirtualMouse._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_VirtualMouse);
  }
}

void Dtool_libp3device_BuildInstants(PyObject *module) {
  (void) module;
  // TrackerData
  Dtool_PyModuleClassInit_TrackerData(module);
  PyModule_AddObject(module, "TrackerData", (PyObject *)&Dtool_TrackerData);
  // InputDevice
  Dtool_PyModuleClassInit_InputDevice(module);
  PyModule_AddObject(module, "InputDevice", (PyObject *)&Dtool_InputDevice);
  // ClientBase
  Dtool_PyModuleClassInit_ClientBase(module);
  PyModule_AddObject(module, "ClientBase", (PyObject *)&Dtool_ClientBase);
  // AnalogNode
  Dtool_PyModuleClassInit_AnalogNode(module);
  PyModule_AddObject(module, "AnalogNode", (PyObject *)&Dtool_AnalogNode);
  // ButtonNode
  Dtool_PyModuleClassInit_ButtonNode(module);
  PyModule_AddObject(module, "ButtonNode", (PyObject *)&Dtool_ButtonNode);
  // DialNode
  Dtool_PyModuleClassInit_DialNode(module);
  PyModule_AddObject(module, "DialNode", (PyObject *)&Dtool_DialNode);
  // InputDeviceSet
  Dtool_PyModuleClassInit_InputDeviceSet(module);
  PyModule_AddObject(module, "InputDeviceSet", (PyObject *)&Dtool_InputDeviceSet);
  // InputDeviceManager
  Dtool_PyModuleClassInit_InputDeviceManager(module);
  PyModule_AddObject(module, "InputDeviceManager", (PyObject *)&Dtool_InputDeviceManager);
  // InputDeviceNode
  Dtool_PyModuleClassInit_InputDeviceNode(module);
  PyModule_AddObject(module, "InputDeviceNode", (PyObject *)&Dtool_InputDeviceNode);
  // LinuxJoystickDevice
  Dtool_PyModuleClassInit_LinuxJoystickDevice(module);
  PyModule_AddObject(module, "LinuxJoystickDevice", (PyObject *)&Dtool_LinuxJoystickDevice);
  // TrackerNode
  Dtool_PyModuleClassInit_TrackerNode(module);
  PyModule_AddObject(module, "TrackerNode", (PyObject *)&Dtool_TrackerNode);
  // VirtualMouse
  Dtool_PyModuleClassInit_VirtualMouse(module);
  PyModule_AddObject(module, "VirtualMouse", (PyObject *)&Dtool_VirtualMouse);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3device_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3device_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613488,  /* file_identifier */
  "libp3device",  /* library_name */
  "k0F5",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3device.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  377  /* next_index */
};

Configure(_in_configure_libp3device);
ConfigureFn(_in_configure_libp3device) {
  interrogate_request_module(&_in_module_def);
}

