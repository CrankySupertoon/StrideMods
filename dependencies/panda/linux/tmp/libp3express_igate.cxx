/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/express -Ipanda/src/express -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3express_igate.cxx -od built/pandac/input/libp3express.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/express -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3express buffer.h checksumHashGenerator.h circBuffer.h compress_string.h config_express.h copy_stream.h datagram.h datagramGenerator.h datagramIterator.h datagramSink.h datagram_ext.h dcast.h encrypt_string.h error_utils.h export_dtool.h fileReference.h hashGeneratorBase.h hashVal.h indirectLess.h memoryInfo.h memoryUsage.h memoryUsagePointerCounts.h memoryUsagePointers.h memoryUsagePointers_ext.h multifile.h namable.h nodePointerTo.h nodePointerToBase.h nodeReferenceCount.h openSSLWrapper.h ordered_vector.h p3express_composite1.cxx p3express_composite2.cxx p3express_ext_composite.cxx pStatCollectorForwardBase.h password_hash.h patchfile.h pointerTo.h pointerToArray.h pointerToArrayBase.h pointerToArray_ext.h pointerToBase.h pointerToVoid.h pta_double.h pta_float.h pta_int.h pta_stdfloat.h pta_uchar.h ramfile.h ramfile_ext.h referenceCount.h stringStream.h stringStreamBuf.h stringStream_ext.h subStream.h subStreamBuf.h subfileInfo.h temporaryFile.h trueClock.h typedReferenceCount.h typedef.h virtualFile.h virtualFileComposite.h virtualFileList.h virtualFileMount.h virtualFileMountAndroidAsset.h virtualFileMountMultifile.h virtualFileMountRamdisk.h virtualFileMountSystem.h virtualFileSimple.h virtualFileSystem.h virtualFileSystem_ext.h virtualFile_ext.h weakPointerCallback.h weakPointerTo.h weakPointerToBase.h weakPointerToVoid.h weakReferenceList.h windowsRegistry.h zStream.h zStreamBuf.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "bigEndian.h"
#include "buffer.h"
#include "checksumHashGenerator.h"
#include "circBuffer.h"
#include "compress_string.h"
#include "configFlags.h"
#include "configPage.h"
#include "configPageManager.h"
#include "configVariable.h"
#include "configVariableBase.h"
#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "configVariableFilename.h"
#include "configVariableInt.h"
#include "configVariableInt64.h"
#include "configVariableList.h"
#include "configVariableManager.h"
#include "configVariableSearchPath.h"
#include "configVariableString.h"
#include "config_express.h"
#include "copy_stream.h"
#include "datagram.h"
#include "datagramGenerator.h"
#include "datagramIterator.h"
#include "datagramSink.h"
#include "datagram_ext.h"
#include "dcast.h"
#include "dtoolbase.h"
#include "encryptStream.h"
#include "encrypt_string.h"
#include "error_utils.h"
#include "export_dtool.h"
#include "extension.h"
#include "fileReference.h"
#include "filename.h"
#include "globPattern.h"
#include "hashGeneratorBase.h"
#include "hashVal.h"
#include "indirectLess.h"
#include "littleEndian.h"
#include "memoryInfo.h"
#include "memoryUsage.h"
#include "memoryUsagePointerCounts.h"
#include "memoryUsagePointers.h"
#include "memoryUsagePointers_ext.h"
#include "multifile.h"
#include "namable.h"
#include "nodePointerTo.h"
#include "nodePointerToBase.h"
#include "nodeReferenceCount.h"
#include "numeric_types.h"
#include "openSSLWrapper.h"
#include <openssl/err.h>
#include <openssl/rand.h>
#include <openssl/ssl.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include "ordered_vector.h"
#include "pStatCollectorForwardBase.h"
#include "pandaFileStream.h"
#include "pandaSystem.h"
#include "pandabase.h"
#include "password_hash.h"
#include "patchfile.h"
#include "pnotify.h"
#include "pointerTo.h"
#include "pointerToArray.h"
#include "pointerToArrayBase.h"
#include "pointerToArray_ext.h"
#include "pointerToBase.h"
#include "pointerToVoid.h"
#include "pta_double.h"
#include "pta_float.h"
#include "pta_int.h"
#include "pta_stdfloat.h"
#include "pta_uchar.h"
#include "pvector.h"
#include "py_panda.h"
#include "ramfile.h"
#include "ramfile_ext.h"
#include "referenceCount.h"
#include "streamReader.h"
#include "streamWrapper.h"
#include "streamWriter.h"
#include <string>
#include "stringStream.h"
#include "stringStreamBuf.h"
#include "stringStream_ext.h"
#include "subStream.h"
#include "subStreamBuf.h"
#include "subfileInfo.h"
#include "temporaryFile.h"
#include "trueClock.h"
#include "typeHandle.h"
#include "typedObject.h"
#include "typedReferenceCount.h"
#include "typedef.h"
#include "vector_uchar.h"
#include "virtualFile.h"
#include "virtualFileComposite.h"
#include "virtualFileList.h"
#include "virtualFileMount.h"
#include "virtualFileMountAndroidAsset.h"
#include "virtualFileMountMultifile.h"
#include "virtualFileMountRamdisk.h"
#include "virtualFileMountSystem.h"
#include "virtualFileSimple.h"
#include "virtualFileSystem.h"
#include "virtualFileSystem_ext.h"
#include "virtualFile_ext.h"
#include "weakPointerCallback.h"
#include "weakPointerTo.h"
#include "weakPointerToBase.h"
#include "weakPointerToVoid.h"
#include "weakReferenceList.h"
#include "windowsRegistry.h"
#include "zStream.h"
#include "zStreamBuf.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class ConstPointerToArray_double
 */
typedef ConstPointerToArray< double > ConstPointerToArray_double_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_double, ConstPointerToArray_double_localtype, ConstPointerToArray_double);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_double = &Dtool_ConstPointerToArray_double;
static void Dtool_PyModuleClassInit_ConstPointerToArray_double(PyObject *module);
ConstPointerToArray< double > *Dtool_Coerce_ConstPointerToArray_double(PyObject *args, ConstPointerToArray< double > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_double
 */
typedef PointerToArrayBase< double > PointerToArrayBase_double_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_double, PointerToArrayBase_double_localtype, PointerToArrayBase_double);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_double = &Dtool_PointerToArrayBase_double;
static void Dtool_PyModuleClassInit_PointerToArrayBase_double(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_double
 */
typedef PointerToBase< ReferenceCountedVector< double > > PointerToBase_ReferenceCountedVector_double_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_double, PointerToBase_ReferenceCountedVector_double_localtype, PointerToBase_ReferenceCountedVector_double);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_double = &Dtool_PointerToBase_ReferenceCountedVector_double;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_double(PyObject *module);

/**
 * Forward declarations for top-level class PointerToVoid
 */
typedef PointerToVoid PointerToVoid_localtype;
Define_Module_Class(panda3d.core, PointerToVoid, PointerToVoid_localtype, PointerToVoid);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToVoid = &Dtool_PointerToVoid;
static void Dtool_PyModuleClassInit_PointerToVoid(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_float
 */
typedef ConstPointerToArray< float > ConstPointerToArray_float_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_float, ConstPointerToArray_float_localtype, ConstPointerToArray_float);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_float = &Dtool_ConstPointerToArray_float;
static void Dtool_PyModuleClassInit_ConstPointerToArray_float(PyObject *module);
ConstPointerToArray< float > *Dtool_Coerce_ConstPointerToArray_float(PyObject *args, ConstPointerToArray< float > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_float
 */
typedef PointerToArrayBase< float > PointerToArrayBase_float_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_float, PointerToArrayBase_float_localtype, PointerToArrayBase_float);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_float = &Dtool_PointerToArrayBase_float;
static void Dtool_PyModuleClassInit_PointerToArrayBase_float(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_float
 */
typedef PointerToBase< ReferenceCountedVector< float > > PointerToBase_ReferenceCountedVector_float_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_float, PointerToBase_ReferenceCountedVector_float_localtype, PointerToBase_ReferenceCountedVector_float);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_float = &Dtool_PointerToBase_ReferenceCountedVector_float;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_float(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_int
 */
typedef ConstPointerToArray< int > ConstPointerToArray_int_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_int, ConstPointerToArray_int_localtype, ConstPointerToArray_int);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_int = &Dtool_ConstPointerToArray_int;
static void Dtool_PyModuleClassInit_ConstPointerToArray_int(PyObject *module);
ConstPointerToArray< int > *Dtool_Coerce_ConstPointerToArray_int(PyObject *args, ConstPointerToArray< int > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_int
 */
typedef PointerToArrayBase< int > PointerToArrayBase_int_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_int, PointerToArrayBase_int_localtype, PointerToArrayBase_int);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_int = &Dtool_PointerToArrayBase_int;
static void Dtool_PyModuleClassInit_PointerToArrayBase_int(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_int
 */
typedef PointerToBase< ReferenceCountedVector< int > > PointerToBase_ReferenceCountedVector_int_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_int, PointerToBase_ReferenceCountedVector_int_localtype, PointerToBase_ReferenceCountedVector_int);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_int = &Dtool_PointerToBase_ReferenceCountedVector_int;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_int(PyObject *module);

/**
 * Forward declarations for top-level class ConstPointerToArray_unsigned_char
 */
typedef ConstPointerToArray< unsigned char > ConstPointerToArray_unsigned_char_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_unsigned_char, ConstPointerToArray_unsigned_char_localtype, ConstPointerToArray_unsigned_char);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_unsigned_char = &Dtool_ConstPointerToArray_unsigned_char;
static void Dtool_PyModuleClassInit_ConstPointerToArray_unsigned_char(PyObject *module);
ConstPointerToArray< unsigned char > *Dtool_Coerce_ConstPointerToArray_unsigned_char(PyObject *args, ConstPointerToArray< unsigned char > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_unsigned_char
 */
typedef PointerToArrayBase< unsigned char > PointerToArrayBase_unsigned_char_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_unsigned_char, PointerToArrayBase_unsigned_char_localtype, PointerToArrayBase_unsigned_char);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_unsigned_char = &Dtool_PointerToArrayBase_unsigned_char;
static void Dtool_PyModuleClassInit_PointerToArrayBase_unsigned_char(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_unsigned_char
 */
typedef PointerToBase< ReferenceCountedVector< unsigned char > > PointerToBase_ReferenceCountedVector_unsigned_char_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_unsigned_char, PointerToBase_ReferenceCountedVector_unsigned_char_localtype, PointerToBase_ReferenceCountedVector_unsigned_char);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char = &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_unsigned_char(PyObject *module);

/**
 * Forward declarations for top-level class PointerToArray_double
 */
typedef PointerToArray< double > PointerToArray_double_localtype;
Define_Module_Class(panda3d.core, PointerToArray_double, PointerToArray_double_localtype, PointerToArray_double);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_double = &Dtool_PointerToArray_double;
static void Dtool_PyModuleClassInit_PointerToArray_double(PyObject *module);
PointerToArray< double > *Dtool_Coerce_PointerToArray_double(PyObject *args, PointerToArray< double > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_float
 */
typedef PointerToArray< float > PointerToArray_float_localtype;
Define_Module_Class(panda3d.core, PointerToArray_float, PointerToArray_float_localtype, PointerToArray_float);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_float = &Dtool_PointerToArray_float;
static void Dtool_PyModuleClassInit_PointerToArray_float(PyObject *module);
PointerToArray< float > *Dtool_Coerce_PointerToArray_float(PyObject *args, PointerToArray< float > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_int
 */
typedef PointerToArray< int > PointerToArray_int_localtype;
Define_Module_Class(panda3d.core, PointerToArray_int, PointerToArray_int_localtype, PointerToArray_int);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_int = &Dtool_PointerToArray_int;
static void Dtool_PyModuleClassInit_PointerToArray_int(PyObject *module);
PointerToArray< int > *Dtool_Coerce_PointerToArray_int(PyObject *args, PointerToArray< int > &coerced);

/**
 * Forward declarations for top-level class PointerToArray_unsigned_char
 */
typedef PointerToArray< unsigned char > PointerToArray_unsigned_char_localtype;
Define_Module_Class(panda3d.core, PointerToArray_unsigned_char, PointerToArray_unsigned_char_localtype, PointerToArray_unsigned_char);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_unsigned_char = &Dtool_PointerToArray_unsigned_char;
static void Dtool_PyModuleClassInit_PointerToArray_unsigned_char(PyObject *module);
PointerToArray< unsigned char > *Dtool_Coerce_PointerToArray_unsigned_char(PyObject *args, PointerToArray< unsigned char > &coerced);

/**
 * Forward declarations for top-level class MemoryUsage
 */
typedef MemoryUsage MemoryUsage_localtype;
Define_Module_Class(panda3d.core, MemoryUsage, MemoryUsage_localtype, MemoryUsage);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MemoryUsage = &Dtool_MemoryUsage;
static void Dtool_PyModuleClassInit_MemoryUsage(PyObject *module);

/**
 * Forward declarations for top-level class ReferenceCount
 */
typedef ReferenceCount ReferenceCount_localtype;
Define_Module_ClassRef(panda3d.core, ReferenceCount, ReferenceCount_localtype, ReferenceCount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
static void Dtool_PyModuleClassInit_ReferenceCount(PyObject *module);

/**
 * Forward declarations for top-level class Buffer
 */
typedef Buffer Buffer_localtype;
Define_Module_ClassRef(panda3d.core, Buffer, Buffer_localtype, Buffer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Buffer = &Dtool_Buffer;
static void Dtool_PyModuleClassInit_Buffer(PyObject *module);

/**
 * Forward declarations for top-level class PStatCollectorForwardBase
 */
typedef PStatCollectorForwardBase PStatCollectorForwardBase_localtype;
Define_Module_ClassRef(panda3d.core, PStatCollectorForwardBase, PStatCollectorForwardBase_localtype, PStatCollectorForwardBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PStatCollectorForwardBase = &Dtool_PStatCollectorForwardBase;
static void Dtool_PyModuleClassInit_PStatCollectorForwardBase(PyObject *module);

/**
 * Forward declarations for top-level class NodeReferenceCount
 */
typedef NodeReferenceCount NodeReferenceCount_localtype;
Define_Module_ClassRef_Private(panda3d.core, NodeReferenceCount, NodeReferenceCount_localtype, NodeReferenceCount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodeReferenceCount = &Dtool_NodeReferenceCount;
static void Dtool_PyModuleClassInit_NodeReferenceCount(PyObject *module);

/**
 * Forward declarations for top-level class Datagram
 */
typedef Datagram Datagram_localtype;
Define_Module_Class(panda3d.core, Datagram, Datagram_localtype, Datagram);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
static void Dtool_PyModuleClassInit_Datagram(PyObject *module);
Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced);

/**
 * Forward declarations for top-level class DatagramGenerator
 */
typedef DatagramGenerator DatagramGenerator_localtype;
Define_Module_Class(panda3d.core, DatagramGenerator, DatagramGenerator_localtype, DatagramGenerator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramGenerator = &Dtool_DatagramGenerator;
static void Dtool_PyModuleClassInit_DatagramGenerator(PyObject *module);

/**
 * Forward declarations for top-level class DatagramIterator
 */
typedef DatagramIterator DatagramIterator_localtype;
Define_Module_Class(panda3d.core, DatagramIterator, DatagramIterator_localtype, DatagramIterator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramIterator = &Dtool_DatagramIterator;
static void Dtool_PyModuleClassInit_DatagramIterator(PyObject *module);
DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced);

/**
 * Forward declarations for top-level class DatagramSink
 */
typedef DatagramSink DatagramSink_localtype;
Define_Module_Class(panda3d.core, DatagramSink, DatagramSink_localtype, DatagramSink);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramSink = &Dtool_DatagramSink;
static void Dtool_PyModuleClassInit_DatagramSink(PyObject *module);

/**
 * Forward declarations for top-level class FileReference
 */
typedef FileReference FileReference_localtype;
Define_Module_ClassRef(panda3d.core, FileReference, FileReference_localtype, FileReference);
static struct Dtool_PyTypedObject *const Dtool_Ptr_FileReference = &Dtool_FileReference;
static void Dtool_PyModuleClassInit_FileReference(PyObject *module);
bool Dtool_ConstCoerce_FileReference(PyObject *args, CPT(FileReference) &coerced);
bool Dtool_Coerce_FileReference(PyObject *args, PT(FileReference) &coerced);

/**
 * Forward declarations for top-level class TypedReferenceCount
 */
typedef TypedReferenceCount TypedReferenceCount_localtype;
Define_Module_ClassRef(panda3d.core, TypedReferenceCount, TypedReferenceCount_localtype, TypedReferenceCount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
static void Dtool_PyModuleClassInit_TypedReferenceCount(PyObject *module);

/**
 * Forward declarations for top-level class Ramfile
 */
typedef Ramfile Ramfile_localtype;
Define_Module_Class(panda3d.core, Ramfile, Ramfile_localtype, Ramfile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Ramfile = &Dtool_Ramfile;
static void Dtool_PyModuleClassInit_Ramfile(PyObject *module);

/**
 * Forward declarations for top-level class HashVal
 */
typedef HashVal HashVal_localtype;
Define_Module_Class(panda3d.core, HashVal, HashVal_localtype, HashVal);
static struct Dtool_PyTypedObject *const Dtool_Ptr_HashVal = &Dtool_HashVal;
static void Dtool_PyModuleClassInit_HashVal(PyObject *module);

/**
 * Forward declarations for top-level class MemoryUsagePointers
 */
typedef MemoryUsagePointers MemoryUsagePointers_localtype;
Define_Module_Class(panda3d.core, MemoryUsagePointers, MemoryUsagePointers_localtype, MemoryUsagePointers);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MemoryUsagePointers = &Dtool_MemoryUsagePointers;
static void Dtool_PyModuleClassInit_MemoryUsagePointers(PyObject *module);

/**
 * Forward declarations for top-level class ISubStream
 */
typedef ISubStream ISubStream_localtype;
Define_Module_Class(panda3d.core, ISubStream, ISubStream_localtype, ISubStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ISubStream = &Dtool_ISubStream;
static void Dtool_PyModuleClassInit_ISubStream(PyObject *module);

/**
 * Forward declarations for top-level class OSubStream
 */
typedef OSubStream OSubStream_localtype;
Define_Module_Class(panda3d.core, OSubStream, OSubStream_localtype, OSubStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OSubStream = &Dtool_OSubStream;
static void Dtool_PyModuleClassInit_OSubStream(PyObject *module);

/**
 * Forward declarations for top-level class SubStream
 */
typedef SubStream SubStream_localtype;
Define_Module_Class(panda3d.core, SubStream, SubStream_localtype, SubStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SubStream = &Dtool_SubStream;
static void Dtool_PyModuleClassInit_SubStream(PyObject *module);

/**
 * Forward declarations for top-level class Multifile
 */
typedef Multifile Multifile_localtype;
Define_Module_ClassRef(panda3d.core, Multifile, Multifile_localtype, Multifile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Multifile = &Dtool_Multifile;
static void Dtool_PyModuleClassInit_Multifile(PyObject *module);

/**
 * Forward declarations for top-level class Namable
 */
typedef Namable Namable_localtype;
Define_Module_Class(panda3d.core, Namable, Namable_localtype, Namable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
static void Dtool_PyModuleClassInit_Namable(PyObject *module);

/**
 * Forward declarations for top-level class OpenSSLWrapper
 */
typedef OpenSSLWrapper OpenSSLWrapper_localtype;
Define_Module_Class_Private(panda3d.core, OpenSSLWrapper, OpenSSLWrapper_localtype, OpenSSLWrapper);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OpenSSLWrapper = &Dtool_OpenSSLWrapper;
static void Dtool_PyModuleClassInit_OpenSSLWrapper(PyObject *module);

/**
 * Forward declarations for top-level class SubfileInfo
 */
typedef SubfileInfo SubfileInfo_localtype;
Define_Module_Class(panda3d.core, SubfileInfo, SubfileInfo_localtype, SubfileInfo);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SubfileInfo = &Dtool_SubfileInfo;
static void Dtool_PyModuleClassInit_SubfileInfo(PyObject *module);

/**
 * Forward declarations for top-level class VirtualFile
 */
typedef VirtualFile VirtualFile_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFile, VirtualFile_localtype, VirtualFile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFile = &Dtool_VirtualFile;
static void Dtool_PyModuleClassInit_VirtualFile(PyObject *module);

/**
 * Forward declarations for top-level class VirtualFileComposite
 */
typedef VirtualFileComposite VirtualFileComposite_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFileComposite, VirtualFileComposite_localtype, VirtualFileComposite);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileComposite = &Dtool_VirtualFileComposite;
static void Dtool_PyModuleClassInit_VirtualFileComposite(PyObject *module);

/**
 * Forward declarations for top-level class VirtualFileMount
 */
typedef VirtualFileMount VirtualFileMount_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFileMount, VirtualFileMount_localtype, VirtualFileMount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileMount = &Dtool_VirtualFileMount;
static void Dtool_PyModuleClassInit_VirtualFileMount(PyObject *module);

/**
 * Forward declarations for top-level class VirtualFileMountMultifile
 */
typedef VirtualFileMountMultifile VirtualFileMountMultifile_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFileMountMultifile, VirtualFileMountMultifile_localtype, VirtualFileMountMultifile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileMountMultifile = &Dtool_VirtualFileMountMultifile;
static void Dtool_PyModuleClassInit_VirtualFileMountMultifile(PyObject *module);
bool Dtool_ConstCoerce_VirtualFileMountMultifile(PyObject *args, CPT(VirtualFileMountMultifile) &coerced);
bool Dtool_Coerce_VirtualFileMountMultifile(PyObject *args, PT(VirtualFileMountMultifile) &coerced);

/**
 * Forward declarations for top-level class VirtualFileMountRamdisk
 */
typedef VirtualFileMountRamdisk VirtualFileMountRamdisk_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFileMountRamdisk, VirtualFileMountRamdisk_localtype, VirtualFileMountRamdisk);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileMountRamdisk = &Dtool_VirtualFileMountRamdisk;
static void Dtool_PyModuleClassInit_VirtualFileMountRamdisk(PyObject *module);

/**
 * Forward declarations for top-level class VirtualFileMountSystem
 */
typedef VirtualFileMountSystem VirtualFileMountSystem_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFileMountSystem, VirtualFileMountSystem_localtype, VirtualFileMountSystem);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileMountSystem = &Dtool_VirtualFileMountSystem;
static void Dtool_PyModuleClassInit_VirtualFileMountSystem(PyObject *module);
bool Dtool_ConstCoerce_VirtualFileMountSystem(PyObject *args, CPT(VirtualFileMountSystem) &coerced);
bool Dtool_Coerce_VirtualFileMountSystem(PyObject *args, PT(VirtualFileMountSystem) &coerced);

/**
 * Forward declarations for top-level class VirtualFileSimple
 */
typedef VirtualFileSimple VirtualFileSimple_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFileSimple, VirtualFileSimple_localtype, VirtualFileSimple);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileSimple = &Dtool_VirtualFileSimple;
static void Dtool_PyModuleClassInit_VirtualFileSimple(PyObject *module);

/**
 * Forward declarations for top-level class TemporaryFile
 */
typedef TemporaryFile TemporaryFile_localtype;
Define_Module_ClassRef(panda3d.core, TemporaryFile, TemporaryFile_localtype, TemporaryFile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TemporaryFile = &Dtool_TemporaryFile;
static void Dtool_PyModuleClassInit_TemporaryFile(PyObject *module);

/**
 * Forward declarations for top-level class IDecompressStream
 */
typedef IDecompressStream IDecompressStream_localtype;
Define_Module_Class(panda3d.core, IDecompressStream, IDecompressStream_localtype, IDecompressStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_IDecompressStream = &Dtool_IDecompressStream;
static void Dtool_PyModuleClassInit_IDecompressStream(PyObject *module);

/**
 * Forward declarations for top-level class OCompressStream
 */
typedef OCompressStream OCompressStream_localtype;
Define_Module_Class(panda3d.core, OCompressStream, OCompressStream_localtype, OCompressStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OCompressStream = &Dtool_OCompressStream;
static void Dtool_PyModuleClassInit_OCompressStream(PyObject *module);

/**
 * Forward declarations for top-level class VirtualFileList
 */
typedef VirtualFileList VirtualFileList_localtype;
Define_Module_ClassRef(panda3d.core, VirtualFileList, VirtualFileList_localtype, VirtualFileList);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileList = &Dtool_VirtualFileList;
static void Dtool_PyModuleClassInit_VirtualFileList(PyObject *module);

/**
 * Forward declarations for top-level class VirtualFileSystem
 */
typedef VirtualFileSystem VirtualFileSystem_localtype;
Define_Module_Class(panda3d.core, VirtualFileSystem, VirtualFileSystem_localtype, VirtualFileSystem);
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFileSystem = &Dtool_VirtualFileSystem;
static void Dtool_PyModuleClassInit_VirtualFileSystem(PyObject *module);

/**
 * Forward declarations for top-level class PointerTo_VirtualFileMount
 */
typedef PointerTo< VirtualFileMount > PointerTo_VirtualFileMount_localtype;
Define_Module_Class(panda3d.core, PointerTo_VirtualFileMount, PointerTo_VirtualFileMount_localtype, PointerTo_VirtualFileMount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerTo_VirtualFileMount = &Dtool_PointerTo_VirtualFileMount;
static void Dtool_PyModuleClassInit_PointerTo_VirtualFileMount(PyObject *module);
PointerTo< VirtualFileMount > *Dtool_Coerce_PointerTo_VirtualFileMount(PyObject *args, PointerTo< VirtualFileMount > &coerced);

/**
 * Forward declarations for top-level class PointerToBase_VirtualFileMount
 */
typedef PointerToBase< VirtualFileMount > PointerToBase_VirtualFileMount_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_VirtualFileMount, PointerToBase_VirtualFileMount_localtype, PointerToBase_VirtualFileMount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_VirtualFileMount = &Dtool_PointerToBase_VirtualFileMount;
static void Dtool_PyModuleClassInit_PointerToBase_VirtualFileMount(PyObject *module);

/**
 * Forward declarations for top-level class StringStream
 */
typedef StringStream StringStream_localtype;
Define_Module_Class(panda3d.core, StringStream, StringStream_localtype, StringStream);
static struct Dtool_PyTypedObject *const Dtool_Ptr_StringStream = &Dtool_StringStream;
static void Dtool_PyModuleClassInit_StringStream(PyObject *module);

/**
 * Forward declarations for top-level class TrueClock
 */
typedef TrueClock TrueClock_localtype;
Define_Module_Class_Private(panda3d.core, TrueClock, TrueClock_localtype, TrueClock);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TrueClock = &Dtool_TrueClock;
static void Dtool_PyModuleClassInit_TrueClock(PyObject *module);

/**
 * Forward declarations for top-level class Patchfile
 */
typedef Patchfile Patchfile_localtype;
Define_Module_Class(panda3d.core, Patchfile, Patchfile_localtype, Patchfile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Patchfile = &Dtool_Patchfile;
static void Dtool_PyModuleClassInit_Patchfile(PyObject *module);

/**
 * Forward declarations for top-level class WeakPointerToVoid
 */
typedef WeakPointerToVoid WeakPointerToVoid_localtype;
Define_Module_Class(panda3d.core, WeakPointerToVoid, WeakPointerToVoid_localtype, WeakPointerToVoid);
static struct Dtool_PyTypedObject *const Dtool_Ptr_WeakPointerToVoid = &Dtool_WeakPointerToVoid;
static void Dtool_PyModuleClassInit_WeakPointerToVoid(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"ConstPointerToArray< double >", &Dtool_ConstPointerToArray_double},
  {"PointerToArrayBase< double >", &Dtool_PointerToArrayBase_double},
  {"PointerToBase< ReferenceCountedVector< double > >", &Dtool_PointerToBase_ReferenceCountedVector_double},
  {"PointerToVoid", &Dtool_PointerToVoid},
  {"ConstPointerToArray< float >", &Dtool_ConstPointerToArray_float},
  {"PointerToArrayBase< float >", &Dtool_PointerToArrayBase_float},
  {"PointerToBase< ReferenceCountedVector< float > >", &Dtool_PointerToBase_ReferenceCountedVector_float},
  {"ConstPointerToArray< int >", &Dtool_ConstPointerToArray_int},
  {"PointerToArrayBase< int >", &Dtool_PointerToArrayBase_int},
  {"PointerToBase< ReferenceCountedVector< int > >", &Dtool_PointerToBase_ReferenceCountedVector_int},
  {"ConstPointerToArray< unsigned char >", &Dtool_ConstPointerToArray_unsigned_char},
  {"PointerToArrayBase< unsigned char >", &Dtool_PointerToArrayBase_unsigned_char},
  {"PointerToBase< ReferenceCountedVector< unsigned char > >", &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char},
  {"PointerToArray< double >", &Dtool_PointerToArray_double},
  {"PointerToArray< float >", &Dtool_PointerToArray_float},
  {"PointerToArray< int >", &Dtool_PointerToArray_int},
  {"PointerToArray< unsigned char >", &Dtool_PointerToArray_unsigned_char},
  {"MemoryUsage", &Dtool_MemoryUsage},
  {"ReferenceCount", &Dtool_ReferenceCount},
  {"Buffer", &Dtool_Buffer},
  {"PStatCollectorForwardBase", &Dtool_PStatCollectorForwardBase},
  {"NodeReferenceCount", &Dtool_NodeReferenceCount},
  {"Datagram", &Dtool_Datagram},
  {"DatagramGenerator", &Dtool_DatagramGenerator},
  {"DatagramIterator", &Dtool_DatagramIterator},
  {"DatagramSink", &Dtool_DatagramSink},
  {"FileReference", &Dtool_FileReference},
  {"TypedReferenceCount", &Dtool_TypedReferenceCount},
  {"Ramfile", &Dtool_Ramfile},
  {"HashVal", &Dtool_HashVal},
  {"MemoryUsagePointers", &Dtool_MemoryUsagePointers},
  {"ISubStream", &Dtool_ISubStream},
  {"OSubStream", &Dtool_OSubStream},
  {"SubStream", &Dtool_SubStream},
  {"Multifile", &Dtool_Multifile},
  {"Namable", &Dtool_Namable},
  {"OpenSSLWrapper", &Dtool_OpenSSLWrapper},
  {"SubfileInfo", &Dtool_SubfileInfo},
  {"VirtualFile", &Dtool_VirtualFile},
  {"VirtualFileComposite", &Dtool_VirtualFileComposite},
  {"VirtualFileMount", &Dtool_VirtualFileMount},
  {"VirtualFileMountMultifile", &Dtool_VirtualFileMountMultifile},
  {"VirtualFileMountRamdisk", &Dtool_VirtualFileMountRamdisk},
  {"VirtualFileMountSystem", &Dtool_VirtualFileMountSystem},
  {"VirtualFileSimple", &Dtool_VirtualFileSimple},
  {"TemporaryFile", &Dtool_TemporaryFile},
  {"IDecompressStream", &Dtool_IDecompressStream},
  {"OCompressStream", &Dtool_OCompressStream},
  {"VirtualFileList", &Dtool_VirtualFileList},
  {"VirtualFileSystem", &Dtool_VirtualFileSystem},
  {"PointerTo< VirtualFileMount >", &Dtool_PointerTo_VirtualFileMount},
  {"PointerToBase< VirtualFileMount >", &Dtool_PointerToBase_VirtualFileMount},
  {"StringStream", &Dtool_StringStream},
  {"TrueClock", &Dtool_TrueClock},
  {"Patchfile", &Dtool_Patchfile},
  {"WeakPointerToVoid", &Dtool_WeakPointerToVoid},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ios_base", nullptr},
#define Dtool_Ptr_std_ios_base (imports[0].type)
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[1].type)
  {"std::istream", nullptr},
#define Dtool_Ptr_std_istream (imports[2].type)
  {"std::iostream", nullptr},
#define Dtool_Ptr_std_iostream (imports[3].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[4].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[5].type)
  {"std::basic_ios< char >", nullptr},
#define Dtool_Ptr_std_basic_ios_char (imports[6].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[7].type)
  {"DSearchPath", nullptr},
#define Dtool_Ptr_DSearchPath (imports[8].type)
  {"DSearchPath::Results", nullptr},
#define Dtool_Ptr_DSearchPath_Results (imports[9].type)
  {"StreamWriter", nullptr},
#define Dtool_Ptr_StreamWriter (imports[10].type)
  {"StreamReader", nullptr},
#define Dtool_Ptr_StreamReader (imports[11].type)
  {"IStreamWrapper", nullptr},
#define Dtool_Ptr_IStreamWrapper (imports[12].type)
  {"OStreamWrapper", nullptr},
#define Dtool_Ptr_OStreamWrapper (imports[13].type)
  {"StreamWrapper", nullptr},
#define Dtool_Ptr_StreamWrapper (imports[14].type)
  {nullptr, nullptr},
};
#endif

// std::ios_base
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ios_base;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ios_base = &Dtool_std_ios_base;
#endif
// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// std::istream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_istream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_istream = &Dtool_std_istream;
#endif
// std::iostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_iostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_iostream = &Dtool_std_iostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// std::basic_ios< char >
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_basic_ios_char;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_basic_ios_char = &Dtool_std_basic_ios_char;
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// DSearchPath
#ifndef LINK_ALL_STATIC
inline static DSearchPath *Dtool_Coerce_DSearchPath(PyObject *args, DSearchPath &coerced) {
  nassertr(Dtool_Ptr_DSearchPath != nullptr, nullptr);
  nassertr(Dtool_Ptr_DSearchPath->_Dtool_Coerce != nullptr, nullptr);
  return ((DSearchPath *(*)(PyObject *, DSearchPath &))Dtool_Ptr_DSearchPath->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DSearchPath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DSearchPath = &Dtool_DSearchPath;
extern DSearchPath *Dtool_Coerce_DSearchPath(PyObject *args, DSearchPath &coerced);
#endif
// DSearchPath::Results
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DSearchPath_Results;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DSearchPath_Results = &Dtool_DSearchPath_Results;
#endif
// StreamWriter
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_StreamWriter;
static struct Dtool_PyTypedObject *const Dtool_Ptr_StreamWriter = &Dtool_StreamWriter;
#endif
// StreamReader
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_StreamReader;
static struct Dtool_PyTypedObject *const Dtool_Ptr_StreamReader = &Dtool_StreamReader;
#endif
// IStreamWrapper
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_IStreamWrapper;
static struct Dtool_PyTypedObject *const Dtool_Ptr_IStreamWrapper = &Dtool_IStreamWrapper;
#endif
// OStreamWrapper
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_OStreamWrapper;
static struct Dtool_PyTypedObject *const Dtool_Ptr_OStreamWrapper = &Dtool_OStreamWrapper;
#endif
// StreamWrapper
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_StreamWrapper;
static struct Dtool_PyTypedObject *const Dtool_Ptr_StreamWrapper = &Dtool_StreamWrapper;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python function wrapper for:
 * std::string compress_string(std::string const &source, int compression_level)
 */
static PyObject *Dtool_compress_string_226(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-std::string compress_string(std::string const &source, int compression_level)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  int param1;
  static const char *keyword_list[] = {"source", "compression_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:compress_string", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    std::string return_value = (::compress_string)(std::string(param0_str, param0_len), (int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compress_string(str source, int compression_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_compress_string_226_comment =
  "C++ Interface:\n"
  "compress_string(str source, int compression_level)\n";
#else
static const char *Dtool_compress_string_226_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string decompress_string(std::string const &source)
 */
static PyObject *Dtool_decompress_string_227(PyObject *, PyObject *arg) {
  // 1-std::string decompress_string(std::string const &source)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    std::string return_value = (::decompress_string)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decompress_string(str source)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_decompress_string_227_comment =
  "C++ Interface:\n"
  "decompress_string(str source)\n";
#else
static const char *Dtool_decompress_string_227_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool compress_file(Filename const &source, Filename const &dest, int compression_level)
 */
static PyObject *Dtool_compress_file_228(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool compress_file(Filename const &source, Filename const &dest, int compression_level)
  PyObject *param0;
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"source", "dest", "compression_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:compress_file", (char **)keyword_list, &param0, &param1, &param2)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "compress_file", "Filename");
    }
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "compress_file", "Filename");
    }
    bool return_value = (::compress_file)(*param0_this, *param1_this, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compress_file(const Filename source, const Filename dest, int compression_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_compress_file_228_comment =
  "C++ Interface:\n"
  "compress_file(const Filename source, const Filename dest, int compression_level)\n";
#else
static const char *Dtool_compress_file_228_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool decompress_file(Filename const &source, Filename const &dest)
 */
static PyObject *Dtool_decompress_file_229(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool decompress_file(Filename const &source, Filename const &dest)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"source", "dest", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:decompress_file", (char **)keyword_list, &param0, &param1)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "decompress_file", "Filename");
    }
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "decompress_file", "Filename");
    }
    bool return_value = (::decompress_file)(*param0_this, *param1_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decompress_file(const Filename source, const Filename dest)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_decompress_file_229_comment =
  "C++ Interface:\n"
  "decompress_file(const Filename source, const Filename dest)\n";
#else
static const char *Dtool_decompress_file_229_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool compress_stream(std::istream &source, std::ostream &dest, int compression_level)
 */
static PyObject *Dtool_compress_stream_230(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool compress_stream(std::istream &source, std::ostream &dest, int compression_level)
  PyObject *param0;
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"source", "dest", "compression_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:compress_stream", (char **)keyword_list, &param0, &param1, &param2)) {
    std::istream *param0_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_std_istream, 0, "compress_stream", false, true);
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "compress_stream", false, true);
    if (param0_this != nullptr && param1_this != nullptr) {
      bool return_value = (::compress_stream)(*param0_this, *param1_this, (int)param2);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compress_stream(istream source, ostream dest, int compression_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_compress_stream_230_comment =
  "C++ Interface:\n"
  "compress_stream(istream source, ostream dest, int compression_level)\n";
#else
static const char *Dtool_compress_stream_230_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool decompress_stream(std::istream &source, std::ostream &dest)
 */
static PyObject *Dtool_decompress_stream_231(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool decompress_stream(std::istream &source, std::ostream &dest)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"source", "dest", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:decompress_stream", (char **)keyword_list, &param0, &param1)) {
    std::istream *param0_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_std_istream, 0, "decompress_stream", false, true);
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "decompress_stream", false, true);
    if (param0_this != nullptr && param1_this != nullptr) {
      bool return_value = (::decompress_stream)(*param0_this, *param1_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decompress_stream(istream source, ostream dest)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_decompress_stream_231_comment =
  "C++ Interface:\n"
  "decompress_stream(istream source, ostream dest)\n";
#else
static const char *Dtool_decompress_stream_231_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool copy_stream(std::istream &source, std::ostream &dest)
 */
static PyObject *Dtool_copy_stream_232(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool copy_stream(std::istream &source, std::ostream &dest)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"source", "dest", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:copy_stream", (char **)keyword_list, &param0, &param1)) {
    std::istream *param0_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_std_istream, 0, "copy_stream", false, true);
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "copy_stream", false, true);
    if (param0_this != nullptr && param1_this != nullptr) {
      bool return_value = (::copy_stream)(*param0_this, *param1_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_stream(istream source, ostream dest)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_copy_stream_232_comment =
  "C++ Interface:\n"
  "copy_stream(istream source, ostream dest)\n";
#else
static const char *Dtool_copy_stream_232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * vector_uchar encrypt_string(std::string const &source, std::string const &password, std::string const &algorithm = string(), int key_length = -1, int iteration_count = -1)
 */
static PyObject *Dtool_encrypt_string_372(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-vector_uchar encrypt_string(std::string const &source, std::string const &password, std::string const &algorithm = string(), int key_length = -1, int iteration_count = -1)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  int param3 = -1;
  int param4 = -1;
  static const char *keyword_list[] = {"source", "password", "algorithm", "key_length", "iteration_count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|s#ii:encrypt_string", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2_str, &param2_len, &param3, &param4)) {
    vector_uchar return_value = (::encrypt_string)(std::string(param0_str, param0_len), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (int)param3, (int)param4);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encrypt_string(str source, str password, str algorithm, int key_length, int iteration_count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_encrypt_string_372_comment =
  "C++ Interface:\n"
  "encrypt_string(str source, str password, str algorithm, int key_length, int iteration_count)\n";
#else
static const char *Dtool_encrypt_string_372_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string decrypt_string(vector_uchar const &source, std::string const &password)
 */
static PyObject *Dtool_decrypt_string_373(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-std::string decrypt_string(vector_uchar const &source, std::string const &password)
  unsigned char *param0_str = nullptr;
  Py_ssize_t param0_len;
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"source", "password", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "" FMTCHAR_BYTES "#s#:decrypt_string", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
    std::string return_value = (::decrypt_string)(vector_uchar(param0_str, param0_str + param0_len), std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decrypt_string(bytes source, str password)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_decrypt_string_373_comment =
  "C++ Interface:\n"
  "decrypt_string(bytes source, str password)\n";
#else
static const char *Dtool_decrypt_string_373_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool encrypt_file(Filename const &source, Filename const &dest, std::string const &password, std::string const &algorithm = string(), int key_length = -1, int iteration_count = -1)
 */
static PyObject *Dtool_encrypt_file_374(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool encrypt_file(Filename const &source, Filename const &dest, std::string const &password, std::string const &algorithm = string(), int key_length = -1, int iteration_count = -1)
  PyObject *param0;
  PyObject *param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  const char *param3_str = "";
  Py_ssize_t param3_len = 0;
  int param4 = -1;
  int param5 = -1;
  static const char *keyword_list[] = {"source", "dest", "password", "algorithm", "key_length", "iteration_count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#|s#ii:encrypt_file", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len, &param3_str, &param3_len, &param4, &param5)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "encrypt_file", "Filename");
    }
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "encrypt_file", "Filename");
    }
    bool return_value = (::encrypt_file)(*param0_this, *param1_this, std::string(param2_str, param2_len), std::string(param3_str, param3_len), (int)param4, (int)param5);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encrypt_file(const Filename source, const Filename dest, str password, str algorithm, int key_length, int iteration_count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_encrypt_file_374_comment =
  "C++ Interface:\n"
  "encrypt_file(const Filename source, const Filename dest, str password, str algorithm, int key_length, int iteration_count)\n";
#else
static const char *Dtool_encrypt_file_374_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool decrypt_file(Filename const &source, Filename const &dest, std::string const &password)
 */
static PyObject *Dtool_decrypt_file_375(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool decrypt_file(Filename const &source, Filename const &dest, std::string const &password)
  PyObject *param0;
  PyObject *param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"source", "dest", "password", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#:decrypt_file", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len)) {
    Filename param0_local;
    Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "decrypt_file", "Filename");
    }
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "decrypt_file", "Filename");
    }
    bool return_value = (::decrypt_file)(*param0_this, *param1_this, std::string(param2_str, param2_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decrypt_file(const Filename source, const Filename dest, str password)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_decrypt_file_375_comment =
  "C++ Interface:\n"
  "decrypt_file(const Filename source, const Filename dest, str password)\n";
#else
static const char *Dtool_decrypt_file_375_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool encrypt_stream(std::istream &source, std::ostream &dest, std::string const &password, std::string const &algorithm = string(), int key_length = -1, int iteration_count = -1)
 */
static PyObject *Dtool_encrypt_stream_376(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool encrypt_stream(std::istream &source, std::ostream &dest, std::string const &password, std::string const &algorithm = string(), int key_length = -1, int iteration_count = -1)
  PyObject *param0;
  PyObject *param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  const char *param3_str = "";
  Py_ssize_t param3_len = 0;
  int param4 = -1;
  int param5 = -1;
  static const char *keyword_list[] = {"source", "dest", "password", "algorithm", "key_length", "iteration_count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#|s#ii:encrypt_stream", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len, &param3_str, &param3_len, &param4, &param5)) {
    std::istream *param0_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_std_istream, 0, "encrypt_stream", false, true);
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "encrypt_stream", false, true);
    if (param0_this != nullptr && param1_this != nullptr) {
      bool return_value = (::encrypt_stream)(*param0_this, *param1_this, std::string(param2_str, param2_len), std::string(param3_str, param3_len), (int)param4, (int)param5);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encrypt_stream(istream source, ostream dest, str password, str algorithm, int key_length, int iteration_count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_encrypt_stream_376_comment =
  "C++ Interface:\n"
  "encrypt_stream(istream source, ostream dest, str password, str algorithm, int key_length, int iteration_count)\n";
#else
static const char *Dtool_encrypt_stream_376_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool decrypt_stream(std::istream &source, std::ostream &dest, std::string const &password)
 */
static PyObject *Dtool_decrypt_stream_377(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-bool decrypt_stream(std::istream &source, std::ostream &dest, std::string const &password)
  PyObject *param0;
  PyObject *param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"source", "dest", "password", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOs#:decrypt_stream", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len)) {
    std::istream *param0_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_std_istream, 0, "decrypt_stream", false, true);
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "decrypt_stream", false, true);
    if (param0_this != nullptr && param1_this != nullptr) {
      bool return_value = (::decrypt_stream)(*param0_this, *param1_this, std::string(param2_str, param2_len));
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decrypt_stream(istream source, ostream dest, str password)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_decrypt_stream_377_comment =
  "C++ Interface:\n"
  "decrypt_stream(istream source, ostream dest, str password)\n";
#else
static const char *Dtool_decrypt_stream_377_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string error_to_text(ErrorUtilCode err)
 */
static PyObject *Dtool_error_to_text_379(PyObject *, PyObject *arg) {
  // 1-std::string error_to_text(ErrorUtilCode err)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (::error_to_text)((ErrorUtilCode)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "error_to_text(int err)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_error_to_text_379_comment =
  "C++ Interface:\n"
  "error_to_text(int err)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_error_to_text_379_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int get_write_error(void)
 */
static PyObject *Dtool_get_write_error_380(PyObject *, PyObject *) {
  // 1-int get_write_error(void)
  int return_value = (::get_write_error)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_get_write_error_380_comment =
  "C++ Interface:\n"
  "get_write_error()\n";
#else
static const char *Dtool_get_write_error_380_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string handle_socket_error(void)
 */
static PyObject *Dtool_handle_socket_error_381(PyObject *, PyObject *) {
  // 1-std::string handle_socket_error(void)
  std::string return_value = (::handle_socket_error)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_handle_socket_error_381_comment =
  "C++ Interface:\n"
  "handle_socket_error()\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_handle_socket_error_381_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int get_network_error(void)
 */
static PyObject *Dtool_get_network_error_382(PyObject *, PyObject *) {
  // 1-int get_network_error(void)
  int return_value = (::get_network_error)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_get_network_error_382_comment =
  "C++ Interface:\n"
  "get_network_error()\n";
#else
static const char *Dtool_get_network_error_382_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string password_hash(std::string const &password, std::string const &salt, int iters, int keylen)
 */
static PyObject *Dtool_password_hash_737(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-std::string password_hash(std::string const &password, std::string const &salt, int iters, int keylen)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  int param2;
  int param3;
  static const char *keyword_list[] = {"password", "salt", "iters", "keylen", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#ii:password_hash", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len, &param2, &param3)) {
    std::string return_value = (::password_hash)(std::string(param0_str, param0_len), std::string(param1_str, param1_len), (int)param2, (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "password_hash(str password, str salt, int iters, int keylen)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_password_hash_737_comment =
  "C++ Interface:\n"
  "password_hash(str password, str salt, int iters, int keylen)\n";
#else
static const char *Dtool_password_hash_737_comment = nullptr;
#endif

/**
 * Python wrappers for functions of class ConstPointerToArray< double >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< double >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_double_clear_14(PyObject *self, PyObject *) {
  ConstPointerToArray< double > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_double, (void **)&local_this, "ConstPointerToArray_double.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< double >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_double_clear_14_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_double_clear_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double const &ConstPointerToArray< double >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_double_get_element_16(PyObject *self, PyObject *arg) {
  ConstPointerToArray< double > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_double)) {
    return nullptr;
  }
  // 1-inline double const &ConstPointerToArray< double >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    double return_value = ((*(const ConstPointerToArray< double >*)local_this).get_element)((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_double_get_element_16_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_double_get_element_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< double >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_double_get_data_18(PyObject *self, PyObject *) {
  ConstPointerToArray< double > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_double)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< double >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< double >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_double_get_data_18_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_double_get_data_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< double >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_double_get_subdata_19(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< double > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_double)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< double >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< double >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_double_get_subdata_19_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_double_get_subdata_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< double >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_double_get_ref_count_20(PyObject *self, PyObject *) {
  ConstPointerToArray< double > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_double)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< double >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< double >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_double_get_ref_count_20_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_double_get_ref_count_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< double >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_double_get_node_ref_count_21(PyObject *self, PyObject *) {
  ConstPointerToArray< double > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_double)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< double >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< double >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_double_get_node_ref_count_21_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_double_get_node_ref_count_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< double >::count(double const &) const
 */
static PyObject *Dtool_ConstPointerToArray_double_count_22(PyObject *self, PyObject *arg) {
  ConstPointerToArray< double > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_double)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< double >::count(double const &) const
  if (PyNumber_Check(arg)) {
    unsigned long int return_value = ((*(const ConstPointerToArray< double >*)local_this).count)(PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, double param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_double_count_22_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, double param0)\n";
#else
static const char *Dtool_ConstPointerToArray_double_count_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< double >::ConstPointerToArray(ConstPointerToArray< double > const &copy)
 * inline ConstPointerToArray< double >::ConstPointerToArray(PointerToArray< double > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_double(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< double >::ConstPointerToArray(ConstPointerToArray< double > const &copy)
      ConstPointerToArray< double > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_double);
      if (arg_this != nullptr) {
        ConstPointerToArray< double > *return_value = new ConstPointerToArray< double >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_double, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< double >::ConstPointerToArray(PointerToArray< double > const &copy)
      PointerToArray< double > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_double);
      if (arg_this != nullptr) {
        ConstPointerToArray< double > *return_value = new ConstPointerToArray< double >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_double, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< double >::ConstPointerToArray(ConstPointerToArray< double > const &copy)
      ConstPointerToArray< double > arg_local;
      ConstPointerToArray< double > const *arg_this = Dtool_Coerce_ConstPointerToArray_double(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< double > *return_value = new ConstPointerToArray< double >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_double, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< double >::ConstPointerToArray(PointerToArray< double > const &copy)
      PointerToArray< double > arg_local;
      PointerToArray< double > const *arg_this = Dtool_Coerce_PointerToArray_double(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< double > *return_value = new ConstPointerToArray< double >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_double, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< double > *Dtool_Coerce_ConstPointerToArray_double(PyObject *args, ConstPointerToArray< double > &coerced) {
  ConstPointerToArray< double > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_double)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< double > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< double >::ConstPointerToArray(PointerToArray< double > const &copy)
    PointerToArray< double > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_double);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< double >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_double(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_double) {
    printf("ConstPointerToArray_double ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< double > *local_this = (ConstPointerToArray< double > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_double) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_double) {
    return (PointerToArrayBase< double > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_double) {
    return (PointerToBase< ReferenceCountedVector< double > > *)(PointerToArrayBase< double > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< double > > *)(PointerToArrayBase< double > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_double(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_double) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_double) {
    PointerToArrayBase< double >* other_this = (PointerToArrayBase< double >*)from_this;
    return (ConstPointerToArray< double >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_double) {
    PointerToBase< ReferenceCountedVector< double > >* other_this = (PointerToBase< ReferenceCountedVector< double > >*)from_this;
    return (ConstPointerToArray< double >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< double >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< double >
 */
static int Dtool_Init_PointerToArrayBase_double(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_double(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_double) {
    printf("PointerToArrayBase_double ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< double > *local_this = (PointerToArrayBase< double > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_double) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_double) {
    return (PointerToBase< ReferenceCountedVector< double > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< double > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_double(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_double) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_double) {
    PointerToBase< ReferenceCountedVector< double > >* other_this = (PointerToBase< ReferenceCountedVector< double > >*)from_this;
    return (PointerToArrayBase< double >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< double >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< double > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< double > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_double_clear_10(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< double > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_double, (void **)&local_this, "PointerToBase_ReferenceCountedVector_double.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< double > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_double_clear_10_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_double_clear_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< double > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_double_output_11(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< double > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_double)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< double > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< double > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_double_output_11_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_double_output_11_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_double(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_double(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_double) {
    printf("PointerToBase_ReferenceCountedVector_double ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< double > > *local_this = (PointerToBase< ReferenceCountedVector< double > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_double) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_double(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_double) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< double > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToVoid
 */
/**
 * Python function wrapper for:
 * constexpr bool PointerToVoid::is_null(void) const
 */
static PyObject *Dtool_PointerToVoid_is_null_7(PyObject *self, PyObject *) {
  PointerToVoid *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToVoid)) {
    return nullptr;
  }
  // 1-constexpr bool PointerToVoid::is_null(void) const
  bool return_value = ((*(const PointerToVoid*)local_this).is_null)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToVoid_is_null_7_comment =
  "C++ Interface:\n"
  "is_null(PointerToVoid self)\n"
  "\n"
  "/**\n"
  " * Returns true if the PointerTo is a NULL pointer, false otherwise.  (Direct\n"
  " * comparison to a NULL pointer also works.)\n"
  " */";
#else
static const char *Dtool_PointerToVoid_is_null_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t PointerToVoid::get_hash(void) const
 */
static PyObject *Dtool_PointerToVoid_get_hash_8(PyObject *self, PyObject *) {
  PointerToVoid *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToVoid)) {
    return nullptr;
  }
  // 1-inline std::size_t PointerToVoid::get_hash(void) const
  std::size_t return_value = ((*(const PointerToVoid*)local_this).get_hash)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToVoid_get_hash_8_comment =
  "C++ Interface:\n"
  "get_hash(PointerToVoid self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PointerToVoid_get_hash_8_comment = nullptr;
#endif

static int Dtool_Init_PointerToVoid(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToVoid(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToVoid) {
    printf("PointerToVoid ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToVoid *local_this = (PointerToVoid *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToVoid) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToVoid(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< float >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< float >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_float_clear_34(PyObject *self, PyObject *) {
  ConstPointerToArray< float > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_float, (void **)&local_this, "ConstPointerToArray_float.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< float >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_float_clear_34_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_float_clear_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float const &ConstPointerToArray< float >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_float_get_element_36(PyObject *self, PyObject *arg) {
  ConstPointerToArray< float > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_float)) {
    return nullptr;
  }
  // 1-inline float const &ConstPointerToArray< float >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    float return_value = ((*(const ConstPointerToArray< float >*)local_this).get_element)((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_float_get_element_36_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_float_get_element_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< float >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_float_get_data_38(PyObject *self, PyObject *) {
  ConstPointerToArray< float > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_float)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< float >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< float >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_float_get_data_38_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_float_get_data_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< float >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_float_get_subdata_39(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< float > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_float)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< float >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< float >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_float_get_subdata_39_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_float_get_subdata_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< float >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_float_get_ref_count_40(PyObject *self, PyObject *) {
  ConstPointerToArray< float > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_float)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< float >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< float >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_float_get_ref_count_40_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_float_get_ref_count_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< float >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_float_get_node_ref_count_41(PyObject *self, PyObject *) {
  ConstPointerToArray< float > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_float)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< float >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< float >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_float_get_node_ref_count_41_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_float_get_node_ref_count_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< float >::count(float const &) const
 */
static PyObject *Dtool_ConstPointerToArray_float_count_42(PyObject *self, PyObject *arg) {
  ConstPointerToArray< float > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_float)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< float >::count(float const &) const
  if (PyNumber_Check(arg)) {
    unsigned long int return_value = ((*(const ConstPointerToArray< float >*)local_this).count)((float)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, float param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_float_count_42_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, float param0)\n";
#else
static const char *Dtool_ConstPointerToArray_float_count_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< float >::ConstPointerToArray(ConstPointerToArray< float > const &copy)
 * inline ConstPointerToArray< float >::ConstPointerToArray(PointerToArray< float > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_float(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< float >::ConstPointerToArray(ConstPointerToArray< float > const &copy)
      ConstPointerToArray< float > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_float);
      if (arg_this != nullptr) {
        ConstPointerToArray< float > *return_value = new ConstPointerToArray< float >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_float, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< float >::ConstPointerToArray(PointerToArray< float > const &copy)
      PointerToArray< float > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_float);
      if (arg_this != nullptr) {
        ConstPointerToArray< float > *return_value = new ConstPointerToArray< float >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_float, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< float >::ConstPointerToArray(ConstPointerToArray< float > const &copy)
      ConstPointerToArray< float > arg_local;
      ConstPointerToArray< float > const *arg_this = Dtool_Coerce_ConstPointerToArray_float(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< float > *return_value = new ConstPointerToArray< float >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_float, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< float >::ConstPointerToArray(PointerToArray< float > const &copy)
      PointerToArray< float > arg_local;
      PointerToArray< float > const *arg_this = Dtool_Coerce_PointerToArray_float(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< float > *return_value = new ConstPointerToArray< float >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_float, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< float > *Dtool_Coerce_ConstPointerToArray_float(PyObject *args, ConstPointerToArray< float > &coerced) {
  ConstPointerToArray< float > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_float)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< float > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< float >::ConstPointerToArray(PointerToArray< float > const &copy)
    PointerToArray< float > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_float);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< float >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_float(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_float) {
    printf("ConstPointerToArray_float ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< float > *local_this = (ConstPointerToArray< float > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_float) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_float) {
    return (PointerToArrayBase< float > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_float) {
    return (PointerToBase< ReferenceCountedVector< float > > *)(PointerToArrayBase< float > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< float > > *)(PointerToArrayBase< float > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_float(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_float) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_float) {
    PointerToArrayBase< float >* other_this = (PointerToArrayBase< float >*)from_this;
    return (ConstPointerToArray< float >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_float) {
    PointerToBase< ReferenceCountedVector< float > >* other_this = (PointerToBase< ReferenceCountedVector< float > >*)from_this;
    return (ConstPointerToArray< float >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< float >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< float >
 */
static int Dtool_Init_PointerToArrayBase_float(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_float(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_float) {
    printf("PointerToArrayBase_float ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< float > *local_this = (PointerToArrayBase< float > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_float) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_float) {
    return (PointerToBase< ReferenceCountedVector< float > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< float > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_float(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_float) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_float) {
    PointerToBase< ReferenceCountedVector< float > >* other_this = (PointerToBase< ReferenceCountedVector< float > >*)from_this;
    return (PointerToArrayBase< float >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< float >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< float > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< float > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_float_clear_30(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< float > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_float, (void **)&local_this, "PointerToBase_ReferenceCountedVector_float.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< float > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_float_clear_30_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_float_clear_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< float > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_float_output_31(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< float > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_float)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< float > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< float > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_float_output_31_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_float_output_31_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_float(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_float(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_float) {
    printf("PointerToBase_ReferenceCountedVector_float ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< float > > *local_this = (PointerToBase< ReferenceCountedVector< float > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_float) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_float(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_float) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< float > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< int >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< int >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_int_clear_54(PyObject *self, PyObject *) {
  ConstPointerToArray< int > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_int, (void **)&local_this, "ConstPointerToArray_int.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< int >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_int_clear_54_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_int_clear_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int const &ConstPointerToArray< int >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_int_get_element_56(PyObject *self, PyObject *arg) {
  ConstPointerToArray< int > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_int)) {
    return nullptr;
  }
  // 1-inline int const &ConstPointerToArray< int >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    int return_value = ((*(const ConstPointerToArray< int >*)local_this).get_element)((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_int_get_element_56_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_int_get_element_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< int >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_int_get_data_58(PyObject *self, PyObject *) {
  ConstPointerToArray< int > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_int)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< int >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< int >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_int_get_data_58_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_int_get_data_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< int >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_int_get_subdata_59(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< int > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_int)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< int >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< int >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_int_get_subdata_59_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_int_get_subdata_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< int >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_int_get_ref_count_60(PyObject *self, PyObject *) {
  ConstPointerToArray< int > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_int)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< int >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< int >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_int_get_ref_count_60_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_int_get_ref_count_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< int >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_int_get_node_ref_count_61(PyObject *self, PyObject *) {
  ConstPointerToArray< int > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_int)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< int >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< int >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_int_get_node_ref_count_61_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_int_get_node_ref_count_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< int >::count(int const &) const
 */
static PyObject *Dtool_ConstPointerToArray_int_count_62(PyObject *self, PyObject *arg) {
  ConstPointerToArray< int > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_int)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< int >::count(int const &) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    unsigned long int return_value = ((*(const ConstPointerToArray< int >*)local_this).count)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, int param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_int_count_62_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, int param0)\n";
#else
static const char *Dtool_ConstPointerToArray_int_count_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< int >::ConstPointerToArray(ConstPointerToArray< int > const &copy)
 * inline ConstPointerToArray< int >::ConstPointerToArray(PointerToArray< int > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_int(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< int >::ConstPointerToArray(ConstPointerToArray< int > const &copy)
      ConstPointerToArray< int > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_int);
      if (arg_this != nullptr) {
        ConstPointerToArray< int > *return_value = new ConstPointerToArray< int >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_int, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< int >::ConstPointerToArray(PointerToArray< int > const &copy)
      PointerToArray< int > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_int);
      if (arg_this != nullptr) {
        ConstPointerToArray< int > *return_value = new ConstPointerToArray< int >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_int, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< int >::ConstPointerToArray(ConstPointerToArray< int > const &copy)
      ConstPointerToArray< int > arg_local;
      ConstPointerToArray< int > const *arg_this = Dtool_Coerce_ConstPointerToArray_int(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< int > *return_value = new ConstPointerToArray< int >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_int, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< int >::ConstPointerToArray(PointerToArray< int > const &copy)
      PointerToArray< int > arg_local;
      PointerToArray< int > const *arg_this = Dtool_Coerce_PointerToArray_int(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< int > *return_value = new ConstPointerToArray< int >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_int, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< int > *Dtool_Coerce_ConstPointerToArray_int(PyObject *args, ConstPointerToArray< int > &coerced) {
  ConstPointerToArray< int > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_int)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< int > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< int >::ConstPointerToArray(PointerToArray< int > const &copy)
    PointerToArray< int > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_int);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< int >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_int(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_int) {
    printf("ConstPointerToArray_int ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< int > *local_this = (ConstPointerToArray< int > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_int) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_int) {
    return (PointerToArrayBase< int > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_int) {
    return (PointerToBase< ReferenceCountedVector< int > > *)(PointerToArrayBase< int > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< int > > *)(PointerToArrayBase< int > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_int(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_int) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_int) {
    PointerToArrayBase< int >* other_this = (PointerToArrayBase< int >*)from_this;
    return (ConstPointerToArray< int >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_int) {
    PointerToBase< ReferenceCountedVector< int > >* other_this = (PointerToBase< ReferenceCountedVector< int > >*)from_this;
    return (ConstPointerToArray< int >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< int >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< int >
 */
static int Dtool_Init_PointerToArrayBase_int(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_int(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_int) {
    printf("PointerToArrayBase_int ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< int > *local_this = (PointerToArrayBase< int > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_int) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_int) {
    return (PointerToBase< ReferenceCountedVector< int > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< int > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_int(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_int) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_int) {
    PointerToBase< ReferenceCountedVector< int > >* other_this = (PointerToBase< ReferenceCountedVector< int > >*)from_this;
    return (PointerToArrayBase< int >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< int >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< int > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< int > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_int_clear_50(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< int > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_int, (void **)&local_this, "PointerToBase_ReferenceCountedVector_int.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< int > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_int_clear_50_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_int_clear_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< int > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_int_output_51(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< int > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_int)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< int > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< int > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_int_output_51_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_int_output_51_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_int(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_int(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_int) {
    printf("PointerToBase_ReferenceCountedVector_int ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< int > > *local_this = (PointerToBase< ReferenceCountedVector< int > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_int) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_int(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_int) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< int > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConstPointerToArray< unsigned char >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< unsigned char >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_unsigned_char_clear_74(PyObject *self, PyObject *) {
  ConstPointerToArray< unsigned char > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_unsigned_char, (void **)&local_this, "ConstPointerToArray_unsigned_char.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< unsigned char >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_unsigned_char_clear_74_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_unsigned_char_clear_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned char const &ConstPointerToArray< unsigned char >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_unsigned_char_get_element_76(PyObject *self, PyObject *arg) {
  ConstPointerToArray< unsigned char > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_unsigned_char)) {
    return nullptr;
  }
  // 1-inline unsigned char const &ConstPointerToArray< unsigned char >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    unsigned char return_value = ((*(const ConstPointerToArray< unsigned char >*)local_this).get_element)((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_unsigned_char_get_element_76_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_unsigned_char_get_element_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< unsigned char >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_unsigned_char_get_data_78(PyObject *self, PyObject *) {
  ConstPointerToArray< unsigned char > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_unsigned_char)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< unsigned char >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< unsigned char >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_unsigned_char_get_data_78_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_unsigned_char_get_data_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< unsigned char >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_unsigned_char_get_subdata_79(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< unsigned char > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_unsigned_char)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< unsigned char >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< unsigned char >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_unsigned_char_get_subdata_79_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_unsigned_char_get_subdata_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< unsigned char >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_unsigned_char_get_ref_count_80(PyObject *self, PyObject *) {
  ConstPointerToArray< unsigned char > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_unsigned_char)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< unsigned char >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< unsigned char >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_unsigned_char_get_ref_count_80_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_unsigned_char_get_ref_count_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< unsigned char >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_81(PyObject *self, PyObject *) {
  ConstPointerToArray< unsigned char > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_unsigned_char)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< unsigned char >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< unsigned char >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_81_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< unsigned char >::count(unsigned char const &) const
 */
static PyObject *Dtool_ConstPointerToArray_unsigned_char_count_82(PyObject *self, PyObject *arg) {
  ConstPointerToArray< unsigned char > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_unsigned_char)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< unsigned char >::count(unsigned char const &) const
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > UCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned byte",
                          param1);
    }
#endif
    unsigned long int return_value = ((*(const ConstPointerToArray< unsigned char >*)local_this).count)((unsigned char)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, int param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_unsigned_char_count_82_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, int param0)\n";
#else
static const char *Dtool_ConstPointerToArray_unsigned_char_count_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< unsigned char >::ConstPointerToArray(ConstPointerToArray< unsigned char > const &copy)
 * inline ConstPointerToArray< unsigned char >::ConstPointerToArray(PointerToArray< unsigned char > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_unsigned_char(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< unsigned char >::ConstPointerToArray(ConstPointerToArray< unsigned char > const &copy)
      ConstPointerToArray< unsigned char > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_unsigned_char);
      if (arg_this != nullptr) {
        ConstPointerToArray< unsigned char > *return_value = new ConstPointerToArray< unsigned char >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_unsigned_char, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< unsigned char >::ConstPointerToArray(PointerToArray< unsigned char > const &copy)
      PointerToArray< unsigned char > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_unsigned_char);
      if (arg_this != nullptr) {
        ConstPointerToArray< unsigned char > *return_value = new ConstPointerToArray< unsigned char >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_unsigned_char, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< unsigned char >::ConstPointerToArray(ConstPointerToArray< unsigned char > const &copy)
      ConstPointerToArray< unsigned char > arg_local;
      ConstPointerToArray< unsigned char > const *arg_this = Dtool_Coerce_ConstPointerToArray_unsigned_char(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< unsigned char > *return_value = new ConstPointerToArray< unsigned char >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_unsigned_char, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< unsigned char >::ConstPointerToArray(PointerToArray< unsigned char > const &copy)
      PointerToArray< unsigned char > arg_local;
      PointerToArray< unsigned char > const *arg_this = Dtool_Coerce_PointerToArray_unsigned_char(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< unsigned char > *return_value = new ConstPointerToArray< unsigned char >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_unsigned_char, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< unsigned char > *Dtool_Coerce_ConstPointerToArray_unsigned_char(PyObject *args, ConstPointerToArray< unsigned char > &coerced) {
  ConstPointerToArray< unsigned char > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_unsigned_char)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< unsigned char > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< unsigned char >::ConstPointerToArray(PointerToArray< unsigned char > const &copy)
    PointerToArray< unsigned char > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_unsigned_char);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< unsigned char >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_unsigned_char(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_unsigned_char) {
    printf("ConstPointerToArray_unsigned_char ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< unsigned char > *local_this = (ConstPointerToArray< unsigned char > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_unsigned_char) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_unsigned_char) {
    return (PointerToArrayBase< unsigned char > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char) {
    return (PointerToBase< ReferenceCountedVector< unsigned char > > *)(PointerToArrayBase< unsigned char > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< unsigned char > > *)(PointerToArrayBase< unsigned char > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_unsigned_char(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_unsigned_char) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_unsigned_char) {
    PointerToArrayBase< unsigned char >* other_this = (PointerToArrayBase< unsigned char >*)from_this;
    return (ConstPointerToArray< unsigned char >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char) {
    PointerToBase< ReferenceCountedVector< unsigned char > >* other_this = (PointerToBase< ReferenceCountedVector< unsigned char > >*)from_this;
    return (ConstPointerToArray< unsigned char >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< unsigned char >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< unsigned char >
 */
static int Dtool_Init_PointerToArrayBase_unsigned_char(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_unsigned_char(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_unsigned_char) {
    printf("PointerToArrayBase_unsigned_char ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< unsigned char > *local_this = (PointerToArrayBase< unsigned char > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_unsigned_char) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char) {
    return (PointerToBase< ReferenceCountedVector< unsigned char > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< unsigned char > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_unsigned_char(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_unsigned_char) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char) {
    PointerToBase< ReferenceCountedVector< unsigned char > >* other_this = (PointerToBase< ReferenceCountedVector< unsigned char > >*)from_this;
    return (PointerToArrayBase< unsigned char >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< unsigned char >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< unsigned char > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< unsigned char > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_clear_70(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< unsigned char > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_unsigned_char, (void **)&local_this, "PointerToBase_ReferenceCountedVector_unsigned_char.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< unsigned char > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_clear_70_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_clear_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< unsigned char > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_output_71(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< unsigned char > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_unsigned_char)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< unsigned char > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< unsigned char > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_output_71_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_output_71_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_unsigned_char(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_unsigned_char(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char) {
    printf("PointerToBase_ReferenceCountedVector_unsigned_char ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< unsigned char > > *local_this = (PointerToBase< ReferenceCountedVector< unsigned char > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_unsigned_char(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< unsigned char > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< double >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< double > PointerToArray< double >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((double const *)(0))))
 */
static PyObject *Dtool_PointerToArray_double_empty_array_89(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< double > PointerToArray< double >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((double const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((double const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< double > *return_value = new PointerToArray< double >((PointerToArray< double >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_double, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_empty_array_89_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_double_empty_array_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< double >::clear(void)
 */
static PyObject *Dtool_PointerToArray_double_clear_90(PyObject *self, PyObject *) {
  PointerToArray< double > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_double, (void **)&local_this, "PointerToArray_double.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< double >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_clear_90_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_double_clear_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< double >::push_back(double const &x)
 */
static PyObject *Dtool_PointerToArray_double_push_back_92(PyObject *self, PyObject *arg) {
  PointerToArray< double > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_double, (void **)&local_this, "PointerToArray_double.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< double >::push_back(double const &x)
  if (PyNumber_Check(arg)) {
    ((*local_this).push_back)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, double x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_push_back_92_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, double x)\n";
#else
static const char *Dtool_PointerToArray_double_push_back_92_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< double >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_double_pop_back_93(PyObject *self, PyObject *) {
  PointerToArray< double > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_double, (void **)&local_this, "PointerToArray_double.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< double >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_pop_back_93_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_double_pop_back_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double const &PointerToArray< double >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_double_get_element_94(PyObject *self, PyObject *arg) {
  PointerToArray< double > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_double)) {
    return nullptr;
  }
  // 1-inline double const &PointerToArray< double >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    double return_value = ((*(const PointerToArray< double >*)local_this).get_element)((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_get_element_94_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_double_get_element_94_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< double >::set_element(unsigned long int n, double const &value)
 */
static PyObject *Dtool_PointerToArray_double_set_element_95(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< double > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_double, (void **)&local_this, "PointerToArray_double.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< double >::set_element(unsigned long int n, double const &value)
  unsigned long param1;
  double param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kd:set_element", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_element)((unsigned long int)param1, (double const &)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_set_element_95_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, double value)\n";
#else
static const char *Dtool_PointerToArray_double_set_element_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< double >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_double_get_data_98(PyObject *self, PyObject *) {
  PointerToArray< double > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_double)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< double >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< double >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_get_data_98_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_double_get_data_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< double >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_double_set_data_99(PyObject *self, PyObject *arg) {
  PointerToArray< double > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_double, (void **)&local_this, "PointerToArray_double.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< double >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_set_data_99_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_double_set_data_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< double >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_double_get_subdata_100(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< double > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_double)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< double >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< double >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_get_subdata_100_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_double_get_subdata_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< double >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_double_set_subdata_101(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< double > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_double, (void **)&local_this, "PointerToArray_double.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< double >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_set_subdata_101_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_double_set_subdata_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< double >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_double_get_ref_count_102(PyObject *self, PyObject *) {
  PointerToArray< double > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_double)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< double >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< double >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_get_ref_count_102_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_double_get_ref_count_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< double >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_double_get_node_ref_count_103(PyObject *self, PyObject *) {
  PointerToArray< double > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_double)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< double >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< double >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_get_node_ref_count_103_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_double_get_node_ref_count_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< double >::count(double const &) const
 */
static PyObject *Dtool_PointerToArray_double_count_104(PyObject *self, PyObject *arg) {
  PointerToArray< double > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_double)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< double >::count(double const &) const
  if (PyNumber_Check(arg)) {
    unsigned long int return_value = ((*(const PointerToArray< double >*)local_this).count)(PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, double param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_double_count_104_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, double param0)\n";
#else
static const char *Dtool_PointerToArray_double_count_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< double >::PointerToArray(PointerToArray< double > const &copy)
 * PointerToArray< double >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< double >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((double const *)(0))))
 */
static int Dtool_Init_PointerToArray_double(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< double >::PointerToArray(TypeHandle type_handle)
      PointerToArray< double > *return_value = new PointerToArray< double >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_double, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< double >::PointerToArray(PointerToArray< double > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< double > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_double);
          if (param0_this != nullptr) {
            PointerToArray< double > *return_value = new PointerToArray< double >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_double, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< double >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< double > *return_value = new PointerToArray< double >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_double, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< double >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_double, false, false);
          PointerToArray< double > *result = new PointerToArray< double >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< double > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_double, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< double >::PointerToArray(PointerToArray< double > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< double > param0_local;
          PointerToArray< double > const *param0_this = Dtool_Coerce_PointerToArray_double(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< double > *return_value = new PointerToArray< double >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_double, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< double >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< double > *return_value = new PointerToArray< double >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_double, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< double >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< double > *Dtool_Coerce_PointerToArray_double(PyObject *args, PointerToArray< double > &coerced) {
  PointerToArray< double > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_double)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< double > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< double >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< double >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< double >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_double(&Dtool_PointerToArray_double._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_double(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_double) {
    printf("PointerToArray_double ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< double > *local_this = (PointerToArray< double > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_double) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_double) {
    return (PointerToArrayBase< double > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_double) {
    return (PointerToBase< ReferenceCountedVector< double > > *)(PointerToArrayBase< double > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< double > > *)(PointerToArrayBase< double > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_double(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_double) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_double) {
    PointerToArrayBase< double >* other_this = (PointerToArrayBase< double >*)from_this;
    return (PointerToArray< double >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_double) {
    PointerToBase< ReferenceCountedVector< double > >* other_this = (PointerToBase< ReferenceCountedVector< double > >*)from_this;
    return (PointerToArray< double >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< double >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< float >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< float > PointerToArray< float >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((float const *)(0))))
 */
static PyObject *Dtool_PointerToArray_float_empty_array_111(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< float > PointerToArray< float >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((float const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((float const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< float > *return_value = new PointerToArray< float >((PointerToArray< float >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_float, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_empty_array_111_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_float_empty_array_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< float >::clear(void)
 */
static PyObject *Dtool_PointerToArray_float_clear_112(PyObject *self, PyObject *) {
  PointerToArray< float > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_float, (void **)&local_this, "PointerToArray_float.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< float >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_clear_112_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_float_clear_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< float >::push_back(float const &x)
 */
static PyObject *Dtool_PointerToArray_float_push_back_114(PyObject *self, PyObject *arg) {
  PointerToArray< float > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_float, (void **)&local_this, "PointerToArray_float.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< float >::push_back(float const &x)
  if (PyNumber_Check(arg)) {
    ((*local_this).push_back)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, float x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_push_back_114_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, float x)\n";
#else
static const char *Dtool_PointerToArray_float_push_back_114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< float >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_float_pop_back_115(PyObject *self, PyObject *) {
  PointerToArray< float > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_float, (void **)&local_this, "PointerToArray_float.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< float >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_pop_back_115_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_float_pop_back_115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float const &PointerToArray< float >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_float_get_element_116(PyObject *self, PyObject *arg) {
  PointerToArray< float > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_float)) {
    return nullptr;
  }
  // 1-inline float const &PointerToArray< float >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    float return_value = ((*(const PointerToArray< float >*)local_this).get_element)((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_get_element_116_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_float_get_element_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< float >::set_element(unsigned long int n, float const &value)
 */
static PyObject *Dtool_PointerToArray_float_set_element_117(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< float > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_float, (void **)&local_this, "PointerToArray_float.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< float >::set_element(unsigned long int n, float const &value)
  unsigned long param1;
  float param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kf:set_element", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_element)((unsigned long int)param1, (float const &)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_set_element_117_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, float value)\n";
#else
static const char *Dtool_PointerToArray_float_set_element_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< float >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_float_get_data_120(PyObject *self, PyObject *) {
  PointerToArray< float > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_float)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< float >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< float >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_get_data_120_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_float_get_data_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< float >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_float_set_data_121(PyObject *self, PyObject *arg) {
  PointerToArray< float > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_float, (void **)&local_this, "PointerToArray_float.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< float >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_set_data_121_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_float_set_data_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< float >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_float_get_subdata_122(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< float > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_float)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< float >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< float >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_get_subdata_122_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_float_get_subdata_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< float >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_float_set_subdata_123(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< float > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_float, (void **)&local_this, "PointerToArray_float.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< float >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_set_subdata_123_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_float_set_subdata_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< float >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_float_get_ref_count_124(PyObject *self, PyObject *) {
  PointerToArray< float > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_float)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< float >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< float >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_get_ref_count_124_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_float_get_ref_count_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< float >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_float_get_node_ref_count_125(PyObject *self, PyObject *) {
  PointerToArray< float > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_float)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< float >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< float >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_get_node_ref_count_125_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_float_get_node_ref_count_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< float >::count(float const &) const
 */
static PyObject *Dtool_PointerToArray_float_count_126(PyObject *self, PyObject *arg) {
  PointerToArray< float > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_float)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< float >::count(float const &) const
  if (PyNumber_Check(arg)) {
    unsigned long int return_value = ((*(const PointerToArray< float >*)local_this).count)((float)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, float param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_float_count_126_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, float param0)\n";
#else
static const char *Dtool_PointerToArray_float_count_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< float >::PointerToArray(PointerToArray< float > const &copy)
 * PointerToArray< float >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< float >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((float const *)(0))))
 */
static int Dtool_Init_PointerToArray_float(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< float >::PointerToArray(TypeHandle type_handle)
      PointerToArray< float > *return_value = new PointerToArray< float >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_float, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< float >::PointerToArray(PointerToArray< float > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< float > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_float);
          if (param0_this != nullptr) {
            PointerToArray< float > *return_value = new PointerToArray< float >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_float, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< float >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< float > *return_value = new PointerToArray< float >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_float, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< float >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_float, false, false);
          PointerToArray< float > *result = new PointerToArray< float >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< float > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_float, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< float >::PointerToArray(PointerToArray< float > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< float > param0_local;
          PointerToArray< float > const *param0_this = Dtool_Coerce_PointerToArray_float(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< float > *return_value = new PointerToArray< float >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_float, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< float >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< float > *return_value = new PointerToArray< float >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_float, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< float >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< float > *Dtool_Coerce_PointerToArray_float(PyObject *args, PointerToArray< float > &coerced) {
  PointerToArray< float > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_float)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< float > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< float >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< float >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< float >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_float(&Dtool_PointerToArray_float._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_float(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_float) {
    printf("PointerToArray_float ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< float > *local_this = (PointerToArray< float > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_float) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_float) {
    return (PointerToArrayBase< float > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_float) {
    return (PointerToBase< ReferenceCountedVector< float > > *)(PointerToArrayBase< float > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< float > > *)(PointerToArrayBase< float > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_float(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_float) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_float) {
    PointerToArrayBase< float >* other_this = (PointerToArrayBase< float >*)from_this;
    return (PointerToArray< float >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_float) {
    PointerToBase< ReferenceCountedVector< float > >* other_this = (PointerToBase< ReferenceCountedVector< float > >*)from_this;
    return (PointerToArray< float >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< float >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< int >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< int > PointerToArray< int >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((int const *)(0))))
 */
static PyObject *Dtool_PointerToArray_int_empty_array_133(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< int > PointerToArray< int >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((int const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((int const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< int > *return_value = new PointerToArray< int >((PointerToArray< int >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_int, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_empty_array_133_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_int_empty_array_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< int >::clear(void)
 */
static PyObject *Dtool_PointerToArray_int_clear_134(PyObject *self, PyObject *) {
  PointerToArray< int > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_int, (void **)&local_this, "PointerToArray_int.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< int >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_clear_134_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_int_clear_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< int >::push_back(int const &x)
 */
static PyObject *Dtool_PointerToArray_int_push_back_136(PyObject *self, PyObject *arg) {
  PointerToArray< int > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_int, (void **)&local_this, "PointerToArray_int.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< int >::push_back(int const &x)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).push_back)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, int x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_push_back_136_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, int x)\n";
#else
static const char *Dtool_PointerToArray_int_push_back_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< int >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_int_pop_back_137(PyObject *self, PyObject *) {
  PointerToArray< int > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_int, (void **)&local_this, "PointerToArray_int.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< int >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_pop_back_137_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_int_pop_back_137_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int const &PointerToArray< int >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_int_get_element_138(PyObject *self, PyObject *arg) {
  PointerToArray< int > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_int)) {
    return nullptr;
  }
  // 1-inline int const &PointerToArray< int >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    int return_value = ((*(const PointerToArray< int >*)local_this).get_element)((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_get_element_138_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_int_get_element_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< int >::set_element(unsigned long int n, int const &value)
 */
static PyObject *Dtool_PointerToArray_int_set_element_139(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< int > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_int, (void **)&local_this, "PointerToArray_int.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< int >::set_element(unsigned long int n, int const &value)
  unsigned long param1;
  int param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ki:set_element", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_element)((unsigned long int)param1, (int const &)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_set_element_139_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, int value)\n";
#else
static const char *Dtool_PointerToArray_int_set_element_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< int >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_int_get_data_142(PyObject *self, PyObject *) {
  PointerToArray< int > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_int)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< int >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< int >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_get_data_142_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_int_get_data_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< int >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_int_set_data_143(PyObject *self, PyObject *arg) {
  PointerToArray< int > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_int, (void **)&local_this, "PointerToArray_int.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< int >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_set_data_143_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_int_set_data_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< int >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_int_get_subdata_144(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< int > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_int)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< int >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< int >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_get_subdata_144_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_int_get_subdata_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< int >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_int_set_subdata_145(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< int > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_int, (void **)&local_this, "PointerToArray_int.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< int >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_set_subdata_145_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_int_set_subdata_145_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< int >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_int_get_ref_count_146(PyObject *self, PyObject *) {
  PointerToArray< int > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_int)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< int >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< int >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_get_ref_count_146_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_int_get_ref_count_146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< int >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_int_get_node_ref_count_147(PyObject *self, PyObject *) {
  PointerToArray< int > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_int)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< int >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< int >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_get_node_ref_count_147_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_int_get_node_ref_count_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< int >::count(int const &) const
 */
static PyObject *Dtool_PointerToArray_int_count_148(PyObject *self, PyObject *arg) {
  PointerToArray< int > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_int)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< int >::count(int const &) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    unsigned long int return_value = ((*(const PointerToArray< int >*)local_this).count)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, int param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_int_count_148_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, int param0)\n";
#else
static const char *Dtool_PointerToArray_int_count_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< int >::PointerToArray(PointerToArray< int > const &copy)
 * PointerToArray< int >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< int >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((int const *)(0))))
 */
static int Dtool_Init_PointerToArray_int(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< int >::PointerToArray(TypeHandle type_handle)
      PointerToArray< int > *return_value = new PointerToArray< int >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_int, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< int >::PointerToArray(PointerToArray< int > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< int > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_int);
          if (param0_this != nullptr) {
            PointerToArray< int > *return_value = new PointerToArray< int >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_int, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< int >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< int > *return_value = new PointerToArray< int >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_int, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< int >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_int, false, false);
          PointerToArray< int > *result = new PointerToArray< int >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< int > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_int, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< int >::PointerToArray(PointerToArray< int > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< int > param0_local;
          PointerToArray< int > const *param0_this = Dtool_Coerce_PointerToArray_int(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< int > *return_value = new PointerToArray< int >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_int, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< int >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< int > *return_value = new PointerToArray< int >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_int, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< int >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< int > *Dtool_Coerce_PointerToArray_int(PyObject *args, PointerToArray< int > &coerced) {
  PointerToArray< int > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_int)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< int > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< int >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< int >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< int >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_int(&Dtool_PointerToArray_int._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_int(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_int) {
    printf("PointerToArray_int ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< int > *local_this = (PointerToArray< int > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_int) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_int) {
    return (PointerToArrayBase< int > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_int) {
    return (PointerToBase< ReferenceCountedVector< int > > *)(PointerToArrayBase< int > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< int > > *)(PointerToArrayBase< int > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_int(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_int) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_int) {
    PointerToArrayBase< int >* other_this = (PointerToArrayBase< int >*)from_this;
    return (PointerToArray< int >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_int) {
    PointerToBase< ReferenceCountedVector< int > >* other_this = (PointerToBase< ReferenceCountedVector< int > >*)from_this;
    return (PointerToArray< int >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< int >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< unsigned char >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< unsigned char > PointerToArray< unsigned char >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((unsigned char const *)(0))))
 */
static PyObject *Dtool_PointerToArray_unsigned_char_empty_array_155(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< unsigned char > PointerToArray< unsigned char >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((unsigned char const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((unsigned char const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >((PointerToArray< unsigned char >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_unsigned_char, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_empty_array_155_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_empty_array_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< unsigned char >::clear(void)
 */
static PyObject *Dtool_PointerToArray_unsigned_char_clear_156(PyObject *self, PyObject *) {
  PointerToArray< unsigned char > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this, "PointerToArray_unsigned_char.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< unsigned char >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_clear_156_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_clear_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< unsigned char >::push_back(unsigned char const &x)
 */
static PyObject *Dtool_PointerToArray_unsigned_char_push_back_158(PyObject *self, PyObject *arg) {
  PointerToArray< unsigned char > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this, "PointerToArray_unsigned_char.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< unsigned char >::push_back(unsigned char const &x)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > UCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned byte",
                          param1);
    }
#endif
    ((*local_this).push_back)((unsigned char)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, int x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_push_back_158_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, int x)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_push_back_158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< unsigned char >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_unsigned_char_pop_back_159(PyObject *self, PyObject *) {
  PointerToArray< unsigned char > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this, "PointerToArray_unsigned_char.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< unsigned char >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_pop_back_159_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_pop_back_159_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned char const &PointerToArray< unsigned char >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_unsigned_char_get_element_160(PyObject *self, PyObject *arg) {
  PointerToArray< unsigned char > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_unsigned_char)) {
    return nullptr;
  }
  // 1-inline unsigned char const &PointerToArray< unsigned char >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    unsigned char return_value = ((*(const PointerToArray< unsigned char >*)local_this).get_element)((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_get_element_160_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_get_element_160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< unsigned char >::set_element(unsigned long int n, unsigned char const &value)
 */
static PyObject *Dtool_PointerToArray_unsigned_char_set_element_161(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< unsigned char > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this, "PointerToArray_unsigned_char.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< unsigned char >::set_element(unsigned long int n, unsigned char const &value)
  unsigned long param1;
  long param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kl:set_element", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param2 < 0 || param2 > UCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned byte",
                          param2);
    }
#endif
    ((*local_this).set_element)((unsigned long int)param1, (unsigned char const &)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_set_element_161_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, int value)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_set_element_161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< unsigned char >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_unsigned_char_get_data_164(PyObject *self, PyObject *) {
  PointerToArray< unsigned char > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_unsigned_char)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< unsigned char >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< unsigned char >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_get_data_164_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_get_data_164_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< unsigned char >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_unsigned_char_set_data_165(PyObject *self, PyObject *arg) {
  PointerToArray< unsigned char > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this, "PointerToArray_unsigned_char.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< unsigned char >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_set_data_165_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_set_data_165_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< unsigned char >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_unsigned_char_get_subdata_166(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< unsigned char > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_unsigned_char)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< unsigned char >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< unsigned char >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_get_subdata_166_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_get_subdata_166_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< unsigned char >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_unsigned_char_set_subdata_167(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< unsigned char > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this, "PointerToArray_unsigned_char.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< unsigned char >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_set_subdata_167_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_set_subdata_167_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< unsigned char >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_unsigned_char_get_ref_count_168(PyObject *self, PyObject *) {
  PointerToArray< unsigned char > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_unsigned_char)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< unsigned char >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< unsigned char >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_get_ref_count_168_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_get_ref_count_168_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< unsigned char >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_unsigned_char_get_node_ref_count_169(PyObject *self, PyObject *) {
  PointerToArray< unsigned char > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_unsigned_char)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< unsigned char >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< unsigned char >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_get_node_ref_count_169_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_get_node_ref_count_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< unsigned char >::count(unsigned char const &) const
 */
static PyObject *Dtool_PointerToArray_unsigned_char_count_170(PyObject *self, PyObject *arg) {
  PointerToArray< unsigned char > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_unsigned_char)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< unsigned char >::count(unsigned char const &) const
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > UCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned byte",
                          param1);
    }
#endif
    unsigned long int return_value = ((*(const PointerToArray< unsigned char >*)local_this).count)((unsigned char)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, int param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_unsigned_char_count_170_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, int param0)\n";
#else
static const char *Dtool_PointerToArray_unsigned_char_count_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< unsigned char >::PointerToArray(PointerToArray< unsigned char > const &copy)
 * PointerToArray< unsigned char >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< unsigned char >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((unsigned char const *)(0))))
 */
static int Dtool_Init_PointerToArray_unsigned_char(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< unsigned char >::PointerToArray(TypeHandle type_handle)
      PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_unsigned_char, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< unsigned char >::PointerToArray(PointerToArray< unsigned char > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< unsigned char > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_unsigned_char);
          if (param0_this != nullptr) {
            PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_unsigned_char, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< unsigned char >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_unsigned_char, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< unsigned char >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_unsigned_char, false, false);
          PointerToArray< unsigned char > *result = new PointerToArray< unsigned char >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< unsigned char > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_unsigned_char, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< unsigned char >::PointerToArray(PointerToArray< unsigned char > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< unsigned char > param0_local;
          PointerToArray< unsigned char > const *param0_this = Dtool_Coerce_PointerToArray_unsigned_char(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_unsigned_char, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< unsigned char >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< unsigned char > *return_value = new PointerToArray< unsigned char >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_unsigned_char, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< unsigned char >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< unsigned char > *Dtool_Coerce_PointerToArray_unsigned_char(PyObject *args, PointerToArray< unsigned char > &coerced) {
  PointerToArray< unsigned char > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_unsigned_char)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< unsigned char > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< unsigned char >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< unsigned char >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< unsigned char >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_unsigned_char(&Dtool_PointerToArray_unsigned_char._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_unsigned_char(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_unsigned_char) {
    printf("PointerToArray_unsigned_char ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< unsigned char > *local_this = (PointerToArray< unsigned char > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_unsigned_char) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_unsigned_char) {
    return (PointerToArrayBase< unsigned char > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char) {
    return (PointerToBase< ReferenceCountedVector< unsigned char > > *)(PointerToArrayBase< unsigned char > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< unsigned char > > *)(PointerToArrayBase< unsigned char > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_unsigned_char(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_unsigned_char) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_unsigned_char) {
    PointerToArrayBase< unsigned char >* other_this = (PointerToArrayBase< unsigned char >*)from_this;
    return (PointerToArray< unsigned char >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char) {
    PointerToBase< ReferenceCountedVector< unsigned char > >* other_this = (PointerToBase< ReferenceCountedVector< unsigned char > >*)from_this;
    return (PointerToArray< unsigned char >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< unsigned char >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MemoryUsage
 */
/**
 * Python function wrapper for:
 * static inline bool MemoryUsage::is_tracking(void)
 */
static PyObject *Dtool_MemoryUsage_is_tracking_176(PyObject *, PyObject *) {
  // 1-static inline bool MemoryUsage::is_tracking(void)
  bool return_value = (MemoryUsage::is_tracking)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_is_tracking_176_comment =
  "C++ Interface:\n"
  "is_tracking()\n"
  "\n"
  "/**\n"
  " * Returns true if the MemoryUsage object is currently tracking memory (e.g.\n"
  " * track-memory-usage is configured #t).\n"
  " */";
#else
static const char *Dtool_MemoryUsage_is_tracking_176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool MemoryUsage::is_counting(void)
 */
static PyObject *Dtool_MemoryUsage_is_counting_177(PyObject *, PyObject *) {
  // 1-static inline bool MemoryUsage::is_counting(void)
  bool return_value = (MemoryUsage::is_counting)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_is_counting_177_comment =
  "C++ Interface:\n"
  "is_counting()\n"
  "\n"
  "/**\n"
  " * Returns true if the MemoryUsage object is currently at least counting\n"
  " * memory (e.g.  this is a Windows debug build), even if it's not fully\n"
  " * tracking it.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_is_counting_177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t MemoryUsage::get_current_cpp_size(void)
 */
static PyObject *Dtool_MemoryUsage_get_current_cpp_size_178(PyObject *, PyObject *) {
  // 1-static inline std::size_t MemoryUsage::get_current_cpp_size(void)
  std::size_t return_value = (MemoryUsage::get_current_cpp_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_current_cpp_size_178_comment =
  "C++ Interface:\n"
  "get_current_cpp_size()\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes of allocated memory consumed by C++\n"
  " * objects, not including the memory previously frozen.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_current_cpp_size_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t MemoryUsage::get_total_cpp_size(void)
 */
static PyObject *Dtool_MemoryUsage_get_total_cpp_size_179(PyObject *, PyObject *) {
  // 1-static inline std::size_t MemoryUsage::get_total_cpp_size(void)
  std::size_t return_value = (MemoryUsage::get_total_cpp_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_total_cpp_size_179_comment =
  "C++ Interface:\n"
  "get_total_cpp_size()\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes of allocated memory consumed by C++\n"
  " * objects, including the memory previously frozen.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_total_cpp_size_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t MemoryUsage::get_panda_heap_single_size(void)
 */
static PyObject *Dtool_MemoryUsage_get_panda_heap_single_size_180(PyObject *, PyObject *) {
  // 1-static inline std::size_t MemoryUsage::get_panda_heap_single_size(void)
  std::size_t return_value = (MemoryUsage::get_panda_heap_single_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_panda_heap_single_size_180_comment =
  "C++ Interface:\n"
  "get_panda_heap_single_size()\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes allocated from the heap from code within\n"
  " * Panda, for individual objects.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_panda_heap_single_size_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t MemoryUsage::get_panda_heap_array_size(void)
 */
static PyObject *Dtool_MemoryUsage_get_panda_heap_array_size_181(PyObject *, PyObject *) {
  // 1-static inline std::size_t MemoryUsage::get_panda_heap_array_size(void)
  std::size_t return_value = (MemoryUsage::get_panda_heap_array_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_panda_heap_array_size_181_comment =
  "C++ Interface:\n"
  "get_panda_heap_array_size()\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes allocated from the heap from code within\n"
  " * Panda, for arrays.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_panda_heap_array_size_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t MemoryUsage::get_panda_heap_overhead(void)
 */
static PyObject *Dtool_MemoryUsage_get_panda_heap_overhead_182(PyObject *, PyObject *) {
  // 1-static inline std::size_t MemoryUsage::get_panda_heap_overhead(void)
  std::size_t return_value = (MemoryUsage::get_panda_heap_overhead)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_panda_heap_overhead_182_comment =
  "C++ Interface:\n"
  "get_panda_heap_overhead()\n"
  "\n"
  "/**\n"
  " * Returns the extra bytes allocated from the system that are not immediately\n"
  " * used for holding allocated objects.  This can only be determined if\n"
  " * ALTERNATIVE_MALLOC is enabled.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_panda_heap_overhead_182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t MemoryUsage::get_panda_mmap_size(void)
 */
static PyObject *Dtool_MemoryUsage_get_panda_mmap_size_183(PyObject *, PyObject *) {
  // 1-static inline std::size_t MemoryUsage::get_panda_mmap_size(void)
  std::size_t return_value = (MemoryUsage::get_panda_mmap_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_panda_mmap_size_183_comment =
  "C++ Interface:\n"
  "get_panda_mmap_size()\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes allocated from the virtual memory pool\n"
  " * from code within Panda.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_panda_mmap_size_183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t MemoryUsage::get_external_size(void)
 */
static PyObject *Dtool_MemoryUsage_get_external_size_184(PyObject *, PyObject *) {
  // 1-static inline std::size_t MemoryUsage::get_external_size(void)
  std::size_t return_value = (MemoryUsage::get_external_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_external_size_184_comment =
  "C++ Interface:\n"
  "get_external_size()\n"
  "\n"
  "/**\n"
  " * Returns the total number of bytes of allocated memory in the heap that\n"
  " * Panda didn't seem to be responsible for.  This includes a few bytes for\n"
  " * very low-level objects (like ConfigVariables) that cannot use Panda memory\n"
  " * tracking because they are so very low-level.\n"
  " *\n"
  " * This also includes all of the memory that might have been allocated by a\n"
  " * high-level interpreter, like Python.\n"
  " *\n"
  " * This number is only available if Panda is able to hook into the actual heap\n"
  " * callback.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_external_size_184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::size_t MemoryUsage::get_total_size(void)
 */
static PyObject *Dtool_MemoryUsage_get_total_size_185(PyObject *, PyObject *) {
  // 1-static inline std::size_t MemoryUsage::get_total_size(void)
  std::size_t return_value = (MemoryUsage::get_total_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_total_size_185_comment =
  "C++ Interface:\n"
  "get_total_size()\n"
  "\n"
  "/**\n"
  " * Returns the total size of allocated memory consumed by the process, as\n"
  " * nearly as can be determined.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_total_size_185_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int MemoryUsage::get_num_pointers(void)
 */
static PyObject *Dtool_MemoryUsage_get_num_pointers_186(PyObject *, PyObject *) {
  // 1-static inline int MemoryUsage::get_num_pointers(void)
  int return_value = (MemoryUsage::get_num_pointers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_num_pointers_186_comment =
  "C++ Interface:\n"
  "get_num_pointers()\n"
  "\n"
  "/**\n"
  " * Returns the number of pointers currently active.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_num_pointers_186_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::get_pointers(MemoryUsagePointers &result)
 */
static PyObject *Dtool_MemoryUsage_get_pointers_187(PyObject *, PyObject *arg) {
  // 1-static inline void MemoryUsage::get_pointers(MemoryUsagePointers &result)
  MemoryUsagePointers *arg_this = (MemoryUsagePointers *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MemoryUsagePointers, 0, "MemoryUsage.get_pointers", false, true);
  if (arg_this != nullptr) {
    (MemoryUsage::get_pointers)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pointers(MemoryUsagePointers result)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_pointers_187_comment =
  "C++ Interface:\n"
  "get_pointers(MemoryUsagePointers result)\n"
  "\n"
  "/**\n"
  " * Fills the indicated MemoryUsagePointers with the set of all pointers\n"
  " * currently active.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_pointers_187_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::get_pointers_of_type(MemoryUsagePointers &result, TypeHandle type)
 */
static PyObject *Dtool_MemoryUsage_get_pointers_of_type_188(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline void MemoryUsage::get_pointers_of_type(MemoryUsagePointers &result, TypeHandle type)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"result", "type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_pointers_of_type", (char **)keyword_list, &param0, &param1)) {
    MemoryUsagePointers *param0_this = (MemoryUsagePointers *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_MemoryUsagePointers, 0, "MemoryUsage.get_pointers_of_type", false, true);
    TypeHandle param1_local;
    TypeHandle *param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "MemoryUsage.get_pointers_of_type", "TypeHandle");
    }
    if (param0_this != nullptr) {
      (MemoryUsage::get_pointers_of_type)(*param0_this, *param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pointers_of_type(MemoryUsagePointers result, TypeHandle type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_pointers_of_type_188_comment =
  "C++ Interface:\n"
  "get_pointers_of_type(MemoryUsagePointers result, TypeHandle type)\n"
  "\n"
  "/**\n"
  " * Fills the indicated MemoryUsagePointers with the set of all pointers of the\n"
  " * indicated type currently active.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_pointers_of_type_188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::get_pointers_of_age(MemoryUsagePointers &result, double from, double to)
 */
static PyObject *Dtool_MemoryUsage_get_pointers_of_age_189(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline void MemoryUsage::get_pointers_of_age(MemoryUsagePointers &result, double from, double to)
  PyObject *param0;
  double param1;
  double param2;
  static const char *keyword_list[] = {"result", "from", "to", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Odd:get_pointers_of_age", (char **)keyword_list, &param0, &param1, &param2)) {
    MemoryUsagePointers *param0_this = (MemoryUsagePointers *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_MemoryUsagePointers, 0, "MemoryUsage.get_pointers_of_age", false, true);
    if (param0_this != nullptr) {
      (MemoryUsage::get_pointers_of_age)(*param0_this, (double)param1, (double)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pointers_of_age(MemoryUsagePointers result, double from, double to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_pointers_of_age_189_comment =
  "C++ Interface:\n"
  "get_pointers_of_age(MemoryUsagePointers result, double from, double to)\n"
  "\n"
  "/**\n"
  " * Fills the indicated MemoryUsagePointers with the set of all pointers that\n"
  " * were allocated within the range of the indicated number of seconds ago.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_pointers_of_age_189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::get_pointers_with_zero_count(MemoryUsagePointers &result)
 */
static PyObject *Dtool_MemoryUsage_get_pointers_with_zero_count_190(PyObject *, PyObject *arg) {
  // 1-static inline void MemoryUsage::get_pointers_with_zero_count(MemoryUsagePointers &result)
  MemoryUsagePointers *arg_this = (MemoryUsagePointers *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MemoryUsagePointers, 0, "MemoryUsage.get_pointers_with_zero_count", false, true);
  if (arg_this != nullptr) {
    (MemoryUsage::get_pointers_with_zero_count)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pointers_with_zero_count(MemoryUsagePointers result)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_get_pointers_with_zero_count_190_comment =
  "C++ Interface:\n"
  "get_pointers_with_zero_count(MemoryUsagePointers result)\n"
  "\n"
  "/**\n"
  " * Fills the indicated MemoryUsagePointers with the set of all currently\n"
  " * active pointers (that is, pointers allocated since the last call to\n"
  " * freeze(), and not yet freed) that have a zero reference count.\n"
  " *\n"
  " * Generally, an undeleted pointer with a zero reference count means its\n"
  " * reference count has never been incremented beyond zero (since once it has\n"
  " * been incremented, the only way it can return to zero would free the\n"
  " * pointer).  This may include objects that are allocated statically or on the\n"
  " * stack, which are never intended to be deleted.  Or, it might represent a\n"
  " * programmer or compiler error.\n"
  " *\n"
  " * This function has the side-effect of incrementing each of their reference\n"
  " * counts by one, thus preventing them from ever being freed--but since they\n"
  " * hadn't been freed anyway, probably no additional harm is done.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_get_pointers_with_zero_count_190_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::freeze(void)
 */
static PyObject *Dtool_MemoryUsage_freeze_191(PyObject *, PyObject *) {
  // 1-static inline void MemoryUsage::freeze(void)
  (MemoryUsage::freeze)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_freeze_191_comment =
  "C++ Interface:\n"
  "freeze()\n"
  "\n"
  "/**\n"
  " * 'Freezes' all pointers currently stored so that they are no longer\n"
  " * reported; only newly allocate pointers from this point on will appear in\n"
  " * future information requests.  This makes it easier to differentiate between\n"
  " * continuous leaks and one-time memory allocations.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_freeze_191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::show_current_types(void)
 */
static PyObject *Dtool_MemoryUsage_show_current_types_192(PyObject *, PyObject *) {
  // 1-static inline void MemoryUsage::show_current_types(void)
  (MemoryUsage::show_current_types)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_show_current_types_192_comment =
  "C++ Interface:\n"
  "show_current_types()\n"
  "\n"
  "/**\n"
  " * Shows the breakdown of types of all of the active pointers.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_show_current_types_192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::show_trend_types(void)
 */
static PyObject *Dtool_MemoryUsage_show_trend_types_193(PyObject *, PyObject *) {
  // 1-static inline void MemoryUsage::show_trend_types(void)
  (MemoryUsage::show_trend_types)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_show_trend_types_193_comment =
  "C++ Interface:\n"
  "show_trend_types()\n"
  "\n"
  "/**\n"
  " * Shows the breakdown of types of all of the pointers allocated and freed\n"
  " * since the last call to freeze().\n"
  " */";
#else
static const char *Dtool_MemoryUsage_show_trend_types_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::show_current_ages(void)
 */
static PyObject *Dtool_MemoryUsage_show_current_ages_194(PyObject *, PyObject *) {
  // 1-static inline void MemoryUsage::show_current_ages(void)
  (MemoryUsage::show_current_ages)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_show_current_ages_194_comment =
  "C++ Interface:\n"
  "show_current_ages()\n"
  "\n"
  "/**\n"
  " * Shows the breakdown of ages of all of the active pointers.\n"
  " */";
#else
static const char *Dtool_MemoryUsage_show_current_ages_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void MemoryUsage::show_trend_ages(void)
 */
static PyObject *Dtool_MemoryUsage_show_trend_ages_195(PyObject *, PyObject *) {
  // 1-static inline void MemoryUsage::show_trend_ages(void)
  (MemoryUsage::show_trend_ages)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsage_show_trend_ages_195_comment =
  "C++ Interface:\n"
  "show_trend_ages()\n"
  "\n"
  "/**\n"
  " * Shows the breakdown of ages of all of the pointers allocated and freed\n"
  " * since the last call to freeze().\n"
  " */";
#else
static const char *Dtool_MemoryUsage_show_trend_ages_195_comment = nullptr;
#endif

static PyObject *Dtool_MemoryUsage_tracking_Getter(PyObject *self, void *) {
  // 1-static inline bool MemoryUsage::is_tracking(void)
  bool return_value = (MemoryUsage::is_tracking)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_MemoryUsage_counting_Getter(PyObject *self, void *) {
  // 1-static inline bool MemoryUsage::is_counting(void)
  bool return_value = (MemoryUsage::is_counting)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_MemoryUsage_current_cpp_size_Getter(PyObject *self, void *) {
  // 1-static inline std::size_t MemoryUsage::get_current_cpp_size(void)
  std::size_t return_value = (MemoryUsage::get_current_cpp_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_MemoryUsage_total_cpp_size_Getter(PyObject *self, void *) {
  // 1-static inline std::size_t MemoryUsage::get_total_cpp_size(void)
  std::size_t return_value = (MemoryUsage::get_total_cpp_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_MemoryUsage_panda_heap_single_size_Getter(PyObject *self, void *) {
  // 1-static inline std::size_t MemoryUsage::get_panda_heap_single_size(void)
  std::size_t return_value = (MemoryUsage::get_panda_heap_single_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_MemoryUsage_panda_heap_array_size_Getter(PyObject *self, void *) {
  // 1-static inline std::size_t MemoryUsage::get_panda_heap_array_size(void)
  std::size_t return_value = (MemoryUsage::get_panda_heap_array_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_MemoryUsage_panda_heap_overhead_Getter(PyObject *self, void *) {
  // 1-static inline std::size_t MemoryUsage::get_panda_heap_overhead(void)
  std::size_t return_value = (MemoryUsage::get_panda_heap_overhead)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_MemoryUsage_panda_mmap_size_Getter(PyObject *self, void *) {
  // 1-static inline std::size_t MemoryUsage::get_panda_mmap_size(void)
  std::size_t return_value = (MemoryUsage::get_panda_mmap_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_MemoryUsage_external_size_Getter(PyObject *self, void *) {
  // 1-static inline std::size_t MemoryUsage::get_external_size(void)
  std::size_t return_value = (MemoryUsage::get_external_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_MemoryUsage_total_size_Getter(PyObject *self, void *) {
  // 1-static inline std::size_t MemoryUsage::get_total_size(void)
  std::size_t return_value = (MemoryUsage::get_total_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline MemoryUsage::MemoryUsage(MemoryUsage const &) = default
 */
static int Dtool_Init_MemoryUsage(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("MemoryUsage() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline MemoryUsage::MemoryUsage(MemoryUsage const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    MemoryUsage const *param0_this = (MemoryUsage *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_MemoryUsage, 0, "MemoryUsage.MemoryUsage", true, true);
    if (param0_this != nullptr) {
      MemoryUsage *return_value = new MemoryUsage(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MemoryUsage, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MemoryUsage(const MemoryUsage param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MemoryUsage(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MemoryUsage) {
    printf("MemoryUsage ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MemoryUsage *local_this = (MemoryUsage *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MemoryUsage) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MemoryUsage(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MemoryUsage) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ReferenceCount
 */
/**
 * Python function wrapper for:
 * inline int ReferenceCount::get_ref_count(void) const
 */
static PyObject *Dtool_ReferenceCount_get_ref_count_215(PyObject *self, PyObject *) {
  ReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ReferenceCount)) {
    return nullptr;
  }
  // 1-inline int ReferenceCount::get_ref_count(void) const
  int return_value = ((*(const ReferenceCount*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ReferenceCount_get_ref_count_215_comment =
  "C++ Interface:\n"
  "get_ref_count(ReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Returns the current reference count.\n"
  " */";
#else
static const char *Dtool_ReferenceCount_get_ref_count_215_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ReferenceCount::ref(void) const
 */
static PyObject *Dtool_ReferenceCount_ref_216(PyObject *self, PyObject *) {
  ReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ReferenceCount)) {
    return nullptr;
  }
  // 1-inline void ReferenceCount::ref(void) const
  ((*(const ReferenceCount*)local_this).ref)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ReferenceCount_ref_216_comment =
  "C++ Interface:\n"
  "ref(ReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Explicitly increments the reference count.  User code should avoid using\n"
  " * ref() and unref() directly, which can result in missed reference counts.\n"
  " * Instead, let a PointerTo object manage the reference counting\n"
  " * automatically.\n"
  " *\n"
  " * This function is const, even though it changes the object, because\n"
  " * generally fiddling with an object's reference count isn't considered part\n"
  " * of fiddling with the object.  An object might be const in other ways, but\n"
  " * we still need to accurately count the number of references to it.\n"
  " */";
#else
static const char *Dtool_ReferenceCount_ref_216_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual inline bool ReferenceCount::unref(void) const
 */
static PyObject *Dtool_ReferenceCount_unref_217(PyObject *self, PyObject *) {
  ReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ReferenceCount)) {
    return nullptr;
  }
  // 1-virtual inline bool ReferenceCount::unref(void) const
  bool return_value = ((*(const ReferenceCount*)local_this).unref)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ReferenceCount_unref_217_comment =
  "C++ Interface:\n"
  "unref(ReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Explicitly decrements the reference count.  Note that the object will not\n"
  " * be implicitly deleted by unref() simply because the reference count drops\n"
  " * to zero.  (Having a member function delete itself is problematic.) However,\n"
  " * see the helper function unref_delete().\n"
  " *\n"
  " * User code should avoid using ref() and unref() directly, which can result\n"
  " * in missed reference counts.  Instead, let a PointerTo object manage the\n"
  " * reference counting automatically.\n"
  " *\n"
  " * This function is const, even though it changes the object, because\n"
  " * generally fiddling with an object's reference count isn't considered part\n"
  " * of fiddling with the object.  An object might be const in other ways, but\n"
  " * we still need to accurately count the number of references to it.\n"
  " *\n"
  " * The return value is true if the new reference count is nonzero, false if it\n"
  " * is zero.\n"
  " */";
#else
static const char *Dtool_ReferenceCount_unref_217_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ReferenceCount::test_ref_count_integrity(void) const
 */
static PyObject *Dtool_ReferenceCount_test_ref_count_integrity_220(PyObject *self, PyObject *) {
  ReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ReferenceCount)) {
    return nullptr;
  }
  // 1-inline bool ReferenceCount::test_ref_count_integrity(void) const
  bool return_value = ((*(const ReferenceCount*)local_this).test_ref_count_integrity)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ReferenceCount_test_ref_count_integrity_220_comment =
  "C++ Interface:\n"
  "test_ref_count_integrity(ReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Does some easy checks to make sure that the reference count isn't\n"
  " * completely bogus.  Returns true if ok, false otherwise.\n"
  " */";
#else
static const char *Dtool_ReferenceCount_test_ref_count_integrity_220_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ReferenceCount::test_ref_count_nonzero(void) const
 */
static PyObject *Dtool_ReferenceCount_test_ref_count_nonzero_221(PyObject *self, PyObject *) {
  ReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ReferenceCount)) {
    return nullptr;
  }
  // 1-inline bool ReferenceCount::test_ref_count_nonzero(void) const
  bool return_value = ((*(const ReferenceCount*)local_this).test_ref_count_nonzero)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ReferenceCount_test_ref_count_nonzero_221_comment =
  "C++ Interface:\n"
  "test_ref_count_nonzero(ReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Does some easy checks to make sure that the reference count isn't zero, or\n"
  " * completely bogus.  Returns true if ok, false otherwise.\n"
  " */";
#else
static const char *Dtool_ReferenceCount_test_ref_count_nonzero_221_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ReferenceCount::get_class_type(void)
 */
static PyObject *Dtool_ReferenceCount_get_class_type_222(PyObject *, PyObject *) {
  // 1-static TypeHandle ReferenceCount::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ReferenceCount::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ReferenceCount_get_class_type_222_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ReferenceCount_get_class_type_222_comment = nullptr;
#endif

static PyObject *Dtool_ReferenceCount_ref_count_Getter(PyObject *self, void *) {
  const ReferenceCount *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ReferenceCount, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int ReferenceCount::get_ref_count(void) const
  int return_value = ((*(const ReferenceCount*)local_this).get_ref_count)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_ReferenceCount(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ReferenceCount) {
    printf("ReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ReferenceCount *local_this = (ReferenceCount *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ReferenceCount) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ReferenceCount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Buffer
 */
/**
 * Python function wrapper for:
 * inline int Buffer::get_length(void) const
 */
static PyObject *Dtool_Buffer_get_length_224(PyObject *self, PyObject *) {
  Buffer *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Buffer)) {
    return nullptr;
  }
  // 1-inline int Buffer::get_length(void) const
  int return_value = ((*(const Buffer*)local_this).get_length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Buffer_get_length_224_comment =
  "C++ Interface:\n"
  "get_length(Buffer self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Buffer_get_length_224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Buffer::Buffer(Buffer const &) = default
 */
static int Dtool_Init_Buffer(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Buffer() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline Buffer::Buffer(Buffer const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    Buffer const *param0_this = (Buffer *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Buffer, 0, "Buffer.Buffer", true, true);
    if (param0_this != nullptr) {
      Buffer *return_value = new Buffer(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Buffer, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Buffer(const Buffer param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Buffer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Buffer) {
    printf("Buffer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Buffer *local_this = (Buffer *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Buffer) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Buffer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Buffer) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Buffer*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PStatCollectorForwardBase
 */
/**
 * Python function wrapper for:
 * virtual void PStatCollectorForwardBase::add_level(double level) = 0
 */
static PyObject *Dtool_PStatCollectorForwardBase_add_level_234(PyObject *self, PyObject *arg) {
  PStatCollectorForwardBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PStatCollectorForwardBase, (void **)&local_this, "PStatCollectorForwardBase.add_level")) {
    return nullptr;
  }
  // 1-virtual void PStatCollectorForwardBase::add_level(double level) = 0
  if (PyNumber_Check(arg)) {
    ((*local_this).add_level)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_level(const PStatCollectorForwardBase self, double level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PStatCollectorForwardBase_add_level_234_comment =
  "C++ Interface:\n"
  "add_level(const PStatCollectorForwardBase self, double level)\n";
#else
static const char *Dtool_PStatCollectorForwardBase_add_level_234_comment = nullptr;
#endif

static int Dtool_Init_PStatCollectorForwardBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PStatCollectorForwardBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PStatCollectorForwardBase) {
    printf("PStatCollectorForwardBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PStatCollectorForwardBase *local_this = (PStatCollectorForwardBase *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PStatCollectorForwardBase) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PStatCollectorForwardBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PStatCollectorForwardBase) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PStatCollectorForwardBase*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NodeReferenceCount
 */
/**
 * Python function wrapper for:
 * inline int NodeReferenceCount::get_node_ref_count(void) const
 */
static PyObject *Dtool_NodeReferenceCount_get_node_ref_count_236(PyObject *self, PyObject *) {
  NodeReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodeReferenceCount)) {
    return nullptr;
  }
  // 1-inline int NodeReferenceCount::get_node_ref_count(void) const
  int return_value = ((*(const NodeReferenceCount*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodeReferenceCount_get_node_ref_count_236_comment =
  "C++ Interface:\n"
  "get_node_ref_count(NodeReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Returns the current reference count.\n"
  " */";
#else
static const char *Dtool_NodeReferenceCount_get_node_ref_count_236_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodeReferenceCount::node_ref(void) const
 */
static PyObject *Dtool_NodeReferenceCount_node_ref_237(PyObject *self, PyObject *) {
  NodeReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodeReferenceCount)) {
    return nullptr;
  }
  // 1-inline void NodeReferenceCount::node_ref(void) const
  ((*(const NodeReferenceCount*)local_this).node_ref)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodeReferenceCount_node_ref_237_comment =
  "C++ Interface:\n"
  "node_ref(NodeReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Explicitly increments the node reference count and the normal reference\n"
  " * count simultaneously.\n"
  " */";
#else
static const char *Dtool_NodeReferenceCount_node_ref_237_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodeReferenceCount::node_unref(void) const
 */
static PyObject *Dtool_NodeReferenceCount_node_unref_238(PyObject *self, PyObject *) {
  NodeReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodeReferenceCount)) {
    return nullptr;
  }
  // 1-inline bool NodeReferenceCount::node_unref(void) const
  bool return_value = ((*(const NodeReferenceCount*)local_this).node_unref)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodeReferenceCount_node_unref_238_comment =
  "C++ Interface:\n"
  "node_unref(NodeReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Explicitly decrements the node reference count and the normal reference\n"
  " * count simultaneously.\n"
  " *\n"
  " * The return value is true if the new reference count is nonzero, false if it\n"
  " * is zero.\n"
  " */";
#else
static const char *Dtool_NodeReferenceCount_node_unref_238_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodeReferenceCount::test_ref_count_integrity(void) const
 */
static PyObject *Dtool_NodeReferenceCount_test_ref_count_integrity_239(PyObject *self, PyObject *) {
  NodeReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodeReferenceCount)) {
    return nullptr;
  }
  // 1-inline bool NodeReferenceCount::test_ref_count_integrity(void) const
  bool return_value = ((*(const NodeReferenceCount*)local_this).test_ref_count_integrity)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodeReferenceCount_test_ref_count_integrity_239_comment =
  "C++ Interface:\n"
  "test_ref_count_integrity(NodeReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Does some easy checks to make sure that the reference count isn't\n"
  " * completely bogus.\n"
  " */";
#else
static const char *Dtool_NodeReferenceCount_test_ref_count_integrity_239_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodeReferenceCount::node_unref_only(void) const
 */
static PyObject *Dtool_NodeReferenceCount_node_unref_only_240(PyObject *self, PyObject *) {
  NodeReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodeReferenceCount)) {
    return nullptr;
  }
  // 1-inline void NodeReferenceCount::node_unref_only(void) const
  ((*(const NodeReferenceCount*)local_this).node_unref_only)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodeReferenceCount_node_unref_only_240_comment =
  "C++ Interface:\n"
  "node_unref_only(NodeReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Decrements the node reference count without affecting the normal reference\n"
  " * count.  Intended to be called by derived classes only, presumably to\n"
  " * reimplement node_unref().\n"
  " */";
#else
static const char *Dtool_NodeReferenceCount_node_unref_only_240_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle NodeReferenceCount::get_class_type(void)
 */
static PyObject *Dtool_NodeReferenceCount_get_class_type_241(PyObject *, PyObject *) {
  // 1-static TypeHandle NodeReferenceCount::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((NodeReferenceCount::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NodeReferenceCount_get_class_type_241_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_NodeReferenceCount_get_class_type_241_comment = nullptr;
#endif

static int Dtool_Init_NodeReferenceCount(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_NodeReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NodeReferenceCount) {
    printf("NodeReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NodeReferenceCount *local_this = (NodeReferenceCount *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NodeReferenceCount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NodeReferenceCount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NodeReferenceCount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NodeReferenceCount*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Datagram
 */
/**
 * Python function wrapper for:
 * Rejected Remap [void Datagram::operator =(Datagram &&from) noexcept = default]
 * void Datagram::operator =(Datagram const &copy) = default
 */
static PyObject *Dtool_Datagram_operator_245(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.assign")) {
    return nullptr;
  }
  // 1-void Datagram::operator =(Datagram const &copy) = default
  Datagram arg_local;
  Datagram const *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Datagram.assign", "Datagram");
  }
  ((*local_this).operator =)(*arg_this);
  Datagram *return_value = local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, false, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const Datagram self, const Datagram copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_operator_245_comment =
  "C++ Interface:\n"
  "assign(const Datagram self, const Datagram copy)\n";
#else
static const char *Dtool_Datagram_operator_245_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void Datagram::clear(void)
 */
static PyObject *Dtool_Datagram_clear_246(PyObject *self, PyObject *) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.clear")) {
    return nullptr;
  }
  // 1-virtual void Datagram::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Datagram_clear_246_comment =
  "C++ Interface:\n"
  "clear(const Datagram self)\n"
  "\n"
  "/**\n"
  " * Resets the datagram to empty, in preparation for building up a new\n"
  " * datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_clear_246_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Datagram::dump_hex(std::ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_Datagram_dump_hex_247(PyObject *self, PyObject *args, PyObject *kwds) {
  Datagram *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Datagram)) {
    return nullptr;
  }
  // 1-void Datagram::dump_hex(std::ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:dump_hex", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "Datagram.dump_hex", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != nullptr) {
      ((*(const Datagram*)local_this).dump_hex)(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "dump_hex(Datagram self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_dump_hex_247_comment =
  "C++ Interface:\n"
  "dump_hex(Datagram self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Writes a representation of the entire datagram contents, as a sequence of\n"
  " * hex (and ASCII) values.\n"
  " */";
#else
static const char *Dtool_Datagram_dump_hex_247_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_bool(bool value)
 */
static PyObject *Dtool_Datagram_add_bool_248(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_bool")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_bool(bool value)
  ((*local_this).add_bool)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_bool(const Datagram self, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_bool_248_comment =
  "C++ Interface:\n"
  "add_bool(const Datagram self, bool value)\n"
  "\n"
  "/**\n"
  " * Adds a boolean value to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_bool_248_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_int8(int8_t value)
 */
static PyObject *Dtool_Datagram_add_int8_249(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_int8")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_int8(int8_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < SCHAR_MIN || param1 > SCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed byte",
                          param1);
    }
#endif
    ((*local_this).add_int8)((int8_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_int8(const Datagram self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_int8_249_comment =
  "C++ Interface:\n"
  "add_int8(const Datagram self, int value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 8-bit integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_int8_249_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_uint8(uint8_t value)
 */
static PyObject *Dtool_Datagram_add_uint8_250(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_uint8")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_uint8(uint8_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > UCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned byte",
                          param1);
    }
#endif
    ((*local_this).add_uint8)((uint8_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uint8(const Datagram self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_uint8_250_comment =
  "C++ Interface:\n"
  "add_uint8(const Datagram self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 8-bit integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_uint8_250_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_int16(int16_t value)
 */
static PyObject *Dtool_Datagram_add_int16_251(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_int16")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_int16(int16_t value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (arg_val < SHRT_MIN || arg_val > SHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed short integer",
                          arg_val);
    }
#endif
    ((*local_this).add_int16)((int16_t)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_int16(const Datagram self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_int16_251_comment =
  "C++ Interface:\n"
  "add_int16(const Datagram self, int value)\n"
  "\n"
  "// The default numeric packing is little-endian.\n"
  "\n"
  "/**\n"
  " * Adds a signed 16-bit integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_int16_251_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_int32(int32_t value)
 */
static PyObject *Dtool_Datagram_add_int32_252(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_int32")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_int32(int32_t value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).add_int32)((int32_t)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_int32(const Datagram self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_int32_252_comment =
  "C++ Interface:\n"
  "add_int32(const Datagram self, int value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 32-bit integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_int32_252_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_int64(int64_t value)
 */
static PyObject *Dtool_Datagram_add_int64_253(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_int64")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_int64(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:add_int64", &param1)) {
    ((*local_this).add_int64)((int64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_int64(const Datagram self, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_int64_253_comment =
  "C++ Interface:\n"
  "add_int64(const Datagram self, long value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 64-bit integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_int64_253_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_uint16(uint16_t value)
 */
static PyObject *Dtool_Datagram_add_uint16_254(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_uint16")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_uint16(uint16_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    ((*local_this).add_uint16)((uint16_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uint16(const Datagram self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_uint16_254_comment =
  "C++ Interface:\n"
  "add_uint16(const Datagram self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 16-bit integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_uint16_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_uint32(uint32_t value)
 */
static PyObject *Dtool_Datagram_add_uint32_255(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_uint32")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_uint32(uint32_t value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).add_uint32)((uint32_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uint32(const Datagram self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_uint32_255_comment =
  "C++ Interface:\n"
  "add_uint32(const Datagram self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 32-bit integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_uint32_255_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_uint64(uint64_t value)
 */
static PyObject *Dtool_Datagram_add_uint64_256(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_uint64")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_uint64(uint64_t value)
  unsigned PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "K:add_uint64", &param1)) {
    ((*local_this).add_uint64)((uint64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_uint64(const Datagram self, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_uint64_256_comment =
  "C++ Interface:\n"
  "add_uint64(const Datagram self, long value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 64-bit integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_uint64_256_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_float32(PN_float32 value)
 */
static PyObject *Dtool_Datagram_add_float32_257(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_float32")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_float32(PN_float32 value)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_float32)((PN_float32)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_float32(const Datagram self, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_float32_257_comment =
  "C++ Interface:\n"
  "add_float32(const Datagram self, float value)\n"
  "\n"
  "/**\n"
  " * Adds a 32-bit single-precision floating-point number to the datagram.\n"
  " * Since this kind of float is not necessarily portable across different\n"
  " * architectures, special care is required.\n"
  " */";
#else
static const char *Dtool_Datagram_add_float32_257_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_float64(PN_float64 value)
 */
static PyObject *Dtool_Datagram_add_float64_258(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_float64")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_float64(PN_float64 value)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_float64)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_float64(const Datagram self, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_float64_258_comment =
  "C++ Interface:\n"
  "add_float64(const Datagram self, double value)\n"
  "\n"
  "/**\n"
  " * Adds a 64-bit floating-point number to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_float64_258_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_stdfloat(PN_stdfloat value)
 */
static PyObject *Dtool_Datagram_add_stdfloat_259(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_stdfloat")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_stdfloat(PN_stdfloat value)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_stdfloat)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_stdfloat(const Datagram self, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_stdfloat_259_comment =
  "C++ Interface:\n"
  "add_stdfloat(const Datagram self, float value)\n"
  "\n"
  "/**\n"
  " * Adds either a 32-bit or a 64-bit floating-point number, according to\n"
  " * set_stdfloat_double().\n"
  " */";
#else
static const char *Dtool_Datagram_add_stdfloat_259_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_be_int16(int16_t value)
 */
static PyObject *Dtool_Datagram_add_be_int16_260(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_be_int16")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_be_int16(int16_t value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (arg_val < SHRT_MIN || arg_val > SHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed short integer",
                          arg_val);
    }
#endif
    ((*local_this).add_be_int16)((int16_t)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_int16(const Datagram self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_be_int16_260_comment =
  "C++ Interface:\n"
  "add_be_int16(const Datagram self, int value)\n"
  "\n"
  "// These functions pack numbers big-endian, in case that's desired.\n"
  "\n"
  "/**\n"
  " * Adds a signed 16-bit big-endian integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_be_int16_260_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_be_int32(int32_t value)
 */
static PyObject *Dtool_Datagram_add_be_int32_261(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_be_int32")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_be_int32(int32_t value)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).add_be_int32)((int32_t)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_int32(const Datagram self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_be_int32_261_comment =
  "C++ Interface:\n"
  "add_be_int32(const Datagram self, int value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 32-bit big-endian integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_be_int32_261_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_be_int64(int64_t value)
 */
static PyObject *Dtool_Datagram_add_be_int64_262(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_be_int64")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_be_int64(int64_t value)
  PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "L:add_be_int64", &param1)) {
    ((*local_this).add_be_int64)((int64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_int64(const Datagram self, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_be_int64_262_comment =
  "C++ Interface:\n"
  "add_be_int64(const Datagram self, long value)\n"
  "\n"
  "/**\n"
  " * Adds a signed 64-bit big-endian integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_be_int64_262_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_be_uint16(uint16_t value)
 */
static PyObject *Dtool_Datagram_add_be_uint16_263(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_be_uint16")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_be_uint16(uint16_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    ((*local_this).add_be_uint16)((uint16_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_uint16(const Datagram self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_be_uint16_263_comment =
  "C++ Interface:\n"
  "add_be_uint16(const Datagram self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 16-bit big-endian integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_be_uint16_263_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_be_uint32(uint32_t value)
 */
static PyObject *Dtool_Datagram_add_be_uint32_264(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_be_uint32")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_be_uint32(uint32_t value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).add_be_uint32)((uint32_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_uint32(const Datagram self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_be_uint32_264_comment =
  "C++ Interface:\n"
  "add_be_uint32(const Datagram self, int value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 32-bit big-endian integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_be_uint32_264_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_be_uint64(uint64_t value)
 */
static PyObject *Dtool_Datagram_add_be_uint64_265(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_be_uint64")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_be_uint64(uint64_t value)
  unsigned PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "K:add_be_uint64", &param1)) {
    ((*local_this).add_be_uint64)((uint64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_uint64(const Datagram self, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_be_uint64_265_comment =
  "C++ Interface:\n"
  "add_be_uint64(const Datagram self, long value)\n"
  "\n"
  "/**\n"
  " * Adds an unsigned 64-bit big-endian integer to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_be_uint64_265_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_be_float32(PN_float32 value)
 */
static PyObject *Dtool_Datagram_add_be_float32_266(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_be_float32")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_be_float32(PN_float32 value)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_be_float32)((PN_float32)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_float32(const Datagram self, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_be_float32_266_comment =
  "C++ Interface:\n"
  "add_be_float32(const Datagram self, float value)\n"
  "\n"
  "/**\n"
  " * Adds a 32-bit single-precision big-endian floating-point number to the\n"
  " * datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_be_float32_266_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_be_float64(PN_float64 value)
 */
static PyObject *Dtool_Datagram_add_be_float64_267(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_be_float64")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_be_float64(PN_float64 value)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_be_float64)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_be_float64(const Datagram self, double value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_be_float64_267_comment =
  "C++ Interface:\n"
  "add_be_float64(const Datagram self, double value)\n"
  "\n"
  "/**\n"
  " * Adds a 64-bit big-endian floating-point number to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_be_float64_267_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_string(std::string const &str)
 */
static PyObject *Dtool_Datagram_add_string_268(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_string")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_string(std::string const &str)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).add_string)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_string(const Datagram self, str str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_string_268_comment =
  "C++ Interface:\n"
  "add_string(const Datagram self, str str)\n"
  "\n"
  "/**\n"
  " * Adds a variable-length string to the datagram.  This actually adds a count\n"
  " * followed by n bytes.\n"
  " */";
#else
static const char *Dtool_Datagram_add_string_268_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_string32(std::string const &str)
 */
static PyObject *Dtool_Datagram_add_string32_269(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_string32")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_string32(std::string const &str)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).add_string32)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_string32(const Datagram self, str str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_string32_269_comment =
  "C++ Interface:\n"
  "add_string32(const Datagram self, str str)\n"
  "\n"
  "/**\n"
  " * Adds a variable-length string to the datagram, using a 32-bit length field\n"
  " * to allow very long strings.\n"
  " */";
#else
static const char *Dtool_Datagram_add_string32_269_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_z_string(std::string const &str)
 */
static PyObject *Dtool_Datagram_add_z_string_270(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_z_string")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_z_string(std::string const &str)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).add_z_string)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_z_string(const Datagram self, str str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_z_string_270_comment =
  "C++ Interface:\n"
  "add_z_string(const Datagram self, str str)\n"
  "\n"
  "/**\n"
  " * Adds a variable-length string to the datagram, as a NULL-terminated string.\n"
  " */";
#else
static const char *Dtool_Datagram_add_z_string_270_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_fixed_string(std::string const &str, std::size_t size)
 */
static PyObject *Dtool_Datagram_add_fixed_string_271(PyObject *self, PyObject *args, PyObject *kwds) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_fixed_string")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_fixed_string(std::string const &str, std::size_t size)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  Py_ssize_t param2;
  static const char *keyword_list[] = {"str", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#n:add_fixed_string", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
    ((*local_this).add_fixed_string)(std::string(param1_str, param1_len), (std::size_t)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_fixed_string(const Datagram self, str str, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_fixed_string_271_comment =
  "C++ Interface:\n"
  "add_fixed_string(const Datagram self, str str, int size)\n"
  "\n"
  "/**\n"
  " * Adds a fixed-length string to the datagram.  If the string given is less\n"
  " * than the requested size, this will pad the string out with zeroes; if it is\n"
  " * greater than the requested size, this will silently truncate the string.\n"
  " */";
#else
static const char *Dtool_Datagram_add_fixed_string_271_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Datagram::add_wstring(std::wstring const &str)
 */
static PyObject *Dtool_Datagram_add_wstring_272(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_wstring")) {
    return nullptr;
  }
  // 1-void Datagram::add_wstring(std::wstring const &str)
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
#else
  PyUnicodeObject *param1;
#endif
  if (PyArg_Parse(arg, "U:add_wstring", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    ((*local_this).add_wstring)(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_wstring(const Datagram self, unicode str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_wstring_272_comment =
  "C++ Interface:\n"
  "add_wstring(const Datagram self, unicode str)\n"
  "\n"
  "/**\n"
  " * Adds a variable-length wstring to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_add_wstring_272_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_blob(vector_uchar const &)
 */
static PyObject *Dtool_Datagram_add_blob_273(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_blob")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_blob(vector_uchar const &)
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param1_str, &param1_len) >= 0) {
    ((*local_this).add_blob)(vector_uchar(param1_str, param1_str + param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_blob(const Datagram self, bytes param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_blob_273_comment =
  "C++ Interface:\n"
  "add_blob(const Datagram self, bytes param0)\n"
  "\n"
  "/**\n"
  " * Adds a variable-length binary blob to the datagram.  This actually adds a\n"
  " * count followed by n bytes.\n"
  " */";
#else
static const char *Dtool_Datagram_add_blob_273_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::add_blob32(vector_uchar const &)
 */
static PyObject *Dtool_Datagram_add_blob32_274(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.add_blob32")) {
    return nullptr;
  }
  // 1-inline void Datagram::add_blob32(vector_uchar const &)
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param1_str, &param1_len) >= 0) {
    ((*local_this).add_blob32)(vector_uchar(param1_str, param1_str + param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_blob32(const Datagram self, bytes param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_add_blob32_274_comment =
  "C++ Interface:\n"
  "add_blob32(const Datagram self, bytes param0)\n"
  "\n"
  "/**\n"
  " * Adds a variable-length binary blob to the datagram, using a 32-bit length\n"
  " * field to allow very long blobs.\n"
  " */";
#else
static const char *Dtool_Datagram_add_blob32_274_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Datagram::pad_bytes(std::size_t size)
 */
static PyObject *Dtool_Datagram_pad_bytes_275(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.pad_bytes")) {
    return nullptr;
  }
  // 1-void Datagram::pad_bytes(std::size_t size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).pad_bytes)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pad_bytes(const Datagram self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_pad_bytes_275_comment =
  "C++ Interface:\n"
  "pad_bytes(const Datagram self, int size)\n"
  "\n"
  "/**\n"
  " * Adds the indicated number of zero bytes to the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_pad_bytes_275_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::append_data(vector_uchar const &data)
 */
static PyObject *Dtool_Datagram_append_data_276(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.append_data")) {
    return nullptr;
  }
  // 1-inline void Datagram::append_data(vector_uchar const &data)
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param1_str, &param1_len) >= 0) {
    ((*local_this).append_data)(vector_uchar(param1_str, param1_str + param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append_data(const Datagram self, bytes data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_append_data_276_comment =
  "C++ Interface:\n"
  "append_data(const Datagram self, bytes data)\n"
  "\n"
  "/**\n"
  " * Appends some more raw data to the end of the datagram.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Appends some more raw data to the end of the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_append_data_276_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *Datagram::get_message(void) const
 */
static PyObject *Dtool_Datagram_get_message_277(PyObject *self, PyObject *) {
  Datagram *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Datagram)) {
    return nullptr;
  }
  // 1-inline PyObject *Datagram::get_message(void) const
  PyObject *return_value = invoke_extension((const Datagram*)local_this).get_message();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Datagram_get_message_277_comment =
  "C++ Interface:\n"
  "get_message(Datagram self)\n"
  "\n"
  "/**\n"
  " * Returns the datagram's data as a string.\n"
  " */";
#else
static const char *Dtool_Datagram_get_message_277_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *Datagram::__bytes__(void) const
 */
static PyObject *Dtool_Datagram_bytes_278(PyObject *self, PyObject *) {
  Datagram *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Datagram)) {
    return nullptr;
  }
  // 1-inline PyObject *Datagram::__bytes__(void) const
  PyObject *return_value = invoke_extension((const Datagram*)local_this).__bytes__();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Datagram_bytes_278_comment =
  "C++ Interface:\n"
  "__bytes__(Datagram self)\n";
#else
static const char *Dtool_Datagram_bytes_278_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Datagram::get_length(void) const
 */
static PyObject *Dtool_Datagram_get_length_279(PyObject *self, PyObject *) {
  Datagram *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Datagram)) {
    return nullptr;
  }
  // 1-inline std::size_t Datagram::get_length(void) const
  std::size_t return_value = ((*(const Datagram*)local_this).get_length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Datagram_get_length_279_comment =
  "C++ Interface:\n"
  "get_length(Datagram self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes in the datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_get_length_279_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::set_array(PTA_uchar data)
 */
static PyObject *Dtool_Datagram_set_array_280(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.set_array")) {
    return nullptr;
  }
  // 1-inline void Datagram::set_array(PTA_uchar data)
  PointerToArray< unsigned char > arg_local;
  PTA_uchar *arg_this = Dtool_Coerce_PointerToArray_unsigned_char(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Datagram.set_array", "PointerToArray");
  }
  ((*local_this).set_array)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_array(const Datagram self, PointerToArray data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_set_array_280_comment =
  "C++ Interface:\n"
  "set_array(const Datagram self, PointerToArray data)\n"
  "\n"
  "/**\n"
  " * Replaces the data in the Datagram with the data in the indicated PTA_uchar.\n"
  " * This is assignment by reference: subsequent changes to the Datagram will\n"
  " * also change the source PTA_uchar.\n"
  " */";
#else
static const char *Dtool_Datagram_set_array_280_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::copy_array(CPTA_uchar data)
 */
static PyObject *Dtool_Datagram_copy_array_281(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.copy_array")) {
    return nullptr;
  }
  // 1-inline void Datagram::copy_array(CPTA_uchar data)
  ConstPointerToArray< unsigned char > arg_local;
  CPTA_uchar *arg_this = Dtool_Coerce_ConstPointerToArray_unsigned_char(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Datagram.copy_array", "ConstPointerToArray");
  }
  ((*local_this).copy_array)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_array(const Datagram self, ConstPointerToArray data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_copy_array_281_comment =
  "C++ Interface:\n"
  "copy_array(const Datagram self, ConstPointerToArray data)\n"
  "\n"
  "/**\n"
  " * Replaces the data in the Datagram with a copy of the data in the indicated\n"
  " * CPTA_uchar.  Unlike set_array(), a complete copy is made of the data;\n"
  " * subsequent changes to the Datagram will *not* change the source CPTA_uchar.\n"
  " */";
#else
static const char *Dtool_Datagram_copy_array_281_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CPTA_uchar Datagram::get_array(void) const
 */
static PyObject *Dtool_Datagram_get_array_282(PyObject *self, PyObject *) {
  Datagram *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Datagram)) {
    return nullptr;
  }
  // 1-inline CPTA_uchar Datagram::get_array(void) const
  CPTA_uchar *return_value = new CPTA_uchar(((*(const Datagram*)local_this).get_array)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConstPointerToArray_unsigned_char, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Datagram_get_array_282_comment =
  "C++ Interface:\n"
  "get_array(Datagram self)\n"
  "\n"
  "/**\n"
  " * Returns a const pointer to the actual data in the Datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_get_array_282_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PTA_uchar Datagram::modify_array(void)
 */
static PyObject *Dtool_Datagram_modify_array_283(PyObject *self, PyObject *) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.modify_array")) {
    return nullptr;
  }
  // 1-inline PTA_uchar Datagram::modify_array(void)
  PTA_uchar *return_value = new PTA_uchar(((*local_this).modify_array)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_unsigned_char, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Datagram_modify_array_283_comment =
  "C++ Interface:\n"
  "modify_array(const Datagram self)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the actual data in the Datagram.\n"
  " */";
#else
static const char *Dtool_Datagram_modify_array_283_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Datagram::set_stdfloat_double(bool stdfloat_double)
 */
static PyObject *Dtool_Datagram_set_stdfloat_double_284(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Datagram, (void **)&local_this, "Datagram.set_stdfloat_double")) {
    return nullptr;
  }
  // 1-inline void Datagram::set_stdfloat_double(bool stdfloat_double)
  ((*local_this).set_stdfloat_double)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_stdfloat_double(const Datagram self, bool stdfloat_double)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_set_stdfloat_double_284_comment =
  "C++ Interface:\n"
  "set_stdfloat_double(const Datagram self, bool stdfloat_double)\n"
  "\n"
  "/**\n"
  " * Changes the stdfloat_double flag, which defines the operation performed by\n"
  " * add_stdfloat() and DatagramIterator::get_stdfloat().  When this is true,\n"
  " * add_stdfloat() adds a 64-bit floating-point number; when it is false, it\n"
  " * adds a 32-bit floating-point number.  The default is based on the\n"
  " * STDFLOAT_DOUBLE compilation flag.\n"
  " */";
#else
static const char *Dtool_Datagram_set_stdfloat_double_284_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Datagram::get_stdfloat_double(void) const
 */
static PyObject *Dtool_Datagram_get_stdfloat_double_285(PyObject *self, PyObject *) {
  Datagram *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Datagram)) {
    return nullptr;
  }
  // 1-inline bool Datagram::get_stdfloat_double(void) const
  bool return_value = ((*(const Datagram*)local_this).get_stdfloat_double)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Datagram_get_stdfloat_double_285_comment =
  "C++ Interface:\n"
  "get_stdfloat_double(Datagram self)\n"
  "\n"
  "/**\n"
  " * Returns the stdfloat_double flag.  See set_stdfloat_double().\n"
  " */";
#else
static const char *Dtool_Datagram_get_stdfloat_double_285_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Datagram::output(std::ostream &out) const
 */
static PyObject *Dtool_Datagram_output_289(PyObject *self, PyObject *arg) {
  Datagram *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Datagram)) {
    return nullptr;
  }
  // 1-void Datagram::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Datagram.output", false, true);
  if (arg_this != nullptr) {
    ((*(const Datagram*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Datagram self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_output_289_comment =
  "C++ Interface:\n"
  "output(Datagram self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_Datagram_output_289_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Datagram::write(std::ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_Datagram_write_290(PyObject *self, PyObject *args, PyObject *kwds) {
  Datagram *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Datagram)) {
    return nullptr;
  }
  // 1-void Datagram::write(std::ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "Datagram.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != nullptr) {
      ((*(const Datagram*)local_this).write)(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(Datagram self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Datagram_write_290_comment =
  "C++ Interface:\n"
  "write(Datagram self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_Datagram_write_290_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Datagram::get_class_type(void)
 */
static PyObject *Dtool_Datagram_get_class_type_291(PyObject *, PyObject *) {
  // 1-static TypeHandle Datagram::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Datagram::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Datagram_get_class_type_291_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Datagram_get_class_type_291_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Datagram::Datagram(void) = default
 * Rejected Remap [Datagram::Datagram(Datagram &&from) noexcept = default]
 * Datagram::Datagram(Datagram const &copy) = default
 * inline explicit Datagram::Datagram(vector_uchar data)
 */
static int Dtool_Init_Datagram(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Datagram::Datagram(void) = default
      Datagram *return_value = new Datagram();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Datagram, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 Datagram::Datagram(Datagram const &copy) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          Datagram const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Datagram);
          if (param0_this != nullptr) {
            Datagram *return_value = new Datagram(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Datagram, true, false);
          }
        }
      }

      {
        // -2 inline explicit Datagram::Datagram(vector_uchar data)
        unsigned char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"data", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "" FMTCHAR_BYTES "#:Datagram", (char **)keyword_list, &param0_str, &param0_len)) {
          Datagram *return_value = new Datagram(vector_uchar(param0_str, param0_str + param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Datagram, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 Datagram::Datagram(Datagram const &copy) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          Datagram param0_local;
          Datagram const *param0_this = Dtool_Coerce_Datagram(param0, param0_local);
          if ((param0_this != nullptr)) {
            Datagram *return_value = new Datagram(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Datagram, true, false);
          }
        }
      }

      // No coercion possible: inline explicit Datagram::Datagram(vector_uchar data)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Datagram() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Datagram()\n"
      "Datagram(const Datagram copy)\n"
      "Datagram(bytes data)\n");
  }
  return -1;
}

Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced) {
  Datagram *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_Datagram)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const Datagram *)local_this;
      return &coerced;
    }
    return local_this;
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_Datagram(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Datagram) {
    printf("Datagram ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Datagram *local_this = (Datagram *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Datagram) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Datagram(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Datagram) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Datagram*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DatagramGenerator
 */
/**
 * Python function wrapper for:
 * virtual bool DatagramGenerator::get_datagram(Datagram &data) = 0
 */
static PyObject *Dtool_DatagramGenerator_get_datagram_294(PyObject *self, PyObject *arg) {
  DatagramGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGenerator, (void **)&local_this, "DatagramGenerator.get_datagram")) {
    return nullptr;
  }
  // 1-virtual bool DatagramGenerator::get_datagram(Datagram &data) = 0
  Datagram arg_local;
  Datagram *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DatagramGenerator.get_datagram", "Datagram");
  }
  bool return_value = ((*local_this).get_datagram)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_datagram(const DatagramGenerator self, Datagram data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_get_datagram_294_comment =
  "C++ Interface:\n"
  "get_datagram(const DatagramGenerator self, Datagram data)\n";
#else
static const char *Dtool_DatagramGenerator_get_datagram_294_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramGenerator::save_datagram(SubfileInfo &info)
 */
static PyObject *Dtool_DatagramGenerator_save_datagram_295(PyObject *self, PyObject *arg) {
  DatagramGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGenerator, (void **)&local_this, "DatagramGenerator.save_datagram")) {
    return nullptr;
  }
  // 1-virtual bool DatagramGenerator::save_datagram(SubfileInfo &info)
  SubfileInfo *arg_this = (SubfileInfo *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SubfileInfo, 1, "DatagramGenerator.save_datagram", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).save_datagram)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "save_datagram(const DatagramGenerator self, SubfileInfo info)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_save_datagram_295_comment =
  "C++ Interface:\n"
  "save_datagram(const DatagramGenerator self, SubfileInfo info)\n"
  "\n"
  "/**\n"
  " * Skips over the next datagram without extracting it, but saves the relevant\n"
  " * file information in the SubfileInfo object so that its data may be read\n"
  " * later.  For non-file-based datagram generators, this may mean creating a\n"
  " * temporary file and copying the contents of the datagram to disk.\n"
  " *\n"
  " * Returns true on success, false on failure or if this method is\n"
  " * unimplemented.\n"
  " */";
#else
static const char *Dtool_DatagramGenerator_save_datagram_295_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramGenerator::is_eof(void) = 0
 */
static PyObject *Dtool_DatagramGenerator_is_eof_296(PyObject *self, PyObject *) {
  DatagramGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGenerator, (void **)&local_this, "DatagramGenerator.is_eof")) {
    return nullptr;
  }
  // 1-virtual bool DatagramGenerator::is_eof(void) = 0
  bool return_value = ((*local_this).is_eof)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_is_eof_296_comment =
  "C++ Interface:\n"
  "is_eof(const DatagramGenerator self)\n";
#else
static const char *Dtool_DatagramGenerator_is_eof_296_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramGenerator::is_error(void) = 0
 */
static PyObject *Dtool_DatagramGenerator_is_error_297(PyObject *self, PyObject *) {
  DatagramGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGenerator, (void **)&local_this, "DatagramGenerator.is_error")) {
    return nullptr;
  }
  // 1-virtual bool DatagramGenerator::is_error(void) = 0
  bool return_value = ((*local_this).is_error)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_is_error_297_comment =
  "C++ Interface:\n"
  "is_error(const DatagramGenerator self)\n";
#else
static const char *Dtool_DatagramGenerator_is_error_297_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual Filename const &DatagramGenerator::get_filename(void)
 */
static PyObject *Dtool_DatagramGenerator_get_filename_298(PyObject *self, PyObject *) {
  DatagramGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGenerator, (void **)&local_this, "DatagramGenerator.get_filename")) {
    return nullptr;
  }
  // 1-virtual Filename const &DatagramGenerator::get_filename(void)
  Filename const *return_value = &(((*local_this).get_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_get_filename_298_comment =
  "C++ Interface:\n"
  "get_filename(const DatagramGenerator self)\n"
  "\n"
  "/**\n"
  " * Returns the filename that provides the source for these datagrams, if any,\n"
  " * or empty string if the datagrams do not originate from a file on disk.\n"
  " */";
#else
static const char *Dtool_DatagramGenerator_get_filename_298_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual time_t DatagramGenerator::get_timestamp(void) const
 */
static PyObject *Dtool_DatagramGenerator_get_timestamp_299(PyObject *self, PyObject *) {
  DatagramGenerator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DatagramGenerator)) {
    return nullptr;
  }
  // 1-virtual time_t DatagramGenerator::get_timestamp(void) const
  time_t return_value = ((*(const DatagramGenerator*)local_this).get_timestamp)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_get_timestamp_299_comment =
  "C++ Interface:\n"
  "get_timestamp(DatagramGenerator self)\n"
  "\n"
  "/**\n"
  " * Returns the on-disk timestamp of the file that was read, at the time it was\n"
  " * opened, if that is available, or 0 if it is not.\n"
  " */";
#else
static const char *Dtool_DatagramGenerator_get_timestamp_299_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual FileReference const *DatagramGenerator::get_file(void)
 */
static PyObject *Dtool_DatagramGenerator_get_file_300(PyObject *self, PyObject *) {
  DatagramGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGenerator, (void **)&local_this, "DatagramGenerator.get_file")) {
    return nullptr;
  }
  // 1-virtual FileReference const *DatagramGenerator::get_file(void)
  FileReference const *return_value = ((*local_this).get_file)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_FileReference, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_get_file_300_comment =
  "C++ Interface:\n"
  "get_file(const DatagramGenerator self)\n"
  "\n"
  "/**\n"
  " * Returns the FileReference that provides the source for these datagrams, if\n"
  " * any, or NULL if the datagrams do not originate from a file on disk.\n"
  " */";
#else
static const char *Dtool_DatagramGenerator_get_file_300_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual VirtualFile *DatagramGenerator::get_vfile(void)
 */
static PyObject *Dtool_DatagramGenerator_get_vfile_301(PyObject *self, PyObject *) {
  DatagramGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGenerator, (void **)&local_this, "DatagramGenerator.get_vfile")) {
    return nullptr;
  }
  // 1-virtual VirtualFile *DatagramGenerator::get_vfile(void)
  VirtualFile *return_value = ((*local_this).get_vfile)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VirtualFile, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_get_vfile_301_comment =
  "C++ Interface:\n"
  "get_vfile(const DatagramGenerator self)\n"
  "\n"
  "/**\n"
  " * Returns the VirtualFile that provides the source for these datagrams, if\n"
  " * any, or NULL if the datagrams do not originate from a VirtualFile.\n"
  " */";
#else
static const char *Dtool_DatagramGenerator_get_vfile_301_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::streamoff DatagramGenerator::get_file_pos(void)
 */
static PyObject *Dtool_DatagramGenerator_get_file_pos_302(PyObject *self, PyObject *) {
  DatagramGenerator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGenerator, (void **)&local_this, "DatagramGenerator.get_file_pos")) {
    return nullptr;
  }
  // 1-virtual std::streamoff DatagramGenerator::get_file_pos(void)
  std::streamoff return_value = ((*local_this).get_file_pos)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGenerator_get_file_pos_302_comment =
  "C++ Interface:\n"
  "get_file_pos(const DatagramGenerator self)\n"
  "\n"
  "/**\n"
  " * Returns the current file position within the data stream, if any, or 0 if\n"
  " * the file position is not meaningful or cannot be determined.\n"
  " *\n"
  " * For DatagramGenerators that return a meaningful file position, this will be\n"
  " * pointing to the first byte following the datagram returned after a call to\n"
  " * get_datagram().\n"
  " */";
#else
static const char *Dtool_DatagramGenerator_get_file_pos_302_comment = nullptr;
#endif

static int Dtool_Init_DatagramGenerator(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DatagramGenerator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DatagramGenerator) {
    printf("DatagramGenerator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DatagramGenerator *local_this = (DatagramGenerator *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DatagramGenerator) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DatagramGenerator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DatagramGenerator) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DatagramIterator
 */
/**
 * Python function wrapper for:
 * inline bool DatagramIterator::get_bool(void)
 */
static PyObject *Dtool_DatagramIterator_get_bool_305(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_bool")) {
    return nullptr;
  }
  // 1-inline bool DatagramIterator::get_bool(void)
  bool return_value = ((*local_this).get_bool)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_bool_305_comment =
  "C++ Interface:\n"
  "get_bool(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a boolean value.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_bool_305_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int8_t DatagramIterator::get_int8(void)
 */
static PyObject *Dtool_DatagramIterator_get_int8_306(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_int8")) {
    return nullptr;
  }
  // 1-inline int8_t DatagramIterator::get_int8(void)
  int8_t return_value = ((*local_this).get_int8)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_int8_306_comment =
  "C++ Interface:\n"
  "get_int8(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 8-bit integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_int8_306_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint8_t DatagramIterator::get_uint8(void)
 */
static PyObject *Dtool_DatagramIterator_get_uint8_307(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_uint8")) {
    return nullptr;
  }
  // 1-inline uint8_t DatagramIterator::get_uint8(void)
  uint8_t return_value = ((*local_this).get_uint8)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_uint8_307_comment =
  "C++ Interface:\n"
  "get_uint8(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 8-bit integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_uint8_307_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int16_t DatagramIterator::get_int16(void)
 */
static PyObject *Dtool_DatagramIterator_get_int16_308(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_int16")) {
    return nullptr;
  }
  // 1-inline int16_t DatagramIterator::get_int16(void)
  int16_t return_value = ((*local_this).get_int16)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_int16_308_comment =
  "C++ Interface:\n"
  "get_int16(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 16-bit integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_int16_308_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int32_t DatagramIterator::get_int32(void)
 */
static PyObject *Dtool_DatagramIterator_get_int32_309(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_int32")) {
    return nullptr;
  }
  // 1-inline int32_t DatagramIterator::get_int32(void)
  int32_t return_value = ((*local_this).get_int32)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_int32_309_comment =
  "C++ Interface:\n"
  "get_int32(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 32-bit integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_int32_309_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int64_t DatagramIterator::get_int64(void)
 */
static PyObject *Dtool_DatagramIterator_get_int64_310(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_int64")) {
    return nullptr;
  }
  // 1-inline int64_t DatagramIterator::get_int64(void)
  int64_t return_value = ((*local_this).get_int64)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_int64_310_comment =
  "C++ Interface:\n"
  "get_int64(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 64-bit integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_int64_310_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint16_t DatagramIterator::get_uint16(void)
 */
static PyObject *Dtool_DatagramIterator_get_uint16_311(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_uint16")) {
    return nullptr;
  }
  // 1-inline uint16_t DatagramIterator::get_uint16(void)
  uint16_t return_value = ((*local_this).get_uint16)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_uint16_311_comment =
  "C++ Interface:\n"
  "get_uint16(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 16-bit integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_uint16_311_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint32_t DatagramIterator::get_uint32(void)
 */
static PyObject *Dtool_DatagramIterator_get_uint32_312(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_uint32")) {
    return nullptr;
  }
  // 1-inline uint32_t DatagramIterator::get_uint32(void)
  uint32_t return_value = ((*local_this).get_uint32)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_uint32_312_comment =
  "C++ Interface:\n"
  "get_uint32(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 32-bit integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_uint32_312_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t DatagramIterator::get_uint64(void)
 */
static PyObject *Dtool_DatagramIterator_get_uint64_313(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_uint64")) {
    return nullptr;
  }
  // 1-inline uint64_t DatagramIterator::get_uint64(void)
  uint64_t return_value = ((*local_this).get_uint64)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_uint64_313_comment =
  "C++ Interface:\n"
  "get_uint64(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 64-bit integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_uint64_313_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_float32 DatagramIterator::get_float32(void)
 */
static PyObject *Dtool_DatagramIterator_get_float32_314(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_float32")) {
    return nullptr;
  }
  // 1-inline PN_float32 DatagramIterator::get_float32(void)
  PN_float32 return_value = ((*local_this).get_float32)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_float32_314_comment =
  "C++ Interface:\n"
  "get_float32(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a 32-bit single-precision floating-point number.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_float32_314_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_float64 DatagramIterator::get_float64(void)
 */
static PyObject *Dtool_DatagramIterator_get_float64_315(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_float64")) {
    return nullptr;
  }
  // 1-inline PN_float64 DatagramIterator::get_float64(void)
  PN_float64 return_value = ((*local_this).get_float64)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_float64_315_comment =
  "C++ Interface:\n"
  "get_float64(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a 64-bit floating-point number.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_float64_315_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat DatagramIterator::get_stdfloat(void)
 */
static PyObject *Dtool_DatagramIterator_get_stdfloat_316(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_stdfloat")) {
    return nullptr;
  }
  // 1-inline PN_stdfloat DatagramIterator::get_stdfloat(void)
  PN_stdfloat return_value = ((*local_this).get_stdfloat)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_stdfloat_316_comment =
  "C++ Interface:\n"
  "get_stdfloat(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts either a 32-bit or a 64-bit floating-point number, according to\n"
  " * Datagram::set_stdfloat_double().\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_stdfloat_316_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int16_t DatagramIterator::get_be_int16(void)
 */
static PyObject *Dtool_DatagramIterator_get_be_int16_317(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_be_int16")) {
    return nullptr;
  }
  // 1-inline int16_t DatagramIterator::get_be_int16(void)
  int16_t return_value = ((*local_this).get_be_int16)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_be_int16_317_comment =
  "C++ Interface:\n"
  "get_be_int16(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 16-bit big-endian integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_be_int16_317_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int32_t DatagramIterator::get_be_int32(void)
 */
static PyObject *Dtool_DatagramIterator_get_be_int32_318(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_be_int32")) {
    return nullptr;
  }
  // 1-inline int32_t DatagramIterator::get_be_int32(void)
  int32_t return_value = ((*local_this).get_be_int32)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_be_int32_318_comment =
  "C++ Interface:\n"
  "get_be_int32(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 32-bit big-endian integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_be_int32_318_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int64_t DatagramIterator::get_be_int64(void)
 */
static PyObject *Dtool_DatagramIterator_get_be_int64_319(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_be_int64")) {
    return nullptr;
  }
  // 1-inline int64_t DatagramIterator::get_be_int64(void)
  int64_t return_value = ((*local_this).get_be_int64)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_be_int64_319_comment =
  "C++ Interface:\n"
  "get_be_int64(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a signed 64-bit big-endian integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_be_int64_319_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint16_t DatagramIterator::get_be_uint16(void)
 */
static PyObject *Dtool_DatagramIterator_get_be_uint16_320(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_be_uint16")) {
    return nullptr;
  }
  // 1-inline uint16_t DatagramIterator::get_be_uint16(void)
  uint16_t return_value = ((*local_this).get_be_uint16)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_be_uint16_320_comment =
  "C++ Interface:\n"
  "get_be_uint16(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 16-bit big-endian integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_be_uint16_320_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint32_t DatagramIterator::get_be_uint32(void)
 */
static PyObject *Dtool_DatagramIterator_get_be_uint32_321(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_be_uint32")) {
    return nullptr;
  }
  // 1-inline uint32_t DatagramIterator::get_be_uint32(void)
  uint32_t return_value = ((*local_this).get_be_uint32)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_be_uint32_321_comment =
  "C++ Interface:\n"
  "get_be_uint32(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 32-bit big-endian integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_be_uint32_321_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t DatagramIterator::get_be_uint64(void)
 */
static PyObject *Dtool_DatagramIterator_get_be_uint64_322(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_be_uint64")) {
    return nullptr;
  }
  // 1-inline uint64_t DatagramIterator::get_be_uint64(void)
  uint64_t return_value = ((*local_this).get_be_uint64)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_be_uint64_322_comment =
  "C++ Interface:\n"
  "get_be_uint64(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts an unsigned 64-bit big-endian integer.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_be_uint64_322_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_float32 DatagramIterator::get_be_float32(void)
 */
static PyObject *Dtool_DatagramIterator_get_be_float32_323(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_be_float32")) {
    return nullptr;
  }
  // 1-inline PN_float32 DatagramIterator::get_be_float32(void)
  PN_float32 return_value = ((*local_this).get_be_float32)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_be_float32_323_comment =
  "C++ Interface:\n"
  "get_be_float32(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a 32-bit big-endian single-precision floating-point number.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_be_float32_323_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_float64 DatagramIterator::get_be_float64(void)
 */
static PyObject *Dtool_DatagramIterator_get_be_float64_324(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_be_float64")) {
    return nullptr;
  }
  // 1-inline PN_float64 DatagramIterator::get_be_float64(void)
  PN_float64 return_value = ((*local_this).get_be_float64)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_be_float64_324_comment =
  "C++ Interface:\n"
  "get_be_float64(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a 64-bit big-endian floating-point number.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_be_float64_324_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string DatagramIterator::get_string(void)
 */
static PyObject *Dtool_DatagramIterator_get_string_325(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_string")) {
    return nullptr;
  }
  // 1-std::string DatagramIterator::get_string(void)
  std::string return_value = ((*local_this).get_string)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_string_325_comment =
  "C++ Interface:\n"
  "get_string(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a variable-length string.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_string_325_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string DatagramIterator::get_string32(void)
 */
static PyObject *Dtool_DatagramIterator_get_string32_326(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_string32")) {
    return nullptr;
  }
  // 1-std::string DatagramIterator::get_string32(void)
  std::string return_value = ((*local_this).get_string32)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_string32_326_comment =
  "C++ Interface:\n"
  "get_string32(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a variable-length string with a 32-bit length field.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_string32_326_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string DatagramIterator::get_z_string(void)
 */
static PyObject *Dtool_DatagramIterator_get_z_string_327(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_z_string")) {
    return nullptr;
  }
  // 1-std::string DatagramIterator::get_z_string(void)
  std::string return_value = ((*local_this).get_z_string)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_z_string_327_comment =
  "C++ Interface:\n"
  "get_z_string(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a variable-length string, as a NULL-terminated string.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_z_string_327_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string DatagramIterator::get_fixed_string(std::size_t size)
 */
static PyObject *Dtool_DatagramIterator_get_fixed_string_328(PyObject *self, PyObject *arg) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_fixed_string")) {
    return nullptr;
  }
  // 1-std::string DatagramIterator::get_fixed_string(std::size_t size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::string return_value = ((*local_this).get_fixed_string)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_fixed_string(const DatagramIterator self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_fixed_string_328_comment =
  "C++ Interface:\n"
  "get_fixed_string(const DatagramIterator self, int size)\n"
  "\n"
  "/**\n"
  " * Extracts a fixed-length string.  However, if a zero byte occurs within the\n"
  " * string, it marks the end of the string.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_fixed_string_328_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::wstring DatagramIterator::get_wstring(void)
 */
static PyObject *Dtool_DatagramIterator_get_wstring_329(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_wstring")) {
    return nullptr;
  }
  // 1-std::wstring DatagramIterator::get_wstring(void)
  std::wstring return_value = ((*local_this).get_wstring)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_wstring_329_comment =
  "C++ Interface:\n"
  "get_wstring(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a variable-length wstring (with a 32-bit length field).\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_wstring_329_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline vector_uchar DatagramIterator::get_blob(void)
 */
static PyObject *Dtool_DatagramIterator_get_blob_330(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_blob")) {
    return nullptr;
  }
  // 1-inline vector_uchar DatagramIterator::get_blob(void)
  vector_uchar return_value = ((*local_this).get_blob)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_blob_330_comment =
  "C++ Interface:\n"
  "get_blob(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a variable-length binary blob.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_blob_330_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline vector_uchar DatagramIterator::get_blob32(void)
 */
static PyObject *Dtool_DatagramIterator_get_blob32_331(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.get_blob32")) {
    return nullptr;
  }
  // 1-inline vector_uchar DatagramIterator::get_blob32(void)
  vector_uchar return_value = ((*local_this).get_blob32)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_blob32_331_comment =
  "C++ Interface:\n"
  "get_blob32(const DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Extracts a variable-length binary blob with a 32-bit size field.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_blob32_331_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DatagramIterator::skip_bytes(std::size_t size)
 */
static PyObject *Dtool_DatagramIterator_skip_bytes_332(PyObject *self, PyObject *arg) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.skip_bytes")) {
    return nullptr;
  }
  // 1-inline void DatagramIterator::skip_bytes(std::size_t size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).skip_bytes)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "skip_bytes(const DatagramIterator self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_skip_bytes_332_comment =
  "C++ Interface:\n"
  "skip_bytes(const DatagramIterator self, int size)\n"
  "\n"
  "/**\n"
  " * Skips over the indicated number of bytes in the datagram.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_skip_bytes_332_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * vector_uchar DatagramIterator::extract_bytes(std::size_t size)
 */
static PyObject *Dtool_DatagramIterator_extract_bytes_333(PyObject *self, PyObject *arg) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramIterator, (void **)&local_this, "DatagramIterator.extract_bytes")) {
    return nullptr;
  }
  // 1-vector_uchar DatagramIterator::extract_bytes(std::size_t size)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    vector_uchar return_value = ((*local_this).extract_bytes)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract_bytes(const DatagramIterator self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_extract_bytes_333_comment =
  "C++ Interface:\n"
  "extract_bytes(const DatagramIterator self, int size)\n"
  "\n"
  "/**\n"
  " * Extracts the indicated number of bytes in the datagram and returns them as\n"
  " * a string.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Extracts the indicated number of bytes in the datagram into the given\n"
  " * character buffer.  Assumes that the buffer is big enough to hold the\n"
  " * requested number of bytes.  Returns the number of bytes that were\n"
  " * successfully written.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_extract_bytes_333_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline vector_uchar DatagramIterator::get_remaining_bytes(void) const
 */
static PyObject *Dtool_DatagramIterator_get_remaining_bytes_334(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DatagramIterator)) {
    return nullptr;
  }
  // 1-inline vector_uchar DatagramIterator::get_remaining_bytes(void) const
  vector_uchar return_value = ((*(const DatagramIterator*)local_this).get_remaining_bytes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_remaining_bytes_334_comment =
  "C++ Interface:\n"
  "get_remaining_bytes(DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Returns the remaining bytes in the datagram as a string, but does not\n"
  " * extract them from the iterator.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_remaining_bytes_334_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t DatagramIterator::get_remaining_size(void) const
 */
static PyObject *Dtool_DatagramIterator_get_remaining_size_335(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DatagramIterator)) {
    return nullptr;
  }
  // 1-inline std::size_t DatagramIterator::get_remaining_size(void) const
  std::size_t return_value = ((*(const DatagramIterator*)local_this).get_remaining_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_remaining_size_335_comment =
  "C++ Interface:\n"
  "get_remaining_size(DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Return the bytes left in the datagram.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_remaining_size_335_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Datagram const &DatagramIterator::get_datagram(void) const
 */
static PyObject *Dtool_DatagramIterator_get_datagram_336(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DatagramIterator)) {
    return nullptr;
  }
  // 1-inline Datagram const &DatagramIterator::get_datagram(void) const
  Datagram const *return_value = &(((*(const DatagramIterator*)local_this).get_datagram)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Datagram, false, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_datagram_336_comment =
  "C++ Interface:\n"
  "get_datagram(DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Return the datagram of this iterator.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_datagram_336_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t DatagramIterator::get_current_index(void) const
 */
static PyObject *Dtool_DatagramIterator_get_current_index_337(PyObject *self, PyObject *) {
  DatagramIterator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DatagramIterator)) {
    return nullptr;
  }
  // 1-inline std::size_t DatagramIterator::get_current_index(void) const
  std::size_t return_value = ((*(const DatagramIterator*)local_this).get_current_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_current_index_337_comment =
  "C++ Interface:\n"
  "get_current_index(DatagramIterator self)\n"
  "\n"
  "/**\n"
  " * Returns the current position within the datagram of the next piece of data\n"
  " * to extract.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_get_current_index_337_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DatagramIterator::output(std::ostream &out) const
 */
static PyObject *Dtool_DatagramIterator_output_338(PyObject *self, PyObject *arg) {
  DatagramIterator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DatagramIterator)) {
    return nullptr;
  }
  // 1-void DatagramIterator::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "DatagramIterator.output", false, true);
  if (arg_this != nullptr) {
    ((*(const DatagramIterator*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DatagramIterator self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_output_338_comment =
  "C++ Interface:\n"
  "output(DatagramIterator self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_output_338_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DatagramIterator::write(std::ostream &out, unsigned int indent = 0) const
 */
static PyObject *Dtool_DatagramIterator_write_339(PyObject *self, PyObject *args, PyObject *kwds) {
  DatagramIterator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DatagramIterator)) {
    return nullptr;
  }
  // 1-void DatagramIterator::write(std::ostream &out, unsigned int indent = 0) const
  PyObject *param1;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|k:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "DatagramIterator.write", false, true);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if (param1_this != nullptr) {
      ((*(const DatagramIterator*)local_this).write)(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DatagramIterator self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_write_339_comment =
  "C++ Interface:\n"
  "write(DatagramIterator self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_DatagramIterator_write_339_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DatagramIterator::get_class_type(void)
 */
static PyObject *Dtool_DatagramIterator_get_class_type_340(PyObject *, PyObject *) {
  // 1-static TypeHandle DatagramIterator::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((DatagramIterator::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramIterator_get_class_type_340_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DatagramIterator_get_class_type_340_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DatagramIterator::DatagramIterator(void)
 * inline DatagramIterator::DatagramIterator(Datagram const &datagram, std::size_t offset = 0)
 * inline DatagramIterator::DatagramIterator(DatagramIterator const &) = default
 */
static int Dtool_Init_DatagramIterator(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline DatagramIterator::DatagramIterator(void)
      DatagramIterator *return_value = new DatagramIterator();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramIterator, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 inline DatagramIterator::DatagramIterator(Datagram const &datagram, std::size_t offset = 0)
        PyObject *param0;
        Py_ssize_t param1 = 0;
        static const char *keyword_list[] = {"datagram", "offset", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|n:DatagramIterator", (char **)keyword_list, &param0, &param1)) {
          Datagram const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Datagram);
#ifndef NDEBUG
          if (param1 < 0) {
            PyErr_Format(PyExc_OverflowError,
                         "can't convert negative value %zd to size_t",
                         param1);
            return -1;
          }
#endif
          if (param0_this != nullptr) {
            DatagramIterator *return_value = new DatagramIterator(*param0_this, (std::size_t)param1);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramIterator, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline DatagramIterator::DatagramIterator(DatagramIterator const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          DatagramIterator const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_DatagramIterator);
          if (param0_this != nullptr) {
            DatagramIterator *return_value = new DatagramIterator(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramIterator, true, false);
          }
        }
      }

      {
        // -2 inline DatagramIterator::DatagramIterator(Datagram const &datagram, std::size_t offset = 0)
        PyObject *param0;
        Py_ssize_t param1 = 0;
        static const char *keyword_list[] = {"datagram", "offset", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|n:DatagramIterator", (char **)keyword_list, &param0, &param1)) {
          Datagram param0_local;
          Datagram const *param0_this = Dtool_Coerce_Datagram(param0, param0_local);
#ifndef NDEBUG
          if (param1 < 0) {
            PyErr_Format(PyExc_OverflowError,
                         "can't convert negative value %zd to size_t",
                         param1);
            return -1;
          }
#endif
          if ((param0_this != nullptr)) {
            DatagramIterator *return_value = new DatagramIterator(*param0_this, (std::size_t)param1);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramIterator, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline DatagramIterator::DatagramIterator(DatagramIterator const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          DatagramIterator param0_local;
          DatagramIterator const *param0_this = Dtool_Coerce_DatagramIterator(param0, param0_local);
          if ((param0_this != nullptr)) {
            DatagramIterator *return_value = new DatagramIterator(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramIterator, true, false);
          }
        }
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DatagramIterator() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DatagramIterator()\n"
      "DatagramIterator(const Datagram datagram, int offset)\n"
      "DatagramIterator(const DatagramIterator param0)\n");
  }
  return -1;
}

DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced) {
  DatagramIterator *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_DatagramIterator)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const DatagramIterator *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline DatagramIterator::DatagramIterator(Datagram const &datagram, std::size_t offset)
    Datagram const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Datagram);
    if (arg_this != nullptr) {
      coerced = DatagramIterator(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-inline DatagramIterator::DatagramIterator(Datagram const &datagram, std::size_t offset)
      PyObject *param0;
      Py_ssize_t param1;
      if (PyArg_ParseTuple(args, "On:DatagramIterator", &param0, &param1)) {
        Datagram const *param0_this = nullptr;
        DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Datagram);
#ifndef NDEBUG
        if (param1 < 0) {
          PyErr_Format(PyExc_OverflowError,
                       "can't convert negative value %zd to size_t",
                       param1);
          return nullptr;
        }
#endif
        if (param0_this != nullptr) {
          coerced = DatagramIterator(*param0_this, (std::size_t)param1);
          if (_PyErr_OCCURRED()) {
            return nullptr;
          } else {
            return &coerced;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_DatagramIterator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DatagramIterator) {
    printf("DatagramIterator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DatagramIterator *local_this = (DatagramIterator *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DatagramIterator) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DatagramIterator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DatagramIterator) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DatagramSink
 */
/**
 * Python function wrapper for:
 * virtual bool DatagramSink::put_datagram(Datagram const &data) = 0
 */
static PyObject *Dtool_DatagramSink_put_datagram_344(PyObject *self, PyObject *arg) {
  DatagramSink *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSink, (void **)&local_this, "DatagramSink.put_datagram")) {
    return nullptr;
  }
  // 1-virtual bool DatagramSink::put_datagram(Datagram const &data) = 0
  Datagram arg_local;
  Datagram const *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DatagramSink.put_datagram", "Datagram");
  }
  bool return_value = ((*local_this).put_datagram)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "put_datagram(const DatagramSink self, const Datagram data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DatagramSink_put_datagram_344_comment =
  "C++ Interface:\n"
  "put_datagram(const DatagramSink self, const Datagram data)\n";
#else
static const char *Dtool_DatagramSink_put_datagram_344_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramSink::copy_datagram(SubfileInfo &result, Filename const &filename)
 * virtual bool DatagramSink::copy_datagram(SubfileInfo &result, SubfileInfo const &source)
 */
static PyObject *Dtool_DatagramSink_copy_datagram_345(PyObject *self, PyObject *args, PyObject *kwds) {
  DatagramSink *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSink, (void **)&local_this, "DatagramSink.copy_datagram")) {
    return nullptr;
  }
  {
    // -2 virtual bool DatagramSink::copy_datagram(SubfileInfo &result, Filename const &filename)
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"result", "filename", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:copy_datagram", (char **)keyword_list, &param1, &param2)) {
      SubfileInfo *param1_this = (SubfileInfo *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_SubfileInfo, 1, "DatagramSink.copy_datagram", false, false);
      Filename const *param2_this = nullptr;
      DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_Filename);
      if (param1_this != nullptr && param2_this != nullptr) {
        bool return_value = ((*local_this).copy_datagram)(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 virtual bool DatagramSink::copy_datagram(SubfileInfo &result, SubfileInfo const &source)
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"result", "source", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:copy_datagram", (char **)keyword_list, &param1, &param2)) {
      SubfileInfo *param1_this = (SubfileInfo *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_SubfileInfo, 1, "DatagramSink.copy_datagram", false, false);
      SubfileInfo const *param2_this = nullptr;
      DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_SubfileInfo);
      if (param1_this != nullptr && param2_this != nullptr) {
        bool return_value = ((*local_this).copy_datagram)(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 virtual bool DatagramSink::copy_datagram(SubfileInfo &result, Filename const &filename)
    PyObject *param1;
    PyObject *param2;
    static const char *keyword_list[] = {"result", "filename", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:copy_datagram", (char **)keyword_list, &param1, &param2)) {
      SubfileInfo *param1_this = (SubfileInfo *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_SubfileInfo, 1, "DatagramSink.copy_datagram", false, false);
      Filename param2_local;
      Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
      if (param1_this != nullptr && (param2_this != nullptr)) {
        bool return_value = ((*local_this).copy_datagram)(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: virtual bool DatagramSink::copy_datagram(SubfileInfo &result, SubfileInfo const &source)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_datagram(const DatagramSink self, SubfileInfo result, const Filename filename)\n"
      "copy_datagram(const DatagramSink self, SubfileInfo result, const SubfileInfo source)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DatagramSink_copy_datagram_345_comment =
  "C++ Interface:\n"
  "copy_datagram(const DatagramSink self, SubfileInfo result, const Filename filename)\n"
  "copy_datagram(const DatagramSink self, SubfileInfo result, const SubfileInfo source)\n"
  "\n"
  "/**\n"
  " * Copies the file data from the entire indicated file (via the vfs) as the\n"
  " * next datagram.  This is intended to support potentially very large\n"
  " * datagrams.\n"
  " *\n"
  " * Returns true on success, false on failure or if this method is\n"
  " * unimplemented.  On true, fills \"result\" with the information that\n"
  " * references the copied file, if possible.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Copies the file data from the range of the indicated file (outside of the\n"
  " * vfs) as the next datagram.  This is intended to support potentially very\n"
  " * large datagrams.\n"
  " *\n"
  " * Returns true on success, false on failure or if this method is\n"
  " * unimplemented.  On true, fills \"result\" with the information that\n"
  " * references the copied file, if possible.\n"
  " */";
#else
static const char *Dtool_DatagramSink_copy_datagram_345_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramSink::is_error(void) = 0
 */
static PyObject *Dtool_DatagramSink_is_error_346(PyObject *self, PyObject *) {
  DatagramSink *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSink, (void **)&local_this, "DatagramSink.is_error")) {
    return nullptr;
  }
  // 1-virtual bool DatagramSink::is_error(void) = 0
  bool return_value = ((*local_this).is_error)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramSink_is_error_346_comment =
  "C++ Interface:\n"
  "is_error(const DatagramSink self)\n";
#else
static const char *Dtool_DatagramSink_is_error_346_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DatagramSink::flush(void) = 0
 */
static PyObject *Dtool_DatagramSink_flush_347(PyObject *self, PyObject *) {
  DatagramSink *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSink, (void **)&local_this, "DatagramSink.flush")) {
    return nullptr;
  }
  // 1-virtual void DatagramSink::flush(void) = 0
  ((*local_this).flush)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DatagramSink_flush_347_comment =
  "C++ Interface:\n"
  "flush(const DatagramSink self)\n";
#else
static const char *Dtool_DatagramSink_flush_347_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual Filename const &DatagramSink::get_filename(void)
 */
static PyObject *Dtool_DatagramSink_get_filename_348(PyObject *self, PyObject *) {
  DatagramSink *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSink, (void **)&local_this, "DatagramSink.get_filename")) {
    return nullptr;
  }
  // 1-virtual Filename const &DatagramSink::get_filename(void)
  Filename const *return_value = &(((*local_this).get_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_DatagramSink_get_filename_348_comment =
  "C++ Interface:\n"
  "get_filename(const DatagramSink self)\n"
  "\n"
  "/**\n"
  " * Returns the filename that provides the target for these datagrams, if any,\n"
  " * or empty string if the datagrams do not get written to a file on disk.\n"
  " */";
#else
static const char *Dtool_DatagramSink_get_filename_348_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual FileReference const *DatagramSink::get_file(void)
 */
static PyObject *Dtool_DatagramSink_get_file_349(PyObject *self, PyObject *) {
  DatagramSink *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSink, (void **)&local_this, "DatagramSink.get_file")) {
    return nullptr;
  }
  // 1-virtual FileReference const *DatagramSink::get_file(void)
  FileReference const *return_value = ((*local_this).get_file)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_FileReference, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_DatagramSink_get_file_349_comment =
  "C++ Interface:\n"
  "get_file(const DatagramSink self)\n"
  "\n"
  "/**\n"
  " * Returns the FileReference that provides the target for these datagrams, if\n"
  " * any, or NULL if the datagrams do not written to a file on disk.\n"
  " */";
#else
static const char *Dtool_DatagramSink_get_file_349_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::streamoff DatagramSink::get_file_pos(void)
 */
static PyObject *Dtool_DatagramSink_get_file_pos_350(PyObject *self, PyObject *) {
  DatagramSink *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSink, (void **)&local_this, "DatagramSink.get_file_pos")) {
    return nullptr;
  }
  // 1-virtual std::streamoff DatagramSink::get_file_pos(void)
  std::streamoff return_value = ((*local_this).get_file_pos)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramSink_get_file_pos_350_comment =
  "C++ Interface:\n"
  "get_file_pos(const DatagramSink self)\n"
  "\n"
  "/**\n"
  " * Returns the current file position within the data stream, if any, or 0 if\n"
  " * the file position is not meaningful or cannot be determined.\n"
  " *\n"
  " * For DatagramSinks that return a meaningful file position, this will be\n"
  " * pointing to the first byte following the datagram returned after a call to\n"
  " * put_datagram().\n"
  " */";
#else
static const char *Dtool_DatagramSink_get_file_pos_350_comment = nullptr;
#endif

static PyObject *Dtool_DatagramSink_filename_Getter(PyObject *self, void *) {
  DatagramSink *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSink, (void **)&local_this, "DatagramSink.filename")) {
    return nullptr;
  }

  // 1-virtual Filename const &DatagramSink::get_filename(void)
  Filename const *return_value = &(((*local_this).get_filename)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static PyObject *Dtool_DatagramSink_file_Getter(PyObject *self, void *) {
  DatagramSink *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSink, (void **)&local_this, "DatagramSink.file")) {
    return nullptr;
  }

  // 1-virtual FileReference const *DatagramSink::get_file(void)
  FileReference const *return_value = ((*local_this).get_file)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_FileReference, true, true, return_value->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_DatagramSink_file_pos_Getter(PyObject *self, void *) {
  DatagramSink *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSink, (void **)&local_this, "DatagramSink.file_pos")) {
    return nullptr;
  }

  // 1-virtual std::streamoff DatagramSink::get_file_pos(void)
  std::streamoff return_value = ((*local_this).get_file_pos)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_DatagramSink(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_DatagramSink(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DatagramSink) {
    printf("DatagramSink ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DatagramSink *local_this = (DatagramSink *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DatagramSink) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DatagramSink(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DatagramSink) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class FileReference
 */
/**
 * Python function wrapper for:
 * inline Filename const &FileReference::get_filename(void) const
 */
static PyObject *Dtool_FileReference_get_filename_366(PyObject *self, PyObject *) {
  FileReference *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_FileReference)) {
    return nullptr;
  }
  // 1-inline Filename const &FileReference::get_filename(void) const
  Filename const *return_value = &(((*(const FileReference*)local_this).get_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_FileReference_get_filename_366_comment =
  "C++ Interface:\n"
  "get_filename(FileReference self)\n"
  "\n"
  "/**\n"
  " * Returns the filename of the reference.\n"
  " */";
#else
static const char *Dtool_FileReference_get_filename_366_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle FileReference::get_class_type(void)
 */
static PyObject *Dtool_FileReference_get_class_type_367(PyObject *, PyObject *) {
  // 1-static TypeHandle FileReference::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((FileReference::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_FileReference_get_class_type_367_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_FileReference_get_class_type_367_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline FileReference::FileReference(FileReference const &) = default
 * inline FileReference::FileReference(Filename const &filename)
 */
static int Dtool_Init_FileReference(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "FileReference() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline FileReference::FileReference(FileReference const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      FileReference const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_FileReference);
      if (param0_this != nullptr) {
        FileReference *return_value = new FileReference(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FileReference, true, false);
      }
    }
  }

  {
    // -2 inline FileReference::FileReference(Filename const &filename)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "filename")) {
      Filename const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Filename);
      if (param0_this != nullptr) {
        FileReference *return_value = new FileReference(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FileReference, true, false);
      }
    }
  }

  {
    // -2 inline FileReference::FileReference(FileReference const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(FileReference) param0_this;
      if (Dtool_ConstCoerce_FileReference(param0, param0_this)) {
        FileReference *return_value = new FileReference(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FileReference, true, false);
      }
    }
  }

  {
    // -2 inline FileReference::FileReference(Filename const &filename)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "filename")) {
      Filename param0_local;
      Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
      if ((param0_this != nullptr)) {
        FileReference *return_value = new FileReference(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_FileReference, true, false);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "FileReference(const FileReference param0)\n"
      "FileReference(const Filename filename)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_FileReference(PyObject *args, CPT(FileReference) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_FileReference)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline FileReference::FileReference(Filename const &filename)
    Filename const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
    if (arg_this != nullptr) {
      FileReference *return_value = new FileReference(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_FileReference(PyObject *args, PT(FileReference) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_FileReference)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline FileReference::FileReference(Filename const &filename)
    Filename const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
    if (arg_this != nullptr) {
      FileReference *return_value = new FileReference(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_FileReference(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_FileReference) {
    printf("FileReference ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  FileReference *local_this = (FileReference *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_FileReference) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_FileReference(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_FileReference) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (FileReference*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (FileReference*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (FileReference*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TypedReferenceCount
 */
/**
 * Python function wrapper for:
 * static TypeHandle TypedReferenceCount::get_class_type(void)
 */
static PyObject *Dtool_TypedReferenceCount_get_class_type_363(PyObject *, PyObject *) {
  // 1-static TypeHandle TypedReferenceCount::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TypedReferenceCount::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypedReferenceCount_get_class_type_363_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TypedReferenceCount_get_class_type_363_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedObject *TypedReferenceCount::upcast_to_TypedObject(void)
 */
static PyObject *Dtool_TypedReferenceCount_upcast_to_TypedObject_359(PyObject *self, PyObject *) {
  TypedReferenceCount *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedReferenceCount, (void **)&local_this, "TypedReferenceCount.upcast_to_TypedObject")) {
    return nullptr;
  }
  // 1-TypedObject *TypedReferenceCount::upcast_to_TypedObject(void)
  TypedObject *return_value = (TypedObject *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedObject, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TypedReferenceCount_upcast_to_TypedObject_359_comment =
  "C++ Interface:\n"
  "upcast_to_TypedObject(const TypedReferenceCount self)\n"
  "\n"
  "upcast from TypedReferenceCount to TypedObject";
#else
static const char *Dtool_TypedReferenceCount_upcast_to_TypedObject_359_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ReferenceCount *TypedReferenceCount::upcast_to_ReferenceCount(void)
 */
static PyObject *Dtool_TypedReferenceCount_upcast_to_ReferenceCount_361(PyObject *self, PyObject *) {
  TypedReferenceCount *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedReferenceCount, (void **)&local_this, "TypedReferenceCount.upcast_to_ReferenceCount")) {
    return nullptr;
  }
  // 1-ReferenceCount *TypedReferenceCount::upcast_to_ReferenceCount(void)
  ReferenceCount *return_value = (ReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReferenceCount, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypedReferenceCount_upcast_to_ReferenceCount_361_comment =
  "C++ Interface:\n"
  "upcast_to_ReferenceCount(const TypedReferenceCount self)\n"
  "\n"
  "upcast from TypedReferenceCount to ReferenceCount";
#else
static const char *Dtool_TypedReferenceCount_upcast_to_ReferenceCount_361_comment = nullptr;
#endif

static int Dtool_Init_TypedReferenceCount(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TypedReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TypedReferenceCount) {
    printf("TypedReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TypedReferenceCount *local_this = (TypedReferenceCount *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TypedReferenceCount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TypedReferenceCount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TypedReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TypedReferenceCount*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Ramfile
 */
/**
 * Python function wrapper for:
 * inline void Ramfile::seek(std::size_t pos)
 */
static PyObject *Dtool_Ramfile_seek_385(PyObject *self, PyObject *arg) {
  Ramfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Ramfile, (void **)&local_this, "Ramfile.seek")) {
    return nullptr;
  }
  // 1-inline void Ramfile::seek(std::size_t pos)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).seek)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "seek(const Ramfile self, int pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Ramfile_seek_385_comment =
  "C++ Interface:\n"
  "seek(const Ramfile self, int pos)\n"
  "\n"
  "/**\n"
  " * Moves the data pointer to the indicated byte position.  It is not an error\n"
  " * to move the pointer past the end of data.\n"
  " */";
#else
static const char *Dtool_Ramfile_seek_385_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Ramfile::tell(void) const
 */
static PyObject *Dtool_Ramfile_tell_386(PyObject *self, PyObject *) {
  Ramfile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Ramfile)) {
    return nullptr;
  }
  // 1-inline std::size_t Ramfile::tell(void) const
  std::size_t return_value = ((*(const Ramfile*)local_this).tell)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Ramfile_tell_386_comment =
  "C++ Interface:\n"
  "tell(Ramfile self)\n"
  "\n"
  "/**\n"
  " * Returns the current data pointer position as a byte offset from the\n"
  " * beginning of the stream.\n"
  " */";
#else
static const char *Dtool_Ramfile_tell_386_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *Ramfile::read(std::size_t length)
 */
static PyObject *Dtool_Ramfile_read_387(PyObject *self, PyObject *arg) {
  Ramfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Ramfile, (void **)&local_this, "Ramfile.read")) {
    return nullptr;
  }
  // 1-PyObject *Ramfile::read(std::size_t length)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    PyObject *return_value = invoke_extension(local_this).read(arg_val);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read(const Ramfile self, int length)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Ramfile_read_387_comment =
  "C++ Interface:\n"
  "read(const Ramfile self, int length)\n"
  "\n"
  "/**\n"
  " * Extracts and returns the indicated number of characters from the current\n"
  " * data pointer, and advances the data pointer.  If the data pointer exceeds\n"
  " * the end of the buffer, returns empty string.\n"
  " *\n"
  " * The interface here is intentionally designed to be similar to that for\n"
  " * Python's file.read() function.\n"
  " */";
#else
static const char *Dtool_Ramfile_read_387_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *Ramfile::readline(void)
 */
static PyObject *Dtool_Ramfile_readline_388(PyObject *self, PyObject *) {
  Ramfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Ramfile, (void **)&local_this, "Ramfile.readline")) {
    return nullptr;
  }
  // 1-PyObject *Ramfile::readline(void)
  PyObject *return_value = invoke_extension(local_this).readline();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Ramfile_readline_388_comment =
  "C++ Interface:\n"
  "readline(const Ramfile self)\n"
  "\n"
  "/**\n"
  " * Assumes the stream represents a text file, and extracts one line up to and\n"
  " * including the trailing newline character.  Returns empty string when the\n"
  " * end of file is reached.\n"
  " *\n"
  " * The interface here is intentionally designed to be similar to that for\n"
  " * Python's file.readline() function.\n"
  " */";
#else
static const char *Dtool_Ramfile_readline_388_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *Ramfile::readlines(void)
 */
static PyObject *Dtool_Ramfile_readlines_389(PyObject *self, PyObject *) {
  Ramfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Ramfile, (void **)&local_this, "Ramfile.readlines")) {
    return nullptr;
  }
  // 1-PyObject *Ramfile::readlines(void)
  PyObject *return_value = invoke_extension(local_this).readlines();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Ramfile_readlines_389_comment =
  "C++ Interface:\n"
  "readlines(const Ramfile self)\n";
#else
static const char *Dtool_Ramfile_readlines_389_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *Ramfile::get_data(void) const
 */
static PyObject *Dtool_Ramfile_get_data_390(PyObject *self, PyObject *) {
  Ramfile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Ramfile)) {
    return nullptr;
  }
  // 1-PyObject *Ramfile::get_data(void) const
  PyObject *return_value = invoke_extension((const Ramfile*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Ramfile_get_data_390_comment =
  "C++ Interface:\n"
  "get_data(Ramfile self)\n"
  "\n"
  "/**\n"
  " * Returns the entire buffer contents as a string, regardless of the current\n"
  " * data pointer.\n"
  " */";
#else
static const char *Dtool_Ramfile_get_data_390_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Ramfile::get_data_size(void) const
 */
static PyObject *Dtool_Ramfile_get_data_size_391(PyObject *self, PyObject *) {
  Ramfile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Ramfile)) {
    return nullptr;
  }
  // 1-inline std::size_t Ramfile::get_data_size(void) const
  std::size_t return_value = ((*(const Ramfile*)local_this).get_data_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Ramfile_get_data_size_391_comment =
  "C++ Interface:\n"
  "get_data_size(Ramfile self)\n"
  "\n"
  "/**\n"
  " * Returns the size of the entire buffer contents.\n"
  " */";
#else
static const char *Dtool_Ramfile_get_data_size_391_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Ramfile::clear(void)
 */
static PyObject *Dtool_Ramfile_clear_392(PyObject *self, PyObject *) {
  Ramfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Ramfile, (void **)&local_this, "Ramfile.clear")) {
    return nullptr;
  }
  // 1-inline void Ramfile::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Ramfile_clear_392_comment =
  "C++ Interface:\n"
  "clear(const Ramfile self)\n"
  "\n"
  "/**\n"
  " * Empties the current buffer contents.\n"
  " */";
#else
static const char *Dtool_Ramfile_clear_392_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Ramfile::Ramfile(void)
 * inline Ramfile::Ramfile(Ramfile const &) = default
 */
static int Dtool_Init_Ramfile(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Ramfile() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline Ramfile::Ramfile(void)
      Ramfile *return_value = new Ramfile();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Ramfile, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline Ramfile::Ramfile(Ramfile const &) = default
      Ramfile const *arg_this = (Ramfile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Ramfile, 0, "Ramfile.Ramfile", true, true);
      if (arg_this != nullptr) {
        Ramfile *return_value = new Ramfile(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Ramfile, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Ramfile() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Ramfile()\n"
      "Ramfile(const Ramfile param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Ramfile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Ramfile) {
    printf("Ramfile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Ramfile *local_this = (Ramfile *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Ramfile) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Ramfile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Ramfile) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class HashVal
 */
/**
 * Python function wrapper for:
 * inline void HashVal::operator =(HashVal const &copy)
 */
static PyObject *Dtool_HashVal_operator_396(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.assign")) {
    return nullptr;
  }
  // 1-inline void HashVal::operator =(HashVal const &copy)
  HashVal const *arg_this = (HashVal *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HashVal, 1, "HashVal.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    HashVal *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HashVal, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const HashVal self, const HashVal copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_operator_396_comment =
  "C++ Interface:\n"
  "assign(const HashVal self, const HashVal copy)\n";
#else
static const char *Dtool_HashVal_operator_396_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int HashVal::compare_to(HashVal const &other) const
 */
static PyObject *Dtool_HashVal_compare_to_400(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HashVal)) {
    return nullptr;
  }
  // 1-inline int HashVal::compare_to(HashVal const &other) const
  HashVal const *arg_this = (HashVal *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HashVal, 1, "HashVal.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const HashVal*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(HashVal self, const HashVal other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_compare_to_400_comment =
  "C++ Interface:\n"
  "compare_to(HashVal self, const HashVal other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HashVal_compare_to_400_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::merge_with(HashVal const &other)
 */
static PyObject *Dtool_HashVal_merge_with_401(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.merge_with")) {
    return nullptr;
  }
  // 1-inline void HashVal::merge_with(HashVal const &other)
  HashVal const *arg_this = (HashVal *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HashVal, 1, "HashVal.merge_with", true, true);
  if (arg_this != nullptr) {
    ((*local_this).merge_with)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "merge_with(const HashVal self, const HashVal other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_merge_with_401_comment =
  "C++ Interface:\n"
  "merge_with(const HashVal self, const HashVal other)\n"
  "\n"
  "/**\n"
  " * Generates a new HashVal representing the xor of this one and the other one.\n"
  " */";
#else
static const char *Dtool_HashVal_merge_with_401_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::output_dec(std::ostream &out) const
 */
static PyObject *Dtool_HashVal_output_dec_402(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HashVal)) {
    return nullptr;
  }
  // 1-inline void HashVal::output_dec(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "HashVal.output_dec", false, true);
  if (arg_this != nullptr) {
    ((*(const HashVal*)local_this).output_dec)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_dec(HashVal self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_output_dec_402_comment =
  "C++ Interface:\n"
  "output_dec(HashVal self, ostream out)\n"
  "\n"
  "/**\n"
  " * Outputs the HashVal as four unsigned decimal integers.\n"
  " */";
#else
static const char *Dtool_HashVal_output_dec_402_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::input_dec(std::istream &in)
 */
static PyObject *Dtool_HashVal_input_dec_403(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.input_dec")) {
    return nullptr;
  }
  // 1-inline void HashVal::input_dec(std::istream &in)
  std::istream *arg_this = (std::istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_istream, 1, "HashVal.input_dec", false, true);
  if (arg_this != nullptr) {
    ((*local_this).input_dec)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "input_dec(const HashVal self, istream in)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_input_dec_403_comment =
  "C++ Interface:\n"
  "input_dec(const HashVal self, istream in)\n"
  "\n"
  "/**\n"
  " * Inputs the HashVal as four unsigned decimal integers.\n"
  " */";
#else
static const char *Dtool_HashVal_input_dec_403_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void HashVal::output_hex(std::ostream &out) const
 */
static PyObject *Dtool_HashVal_output_hex_404(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HashVal)) {
    return nullptr;
  }
  // 1-void HashVal::output_hex(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "HashVal.output_hex", false, true);
  if (arg_this != nullptr) {
    ((*(const HashVal*)local_this).output_hex)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_hex(HashVal self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_output_hex_404_comment =
  "C++ Interface:\n"
  "output_hex(HashVal self, ostream out)\n"
  "\n"
  "/**\n"
  " * Outputs the HashVal as a 32-digit hexadecimal number.\n"
  " */";
#else
static const char *Dtool_HashVal_output_hex_404_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void HashVal::input_hex(std::istream &in)
 */
static PyObject *Dtool_HashVal_input_hex_405(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.input_hex")) {
    return nullptr;
  }
  // 1-void HashVal::input_hex(std::istream &in)
  std::istream *arg_this = (std::istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_istream, 1, "HashVal.input_hex", false, true);
  if (arg_this != nullptr) {
    ((*local_this).input_hex)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "input_hex(const HashVal self, istream in)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_input_hex_405_comment =
  "C++ Interface:\n"
  "input_hex(const HashVal self, istream in)\n"
  "\n"
  "/**\n"
  " * Inputs the HashVal as a 32-digit hexadecimal number.\n"
  " */";
#else
static const char *Dtool_HashVal_input_hex_405_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void HashVal::output_binary(std::ostream &out) const
 */
static PyObject *Dtool_HashVal_output_binary_406(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HashVal)) {
    return nullptr;
  }
  // 1-void HashVal::output_binary(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "HashVal.output_binary", false, true);
  if (arg_this != nullptr) {
    ((*(const HashVal*)local_this).output_binary)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_binary(HashVal self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_output_binary_406_comment =
  "C++ Interface:\n"
  "output_binary(HashVal self, ostream out)\n"
  "\n"
  "/**\n"
  " * Outputs the HashVal as a binary stream of bytes in order.  This is not the\n"
  " * same order generated by write_stream().\n"
  " */";
#else
static const char *Dtool_HashVal_output_binary_406_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void HashVal::input_binary(std::istream &in)
 */
static PyObject *Dtool_HashVal_input_binary_407(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.input_binary")) {
    return nullptr;
  }
  // 1-void HashVal::input_binary(std::istream &in)
  std::istream *arg_this = (std::istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_istream, 1, "HashVal.input_binary", false, true);
  if (arg_this != nullptr) {
    ((*local_this).input_binary)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "input_binary(const HashVal self, istream in)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_input_binary_407_comment =
  "C++ Interface:\n"
  "input_binary(const HashVal self, istream in)\n"
  "\n"
  "/**\n"
  " * Inputs the HashVal as a binary stream of bytes in order.  This is not the\n"
  " * same order expected by read_stream().\n"
  " */";
#else
static const char *Dtool_HashVal_input_binary_407_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::output(std::ostream &out) const
 */
static PyObject *Dtool_HashVal_output_408(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HashVal)) {
    return nullptr;
  }
  // 1-inline void HashVal::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "HashVal.output", false, true);
  if (arg_this != nullptr) {
    ((*(const HashVal*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(HashVal self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_output_408_comment =
  "C++ Interface:\n"
  "output(HashVal self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HashVal_output_408_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string HashVal::as_dec(void) const
 */
static PyObject *Dtool_HashVal_as_dec_409(PyObject *self, PyObject *) {
  HashVal *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HashVal)) {
    return nullptr;
  }
  // 1-std::string HashVal::as_dec(void) const
  std::string return_value = ((*(const HashVal*)local_this).as_dec)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HashVal_as_dec_409_comment =
  "C++ Interface:\n"
  "as_dec(HashVal self)\n"
  "\n"
  "/**\n"
  " * Returns the HashVal as a string with four decimal numbers.\n"
  " */";
#else
static const char *Dtool_HashVal_as_dec_409_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool HashVal::set_from_dec(std::string const &text)
 */
static PyObject *Dtool_HashVal_set_from_dec_410(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.set_from_dec")) {
    return nullptr;
  }
  // 1-bool HashVal::set_from_dec(std::string const &text)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*local_this).set_from_dec)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_dec(const HashVal self, str text)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_set_from_dec_410_comment =
  "C++ Interface:\n"
  "set_from_dec(const HashVal self, str text)\n"
  "\n"
  "/**\n"
  " * Sets the HashVal from a string with four decimal numbers.  Returns true if\n"
  " * valid, false otherwise.\n"
  " */";
#else
static const char *Dtool_HashVal_set_from_dec_410_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string HashVal::as_hex(void) const
 */
static PyObject *Dtool_HashVal_as_hex_411(PyObject *self, PyObject *) {
  HashVal *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HashVal)) {
    return nullptr;
  }
  // 1-std::string HashVal::as_hex(void) const
  std::string return_value = ((*(const HashVal*)local_this).as_hex)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HashVal_as_hex_411_comment =
  "C++ Interface:\n"
  "as_hex(HashVal self)\n"
  "\n"
  "/**\n"
  " * Returns the HashVal as a 32-byte hexadecimal string.\n"
  " */";
#else
static const char *Dtool_HashVal_as_hex_411_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool HashVal::set_from_hex(std::string const &text)
 */
static PyObject *Dtool_HashVal_set_from_hex_412(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.set_from_hex")) {
    return nullptr;
  }
  // 1-bool HashVal::set_from_hex(std::string const &text)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*local_this).set_from_hex)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_hex(const HashVal self, str text)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_set_from_hex_412_comment =
  "C++ Interface:\n"
  "set_from_hex(const HashVal self, str text)\n"
  "\n"
  "/**\n"
  " * Sets the HashVal from a 32-byte hexademical string.  Returns true if\n"
  " * successful, false otherwise.\n"
  " */";
#else
static const char *Dtool_HashVal_set_from_hex_412_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * vector_uchar HashVal::as_bin(void) const
 */
static PyObject *Dtool_HashVal_as_bin_413(PyObject *self, PyObject *) {
  HashVal *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HashVal)) {
    return nullptr;
  }
  // 1-vector_uchar HashVal::as_bin(void) const
  vector_uchar return_value = ((*(const HashVal*)local_this).as_bin)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_HashVal_as_bin_413_comment =
  "C++ Interface:\n"
  "as_bin(HashVal self)\n"
  "\n"
  "/**\n"
  " * Returns the HashVal as a 16-byte binary string.\n"
  " */";
#else
static const char *Dtool_HashVal_as_bin_413_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool HashVal::set_from_bin(vector_uchar const &text)
 */
static PyObject *Dtool_HashVal_set_from_bin_414(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.set_from_bin")) {
    return nullptr;
  }
  // 1-bool HashVal::set_from_bin(vector_uchar const &text)
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param1_str, &param1_len) >= 0) {
    bool return_value = ((*local_this).set_from_bin)(vector_uchar(param1_str, param1_str + param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_from_bin(const HashVal self, bytes text)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_set_from_bin_414_comment =
  "C++ Interface:\n"
  "set_from_bin(const HashVal self, bytes text)\n"
  "\n"
  "/**\n"
  " * Sets the HashVal from a 16-byte binary string.  Returns true if successful,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_HashVal_set_from_bin_414_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::write_datagram(Datagram &destination) const
 */
static PyObject *Dtool_HashVal_write_datagram_415(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HashVal)) {
    return nullptr;
  }
  // 1-inline void HashVal::write_datagram(Datagram &destination) const
  Datagram arg_local;
  Datagram *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HashVal.write_datagram", "Datagram");
  }
  ((*(const HashVal*)local_this).write_datagram)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_datagram(HashVal self, Datagram destination)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_write_datagram_415_comment =
  "C++ Interface:\n"
  "write_datagram(HashVal self, Datagram destination)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HashVal_write_datagram_415_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::read_datagram(DatagramIterator &source)
 */
static PyObject *Dtool_HashVal_read_datagram_416(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.read_datagram")) {
    return nullptr;
  }
  // 1-inline void HashVal::read_datagram(DatagramIterator &source)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HashVal.read_datagram", "DatagramIterator");
  }
  ((*local_this).read_datagram)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_datagram(const HashVal self, DatagramIterator source)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_read_datagram_416_comment =
  "C++ Interface:\n"
  "read_datagram(const HashVal self, DatagramIterator source)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HashVal_read_datagram_416_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::write_stream(StreamWriter &destination) const
 */
static PyObject *Dtool_HashVal_write_stream_417(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_HashVal)) {
    return nullptr;
  }
  // 1-inline void HashVal::write_stream(StreamWriter &destination) const
  StreamWriter *arg_this = (StreamWriter *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_StreamWriter, 1, "HashVal.write_stream", false, true);
  if (arg_this != nullptr) {
    ((*(const HashVal*)local_this).write_stream)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_stream(HashVal self, StreamWriter destination)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_write_stream_417_comment =
  "C++ Interface:\n"
  "write_stream(HashVal self, StreamWriter destination)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HashVal_write_stream_417_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::read_stream(StreamReader &source)
 */
static PyObject *Dtool_HashVal_read_stream_418(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.read_stream")) {
    return nullptr;
  }
  // 1-inline void HashVal::read_stream(StreamReader &source)
  StreamReader *arg_this = (StreamReader *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_StreamReader, 1, "HashVal.read_stream", false, true);
  if (arg_this != nullptr) {
    ((*local_this).read_stream)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_stream(const HashVal self, StreamReader source)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_read_stream_418_comment =
  "C++ Interface:\n"
  "read_stream(const HashVal self, StreamReader source)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_HashVal_read_stream_418_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool HashVal::hash_file(Filename const &filename)
 */
static PyObject *Dtool_HashVal_hash_file_419(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.hash_file")) {
    return nullptr;
  }
  // 1-bool HashVal::hash_file(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "HashVal.hash_file", "Filename");
  }
  bool return_value = ((*local_this).hash_file)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "hash_file(const HashVal self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_hash_file_419_comment =
  "C++ Interface:\n"
  "hash_file(const HashVal self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Generates the hash value from the indicated file.  Returns true on success,\n"
  " * false if the file cannot be read.  This method is only defined if we have\n"
  " * the OpenSSL library (which provides md5 functionality) available.\n"
  " */";
#else
static const char *Dtool_HashVal_hash_file_419_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool HashVal::hash_stream(std::istream &stream)
 */
static PyObject *Dtool_HashVal_hash_stream_420(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.hash_stream")) {
    return nullptr;
  }
  // 1-bool HashVal::hash_stream(std::istream &stream)
  std::istream *arg_this = (std::istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_istream, 1, "HashVal.hash_stream", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).hash_stream)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "hash_stream(const HashVal self, istream stream)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_hash_stream_420_comment =
  "C++ Interface:\n"
  "hash_stream(const HashVal self, istream stream)\n"
  "\n"
  "/**\n"
  " * Generates the hash value from the indicated file.  Returns true on success,\n"
  " * false if the file cannot be read.  This method is only defined if we have\n"
  " * the OpenSSL library (which provides md5 functionality) available.\n"
  " */";
#else
static const char *Dtool_HashVal_hash_stream_420_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::hash_ramfile(Ramfile const &ramfile)
 */
static PyObject *Dtool_HashVal_hash_ramfile_421(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.hash_ramfile")) {
    return nullptr;
  }
  // 1-inline void HashVal::hash_ramfile(Ramfile const &ramfile)
  Ramfile const *arg_this = (Ramfile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Ramfile, 1, "HashVal.hash_ramfile", true, true);
  if (arg_this != nullptr) {
    ((*local_this).hash_ramfile)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "hash_ramfile(const HashVal self, const Ramfile ramfile)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_hash_ramfile_421_comment =
  "C++ Interface:\n"
  "hash_ramfile(const HashVal self, const Ramfile ramfile)\n"
  "\n"
  "/**\n"
  " * Generates the hash value by hashing the indicated data.  This method is\n"
  " * only defined if we have the OpenSSL library (which provides md5\n"
  " * functionality) available.\n"
  " */";
#else
static const char *Dtool_HashVal_hash_ramfile_421_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::hash_string(std::string const &data)
 */
static PyObject *Dtool_HashVal_hash_string_422(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.hash_string")) {
    return nullptr;
  }
  // 1-inline void HashVal::hash_string(std::string const &data)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).hash_string)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "hash_string(const HashVal self, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_hash_string_422_comment =
  "C++ Interface:\n"
  "hash_string(const HashVal self, str data)\n"
  "\n"
  "/**\n"
  " * Generates the hash value by hashing the indicated data.  This method is\n"
  " * only defined if we have the OpenSSL library (which provides md5\n"
  " * functionality) available.\n"
  " */";
#else
static const char *Dtool_HashVal_hash_string_422_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void HashVal::hash_bytes(vector_uchar const &data)
 */
static PyObject *Dtool_HashVal_hash_bytes_423(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.hash_bytes")) {
    return nullptr;
  }
  // 1-inline void HashVal::hash_bytes(vector_uchar const &data)
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param1_str, &param1_len) >= 0) {
    ((*local_this).hash_bytes)(vector_uchar(param1_str, param1_str + param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "hash_bytes(const HashVal self, bytes data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_hash_bytes_423_comment =
  "C++ Interface:\n"
  "hash_bytes(const HashVal self, bytes data)\n"
  "\n"
  "/**\n"
  " * Generates the hash value by hashing the indicated data.  This method is\n"
  " * only defined if we have the OpenSSL library (which provides md5\n"
  " * functionality) available.\n"
  " */";
#else
static const char *Dtool_HashVal_hash_bytes_423_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void HashVal::hash_buffer(char const *buffer, int length)
 */
static PyObject *Dtool_HashVal_hash_buffer_424(PyObject *self, PyObject *args, PyObject *kwds) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_HashVal, (void **)&local_this, "HashVal.hash_buffer")) {
    return nullptr;
  }
  // 1-void HashVal::hash_buffer(char const *buffer, int length)
  char const *param1;
  int param2;
  static const char *keyword_list[] = {"buffer", "length", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "zi:hash_buffer", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).hash_buffer)((char const *)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "hash_buffer(const HashVal self, str buffer, int length)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_HashVal_hash_buffer_424_comment =
  "C++ Interface:\n"
  "hash_buffer(const HashVal self, str buffer, int length)\n"
  "\n"
  "/**\n"
  " * Generates the hash value by hashing the indicated data.  This method is\n"
  " * only defined if we have the OpenSSL library (which provides md5\n"
  " * functionality) available.\n"
  " */";
#else
static const char *Dtool_HashVal_hash_buffer_424_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline HashVal::HashVal(void)
 * inline HashVal::HashVal(HashVal const &copy)
 */
static int Dtool_Init_HashVal(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline HashVal::HashVal(void)
      HashVal *return_value = new HashVal();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HashVal, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline HashVal::HashVal(HashVal const &copy)
        HashVal const *arg_this = (HashVal *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HashVal, 0, "HashVal.HashVal", true, true);
        if (arg_this != nullptr) {
          HashVal *return_value = new HashVal(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HashVal, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "HashVal() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "HashVal()\n"
      "HashVal(const HashVal copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_HashVal(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_HashVal) {
    printf("HashVal ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  HashVal *local_this = (HashVal *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_HashVal) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_HashVal(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_HashVal) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MemoryUsagePointers
 */
/**
 * Python function wrapper for:
 * std::size_t MemoryUsagePointers::get_num_pointers(void) const
 */
static PyObject *Dtool_MemoryUsagePointers_get_num_pointers_429(PyObject *self, PyObject *) {
  MemoryUsagePointers *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MemoryUsagePointers)) {
    return nullptr;
  }
  // 1-std::size_t MemoryUsagePointers::get_num_pointers(void) const
  std::size_t return_value = ((*(const MemoryUsagePointers*)local_this).get_num_pointers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_get_num_pointers_429_comment =
  "C++ Interface:\n"
  "get_num_pointers(MemoryUsagePointers self)\n"
  "\n"
  "/**\n"
  " * Returns the number of pointers in the set.\n"
  " */";
#else
static const char *Dtool_MemoryUsagePointers_get_num_pointers_429_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ReferenceCount *MemoryUsagePointers::get_pointer(std::size_t n) const
 */
static PyObject *Dtool_MemoryUsagePointers_get_pointer_430(PyObject *self, PyObject *arg) {
  MemoryUsagePointers *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MemoryUsagePointers)) {
    return nullptr;
  }
  // 1-ReferenceCount *MemoryUsagePointers::get_pointer(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ReferenceCount *return_value = ((*(const MemoryUsagePointers*)local_this).get_pointer)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReferenceCount, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pointer(MemoryUsagePointers self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_get_pointer_430_comment =
  "C++ Interface:\n"
  "get_pointer(MemoryUsagePointers self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth pointer of the set.\n"
  " */";
#else
static const char *Dtool_MemoryUsagePointers_get_pointer_430_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedObject *MemoryUsagePointers::get_typed_pointer(std::size_t n) const
 */
static PyObject *Dtool_MemoryUsagePointers_get_typed_pointer_432(PyObject *self, PyObject *arg) {
  MemoryUsagePointers *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MemoryUsagePointers)) {
    return nullptr;
  }
  // 1-TypedObject *MemoryUsagePointers::get_typed_pointer(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    TypedObject *return_value = ((*(const MemoryUsagePointers*)local_this).get_typed_pointer)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedObject, false, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_typed_pointer(MemoryUsagePointers self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_get_typed_pointer_432_comment =
  "C++ Interface:\n"
  "get_typed_pointer(MemoryUsagePointers self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth pointer of the set, typecast to a TypedObject if possible.\n"
  " * If the pointer is not a TypedObject or if the cast cannot be made, returns\n"
  " * nullptr.\n"
  " */";
#else
static const char *Dtool_MemoryUsagePointers_get_typed_pointer_432_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypeHandle MemoryUsagePointers::get_type(std::size_t n) const
 */
static PyObject *Dtool_MemoryUsagePointers_get_type_434(PyObject *self, PyObject *arg) {
  MemoryUsagePointers *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MemoryUsagePointers)) {
    return nullptr;
  }
  // 1-TypeHandle MemoryUsagePointers::get_type(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    TypeHandle *return_value = new TypeHandle(((*(const MemoryUsagePointers*)local_this).get_type)(arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_type(MemoryUsagePointers self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_get_type_434_comment =
  "C++ Interface:\n"
  "get_type(MemoryUsagePointers self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the actual type of the nth pointer, if it is known.\n"
  " */";
#else
static const char *Dtool_MemoryUsagePointers_get_type_434_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string MemoryUsagePointers::get_type_name(std::size_t n) const
 */
static PyObject *Dtool_MemoryUsagePointers_get_type_name_435(PyObject *self, PyObject *arg) {
  MemoryUsagePointers *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MemoryUsagePointers)) {
    return nullptr;
  }
  // 1-std::string MemoryUsagePointers::get_type_name(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    std::string return_value = ((*(const MemoryUsagePointers*)local_this).get_type_name)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_type_name(MemoryUsagePointers self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_get_type_name_435_comment =
  "C++ Interface:\n"
  "get_type_name(MemoryUsagePointers self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the type name of the nth pointer, if it is known.\n"
  " */";
#else
static const char *Dtool_MemoryUsagePointers_get_type_name_435_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double MemoryUsagePointers::get_age(std::size_t n) const
 */
static PyObject *Dtool_MemoryUsagePointers_get_age_436(PyObject *self, PyObject *arg) {
  MemoryUsagePointers *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MemoryUsagePointers)) {
    return nullptr;
  }
  // 1-double MemoryUsagePointers::get_age(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    double return_value = ((*(const MemoryUsagePointers*)local_this).get_age)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_age(MemoryUsagePointers self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_get_age_436_comment =
  "C++ Interface:\n"
  "get_age(MemoryUsagePointers self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the age of the nth pointer: the number of seconds elapsed between\n"
  " * the time it was allocated and the time it was added to this set via a call\n"
  " * to MemoryUsage::get_pointers().\n"
  " */";
#else
static const char *Dtool_MemoryUsagePointers_get_age_436_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *MemoryUsagePointers::get_python_pointer(std::size_t n) const
 */
static PyObject *Dtool_MemoryUsagePointers_get_python_pointer_437(PyObject *self, PyObject *arg) {
  MemoryUsagePointers *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MemoryUsagePointers)) {
    return nullptr;
  }
  // 1-PyObject *MemoryUsagePointers::get_python_pointer(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    PyObject *return_value = invoke_extension((const MemoryUsagePointers*)local_this).get_python_pointer(arg_val);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_python_pointer(MemoryUsagePointers self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_get_python_pointer_437_comment =
  "C++ Interface:\n"
  "get_python_pointer(MemoryUsagePointers self, int n)\n";
#else
static const char *Dtool_MemoryUsagePointers_get_python_pointer_437_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void MemoryUsagePointers::clear(void)
 */
static PyObject *Dtool_MemoryUsagePointers_clear_438(PyObject *self, PyObject *) {
  MemoryUsagePointers *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_MemoryUsagePointers, (void **)&local_this, "MemoryUsagePointers.clear")) {
    return nullptr;
  }
  // 1-void MemoryUsagePointers::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_clear_438_comment =
  "C++ Interface:\n"
  "clear(const MemoryUsagePointers self)\n"
  "\n"
  "/**\n"
  " * Empties the set of pointers.\n"
  " */";
#else
static const char *Dtool_MemoryUsagePointers_clear_438_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void MemoryUsagePointers::output(std::ostream &out) const
 */
static PyObject *Dtool_MemoryUsagePointers_output_439(PyObject *self, PyObject *arg) {
  MemoryUsagePointers *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MemoryUsagePointers)) {
    return nullptr;
  }
  // 1-void MemoryUsagePointers::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "MemoryUsagePointers.output", false, true);
  if (arg_this != nullptr) {
    ((*(const MemoryUsagePointers*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(MemoryUsagePointers self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MemoryUsagePointers_output_439_comment =
  "C++ Interface:\n"
  "output(MemoryUsagePointers self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_MemoryUsagePointers_output_439_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * MemoryUsagePointers::MemoryUsagePointers(void)
 * inline MemoryUsagePointers::MemoryUsagePointers(MemoryUsagePointers const &) = default
 */
static int Dtool_Init_MemoryUsagePointers(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("MemoryUsagePointers() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-MemoryUsagePointers::MemoryUsagePointers(void)
      MemoryUsagePointers *return_value = new MemoryUsagePointers();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MemoryUsagePointers, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline MemoryUsagePointers::MemoryUsagePointers(MemoryUsagePointers const &) = default
      MemoryUsagePointers const *arg_this = (MemoryUsagePointers *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MemoryUsagePointers, 0, "MemoryUsagePointers.MemoryUsagePointers", true, true);
      if (arg_this != nullptr) {
        MemoryUsagePointers *return_value = new MemoryUsagePointers(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MemoryUsagePointers, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "MemoryUsagePointers() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MemoryUsagePointers()\n"
      "MemoryUsagePointers(const MemoryUsagePointers param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_MemoryUsagePointers_get_pointers(PyObject *self, PyObject *) {
  MemoryUsagePointers *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MemoryUsagePointers, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_pointers)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_MemoryUsagePointers_get_pointer_430(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_MemoryUsagePointers_get_typed_pointers(PyObject *self, PyObject *) {
  MemoryUsagePointers *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MemoryUsagePointers, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_pointers)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_MemoryUsagePointers_get_typed_pointer_432(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_MemoryUsagePointers(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MemoryUsagePointers) {
    printf("MemoryUsagePointers ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MemoryUsagePointers *local_this = (MemoryUsagePointers *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MemoryUsagePointers) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MemoryUsagePointers(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MemoryUsagePointers) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ISubStream
 */
/**
 * Python function wrapper for:
 * inline ISubStream &ISubStream::open(IStreamWrapper *source, std::streamoff start, std::streamoff end)
 */
static PyObject *Dtool_ISubStream_open_443(PyObject *self, PyObject *args, PyObject *kwds) {
  ISubStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ISubStream, (void **)&local_this, "ISubStream.open")) {
    return nullptr;
  }
  // 1-inline ISubStream &ISubStream::open(IStreamWrapper *source, std::streamoff start, std::streamoff end)
  PyObject *param1;
  PY_LONG_LONG param2;
  PY_LONG_LONG param3;
  static const char *keyword_list[] = {"source", "start", "end", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OLL:open", (char **)keyword_list, &param1, &param2, &param3)) {
    IStreamWrapper *param1_this = (IStreamWrapper *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_IStreamWrapper, 1, "ISubStream.open", false, true);
    if (param1_this != nullptr) {
      ISubStream *return_value = &(((*local_this).open)(param1_this, (std::streamoff)param2, (std::streamoff)param3));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ISubStream, false, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const ISubStream self, IStreamWrapper source, long start, long end)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ISubStream_open_443_comment =
  "C++ Interface:\n"
  "open(const ISubStream self, IStreamWrapper source, long start, long end)\n"
  "\n"
  "/**\n"
  " * Starts the SubStream reading from the indicated source, with the first\n"
  " * character being the character at position \"start\" within the source, for\n"
  " * end - start total characters.  The character at \"end\" within the source\n"
  " * will never be read; this will appear to be EOF.\n"
  " *\n"
  " * If end is zero, it indicates that the ISubStream will continue until the\n"
  " * end of the source stream.\n"
  " */";
#else
static const char *Dtool_ISubStream_open_443_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ISubStream &ISubStream::close(void)
 */
static PyObject *Dtool_ISubStream_close_444(PyObject *self, PyObject *) {
  ISubStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ISubStream, (void **)&local_this, "ISubStream.close")) {
    return nullptr;
  }
  // 1-inline ISubStream &ISubStream::close(void)
  ISubStream *return_value = &(((*local_this).close)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ISubStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ISubStream_close_444_comment =
  "C++ Interface:\n"
  "close(const ISubStream self)\n"
  "\n"
  "/**\n"
  " * Resets the SubStream to empty, but does not actually close the source\n"
  " * istream.\n"
  " */";
#else
static const char *Dtool_ISubStream_close_444_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ISubStream::ISubStream(void)
 * inline explicit ISubStream::ISubStream(IStreamWrapper *source, std::streamoff start, std::streamoff end)
 */
static int Dtool_Init_ISubStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline ISubStream::ISubStream(void)
      ISubStream *return_value = new ISubStream();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ISubStream, true, false);
    }
    break;
  case 3:
    {
      // 1-inline explicit ISubStream::ISubStream(IStreamWrapper *source, std::streamoff start, std::streamoff end)
      PyObject *param0;
      PY_LONG_LONG param1;
      PY_LONG_LONG param2;
      static const char *keyword_list[] = {"source", "start", "end", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OLL:ISubStream", (char **)keyword_list, &param0, &param1, &param2)) {
        IStreamWrapper *param0_this = (IStreamWrapper *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_IStreamWrapper, 0, "ISubStream.ISubStream", false, true);
        if (param0_this != nullptr) {
          ISubStream *return_value = new ISubStream(param0_this, (std::streamoff)param1, (std::streamoff)param2);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ISubStream, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ISubStream() takes 0 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ISubStream()\n"
      "ISubStream(IStreamWrapper source, long start, long end)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ISubStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ISubStream) {
    printf("ISubStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ISubStream *local_this = (ISubStream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ISubStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *)(std::istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *)(std::istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_istream) {
    return (std::istream *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ISubStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ISubStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_std_istream) {
    std::istream* other_this = (std::istream*)from_this;
    return (ISubStream*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OSubStream
 */
/**
 * Python function wrapper for:
 * inline OSubStream &OSubStream::open(OStreamWrapper *dest, std::streamoff start, std::streamoff end, bool append = false)
 */
static PyObject *Dtool_OSubStream_open_449(PyObject *self, PyObject *args, PyObject *kwds) {
  OSubStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OSubStream, (void **)&local_this, "OSubStream.open")) {
    return nullptr;
  }
  // 1-inline OSubStream &OSubStream::open(OStreamWrapper *dest, std::streamoff start, std::streamoff end, bool append = false)
  PyObject *param1;
  PY_LONG_LONG param2;
  PY_LONG_LONG param3;
  PyObject *param4 = Py_False;
  static const char *keyword_list[] = {"dest", "start", "end", "append", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OLL|O:open", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    OStreamWrapper *param1_this = (OStreamWrapper *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OStreamWrapper, 1, "OSubStream.open", false, true);
    if (param1_this != nullptr) {
      OSubStream *return_value = &(((*local_this).open)(param1_this, (std::streamoff)param2, (std::streamoff)param3, (PyObject_IsTrue(param4) != 0)));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OSubStream, false, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const OSubStream self, OStreamWrapper dest, long start, long end, bool append)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OSubStream_open_449_comment =
  "C++ Interface:\n"
  "open(const OSubStream self, OStreamWrapper dest, long start, long end, bool append)\n"
  "\n"
  "/**\n"
  " * Starts the SubStream reading from the indicated dest, with the first\n"
  " * character being the character at position \"start\" within the dest, for end\n"
  " * - start total characters.  The character at \"end\" within the dest will\n"
  " * never be read; this will appear to be EOF.\n"
  " *\n"
  " * If end is zero, it indicates that the OSubStream will continue until the\n"
  " * end of the dest stream.\n"
  " */";
#else
static const char *Dtool_OSubStream_open_449_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OSubStream &OSubStream::close(void)
 */
static PyObject *Dtool_OSubStream_close_450(PyObject *self, PyObject *) {
  OSubStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OSubStream, (void **)&local_this, "OSubStream.close")) {
    return nullptr;
  }
  // 1-inline OSubStream &OSubStream::close(void)
  OSubStream *return_value = &(((*local_this).close)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OSubStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OSubStream_close_450_comment =
  "C++ Interface:\n"
  "close(const OSubStream self)\n"
  "\n"
  "/**\n"
  " * Resets the SubStream to empty, but does not actually close the dest\n"
  " * ostream.\n"
  " */";
#else
static const char *Dtool_OSubStream_close_450_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OSubStream::OSubStream(void)
 * inline explicit OSubStream::OSubStream(OStreamWrapper *dest, std::streamoff start, std::streamoff end, bool append = false)
 */
static int Dtool_Init_OSubStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline OSubStream::OSubStream(void)
      OSubStream *return_value = new OSubStream();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OSubStream, true, false);
    }
    break;
  case 3:
  case 4:
    {
      // 1-inline explicit OSubStream::OSubStream(OStreamWrapper *dest, std::streamoff start, std::streamoff end, bool append = false)
      PyObject *param0;
      PY_LONG_LONG param1;
      PY_LONG_LONG param2;
      PyObject *param3 = Py_False;
      static const char *keyword_list[] = {"dest", "start", "end", "append", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OLL|O:OSubStream", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        OStreamWrapper *param0_this = (OStreamWrapper *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OStreamWrapper, 0, "OSubStream.OSubStream", false, true);
        if (param0_this != nullptr) {
          OSubStream *return_value = new OSubStream(param0_this, (std::streamoff)param1, (std::streamoff)param2, (PyObject_IsTrue(param3) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OSubStream, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OSubStream() takes 0, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OSubStream()\n"
      "OSubStream(OStreamWrapper dest, long start, long end, bool append)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OSubStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OSubStream) {
    printf("OSubStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OSubStream *local_this = (OSubStream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OSubStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *)(std::ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *)(std::ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ostream) {
    return (std::ostream *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OSubStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OSubStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_std_ostream) {
    std::ostream* other_this = (std::ostream*)from_this;
    return (OSubStream*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SubStream
 */
/**
 * Python function wrapper for:
 * inline SubStream &SubStream::open(StreamWrapper *nested, std::streamoff start, std::streamoff end, bool append = false)
 */
static PyObject *Dtool_SubStream_open_455(PyObject *self, PyObject *args, PyObject *kwds) {
  SubStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SubStream, (void **)&local_this, "SubStream.open")) {
    return nullptr;
  }
  // 1-inline SubStream &SubStream::open(StreamWrapper *nested, std::streamoff start, std::streamoff end, bool append = false)
  PyObject *param1;
  PY_LONG_LONG param2;
  PY_LONG_LONG param3;
  PyObject *param4 = Py_False;
  static const char *keyword_list[] = {"nested", "start", "end", "append", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OLL|O:open", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    StreamWrapper *param1_this = (StreamWrapper *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_StreamWrapper, 1, "SubStream.open", false, true);
    if (param1_this != nullptr) {
      SubStream *return_value = &(((*local_this).open)(param1_this, (std::streamoff)param2, (std::streamoff)param3, (PyObject_IsTrue(param4) != 0)));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SubStream, false, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const SubStream self, StreamWrapper nested, long start, long end, bool append)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SubStream_open_455_comment =
  "C++ Interface:\n"
  "open(const SubStream self, StreamWrapper nested, long start, long end, bool append)\n"
  "\n"
  "/**\n"
  " * Starts the SubStream reading and writing from the indicated nested stream,\n"
  " * within the indicated range.  \"end\" is the first character outside of the\n"
  " * range.\n"
  " *\n"
  " * If end is zero, it indicates that the SubStream will continue until the end\n"
  " * of the nested stream.\n"
  " */";
#else
static const char *Dtool_SubStream_open_455_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SubStream &SubStream::close(void)
 */
static PyObject *Dtool_SubStream_close_456(PyObject *self, PyObject *) {
  SubStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SubStream, (void **)&local_this, "SubStream.close")) {
    return nullptr;
  }
  // 1-inline SubStream &SubStream::close(void)
  SubStream *return_value = &(((*local_this).close)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SubStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_SubStream_close_456_comment =
  "C++ Interface:\n"
  "close(const SubStream self)\n"
  "\n"
  "/**\n"
  " * Resets the SubStream to empty, but does not actually close the nested\n"
  " * ostream.\n"
  " */";
#else
static const char *Dtool_SubStream_close_456_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SubStream::SubStream(void)
 * inline explicit SubStream::SubStream(StreamWrapper *nested, std::streamoff start, std::streamoff end, bool append = false)
 */
static int Dtool_Init_SubStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline SubStream::SubStream(void)
      SubStream *return_value = new SubStream();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SubStream, true, false);
    }
    break;
  case 3:
  case 4:
    {
      // 1-inline explicit SubStream::SubStream(StreamWrapper *nested, std::streamoff start, std::streamoff end, bool append = false)
      PyObject *param0;
      PY_LONG_LONG param1;
      PY_LONG_LONG param2;
      PyObject *param3 = Py_False;
      static const char *keyword_list[] = {"nested", "start", "end", "append", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OLL|O:SubStream", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        StreamWrapper *param0_this = (StreamWrapper *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_StreamWrapper, 0, "SubStream.SubStream", false, true);
        if (param0_this != nullptr) {
          SubStream *return_value = new SubStream(param0_this, (std::streamoff)param1, (std::streamoff)param2, (PyObject_IsTrue(param3) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SubStream, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SubStream() takes 0, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SubStream()\n"
      "SubStream(StreamWrapper nested, long start, long end, bool append)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SubStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SubStream) {
    printf("SubStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SubStream *local_this = (SubStream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SubStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *)(std::istream *)(std::iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *)(std::istream *)(std::iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_iostream) {
    return (std::iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_istream) {
    return (std::istream *)(std::iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ostream) {
    return (std::ostream *)(std::iostream *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SubStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SubStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_std_iostream) {
    std::iostream* other_this = (std::iostream*)from_this;
    return (SubStream*)other_this;
  }
  if (from_type == Dtool_Ptr_std_istream) {
    std::istream* other_this = (std::istream*)from_this;
    return (SubStream*)other_this;
  }
  if (from_type == Dtool_Ptr_std_ostream) {
    std::ostream* other_this = (std::ostream*)from_this;
    return (SubStream*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Multifile
 */
/**
 * Python function wrapper for:
 * bool Multifile::open_read(Filename const &multifile_name, std::streamoff const &offset = 0)
 * bool Multifile::open_read(IStreamWrapper *multifile_stream, bool owns_pointer = false, std::streamoff const &offset = 0)
 */
static PyObject *Dtool_Multifile_open_read_460(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.open_read")) {
    return nullptr;
  }
  {
    // -2 bool Multifile::open_read(IStreamWrapper *multifile_stream, bool owns_pointer = false, std::streamoff const &offset = 0)
    PyObject *param1;
    PyObject *param2 = Py_False;
    PY_LONG_LONG param3 = 0;
    static const char *keyword_list[] = {"multifile_stream", "owns_pointer", "offset", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|OL:open_read", (char **)keyword_list, &param1, &param2, &param3)) {
      IStreamWrapper *param1_this = (IStreamWrapper *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_IStreamWrapper, 1, "Multifile.open_read", false, false);
      if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).open_read)(param1_this, (PyObject_IsTrue(param2) != 0), (std::streamoff const &)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool Multifile::open_read(IStreamWrapper *multifile_stream, bool owns_pointer = false, std::streamoff const &offset = 0)
  {
    // -2 bool Multifile::open_read(Filename const &multifile_name, std::streamoff const &offset = 0)
    PyObject *param1;
    PY_LONG_LONG param2 = 0;
    static const char *keyword_list[] = {"multifile_name", "offset", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|L:open_read", (char **)keyword_list, &param1, &param2)) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).open_read)(*param1_this, (std::streamoff const &)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read(const Multifile self, IStreamWrapper multifile_stream, bool owns_pointer, long offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_open_read_460_comment =
  "C++ Interface:\n"
  "open_read(const Multifile self, IStreamWrapper multifile_stream, bool owns_pointer, long offset)\n"
  "\n"
  "/**\n"
  " * Opens the named Multifile on disk for reading.  The Multifile index is read\n"
  " * in, and the list of subfiles becomes available; individual subfiles may\n"
  " * then be extracted or read, but the list of subfiles may not be modified.\n"
  " *\n"
  " * Also see the version of open_read() which accepts an istream.  Returns true\n"
  " * on success, false on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Opens an anonymous Multifile for reading using an istream.  There must be\n"
  " * seek functionality via seekg() and tellg() on the istream.\n"
  " *\n"
  " * If owns_pointer is true, then the Multifile assumes ownership of the stream\n"
  " * pointer and will delete it when the multifile is closed, including if this\n"
  " * function returns false.\n"
  " */";
#else
static const char *Dtool_Multifile_open_read_460_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::open_write(Filename const &multifile_name)
 * bool Multifile::open_write(std::ostream *multifile_stream, bool owns_pointer = false)
 */
static PyObject *Dtool_Multifile_open_write_461(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.open_write")) {
    return nullptr;
  }
  {
    // -2 bool Multifile::open_write(std::ostream *multifile_stream, bool owns_pointer = false)
    PyObject *param1;
    PyObject *param2 = Py_False;
    static const char *keyword_list[] = {"multifile_stream", "owns_pointer", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open_write", (char **)keyword_list, &param1, &param2)) {
      std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "Multifile.open_write", false, false);
      if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).open_write)(param1_this, (PyObject_IsTrue(param2) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool Multifile::open_write(std::ostream *multifile_stream, bool owns_pointer = false)
  {
    // -2 bool Multifile::open_write(Filename const &multifile_name)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "multifile_name")) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).open_write)(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_write(const Multifile self, ostream multifile_stream, bool owns_pointer)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_open_write_461_comment =
  "C++ Interface:\n"
  "open_write(const Multifile self, ostream multifile_stream, bool owns_pointer)\n"
  "\n"
  "/**\n"
  " * Opens the named Multifile on disk for writing.  If there already exists a\n"
  " * file by that name, it is truncated.  The Multifile is then prepared for\n"
  " * accepting a brand new set of subfiles, which will be written to the\n"
  " * indicated filename.  Individual subfiles may not be extracted or read.\n"
  " *\n"
  " * Also see the version of open_write() which accepts an ostream.  Returns\n"
  " * true on success, false on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Opens an anonymous Multifile for writing using an ostream.  There must be\n"
  " * seek functionality via seekp() and tellp() on the pstream.\n"
  " *\n"
  " * If owns_pointer is true, then the Multifile assumes ownership of the stream\n"
  " * pointer and will delete it when the multifile is closed, including if this\n"
  " * function returns false.\n"
  " */";
#else
static const char *Dtool_Multifile_open_write_461_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::open_read_write(Filename const &multifile_name)
 * bool Multifile::open_read_write(std::iostream *multifile_stream, bool owns_pointer = false)
 */
static PyObject *Dtool_Multifile_open_read_write_462(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.open_read_write")) {
    return nullptr;
  }
  {
    // -2 bool Multifile::open_read_write(std::iostream *multifile_stream, bool owns_pointer = false)
    PyObject *param1;
    PyObject *param2 = Py_False;
    static const char *keyword_list[] = {"multifile_stream", "owns_pointer", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open_read_write", (char **)keyword_list, &param1, &param2)) {
      std::iostream *param1_this = (std::iostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_iostream, 1, "Multifile.open_read_write", false, false);
      if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).open_read_write)(param1_this, (PyObject_IsTrue(param2) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: bool Multifile::open_read_write(std::iostream *multifile_stream, bool owns_pointer = false)
  {
    // -2 bool Multifile::open_read_write(Filename const &multifile_name)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "multifile_name")) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).open_read_write)(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_write(const Multifile self, iostream multifile_stream, bool owns_pointer)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_open_read_write_462_comment =
  "C++ Interface:\n"
  "open_read_write(const Multifile self, iostream multifile_stream, bool owns_pointer)\n"
  "\n"
  "/**\n"
  " * Opens the named Multifile on disk for reading and writing.  If there\n"
  " * already exists a file by that name, its index is read.  Subfiles may be\n"
  " * added or removed, and the resulting changes will be written to the named\n"
  " * file.\n"
  " *\n"
  " * Also see the version of open_read_write() which accepts an iostream.\n"
  " * Returns true on success, false on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Opens an anonymous Multifile for reading and writing using an iostream.\n"
  " * There must be seek functionality via seekg()/seekp() and tellg()/tellp() on\n"
  " * the iostream.\n"
  " *\n"
  " * If owns_pointer is true, then the Multifile assumes ownership of the stream\n"
  " * pointer and will delete it when the multifile is closed, including if this\n"
  " * function returns false.\n"
  " */";
#else
static const char *Dtool_Multifile_open_read_write_462_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Multifile::close(void)
 */
static PyObject *Dtool_Multifile_close_463(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.close")) {
    return nullptr;
  }
  // 1-void Multifile::close(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).close)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Multifile_close_463_comment =
  "C++ Interface:\n"
  "close(const Multifile self)\n"
  "\n"
  "/**\n"
  " * Closes the Multifile if it is open.  All changes are flushed to disk, and\n"
  " * the file becomes invalid for further operations until the next call to\n"
  " * open().\n"
  " */";
#else
static const char *Dtool_Multifile_close_463_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &Multifile::get_multifile_name(void) const
 */
static PyObject *Dtool_Multifile_get_multifile_name_464(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-inline Filename const &Multifile::get_multifile_name(void) const
  Filename const *return_value = &(((*(const Multifile*)local_this).get_multifile_name)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_multifile_name_464_comment =
  "C++ Interface:\n"
  "get_multifile_name(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the filename of the Multifile, if it is available.\n"
  " */";
#else
static const char *Dtool_Multifile_get_multifile_name_464_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Multifile::set_multifile_name(Filename const &multifile_name)
 */
static PyObject *Dtool_Multifile_set_multifile_name_465(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_multifile_name")) {
    return nullptr;
  }
  // 1-inline void Multifile::set_multifile_name(Filename const &multifile_name)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Multifile.set_multifile_name", "Filename");
  }
  ((*local_this).set_multifile_name)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_multifile_name(const Multifile self, const Filename multifile_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_multifile_name_465_comment =
  "C++ Interface:\n"
  "set_multifile_name(const Multifile self, const Filename multifile_name)\n"
  "\n"
  "/**\n"
  " * Replaces the filename of the Multifile.  This is primarily used for\n"
  " * documentation purposes only; changing this name does not open the indicated\n"
  " * file.  See open_read() or open_write() for that.\n"
  " */";
#else
static const char *Dtool_Multifile_set_multifile_name_465_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Multifile::is_read_valid(void) const
 */
static PyObject *Dtool_Multifile_is_read_valid_466(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-inline bool Multifile::is_read_valid(void) const
  bool return_value = ((*(const Multifile*)local_this).is_read_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_is_read_valid_466_comment =
  "C++ Interface:\n"
  "is_read_valid(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Multifile has been opened for read mode and there have\n"
  " * been no errors, and individual Subfile contents may be extracted.\n"
  " */";
#else
static const char *Dtool_Multifile_is_read_valid_466_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Multifile::is_write_valid(void) const
 */
static PyObject *Dtool_Multifile_is_write_valid_467(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-inline bool Multifile::is_write_valid(void) const
  bool return_value = ((*(const Multifile*)local_this).is_write_valid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_is_write_valid_467_comment =
  "C++ Interface:\n"
  "is_write_valid(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Multifile has been opened for write mode and there have\n"
  " * been no errors, and Subfiles may be added or removed from the Multifile.\n"
  " */";
#else
static const char *Dtool_Multifile_is_write_valid_467_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Multifile::needs_repack(void) const
 */
static PyObject *Dtool_Multifile_needs_repack_468(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-inline bool Multifile::needs_repack(void) const
  bool return_value = ((*(const Multifile*)local_this).needs_repack)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_needs_repack_468_comment =
  "C++ Interface:\n"
  "needs_repack(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Multifile index is suboptimal and should be repacked.\n"
  " * Call repack() to achieve this.\n"
  " */";
#else
static const char *Dtool_Multifile_needs_repack_468_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline time_t Multifile::get_timestamp(void) const
 */
static PyObject *Dtool_Multifile_get_timestamp_469(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-inline time_t Multifile::get_timestamp(void) const
  time_t return_value = ((*(const Multifile*)local_this).get_timestamp)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_timestamp_469_comment =
  "C++ Interface:\n"
  "get_timestamp(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the modification timestamp of the overall Multifile.  This\n"
  " * indicates the most recent date at which subfiles were added or removed from\n"
  " * the Multifile.  Note that it is logically possible for an individual\n"
  " * subfile to have a more recent timestamp than the overall timestamp.\n"
  " */";
#else
static const char *Dtool_Multifile_get_timestamp_469_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Multifile::set_record_timestamp(bool record_timestamp)
 */
static PyObject *Dtool_Multifile_set_record_timestamp_470(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_record_timestamp")) {
    return nullptr;
  }
  // 1-inline void Multifile::set_record_timestamp(bool record_timestamp)
  ((*local_this).set_record_timestamp)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_record_timestamp(const Multifile self, bool record_timestamp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_record_timestamp_470_comment =
  "C++ Interface:\n"
  "set_record_timestamp(const Multifile self, bool record_timestamp)\n"
  "\n"
  "/**\n"
  " * Sets the flag indicating whether timestamps should be recorded within the\n"
  " * Multifile or not.  The default is true, indicating the Multifile will\n"
  " * record timestamps for the overall file and also for each subfile.\n"
  " *\n"
  " * If this is false, the Multifile will not record timestamps internally.  In\n"
  " * this case, the return value from get_timestamp() or get_subfile_timestamp()\n"
  " * will be estimations.\n"
  " *\n"
  " * You may want to set this false to minimize the bitwise difference between\n"
  " * independently-generated Multifiles.\n"
  " */";
#else
static const char *Dtool_Multifile_set_record_timestamp_470_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Multifile::get_record_timestamp(void) const
 */
static PyObject *Dtool_Multifile_get_record_timestamp_471(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-inline bool Multifile::get_record_timestamp(void) const
  bool return_value = ((*(const Multifile*)local_this).get_record_timestamp)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_record_timestamp_471_comment =
  "C++ Interface:\n"
  "get_record_timestamp(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the flag indicating whether timestamps should be recorded within\n"
  " * the Multifile or not.  See set_record_timestamp().\n"
  " */";
#else
static const char *Dtool_Multifile_get_record_timestamp_471_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Multifile::set_scale_factor(std::size_t scale_factor)
 */
static PyObject *Dtool_Multifile_set_scale_factor_472(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_scale_factor")) {
    return nullptr;
  }
  // 1-void Multifile::set_scale_factor(std::size_t scale_factor)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).set_scale_factor)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_scale_factor(const Multifile self, int scale_factor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_scale_factor_472_comment =
  "C++ Interface:\n"
  "set_scale_factor(const Multifile self, int scale_factor)\n"
  "\n"
  "/**\n"
  " * Changes the internal scale factor for this Multifile.\n"
  " *\n"
  " * This is normally 1, but it may be set to any arbitrary value (greater than\n"
  " * zero) to support Multifile archives that exceed 4GB, if necessary.\n"
  " * (Individual subfiles may still not exceed 4GB.)\n"
  " *\n"
  " * All addresses within the file are rounded up to the next multiple of\n"
  " * _scale_factor, and zeros are written to the file to fill the resulting\n"
  " * gaps.  Then the address is divided by _scale_factor and written out as a\n"
  " * 32-bit integer.  Thus, setting a scale factor of 2 supports up to 8GB\n"
  " * files, 3 supports 12GB files, etc.\n"
  " *\n"
  " * Calling this function on an already-existing Multifile will have no\n"
  " * immediate effect until a future call to repack() or close() (or until the\n"
  " * Multifile is destructed).\n"
  " */";
#else
static const char *Dtool_Multifile_set_scale_factor_472_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t Multifile::get_scale_factor(void) const
 */
static PyObject *Dtool_Multifile_get_scale_factor_473(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-inline std::size_t Multifile::get_scale_factor(void) const
  std::size_t return_value = ((*(const Multifile*)local_this).get_scale_factor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_scale_factor_473_comment =
  "C++ Interface:\n"
  "get_scale_factor(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the internal scale factor for this Multifile.  See\n"
  " * set_scale_factor().\n"
  " */";
#else
static const char *Dtool_Multifile_get_scale_factor_473_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Multifile::set_encryption_flag(bool flag)
 */
static PyObject *Dtool_Multifile_set_encryption_flag_474(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_encryption_flag")) {
    return nullptr;
  }
  // 1-inline void Multifile::set_encryption_flag(bool flag)
  ((*local_this).set_encryption_flag)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_encryption_flag(const Multifile self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_encryption_flag_474_comment =
  "C++ Interface:\n"
  "set_encryption_flag(const Multifile self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets the flag indicating whether subsequently-added subfiles should be\n"
  " * encrypted before writing them to the multifile.  If true, subfiles will be\n"
  " * encrypted; if false (the default), they will be written without encryption.\n"
  " *\n"
  " * When true, subfiles will be encrypted with the password specified by\n"
  " * set_encryption_password().  It is possible to apply a different password to\n"
  " * different files, but the resulting file can't be mounted via VFS.\n"
  " */";
#else
static const char *Dtool_Multifile_set_encryption_flag_474_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Multifile::get_encryption_flag(void) const
 */
static PyObject *Dtool_Multifile_get_encryption_flag_475(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-inline bool Multifile::get_encryption_flag(void) const
  bool return_value = ((*(const Multifile*)local_this).get_encryption_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_encryption_flag_475_comment =
  "C++ Interface:\n"
  "get_encryption_flag(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the flag indicating whether subsequently-added subfiles should be\n"
  " * encrypted before writing them to the multifile.  See set_encryption_flag().\n"
  " */";
#else
static const char *Dtool_Multifile_get_encryption_flag_475_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Multifile::set_encryption_password(std::string const &encryption_password)
 */
static PyObject *Dtool_Multifile_set_encryption_password_476(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_encryption_password")) {
    return nullptr;
  }
  // 1-inline void Multifile::set_encryption_password(std::string const &encryption_password)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_encryption_password)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_encryption_password(const Multifile self, str encryption_password)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_encryption_password_476_comment =
  "C++ Interface:\n"
  "set_encryption_password(const Multifile self, str encryption_password)\n"
  "\n"
  "/**\n"
  " * Specifies the password that will be used to encrypt subfiles subsequently\n"
  " * added to the multifile, if the encryption flag is also set true (see\n"
  " * set_encryption_flag()).\n"
  " *\n"
  " * It is possible to apply a different password to different files, but the\n"
  " * resulting file can't be mounted via VFS.  Changing this value may cause an\n"
  " * implicit call to flush().\n"
  " */";
#else
static const char *Dtool_Multifile_set_encryption_password_476_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Multifile::get_encryption_password(void) const
 */
static PyObject *Dtool_Multifile_get_encryption_password_477(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-inline std::string const &Multifile::get_encryption_password(void) const
  std::string const &return_value = ((*(const Multifile*)local_this).get_encryption_password)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_encryption_password_477_comment =
  "C++ Interface:\n"
  "get_encryption_password(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the password that will be used to encrypt subfiles subsequently\n"
  " * added to the multifile.  See set_encryption_password().\n"
  " */";
#else
static const char *Dtool_Multifile_get_encryption_password_477_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Multifile::set_encryption_algorithm(std::string const &encryption_algorithm)
 */
static PyObject *Dtool_Multifile_set_encryption_algorithm_478(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_encryption_algorithm")) {
    return nullptr;
  }
  // 1-inline void Multifile::set_encryption_algorithm(std::string const &encryption_algorithm)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_encryption_algorithm)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_encryption_algorithm(const Multifile self, str encryption_algorithm)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_encryption_algorithm_478_comment =
  "C++ Interface:\n"
  "set_encryption_algorithm(const Multifile self, str encryption_algorithm)\n"
  "\n"
  "/**\n"
  " * Specifies the encryption algorithm that should be used for future calls to\n"
  " * add_subfile().  The default is whatever is specified by the encryption-\n"
  " * algorithm config variable.  The complete set of available algorithms is\n"
  " * defined by the current version of OpenSSL.\n"
  " *\n"
  " * If an invalid algorithm is specified, there is no immediate error return\n"
  " * code, but flush() will fail and the file will be invalid.\n"
  " *\n"
  " * It is possible to apply a different encryption algorithm to different\n"
  " * files, and unlike the password, this does not interfere with mounting the\n"
  " * multifile via VFS.  Changing this value may cause an implicit call to\n"
  " * flush().\n"
  " */";
#else
static const char *Dtool_Multifile_set_encryption_algorithm_478_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Multifile::get_encryption_algorithm(void) const
 */
static PyObject *Dtool_Multifile_get_encryption_algorithm_479(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-inline std::string const &Multifile::get_encryption_algorithm(void) const
  std::string const &return_value = ((*(const Multifile*)local_this).get_encryption_algorithm)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_encryption_algorithm_479_comment =
  "C++ Interface:\n"
  "get_encryption_algorithm(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the encryption algorithm that was specified by\n"
  " * set_encryption_algorithm().\n"
  " */";
#else
static const char *Dtool_Multifile_get_encryption_algorithm_479_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Multifile::set_encryption_key_length(int encryption_key_length)
 */
static PyObject *Dtool_Multifile_set_encryption_key_length_480(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_encryption_key_length")) {
    return nullptr;
  }
  // 1-inline void Multifile::set_encryption_key_length(int encryption_key_length)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_encryption_key_length)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_encryption_key_length(const Multifile self, int encryption_key_length)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_encryption_key_length_480_comment =
  "C++ Interface:\n"
  "set_encryption_key_length(const Multifile self, int encryption_key_length)\n"
  "\n"
  "/**\n"
  " * Specifies the length of the key, in bits, that should be used to encrypt\n"
  " * the stream in future calls to add_subfile().  The default is whatever is\n"
  " * specified by the encryption-key-length config variable.\n"
  " *\n"
  " * If an invalid key_length for the chosen algorithm is specified, there is no\n"
  " * immediate error return code, but flush() will fail and the file will be\n"
  " * invalid.\n"
  " *\n"
  " * It is possible to apply a different key length to different files, and\n"
  " * unlike the password, this does not interfere with mounting the multifile\n"
  " * via VFS. Changing this value may cause an implicit call to flush().\n"
  " */";
#else
static const char *Dtool_Multifile_set_encryption_key_length_480_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Multifile::get_encryption_key_length(void) const
 */
static PyObject *Dtool_Multifile_get_encryption_key_length_481(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-inline int Multifile::get_encryption_key_length(void) const
  int return_value = ((*(const Multifile*)local_this).get_encryption_key_length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_encryption_key_length_481_comment =
  "C++ Interface:\n"
  "get_encryption_key_length(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the encryption key length, in bits, that was specified by\n"
  " * set_encryption_key_length().\n"
  " */";
#else
static const char *Dtool_Multifile_get_encryption_key_length_481_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Multifile::set_encryption_iteration_count(int encryption_iteration_count)
 */
static PyObject *Dtool_Multifile_set_encryption_iteration_count_482(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_encryption_iteration_count")) {
    return nullptr;
  }
  // 1-inline void Multifile::set_encryption_iteration_count(int encryption_iteration_count)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_encryption_iteration_count)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_encryption_iteration_count(const Multifile self, int encryption_iteration_count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_encryption_iteration_count_482_comment =
  "C++ Interface:\n"
  "set_encryption_iteration_count(const Multifile self, int encryption_iteration_count)\n"
  "\n"
  "/**\n"
  " * Specifies the number of times to repeatedly hash the key before writing it\n"
  " * to the stream in future calls to add_subfile().  Its purpose is to make it\n"
  " * computationally more expensive for an attacker to search the key space\n"
  " * exhaustively.  This should be a multiple of 1,000 and should not exceed\n"
  " * about 65 million; the value 0 indicates just one application of the hashing\n"
  " * algorithm.\n"
  " *\n"
  " * The default is whatever is specified by the multifile-encryption-iteration-\n"
  " * count config variable.\n"
  " *\n"
  " * It is possible to apply a different iteration count to different files, and\n"
  " * unlike the password, this does not interfere with mounting the multifile\n"
  " * via VFS.  Changing this value causes an implicit call to flush().\n"
  " */";
#else
static const char *Dtool_Multifile_set_encryption_iteration_count_482_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Multifile::get_encryption_iteration_count(void) const
 */
static PyObject *Dtool_Multifile_get_encryption_iteration_count_483(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-inline int Multifile::get_encryption_iteration_count(void) const
  int return_value = ((*(const Multifile*)local_this).get_encryption_iteration_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_encryption_iteration_count_483_comment =
  "C++ Interface:\n"
  "get_encryption_iteration_count(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the value that was specified by set_encryption_iteration_count().\n"
  " */";
#else
static const char *Dtool_Multifile_get_encryption_iteration_count_483_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string Multifile::add_subfile(std::string const &subfile_name, Filename const &filename, int compression_level)
 * std::string Multifile::add_subfile(std::string const &subfile_name, std::istream *subfile_data, int compression_level)
 */
static PyObject *Dtool_Multifile_add_subfile_484(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.add_subfile")) {
    return nullptr;
  }
  {
    // -2 std::string Multifile::add_subfile(std::string const &subfile_name, Filename const &filename, int compression_level)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    PyObject *param2;
    int param3;
    static const char *keyword_list[] = {"subfile_name", "filename", "compression_level", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Oi:add_subfile", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
      Filename const *param2_this = nullptr;
      DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_Filename);
      if (param2_this != nullptr) {
        std::string return_value = ((*local_this).add_subfile)(std::string(param1_str, param1_len), *param2_this, (int)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 std::string Multifile::add_subfile(std::string const &subfile_name, std::istream *subfile_data, int compression_level)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    PyObject *param2;
    int param3;
    static const char *keyword_list[] = {"subfile_name", "subfile_data", "compression_level", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Oi:add_subfile", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
      std::istream *param2_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_std_istream, 2, "Multifile.add_subfile", false, false);
      if (param2_this != nullptr) {
        std::string return_value = ((*local_this).add_subfile)(std::string(param1_str, param1_len), param2_this, (int)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 std::string Multifile::add_subfile(std::string const &subfile_name, Filename const &filename, int compression_level)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
    PyObject *param2;
    int param3;
    static const char *keyword_list[] = {"subfile_name", "filename", "compression_level", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Oi:add_subfile", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
      Filename param2_local;
      Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
      if ((param2_this != nullptr)) {
        std::string return_value = ((*local_this).add_subfile)(std::string(param1_str, param1_len), *param2_this, (int)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: std::string Multifile::add_subfile(std::string const &subfile_name, std::istream *subfile_data, int compression_level)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_subfile(const Multifile self, str subfile_name, const Filename filename, int compression_level)\n"
      "add_subfile(const Multifile self, str subfile_name, istream subfile_data, int compression_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_add_subfile_484_comment =
  "C++ Interface:\n"
  "add_subfile(const Multifile self, str subfile_name, const Filename filename, int compression_level)\n"
  "add_subfile(const Multifile self, str subfile_name, istream subfile_data, int compression_level)\n"
  "\n"
  "/**\n"
  " * Adds a file on disk as a subfile to the Multifile.  The file named by\n"
  " * filename will be read and added to the Multifile at the next call to\n"
  " * flush().  If there already exists a subfile with the indicated name, it is\n"
  " * replaced without examining its contents (but see also update_subfile).\n"
  " *\n"
  " * Either Filename:::set_binary() or set_text() must have been called\n"
  " * previously to specify the nature of the source file.  If set_text() was\n"
  " * called, the text flag will be set on the subfile.\n"
  " *\n"
  " * Returns the subfile name on success (it might have been modified slightly),\n"
  " * or empty string on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a file from a stream as a subfile to the Multifile.  The indicated\n"
  " * istream will be read and its contents added to the Multifile at the next\n"
  " * call to flush(). The file will be added as a binary subfile.\n"
  " *\n"
  " * Note that the istream must remain untouched and unused by any other code\n"
  " * until flush() is called.  At that time, the Multifile will read the entire\n"
  " * contents of the istream from the current file position to the end of the\n"
  " * file.  Subsequently, the Multifile will *not* close or delete the istream.\n"
  " * It is the caller's responsibility to ensure that the istream pointer does\n"
  " * not destruct during the lifetime of the Multifile.\n"
  " *\n"
  " * Returns the subfile name on success (it might have been modified slightly),\n"
  " * or empty string on failure.\n"
  " */";
#else
static const char *Dtool_Multifile_add_subfile_484_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string Multifile::update_subfile(std::string const &subfile_name, Filename const &filename, int compression_level)
 */
static PyObject *Dtool_Multifile_update_subfile_485(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.update_subfile")) {
    return nullptr;
  }
  // 1-std::string Multifile::update_subfile(std::string const &subfile_name, Filename const &filename, int compression_level)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  int param3;
  static const char *keyword_list[] = {"subfile_name", "filename", "compression_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Oi:update_subfile", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Multifile.update_subfile", "Filename");
    }
    std::string return_value = ((*local_this).update_subfile)(std::string(param1_str, param1_len), *param2_this, (int)param3);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "update_subfile(const Multifile self, str subfile_name, const Filename filename, int compression_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_update_subfile_485_comment =
  "C++ Interface:\n"
  "update_subfile(const Multifile self, str subfile_name, const Filename filename, int compression_level)\n"
  "\n"
  "/**\n"
  " * Adds a file on disk to the subfile.  If a subfile already exists with the\n"
  " * same name, its contents are compared byte-for-byte to the disk file, and it\n"
  " * is replaced only if it is different; otherwise, the multifile is left\n"
  " * unchanged.\n"
  " *\n"
  " * Either Filename:::set_binary() or set_text() must have been called\n"
  " * previously to specify the nature of the source file.  If set_text() was\n"
  " * called, the text flag will be set on the subfile.\n"
  " */";
#else
static const char *Dtool_Multifile_update_subfile_485_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::add_signature(Filename const &certificate, Filename const &chain, Filename const &pkey, std::string const &password = "")
 * bool Multifile::add_signature(Filename const &composite, std::string const &password = "")
 */
static PyObject *Dtool_Multifile_add_signature_486(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.add_signature")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "composite")) {
        // 1-bool Multifile::add_signature(Filename const &composite, std::string const &password)
        Filename arg_local;
        Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "Multifile.add_signature", "Filename");
        }
        bool return_value = ((*local_this).add_signature)(*arg_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 2:
    {
      // 1-bool Multifile::add_signature(Filename const &composite, std::string const &password)
      PyObject *param1;
      const char *param2_str = nullptr;
      Py_ssize_t param2_len;
      static const char *keyword_list[] = {"composite", "password", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:add_signature", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Multifile.add_signature", "Filename");
        }
        bool return_value = ((*local_this).add_signature)(*param1_this, std::string(param2_str, param2_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
  case 4:
    {
      // 1-bool Multifile::add_signature(Filename const &certificate, Filename const &chain, Filename const &pkey, std::string const &password = "")
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      const char *param4_str = "";
      Py_ssize_t param4_len = 0;
      static const char *keyword_list[] = {"certificate", "chain", "pkey", "password", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|s#:add_signature", (char **)keyword_list, &param1, &param2, &param3, &param4_str, &param4_len)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Multifile.add_signature", "Filename");
        }
        Filename param2_local;
        Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "Multifile.add_signature", "Filename");
        }
        Filename param3_local;
        Filename const *param3_this = Dtool_Coerce_Filename(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "Multifile.add_signature", "Filename");
        }
        bool return_value = ((*local_this).add_signature)(*param1_this, *param2_this, *param3_this, std::string(param4_str, param4_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_signature() takes 2, 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_signature(const Multifile self, const Filename composite)\n"
      "add_signature(const Multifile self, const Filename composite, str password)\n"
      "add_signature(const Multifile self, const Filename certificate, const Filename chain, const Filename pkey, str password)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_add_signature_486_comment =
  "C++ Interface:\n"
  "add_signature(const Multifile self, const Filename composite)\n"
  "add_signature(const Multifile self, const Filename composite, str password)\n"
  "add_signature(const Multifile self, const Filename certificate, const Filename chain, const Filename pkey, str password)\n"
  "\n"
  "/**\n"
  " * Adds a new signature to the Multifile.  This signature associates the\n"
  " * indicated certificate with the current contents of the Multifile.  When the\n"
  " * Multifile is read later, the signature will still be present only if the\n"
  " * Multifile is unchanged; any subsequent changes to the Multifile will\n"
  " * automatically invalidate and remove the signature.\n"
  " *\n"
  " * The chain filename may be empty if the certificate does not require an\n"
  " * authenticating certificate chain (e.g.  because it is self-signed).\n"
  " *\n"
  " * The specified private key must match the certificate, and the Multifile\n"
  " * must be open in read-write mode.  The private key is only used for\n"
  " * generating the signature; it is not written to the Multifile and cannot be\n"
  " * retrieved from the Multifile later.  (However, the certificate *can* be\n"
  " * retrieved from the Multifile later, to identify the entity that created the\n"
  " * signature.)\n"
  " *\n"
  " * This implicitly causes a repack() operation if one is needed.  Returns true\n"
  " * on success, false on failure.\n"
  " *\n"
  " * This flavor of add_signature() reads the certificate and private key from a\n"
  " * PEM-formatted file, for instance as generated by the openssl command.  If\n"
  " * the private key file is password-encrypted, the third parameter will be\n"
  " * used as the password to decrypt it.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new signature to the Multifile.  This signature associates the\n"
  " * indicated certificate with the current contents of the Multifile.  When the\n"
  " * Multifile is read later, the signature will still be present only if the\n"
  " * Multifile is unchanged; any subsequent changes to the Multifile will\n"
  " * automatically invalidate and remove the signature.\n"
  " *\n"
  " * This flavor of add_signature() reads the certificate, private key, and\n"
  " * certificate chain from the same PEM-formatted file.  It takes the first\n"
  " * private key found as the intended key, and then uses the first certificate\n"
  " * found that matches that key as the signing certificate.  Any other\n"
  " * certificates in the file are taken to be part of the chain.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds a new signature to the Multifile.  This signature associates the\n"
  " * indicated certificate with the current contents of the Multifile.  When the\n"
  " * Multifile is read later, the signature will still be present only if the\n"
  " * Multifile is unchanged; any subsequent changes to the Multifile will\n"
  " * automatically invalidate and remove the signature.\n"
  " *\n"
  " * The signature certificate is the first certificate on the CertChain object.\n"
  " * Any remaining certificates are support certificates to authenticate the\n"
  " * first one.\n"
  " *\n"
  " * The specified private key must match the certificate, and the Multifile\n"
  " * must be open in read-write mode.  The private key is only used for\n"
  " * generating the signature; it is not written to the Multifile and cannot be\n"
  " * retrieved from the Multifile later.  (However, the certificate *can* be\n"
  " * retrieved from the Multifile later, to identify the entity that created the\n"
  " * signature.)\n"
  " *\n"
  " * This implicitly causes a repack() operation if one is needed.  Returns true\n"
  " * on success, false on failure.\n"
  " */";
#else
static const char *Dtool_Multifile_add_signature_486_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Multifile::get_num_signatures(void) const
 */
static PyObject *Dtool_Multifile_get_num_signatures_487(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-int Multifile::get_num_signatures(void) const
  int return_value = ((*(const Multifile*)local_this).get_num_signatures)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_num_signatures_487_comment =
  "C++ Interface:\n"
  "get_num_signatures(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the number of matching signatures found on the Multifile.  These\n"
  " * signatures may be iterated via get_signature() and related methods.\n"
  " *\n"
  " * A signature on this list is guaranteed to match the Multifile contents,\n"
  " * proving that the Multifile has been unmodified since the signature was\n"
  " * applied.  However, this does not guarantee that the certificate itself is\n"
  " * actually from who it says it is from; only that it matches the Multifile\n"
  " * contents.  See validate_signature_certificate() to authenticate a\n"
  " * particular certificate.\n"
  " */";
#else
static const char *Dtool_Multifile_get_num_signatures_487_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string Multifile::get_signature_subject_name(int n) const
 */
static PyObject *Dtool_Multifile_get_signature_subject_name_488(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-std::string Multifile::get_signature_subject_name(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const Multifile*)local_this).get_signature_subject_name)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_signature_subject_name(Multifile self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_signature_subject_name_488_comment =
  "C++ Interface:\n"
  "get_signature_subject_name(Multifile self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the \"subject name\" for the nth signature found on the Multifile.\n"
  " * This is a string formatted according to RFC2253 that should more-or-less\n"
  " * identify a particular certificate; when paired with the public key (see\n"
  " * get_signature_public_key()), it can uniquely identify a certificate.  See\n"
  " * the comments in get_num_signatures().\n"
  " */";
#else
static const char *Dtool_Multifile_get_signature_subject_name_488_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string Multifile::get_signature_friendly_name(int n) const
 */
static PyObject *Dtool_Multifile_get_signature_friendly_name_489(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-std::string Multifile::get_signature_friendly_name(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const Multifile*)local_this).get_signature_friendly_name)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_signature_friendly_name(Multifile self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_signature_friendly_name_489_comment =
  "C++ Interface:\n"
  "get_signature_friendly_name(Multifile self, int n)\n"
  "\n"
  "/**\n"
  " * Returns a \"friendly name\" for the nth signature found on the Multifile.\n"
  " * This attempts to extract out the most meaningful part of the subject name.\n"
  " * It returns the emailAddress, if it is defined; otherwise, it returns the\n"
  " * commonName.\n"
  " *\n"
  " * See the comments in get_num_signatures().\n"
  " */";
#else
static const char *Dtool_Multifile_get_signature_friendly_name_489_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string Multifile::get_signature_public_key(int n) const
 */
static PyObject *Dtool_Multifile_get_signature_public_key_490(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-std::string Multifile::get_signature_public_key(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const Multifile*)local_this).get_signature_public_key)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_signature_public_key(Multifile self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_signature_public_key_490_comment =
  "C++ Interface:\n"
  "get_signature_public_key(Multifile self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the public key used for the nth signature found on the Multifile.\n"
  " * This is encoded in DER form and returned as a string of hex digits.\n"
  " *\n"
  " * This can be used, in conjunction with the subject name (see\n"
  " * get_signature_subject_name()), to uniquely identify a particular\n"
  " * certificate and its subsequent reissues.  See the comments in\n"
  " * get_num_signatures().\n"
  " */";
#else
static const char *Dtool_Multifile_get_signature_public_key_490_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Multifile::print_signature_certificate(int n, std::ostream &out) const
 */
static PyObject *Dtool_Multifile_print_signature_certificate_491(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-void Multifile::print_signature_certificate(int n, std::ostream &out) const
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "out", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:print_signature_certificate", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param2_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_std_ostream, 2, "Multifile.print_signature_certificate", false, true);
    if (param2_this != nullptr) {
      ((*(const Multifile*)local_this).print_signature_certificate)((int)param1, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "print_signature_certificate(Multifile self, int n, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_print_signature_certificate_491_comment =
  "C++ Interface:\n"
  "print_signature_certificate(Multifile self, int n, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes the certificate for the nth signature, in user-readable verbose\n"
  " * form, to the indicated stream.  See the comments in get_num_signatures().\n"
  " */";
#else
static const char *Dtool_Multifile_print_signature_certificate_491_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Multifile::write_signature_certificate(int n, std::ostream &out) const
 */
static PyObject *Dtool_Multifile_write_signature_certificate_492(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-void Multifile::write_signature_certificate(int n, std::ostream &out) const
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"n", "out", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:write_signature_certificate", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param2_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_std_ostream, 2, "Multifile.write_signature_certificate", false, true);
    if (param2_this != nullptr) {
      ((*(const Multifile*)local_this).write_signature_certificate)((int)param1, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_signature_certificate(Multifile self, int n, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_write_signature_certificate_492_comment =
  "C++ Interface:\n"
  "write_signature_certificate(Multifile self, int n, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes the certificate for the nth signature, in PEM form, to the indicated\n"
  " * stream.  See the comments in get_num_signatures().\n"
  " */";
#else
static const char *Dtool_Multifile_write_signature_certificate_492_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Multifile::validate_signature_certificate(int n) const
 */
static PyObject *Dtool_Multifile_validate_signature_certificate_493(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-int Multifile::validate_signature_certificate(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const Multifile*)local_this).validate_signature_certificate)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "validate_signature_certificate(Multifile self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_validate_signature_certificate_493_comment =
  "C++ Interface:\n"
  "validate_signature_certificate(Multifile self, int n)\n"
  "\n"
  "/**\n"
  " * Checks that the certificate used for the nth signature is a valid,\n"
  " * authorized certificate with some known certificate authority.  Returns 0 if\n"
  " * it is valid, -1 if there is some error, or the corresponding OpenSSL error\n"
  " * code if it is invalid, out-of-date, or self-signed.\n"
  " */";
#else
static const char *Dtool_Multifile_validate_signature_certificate_493_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::flush(void)
 */
static PyObject *Dtool_Multifile_flush_494(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.flush")) {
    return nullptr;
  }
  // 1-bool Multifile::flush(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).flush)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_flush_494_comment =
  "C++ Interface:\n"
  "flush(const Multifile self)\n"
  "\n"
  "/**\n"
  " * Writes all contents of the Multifile to disk.  Until flush() is called,\n"
  " * add_subfile() and remove_subfile() do not actually do anything to disk.  At\n"
  " * this point, all of the recently-added subfiles are read and their contents\n"
  " * are added to the end of the Multifile, and the recently-removed subfiles\n"
  " * are marked gone from the Multifile.\n"
  " *\n"
  " * This may result in a suboptimal index.  To guarantee that the index is\n"
  " * written at the beginning of the file, call repack() instead of flush().\n"
  " *\n"
  " * It is not necessary to call flush() explicitly unless you are concerned\n"
  " * about reading the recently-added subfiles immediately.\n"
  " *\n"
  " * Returns true on success, false on failure.\n"
  " */";
#else
static const char *Dtool_Multifile_flush_494_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::repack(void)
 */
static PyObject *Dtool_Multifile_repack_495(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.repack")) {
    return nullptr;
  }
  // 1-bool Multifile::repack(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).repack)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_repack_495_comment =
  "C++ Interface:\n"
  "repack(const Multifile self)\n"
  "\n"
  "/**\n"
  " * Forces a complete rewrite of the Multifile and all of its contents, so that\n"
  " * its index will appear at the beginning of the file with all of the subfiles\n"
  " * listed in alphabetical order.  This is considered optimal for reading, and\n"
  " * is the standard configuration; but it is not essential to do this.\n"
  " *\n"
  " * It is only valid to call this if the Multifile was opened using\n"
  " * open_read_write() and an explicit filename, rather than an iostream.  Also,\n"
  " * we must have write permission to the directory containing the Multifile.\n"
  " *\n"
  " * Returns true on success, false on failure.\n"
  " */";
#else
static const char *Dtool_Multifile_repack_495_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Multifile::get_num_subfiles(void) const
 */
static PyObject *Dtool_Multifile_get_num_subfiles_496(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-int Multifile::get_num_subfiles(void) const
  int return_value = ((*(const Multifile*)local_this).get_num_subfiles)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_num_subfiles_496_comment =
  "C++ Interface:\n"
  "get_num_subfiles(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the number of subfiles within the Multifile.  The subfiles may be\n"
  " * accessed in alphabetical order by iterating through [0 ..\n"
  " * get_num_subfiles()).\n"
  " */";
#else
static const char *Dtool_Multifile_get_num_subfiles_496_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Multifile::find_subfile(std::string const &subfile_name) const
 */
static PyObject *Dtool_Multifile_find_subfile_497(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-int Multifile::find_subfile(std::string const &subfile_name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    int return_value = ((*(const Multifile*)local_this).find_subfile)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_subfile(Multifile self, str subfile_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_find_subfile_497_comment =
  "C++ Interface:\n"
  "find_subfile(Multifile self, str subfile_name)\n"
  "\n"
  "/**\n"
  " * Returns the index of the subfile with the indicated name, or -1 if the\n"
  " * named subfile is not within the Multifile.\n"
  " */";
#else
static const char *Dtool_Multifile_find_subfile_497_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::has_directory(std::string const &subfile_name) const
 */
static PyObject *Dtool_Multifile_has_directory_498(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-bool Multifile::has_directory(std::string const &subfile_name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const Multifile*)local_this).has_directory)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_directory(Multifile self, str subfile_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_has_directory_498_comment =
  "C++ Interface:\n"
  "has_directory(Multifile self, str subfile_name)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated subfile name is the directory prefix to one\n"
  " * or more files within the Multifile.  That is, the Multifile contains at\n"
  " * least one file named \"subfile_name/...\".\n"
  " */";
#else
static const char *Dtool_Multifile_has_directory_498_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Multifile::remove_subfile(int index)
 * inline bool Multifile::remove_subfile(std::string const &subfile_name)
 */
static PyObject *Dtool_Multifile_remove_subfile_500(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.remove_subfile")) {
    return nullptr;
  }
  {
    // -2 inline bool Multifile::remove_subfile(std::string const &subfile_name)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      bool return_value = ((*local_this).remove_subfile)(std::string(param1_str, param1_len));
      return Dtool_Return_Bool(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 void Multifile::remove_subfile(int index)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      ((*local_this).remove_subfile)((int)arg_val);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: inline bool Multifile::remove_subfile(std::string const &subfile_name)
  // No coercion possible: void Multifile::remove_subfile(int index)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_subfile(const Multifile self, str subfile_name)\n"
      "remove_subfile(const Multifile self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_remove_subfile_500_comment =
  "C++ Interface:\n"
  "remove_subfile(const Multifile self, str subfile_name)\n"
  "remove_subfile(const Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Removes the named subfile from the Multifile, if it exists; returns true if\n"
  " * successfully removed, or false if it did not exist in the first place.  The\n"
  " * file will not actually be removed from the disk until the next call to\n"
  " * flush().\n"
  " *\n"
  " * Note that this does not actually remove the data from the indicated\n"
  " * subfile; it simply removes it from the index.  The Multifile will not be\n"
  " * reduced in size after this operation, until the next call to repack().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Removes the nth subfile from the Multifile.  This will cause all subsequent\n"
  " * index numbers to decrease by one.  The file will not actually be removed\n"
  " * from the disk until the next call to flush().\n"
  " *\n"
  " * Note that this does not actually remove the data from the indicated\n"
  " * subfile; it simply removes it from the index.  The Multifile will not be\n"
  " * reduced in size after this operation, until the next call to repack().\n"
  " */";
#else
static const char *Dtool_Multifile_remove_subfile_500_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string const &Multifile::get_subfile_name(int index) const
 */
static PyObject *Dtool_Multifile_get_subfile_name_501(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-std::string const &Multifile::get_subfile_name(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string const &return_value = ((*(const Multifile*)local_this).get_subfile_name)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subfile_name(Multifile self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_subfile_name_501_comment =
  "C++ Interface:\n"
  "get_subfile_name(Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the name of the nth subfile.\n"
  " */";
#else
static const char *Dtool_Multifile_get_subfile_name_501_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t Multifile::get_subfile_length(int index) const
 */
static PyObject *Dtool_Multifile_get_subfile_length_503(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-std::size_t Multifile::get_subfile_length(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::size_t return_value = ((*(const Multifile*)local_this).get_subfile_length)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subfile_length(Multifile self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_subfile_length_503_comment =
  "C++ Interface:\n"
  "get_subfile_length(Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the uncompressed data length of the nth subfile.  This might return\n"
  " * 0 if the subfile has recently been added and flush() has not yet been\n"
  " * called.\n"
  " */";
#else
static const char *Dtool_Multifile_get_subfile_length_503_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * time_t Multifile::get_subfile_timestamp(int index) const
 */
static PyObject *Dtool_Multifile_get_subfile_timestamp_504(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-time_t Multifile::get_subfile_timestamp(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    time_t return_value = ((*(const Multifile*)local_this).get_subfile_timestamp)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subfile_timestamp(Multifile self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_subfile_timestamp_504_comment =
  "C++ Interface:\n"
  "get_subfile_timestamp(Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the modification time of the nth subfile.  If this is called on an\n"
  " * older .mf file, which did not store individual timestamps in the file (or\n"
  " * if get_record_timestamp() is false), this will return the modification time\n"
  " * of the overall multifile.\n"
  " */";
#else
static const char *Dtool_Multifile_get_subfile_timestamp_504_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::is_subfile_compressed(int index) const
 */
static PyObject *Dtool_Multifile_is_subfile_compressed_505(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-bool Multifile::is_subfile_compressed(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const Multifile*)local_this).is_subfile_compressed)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_subfile_compressed(Multifile self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_is_subfile_compressed_505_comment =
  "C++ Interface:\n"
  "is_subfile_compressed(Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated subfile has been compressed when stored\n"
  " * within the archive, false otherwise.\n"
  " */";
#else
static const char *Dtool_Multifile_is_subfile_compressed_505_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::is_subfile_encrypted(int index) const
 */
static PyObject *Dtool_Multifile_is_subfile_encrypted_506(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-bool Multifile::is_subfile_encrypted(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const Multifile*)local_this).is_subfile_encrypted)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_subfile_encrypted(Multifile self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_is_subfile_encrypted_506_comment =
  "C++ Interface:\n"
  "is_subfile_encrypted(Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated subfile has been encrypted when stored within\n"
  " * the archive, false otherwise.\n"
  " */";
#else
static const char *Dtool_Multifile_is_subfile_encrypted_506_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::is_subfile_text(int index) const
 */
static PyObject *Dtool_Multifile_is_subfile_text_507(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-bool Multifile::is_subfile_text(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const Multifile*)local_this).is_subfile_text)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_subfile_text(Multifile self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_is_subfile_text_507_comment =
  "C++ Interface:\n"
  "is_subfile_text(Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated subfile represents text data, or false if it\n"
  " * represents binary data.  If the file is text data, it may have been\n"
  " * processed by end-of-line conversion when it was added.  (But the actual\n"
  " * bits in the multifile will represent the standard Unix end-of-line\n"
  " * convention, e.g.  \\n instead of \\r\\n.)\n"
  " */";
#else
static const char *Dtool_Multifile_is_subfile_text_507_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::streamoff Multifile::get_index_end(void) const
 */
static PyObject *Dtool_Multifile_get_index_end_508(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-std::streamoff Multifile::get_index_end(void) const
  std::streamoff return_value = ((*(const Multifile*)local_this).get_index_end)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_index_end_508_comment =
  "C++ Interface:\n"
  "get_index_end(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the first byte that is guaranteed to follow any index byte already\n"
  " * written to disk in the Multifile.\n"
  " *\n"
  " * This number is largely meaningless in many cases, but if needs_repack() is\n"
  " * false, and the file is flushed, this will indicate the number of bytes in\n"
  " * the header + index.  Everything at this byte position and later will be\n"
  " * actual data.\n"
  " */";
#else
static const char *Dtool_Multifile_get_index_end_508_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::streamoff Multifile::get_subfile_internal_start(int index) const
 */
static PyObject *Dtool_Multifile_get_subfile_internal_start_509(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-std::streamoff Multifile::get_subfile_internal_start(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::streamoff return_value = ((*(const Multifile*)local_this).get_subfile_internal_start)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subfile_internal_start(Multifile self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_subfile_internal_start_509_comment =
  "C++ Interface:\n"
  "get_subfile_internal_start(Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the starting byte position within the Multifile at which the\n"
  " * indicated subfile begins.  This may be used, with\n"
  " * get_subfile_internal_length(), for low-level access to the subfile, but\n"
  " * usually it is better to use open_read_subfile() instead (which\n"
  " * automatically decrypts and/or uncompresses the subfile data).\n"
  " */";
#else
static const char *Dtool_Multifile_get_subfile_internal_start_509_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t Multifile::get_subfile_internal_length(int index) const
 */
static PyObject *Dtool_Multifile_get_subfile_internal_length_510(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-std::size_t Multifile::get_subfile_internal_length(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::size_t return_value = ((*(const Multifile*)local_this).get_subfile_internal_length)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subfile_internal_length(Multifile self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_subfile_internal_length_510_comment =
  "C++ Interface:\n"
  "get_subfile_internal_length(Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the number of bytes the indicated subfile consumes within the\n"
  " * archive.  For compressed subfiles, this will generally be smaller than\n"
  " * get_subfile_length(); for encrypted (but noncompressed) subfiles, it may be\n"
  " * slightly different, for noncompressed and nonencrypted subfiles, it will be\n"
  " * equal.\n"
  " */";
#else
static const char *Dtool_Multifile_get_subfile_internal_length_510_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline vector_uchar Multifile::read_subfile(int index)
 */
static PyObject *Dtool_Multifile_read_subfile_511(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.read_subfile")) {
    return nullptr;
  }
  // 1-inline vector_uchar Multifile::read_subfile(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    vector_uchar return_value = ((*local_this).read_subfile)((int)arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_subfile(const Multifile self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_read_subfile_511_comment =
  "C++ Interface:\n"
  "read_subfile(const Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns a vector_uchar that contains the entire contents of the indicated\n"
  " * subfile.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills a string with the entire contents of the indicated subfile.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills a pvector with the entire contents of the indicated subfile.\n"
  " */";
#else
static const char *Dtool_Multifile_read_subfile_511_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::istream *Multifile::open_read_subfile(int index)
 */
static PyObject *Dtool_Multifile_open_read_subfile_512(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.open_read_subfile")) {
    return nullptr;
  }
  // 1-std::istream *Multifile::open_read_subfile(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    std::istream *return_value = ((*local_this).open_read_subfile)((int)arg_val);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_istream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_subfile(const Multifile self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_open_read_subfile_512_comment =
  "C++ Interface:\n"
  "open_read_subfile(const Multifile self, int index)\n"
  "\n"
  "/**\n"
  " * Returns an istream that may be used to read the indicated subfile.  You may\n"
  " * seek() within this istream to your heart's content; even though it will be\n"
  " * a reference to the already-opened pfstream of the Multifile itself, byte 0\n"
  " * appears to be the beginning of the subfile and EOF appears to be the end of\n"
  " * the subfile.\n"
  " *\n"
  " * The returned istream will have been allocated via new; you should pass the\n"
  " * pointer to close_read_subfile() when you are finished with it to delete it\n"
  " * and release its resources.\n"
  " *\n"
  " * Any future calls to repack() or close() (or the Multifile destructor) will\n"
  " * invalidate all currently open subfile pointers.\n"
  " *\n"
  " * The return value will be NULL if the stream cannot be opened for some\n"
  " * reason.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This variant of open_read_subfile() is used internally only, and accepts a\n"
  " * pointer to the internal Subfile object, which is assumed to be valid and\n"
  " * written to the multifile.\n"
  " */";
#else
static const char *Dtool_Multifile_open_read_subfile_512_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void Multifile::close_read_subfile(std::istream *stream)
 */
static PyObject *Dtool_Multifile_close_read_subfile_513(PyObject *, PyObject *arg) {
  // 1-static void Multifile::close_read_subfile(std::istream *stream)
  std::istream *arg_this = (std::istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_istream, 0, "Multifile.close_read_subfile", false, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (Multifile::close_read_subfile)(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_read_subfile(istream stream)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_close_read_subfile_513_comment =
  "C++ Interface:\n"
  "close_read_subfile(istream stream)\n"
  "\n"
  "/**\n"
  " * Closes a file opened by a previous call to open_read_subfile().  This\n"
  " * really just deletes the istream pointer, but it is recommended to use this\n"
  " * interface instead of deleting it explicitly, to help work around compiler\n"
  " * issues.\n"
  " */";
#else
static const char *Dtool_Multifile_close_read_subfile_513_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::extract_subfile(int index, Filename const &filename)
 */
static PyObject *Dtool_Multifile_extract_subfile_514(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.extract_subfile")) {
    return nullptr;
  }
  // 1-bool Multifile::extract_subfile(int index, Filename const &filename)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "filename", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:extract_subfile", (char **)keyword_list, &param1, &param2)) {
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Multifile.extract_subfile", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = ((*local_this).extract_subfile)((int)param1, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract_subfile(const Multifile self, int index, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_extract_subfile_514_comment =
  "C++ Interface:\n"
  "extract_subfile(const Multifile self, int index, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Extracts the nth subfile into a file with the given name.\n"
  " */";
#else
static const char *Dtool_Multifile_extract_subfile_514_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::extract_subfile_to(int index, std::ostream &out)
 */
static PyObject *Dtool_Multifile_extract_subfile_to_515(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.extract_subfile_to")) {
    return nullptr;
  }
  // 1-bool Multifile::extract_subfile_to(int index, std::ostream &out)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "out", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:extract_subfile_to", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param2_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_std_ostream, 2, "Multifile.extract_subfile_to", false, true);
    if (param2_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      bool return_value = ((*local_this).extract_subfile_to)((int)param1, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract_subfile_to(const Multifile self, int index, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_extract_subfile_to_515_comment =
  "C++ Interface:\n"
  "extract_subfile_to(const Multifile self, int index, ostream out)\n"
  "\n"
  "/**\n"
  " * Extracts the nth subfile to the indicated ostream.\n"
  " */";
#else
static const char *Dtool_Multifile_extract_subfile_to_515_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Multifile::compare_subfile(int index, Filename const &filename)
 */
static PyObject *Dtool_Multifile_compare_subfile_516(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.compare_subfile")) {
    return nullptr;
  }
  // 1-bool Multifile::compare_subfile(int index, Filename const &filename)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "filename", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:compare_subfile", (char **)keyword_list, &param1, &param2)) {
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Multifile.compare_subfile", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = ((*local_this).compare_subfile)((int)param1, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_subfile(const Multifile self, int index, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_compare_subfile_516_comment =
  "C++ Interface:\n"
  "compare_subfile(const Multifile self, int index, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Performs a byte-for-byte comparison of the indicated file on disk with the\n"
  " * nth subfile.  Returns true if the files are equivalent, or false if they\n"
  " * are different (or the file is missing).\n"
  " *\n"
  " * If Filename::set_binary() or set_text() has already been called, it\n"
  " * specifies the nature of the source file.  If this is different from the\n"
  " * text flag of the subfile, the comparison will always return false.  If this\n"
  " * has not been specified, it will be set from the text flag of the subfile.\n"
  " */";
#else
static const char *Dtool_Multifile_compare_subfile_516_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Multifile::output(std::ostream &out) const
 */
static PyObject *Dtool_Multifile_output_517(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-void Multifile::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Multifile.output", false, true);
  if (arg_this != nullptr) {
    ((*(const Multifile*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Multifile self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_output_517_comment =
  "C++ Interface:\n"
  "output(Multifile self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Multifile_output_517_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Multifile::ls(std::ostream &out = ::std::cout) const
 */
static PyObject *Dtool_Multifile_ls_518(PyObject *self, PyObject *args, PyObject *kwds) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-void Multifile::ls(std::ostream &out = ::std::cout) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "out")) {
    std::ostream *param1_this;
    if (param1 == nullptr) {
      param1_this = &(std::cout);
    } else {
      param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "Multifile.ls", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*(const Multifile*)local_this).ls)(*param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ls(Multifile self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_ls_518_comment =
  "C++ Interface:\n"
  "ls(Multifile self, ostream out)\n"
  "\n"
  "/**\n"
  " * Shows a list of all subfiles within the Multifile.\n"
  " */";
#else
static const char *Dtool_Multifile_ls_518_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::string Multifile::get_magic_number(void)
 */
static PyObject *Dtool_Multifile_get_magic_number_519(PyObject *, PyObject *) {
  // 1-static inline std::string Multifile::get_magic_number(void)
  std::string return_value = (Multifile::get_magic_number)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_magic_number_519_comment =
  "C++ Interface:\n"
  "get_magic_number()\n"
  "\n"
  "/**\n"
  " * Returns a string with the first n bytes written to a Multifile, to identify\n"
  " * it as a Multifile.\n"
  " */";
#else
static const char *Dtool_Multifile_get_magic_number_519_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Multifile::set_header_prefix(std::string const &header_prefix)
 */
static PyObject *Dtool_Multifile_set_header_prefix_523(PyObject *self, PyObject *arg) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Multifile, (void **)&local_this, "Multifile.set_header_prefix")) {
    return nullptr;
  }
  // 1-void Multifile::set_header_prefix(std::string const &header_prefix)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_header_prefix)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_header_prefix(const Multifile self, str header_prefix)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Multifile_set_header_prefix_523_comment =
  "C++ Interface:\n"
  "set_header_prefix(const Multifile self, str header_prefix)\n"
  "\n"
  "/**\n"
  " * Sets the string which is written to the Multifile before the Multifile\n"
  " * header.  This string must begin with a hash mark and end with a newline\n"
  " * character; and if it includes embedded newline characters, each one must be\n"
  " * followed by a hash mark.  If these conditions are not initially true, the\n"
  " * string will be modified as necessary to make it so.\n"
  " *\n"
  " * This is primarily useful as a simple hack to allow p3d applications to be\n"
  " * run directly from the command line on Unix-like systems.\n"
  " *\n"
  " * The return value is true if successful, or false on failure (for instance,\n"
  " * because the header prefix violates the above rules).\n"
  " */";
#else
static const char *Dtool_Multifile_set_header_prefix_523_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Multifile::get_header_prefix(void) const
 */
static PyObject *Dtool_Multifile_get_header_prefix_524(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Multifile)) {
    return nullptr;
  }
  // 1-inline std::string const &Multifile::get_header_prefix(void) const
  std::string const &return_value = ((*(const Multifile*)local_this).get_header_prefix)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Multifile_get_header_prefix_524_comment =
  "C++ Interface:\n"
  "get_header_prefix(Multifile self)\n"
  "\n"
  "/**\n"
  " * Returns the string that preceded the Multifile header on the file, if any.\n"
  " * See set_header_prefix().\n"
  " */";
#else
static const char *Dtool_Multifile_get_header_prefix_524_comment = nullptr;
#endif

static PyObject *Dtool_Multifile_magic_number_Getter(PyObject *self, void *) {
  // 1-static inline std::string Multifile::get_magic_number(void)
  std::string return_value = (Multifile::get_magic_number)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * Multifile::Multifile(void)
 */
static int Dtool_Init_Multifile(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Multifile() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "Multifile() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-Multifile::Multifile(void)
  Multifile *return_value = new Multifile();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Multifile, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Multifile()\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_Multifile_get_subfile_names(PyObject *self, PyObject *) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_subfiles)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_Multifile_get_subfile_name_501(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_Multifile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Multifile) {
    printf("Multifile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Multifile *local_this = (Multifile *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Multifile) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Multifile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Multifile) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Multifile*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Namable
 */
/**
 * Python function wrapper for:
 * inline void Namable::set_name(std::string const &name)
 */
static PyObject *Dtool_Namable_set_name_527(PyObject *self, PyObject *arg) {
  Namable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Namable, (void **)&local_this, "Namable.set_name")) {
    return nullptr;
  }
  // 1-inline void Namable::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const Namable self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Namable_set_name_527_comment =
  "C++ Interface:\n"
  "set_name(const Namable self, str name)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Namable_set_name_527_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Namable::clear_name(void)
 */
static PyObject *Dtool_Namable_clear_name_528(PyObject *self, PyObject *) {
  Namable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Namable, (void **)&local_this, "Namable.clear_name")) {
    return nullptr;
  }
  // 1-inline void Namable::clear_name(void)
  ((*local_this).clear_name)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Namable_clear_name_528_comment =
  "C++ Interface:\n"
  "clear_name(const Namable self)\n"
  "\n"
  "/**\n"
  " * Resets the Namable's name to empty.\n"
  " */";
#else
static const char *Dtool_Namable_clear_name_528_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Namable::has_name(void) const
 */
static PyObject *Dtool_Namable_has_name_529(PyObject *self, PyObject *) {
  Namable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Namable)) {
    return nullptr;
  }
  // 1-inline bool Namable::has_name(void) const
  bool return_value = ((*(const Namable*)local_this).has_name)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Namable_has_name_529_comment =
  "C++ Interface:\n"
  "has_name(Namable self)\n"
  "\n"
  "/**\n"
  " * Returns true if the Namable has a nonempty name set, false if the name is\n"
  " * empty.\n"
  " */";
#else
static const char *Dtool_Namable_has_name_529_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &Namable::get_name(void) const
 */
static PyObject *Dtool_Namable_get_name_530(PyObject *self, PyObject *) {
  Namable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Namable)) {
    return nullptr;
  }
  // 1-inline std::string const &Namable::get_name(void) const
  std::string const &return_value = ((*(const Namable*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Namable_get_name_530_comment =
  "C++ Interface:\n"
  "get_name(Namable self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Namable_get_name_530_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Namable::output(std::ostream &out) const
 */
static PyObject *Dtool_Namable_output_533(PyObject *self, PyObject *arg) {
  Namable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Namable)) {
    return nullptr;
  }
  // 1-inline void Namable::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Namable.output", false, true);
  if (arg_this != nullptr) {
    ((*(const Namable*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Namable self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Namable_output_533_comment =
  "C++ Interface:\n"
  "output(Namable self, ostream out)\n"
  "\n"
  "// In the absence of any definition to the contrary, outputting a Namable\n"
  "// will write out its name.\n"
  "\n"
  "/**\n"
  " * Outputs the Namable.  This function simply writes the name to the output\n"
  " * stream; most Namable derivatives will probably redefine this.\n"
  " */";
#else
static const char *Dtool_Namable_output_533_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Namable::get_class_type(void)
 */
static PyObject *Dtool_Namable_get_class_type_534(PyObject *, PyObject *) {
  // 1-static TypeHandle Namable::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Namable::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Namable_get_class_type_534_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Namable_get_class_type_534_comment = nullptr;
#endif

static PyObject *Dtool_Namable_name_Getter(PyObject *self, void *) {
  const Namable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Namable, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &Namable::get_name(void) const
  std::string const &return_value = ((*(const Namable*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Namable_name_Setter(PyObject *self, PyObject *arg, void *) {
  Namable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Namable, (void **)&local_this, "Namable.name")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete name attribute");
    return -1;
  }
  // 1-inline void Namable::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_name(const Namable self, str name)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline Namable::Namable(Namable const &) = default
 * inline explicit Namable::Namable(std::string const &initial_name = "")
 */
static int Dtool_Init_Namable(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline explicit Namable::Namable(std::string const &initial_name)
      Namable *return_value = new Namable();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Namable, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline Namable::Namable(Namable const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          Namable const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Namable);
          if (param0_this != nullptr) {
            Namable *return_value = new Namable(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Namable, true, false);
          }
        }
      }

      {
        // -2 inline explicit Namable::Namable(std::string const &initial_name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"initial_name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:Namable", (char **)keyword_list, &param0_str, &param0_len)) {
          Namable *return_value = new Namable(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Namable, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: inline Namable::Namable(Namable const &) = default
      // No coercion possible: inline explicit Namable::Namable(std::string const &initial_name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Namable() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Namable()\n"
      "Namable(const Namable param0)\n"
      "Namable(str initial_name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Namable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Namable) {
    printf("Namable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Namable *local_this = (Namable *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Namable) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Namable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Namable) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OpenSSLWrapper
 */
/**
 * Python function wrapper for:
 * void OpenSSLWrapper::clear_certificates(void)
 */
static PyObject *Dtool_OpenSSLWrapper_clear_certificates_537(PyObject *self, PyObject *) {
  OpenSSLWrapper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OpenSSLWrapper, (void **)&local_this, "OpenSSLWrapper.clear_certificates")) {
    return nullptr;
  }
  // 1-void OpenSSLWrapper::clear_certificates(void)
  ((*local_this).clear_certificates)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OpenSSLWrapper_clear_certificates_537_comment =
  "C++ Interface:\n"
  "clear_certificates(const OpenSSLWrapper self)\n"
  "\n"
  "/**\n"
  " * Removes all the certificates from the global store, including the compiled-\n"
  " * in certificates loaded from ca_bundle_data.c.  You can add new certificates\n"
  " * by calling load_certificates().\n"
  " */";
#else
static const char *Dtool_OpenSSLWrapper_clear_certificates_537_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int OpenSSLWrapper::load_certificates(Filename const &filename)
 */
static PyObject *Dtool_OpenSSLWrapper_load_certificates_538(PyObject *self, PyObject *arg) {
  OpenSSLWrapper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OpenSSLWrapper, (void **)&local_this, "OpenSSLWrapper.load_certificates")) {
    return nullptr;
  }
  // 1-int OpenSSLWrapper::load_certificates(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OpenSSLWrapper.load_certificates", "Filename");
  }
  int return_value = ((*local_this).load_certificates)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_certificates(const OpenSSLWrapper self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OpenSSLWrapper_load_certificates_538_comment =
  "C++ Interface:\n"
  "load_certificates(const OpenSSLWrapper self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Reads the PEM-formatted certificate(s) (delimited by -----BEGIN\n"
  " * CERTIFICATE----- and -----END CERTIFICATE-----) from the indicated file and\n"
  " * adds them to the global store object, retrieved via get_x509_store().\n"
  " *\n"
  " * Returns the number of certificates read on success, or 0 on failure.\n"
  " *\n"
  " * You should call this only with trusted, locally-stored certificates; not\n"
  " * with certificates received from an untrusted source.\n"
  " */";
#else
static const char *Dtool_OpenSSLWrapper_load_certificates_538_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int OpenSSLWrapper::load_certificates_from_pem_ram(char const *data, std::size_t data_size)
 * inline int OpenSSLWrapper::load_certificates_from_pem_ram(std::string const &data)
 */
static PyObject *Dtool_OpenSSLWrapper_load_certificates_from_pem_ram_539(PyObject *self, PyObject *args, PyObject *kwds) {
  OpenSSLWrapper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OpenSSLWrapper, (void **)&local_this, "OpenSSLWrapper.load_certificates_from_pem_ram")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline int OpenSSLWrapper::load_certificates_from_pem_ram(std::string const &data)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          int return_value = ((*local_this).load_certificates_from_pem_ram)(std::string(param1_str, param1_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
  case 2:
    {
      // 1-int OpenSSLWrapper::load_certificates_from_pem_ram(char const *data, std::size_t data_size)
      char const *param1;
      Py_ssize_t param2;
      static const char *keyword_list[] = {"data", "data_size", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "zn:load_certificates_from_pem_ram", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param2 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param2);
        }
#endif
        int return_value = ((*local_this).load_certificates_from_pem_ram)((char const *)param1, (std::size_t)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "load_certificates_from_pem_ram() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_certificates_from_pem_ram(const OpenSSLWrapper self, str data)\n"
      "load_certificates_from_pem_ram(const OpenSSLWrapper self, str data, int data_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OpenSSLWrapper_load_certificates_from_pem_ram_539_comment =
  "C++ Interface:\n"
  "load_certificates_from_pem_ram(const OpenSSLWrapper self, str data)\n"
  "load_certificates_from_pem_ram(const OpenSSLWrapper self, str data, int data_size)\n"
  "\n"
  "/**\n"
  " * Reads a chain of trusted certificates from the indicated data buffer and\n"
  " * adds them to the X509_STORE object.  The data buffer should be PEM-\n"
  " * formatted.  Returns the number of certificates read on success, or 0 on\n"
  " * failure.\n"
  " *\n"
  " * You should call this only with trusted, locally-stored certificates; not\n"
  " * with certificates received from an untrusted source.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Reads a chain of trusted certificates from the indicated data buffer and\n"
  " * adds them to the X509_STORE object.  The data buffer should be PEM-\n"
  " * formatted.  Returns the number of certificates read on success, or 0 on\n"
  " * failure.\n"
  " *\n"
  " * You should call this only with trusted, locally-stored certificates; not\n"
  " * with certificates received from an untrusted source.\n"
  " */";
#else
static const char *Dtool_OpenSSLWrapper_load_certificates_from_pem_ram_539_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int OpenSSLWrapper::load_certificates_from_der_ram(char const *data, std::size_t data_size)
 * inline int OpenSSLWrapper::load_certificates_from_der_ram(std::string const &data)
 */
static PyObject *Dtool_OpenSSLWrapper_load_certificates_from_der_ram_540(PyObject *self, PyObject *args, PyObject *kwds) {
  OpenSSLWrapper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OpenSSLWrapper, (void **)&local_this, "OpenSSLWrapper.load_certificates_from_der_ram")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline int OpenSSLWrapper::load_certificates_from_der_ram(std::string const &data)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          int return_value = ((*local_this).load_certificates_from_der_ram)(std::string(param1_str, param1_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          return Dtool_WrapValue(return_value);
        }
      }
    }
    break;
  case 2:
    {
      // 1-int OpenSSLWrapper::load_certificates_from_der_ram(char const *data, std::size_t data_size)
      char const *param1;
      Py_ssize_t param2;
      static const char *keyword_list[] = {"data", "data_size", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "zn:load_certificates_from_der_ram", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
        if (param2 < 0) {
          return PyErr_Format(PyExc_OverflowError,
                              "can't convert negative value %zd to size_t",
                              param2);
        }
#endif
        int return_value = ((*local_this).load_certificates_from_der_ram)((char const *)param1, (std::size_t)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "load_certificates_from_der_ram() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_certificates_from_der_ram(const OpenSSLWrapper self, str data)\n"
      "load_certificates_from_der_ram(const OpenSSLWrapper self, str data, int data_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OpenSSLWrapper_load_certificates_from_der_ram_540_comment =
  "C++ Interface:\n"
  "load_certificates_from_der_ram(const OpenSSLWrapper self, str data)\n"
  "load_certificates_from_der_ram(const OpenSSLWrapper self, str data, int data_size)\n"
  "\n"
  "/**\n"
  " * Reads a chain of trusted certificates from the indicated data buffer and\n"
  " * adds them to the X509_STORE object.  The data buffer should be DER-\n"
  " * formatted.  Returns the number of certificates read on success, or 0 on\n"
  " * failure.\n"
  " *\n"
  " * You should call this only with trusted, locally-stored certificates; not\n"
  " * with certificates received from an untrusted source.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Reads a chain of trusted certificates from the indicated data buffer and\n"
  " * adds them to the X509_STORE object.  The data buffer should be DER-\n"
  " * formatted.  Returns the number of certificates read on success, or 0 on\n"
  " * failure.\n"
  " *\n"
  " * You should call this only with trusted, locally-stored certificates; not\n"
  " * with certificates received from an untrusted source.\n"
  " */";
#else
static const char *Dtool_OpenSSLWrapper_load_certificates_from_der_ram_540_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OpenSSLWrapper::notify_ssl_errors(void)
 */
static PyObject *Dtool_OpenSSLWrapper_notify_ssl_errors_542(PyObject *self, PyObject *) {
  OpenSSLWrapper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OpenSSLWrapper, (void **)&local_this, "OpenSSLWrapper.notify_ssl_errors")) {
    return nullptr;
  }
  // 1-void OpenSSLWrapper::notify_ssl_errors(void)
  ((*local_this).notify_ssl_errors)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OpenSSLWrapper_notify_ssl_errors_542_comment =
  "C++ Interface:\n"
  "notify_ssl_errors(const OpenSSLWrapper self)\n"
  "\n"
  "/**\n"
  " * A convenience function that is itself a wrapper around the OpenSSL\n"
  " * convenience function to output the recent OpenSSL errors.  This function\n"
  " * sends the error string to express_cat.warning().  If REPORT_OPENSSL_ERRORS\n"
  " * is not defined, the function does nothing.\n"
  " */";
#else
static const char *Dtool_OpenSSLWrapper_notify_ssl_errors_542_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OpenSSLWrapper::notify_debug_ssl_errors(void)
 */
static PyObject *Dtool_OpenSSLWrapper_notify_debug_ssl_errors_543(PyObject *self, PyObject *) {
  OpenSSLWrapper *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OpenSSLWrapper, (void **)&local_this, "OpenSSLWrapper.notify_debug_ssl_errors")) {
    return nullptr;
  }
  // 1-void OpenSSLWrapper::notify_debug_ssl_errors(void)
  ((*local_this).notify_debug_ssl_errors)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OpenSSLWrapper_notify_debug_ssl_errors_543_comment =
  "C++ Interface:\n"
  "notify_debug_ssl_errors(const OpenSSLWrapper self)\n"
  "\n"
  "/**\n"
  " * As notify_ssl_errors(), but sends the output to debug instead of warning.\n"
  " */";
#else
static const char *Dtool_OpenSSLWrapper_notify_debug_ssl_errors_543_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static OpenSSLWrapper *OpenSSLWrapper::get_global_ptr(void)
 */
static PyObject *Dtool_OpenSSLWrapper_get_global_ptr_544(PyObject *, PyObject *) {
  // 1-static OpenSSLWrapper *OpenSSLWrapper::get_global_ptr(void)
  OpenSSLWrapper *return_value = (OpenSSLWrapper::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OpenSSLWrapper, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OpenSSLWrapper_get_global_ptr_544_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_OpenSSLWrapper_get_global_ptr_544_comment = nullptr;
#endif

static int Dtool_Init_OpenSSLWrapper(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_OpenSSLWrapper(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OpenSSLWrapper) {
    printf("OpenSSLWrapper ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OpenSSLWrapper *local_this = (OpenSSLWrapper *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OpenSSLWrapper) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OpenSSLWrapper(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OpenSSLWrapper) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SubfileInfo
 */
/**
 * Python function wrapper for:
 * inline void SubfileInfo::operator =(SubfileInfo const &copy)
 */
static PyObject *Dtool_SubfileInfo_operator_547(PyObject *self, PyObject *arg) {
  SubfileInfo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SubfileInfo, (void **)&local_this, "SubfileInfo.assign")) {
    return nullptr;
  }
  // 1-inline void SubfileInfo::operator =(SubfileInfo const &copy)
  SubfileInfo const *arg_this = (SubfileInfo *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SubfileInfo, 1, "SubfileInfo.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    SubfileInfo *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SubfileInfo, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const SubfileInfo self, const SubfileInfo copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SubfileInfo_operator_547_comment =
  "C++ Interface:\n"
  "assign(const SubfileInfo self, const SubfileInfo copy)\n";
#else
static const char *Dtool_SubfileInfo_operator_547_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SubfileInfo::is_empty(void) const
 */
static PyObject *Dtool_SubfileInfo_is_empty_548(PyObject *self, PyObject *) {
  SubfileInfo *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SubfileInfo)) {
    return nullptr;
  }
  // 1-inline bool SubfileInfo::is_empty(void) const
  bool return_value = ((*(const SubfileInfo*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SubfileInfo_is_empty_548_comment =
  "C++ Interface:\n"
  "is_empty(SubfileInfo self)\n"
  "\n"
  "/**\n"
  " * Returns true if this SubfileInfo doesn't define any file, false if it has\n"
  " * real data.\n"
  " */";
#else
static const char *Dtool_SubfileInfo_is_empty_548_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline FileReference const *SubfileInfo::get_file(void) const
 */
static PyObject *Dtool_SubfileInfo_get_file_549(PyObject *self, PyObject *) {
  SubfileInfo *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SubfileInfo)) {
    return nullptr;
  }
  // 1-inline FileReference const *SubfileInfo::get_file(void) const
  FileReference const *return_value = ((*(const SubfileInfo*)local_this).get_file)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_FileReference, true, true, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_SubfileInfo_get_file_549_comment =
  "C++ Interface:\n"
  "get_file(SubfileInfo self)\n"
  "\n"
  "/**\n"
  " * Returns the FileReference that represents this file.\n"
  " */";
#else
static const char *Dtool_SubfileInfo_get_file_549_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &SubfileInfo::get_filename(void) const
 */
static PyObject *Dtool_SubfileInfo_get_filename_550(PyObject *self, PyObject *) {
  SubfileInfo *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SubfileInfo)) {
    return nullptr;
  }
  // 1-inline Filename const &SubfileInfo::get_filename(void) const
  Filename const *return_value = &(((*(const SubfileInfo*)local_this).get_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_SubfileInfo_get_filename_550_comment =
  "C++ Interface:\n"
  "get_filename(SubfileInfo self)\n"
  "\n"
  "/**\n"
  " * A shortcut to the filename.\n"
  " */";
#else
static const char *Dtool_SubfileInfo_get_filename_550_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::streamoff SubfileInfo::get_start(void) const
 */
static PyObject *Dtool_SubfileInfo_get_start_551(PyObject *self, PyObject *) {
  SubfileInfo *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SubfileInfo)) {
    return nullptr;
  }
  // 1-inline std::streamoff SubfileInfo::get_start(void) const
  std::streamoff return_value = ((*(const SubfileInfo*)local_this).get_start)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SubfileInfo_get_start_551_comment =
  "C++ Interface:\n"
  "get_start(SubfileInfo self)\n"
  "\n"
  "/**\n"
  " * Returns the offset within the file at which this file data begins.\n"
  " */";
#else
static const char *Dtool_SubfileInfo_get_start_551_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::streamsize SubfileInfo::get_size(void) const
 */
static PyObject *Dtool_SubfileInfo_get_size_552(PyObject *self, PyObject *) {
  SubfileInfo *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SubfileInfo)) {
    return nullptr;
  }
  // 1-inline std::streamsize SubfileInfo::get_size(void) const
  std::streamsize return_value = ((*(const SubfileInfo*)local_this).get_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SubfileInfo_get_size_552_comment =
  "C++ Interface:\n"
  "get_size(SubfileInfo self)\n"
  "\n"
  "/**\n"
  " * Returns the number of consecutive bytes, beginning at get_start(), that\n"
  " * correspond to this file data.\n"
  " */";
#else
static const char *Dtool_SubfileInfo_get_size_552_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SubfileInfo::output(std::ostream &out) const
 */
static PyObject *Dtool_SubfileInfo_output_553(PyObject *self, PyObject *arg) {
  SubfileInfo *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SubfileInfo)) {
    return nullptr;
  }
  // 1-void SubfileInfo::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "SubfileInfo.output", false, true);
  if (arg_this != nullptr) {
    ((*(const SubfileInfo*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(SubfileInfo self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SubfileInfo_output_553_comment =
  "C++ Interface:\n"
  "output(SubfileInfo self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SubfileInfo_output_553_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SubfileInfo::SubfileInfo(void)
 * inline explicit SubfileInfo::SubfileInfo(FileReference const *file, std::streamoff start, std::streamsize size)
 * inline explicit SubfileInfo::SubfileInfo(Filename const &filename, std::streamoff start, std::streamsize size)
 * inline SubfileInfo::SubfileInfo(SubfileInfo const &copy)
 */
static int Dtool_Init_SubfileInfo(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline SubfileInfo::SubfileInfo(void)
      SubfileInfo *return_value = new SubfileInfo();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SubfileInfo, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline SubfileInfo::SubfileInfo(SubfileInfo const &copy)
        SubfileInfo const *arg_this = (SubfileInfo *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SubfileInfo, 0, "SubfileInfo.SubfileInfo", true, true);
        if (arg_this != nullptr) {
          SubfileInfo *return_value = new SubfileInfo(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SubfileInfo, true, false);
        }
      }
    }
    break;
  case 3:
    {
      {
        // -2 inline explicit SubfileInfo::SubfileInfo(FileReference const *file, std::streamoff start, std::streamsize size)
        PyObject *param0;
        PY_LONG_LONG param1;
        Py_ssize_t param2;
        static const char *keyword_list[] = {"file", "start", "size", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OLn:SubfileInfo", (char **)keyword_list, &param0, &param1, &param2)) {
          FileReference const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_FileReference);
          if (param0_this != nullptr) {
            SubfileInfo *return_value = new SubfileInfo(param0_this, (std::streamoff)param1, (std::streamsize)param2);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SubfileInfo, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline explicit SubfileInfo::SubfileInfo(Filename const &filename, std::streamoff start, std::streamsize size)
        PyObject *param0;
        PY_LONG_LONG param1;
        Py_ssize_t param2;
        static const char *keyword_list[] = {"filename", "start", "size", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OLn:SubfileInfo", (char **)keyword_list, &param0, &param1, &param2)) {
          Filename const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Filename);
          if (param0_this != nullptr) {
            SubfileInfo *return_value = new SubfileInfo(*param0_this, (std::streamoff)param1, (std::streamsize)param2);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SubfileInfo, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline explicit SubfileInfo::SubfileInfo(FileReference const *file, std::streamoff start, std::streamsize size)
        PyObject *param0;
        PY_LONG_LONG param1;
        Py_ssize_t param2;
        static const char *keyword_list[] = {"file", "start", "size", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OLn:SubfileInfo", (char **)keyword_list, &param0, &param1, &param2)) {
          CPT(FileReference) param0_this;
          if (Dtool_ConstCoerce_FileReference(param0, param0_this)) {
            SubfileInfo *return_value = new SubfileInfo(std::move(param0_this), (std::streamoff)param1, (std::streamsize)param2);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SubfileInfo, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline explicit SubfileInfo::SubfileInfo(Filename const &filename, std::streamoff start, std::streamsize size)
        PyObject *param0;
        PY_LONG_LONG param1;
        Py_ssize_t param2;
        static const char *keyword_list[] = {"filename", "start", "size", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OLn:SubfileInfo", (char **)keyword_list, &param0, &param1, &param2)) {
          Filename param0_local;
          Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
          if ((param0_this != nullptr)) {
            SubfileInfo *return_value = new SubfileInfo(*param0_this, (std::streamoff)param1, (std::streamsize)param2);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SubfileInfo, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SubfileInfo() takes 0, 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SubfileInfo()\n"
      "SubfileInfo(const SubfileInfo copy)\n"
      "SubfileInfo(const FileReference file, long start, int size)\n"
      "SubfileInfo(const Filename filename, long start, int size)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_SubfileInfo(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SubfileInfo) {
    printf("SubfileInfo ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SubfileInfo *local_this = (SubfileInfo *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SubfileInfo) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SubfileInfo(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SubfileInfo) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VirtualFile
 */
/**
 * Python function wrapper for:
 * virtual VirtualFileSystem *VirtualFile::get_file_system(void) const = 0
 */
static PyObject *Dtool_VirtualFile_get_file_system_556(PyObject *self, PyObject *) {
  VirtualFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFile)) {
    return nullptr;
  }
  // 1-virtual VirtualFileSystem *VirtualFile::get_file_system(void) const = 0
  VirtualFileSystem *return_value = ((*(const VirtualFile*)local_this).get_file_system)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_VirtualFileSystem, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_get_file_system_556_comment =
  "C++ Interface:\n"
  "get_file_system(VirtualFile self)\n";
#else
static const char *Dtool_VirtualFile_get_file_system_556_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual Filename VirtualFile::get_filename(void) const = 0
 */
static PyObject *Dtool_VirtualFile_get_filename_557(PyObject *self, PyObject *) {
  VirtualFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFile)) {
    return nullptr;
  }
  // 1-virtual Filename VirtualFile::get_filename(void) const = 0
  Filename *return_value = new Filename(((*(const VirtualFile*)local_this).get_filename)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_get_filename_557_comment =
  "C++ Interface:\n"
  "get_filename(VirtualFile self)\n";
#else
static const char *Dtool_VirtualFile_get_filename_557_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &VirtualFile::get_original_filename(void) const
 */
static PyObject *Dtool_VirtualFile_get_original_filename_558(PyObject *self, PyObject *) {
  VirtualFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFile)) {
    return nullptr;
  }
  // 1-inline Filename const &VirtualFile::get_original_filename(void) const
  Filename const *return_value = &(((*(const VirtualFile*)local_this).get_original_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_get_original_filename_558_comment =
  "C++ Interface:\n"
  "get_original_filename(VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Returns the original filename as it was used to locate this VirtualFile.\n"
  " * This is usually, but not always, the same string returned by\n"
  " * get_filename().\n"
  " */";
#else
static const char *Dtool_VirtualFile_get_original_filename_558_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::has_file(void) const
 */
static PyObject *Dtool_VirtualFile_has_file_559(PyObject *self, PyObject *) {
  VirtualFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFile)) {
    return nullptr;
  }
  // 1-virtual bool VirtualFile::has_file(void) const
  bool return_value = ((*(const VirtualFile*)local_this).has_file)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_has_file_559_comment =
  "C++ Interface:\n"
  "has_file(VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Returns true if this file exists, false otherwise.\n"
  " */";
#else
static const char *Dtool_VirtualFile_has_file_559_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::is_directory(void) const
 */
static PyObject *Dtool_VirtualFile_is_directory_560(PyObject *self, PyObject *) {
  VirtualFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFile)) {
    return nullptr;
  }
  // 1-virtual bool VirtualFile::is_directory(void) const
  bool return_value = ((*(const VirtualFile*)local_this).is_directory)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_is_directory_560_comment =
  "C++ Interface:\n"
  "is_directory(VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Returns true if this file represents a directory (and scan_directory() may\n"
  " * be called), false otherwise.\n"
  " */";
#else
static const char *Dtool_VirtualFile_is_directory_560_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::is_regular_file(void) const
 */
static PyObject *Dtool_VirtualFile_is_regular_file_561(PyObject *self, PyObject *) {
  VirtualFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFile)) {
    return nullptr;
  }
  // 1-virtual bool VirtualFile::is_regular_file(void) const
  bool return_value = ((*(const VirtualFile*)local_this).is_regular_file)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_is_regular_file_561_comment =
  "C++ Interface:\n"
  "is_regular_file(VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Returns true if this file represents a regular file (and read_file() may be\n"
  " * called), false otherwise.\n"
  " */";
#else
static const char *Dtool_VirtualFile_is_regular_file_561_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::is_writable(void) const
 */
static PyObject *Dtool_VirtualFile_is_writable_562(PyObject *self, PyObject *) {
  VirtualFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFile)) {
    return nullptr;
  }
  // 1-virtual bool VirtualFile::is_writable(void) const
  bool return_value = ((*(const VirtualFile*)local_this).is_writable)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_is_writable_562_comment =
  "C++ Interface:\n"
  "is_writable(VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Returns true if this file may be written to, which implies write_file() may\n"
  " * be called (unless it is a directory instead of a regular file).\n"
  " */";
#else
static const char *Dtool_VirtualFile_is_writable_562_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::delete_file(void)
 */
static PyObject *Dtool_VirtualFile_delete_file_563(PyObject *self, PyObject *) {
  VirtualFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.delete_file")) {
    return nullptr;
  }
  // 1-virtual bool VirtualFile::delete_file(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).delete_file)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_delete_file_563_comment =
  "C++ Interface:\n"
  "delete_file(const VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Attempts to delete this file or directory.  This can remove a single file\n"
  " * or an empty directory.  It will not remove a nonempty directory.  Returns\n"
  " * true on success, false on failure.\n"
  " */";
#else
static const char *Dtool_VirtualFile_delete_file_563_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::rename_file(VirtualFile *new_file)
 */
static PyObject *Dtool_VirtualFile_rename_file_564(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.rename_file")) {
    return nullptr;
  }
  // 1-virtual bool VirtualFile::rename_file(VirtualFile *new_file)
  VirtualFile *arg_this = (VirtualFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VirtualFile, 1, "VirtualFile.rename_file", false, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = ((*local_this).rename_file)(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rename_file(const VirtualFile self, VirtualFile new_file)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_rename_file_564_comment =
  "C++ Interface:\n"
  "rename_file(const VirtualFile self, VirtualFile new_file)\n"
  "\n"
  "/**\n"
  " * Attempts to move or rename this file or directory.  If the original file is\n"
  " * an ordinary file, it will quietly replace any already-existing file in the\n"
  " * new filename (but not a directory).  If the original file is a directory,\n"
  " * the new filename must not already exist.\n"
  " *\n"
  " * If the file is a directory, the new filename must be within the same mount\n"
  " * point.  If the file is an ordinary file, the new filename may be anywhere;\n"
  " * but if it is not within the same mount point then the rename operation is\n"
  " * automatically performed as a two-step copy-and-delete operation.\n"
  " */";
#else
static const char *Dtool_VirtualFile_rename_file_564_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::copy_file(VirtualFile *new_file)
 */
static PyObject *Dtool_VirtualFile_copy_file_565(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.copy_file")) {
    return nullptr;
  }
  // 1-virtual bool VirtualFile::copy_file(VirtualFile *new_file)
  VirtualFile *arg_this = (VirtualFile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VirtualFile, 1, "VirtualFile.copy_file", false, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = ((*local_this).copy_file)(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_file(const VirtualFile self, VirtualFile new_file)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_copy_file_565_comment =
  "C++ Interface:\n"
  "copy_file(const VirtualFile self, VirtualFile new_file)\n"
  "\n"
  "/**\n"
  " * Attempts to copy the contents of this file to the indicated file.  Returns\n"
  " * true on success, false on failure.\n"
  " */";
#else
static const char *Dtool_VirtualFile_copy_file_565_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< VirtualFileList > VirtualFile::scan_directory(void) const
 */
static PyObject *Dtool_VirtualFile_scan_directory_566(PyObject *self, PyObject *) {
  VirtualFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFile)) {
    return nullptr;
  }
  // 1-PointerTo< VirtualFileList > VirtualFile::scan_directory(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PointerTo< VirtualFileList > return_value = ((*(const VirtualFile*)local_this).scan_directory)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  VirtualFileList *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_VirtualFileList, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_scan_directory_566_comment =
  "C++ Interface:\n"
  "scan_directory(VirtualFile self)\n"
  "\n"
  "/**\n"
  " * If the file represents a directory (that is, is_directory() returns true),\n"
  " * this returns the list of files within the directory at the current time.\n"
  " * Returns NULL if the file is not a directory or if the directory cannot be\n"
  " * read.\n"
  " */";
#else
static const char *Dtool_VirtualFile_scan_directory_566_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void VirtualFile::output(std::ostream &out) const
 */
static PyObject *Dtool_VirtualFile_output_567(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFile)) {
    return nullptr;
  }
  // 1-void VirtualFile::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "VirtualFile.output", false, true);
  if (arg_this != nullptr) {
    ((*(const VirtualFile*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(VirtualFile self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_output_567_comment =
  "C++ Interface:\n"
  "output(VirtualFile self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_VirtualFile_output_567_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void VirtualFile::ls(std::ostream &out = ::std::cout) const
 */
static PyObject *Dtool_VirtualFile_ls_568(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFile)) {
    return nullptr;
  }
  // 1-void VirtualFile::ls(std::ostream &out = ::std::cout) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "out")) {
    std::ostream *param1_this;
    if (param1 == nullptr) {
      param1_this = &(std::cout);
    } else {
      param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "VirtualFile.ls", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*(const VirtualFile*)local_this).ls)(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ls(VirtualFile self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_ls_568_comment =
  "C++ Interface:\n"
  "ls(VirtualFile self, ostream out)\n"
  "\n"
  "/**\n"
  " * If the file represents a directory, lists its contents.\n"
  " */";
#else
static const char *Dtool_VirtualFile_ls_568_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void VirtualFile::ls_all(std::ostream &out = ::std::cout) const
 */
static PyObject *Dtool_VirtualFile_ls_all_569(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFile)) {
    return nullptr;
  }
  // 1-void VirtualFile::ls_all(std::ostream &out = ::std::cout) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "out")) {
    std::ostream *param1_this;
    if (param1 == nullptr) {
      param1_this = &(std::cout);
    } else {
      param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "VirtualFile.ls_all", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      ((*(const VirtualFile*)local_this).ls_all)(*param1_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ls_all(VirtualFile self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_ls_all_569_comment =
  "C++ Interface:\n"
  "ls_all(VirtualFile self, ostream out)\n"
  "\n"
  "/**\n"
  " * If the file represents a directory, recursively lists its contents and\n"
  " * those of all subdirectories.\n"
  " */";
#else
static const char *Dtool_VirtualFile_ls_all_569_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *VirtualFile::read_file(bool auto_unwrap) const
 */
static PyObject *Dtool_VirtualFile_read_file_570(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFile)) {
    return nullptr;
  }
  // 1-PyObject *VirtualFile::read_file(bool auto_unwrap) const
  PyObject *return_value = invoke_extension((const VirtualFile*)local_this).read_file((PyObject_IsTrue(arg) != 0));
  return Dtool_Return(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_file(VirtualFile self, bool auto_unwrap)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_read_file_570_comment =
  "C++ Interface:\n"
  "read_file(VirtualFile self, bool auto_unwrap)\n"
  "\n"
  "/**\n"
  " * Returns the entire contents of the file as a string.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills up the indicated string with the contents of the file, if it is a\n"
  " * regular file.  Returns true on success, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Fills up the indicated pvector with the contents of the file, if it is a\n"
  " * regular file.  Returns true on success, false otherwise.\n"
  " */";
#else
static const char *Dtool_VirtualFile_read_file_570_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::istream *VirtualFile::open_read_file(bool auto_unwrap) const
 */
static PyObject *Dtool_VirtualFile_open_read_file_571(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFile)) {
    return nullptr;
  }
  // 1-virtual std::istream *VirtualFile::open_read_file(bool auto_unwrap) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  std::istream *return_value = ((*(const VirtualFile*)local_this).open_read_file)((PyObject_IsTrue(arg) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_istream, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_file(VirtualFile self, bool auto_unwrap)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_open_read_file_571_comment =
  "C++ Interface:\n"
  "open_read_file(VirtualFile self, bool auto_unwrap)\n"
  "\n"
  "/**\n"
  " * Opens the file for reading.  Returns a newly allocated istream on success\n"
  " * (which you should eventually delete when you are done reading). Returns\n"
  " * NULL on failure.\n"
  " */";
#else
static const char *Dtool_VirtualFile_open_read_file_571_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void VirtualFile::close_read_file(std::istream *stream) const
 */
static PyObject *Dtool_VirtualFile_close_read_file_572(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFile)) {
    return nullptr;
  }
  // 1-virtual void VirtualFile::close_read_file(std::istream *stream) const
  std::istream *arg_this = (std::istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_istream, 1, "VirtualFile.close_read_file", false, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*(const VirtualFile*)local_this).close_read_file)(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_read_file(VirtualFile self, istream stream)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_close_read_file_572_comment =
  "C++ Interface:\n"
  "close_read_file(VirtualFile self, istream stream)\n"
  "\n"
  "/**\n"
  " * Closes a file opened by a previous call to open_read_file().  This really\n"
  " * just deletes the istream pointer, but it is recommended to use this\n"
  " * interface instead of deleting it explicitly, to help work around compiler\n"
  " * issues.\n"
  " */";
#else
static const char *Dtool_VirtualFile_close_read_file_572_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::was_read_successful(void) const
 */
static PyObject *Dtool_VirtualFile_was_read_successful_573(PyObject *self, PyObject *) {
  VirtualFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFile)) {
    return nullptr;
  }
  // 1-virtual bool VirtualFile::was_read_successful(void) const
  bool return_value = ((*(const VirtualFile*)local_this).was_read_successful)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_was_read_successful_573_comment =
  "C++ Interface:\n"
  "was_read_successful(VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Call this method after a reading the istream returned by open_read_file()\n"
  " * to completion.  If it returns true, the file was read completely and\n"
  " * without error; if it returns false, there may have been some errors or a\n"
  " * truncated file read.  This is particularly likely if the stream is a\n"
  " * VirtualFileHTTP.\n"
  " */";
#else
static const char *Dtool_VirtualFile_was_read_successful_573_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *VirtualFile::write_file(PyObject *data, bool auto_wrap)
 */
static PyObject *Dtool_VirtualFile_write_file_574(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.write_file")) {
    return nullptr;
  }
  // 1-PyObject *VirtualFile::write_file(PyObject *data, bool auto_wrap)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"data", "auto_wrap", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:write_file", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension(local_this).write_file(param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_file(const VirtualFile self, object data, bool auto_wrap)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_write_file_574_comment =
  "C++ Interface:\n"
  "write_file(const VirtualFile self, object data, bool auto_wrap)\n"
  "\n"
  "/**\n"
  " * Writes the entire contents of the file as a string, if it is writable.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Writes the indicated data to the file, if it is writable.  Returns true on\n"
  " * success, false otherwise.\n"
  " */";
#else
static const char *Dtool_VirtualFile_write_file_574_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::ostream *VirtualFile::open_write_file(bool auto_wrap, bool truncate)
 */
static PyObject *Dtool_VirtualFile_open_write_file_575(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.open_write_file")) {
    return nullptr;
  }
  // 1-virtual std::ostream *VirtualFile::open_write_file(bool auto_wrap, bool truncate)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"auto_wrap", "truncate", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:open_write_file", (char **)keyword_list, &param1, &param2)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    std::ostream *return_value = ((*local_this).open_write_file)((PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_write_file(const VirtualFile self, bool auto_wrap, bool truncate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_open_write_file_575_comment =
  "C++ Interface:\n"
  "open_write_file(const VirtualFile self, bool auto_wrap, bool truncate)\n"
  "\n"
  "/**\n"
  " * Opens the file for writing.  Returns a newly allocated ostream on success\n"
  " * (which you should eventually delete when you are done writing). Returns\n"
  " * NULL on failure.\n"
  " */";
#else
static const char *Dtool_VirtualFile_open_write_file_575_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::ostream *VirtualFile::open_append_file(void)
 */
static PyObject *Dtool_VirtualFile_open_append_file_576(PyObject *self, PyObject *) {
  VirtualFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.open_append_file")) {
    return nullptr;
  }
  // 1-virtual std::ostream *VirtualFile::open_append_file(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  std::ostream *return_value = ((*local_this).open_append_file)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_open_append_file_576_comment =
  "C++ Interface:\n"
  "open_append_file(const VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Works like open_write_file(), but the file is opened in append mode.  Like\n"
  " * open_write_file, the returned pointer should eventually be passed to\n"
  " * close_write_file().\n"
  " */";
#else
static const char *Dtool_VirtualFile_open_append_file_576_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void VirtualFile::close_write_file(std::ostream *stream)
 */
static PyObject *Dtool_VirtualFile_close_write_file_577(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.close_write_file")) {
    return nullptr;
  }
  // 1-virtual void VirtualFile::close_write_file(std::ostream *stream)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "VirtualFile.close_write_file", false, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).close_write_file)(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_write_file(const VirtualFile self, ostream stream)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_close_write_file_577_comment =
  "C++ Interface:\n"
  "close_write_file(const VirtualFile self, ostream stream)\n"
  "\n"
  "/**\n"
  " * Closes a file opened by a previous call to open_write_file().  This really\n"
  " * just deletes the ostream pointer, but it is recommended to use this\n"
  " * interface instead of deleting it explicitly, to help work around compiler\n"
  " * issues.\n"
  " */";
#else
static const char *Dtool_VirtualFile_close_write_file_577_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::iostream *VirtualFile::open_read_write_file(bool truncate)
 */
static PyObject *Dtool_VirtualFile_open_read_write_file_578(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.open_read_write_file")) {
    return nullptr;
  }
  // 1-virtual std::iostream *VirtualFile::open_read_write_file(bool truncate)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  std::iostream *return_value = ((*local_this).open_read_write_file)((PyObject_IsTrue(arg) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_iostream, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_write_file(const VirtualFile self, bool truncate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_open_read_write_file_578_comment =
  "C++ Interface:\n"
  "open_read_write_file(const VirtualFile self, bool truncate)\n"
  "\n"
  "/**\n"
  " * Opens the file for writing.  Returns a newly allocated iostream on success\n"
  " * (which you should eventually delete when you are done writing). Returns\n"
  " * NULL on failure.\n"
  " */";
#else
static const char *Dtool_VirtualFile_open_read_write_file_578_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::iostream *VirtualFile::open_read_append_file(void)
 */
static PyObject *Dtool_VirtualFile_open_read_append_file_579(PyObject *self, PyObject *) {
  VirtualFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.open_read_append_file")) {
    return nullptr;
  }
  // 1-virtual std::iostream *VirtualFile::open_read_append_file(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  std::iostream *return_value = ((*local_this).open_read_append_file)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_iostream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_open_read_append_file_579_comment =
  "C++ Interface:\n"
  "open_read_append_file(const VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Works like open_read_write_file(), but the file is opened in append mode.\n"
  " * Like open_read_write_file, the returned pointer should eventually be passed\n"
  " * to close_read_write_file().\n"
  " */";
#else
static const char *Dtool_VirtualFile_open_read_append_file_579_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void VirtualFile::close_read_write_file(std::iostream *stream)
 */
static PyObject *Dtool_VirtualFile_close_read_write_file_580(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.close_read_write_file")) {
    return nullptr;
  }
  // 1-virtual void VirtualFile::close_read_write_file(std::iostream *stream)
  std::iostream *arg_this = (std::iostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_iostream, 1, "VirtualFile.close_read_write_file", false, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).close_read_write_file)(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_read_write_file(const VirtualFile self, iostream stream)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_close_read_write_file_580_comment =
  "C++ Interface:\n"
  "close_read_write_file(const VirtualFile self, iostream stream)\n"
  "\n"
  "/**\n"
  " * Closes a file opened by a previous call to open_read_write_file().  This\n"
  " * really just deletes the iostream pointer, but it is recommended to use this\n"
  " * interface instead of deleting it explicitly, to help work around compiler\n"
  " * issues.\n"
  " */";
#else
static const char *Dtool_VirtualFile_close_read_write_file_580_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual std::streamsize VirtualFile::get_file_size(void) const
 * virtual std::streamsize VirtualFile::get_file_size(std::istream *stream) const
 */
static PyObject *Dtool_VirtualFile_get_file_size_581(PyObject *self, PyObject *args) {
  VirtualFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFile)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-virtual std::streamsize VirtualFile::get_file_size(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      std::streamsize return_value = ((*(const VirtualFile*)local_this).get_file_size)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-virtual std::streamsize VirtualFile::get_file_size(std::istream *stream) const
      std::istream *arg_this = (std::istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_istream, 1, "VirtualFile.get_file_size", false, true);
      if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        std::streamsize return_value = ((*(const VirtualFile*)local_this).get_file_size)(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_file_size() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_file_size(VirtualFile self)\n"
      "get_file_size(VirtualFile self, istream stream)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_get_file_size_581_comment =
  "C++ Interface:\n"
  "get_file_size(VirtualFile self)\n"
  "get_file_size(VirtualFile self, istream stream)\n"
  "\n"
  "/**\n"
  " * Returns the current size on disk (or wherever it is) of the already-open\n"
  " * file.  Pass in the stream that was returned by open_read_file(); some\n"
  " * implementations may require this stream to determine the size.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the current size on disk (or wherever it is) of the file before it\n"
  " * has been opened.\n"
  " */";
#else
static const char *Dtool_VirtualFile_get_file_size_581_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual time_t VirtualFile::get_timestamp(void) const
 */
static PyObject *Dtool_VirtualFile_get_timestamp_582(PyObject *self, PyObject *) {
  VirtualFile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFile)) {
    return nullptr;
  }
  // 1-virtual time_t VirtualFile::get_timestamp(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  time_t return_value = ((*(const VirtualFile*)local_this).get_timestamp)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_get_timestamp_582_comment =
  "C++ Interface:\n"
  "get_timestamp(VirtualFile self)\n"
  "\n"
  "/**\n"
  " * Returns a time_t value that represents the time the file was last modified,\n"
  " * to within whatever precision the operating system records this information\n"
  " * (on a Windows95 system, for instance, this may only be accurate to within 2\n"
  " * seconds).\n"
  " *\n"
  " * If the timestamp cannot be determined, either because it is not supported\n"
  " * by the operating system or because there is some error (such as file not\n"
  " * found), returns 0.\n"
  " */";
#else
static const char *Dtool_VirtualFile_get_timestamp_582_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool VirtualFile::get_system_info(SubfileInfo &info)
 */
static PyObject *Dtool_VirtualFile_get_system_info_583(PyObject *self, PyObject *arg) {
  VirtualFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFile, (void **)&local_this, "VirtualFile.get_system_info")) {
    return nullptr;
  }
  // 1-virtual bool VirtualFile::get_system_info(SubfileInfo &info)
  SubfileInfo *arg_this = (SubfileInfo *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_SubfileInfo, 1, "VirtualFile.get_system_info", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).get_system_info)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_system_info(const VirtualFile self, SubfileInfo info)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_get_system_info_583_comment =
  "C++ Interface:\n"
  "get_system_info(const VirtualFile self, SubfileInfo info)\n"
  "\n"
  "/**\n"
  " * Populates the SubfileInfo structure with the data representing where the\n"
  " * file actually resides on disk, if this is knowable.  Returns true if the\n"
  " * file might reside on disk, and the info is populated, or false if it does\n"
  " * not (or it is not known where the file resides), in which case the info is\n"
  " * meaningless.\n"
  " */";
#else
static const char *Dtool_VirtualFile_get_system_info_583_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VirtualFile::get_class_type(void)
 */
static PyObject *Dtool_VirtualFile_get_class_type_584(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualFile::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((VirtualFile::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFile_get_class_type_584_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualFile_get_class_type_584_comment = nullptr;
#endif

static int Dtool_Init_VirtualFile(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_VirtualFile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VirtualFile) {
    printf("VirtualFile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VirtualFile *local_this = (VirtualFile *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VirtualFile) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VirtualFile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VirtualFile) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFile*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualFile*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (VirtualFile*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VirtualFileComposite
 */
/**
 * Python function wrapper for:
 * static TypeHandle VirtualFileComposite::get_class_type(void)
 */
static PyObject *Dtool_VirtualFileComposite_get_class_type_587(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualFileComposite::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((VirtualFileComposite::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileComposite_get_class_type_587_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualFileComposite_get_class_type_587_comment = nullptr;
#endif

static int Dtool_Init_VirtualFileComposite(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_VirtualFileComposite(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VirtualFileComposite) {
    printf("VirtualFileComposite ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VirtualFileComposite *local_this = (VirtualFileComposite *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VirtualFileComposite) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(VirtualFile *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(VirtualFile *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(VirtualFile *) local_this;
  }
  if (requested_type == Dtool_Ptr_VirtualFile) {
    return (VirtualFile *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VirtualFileComposite(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VirtualFileComposite) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFileComposite*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualFileComposite*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (VirtualFileComposite*)other_this;
  }
  if (from_type == Dtool_Ptr_VirtualFile) {
    VirtualFile* other_this = (VirtualFile*)from_this;
    return (VirtualFileComposite*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VirtualFileMount
 */
/**
 * Python function wrapper for:
 * inline VirtualFileSystem *VirtualFileMount::get_file_system(void) const
 */
static PyObject *Dtool_VirtualFileMount_get_file_system_590(PyObject *self, PyObject *) {
  VirtualFileMount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileMount)) {
    return nullptr;
  }
  // 1-inline VirtualFileSystem *VirtualFileMount::get_file_system(void) const
  VirtualFileSystem *return_value = ((*(const VirtualFileMount*)local_this).get_file_system)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_VirtualFileSystem, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMount_get_file_system_590_comment =
  "C++ Interface:\n"
  "get_file_system(VirtualFileMount self)\n"
  "\n"
  "/**\n"
  " * Returns the file system this mount object is attached to.\n"
  " */";
#else
static const char *Dtool_VirtualFileMount_get_file_system_590_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &VirtualFileMount::get_mount_point(void) const
 */
static PyObject *Dtool_VirtualFileMount_get_mount_point_591(PyObject *self, PyObject *) {
  VirtualFileMount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileMount)) {
    return nullptr;
  }
  // 1-inline Filename const &VirtualFileMount::get_mount_point(void) const
  Filename const *return_value = &(((*(const VirtualFileMount*)local_this).get_mount_point)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMount_get_mount_point_591_comment =
  "C++ Interface:\n"
  "get_mount_point(VirtualFileMount self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the directory within the virtual file system that this\n"
  " * mount object is attached to.  This directory name will end with a slash.\n"
  " */";
#else
static const char *Dtool_VirtualFileMount_get_mount_point_591_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int VirtualFileMount::get_mount_flags(void) const
 */
static PyObject *Dtool_VirtualFileMount_get_mount_flags_592(PyObject *self, PyObject *) {
  VirtualFileMount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileMount)) {
    return nullptr;
  }
  // 1-inline int VirtualFileMount::get_mount_flags(void) const
  int return_value = ((*(const VirtualFileMount*)local_this).get_mount_flags)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMount_get_mount_flags_592_comment =
  "C++ Interface:\n"
  "get_mount_flags(VirtualFileMount self)\n"
  "\n"
  "/**\n"
  " * Returns the set of flags passed by the user to the\n"
  " * VirtualFileSystem::mount() command.\n"
  " */";
#else
static const char *Dtool_VirtualFileMount_get_mount_flags_592_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void VirtualFileMount::output(std::ostream &out) const
 */
static PyObject *Dtool_VirtualFileMount_output_593(PyObject *self, PyObject *arg) {
  VirtualFileMount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileMount)) {
    return nullptr;
  }
  // 1-virtual void VirtualFileMount::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "VirtualFileMount.output", false, true);
  if (arg_this != nullptr) {
    ((*(const VirtualFileMount*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(VirtualFileMount self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMount_output_593_comment =
  "C++ Interface:\n"
  "output(VirtualFileMount self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_VirtualFileMount_output_593_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void VirtualFileMount::write(std::ostream &out) const
 */
static PyObject *Dtool_VirtualFileMount_write_594(PyObject *self, PyObject *arg) {
  VirtualFileMount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileMount)) {
    return nullptr;
  }
  // 1-virtual void VirtualFileMount::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "VirtualFileMount.write", false, true);
  if (arg_this != nullptr) {
    ((*(const VirtualFileMount*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(VirtualFileMount self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMount_write_594_comment =
  "C++ Interface:\n"
  "write(VirtualFileMount self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_VirtualFileMount_write_594_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VirtualFileMount::get_class_type(void)
 */
static PyObject *Dtool_VirtualFileMount_get_class_type_595(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualFileMount::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((VirtualFileMount::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMount_get_class_type_595_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualFileMount_get_class_type_595_comment = nullptr;
#endif

static int Dtool_Init_VirtualFileMount(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_VirtualFileMount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VirtualFileMount) {
    printf("VirtualFileMount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VirtualFileMount *local_this = (VirtualFileMount *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VirtualFileMount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VirtualFileMount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VirtualFileMount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFileMount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualFileMount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (VirtualFileMount*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VirtualFileMountMultifile
 */
/**
 * Python function wrapper for:
 * inline Multifile *VirtualFileMountMultifile::get_multifile(void) const
 */
static PyObject *Dtool_VirtualFileMountMultifile_get_multifile_598(PyObject *self, PyObject *) {
  VirtualFileMountMultifile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileMountMultifile)) {
    return nullptr;
  }
  // 1-inline Multifile *VirtualFileMountMultifile::get_multifile(void) const
  Multifile *return_value = ((*(const VirtualFileMountMultifile*)local_this).get_multifile)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Multifile, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMountMultifile_get_multifile_598_comment =
  "C++ Interface:\n"
  "get_multifile(VirtualFileMountMultifile self)\n"
  "\n"
  "/**\n"
  " * Returns the Multifile pointer that this mount object is based on.\n"
  " */";
#else
static const char *Dtool_VirtualFileMountMultifile_get_multifile_598_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VirtualFileMountMultifile::get_class_type(void)
 */
static PyObject *Dtool_VirtualFileMountMultifile_get_class_type_599(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualFileMountMultifile::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((VirtualFileMountMultifile::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMountMultifile_get_class_type_599_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualFileMountMultifile_get_class_type_599_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline VirtualFileMountMultifile::VirtualFileMountMultifile(Multifile *multifile)
 */
static int Dtool_Init_VirtualFileMountMultifile(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "VirtualFileMountMultifile() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "multifile")) {
    // 1-inline VirtualFileMountMultifile::VirtualFileMountMultifile(Multifile *multifile)
    Multifile *arg_this = (Multifile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Multifile, 0, "VirtualFileMountMultifile.VirtualFileMountMultifile", false, true);
    if (arg_this != nullptr) {
      VirtualFileMountMultifile *return_value = new VirtualFileMountMultifile(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualFileMountMultifile, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VirtualFileMountMultifile(Multifile multifile)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_VirtualFileMountMultifile(PyObject *args, CPT(VirtualFileMountMultifile) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_VirtualFileMountMultifile)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline VirtualFileMountMultifile::VirtualFileMountMultifile(Multifile *multifile)
    Multifile *arg_this = (Multifile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Multifile, 0, "VirtualFileMountMultifile.VirtualFileMountMultifile", false, false);
    if (arg_this != nullptr) {
      VirtualFileMountMultifile *return_value = new VirtualFileMountMultifile(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_VirtualFileMountMultifile(PyObject *args, PT(VirtualFileMountMultifile) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_VirtualFileMountMultifile)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline VirtualFileMountMultifile::VirtualFileMountMultifile(Multifile *multifile)
    Multifile *arg_this = (Multifile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Multifile, 0, "VirtualFileMountMultifile.VirtualFileMountMultifile", false, false);
    if (arg_this != nullptr) {
      VirtualFileMountMultifile *return_value = new VirtualFileMountMultifile(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_VirtualFileMountMultifile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VirtualFileMountMultifile) {
    printf("VirtualFileMountMultifile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VirtualFileMountMultifile *local_this = (VirtualFileMountMultifile *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VirtualFileMountMultifile) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_VirtualFileMount) {
    return (VirtualFileMount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VirtualFileMountMultifile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VirtualFileMountMultifile) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFileMountMultifile*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualFileMountMultifile*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (VirtualFileMountMultifile*)other_this;
  }
  if (from_type == Dtool_Ptr_VirtualFileMount) {
    VirtualFileMount* other_this = (VirtualFileMount*)from_this;
    return (VirtualFileMountMultifile*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VirtualFileMountRamdisk
 */
/**
 * Python function wrapper for:
 * static TypeHandle VirtualFileMountRamdisk::get_class_type(void)
 */
static PyObject *Dtool_VirtualFileMountRamdisk_get_class_type_602(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualFileMountRamdisk::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((VirtualFileMountRamdisk::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMountRamdisk_get_class_type_602_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualFileMountRamdisk_get_class_type_602_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * VirtualFileMountRamdisk::VirtualFileMountRamdisk(void)
 */
static int Dtool_Init_VirtualFileMountRamdisk(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("VirtualFileMountRamdisk() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "VirtualFileMountRamdisk() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-VirtualFileMountRamdisk::VirtualFileMountRamdisk(void)
  VirtualFileMountRamdisk *return_value = new VirtualFileMountRamdisk();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualFileMountRamdisk, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VirtualFileMountRamdisk()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_VirtualFileMountRamdisk(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VirtualFileMountRamdisk) {
    printf("VirtualFileMountRamdisk ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VirtualFileMountRamdisk *local_this = (VirtualFileMountRamdisk *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VirtualFileMountRamdisk) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_VirtualFileMount) {
    return (VirtualFileMount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VirtualFileMountRamdisk(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VirtualFileMountRamdisk) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFileMountRamdisk*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualFileMountRamdisk*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (VirtualFileMountRamdisk*)other_this;
  }
  if (from_type == Dtool_Ptr_VirtualFileMount) {
    VirtualFileMount* other_this = (VirtualFileMount*)from_this;
    return (VirtualFileMountRamdisk*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VirtualFileMountSystem
 */
/**
 * Python function wrapper for:
 * inline Filename const &VirtualFileMountSystem::get_physical_filename(void) const
 */
static PyObject *Dtool_VirtualFileMountSystem_get_physical_filename_606(PyObject *self, PyObject *) {
  VirtualFileMountSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileMountSystem)) {
    return nullptr;
  }
  // 1-inline Filename const &VirtualFileMountSystem::get_physical_filename(void) const
  Filename const *return_value = &(((*(const VirtualFileMountSystem*)local_this).get_physical_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMountSystem_get_physical_filename_606_comment =
  "C++ Interface:\n"
  "get_physical_filename(VirtualFileMountSystem self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the source file on the OS filesystem of the directory\n"
  " * or file that is mounted.\n"
  " */";
#else
static const char *Dtool_VirtualFileMountSystem_get_physical_filename_606_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VirtualFileMountSystem::get_class_type(void)
 */
static PyObject *Dtool_VirtualFileMountSystem_get_class_type_607(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualFileMountSystem::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((VirtualFileMountSystem::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileMountSystem_get_class_type_607_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualFileMountSystem_get_class_type_607_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline VirtualFileMountSystem::VirtualFileMountSystem(Filename const &physical_filename)
 */
static int Dtool_Init_VirtualFileMountSystem(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "VirtualFileMountSystem() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "physical_filename")) {
    // 1-inline VirtualFileMountSystem::VirtualFileMountSystem(Filename const &physical_filename)
    Filename arg_local;
    Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
    if (!(arg_this != nullptr)) {
      Dtool_Raise_ArgTypeError(arg, 0, "VirtualFileMountSystem.VirtualFileMountSystem", "Filename");
      return -1;
    }
    VirtualFileMountSystem *return_value = new VirtualFileMountSystem(*arg_this);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualFileMountSystem, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VirtualFileMountSystem(const Filename physical_filename)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_VirtualFileMountSystem(PyObject *args, CPT(VirtualFileMountSystem) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_VirtualFileMountSystem)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline VirtualFileMountSystem::VirtualFileMountSystem(Filename const &physical_filename)
    Filename const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
    if (arg_this != nullptr) {
      VirtualFileMountSystem *return_value = new VirtualFileMountSystem(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_VirtualFileMountSystem(PyObject *args, PT(VirtualFileMountSystem) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_VirtualFileMountSystem)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline VirtualFileMountSystem::VirtualFileMountSystem(Filename const &physical_filename)
    Filename const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
    if (arg_this != nullptr) {
      VirtualFileMountSystem *return_value = new VirtualFileMountSystem(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_VirtualFileMountSystem(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VirtualFileMountSystem) {
    printf("VirtualFileMountSystem ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VirtualFileMountSystem *local_this = (VirtualFileMountSystem *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VirtualFileMountSystem) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(VirtualFileMount *) local_this;
  }
  if (requested_type == Dtool_Ptr_VirtualFileMount) {
    return (VirtualFileMount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VirtualFileMountSystem(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VirtualFileMountSystem) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFileMountSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualFileMountSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (VirtualFileMountSystem*)other_this;
  }
  if (from_type == Dtool_Ptr_VirtualFileMount) {
    VirtualFileMount* other_this = (VirtualFileMount*)from_this;
    return (VirtualFileMountSystem*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VirtualFileSimple
 */
/**
 * Python function wrapper for:
 * inline VirtualFileMount *VirtualFileSimple::get_mount(void) const
 */
static PyObject *Dtool_VirtualFileSimple_get_mount_610(PyObject *self, PyObject *) {
  VirtualFileSimple *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSimple)) {
    return nullptr;
  }
  // 1-inline VirtualFileMount *VirtualFileSimple::get_mount(void) const
  VirtualFileMount *return_value = ((*(const VirtualFileSimple*)local_this).get_mount)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VirtualFileMount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSimple_get_mount_610_comment =
  "C++ Interface:\n"
  "get_mount(VirtualFileSimple self)\n"
  "\n"
  "/**\n"
  " * Returns the VirtualFileMount this file is associated with.\n"
  " */";
#else
static const char *Dtool_VirtualFileSimple_get_mount_610_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool VirtualFileSimple::is_implicit_pz_file(void) const
 */
static PyObject *Dtool_VirtualFileSimple_is_implicit_pz_file_611(PyObject *self, PyObject *) {
  VirtualFileSimple *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSimple)) {
    return nullptr;
  }
  // 1-inline bool VirtualFileSimple::is_implicit_pz_file(void) const
  bool return_value = ((*(const VirtualFileSimple*)local_this).is_implicit_pz_file)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSimple_is_implicit_pz_file_611_comment =
  "C++ Interface:\n"
  "is_implicit_pz_file(VirtualFileSimple self)\n"
  "\n"
  "/**\n"
  " * Returns true if this file is a .pz file that should be implicitly\n"
  " * decompressed on load, or false if it is not a .pz file or if it should not\n"
  " * be decompressed.\n"
  " */";
#else
static const char *Dtool_VirtualFileSimple_is_implicit_pz_file_611_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle VirtualFileSimple::get_class_type(void)
 */
static PyObject *Dtool_VirtualFileSimple_get_class_type_612(PyObject *, PyObject *) {
  // 1-static TypeHandle VirtualFileSimple::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((VirtualFileSimple::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSimple_get_class_type_612_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_VirtualFileSimple_get_class_type_612_comment = nullptr;
#endif

static int Dtool_Init_VirtualFileSimple(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_VirtualFileSimple(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VirtualFileSimple) {
    printf("VirtualFileSimple ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VirtualFileSimple *local_this = (VirtualFileSimple *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VirtualFileSimple) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(VirtualFile *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(VirtualFile *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(VirtualFile *) local_this;
  }
  if (requested_type == Dtool_Ptr_VirtualFile) {
    return (VirtualFile *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VirtualFileSimple(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VirtualFileSimple) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFileSimple*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (VirtualFileSimple*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (VirtualFileSimple*)other_this;
  }
  if (from_type == Dtool_Ptr_VirtualFile) {
    VirtualFile* other_this = (VirtualFile*)from_this;
    return (VirtualFileSimple*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TemporaryFile
 */
/**
 * Python function wrapper for:
 * static TypeHandle TemporaryFile::get_class_type(void)
 */
static PyObject *Dtool_TemporaryFile_get_class_type_616(PyObject *, PyObject *) {
  // 1-static TypeHandle TemporaryFile::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TemporaryFile::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TemporaryFile_get_class_type_616_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TemporaryFile_get_class_type_616_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline explicit TemporaryFile::TemporaryFile(Filename const &filename)
 * inline TemporaryFile::TemporaryFile(TemporaryFile const &) = default
 */
static int Dtool_Init_TemporaryFile(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "TemporaryFile() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline TemporaryFile::TemporaryFile(TemporaryFile const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      TemporaryFile const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TemporaryFile);
      if (param0_this != nullptr) {
        TemporaryFile *return_value = new TemporaryFile(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TemporaryFile, true, false);
      }
    }
  }

  // No coercion possible: inline TemporaryFile::TemporaryFile(TemporaryFile const &) = default
  {
    // -2 inline explicit TemporaryFile::TemporaryFile(Filename const &filename)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "filename")) {
      Filename param0_local;
      Filename const *param0_this = Dtool_Coerce_Filename(param0, param0_local);
      if ((param0_this != nullptr)) {
        TemporaryFile *return_value = new TemporaryFile(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TemporaryFile, true, false);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TemporaryFile(const TemporaryFile param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TemporaryFile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TemporaryFile) {
    printf("TemporaryFile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TemporaryFile *local_this = (TemporaryFile *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TemporaryFile) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_FileReference) {
    return (FileReference *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(FileReference *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(FileReference *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(FileReference *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TemporaryFile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TemporaryFile) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_FileReference) {
    FileReference* other_this = (FileReference*)from_this;
    return (TemporaryFile*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TemporaryFile*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TemporaryFile*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (TemporaryFile*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class IDecompressStream
 */
/**
 * Python function wrapper for:
 * inline IDecompressStream &IDecompressStream::open(std::istream *source, bool owns_source)
 */
static PyObject *Dtool_IDecompressStream_open_619(PyObject *self, PyObject *args, PyObject *kwds) {
  IDecompressStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IDecompressStream, (void **)&local_this, "IDecompressStream.open")) {
    return nullptr;
  }
  // 1-inline IDecompressStream &IDecompressStream::open(std::istream *source, bool owns_source)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"source", "owns_source", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:open", (char **)keyword_list, &param1, &param2)) {
    std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "IDecompressStream.open", false, true);
    if (param1_this != nullptr) {
      IDecompressStream *return_value = &(((*local_this).open)(param1_this, (PyObject_IsTrue(param2) != 0)));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_IDecompressStream, false, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const IDecompressStream self, istream source, bool owns_source)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_IDecompressStream_open_619_comment =
  "C++ Interface:\n"
  "open(const IDecompressStream self, istream source, bool owns_source)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_IDecompressStream_open_619_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline IDecompressStream &IDecompressStream::close(void)
 */
static PyObject *Dtool_IDecompressStream_close_620(PyObject *self, PyObject *) {
  IDecompressStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_IDecompressStream, (void **)&local_this, "IDecompressStream.close")) {
    return nullptr;
  }
  // 1-inline IDecompressStream &IDecompressStream::close(void)
  IDecompressStream *return_value = &(((*local_this).close)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_IDecompressStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_IDecompressStream_close_620_comment =
  "C++ Interface:\n"
  "close(const IDecompressStream self)\n"
  "\n"
  "/**\n"
  " * Resets the ZStream to empty, but does not actually close the source istream\n"
  " * unless owns_source was true.\n"
  " */";
#else
static const char *Dtool_IDecompressStream_close_620_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline IDecompressStream::IDecompressStream(void)
 * inline explicit IDecompressStream::IDecompressStream(std::istream *source, bool owns_source)
 */
static int Dtool_Init_IDecompressStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline IDecompressStream::IDecompressStream(void)
      IDecompressStream *return_value = new IDecompressStream();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IDecompressStream, true, false);
    }
    break;
  case 2:
    {
      // 1-inline explicit IDecompressStream::IDecompressStream(std::istream *source, bool owns_source)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"source", "owns_source", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:IDecompressStream", (char **)keyword_list, &param0, &param1)) {
        std::istream *param0_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_std_istream, 0, "IDecompressStream.IDecompressStream", false, true);
        if (param0_this != nullptr) {
          IDecompressStream *return_value = new IDecompressStream(param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_IDecompressStream, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "IDecompressStream() takes 0 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "IDecompressStream()\n"
      "IDecompressStream(istream source, bool owns_source)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_IDecompressStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_IDecompressStream) {
    printf("IDecompressStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  IDecompressStream *local_this = (IDecompressStream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_IDecompressStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *)(std::istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *)(std::istream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_istream) {
    return (std::istream *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_IDecompressStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_IDecompressStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_std_istream) {
    std::istream* other_this = (std::istream*)from_this;
    return (IDecompressStream*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OCompressStream
 */
/**
 * Python function wrapper for:
 * inline OCompressStream &OCompressStream::open(std::ostream *dest, bool owns_dest, int compression_level = 6)
 */
static PyObject *Dtool_OCompressStream_open_624(PyObject *self, PyObject *args, PyObject *kwds) {
  OCompressStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OCompressStream, (void **)&local_this, "OCompressStream.open")) {
    return nullptr;
  }
  // 1-inline OCompressStream &OCompressStream::open(std::ostream *dest, bool owns_dest, int compression_level = 6)
  PyObject *param1;
  PyObject *param2;
  int param3 = 6;
  static const char *keyword_list[] = {"dest", "owns_dest", "compression_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|i:open", (char **)keyword_list, &param1, &param2, &param3)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "OCompressStream.open", false, true);
    if (param1_this != nullptr) {
      OCompressStream *return_value = &(((*local_this).open)(param1_this, (PyObject_IsTrue(param2) != 0), (int)param3));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OCompressStream, false, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const OCompressStream self, ostream dest, bool owns_dest, int compression_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OCompressStream_open_624_comment =
  "C++ Interface:\n"
  "open(const OCompressStream self, ostream dest, bool owns_dest, int compression_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_OCompressStream_open_624_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OCompressStream &OCompressStream::close(void)
 */
static PyObject *Dtool_OCompressStream_close_625(PyObject *self, PyObject *) {
  OCompressStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OCompressStream, (void **)&local_this, "OCompressStream.close")) {
    return nullptr;
  }
  // 1-inline OCompressStream &OCompressStream::close(void)
  OCompressStream *return_value = &(((*local_this).close)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OCompressStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OCompressStream_close_625_comment =
  "C++ Interface:\n"
  "close(const OCompressStream self)\n"
  "\n"
  "/**\n"
  " * Resets the ZStream to empty, but does not actually close the dest ostream\n"
  " * unless owns_dest was true.\n"
  " */";
#else
static const char *Dtool_OCompressStream_close_625_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OCompressStream::OCompressStream(void)
 * inline explicit OCompressStream::OCompressStream(std::ostream *dest, bool owns_dest, int compression_level = 6)
 */
static int Dtool_Init_OCompressStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline OCompressStream::OCompressStream(void)
      OCompressStream *return_value = new OCompressStream();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OCompressStream, true, false);
    }
    break;
  case 2:
  case 3:
    {
      // 1-inline explicit OCompressStream::OCompressStream(std::ostream *dest, bool owns_dest, int compression_level = 6)
      PyObject *param0;
      PyObject *param1;
      int param2 = 6;
      static const char *keyword_list[] = {"dest", "owns_dest", "compression_level", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|i:OCompressStream", (char **)keyword_list, &param0, &param1, &param2)) {
        std::ostream *param0_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_std_ostream, 0, "OCompressStream.OCompressStream", false, true);
        if (param0_this != nullptr) {
          OCompressStream *return_value = new OCompressStream(param0_this, (PyObject_IsTrue(param1) != 0), (int)param2);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OCompressStream, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OCompressStream() takes 0, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OCompressStream()\n"
      "OCompressStream(ostream dest, bool owns_dest, int compression_level)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OCompressStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OCompressStream) {
    printf("OCompressStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OCompressStream *local_this = (OCompressStream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OCompressStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *)(std::ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *)(std::ostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ostream) {
    return (std::ostream *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OCompressStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OCompressStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_std_ostream) {
    std::ostream* other_this = (std::ostream*)from_this;
    return (OCompressStream*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VirtualFileList
 */
/**
 * Python function wrapper for:
 * inline std::size_t VirtualFileList::get_num_files(void) const
 */
static PyObject *Dtool_VirtualFileList_get_num_files_628(PyObject *self, PyObject *) {
  VirtualFileList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileList)) {
    return nullptr;
  }
  // 1-inline std::size_t VirtualFileList::get_num_files(void) const
  std::size_t return_value = ((*(const VirtualFileList*)local_this).get_num_files)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileList_get_num_files_628_comment =
  "C++ Interface:\n"
  "get_num_files(VirtualFileList self)\n"
  "\n"
  "/**\n"
  " * Returns the number of files in the list.\n"
  " */";
#else
static const char *Dtool_VirtualFileList_get_num_files_628_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline VirtualFile *VirtualFileList::get_file(std::size_t n) const
 */
static PyObject *Dtool_VirtualFileList_get_file_629(PyObject *self, PyObject *arg) {
  VirtualFileList *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileList)) {
    return nullptr;
  }
  // 1-inline VirtualFile *VirtualFileList::get_file(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    VirtualFile *return_value = ((*(const VirtualFileList*)local_this).get_file)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VirtualFile, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_file(VirtualFileList self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileList_get_file_629_comment =
  "C++ Interface:\n"
  "get_file(VirtualFileList self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth file in the list.\n"
  " */";
#else
static const char *Dtool_VirtualFileList_get_file_629_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline VirtualFileList::VirtualFileList(VirtualFileList const &) = default
 */
static int Dtool_Init_VirtualFileList(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("VirtualFileList() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline VirtualFileList::VirtualFileList(VirtualFileList const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    VirtualFileList const *param0_this = (VirtualFileList *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_VirtualFileList, 0, "VirtualFileList.VirtualFileList", true, true);
    if (param0_this != nullptr) {
      VirtualFileList *return_value = new VirtualFileList(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualFileList, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VirtualFileList(const VirtualFileList param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_VirtualFileList_get_files(PyObject *self, PyObject *) {
  VirtualFileList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileList, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_files)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_VirtualFileList_get_file_629(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_VirtualFileList(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VirtualFileList) {
    printf("VirtualFileList ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VirtualFileList *local_this = (VirtualFileList *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VirtualFileList) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VirtualFileList(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VirtualFileList) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (VirtualFileList*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class VirtualFileSystem
 */
/**
 * Python function wrapper for:
 * bool VirtualFileSystem::mount(Filename const &physical_filename, Filename const &mount_point, int flags, std::string const &password = "")
 * bool VirtualFileSystem::mount(Multifile *multifile, Filename const &mount_point, int flags)
 * bool VirtualFileSystem::mount(VirtualFileMount *mount, Filename const &mount_point, int flags)
 */
static PyObject *Dtool_VirtualFileSystem_mount_640(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.mount")) {
    return nullptr;
  }
  {
    // -2 bool VirtualFileSystem::mount(Filename const &physical_filename, Filename const &mount_point, int flags, std::string const &password = "")
    PyObject *param1;
    PyObject *param2;
    int param3;
    const char *param4_str = "";
    Py_ssize_t param4_len = 0;
    static const char *keyword_list[] = {"physical_filename", "mount_point", "flags", "password", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi|s#:mount", (char **)keyword_list, &param1, &param2, &param3, &param4_str, &param4_len)) {
      Filename const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_Filename);
      Filename const *param2_this = nullptr;
      DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_Filename);
      if (param1_this != nullptr && param2_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).mount)(*param1_this, *param2_this, (int)param3, std::string(param4_str, param4_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool VirtualFileSystem::mount(VirtualFileMount *mount, Filename const &mount_point, int flags)
    PyObject *param1;
    PyObject *param2;
    int param3;
    static const char *keyword_list[] = {"mount", "mount_point", "flags", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:mount", (char **)keyword_list, &param1, &param2, &param3)) {
      VirtualFileMount *param1_this = (VirtualFileMount *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_VirtualFileMount, 1, "VirtualFileSystem.mount", false, false);
      Filename const *param2_this = nullptr;
      DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_Filename);
      if (param1_this != nullptr && param2_this != nullptr) {
        bool return_value = ((*local_this).mount)(param1_this, *param2_this, (int)param3);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool VirtualFileSystem::mount(Multifile *multifile, Filename const &mount_point, int flags)
    PyObject *param1;
    PyObject *param2;
    int param3;
    static const char *keyword_list[] = {"multifile", "mount_point", "flags", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:mount", (char **)keyword_list, &param1, &param2, &param3)) {
      Multifile *param1_this = (Multifile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Multifile, 1, "VirtualFileSystem.mount", false, false);
      Filename const *param2_this = nullptr;
      DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_Filename);
      if (param1_this != nullptr && param2_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).mount)(param1_this, *param2_this, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool VirtualFileSystem::mount(Filename const &physical_filename, Filename const &mount_point, int flags, std::string const &password = "")
    PyObject *param1;
    PyObject *param2;
    int param3;
    const char *param4_str = "";
    Py_ssize_t param4_len = 0;
    static const char *keyword_list[] = {"physical_filename", "mount_point", "flags", "password", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi|s#:mount", (char **)keyword_list, &param1, &param2, &param3, &param4_str, &param4_len)) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      Filename param2_local;
      Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
      if ((param1_this != nullptr) && (param2_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).mount)(*param1_this, *param2_this, (int)param3, std::string(param4_str, param4_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool VirtualFileSystem::mount(VirtualFileMount *mount, Filename const &mount_point, int flags)
    PyObject *param1;
    PyObject *param2;
    int param3;
    static const char *keyword_list[] = {"mount", "mount_point", "flags", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:mount", (char **)keyword_list, &param1, &param2, &param3)) {
      VirtualFileMount *param1_this = (VirtualFileMount *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_VirtualFileMount, 1, "VirtualFileSystem.mount", false, false);
      Filename param2_local;
      Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
      if (param1_this != nullptr && (param2_this != nullptr)) {
        bool return_value = ((*local_this).mount)(param1_this, *param2_this, (int)param3);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool VirtualFileSystem::mount(Multifile *multifile, Filename const &mount_point, int flags)
    PyObject *param1;
    PyObject *param2;
    int param3;
    static const char *keyword_list[] = {"multifile", "mount_point", "flags", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:mount", (char **)keyword_list, &param1, &param2, &param3)) {
      Multifile *param1_this = (Multifile *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Multifile, 1, "VirtualFileSystem.mount", false, false);
      Filename param2_local;
      Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
      if (param1_this != nullptr && (param2_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        bool return_value = ((*local_this).mount)(param1_this, *param2_this, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "mount(const VirtualFileSystem self, const Filename physical_filename, const Filename mount_point, int flags, str password)\n"
      "mount(const VirtualFileSystem self, VirtualFileMount mount, const Filename mount_point, int flags)\n"
      "mount(const VirtualFileSystem self, Multifile multifile, const Filename mount_point, int flags)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_mount_640_comment =
  "C++ Interface:\n"
  "mount(const VirtualFileSystem self, const Filename physical_filename, const Filename mount_point, int flags, str password)\n"
  "mount(const VirtualFileSystem self, VirtualFileMount mount, const Filename mount_point, int flags)\n"
  "mount(const VirtualFileSystem self, Multifile multifile, const Filename mount_point, int flags)\n"
  "\n"
  "/**\n"
  " * Mounts the indicated Multifile at the given mount point.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Mounts the indicated system file or directory at the given mount point.  If\n"
  " * the named file is a directory, mounts the directory.  If the named file is\n"
  " * a Multifile, mounts it as a Multifile.  Returns true on success, false on\n"
  " * failure.\n"
  " *\n"
  " * A given system directory may be mounted to multiple different mount point,\n"
  " * and the same mount point may share multiple system directories.  In the\n"
  " * case of ambiguities (that is, two different files with exactly the same\n"
  " * full pathname), the most-recently mounted system wins.\n"
  " *\n"
  " * The filename specified as the first parameter must refer to a real,\n"
  " * physical filename on disk; it cannot be a virtual file already appearing\n"
  " * within the vfs filespace.  However, it is possible to mount such a file;\n"
  " * see mount_loop() for this.\n"
  " *\n"
  " * Note that a mounted VirtualFileSystem directory is fully case-sensitive,\n"
  " * unlike the native Windows file system, so you must refer to files within\n"
  " * the virtual file system with exactly the right case.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Adds the given VirtualFileMount object to the mount list.  This is a lower-\n"
  " * level function than the other flavors of mount(); it requires you to create\n"
  " * a VirtualFileMount object specifically.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_mount_640_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool VirtualFileSystem::mount_loop(Filename const &virtual_filename, Filename const &mount_point, int flags, std::string const &password = "")
 */
static PyObject *Dtool_VirtualFileSystem_mount_loop_641(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.mount_loop")) {
    return nullptr;
  }
  // 1-bool VirtualFileSystem::mount_loop(Filename const &virtual_filename, Filename const &mount_point, int flags, std::string const &password = "")
  PyObject *param1;
  PyObject *param2;
  int param3;
  const char *param4_str = "";
  Py_ssize_t param4_len = 0;
  static const char *keyword_list[] = {"virtual_filename", "mount_point", "flags", "password", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi|s#:mount_loop", (char **)keyword_list, &param1, &param2, &param3, &param4_str, &param4_len)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.mount_loop", "Filename");
    }
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "VirtualFileSystem.mount_loop", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = ((*local_this).mount_loop)(*param1_this, *param2_this, (int)param3, std::string(param4_str, param4_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "mount_loop(const VirtualFileSystem self, const Filename virtual_filename, const Filename mount_point, int flags, str password)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_mount_loop_641_comment =
  "C++ Interface:\n"
  "mount_loop(const VirtualFileSystem self, const Filename virtual_filename, const Filename mount_point, int flags, str password)\n"
  "\n"
  "/**\n"
  " * This is similar to mount(), but it receives the name of a Multifile that\n"
  " * already appears within the virtual file system.  It can be used to mount a\n"
  " * Multifile that is itself hosted within a virtually-mounted Multifile.\n"
  " *\n"
  " * This interface can also be used to mount physical files (that appear within\n"
  " * the virtual filespace), but it cannot be used to mount directories.  Use\n"
  " * mount() if you need to mount a directory.\n"
  " *\n"
  " * Note that there is additional overhead, in the form of additional buffer\n"
  " * copies of the data, for recursively mounting a multifile like this.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_mount_loop_641_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int VirtualFileSystem::unmount(Filename const &physical_filename)
 * int VirtualFileSystem::unmount(Multifile *multifile)
 * int VirtualFileSystem::unmount(VirtualFileMount *mount)
 */
static PyObject *Dtool_VirtualFileSystem_unmount_642(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.unmount")) {
    return nullptr;
  }
  {
    // -2 int VirtualFileSystem::unmount(VirtualFileMount *mount)
    VirtualFileMount *arg_this = (VirtualFileMount *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VirtualFileMount, 1, "VirtualFileSystem.unmount", false, false);
    if (arg_this != nullptr) {
      int return_value = ((*local_this).unmount)(arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 int VirtualFileSystem::unmount(Multifile *multifile)
    Multifile *arg_this = (Multifile *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Multifile, 1, "VirtualFileSystem.unmount", false, false);
    if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      int return_value = ((*local_this).unmount)(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: int VirtualFileSystem::unmount(VirtualFileMount *mount)
  // No coercion possible: int VirtualFileSystem::unmount(Multifile *multifile)
  {
    // -2 int VirtualFileSystem::unmount(Filename const &physical_filename)
    Filename arg_local;
    Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
    if ((arg_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      int return_value = ((*local_this).unmount)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unmount(const VirtualFileSystem self, VirtualFileMount mount)\n"
      "unmount(const VirtualFileSystem self, Multifile multifile)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_unmount_642_comment =
  "C++ Interface:\n"
  "unmount(const VirtualFileSystem self, VirtualFileMount mount)\n"
  "unmount(const VirtualFileSystem self, Multifile multifile)\n"
  "\n"
  "/**\n"
  " * Unmounts all appearances of the indicated Multifile from the file system.\n"
  " * Returns the number of appearances unmounted.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unmounts all appearances of the indicated directory name or multifile name\n"
  " * from the file system.  Returns the number of appearances unmounted.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Unmounts the indicated VirtualFileMount object from the file system.\n"
  " * Returns the number of appearances unmounted.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_unmount_642_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int VirtualFileSystem::unmount_point(Filename const &mount_point)
 */
static PyObject *Dtool_VirtualFileSystem_unmount_point_643(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.unmount_point")) {
    return nullptr;
  }
  // 1-int VirtualFileSystem::unmount_point(Filename const &mount_point)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.unmount_point", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int return_value = ((*local_this).unmount_point)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unmount_point(const VirtualFileSystem self, const Filename mount_point)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_unmount_point_643_comment =
  "C++ Interface:\n"
  "unmount_point(const VirtualFileSystem self, const Filename mount_point)\n"
  "\n"
  "/**\n"
  " * Unmounts all systems attached to the given mount point from the file\n"
  " * system.  Returns the number of appearances unmounted.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_unmount_point_643_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int VirtualFileSystem::unmount_all(void)
 */
static PyObject *Dtool_VirtualFileSystem_unmount_all_644(PyObject *self, PyObject *) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.unmount_all")) {
    return nullptr;
  }
  // 1-int VirtualFileSystem::unmount_all(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int return_value = ((*local_this).unmount_all)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_unmount_all_644_comment =
  "C++ Interface:\n"
  "unmount_all(const VirtualFileSystem self)\n"
  "\n"
  "/**\n"
  " * Unmounts all files from the file system.  Returns the number of systems\n"
  " * unmounted.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_unmount_all_644_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int VirtualFileSystem::get_num_mounts(void) const
 */
static PyObject *Dtool_VirtualFileSystem_get_num_mounts_645(PyObject *self, PyObject *) {
  VirtualFileSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSystem)) {
    return nullptr;
  }
  // 1-int VirtualFileSystem::get_num_mounts(void) const
  int return_value = ((*(const VirtualFileSystem*)local_this).get_num_mounts)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_get_num_mounts_645_comment =
  "C++ Interface:\n"
  "get_num_mounts(VirtualFileSystem self)\n"
  "\n"
  "/**\n"
  " * Returns the number of individual mounts in the system.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_get_num_mounts_645_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< VirtualFileMount > VirtualFileSystem::get_mount(int n) const
 */
static PyObject *Dtool_VirtualFileSystem_get_mount_646(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSystem)) {
    return nullptr;
  }
  // 1-PointerTo< VirtualFileMount > VirtualFileSystem::get_mount(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< VirtualFileMount > return_value = ((*(const VirtualFileSystem*)local_this).get_mount)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    VirtualFileMount *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_VirtualFileMount, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_mount(VirtualFileSystem self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_get_mount_646_comment =
  "C++ Interface:\n"
  "get_mount(VirtualFileSystem self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth mount in the system.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_get_mount_646_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool VirtualFileSystem::chdir(Filename const &new_directory)
 */
static PyObject *Dtool_VirtualFileSystem_chdir_659(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.chdir")) {
    return nullptr;
  }
  // 1-bool VirtualFileSystem::chdir(Filename const &new_directory)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.chdir", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).chdir)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "chdir(const VirtualFileSystem self, const Filename new_directory)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_chdir_659_comment =
  "C++ Interface:\n"
  "chdir(const VirtualFileSystem self, const Filename new_directory)\n"
  "\n"
  "/**\n"
  " * Changes the current directory.  This is used to resolve relative pathnames\n"
  " * in get_file() and/or find_file().  Returns true if successful, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_chdir_659_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Filename VirtualFileSystem::get_cwd(void) const
 */
static PyObject *Dtool_VirtualFileSystem_get_cwd_660(PyObject *self, PyObject *) {
  VirtualFileSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSystem)) {
    return nullptr;
  }
  // 1-Filename VirtualFileSystem::get_cwd(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  Filename *return_value = new Filename(((*(const VirtualFileSystem*)local_this).get_cwd)());
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_get_cwd_660_comment =
  "C++ Interface:\n"
  "get_cwd(VirtualFileSystem self)\n"
  "\n"
  "/**\n"
  " * Returns the current directory name.  See chdir().\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_get_cwd_660_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool VirtualFileSystem::make_directory(Filename const &filename)
 */
static PyObject *Dtool_VirtualFileSystem_make_directory_661(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.make_directory")) {
    return nullptr;
  }
  // 1-bool VirtualFileSystem::make_directory(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.make_directory", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).make_directory)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_directory(const VirtualFileSystem self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_make_directory_661_comment =
  "C++ Interface:\n"
  "make_directory(const VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Attempts to create a directory within the file system.  Returns true on\n"
  " * success, false on failure (for instance, because the parent directory does\n"
  " * not exist, or is read-only).  If the directory already existed prior to\n"
  " * this call, returns true.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_make_directory_661_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool VirtualFileSystem::make_directory_full(Filename const &filename)
 */
static PyObject *Dtool_VirtualFileSystem_make_directory_full_662(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.make_directory_full")) {
    return nullptr;
  }
  // 1-bool VirtualFileSystem::make_directory_full(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.make_directory_full", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).make_directory_full)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make_directory_full(const VirtualFileSystem self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_make_directory_full_662_comment =
  "C++ Interface:\n"
  "make_directory_full(const VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Attempts to create a directory within the file system.  Will also create\n"
  " * any intervening directories needed.  Returns true on success, false on\n"
  " * failure.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_make_directory_full_662_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< VirtualFile > VirtualFileSystem::get_file(Filename const &filename, bool status_only = false) const
 */
static PyObject *Dtool_VirtualFileSystem_get_file_663(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSystem)) {
    return nullptr;
  }
  // 1-PointerTo< VirtualFile > VirtualFileSystem::get_file(Filename const &filename, bool status_only = false) const
  PyObject *param1;
  PyObject *param2 = Py_False;
  static const char *keyword_list[] = {"filename", "status_only", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:get_file", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.get_file", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    PointerTo< VirtualFile > return_value = ((*(const VirtualFileSystem*)local_this).get_file)(*param1_this, (PyObject_IsTrue(param2) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    VirtualFile *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_VirtualFile, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_file(VirtualFileSystem self, const Filename filename, bool status_only)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_get_file_663_comment =
  "C++ Interface:\n"
  "get_file(VirtualFileSystem self, const Filename filename, bool status_only)\n"
  "\n"
  "/**\n"
  " * Looks up the file by the indicated name in the file system.  Returns a\n"
  " * VirtualFile pointer representing the file if it is found, or NULL if it is\n"
  " * not.\n"
  " *\n"
  " * If status_only is true, the file will be checked for existence and length\n"
  " * and so on, but the returned file's contents cannot be read.  This is an\n"
  " * optimization which is especially important for certain mount types, for\n"
  " * instance HTTP, for which opening a file to determine its status is\n"
  " * substantially less expensive than opening it to read its contents.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_get_file_663_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< VirtualFile > VirtualFileSystem::create_file(Filename const &filename)
 */
static PyObject *Dtool_VirtualFileSystem_create_file_664(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.create_file")) {
    return nullptr;
  }
  // 1-PointerTo< VirtualFile > VirtualFileSystem::create_file(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.create_file", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PointerTo< VirtualFile > return_value = ((*local_this).create_file)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  VirtualFile *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_VirtualFile, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "create_file(const VirtualFileSystem self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_create_file_664_comment =
  "C++ Interface:\n"
  "create_file(const VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Attempts to create a file by the indicated name in the filesystem, if\n"
  " * possible, and returns it.  If a file by this name already exists, returns\n"
  " * the same thing as get_file().  If the filename is located within a read-\n"
  " * only directory, or the directory doesn't exist, returns NULL.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_create_file_664_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< VirtualFile > VirtualFileSystem::find_file(Filename const &filename, DSearchPath const &searchpath, bool status_only = false) const
 */
static PyObject *Dtool_VirtualFileSystem_find_file_665(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSystem)) {
    return nullptr;
  }
  // 1-PointerTo< VirtualFile > VirtualFileSystem::find_file(Filename const &filename, DSearchPath const &searchpath, bool status_only = false) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3 = Py_False;
  static const char *keyword_list[] = {"filename", "searchpath", "status_only", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|O:find_file", (char **)keyword_list, &param1, &param2, &param3)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.find_file", "Filename");
    }
    DSearchPath param2_local;
    DSearchPath const *param2_this = Dtool_Coerce_DSearchPath(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "VirtualFileSystem.find_file", "DSearchPath");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    PointerTo< VirtualFile > return_value = ((*(const VirtualFileSystem*)local_this).find_file)(*param1_this, *param2_this, (PyObject_IsTrue(param3) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    VirtualFile *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_VirtualFile, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_file(VirtualFileSystem self, const Filename filename, const DSearchPath searchpath, bool status_only)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_find_file_665_comment =
  "C++ Interface:\n"
  "find_file(VirtualFileSystem self, const Filename filename, const DSearchPath searchpath, bool status_only)\n"
  "\n"
  "/**\n"
  " * Uses the indicated search path to find the file within the file system.\n"
  " * Returns the first occurrence of the file found, or NULL if the file cannot\n"
  " * be found.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_find_file_665_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool VirtualFileSystem::delete_file(Filename const &filename)
 */
static PyObject *Dtool_VirtualFileSystem_delete_file_666(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.delete_file")) {
    return nullptr;
  }
  // 1-bool VirtualFileSystem::delete_file(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.delete_file", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).delete_file)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "delete_file(const VirtualFileSystem self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_delete_file_666_comment =
  "C++ Interface:\n"
  "delete_file(const VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Attempts to delete the indicated file or directory.  This can remove a\n"
  " * single file or an empty directory.  It will not remove a nonempty\n"
  " * directory.  Returns true on success, false on failure.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_delete_file_666_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool VirtualFileSystem::rename_file(Filename const &orig_filename, Filename const &new_filename)
 */
static PyObject *Dtool_VirtualFileSystem_rename_file_667(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.rename_file")) {
    return nullptr;
  }
  // 1-bool VirtualFileSystem::rename_file(Filename const &orig_filename, Filename const &new_filename)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"orig_filename", "new_filename", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:rename_file", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.rename_file", "Filename");
    }
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "VirtualFileSystem.rename_file", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = ((*local_this).rename_file)(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rename_file(const VirtualFileSystem self, const Filename orig_filename, const Filename new_filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_rename_file_667_comment =
  "C++ Interface:\n"
  "rename_file(const VirtualFileSystem self, const Filename orig_filename, const Filename new_filename)\n"
  "\n"
  "/**\n"
  " * Attempts to move or rename the indicated file or directory.  If the\n"
  " * original file is an ordinary file, it will quietly replace any already-\n"
  " * existing file in the new filename (but not a directory).  If the original\n"
  " * file is a directory, the new filename must not already exist.\n"
  " *\n"
  " * If the file is a directory, the new filename must be within the same mount\n"
  " * point.  If the file is an ordinary file, the new filename may be anywhere;\n"
  " * but if it is not within the same mount point then the rename operation is\n"
  " * automatically performed as a two-step copy-and-delete operation.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_rename_file_667_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool VirtualFileSystem::copy_file(Filename const &orig_filename, Filename const &new_filename)
 */
static PyObject *Dtool_VirtualFileSystem_copy_file_668(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.copy_file")) {
    return nullptr;
  }
  // 1-bool VirtualFileSystem::copy_file(Filename const &orig_filename, Filename const &new_filename)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"orig_filename", "new_filename", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:copy_file", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.copy_file", "Filename");
    }
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "VirtualFileSystem.copy_file", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = ((*local_this).copy_file)(*param1_this, *param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "copy_file(const VirtualFileSystem self, const Filename orig_filename, const Filename new_filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_copy_file_668_comment =
  "C++ Interface:\n"
  "copy_file(const VirtualFileSystem self, const Filename orig_filename, const Filename new_filename)\n"
  "\n"
  "/**\n"
  " * Attempts to copy the contents of the indicated file to the indicated file.\n"
  " * Returns true on success, false on failure.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_copy_file_668_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool VirtualFileSystem::resolve_filename(Filename &filename, DSearchPath const &searchpath, std::string const &default_extension = string()) const
 */
static PyObject *Dtool_VirtualFileSystem_resolve_filename_669(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSystem)) {
    return nullptr;
  }
  // 1-bool VirtualFileSystem::resolve_filename(Filename &filename, DSearchPath const &searchpath, std::string const &default_extension = string()) const
  PyObject *param1;
  PyObject *param2;
  const char *param3_str = "";
  Py_ssize_t param3_len = 0;
  static const char *keyword_list[] = {"filename", "searchpath", "default_extension", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|s#:resolve_filename", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    Filename param1_local;
    Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.resolve_filename", "Filename");
    }
    DSearchPath param2_local;
    DSearchPath const *param2_this = Dtool_Coerce_DSearchPath(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "VirtualFileSystem.resolve_filename", "DSearchPath");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = ((*(const VirtualFileSystem*)local_this).resolve_filename)(*param1_this, *param2_this, std::string(param3_str, param3_len));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "resolve_filename(VirtualFileSystem self, Filename filename, const DSearchPath searchpath, str default_extension)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_resolve_filename_669_comment =
  "C++ Interface:\n"
  "resolve_filename(VirtualFileSystem self, Filename filename, const DSearchPath searchpath, str default_extension)\n"
  "\n"
  "/**\n"
  " * Searches the given search path for the filename.  If it is found, updates\n"
  " * the filename to the full pathname found and returns true; otherwise,\n"
  " * returns false.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_resolve_filename_669_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int VirtualFileSystem::find_all_files(Filename const &filename, DSearchPath const &searchpath, DSearchPath::Results &results) const
 */
static PyObject *Dtool_VirtualFileSystem_find_all_files_670(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSystem)) {
    return nullptr;
  }
  // 1-int VirtualFileSystem::find_all_files(Filename const &filename, DSearchPath const &searchpath, DSearchPath::Results &results) const
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"filename", "searchpath", "results", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:find_all_files", (char **)keyword_list, &param1, &param2, &param3)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.find_all_files", "Filename");
    }
    DSearchPath param2_local;
    DSearchPath const *param2_this = Dtool_Coerce_DSearchPath(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "VirtualFileSystem.find_all_files", "DSearchPath");
    }
    DSearchPath::Results *param3_this = (DSearchPath::Results *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_DSearchPath_Results, 3, "VirtualFileSystem.find_all_files", false, true);
    if (param3_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      int return_value = ((*(const VirtualFileSystem*)local_this).find_all_files)(*param1_this, *param2_this, *param3_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
      Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_all_files(VirtualFileSystem self, const Filename filename, const DSearchPath searchpath, Results results)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_find_all_files_670_comment =
  "C++ Interface:\n"
  "find_all_files(VirtualFileSystem self, const Filename filename, const DSearchPath searchpath, Results results)\n"
  "\n"
  "/**\n"
  " * Searches all the directories in the search list for the indicated file, in\n"
  " * order.  Fills up the results list with *all* of the matching filenames\n"
  " * found, if any.  Returns the number of matches found.\n"
  " *\n"
  " * It is the responsibility of the the caller to clear the results list first;\n"
  " * otherwise, the newly-found files will be appended to the list.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_find_all_files_670_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool VirtualFileSystem::exists(Filename const &filename) const
 */
static PyObject *Dtool_VirtualFileSystem_exists_671(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSystem)) {
    return nullptr;
  }
  // 1-inline bool VirtualFileSystem::exists(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.exists", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*(const VirtualFileSystem*)local_this).exists)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "exists(VirtualFileSystem self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_exists_671_comment =
  "C++ Interface:\n"
  "exists(VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Convenience function; returns true if the named file exists.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_exists_671_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool VirtualFileSystem::is_directory(Filename const &filename) const
 */
static PyObject *Dtool_VirtualFileSystem_is_directory_672(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSystem)) {
    return nullptr;
  }
  // 1-inline bool VirtualFileSystem::is_directory(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.is_directory", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*(const VirtualFileSystem*)local_this).is_directory)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_directory(VirtualFileSystem self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_is_directory_672_comment =
  "C++ Interface:\n"
  "is_directory(VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Convenience function; returns true if the named file exists and is a\n"
  " * directory.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_is_directory_672_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool VirtualFileSystem::is_regular_file(Filename const &filename) const
 */
static PyObject *Dtool_VirtualFileSystem_is_regular_file_673(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSystem)) {
    return nullptr;
  }
  // 1-inline bool VirtualFileSystem::is_regular_file(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.is_regular_file", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*(const VirtualFileSystem*)local_this).is_regular_file)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_regular_file(VirtualFileSystem self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_is_regular_file_673_comment =
  "C++ Interface:\n"
  "is_regular_file(VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Convenience function; returns true if the named file exists and is a\n"
  " * regular file.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_is_regular_file_673_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< VirtualFileList > VirtualFileSystem::scan_directory(Filename const &filename) const
 */
static PyObject *Dtool_VirtualFileSystem_scan_directory_674(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSystem)) {
    return nullptr;
  }
  // 1-inline PointerTo< VirtualFileList > VirtualFileSystem::scan_directory(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.scan_directory", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  PointerTo< VirtualFileList > return_value = ((*(const VirtualFileSystem*)local_this).scan_directory)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  VirtualFileList *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_VirtualFileList, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "scan_directory(VirtualFileSystem self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_scan_directory_674_comment =
  "C++ Interface:\n"
  "scan_directory(VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * If the file represents a directory (that is, is_directory() returns true),\n"
  " * this returns the list of files within the directory at the current time.\n"
  " * Returns NULL if the file is not a directory or if the directory cannot be\n"
  " * read.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_scan_directory_674_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void VirtualFileSystem::ls(Filename const &filename) const
 */
static PyObject *Dtool_VirtualFileSystem_ls_675(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSystem)) {
    return nullptr;
  }
  // 1-inline void VirtualFileSystem::ls(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.ls", "Filename");
  }
  ((*(const VirtualFileSystem*)local_this).ls)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ls(VirtualFileSystem self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_ls_675_comment =
  "C++ Interface:\n"
  "ls(VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Convenience function; lists the files within the indicated directory.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_ls_675_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void VirtualFileSystem::ls_all(Filename const &filename) const
 */
static PyObject *Dtool_VirtualFileSystem_ls_all_676(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSystem)) {
    return nullptr;
  }
  // 1-inline void VirtualFileSystem::ls_all(Filename const &filename) const
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.ls_all", "Filename");
  }
  ((*(const VirtualFileSystem*)local_this).ls_all)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ls_all(VirtualFileSystem self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_ls_all_676_comment =
  "C++ Interface:\n"
  "ls_all(VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Convenience function; lists the files within the indicated directory, and\n"
  " * all files below, recursively.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_ls_all_676_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void VirtualFileSystem::write(std::ostream &out) const
 */
static PyObject *Dtool_VirtualFileSystem_write_677(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSystem)) {
    return nullptr;
  }
  // 1-void VirtualFileSystem::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "VirtualFileSystem.write", false, true);
  if (arg_this != nullptr) {
    ((*(const VirtualFileSystem*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(VirtualFileSystem self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_write_677_comment =
  "C++ Interface:\n"
  "write(VirtualFileSystem self, ostream out)\n"
  "\n"
  "/**\n"
  " * Print debugging information.  (e.g.  from Python or gdb prompt).\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_write_677_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static VirtualFileSystem *VirtualFileSystem::get_global_ptr(void)
 */
static PyObject *Dtool_VirtualFileSystem_get_global_ptr_678(PyObject *, PyObject *) {
  // 1-static VirtualFileSystem *VirtualFileSystem::get_global_ptr(void)
  VirtualFileSystem *return_value = (VirtualFileSystem::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_VirtualFileSystem, false, false);
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_get_global_ptr_678_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns the default global VirtualFileSystem.  You may create your own\n"
  " * personal VirtualFileSystem objects and use them for whatever you like, but\n"
  " * Panda will attempt to load models and stuff from this default object.\n"
  " *\n"
  " * Initially, the global VirtualFileSystem is set up to mount the OS\n"
  " * filesystem to root; i.e.  it is equivalent to the OS filesystem.  This may\n"
  " * be subsequently adjusted by the user.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_get_global_ptr_678_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *VirtualFileSystem::read_file(Filename const &filename, bool auto_unwrap) const
 */
static PyObject *Dtool_VirtualFileSystem_read_file_679(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSystem)) {
    return nullptr;
  }
  // 1-PyObject *VirtualFileSystem::read_file(Filename const &filename, bool auto_unwrap) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"filename", "auto_unwrap", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:read_file", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.read_file", "Filename");
    }
    PyObject *return_value = invoke_extension((const VirtualFileSystem*)local_this).read_file(*param1_this, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_file(VirtualFileSystem self, const Filename filename, bool auto_unwrap)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_read_file_679_comment =
  "C++ Interface:\n"
  "read_file(VirtualFileSystem self, const Filename filename, bool auto_unwrap)\n"
  "\n"
  "/**\n"
  " * Convenience function; returns the entire contents of the indicated file as\n"
  " * a string.\n"
  " *\n"
  " * If auto_unwrap is true, an explicitly-named .pz/.gz file is automatically\n"
  " * decompressed and the decompressed contents are returned.  This is different\n"
  " * than vfs-implicit-pz, which will automatically decompress a file if the\n"
  " * extension .pz is *not* given.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Convenience function; fills the string up with the data from the indicated\n"
  " * file, if it exists and can be read.  Returns true on success, false\n"
  " * otherwise.\n"
  " *\n"
  " * If auto_unwrap is true, an explicitly-named .pz/.gz file is automatically\n"
  " * decompressed and the decompressed contents are returned.  This is different\n"
  " * than vfs-implicit-pz, which will automatically decompress a file if the\n"
  " * extension .pz is *not* given.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Convenience function; fills the pvector up with the data from the indicated\n"
  " * file, if it exists and can be read.  Returns true on success, false\n"
  " * otherwise.\n"
  " *\n"
  " * If auto_unwrap is true, an explicitly-named .pz/.gz file is automatically\n"
  " * decompressed and the decompressed contents are returned.  This is different\n"
  " * than vfs-implicit-pz, which will automatically decompress a file if the\n"
  " * extension .pz is *not* given.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_read_file_679_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::istream *VirtualFileSystem::open_read_file(Filename const &filename, bool auto_unwrap) const
 */
static PyObject *Dtool_VirtualFileSystem_open_read_file_680(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_VirtualFileSystem)) {
    return nullptr;
  }
  // 1-std::istream *VirtualFileSystem::open_read_file(Filename const &filename, bool auto_unwrap) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"filename", "auto_unwrap", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:open_read_file", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.open_read_file", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    std::istream *return_value = ((*(const VirtualFileSystem*)local_this).open_read_file)(*param1_this, (PyObject_IsTrue(param2) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_istream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_file(VirtualFileSystem self, const Filename filename, bool auto_unwrap)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_open_read_file_680_comment =
  "C++ Interface:\n"
  "open_read_file(VirtualFileSystem self, const Filename filename, bool auto_unwrap)\n"
  "\n"
  "/**\n"
  " * Convenience function; returns a newly allocated istream if the file exists\n"
  " * and can be read, or NULL otherwise.  Does not return an invalid istream.\n"
  " *\n"
  " * If auto_unwrap is true, an explicitly-named .pz file is automatically\n"
  " * decompressed and the decompressed contents are returned.  This is different\n"
  " * than vfs-implicit-pz, which will automatically decompress a file if the\n"
  " * extension .pz is *not* given.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_open_read_file_680_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void VirtualFileSystem::close_read_file(std::istream *stream)
 */
static PyObject *Dtool_VirtualFileSystem_close_read_file_681(PyObject *, PyObject *arg) {
  // 1-static void VirtualFileSystem::close_read_file(std::istream *stream)
  std::istream *arg_this = (std::istream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_istream, 0, "VirtualFileSystem.close_read_file", false, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (VirtualFileSystem::close_read_file)(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_read_file(istream stream)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_close_read_file_681_comment =
  "C++ Interface:\n"
  "close_read_file(istream stream)\n"
  "\n"
  "/**\n"
  " * Closes a file opened by a previous call to open_read_file().  This really\n"
  " * just deletes the istream pointer, but it is recommended to use this\n"
  " * interface instead of deleting it explicitly, to help work around compiler\n"
  " * issues.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_close_read_file_681_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *VirtualFileSystem::write_file(Filename const &filename, PyObject *data, bool auto_wrap)
 */
static PyObject *Dtool_VirtualFileSystem_write_file_682(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.write_file")) {
    return nullptr;
  }
  // 1-PyObject *VirtualFileSystem::write_file(Filename const &filename, PyObject *data, bool auto_wrap)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"filename", "data", "auto_wrap", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:write_file", (char **)keyword_list, &param1, &param2, &param3)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.write_file", "Filename");
    }
    PyObject *return_value = invoke_extension(local_this).write_file(*param1_this, param2, (PyObject_IsTrue(param3) != 0));
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_file(const VirtualFileSystem self, const Filename filename, object data, bool auto_wrap)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_write_file_682_comment =
  "C++ Interface:\n"
  "write_file(const VirtualFileSystem self, const Filename filename, object data, bool auto_wrap)\n"
  "\n"
  "/**\n"
  " * Convenience function; writes the entire contents of the indicated file as a\n"
  " * string.\n"
  " *\n"
  " * If auto_wrap is true, an explicitly-named .pz file is automatically\n"
  " * compressed while writing.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Convenience function; writes the entire contents of the indicated file as a\n"
  " * block of data.\n"
  " *\n"
  " * If auto_wrap is true, an explicitly-named .pz file is automatically\n"
  " * compressed while writing.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_write_file_682_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::ostream *VirtualFileSystem::open_write_file(Filename const &filename, bool auto_wrap, bool truncate)
 */
static PyObject *Dtool_VirtualFileSystem_open_write_file_683(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.open_write_file")) {
    return nullptr;
  }
  // 1-std::ostream *VirtualFileSystem::open_write_file(Filename const &filename, bool auto_wrap, bool truncate)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"filename", "auto_wrap", "truncate", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:open_write_file", (char **)keyword_list, &param1, &param2, &param3)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.open_write_file", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    std::ostream *return_value = ((*local_this).open_write_file)(*param1_this, (PyObject_IsTrue(param2) != 0), (PyObject_IsTrue(param3) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_write_file(const VirtualFileSystem self, const Filename filename, bool auto_wrap, bool truncate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_open_write_file_683_comment =
  "C++ Interface:\n"
  "open_write_file(const VirtualFileSystem self, const Filename filename, bool auto_wrap, bool truncate)\n"
  "\n"
  "/**\n"
  " * Convenience function; returns a newly allocated ostream if the file exists\n"
  " * and can be written, or NULL otherwise.  Does not return an invalid ostream.\n"
  " *\n"
  " * If auto_wrap is true, an explicitly-named .pz file is automatically\n"
  " * compressed while writing.  If truncate is true, the file is truncated to\n"
  " * zero length before writing.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_open_write_file_683_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::ostream *VirtualFileSystem::open_append_file(Filename const &filename)
 */
static PyObject *Dtool_VirtualFileSystem_open_append_file_684(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.open_append_file")) {
    return nullptr;
  }
  // 1-std::ostream *VirtualFileSystem::open_append_file(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.open_append_file", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  std::ostream *return_value = ((*local_this).open_append_file)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_append_file(const VirtualFileSystem self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_open_append_file_684_comment =
  "C++ Interface:\n"
  "open_append_file(const VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Works like open_write_file(), but the file is opened in append mode.  Like\n"
  " * open_write_file, the returned pointer should eventually be passed to\n"
  " * close_write_file().\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_open_append_file_684_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void VirtualFileSystem::close_write_file(std::ostream *stream)
 */
static PyObject *Dtool_VirtualFileSystem_close_write_file_685(PyObject *, PyObject *arg) {
  // 1-static void VirtualFileSystem::close_write_file(std::ostream *stream)
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 0, "VirtualFileSystem.close_write_file", false, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (VirtualFileSystem::close_write_file)(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_write_file(ostream stream)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_close_write_file_685_comment =
  "C++ Interface:\n"
  "close_write_file(ostream stream)\n"
  "\n"
  "/**\n"
  " * Closes a file opened by a previous call to open_write_file().  This really\n"
  " * just deletes the ostream pointer, but it is recommended to use this\n"
  " * interface instead of deleting it explicitly, to help work around compiler\n"
  " * issues.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_close_write_file_685_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::iostream *VirtualFileSystem::open_read_write_file(Filename const &filename, bool truncate)
 */
static PyObject *Dtool_VirtualFileSystem_open_read_write_file_686(PyObject *self, PyObject *args, PyObject *kwds) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.open_read_write_file")) {
    return nullptr;
  }
  // 1-std::iostream *VirtualFileSystem::open_read_write_file(Filename const &filename, bool truncate)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"filename", "truncate", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:open_read_write_file", (char **)keyword_list, &param1, &param2)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "VirtualFileSystem.open_read_write_file", "Filename");
    }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    std::iostream *return_value = ((*local_this).open_read_write_file)(*param1_this, (PyObject_IsTrue(param2) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_iostream, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_write_file(const VirtualFileSystem self, const Filename filename, bool truncate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_open_read_write_file_686_comment =
  "C++ Interface:\n"
  "open_read_write_file(const VirtualFileSystem self, const Filename filename, bool truncate)\n"
  "\n"
  "/**\n"
  " * Convenience function; returns a newly allocated iostream if the file exists\n"
  " * and can be written, or NULL otherwise.  Does not return an invalid\n"
  " * iostream.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_open_read_write_file_686_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::iostream *VirtualFileSystem::open_read_append_file(Filename const &filename)
 */
static PyObject *Dtool_VirtualFileSystem_open_read_append_file_687(PyObject *self, PyObject *arg) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_VirtualFileSystem, (void **)&local_this, "VirtualFileSystem.open_read_append_file")) {
    return nullptr;
  }
  // 1-std::iostream *VirtualFileSystem::open_read_append_file(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "VirtualFileSystem.open_read_append_file", "Filename");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  std::iostream *return_value = ((*local_this).open_read_append_file)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_iostream, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_read_append_file(const VirtualFileSystem self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_open_read_append_file_687_comment =
  "C++ Interface:\n"
  "open_read_append_file(const VirtualFileSystem self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Works like open_read_write_file(), but the file is opened in append mode.\n"
  " * Like open_read_write_file, the returned pointer should eventually be passed\n"
  " * to close_read_write_file().\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_open_read_append_file_687_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void VirtualFileSystem::close_read_write_file(std::iostream *stream)
 */
static PyObject *Dtool_VirtualFileSystem_close_read_write_file_688(PyObject *, PyObject *arg) {
  // 1-static void VirtualFileSystem::close_read_write_file(std::iostream *stream)
  std::iostream *arg_this = (std::iostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_iostream, 0, "VirtualFileSystem.close_read_write_file", false, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    (VirtualFileSystem::close_read_write_file)(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_read_write_file(iostream stream)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_VirtualFileSystem_close_read_write_file_688_comment =
  "C++ Interface:\n"
  "close_read_write_file(iostream stream)\n"
  "\n"
  "/**\n"
  " * Closes a file opened by a previous call to open_read_write_file().  This\n"
  " * really just deletes the iostream pointer, but it is recommended to use this\n"
  " * interface instead of deleting it explicitly, to help work around compiler\n"
  " * issues.\n"
  " */";
#else
static const char *Dtool_VirtualFileSystem_close_read_write_file_688_comment = nullptr;
#endif

/**
 * sequence length function for property VirtualFileSystem::mounts
 */
static Py_ssize_t Dtool_VirtualFileSystem_mounts_Len(PyObject *self) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_mounts)();
}

/**
 * sequence getter for property VirtualFileSystem::mounts
 */
static PyObject *Dtool_VirtualFileSystem_mounts_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_mounts)()) {
    PyErr_SetString(PyExc_IndexError, "VirtualFileSystem.mounts[] index out of range");
    return nullptr;
  }
  // 1-PointerTo< VirtualFileMount > VirtualFileSystem::get_mount(int n) const
  PointerTo< VirtualFileMount > return_value = ((*(const VirtualFileSystem*)local_this).get_mount)(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  VirtualFileMount *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_VirtualFileMount, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_mount(VirtualFileSystem self, index)\n");
  }
}

static PyObject *Dtool_VirtualFileSystem_mounts_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "VirtualFileSystem.mounts");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_VirtualFileSystem_mounts_Len;
    wrap->_getitem_func = &Dtool_VirtualFileSystem_mounts_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * VirtualFileSystem::VirtualFileSystem(void)
 */
static int Dtool_Init_VirtualFileSystem(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("VirtualFileSystem() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "VirtualFileSystem() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-VirtualFileSystem::VirtualFileSystem(void)
  VirtualFileSystem *return_value = new VirtualFileSystem();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_VirtualFileSystem, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "VirtualFileSystem()\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_VirtualFileSystem_get_mounts(PyObject *self, PyObject *) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_mounts)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_VirtualFileSystem_get_mount_646(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_VirtualFileSystem(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_VirtualFileSystem) {
    printf("VirtualFileSystem ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  VirtualFileSystem *local_this = (VirtualFileSystem *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_VirtualFileSystem) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_VirtualFileSystem(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_VirtualFileSystem) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerTo< VirtualFileMount >
 */
/**
 * Python function wrapper for:
 * constexpr VirtualFileMount *PointerTo< VirtualFileMount >::p(void) const noexcept
 */
static PyObject *Dtool_PointerTo_VirtualFileMount_p_654(PyObject *self, PyObject *) {
  PointerTo< VirtualFileMount > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerTo_VirtualFileMount)) {
    return nullptr;
  }
  // 1-constexpr VirtualFileMount *PointerTo< VirtualFileMount >::p(void) const noexcept
  VirtualFileMount *return_value = ((*(const PointerTo< VirtualFileMount >*)local_this).p)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VirtualFileMount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PointerTo_VirtualFileMount_p_654_comment =
  "C++ Interface:\n"
  "p(PointerTo self)\n"
  "\n"
  "// If your base class is a derivative of TypedObject, you might want to use\n"
  "// the DCAST macro defined in typedObject.h instead, e.g.  DCAST(MyType,\n"
  "// ptr).  This provides a clean downcast that doesn't require .p() or any\n"
  "// double-casting, and it can be run-time checked for correctness.";
#else
static const char *Dtool_PointerTo_VirtualFileMount_p_654_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerTo< VirtualFileMount >::operator =(PointerTo< VirtualFileMount > const &copy)
 * inline void PointerTo< VirtualFileMount >::operator =(VirtualFileMount *ptr)
 */
static PyObject *Dtool_PointerTo_VirtualFileMount_operator_655(PyObject *self, PyObject *arg) {
  PointerTo< VirtualFileMount > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerTo_VirtualFileMount, (void **)&local_this, "PointerTo_VirtualFileMount.assign")) {
    return nullptr;
  }
  {
    // -2 inline void PointerTo< VirtualFileMount >::operator =(PointerTo< VirtualFileMount > const &copy)
    VirtualFileMount *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_VirtualFileMount);
    if (arg_this != nullptr) {
      ((*local_this).operator =)(arg_this);
      PointerTo< VirtualFileMount > *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerTo_VirtualFileMount, false, false);
    }
  }

  {
    // -2 inline void PointerTo< VirtualFileMount >::operator =(VirtualFileMount *ptr)
    VirtualFileMount *arg_this = (VirtualFileMount *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VirtualFileMount, 1, "PointerTo.assign", false, false);
    if (arg_this != nullptr) {
      ((*local_this).operator =)(arg_this);
      PointerTo< VirtualFileMount > *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerTo_VirtualFileMount, false, false);
    }
  }

  // No coercion possible: inline void PointerTo< VirtualFileMount >::operator =(PointerTo< VirtualFileMount > const &copy)
  // No coercion possible: inline void PointerTo< VirtualFileMount >::operator =(VirtualFileMount *ptr)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PointerTo self, const VirtualFileMount copy)\n"
      "assign(const PointerTo self, VirtualFileMount ptr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerTo_VirtualFileMount_operator_655_comment =
  "C++ Interface:\n"
  "assign(const PointerTo self, const VirtualFileMount copy)\n"
  "assign(const PointerTo self, VirtualFileMount ptr)\n";
#else
static const char *Dtool_PointerTo_VirtualFileMount_operator_655_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PointerTo< VirtualFileMount >::is_null(void) const
 */
static PyObject *Dtool_PointerTo_VirtualFileMount_is_null_656(PyObject *self, PyObject *) {
  PointerTo< VirtualFileMount > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerTo_VirtualFileMount)) {
    return nullptr;
  }
  // 1-inline bool PointerTo< VirtualFileMount >::is_null(void) const
  bool return_value = ((*(const PointerTo< VirtualFileMount >*)local_this).is_null)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerTo_VirtualFileMount_is_null_656_comment =
  "C++ Interface:\n"
  "is_null(PointerTo self)\n";
#else
static const char *Dtool_PointerTo_VirtualFileMount_is_null_656_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerTo< VirtualFileMount >::clear(void)
 */
static PyObject *Dtool_PointerTo_VirtualFileMount_clear_657(PyObject *self, PyObject *) {
  PointerTo< VirtualFileMount > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerTo_VirtualFileMount, (void **)&local_this, "PointerTo_VirtualFileMount.clear")) {
    return nullptr;
  }
  // 1-inline void PointerTo< VirtualFileMount >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerTo_VirtualFileMount_clear_657_comment =
  "C++ Interface:\n"
  "clear(const PointerTo self)\n";
#else
static const char *Dtool_PointerTo_VirtualFileMount_clear_657_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline constexpr PointerTo< VirtualFileMount >::PointerTo(void) noexcept = default
 * inline PointerTo< VirtualFileMount >::PointerTo(PointerTo< VirtualFileMount > const &copy)
 * inline PointerTo< VirtualFileMount >::PointerTo(VirtualFileMount *ptr) noexcept
 * inline explicit constexpr PointerTo< VirtualFileMount >::PointerTo(decltype(nullptr) ) noexcept
 */
static int Dtool_Init_PointerTo_VirtualFileMount(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline constexpr PointerTo< VirtualFileMount >::PointerTo(void) noexcept = default
      PointerTo< VirtualFileMount > *return_value = new PointerTo< VirtualFileMount >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerTo_VirtualFileMount, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerTo< VirtualFileMount >::PointerTo(PointerTo< VirtualFileMount > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          VirtualFileMount *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_VirtualFileMount);
          if (param0_this != nullptr) {
            PointerTo< VirtualFileMount > *return_value = new PointerTo< VirtualFileMount >(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerTo_VirtualFileMount, true, false);
          }
        }
      }

      {
        // -2 inline PointerTo< VirtualFileMount >::PointerTo(VirtualFileMount *ptr) noexcept
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "ptr")) {
          VirtualFileMount *param0_this = (VirtualFileMount *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_VirtualFileMount, 0, "PointerTo.PointerTo", false, false);
          if (param0_this != nullptr) {
            PointerTo< VirtualFileMount > *return_value = new PointerTo< VirtualFileMount >(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerTo_VirtualFileMount, true, false);
          }
        }
      }

      {
        // -2 inline explicit constexpr PointerTo< VirtualFileMount >::PointerTo(decltype(nullptr) ) noexcept
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          if (param0 == Py_None) {
            PointerTo< VirtualFileMount > *return_value = new PointerTo< VirtualFileMount >(nullptr);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerTo_VirtualFileMount, true, false);
          }
        }
      }

      // No coercion possible: inline PointerTo< VirtualFileMount >::PointerTo(PointerTo< VirtualFileMount > const &copy)
      // No coercion possible: inline PointerTo< VirtualFileMount >::PointerTo(VirtualFileMount *ptr) noexcept
      // No coercion possible: inline explicit constexpr PointerTo< VirtualFileMount >::PointerTo(decltype(nullptr) ) noexcept
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerTo() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerTo()\n"
      "PointerTo(const VirtualFileMount copy)\n"
      "PointerTo(VirtualFileMount ptr)\n"
      "PointerTo(NoneType param0)\n");
  }
  return -1;
}

PointerTo< VirtualFileMount > *Dtool_Coerce_PointerTo_VirtualFileMount(PyObject *args, PointerTo< VirtualFileMount > &coerced) {
  PointerTo< VirtualFileMount > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerTo_VirtualFileMount)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerTo< VirtualFileMount > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline PointerTo< VirtualFileMount >::PointerTo(VirtualFileMount *ptr) noexcept
    VirtualFileMount *arg_this = (VirtualFileMount *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VirtualFileMount, 0, "PointerTo.PointerTo", false, false);
    if (arg_this != nullptr) {
      coerced = PointerTo< VirtualFileMount >(arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerTo_VirtualFileMount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerTo_VirtualFileMount) {
    printf("PointerTo_VirtualFileMount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerTo< VirtualFileMount > *local_this = (PointerTo< VirtualFileMount > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerTo_VirtualFileMount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_VirtualFileMount) {
    return (PointerToBase< VirtualFileMount > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< VirtualFileMount > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerTo_VirtualFileMount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerTo_VirtualFileMount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_VirtualFileMount) {
    PointerToBase< VirtualFileMount >* other_this = (PointerToBase< VirtualFileMount >*)from_this;
    return (PointerTo< VirtualFileMount >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerTo< VirtualFileMount >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< VirtualFileMount >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< VirtualFileMount >::clear(void)
 */
static PyObject *Dtool_PointerToBase_VirtualFileMount_clear_651(PyObject *self, PyObject *) {
  PointerToBase< VirtualFileMount > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_VirtualFileMount, (void **)&local_this, "PointerToBase_VirtualFileMount.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< VirtualFileMount >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_VirtualFileMount_clear_651_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_VirtualFileMount_clear_651_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< VirtualFileMount >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_VirtualFileMount_output_652(PyObject *self, PyObject *arg) {
  PointerToBase< VirtualFileMount > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_VirtualFileMount)) {
    return nullptr;
  }
  // 1-void PointerToBase< VirtualFileMount >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< VirtualFileMount >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_VirtualFileMount_output_652_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_VirtualFileMount_output_652_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_VirtualFileMount(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_VirtualFileMount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_VirtualFileMount) {
    printf("PointerToBase_VirtualFileMount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< VirtualFileMount > *local_this = (PointerToBase< VirtualFileMount > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_VirtualFileMount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_VirtualFileMount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_VirtualFileMount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< VirtualFileMount >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class StringStream
 */
/**
 * Python function wrapper for:
 * inline void StringStream::clear_data(void)
 */
static PyObject *Dtool_StringStream_clear_data_691(PyObject *self, PyObject *) {
  StringStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StringStream, (void **)&local_this, "StringStream.clear_data")) {
    return nullptr;
  }
  // 1-inline void StringStream::clear_data(void)
  ((*local_this).clear_data)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_StringStream_clear_data_691_comment =
  "C++ Interface:\n"
  "clear_data(const StringStream self)\n"
  "\n"
  "/**\n"
  " * Empties the buffer.\n"
  " */";
#else
static const char *Dtool_StringStream_clear_data_691_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t StringStream::get_data_size(void)
 */
static PyObject *Dtool_StringStream_get_data_size_692(PyObject *self, PyObject *) {
  StringStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StringStream, (void **)&local_this, "StringStream.get_data_size")) {
    return nullptr;
  }
  // 1-inline std::size_t StringStream::get_data_size(void)
  std::size_t return_value = ((*local_this).get_data_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StringStream_get_data_size_692_comment =
  "C++ Interface:\n"
  "get_data_size(const StringStream self)\n"
  "\n"
  "/**\n"
  " * Returns the number of characters available to be read from the data stream.\n"
  " */";
#else
static const char *Dtool_StringStream_get_data_size_692_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *StringStream::get_data(void)
 */
static PyObject *Dtool_StringStream_get_data_693(PyObject *self, PyObject *) {
  StringStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StringStream, (void **)&local_this, "StringStream.get_data")) {
    return nullptr;
  }
  // 1-PyObject *StringStream::get_data(void)
  PyObject *return_value = invoke_extension(local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_StringStream_get_data_693_comment =
  "C++ Interface:\n"
  "get_data(const StringStream self)\n"
  "\n"
  "/**\n"
  " * Returns the contents of the data stream as a string.\n"
  " */";
#else
static const char *Dtool_StringStream_get_data_693_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void StringStream::set_data(PyObject *data)
 */
static PyObject *Dtool_StringStream_set_data_694(PyObject *self, PyObject *arg) {
  StringStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StringStream, (void **)&local_this, "StringStream.set_data")) {
    return nullptr;
  }
  // 1-void StringStream::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const StringStream self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_StringStream_set_data_694_comment =
  "C++ Interface:\n"
  "set_data(const StringStream self, object data)\n"
  "\n"
  "/**\n"
  " * Replaces the contents of the data stream.  This implicitly reseeks to 0.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Replaces the contents of the data stream.  This implicitly reseeks to 0.\n"
  " */";
#else
static const char *Dtool_StringStream_set_data_694_comment = nullptr;
#endif

static PyObject *Dtool_StringStream_data_Getter(PyObject *self, void *) {
  StringStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StringStream, (void **)&local_this, "StringStream.data")) {
    return nullptr;
  }

  // 1-PyObject *StringStream::get_data(void)
  PyObject *return_value = invoke_extension(local_this).get_data();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_StringStream_data_Setter(PyObject *self, PyObject *arg, void *) {
  StringStream *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_StringStream, (void **)&local_this, "StringStream.data")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete data attribute");
    return -1;
  }
  // 1-void StringStream::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  if (Dtool_CheckErrorOccurred()) {
    return -1;
  }
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_data(const StringStream self, object data)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline StringStream::StringStream(void)
 * StringStream::StringStream(PyObject *source)
 */
static int Dtool_Init_StringStream(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline StringStream::StringStream(void)
      StringStream *return_value = new StringStream();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StringStream, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "source")) {
        // 1-StringStream::StringStream(PyObject *source)
        StringStream *result = new StringStream;
        invoke_extension(result).__init__(arg);
        StringStream *return_value = result;
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_StringStream, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "StringStream() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "StringStream()\n"
      "StringStream(object source)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_StringStream(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_StringStream) {
    printf("StringStream ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  StringStream *local_this = (StringStream *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_StringStream) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_std_basic_ios_char) {
    return (std::basic_ios< char > *)(std::istream *)(std::iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ios_base) {
    return (std::ios_base *)(std::basic_ios< char > *)(std::istream *)(std::iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_iostream) {
    return (std::iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_istream) {
    return (std::istream *)(std::iostream *) local_this;
  }
  if (requested_type == Dtool_Ptr_std_ostream) {
    return (std::ostream *)(std::iostream *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_StringStream(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_StringStream) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_std_iostream) {
    std::iostream* other_this = (std::iostream*)from_this;
    return (StringStream*)other_this;
  }
  if (from_type == Dtool_Ptr_std_istream) {
    std::istream* other_this = (std::istream*)from_this;
    return (StringStream*)other_this;
  }
  if (from_type == Dtool_Ptr_std_ostream) {
    std::ostream* other_this = (std::ostream*)from_this;
    return (StringStream*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TrueClock
 */
/**
 * Python function wrapper for:
 * double TrueClock::get_long_time(void)
 */
static PyObject *Dtool_TrueClock_get_long_time_701(PyObject *self, PyObject *) {
  TrueClock *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrueClock, (void **)&local_this, "TrueClock.get_long_time")) {
    return nullptr;
  }
  // 1-double TrueClock::get_long_time(void)
  double return_value = ((*local_this).get_long_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrueClock_get_long_time_701_comment =
  "C++ Interface:\n"
  "get_long_time(const TrueClock self)\n"
  "\n"
  "// get_long_time() returns the most accurate timer we have over a long\n"
  "// interval.  It may not be very precise for measuring short intervals, but\n"
  "// it should not drift substantially over the long haul.\n"
  "\n"
  "// get_long_time() returns the most accurate timer we have over a long\n"
  "// interval.  It may not be very precise for measuring short intervals, but\n"
  "// it should not drift substantially over the long haul.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TrueClock_get_long_time_701_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double TrueClock::get_short_time(void)
 */
static PyObject *Dtool_TrueClock_get_short_time_704(PyObject *self, PyObject *) {
  TrueClock *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrueClock, (void **)&local_this, "TrueClock.get_short_time")) {
    return nullptr;
  }
  // 1-inline double TrueClock::get_short_time(void)
  double return_value = ((*local_this).get_short_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrueClock_get_short_time_704_comment =
  "C++ Interface:\n"
  "get_short_time(const TrueClock self)\n"
  "\n"
  "// get_short_time() returns the most precise timer we have over a short\n"
  "// interval.  It may tend to drift over the long haul, but it should have\n"
  "// lots of digits to measure short intervals very precisely.\n"
  "\n"
  "// get_short_time() returns the most precise timer we have over a short\n"
  "// interval.  It may tend to drift over the long haul, but it should have\n"
  "// lots of digits to measure short intervals very precisely.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TrueClock_get_short_time_704_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double TrueClock::get_short_raw_time(void)
 */
static PyObject *Dtool_TrueClock_get_short_raw_time_706(PyObject *self, PyObject *) {
  TrueClock *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrueClock, (void **)&local_this, "TrueClock.get_short_raw_time")) {
    return nullptr;
  }
  // 1-double TrueClock::get_short_raw_time(void)
  double return_value = ((*local_this).get_short_raw_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrueClock_get_short_raw_time_706_comment =
  "C++ Interface:\n"
  "get_short_raw_time(const TrueClock self)\n"
  "\n"
  "// get_short_raw_time() is like get_short_time(), but does not apply any\n"
  "// corrections (e.g.  paranoid-clock) to the result returned by the OS.\n"
  "\n"
  "// get_short_raw_time() is like get_short_time(), but does not apply any\n"
  "// corrections (e.g.  paranoid-clock) to the result returned by the OS.\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TrueClock_get_short_raw_time_706_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int TrueClock::get_error_count(void) const
 */
static PyObject *Dtool_TrueClock_get_error_count_708(PyObject *self, PyObject *) {
  TrueClock *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TrueClock)) {
    return nullptr;
  }
  // 1-inline int TrueClock::get_error_count(void) const
  int return_value = ((*(const TrueClock*)local_this).get_error_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TrueClock_get_error_count_708_comment =
  "C++ Interface:\n"
  "get_error_count(TrueClock self)\n"
  "\n"
  "/**\n"
  " * Returns the number of clock errors that have been detected.  Each time a\n"
  " * clock error is detected, in which the value returned by either of the above\n"
  " * methods is suspect, the value returned by this method will be incremented.\n"
  " * Applications can monitor this value and react, for instance, by\n"
  " * resynchronizing their clocks each time this value changes.\n"
  " */";
#else
static const char *Dtool_TrueClock_get_error_count_708_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline TrueClock *TrueClock::get_global_ptr(void)
 */
static PyObject *Dtool_TrueClock_get_global_ptr_710(PyObject *, PyObject *) {
  // 1-static inline TrueClock *TrueClock::get_global_ptr(void)
  TrueClock *return_value = (TrueClock::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TrueClock, false, false);
}

#ifndef NDEBUG
static const char *Dtool_TrueClock_get_global_ptr_710_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the one TrueClock object in the world.\n"
  " */";
#else
static const char *Dtool_TrueClock_get_global_ptr_710_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool TrueClock::set_cpu_affinity(uint32_t mask) const
 */
static PyObject *Dtool_TrueClock_set_cpu_affinity_711(PyObject *self, PyObject *arg) {
  TrueClock *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TrueClock)) {
    return nullptr;
  }
  // 1-bool TrueClock::set_cpu_affinity(uint32_t mask) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    bool return_value = ((*(const TrueClock*)local_this).set_cpu_affinity)((uint32_t)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cpu_affinity(TrueClock self, int mask)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TrueClock_set_cpu_affinity_711_comment =
  "C++ Interface:\n"
  "set_cpu_affinity(TrueClock self, int mask)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TrueClock_set_cpu_affinity_711_comment = nullptr;
#endif

static PyObject *Dtool_TrueClock_long_time_Getter(PyObject *self, void *) {
  TrueClock *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrueClock, (void **)&local_this, "TrueClock.long_time")) {
    return nullptr;
  }

  // 1-double TrueClock::get_long_time(void)
  double return_value = ((*local_this).get_long_time)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_TrueClock_short_time_Getter(PyObject *self, void *) {
  TrueClock *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrueClock, (void **)&local_this, "TrueClock.short_time")) {
    return nullptr;
  }

  // 1-inline double TrueClock::get_short_time(void)
  double return_value = ((*local_this).get_short_time)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_TrueClock_short_raw_time_Getter(PyObject *self, void *) {
  TrueClock *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TrueClock, (void **)&local_this, "TrueClock.short_raw_time")) {
    return nullptr;
  }

  // 1-double TrueClock::get_short_raw_time(void)
  double return_value = ((*local_this).get_short_raw_time)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_TrueClock_error_count_Getter(PyObject *self, void *) {
  const TrueClock *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_TrueClock, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int TrueClock::get_error_count(void) const
  int return_value = ((*(const TrueClock*)local_this).get_error_count)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_TrueClock(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TrueClock(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TrueClock) {
    printf("TrueClock ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TrueClock *local_this = (TrueClock *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TrueClock) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TrueClock(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TrueClock) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Patchfile
 */
/**
 * Python function wrapper for:
 * bool Patchfile::build(Filename file_orig, Filename file_new, Filename patch_name)
 */
static PyObject *Dtool_Patchfile_build_715(PyObject *self, PyObject *args, PyObject *kwds) {
  Patchfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.build")) {
    return nullptr;
  }
  // 1-bool Patchfile::build(Filename file_orig, Filename file_new, Filename patch_name)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"file_orig", "file_new", "patch_name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:build", (char **)keyword_list, &param1, &param2, &param3)) {
    Filename param1_local;
    Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "Patchfile.build", "Filename");
    }
    Filename param2_local;
    Filename *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "Patchfile.build", "Filename");
    }
    Filename param3_local;
    Filename *param3_this = Dtool_Coerce_Filename(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "Patchfile.build", "Filename");
    }
    bool return_value = ((*local_this).build)(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "build(const Patchfile self, Filename file_orig, Filename file_new, Filename patch_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_build_715_comment =
  "C++ Interface:\n"
  "build(const Patchfile self, Filename file_orig, Filename file_new, Filename patch_name)\n"
  "\n"
  "/**\n"
  " *\n"
  " * This implementation uses the \"greedy differencing algorithm\" described in\n"
  " * the masters thesis \"Differential Compression: A Generalized Solution for\n"
  " * Binary Files\" by Randal C. Burns (p.13). For an original file of size M and\n"
  " * a new file of size N, this algorithm is O(M) in space and O(M*N) (worst-\n"
  " * case) in time.  return false on error\n"
  " */";
#else
static const char *Dtool_Patchfile_build_715_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Patchfile::read_header(Filename const &patch_file)
 */
static PyObject *Dtool_Patchfile_read_header_716(PyObject *self, PyObject *arg) {
  Patchfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.read_header")) {
    return nullptr;
  }
  // 1-int Patchfile::read_header(Filename const &patch_file)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "Patchfile.read_header", "Filename");
  }
  int return_value = ((*local_this).read_header)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "read_header(const Patchfile self, const Filename patch_file)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_read_header_716_comment =
  "C++ Interface:\n"
  "read_header(const Patchfile self, const Filename patch_file)\n"
  "\n"
  "/**\n"
  " * Opens the patch file for reading, and gets the header information from the\n"
  " * file but does not begin to do any real work.  This can be used to query the\n"
  " * data stored in the patch.\n"
  " */";
#else
static const char *Dtool_Patchfile_read_header_716_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Patchfile::initiate(Filename const &patch_file, Filename const &file)
 * int Patchfile::initiate(Filename const &patch_file, Filename const &orig_file, Filename const &target_file)
 */
static PyObject *Dtool_Patchfile_initiate_717(PyObject *self, PyObject *args, PyObject *kwds) {
  Patchfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.initiate")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-int Patchfile::initiate(Filename const &patch_file, Filename const &file)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"patch_file", "file", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:initiate", (char **)keyword_list, &param1, &param2)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Patchfile.initiate", "Filename");
        }
        Filename param2_local;
        Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "Patchfile.initiate", "Filename");
        }
        int return_value = ((*local_this).initiate)(*param1_this, *param2_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-int Patchfile::initiate(Filename const &patch_file, Filename const &orig_file, Filename const &target_file)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"patch_file", "orig_file", "target_file", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:initiate", (char **)keyword_list, &param1, &param2, &param3)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Patchfile.initiate", "Filename");
        }
        Filename param2_local;
        Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "Patchfile.initiate", "Filename");
        }
        Filename param3_local;
        Filename const *param3_this = Dtool_Coerce_Filename(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "Patchfile.initiate", "Filename");
        }
        int return_value = ((*local_this).initiate)(*param1_this, *param2_this, *param3_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "initiate() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "initiate(const Patchfile self, const Filename patch_file, const Filename file)\n"
      "initiate(const Patchfile self, const Filename patch_file, const Filename orig_file, const Filename target_file)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_initiate_717_comment =
  "C++ Interface:\n"
  "initiate(const Patchfile self, const Filename patch_file, const Filename file)\n"
  "initiate(const Patchfile self, const Filename patch_file, const Filename orig_file, const Filename target_file)\n"
  "\n"
  "/**\n"
  " * Set up to apply the patch to the file (original file and patch are\n"
  " * destroyed in the process).\n"
  " */\n"
  "\n"
  "/**\n"
  " * Set up to apply the patch to the file.  In this form, neither the original\n"
  " * file nor the patch file are destroyed.\n"
  " */";
#else
static const char *Dtool_Patchfile_initiate_717_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int Patchfile::run(void)
 */
static PyObject *Dtool_Patchfile_run_718(PyObject *self, PyObject *) {
  Patchfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.run")) {
    return nullptr;
  }
  // 1-int Patchfile::run(void)
  int return_value = ((*local_this).run)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_run_718_comment =
  "C++ Interface:\n"
  "run(const Patchfile self)\n"
  "\n"
  "/**\n"
  " * Perform one buffer's worth of patching Returns EU_ok while patching Returns\n"
  " * EU_success when done If error happens will return one of: EU_error_abort :\n"
  " * Patching has not been initiated EU_error_file_invalid : file is corrupted\n"
  " * EU_error_invalid_checksum : incompatible patch file\n"
  " * EU_error_write_file_rename : could not rename file\n"
  " */";
#else
static const char *Dtool_Patchfile_run_718_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Patchfile::apply(Filename &patch_file, Filename &file)
 * bool Patchfile::apply(Filename &patch_file, Filename &orig_file, Filename const &target_file)
 */
static PyObject *Dtool_Patchfile_apply_719(PyObject *self, PyObject *args, PyObject *kwds) {
  Patchfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.apply")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-bool Patchfile::apply(Filename &patch_file, Filename &file)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"patch_file", "file", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:apply", (char **)keyword_list, &param1, &param2)) {
        Filename param1_local;
        Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Patchfile.apply", "Filename");
        }
        Filename param2_local;
        Filename *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "Patchfile.apply", "Filename");
        }
        bool return_value = ((*local_this).apply)(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-bool Patchfile::apply(Filename &patch_file, Filename &orig_file, Filename const &target_file)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"patch_file", "orig_file", "target_file", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:apply", (char **)keyword_list, &param1, &param2, &param3)) {
        Filename param1_local;
        Filename *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "Patchfile.apply", "Filename");
        }
        Filename param2_local;
        Filename *param2_this = Dtool_Coerce_Filename(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "Patchfile.apply", "Filename");
        }
        Filename param3_local;
        Filename const *param3_this = Dtool_Coerce_Filename(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "Patchfile.apply", "Filename");
        }
        bool return_value = ((*local_this).apply)(*param1_this, *param2_this, *param3_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "apply() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply(const Patchfile self, Filename patch_file, Filename file)\n"
      "apply(const Patchfile self, Filename patch_file, Filename orig_file, const Filename target_file)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_apply_719_comment =
  "C++ Interface:\n"
  "apply(const Patchfile self, Filename patch_file, Filename file)\n"
  "apply(const Patchfile self, Filename patch_file, Filename orig_file, const Filename target_file)\n"
  "\n"
  "/**\n"
  " * Patches the entire file in one call returns true on success and false on\n"
  " * error\n"
  " *\n"
  " * This version will delete the patch file and overwrite the original file.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Patches the entire file in one call returns true on success and false on\n"
  " * error\n"
  " *\n"
  " * This version will not delete any files.\n"
  " */";
#else
static const char *Dtool_Patchfile_apply_719_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Patchfile::get_progress(void) const
 */
static PyObject *Dtool_Patchfile_get_progress_720(PyObject *self, PyObject *) {
  Patchfile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Patchfile)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Patchfile::get_progress(void) const
  PN_stdfloat return_value = ((*(const Patchfile*)local_this).get_progress)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_get_progress_720_comment =
  "C++ Interface:\n"
  "get_progress(Patchfile self)\n"
  "\n"
  "/**\n"
  " * Returns a value in the range 0..1, representing the amount of progress\n"
  " * through the patchfile, during a session.\n"
  " */";
#else
static const char *Dtool_Patchfile_get_progress_720_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Patchfile::set_allow_multifile(bool allow_multifile)
 */
static PyObject *Dtool_Patchfile_set_allow_multifile_724(PyObject *self, PyObject *arg) {
  Patchfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.set_allow_multifile")) {
    return nullptr;
  }
  // 1-inline void Patchfile::set_allow_multifile(bool allow_multifile)
  ((*local_this).set_allow_multifile)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_allow_multifile(const Patchfile self, bool allow_multifile)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_set_allow_multifile_724_comment =
  "C++ Interface:\n"
  "set_allow_multifile(const Patchfile self, bool allow_multifile)\n"
  "\n"
  "/**\n"
  " * If this flag is set true, the Patchfile will make a special case for\n"
  " * patching Panda Multifiles, if detected, and attempt to patch them on a\n"
  " * subfile-by-subfile basis.  If this flag is false, the Patchfile will always\n"
  " * patch the file on a full-file basis.\n"
  " *\n"
  " * This has effect only when building patches; it is not used for applying\n"
  " * patches.\n"
  " */";
#else
static const char *Dtool_Patchfile_set_allow_multifile_724_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Patchfile::get_allow_multifile(void)
 */
static PyObject *Dtool_Patchfile_get_allow_multifile_725(PyObject *self, PyObject *) {
  Patchfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.get_allow_multifile")) {
    return nullptr;
  }
  // 1-inline bool Patchfile::get_allow_multifile(void)
  bool return_value = ((*local_this).get_allow_multifile)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_get_allow_multifile_725_comment =
  "C++ Interface:\n"
  "get_allow_multifile(const Patchfile self)\n"
  "\n"
  "/**\n"
  " * See set_allow_multifile().\n"
  " */";
#else
static const char *Dtool_Patchfile_get_allow_multifile_725_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Patchfile::set_footprint_length(int length)
 */
static PyObject *Dtool_Patchfile_set_footprint_length_727(PyObject *self, PyObject *arg) {
  Patchfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.set_footprint_length")) {
    return nullptr;
  }
  // 1-inline void Patchfile::set_footprint_length(int length)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_footprint_length)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_footprint_length(const Patchfile self, int length)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_set_footprint_length_727_comment =
  "C++ Interface:\n"
  "set_footprint_length(const Patchfile self, int length)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Patchfile_set_footprint_length_727_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Patchfile::get_footprint_length(void)
 */
static PyObject *Dtool_Patchfile_get_footprint_length_728(PyObject *self, PyObject *) {
  Patchfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.get_footprint_length")) {
    return nullptr;
  }
  // 1-inline int Patchfile::get_footprint_length(void)
  int return_value = ((*local_this).get_footprint_length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_get_footprint_length_728_comment =
  "C++ Interface:\n"
  "get_footprint_length(const Patchfile self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Patchfile_get_footprint_length_728_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Patchfile::reset_footprint_length(void)
 */
static PyObject *Dtool_Patchfile_reset_footprint_length_729(PyObject *self, PyObject *) {
  Patchfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.reset_footprint_length")) {
    return nullptr;
  }
  // 1-inline void Patchfile::reset_footprint_length(void)
  ((*local_this).reset_footprint_length)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_reset_footprint_length_729_comment =
  "C++ Interface:\n"
  "reset_footprint_length(const Patchfile self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_Patchfile_reset_footprint_length_729_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool Patchfile::has_source_hash(void) const
 */
static PyObject *Dtool_Patchfile_has_source_hash_731(PyObject *self, PyObject *) {
  Patchfile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Patchfile)) {
    return nullptr;
  }
  // 1-inline bool Patchfile::has_source_hash(void) const
  bool return_value = ((*(const Patchfile*)local_this).has_source_hash)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_has_source_hash_731_comment =
  "C++ Interface:\n"
  "has_source_hash(Patchfile self)\n"
  "\n"
  "/**\n"
  " * Returns true if the MD5 hash for the source file is known.  (Some early\n"
  " * versions of the patch file did not store this information.)\n"
  " */";
#else
static const char *Dtool_Patchfile_has_source_hash_731_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline HashVal const &Patchfile::get_source_hash(void) const
 */
static PyObject *Dtool_Patchfile_get_source_hash_732(PyObject *self, PyObject *) {
  Patchfile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Patchfile)) {
    return nullptr;
  }
  // 1-inline HashVal const &Patchfile::get_source_hash(void) const
  HashVal const *return_value = &(((*(const Patchfile*)local_this).get_source_hash)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HashVal, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_get_source_hash_732_comment =
  "C++ Interface:\n"
  "get_source_hash(Patchfile self)\n"
  "\n"
  "/**\n"
  " * Returns the MD5 hash for the source file.\n"
  " */";
#else
static const char *Dtool_Patchfile_get_source_hash_732_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline HashVal const &Patchfile::get_result_hash(void) const
 */
static PyObject *Dtool_Patchfile_get_result_hash_733(PyObject *self, PyObject *) {
  Patchfile *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Patchfile)) {
    return nullptr;
  }
  // 1-inline HashVal const &Patchfile::get_result_hash(void) const
  HashVal const *return_value = &(((*(const Patchfile*)local_this).get_result_hash)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HashVal, false, true);
}

#ifndef NDEBUG
static const char *Dtool_Patchfile_get_result_hash_733_comment =
  "C++ Interface:\n"
  "get_result_hash(Patchfile self)\n"
  "\n"
  "/**\n"
  " * Returns the MD5 hash for the file after the patch has been applied.\n"
  " */";
#else
static const char *Dtool_Patchfile_get_result_hash_733_comment = nullptr;
#endif

static PyObject *Dtool_Patchfile_progress_Getter(PyObject *self, void *) {
  const Patchfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Patchfile, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat Patchfile::get_progress(void) const
  PN_stdfloat return_value = ((*(const Patchfile*)local_this).get_progress)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_Patchfile_allow_multifile_Getter(PyObject *self, void *) {
  Patchfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.allow_multifile")) {
    return nullptr;
  }

  // 1-inline bool Patchfile::get_allow_multifile(void)
  bool return_value = ((*local_this).get_allow_multifile)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Patchfile_allow_multifile_Setter(PyObject *self, PyObject *arg, void *) {
  Patchfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.allow_multifile")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete allow_multifile attribute");
    return -1;
  }
  // 1-inline void Patchfile::set_allow_multifile(bool allow_multifile)
  ((*local_this).set_allow_multifile)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_allow_multifile(const Patchfile self, bool allow_multifile)\n");
  }
  return -1;
}

static PyObject *Dtool_Patchfile_footprint_length_Getter(PyObject *self, void *) {
  Patchfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.footprint_length")) {
    return nullptr;
  }

  // 1-inline int Patchfile::get_footprint_length(void)
  int return_value = ((*local_this).get_footprint_length)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Patchfile_footprint_length_Setter(PyObject *self, PyObject *arg, void *) {
  Patchfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Patchfile, (void **)&local_this, "Patchfile.footprint_length")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete footprint_length attribute");
    return -1;
  }
  // 1-inline void Patchfile::set_footprint_length(int length)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_footprint_length)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_footprint_length(const Patchfile self, int length)\n");
  }
  return -1;
}

static PyObject *Dtool_Patchfile_source_hash_Getter(PyObject *self, void *) {
  const Patchfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Patchfile, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_source_hash()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline HashVal const &Patchfile::get_source_hash(void) const
  HashVal const *return_value = &(((*(const Patchfile*)local_this).get_source_hash)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HashVal, false, true);
}

static PyObject *Dtool_Patchfile_result_hash_Getter(PyObject *self, void *) {
  const Patchfile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Patchfile, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline HashVal const &Patchfile::get_result_hash(void) const
  HashVal const *return_value = &(((*(const Patchfile*)local_this).get_result_hash)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_HashVal, false, true);
}

/**
 * Python function wrapper for:
 * Patchfile::Patchfile(void)
 * explicit Patchfile::Patchfile(PointerTo< Buffer > buffer)
 */
static int Dtool_Init_Patchfile(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-Patchfile::Patchfile(void)
      Patchfile *return_value = new Patchfile();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Patchfile, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "buffer")) {
        // 1-explicit Patchfile::Patchfile(PointerTo< Buffer > buffer)
        Buffer *arg_this = (Buffer *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Buffer, 0, "Patchfile.Patchfile", false, true);
        if (arg_this != nullptr) {
          Patchfile *return_value = new Patchfile(arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Patchfile, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Patchfile() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Patchfile()\n"
      "Patchfile(Buffer buffer)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Patchfile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Patchfile) {
    printf("Patchfile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Patchfile *local_this = (Patchfile *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Patchfile) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Patchfile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Patchfile) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class WeakPointerToVoid
 */
/**
 * Python function wrapper for:
 * inline bool WeakPointerToVoid::was_deleted(void) const
 */
static PyObject *Dtool_WeakPointerToVoid_was_deleted_739(PyObject *self, PyObject *) {
  WeakPointerToVoid *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WeakPointerToVoid)) {
    return nullptr;
  }
  // 1-inline bool WeakPointerToVoid::was_deleted(void) const
  bool return_value = ((*(const WeakPointerToVoid*)local_this).was_deleted)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WeakPointerToVoid_was_deleted_739_comment =
  "C++ Interface:\n"
  "was_deleted(WeakPointerToVoid self)\n"
  "\n"
  "/**\n"
  " * Returns true if the object we are pointing to has been deleted, false\n"
  " * otherwise.  If this returns true, it means that the pointer can not yet be\n"
  " * reused, but it does not guarantee that it can be safely accessed.  See the\n"
  " * lock() method for a safe way to access the underlying pointer.\n"
  " *\n"
  " * This will always return true for a null pointer, unlike is_valid_pointer().\n"
  " */";
#else
static const char *Dtool_WeakPointerToVoid_was_deleted_739_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool WeakPointerToVoid::is_valid_pointer(void) const
 */
static PyObject *Dtool_WeakPointerToVoid_is_valid_pointer_740(PyObject *self, PyObject *) {
  WeakPointerToVoid *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_WeakPointerToVoid)) {
    return nullptr;
  }
  // 1-inline bool WeakPointerToVoid::is_valid_pointer(void) const
  bool return_value = ((*(const WeakPointerToVoid*)local_this).is_valid_pointer)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_WeakPointerToVoid_is_valid_pointer_740_comment =
  "C++ Interface:\n"
  "is_valid_pointer(WeakPointerToVoid self)\n"
  "\n"
  "/**\n"
  " * Returns true if the pointer is not null and the object has not been\n"
  " * deleted.  See was_deleted() for caveats.\n"
  " */";
#else
static const char *Dtool_WeakPointerToVoid_is_valid_pointer_740_comment = nullptr;
#endif

static int Dtool_Init_WeakPointerToVoid(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_WeakPointerToVoid(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_WeakPointerToVoid) {
    printf("WeakPointerToVoid ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  WeakPointerToVoid *local_this = (WeakPointerToVoid *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_WeakPointerToVoid) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_WeakPointerToVoid(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_WeakPointerToVoid) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (WeakPointerToVoid*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for ConstPointerToArray_double (ConstPointerToArray_double)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_double[] = {
  {"clear", &Dtool_ConstPointerToArray_double_clear_14, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_double_clear_14_comment},
  {"get_element", &Dtool_ConstPointerToArray_double_get_element_16, METH_O, (const char *)Dtool_ConstPointerToArray_double_get_element_16_comment},
  {"getElement", &Dtool_ConstPointerToArray_double_get_element_16, METH_O, (const char *)Dtool_ConstPointerToArray_double_get_element_16_comment},
  {"get_data", &Dtool_ConstPointerToArray_double_get_data_18, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_double_get_data_18_comment},
  {"getData", &Dtool_ConstPointerToArray_double_get_data_18, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_double_get_data_18_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_double_get_subdata_19, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_double_get_subdata_19_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_double_get_subdata_19, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_double_get_subdata_19_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_double_get_ref_count_20, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_double_get_ref_count_20_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_double_get_ref_count_20, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_double_get_ref_count_20_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_double_get_node_ref_count_21, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_double_get_node_ref_count_21_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_double_get_node_ref_count_21, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_double_get_node_ref_count_21_comment},
  {"count", &Dtool_ConstPointerToArray_double_count_22, METH_O, (const char *)Dtool_ConstPointerToArray_double_count_22_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_double slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_double_getbuffer_23_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< double > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_double, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< double > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_double slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_double_releasebuffer_24_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< double > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_double, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< double > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_double slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_double_getitem_17_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< double > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_double, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_double index out of range");
    return nullptr;
  }
  // 1-double const &ConstPointerToArray< double >::__getitem__(unsigned long int n) const
  double return_value = invoke_extension((const ConstPointerToArray< double >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_double slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_double_size_15_sq_length(PyObject *self) {
  ConstPointerToArray< double > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_double, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_double = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_double = {
  &Dtool_ConstPointerToArray_double_size_15_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_double_getitem_17_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_double = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_double = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_double_getbuffer_23_bf_getbuffer,
  &Dtool_ConstPointerToArray_double_releasebuffer_24_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_double = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_double = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_double",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_double,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_double,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_double,
    &Dtool_SequenceMethods_ConstPointerToArray_double,
    &Dtool_MappingMethods_ConstPointerToArray_double,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_double,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_double,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_double,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_double,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_double,
  Dtool_UpcastInterface_ConstPointerToArray_double,
  Dtool_DowncastInterface_ConstPointerToArray_double,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_double,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_double(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_double(nullptr);
    Dtool_ConstPointerToArray_double._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_double);
    Dtool_ConstPointerToArray_double._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_double._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_double) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_double)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_double);
  }
}

/**
 * Python method tables for PointerToArrayBase_double (PointerToArrayBase_double)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_double[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_double = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_double = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_double = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_double = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_double = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_double = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_double",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_double,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_double,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_double,
    &Dtool_SequenceMethods_PointerToArrayBase_double,
    &Dtool_MappingMethods_PointerToArrayBase_double,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_double,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_double,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_double,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_double,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_double,
  Dtool_UpcastInterface_PointerToArrayBase_double,
  Dtool_DowncastInterface_PointerToArrayBase_double,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_double(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_double(nullptr);
    Dtool_PointerToArrayBase_double._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_double);
    Dtool_PointerToArrayBase_double._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_double._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_double) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_double)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_double);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_double (PointerToBase_ReferenceCountedVector_double)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_double[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_double_clear_10, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_double_clear_10_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_double_output_11, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_double_output_11_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_double
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_double(PyObject *self) {
  PointerToBase< ReferenceCountedVector< double > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_double, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_double = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_double = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_double = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_double = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_double = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_double = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_double",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_double,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_double,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_double,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_double,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_double,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_double,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_double,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_double,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_double,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_double,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_double,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_double,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_double,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_double,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_double(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToVoid(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_double._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_double._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_double._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_double) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_double)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_double);
  }
}

/**
 * Python method tables for PointerToVoid (PointerToVoid)
 */
static PyMethodDef Dtool_Methods_PointerToVoid[] = {
  {"is_null", &Dtool_PointerToVoid_is_null_7, METH_NOARGS, (const char *)Dtool_PointerToVoid_is_null_7_comment},
  {"isNull", &Dtool_PointerToVoid_is_null_7, METH_NOARGS, (const char *)Dtool_PointerToVoid_is_null_7_comment},
  {"get_hash", &Dtool_PointerToVoid_get_hash_8, METH_NOARGS, (const char *)Dtool_PointerToVoid_get_hash_8_comment},
  {"getHash", &Dtool_PointerToVoid_get_hash_8, METH_NOARGS, (const char *)Dtool_PointerToVoid_get_hash_8_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToVoid slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_PointerToVoid_get_hash_8_tp_hash(PyObject *self) {
  PointerToVoid *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToVoid, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) ((*local_this).get_hash)();
}

static PyNumberMethods Dtool_NumberMethods_PointerToVoid = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToVoid = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToVoid = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToVoid = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToVoid = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToVoid = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToVoid",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToVoid,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToVoid,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToVoid,
    &Dtool_SequenceMethods_PointerToVoid,
    &Dtool_MappingMethods_PointerToVoid,
    &Dtool_PointerToVoid_get_hash_8_tp_hash,
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToVoid,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the non-template part of the base class for PointerTo and\n"
    " * ConstPointerTo.  It is necessary so we can keep a pointer to a non-template\n"
    " * class within the ReferenceCount object, to implement weak reference\n"
    " * pointers--we need to have something to clean up when the ReferenceCount\n"
    " * object destructs.\n"
    " *\n"
    " * This is the base class for PointerToBase<T>.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
#if PY_MAJOR_VERSION >= 3
    &DtoolInstance_RichComparePointers,
#else
    nullptr, // tp_richcompare
#endif
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToVoid,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToVoid,
    PyType_GenericAlloc,
    Dtool_new_PointerToVoid,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToVoid,
  Dtool_UpcastInterface_PointerToVoid,
  Dtool_DowncastInterface_PointerToVoid,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToVoid(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PointerToVoid._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToVoid._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToVoid) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToVoid)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToVoid);
  }
}

/**
 * Python method tables for ConstPointerToArray_float (ConstPointerToArray_float)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_float[] = {
  {"clear", &Dtool_ConstPointerToArray_float_clear_34, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_float_clear_34_comment},
  {"get_element", &Dtool_ConstPointerToArray_float_get_element_36, METH_O, (const char *)Dtool_ConstPointerToArray_float_get_element_36_comment},
  {"getElement", &Dtool_ConstPointerToArray_float_get_element_36, METH_O, (const char *)Dtool_ConstPointerToArray_float_get_element_36_comment},
  {"get_data", &Dtool_ConstPointerToArray_float_get_data_38, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_float_get_data_38_comment},
  {"getData", &Dtool_ConstPointerToArray_float_get_data_38, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_float_get_data_38_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_float_get_subdata_39, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_float_get_subdata_39_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_float_get_subdata_39, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_float_get_subdata_39_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_float_get_ref_count_40, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_float_get_ref_count_40_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_float_get_ref_count_40, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_float_get_ref_count_40_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_float_get_node_ref_count_41, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_float_get_node_ref_count_41_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_float_get_node_ref_count_41, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_float_get_node_ref_count_41_comment},
  {"count", &Dtool_ConstPointerToArray_float_count_42, METH_O, (const char *)Dtool_ConstPointerToArray_float_count_42_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_float slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_float_getbuffer_43_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< float > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_float, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< float > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_float slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_float_releasebuffer_44_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< float > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_float, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< float > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_float slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_float_getitem_37_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< float > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_float, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_float index out of range");
    return nullptr;
  }
  // 1-float const &ConstPointerToArray< float >::__getitem__(unsigned long int n) const
  float return_value = invoke_extension((const ConstPointerToArray< float >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_float slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_float_size_35_sq_length(PyObject *self) {
  ConstPointerToArray< float > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_float, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_float = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_float = {
  &Dtool_ConstPointerToArray_float_size_35_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_float_getitem_37_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_float = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_float = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_float_getbuffer_43_bf_getbuffer,
  &Dtool_ConstPointerToArray_float_releasebuffer_44_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_float = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_float = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_float",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_float,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_float,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_float,
    &Dtool_SequenceMethods_ConstPointerToArray_float,
    &Dtool_MappingMethods_ConstPointerToArray_float,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_float,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_float,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_float,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_float,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_float,
  Dtool_UpcastInterface_ConstPointerToArray_float,
  Dtool_DowncastInterface_ConstPointerToArray_float,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_float,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_float(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_float(nullptr);
    Dtool_ConstPointerToArray_float._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_float);
    Dtool_ConstPointerToArray_float._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_float._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_float) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_float)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_float);
  }
}

/**
 * Python method tables for PointerToArrayBase_float (PointerToArrayBase_float)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_float[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_float = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_float = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_float = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_float = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_float = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_float = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_float",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_float,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_float,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_float,
    &Dtool_SequenceMethods_PointerToArrayBase_float,
    &Dtool_MappingMethods_PointerToArrayBase_float,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_float,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_float,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_float,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_float,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_float,
  Dtool_UpcastInterface_PointerToArrayBase_float,
  Dtool_DowncastInterface_PointerToArrayBase_float,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_float(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_float(nullptr);
    Dtool_PointerToArrayBase_float._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_float);
    Dtool_PointerToArrayBase_float._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_float._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_float) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_float)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_float);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_float (PointerToBase_ReferenceCountedVector_float)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_float[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_float_clear_30, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_float_clear_30_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_float_output_31, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_float_output_31_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_float
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_float(PyObject *self) {
  PointerToBase< ReferenceCountedVector< float > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_float, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_float = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_float = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_float = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_float = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_float = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_float = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_float",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_float,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_float,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_float,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_float,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_float,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_float,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_float,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_float,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_float,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_float,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_float,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_float,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_float,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_float,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_float(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToVoid(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_float._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_float._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_float._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_float) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_float)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_float);
  }
}

/**
 * Python method tables for ConstPointerToArray_int (ConstPointerToArray_int)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_int[] = {
  {"clear", &Dtool_ConstPointerToArray_int_clear_54, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_int_clear_54_comment},
  {"get_element", &Dtool_ConstPointerToArray_int_get_element_56, METH_O, (const char *)Dtool_ConstPointerToArray_int_get_element_56_comment},
  {"getElement", &Dtool_ConstPointerToArray_int_get_element_56, METH_O, (const char *)Dtool_ConstPointerToArray_int_get_element_56_comment},
  {"get_data", &Dtool_ConstPointerToArray_int_get_data_58, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_int_get_data_58_comment},
  {"getData", &Dtool_ConstPointerToArray_int_get_data_58, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_int_get_data_58_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_int_get_subdata_59, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_int_get_subdata_59_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_int_get_subdata_59, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_int_get_subdata_59_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_int_get_ref_count_60, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_int_get_ref_count_60_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_int_get_ref_count_60, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_int_get_ref_count_60_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_int_get_node_ref_count_61, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_int_get_node_ref_count_61_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_int_get_node_ref_count_61, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_int_get_node_ref_count_61_comment},
  {"count", &Dtool_ConstPointerToArray_int_count_62, METH_O, (const char *)Dtool_ConstPointerToArray_int_count_62_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_int slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_int_getbuffer_63_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< int > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_int, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< int > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_int slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_int_releasebuffer_64_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< int > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_int, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< int > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_int slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_int_getitem_57_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< int > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_int, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_int index out of range");
    return nullptr;
  }
  // 1-int const &ConstPointerToArray< int >::__getitem__(unsigned long int n) const
  int return_value = invoke_extension((const ConstPointerToArray< int >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_int slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_int_size_55_sq_length(PyObject *self) {
  ConstPointerToArray< int > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_int, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_int = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_int = {
  &Dtool_ConstPointerToArray_int_size_55_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_int_getitem_57_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_int = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_int = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_int_getbuffer_63_bf_getbuffer,
  &Dtool_ConstPointerToArray_int_releasebuffer_64_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_int = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_int = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_int",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_int,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_int,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_int,
    &Dtool_SequenceMethods_ConstPointerToArray_int,
    &Dtool_MappingMethods_ConstPointerToArray_int,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_int,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_int,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_int,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_int,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_int,
  Dtool_UpcastInterface_ConstPointerToArray_int,
  Dtool_DowncastInterface_ConstPointerToArray_int,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_int,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_int(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_int(nullptr);
    Dtool_ConstPointerToArray_int._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_int);
    Dtool_ConstPointerToArray_int._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_int._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_int) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_int)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_int);
  }
}

/**
 * Python method tables for PointerToArrayBase_int (PointerToArrayBase_int)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_int[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_int = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_int = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_int = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_int = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_int = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_int = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_int",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_int,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_int,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_int,
    &Dtool_SequenceMethods_PointerToArrayBase_int,
    &Dtool_MappingMethods_PointerToArrayBase_int,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_int,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_int,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_int,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_int,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_int,
  Dtool_UpcastInterface_PointerToArrayBase_int,
  Dtool_DowncastInterface_PointerToArrayBase_int,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_int(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_int(nullptr);
    Dtool_PointerToArrayBase_int._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_int);
    Dtool_PointerToArrayBase_int._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_int._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_int) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_int)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_int);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_int (PointerToBase_ReferenceCountedVector_int)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_int[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_int_clear_50, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_int_clear_50_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_int_output_51, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_int_output_51_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_int
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_int(PyObject *self) {
  PointerToBase< ReferenceCountedVector< int > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_int, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_int = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_int = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_int = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_int = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_int = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_int = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_int",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_int,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_int,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_int,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_int,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_int,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_int,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_int,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_int,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_int,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_int,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_int,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_int,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_int,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_int,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_int(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToVoid(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_int._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_int._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_int._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_int) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_int)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_int);
  }
}

/**
 * Python method tables for ConstPointerToArray_unsigned_char (ConstPointerToArray_unsigned_char)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_unsigned_char[] = {
  {"clear", &Dtool_ConstPointerToArray_unsigned_char_clear_74, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_unsigned_char_clear_74_comment},
  {"get_element", &Dtool_ConstPointerToArray_unsigned_char_get_element_76, METH_O, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_element_76_comment},
  {"getElement", &Dtool_ConstPointerToArray_unsigned_char_get_element_76, METH_O, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_element_76_comment},
  {"get_data", &Dtool_ConstPointerToArray_unsigned_char_get_data_78, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_data_78_comment},
  {"getData", &Dtool_ConstPointerToArray_unsigned_char_get_data_78, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_data_78_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_unsigned_char_get_subdata_79, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_subdata_79_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_unsigned_char_get_subdata_79, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_subdata_79_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_unsigned_char_get_ref_count_80, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_ref_count_80_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_unsigned_char_get_ref_count_80, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_ref_count_80_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_81, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_81_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_81, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_unsigned_char_get_node_ref_count_81_comment},
  {"count", &Dtool_ConstPointerToArray_unsigned_char_count_82, METH_O, (const char *)Dtool_ConstPointerToArray_unsigned_char_count_82_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_unsigned_char slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_unsigned_char_getbuffer_83_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< unsigned char > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_unsigned_char, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< unsigned char > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_unsigned_char slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_unsigned_char_releasebuffer_84_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< unsigned char > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_unsigned_char, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< unsigned char > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_unsigned_char slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_unsigned_char_getitem_77_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< unsigned char > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_unsigned_char, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_unsigned_char index out of range");
    return nullptr;
  }
  // 1-unsigned char const &ConstPointerToArray< unsigned char >::__getitem__(unsigned long int n) const
  unsigned char return_value = invoke_extension((const ConstPointerToArray< unsigned char >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_unsigned_char slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_unsigned_char_size_75_sq_length(PyObject *self) {
  ConstPointerToArray< unsigned char > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_unsigned_char, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_unsigned_char = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_unsigned_char = {
  &Dtool_ConstPointerToArray_unsigned_char_size_75_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_unsigned_char_getitem_77_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_unsigned_char = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_unsigned_char = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_unsigned_char_getbuffer_83_bf_getbuffer,
  &Dtool_ConstPointerToArray_unsigned_char_releasebuffer_84_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_unsigned_char = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_unsigned_char = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_unsigned_char",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_unsigned_char,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_unsigned_char,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_unsigned_char,
    &Dtool_SequenceMethods_ConstPointerToArray_unsigned_char,
    &Dtool_MappingMethods_ConstPointerToArray_unsigned_char,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_unsigned_char,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_unsigned_char,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_unsigned_char,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_unsigned_char,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_unsigned_char,
  Dtool_UpcastInterface_ConstPointerToArray_unsigned_char,
  Dtool_DowncastInterface_ConstPointerToArray_unsigned_char,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_unsigned_char,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_unsigned_char(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_unsigned_char(nullptr);
    Dtool_ConstPointerToArray_unsigned_char._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_unsigned_char);
    Dtool_ConstPointerToArray_unsigned_char._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_unsigned_char._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_unsigned_char) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_unsigned_char)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_unsigned_char);
  }
}

/**
 * Python method tables for PointerToArrayBase_unsigned_char (PointerToArrayBase_unsigned_char)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_unsigned_char[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_unsigned_char = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_unsigned_char = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_unsigned_char = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_unsigned_char = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_unsigned_char = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_unsigned_char = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_unsigned_char",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_unsigned_char,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_unsigned_char,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_unsigned_char,
    &Dtool_SequenceMethods_PointerToArrayBase_unsigned_char,
    &Dtool_MappingMethods_PointerToArrayBase_unsigned_char,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_unsigned_char,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_unsigned_char,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_unsigned_char,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_unsigned_char,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_unsigned_char,
  Dtool_UpcastInterface_PointerToArrayBase_unsigned_char,
  Dtool_DowncastInterface_PointerToArrayBase_unsigned_char,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_unsigned_char(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_unsigned_char(nullptr);
    Dtool_PointerToArrayBase_unsigned_char._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char);
    Dtool_PointerToArrayBase_unsigned_char._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_unsigned_char._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_unsigned_char) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_unsigned_char)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_unsigned_char);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_unsigned_char (PointerToBase_ReferenceCountedVector_unsigned_char)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_unsigned_char[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_clear_70, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_clear_70_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_output_71, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_unsigned_char_output_71_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_unsigned_char
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_unsigned_char(PyObject *self) {
  PointerToBase< ReferenceCountedVector< unsigned char > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_unsigned_char, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_unsigned_char = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_unsigned_char = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_unsigned_char = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_unsigned_char = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_unsigned_char = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_unsigned_char = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_unsigned_char",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_unsigned_char,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_unsigned_char,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_unsigned_char,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_unsigned_char,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_unsigned_char,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_unsigned_char,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_unsigned_char,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_unsigned_char,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_unsigned_char,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_unsigned_char,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_unsigned_char,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_unsigned_char,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_unsigned_char,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_unsigned_char,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_unsigned_char(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToVoid(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_unsigned_char._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_unsigned_char._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_unsigned_char._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_unsigned_char)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char);
  }
}

/**
 * Python method tables for PointerToArray_double (PointerToArray_double)
 */
static PyMethodDef Dtool_Methods_PointerToArray_double[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_double_empty_array_89, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_double_empty_array_89_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_double_empty_array_89, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_double_empty_array_89_comment},
  {"clear", &Dtool_PointerToArray_double_clear_90, METH_NOARGS, (const char *)Dtool_PointerToArray_double_clear_90_comment},
  {"push_back", &Dtool_PointerToArray_double_push_back_92, METH_O, (const char *)Dtool_PointerToArray_double_push_back_92_comment},
  {"pushBack", &Dtool_PointerToArray_double_push_back_92, METH_O, (const char *)Dtool_PointerToArray_double_push_back_92_comment},
  {"pop_back", &Dtool_PointerToArray_double_pop_back_93, METH_NOARGS, (const char *)Dtool_PointerToArray_double_pop_back_93_comment},
  {"popBack", &Dtool_PointerToArray_double_pop_back_93, METH_NOARGS, (const char *)Dtool_PointerToArray_double_pop_back_93_comment},
  {"get_element", &Dtool_PointerToArray_double_get_element_94, METH_O, (const char *)Dtool_PointerToArray_double_get_element_94_comment},
  {"getElement", &Dtool_PointerToArray_double_get_element_94, METH_O, (const char *)Dtool_PointerToArray_double_get_element_94_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_double_set_element_95, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_double_set_element_95_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_double_set_element_95, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_double_set_element_95_comment},
  {"get_data", &Dtool_PointerToArray_double_get_data_98, METH_NOARGS, (const char *)Dtool_PointerToArray_double_get_data_98_comment},
  {"getData", &Dtool_PointerToArray_double_get_data_98, METH_NOARGS, (const char *)Dtool_PointerToArray_double_get_data_98_comment},
  {"set_data", &Dtool_PointerToArray_double_set_data_99, METH_O, (const char *)Dtool_PointerToArray_double_set_data_99_comment},
  {"setData", &Dtool_PointerToArray_double_set_data_99, METH_O, (const char *)Dtool_PointerToArray_double_set_data_99_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_double_get_subdata_100, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_double_get_subdata_100_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_double_get_subdata_100, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_double_get_subdata_100_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_double_set_subdata_101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_double_set_subdata_101_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_double_set_subdata_101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_double_set_subdata_101_comment},
  {"get_ref_count", &Dtool_PointerToArray_double_get_ref_count_102, METH_NOARGS, (const char *)Dtool_PointerToArray_double_get_ref_count_102_comment},
  {"getRefCount", &Dtool_PointerToArray_double_get_ref_count_102, METH_NOARGS, (const char *)Dtool_PointerToArray_double_get_ref_count_102_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_double_get_node_ref_count_103, METH_NOARGS, (const char *)Dtool_PointerToArray_double_get_node_ref_count_103_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_double_get_node_ref_count_103, METH_NOARGS, (const char *)Dtool_PointerToArray_double_get_node_ref_count_103_comment},
  {"count", &Dtool_PointerToArray_double_count_104, METH_O, (const char *)Dtool_PointerToArray_double_count_104_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_double slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_double_getbuffer_105_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< double > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_double, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_double.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_double slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_double_releasebuffer_106_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< double > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_double, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< double > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_double slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_double_setitem_97_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< double > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_double, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_double index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< double >::__setitem__(unsigned long int n, double const &value)
      if (PyNumber_Check(arg)) {
        invoke_extension(local_this).__setitem__(index, PyFloat_AsDouble(arg));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, double value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_double slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_double_getitem_96_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< double > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_double, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_double index out of range");
    return nullptr;
  }
  // 1-double const &PointerToArray< double >::__getitem__(unsigned long int n) const
  double return_value = invoke_extension((const PointerToArray< double >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_double slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_double_size_91_sq_length(PyObject *self) {
  PointerToArray< double > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_double, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_double = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_double = {
  &Dtool_PointerToArray_double_size_91_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_double_getitem_96_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_double_setitem_97_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_double = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_double = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_double_getbuffer_105_bf_getbuffer,
  &Dtool_PointerToArray_double_releasebuffer_106_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_double = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_double = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_double",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_double,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_double,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_double,
    &Dtool_SequenceMethods_PointerToArray_double,
    &Dtool_MappingMethods_PointerToArray_double,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_double,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_double,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_double,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_double,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_double,
  Dtool_UpcastInterface_PointerToArray_double,
  Dtool_DowncastInterface_PointerToArray_double,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_double,
};

static void Dtool_PyModuleClassInit_PointerToArray_double(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_double(nullptr);
    Dtool_PointerToArray_double._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_double);
    Dtool_PointerToArray_double._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_double._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_double) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_double)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_double);
  }
}

/**
 * Python method tables for PointerToArray_float (PointerToArray_float)
 */
static PyMethodDef Dtool_Methods_PointerToArray_float[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_float_empty_array_111, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_float_empty_array_111_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_float_empty_array_111, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_float_empty_array_111_comment},
  {"clear", &Dtool_PointerToArray_float_clear_112, METH_NOARGS, (const char *)Dtool_PointerToArray_float_clear_112_comment},
  {"push_back", &Dtool_PointerToArray_float_push_back_114, METH_O, (const char *)Dtool_PointerToArray_float_push_back_114_comment},
  {"pushBack", &Dtool_PointerToArray_float_push_back_114, METH_O, (const char *)Dtool_PointerToArray_float_push_back_114_comment},
  {"pop_back", &Dtool_PointerToArray_float_pop_back_115, METH_NOARGS, (const char *)Dtool_PointerToArray_float_pop_back_115_comment},
  {"popBack", &Dtool_PointerToArray_float_pop_back_115, METH_NOARGS, (const char *)Dtool_PointerToArray_float_pop_back_115_comment},
  {"get_element", &Dtool_PointerToArray_float_get_element_116, METH_O, (const char *)Dtool_PointerToArray_float_get_element_116_comment},
  {"getElement", &Dtool_PointerToArray_float_get_element_116, METH_O, (const char *)Dtool_PointerToArray_float_get_element_116_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_float_set_element_117, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_float_set_element_117_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_float_set_element_117, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_float_set_element_117_comment},
  {"get_data", &Dtool_PointerToArray_float_get_data_120, METH_NOARGS, (const char *)Dtool_PointerToArray_float_get_data_120_comment},
  {"getData", &Dtool_PointerToArray_float_get_data_120, METH_NOARGS, (const char *)Dtool_PointerToArray_float_get_data_120_comment},
  {"set_data", &Dtool_PointerToArray_float_set_data_121, METH_O, (const char *)Dtool_PointerToArray_float_set_data_121_comment},
  {"setData", &Dtool_PointerToArray_float_set_data_121, METH_O, (const char *)Dtool_PointerToArray_float_set_data_121_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_float_get_subdata_122, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_float_get_subdata_122_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_float_get_subdata_122, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_float_get_subdata_122_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_float_set_subdata_123, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_float_set_subdata_123_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_float_set_subdata_123, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_float_set_subdata_123_comment},
  {"get_ref_count", &Dtool_PointerToArray_float_get_ref_count_124, METH_NOARGS, (const char *)Dtool_PointerToArray_float_get_ref_count_124_comment},
  {"getRefCount", &Dtool_PointerToArray_float_get_ref_count_124, METH_NOARGS, (const char *)Dtool_PointerToArray_float_get_ref_count_124_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_float_get_node_ref_count_125, METH_NOARGS, (const char *)Dtool_PointerToArray_float_get_node_ref_count_125_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_float_get_node_ref_count_125, METH_NOARGS, (const char *)Dtool_PointerToArray_float_get_node_ref_count_125_comment},
  {"count", &Dtool_PointerToArray_float_count_126, METH_O, (const char *)Dtool_PointerToArray_float_count_126_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_float slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_float_getbuffer_127_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< float > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_float, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_float.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_float slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_float_releasebuffer_128_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< float > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_float, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< float > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_float slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_float_setitem_119_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< float > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_float, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_float index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< float >::__setitem__(unsigned long int n, float const &value)
      if (PyNumber_Check(arg)) {
        invoke_extension(local_this).__setitem__(index, (float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, float value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_float slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_float_getitem_118_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< float > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_float, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_float index out of range");
    return nullptr;
  }
  // 1-float const &PointerToArray< float >::__getitem__(unsigned long int n) const
  float return_value = invoke_extension((const PointerToArray< float >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_float slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_float_size_113_sq_length(PyObject *self) {
  PointerToArray< float > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_float, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_float = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_float = {
  &Dtool_PointerToArray_float_size_113_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_float_getitem_118_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_float_setitem_119_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_float = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_float = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_float_getbuffer_127_bf_getbuffer,
  &Dtool_PointerToArray_float_releasebuffer_128_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_float = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_float = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_float",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_float,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_float,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_float,
    &Dtool_SequenceMethods_PointerToArray_float,
    &Dtool_MappingMethods_PointerToArray_float,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_float,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_float,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_float,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_float,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_float,
  Dtool_UpcastInterface_PointerToArray_float,
  Dtool_DowncastInterface_PointerToArray_float,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_float,
};

static void Dtool_PyModuleClassInit_PointerToArray_float(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_float(nullptr);
    Dtool_PointerToArray_float._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_float);
    Dtool_PointerToArray_float._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_float._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_float) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_float)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_float);
  }
}

/**
 * Python method tables for PointerToArray_int (PointerToArray_int)
 */
static PyMethodDef Dtool_Methods_PointerToArray_int[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_int_empty_array_133, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_int_empty_array_133_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_int_empty_array_133, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_int_empty_array_133_comment},
  {"clear", &Dtool_PointerToArray_int_clear_134, METH_NOARGS, (const char *)Dtool_PointerToArray_int_clear_134_comment},
  {"push_back", &Dtool_PointerToArray_int_push_back_136, METH_O, (const char *)Dtool_PointerToArray_int_push_back_136_comment},
  {"pushBack", &Dtool_PointerToArray_int_push_back_136, METH_O, (const char *)Dtool_PointerToArray_int_push_back_136_comment},
  {"pop_back", &Dtool_PointerToArray_int_pop_back_137, METH_NOARGS, (const char *)Dtool_PointerToArray_int_pop_back_137_comment},
  {"popBack", &Dtool_PointerToArray_int_pop_back_137, METH_NOARGS, (const char *)Dtool_PointerToArray_int_pop_back_137_comment},
  {"get_element", &Dtool_PointerToArray_int_get_element_138, METH_O, (const char *)Dtool_PointerToArray_int_get_element_138_comment},
  {"getElement", &Dtool_PointerToArray_int_get_element_138, METH_O, (const char *)Dtool_PointerToArray_int_get_element_138_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_int_set_element_139, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_int_set_element_139_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_int_set_element_139, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_int_set_element_139_comment},
  {"get_data", &Dtool_PointerToArray_int_get_data_142, METH_NOARGS, (const char *)Dtool_PointerToArray_int_get_data_142_comment},
  {"getData", &Dtool_PointerToArray_int_get_data_142, METH_NOARGS, (const char *)Dtool_PointerToArray_int_get_data_142_comment},
  {"set_data", &Dtool_PointerToArray_int_set_data_143, METH_O, (const char *)Dtool_PointerToArray_int_set_data_143_comment},
  {"setData", &Dtool_PointerToArray_int_set_data_143, METH_O, (const char *)Dtool_PointerToArray_int_set_data_143_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_int_get_subdata_144, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_int_get_subdata_144_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_int_get_subdata_144, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_int_get_subdata_144_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_int_set_subdata_145, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_int_set_subdata_145_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_int_set_subdata_145, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_int_set_subdata_145_comment},
  {"get_ref_count", &Dtool_PointerToArray_int_get_ref_count_146, METH_NOARGS, (const char *)Dtool_PointerToArray_int_get_ref_count_146_comment},
  {"getRefCount", &Dtool_PointerToArray_int_get_ref_count_146, METH_NOARGS, (const char *)Dtool_PointerToArray_int_get_ref_count_146_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_int_get_node_ref_count_147, METH_NOARGS, (const char *)Dtool_PointerToArray_int_get_node_ref_count_147_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_int_get_node_ref_count_147, METH_NOARGS, (const char *)Dtool_PointerToArray_int_get_node_ref_count_147_comment},
  {"count", &Dtool_PointerToArray_int_count_148, METH_O, (const char *)Dtool_PointerToArray_int_count_148_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_int slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_int_getbuffer_149_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< int > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_int, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_int.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_int slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_int_releasebuffer_150_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< int > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_int, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< int > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_int slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_int_setitem_141_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< int > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_int, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_int index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< int >::__setitem__(unsigned long int n, int const &value)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return -1;
        }
#endif
        invoke_extension(local_this).__setitem__(index, (int)arg_val);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, int value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_int slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_int_getitem_140_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< int > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_int, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_int index out of range");
    return nullptr;
  }
  // 1-int const &PointerToArray< int >::__getitem__(unsigned long int n) const
  int return_value = invoke_extension((const PointerToArray< int >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_int slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_int_size_135_sq_length(PyObject *self) {
  PointerToArray< int > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_int, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_int = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_int = {
  &Dtool_PointerToArray_int_size_135_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_int_getitem_140_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_int_setitem_141_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_int = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_int = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_int_getbuffer_149_bf_getbuffer,
  &Dtool_PointerToArray_int_releasebuffer_150_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_int = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_int = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_int",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_int,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_int,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_int,
    &Dtool_SequenceMethods_PointerToArray_int,
    &Dtool_MappingMethods_PointerToArray_int,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_int,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_int,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_int,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_int,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_int,
  Dtool_UpcastInterface_PointerToArray_int,
  Dtool_DowncastInterface_PointerToArray_int,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_int,
};

static void Dtool_PyModuleClassInit_PointerToArray_int(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_int(nullptr);
    Dtool_PointerToArray_int._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_int);
    Dtool_PointerToArray_int._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_int._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_int) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_int)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_int);
  }
}

/**
 * Python method tables for PointerToArray_unsigned_char (PointerToArray_unsigned_char)
 */
static PyMethodDef Dtool_Methods_PointerToArray_unsigned_char[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_unsigned_char_empty_array_155, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_unsigned_char_empty_array_155_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_unsigned_char_empty_array_155, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_unsigned_char_empty_array_155_comment},
  {"clear", &Dtool_PointerToArray_unsigned_char_clear_156, METH_NOARGS, (const char *)Dtool_PointerToArray_unsigned_char_clear_156_comment},
  {"push_back", &Dtool_PointerToArray_unsigned_char_push_back_158, METH_O, (const char *)Dtool_PointerToArray_unsigned_char_push_back_158_comment},
  {"pushBack", &Dtool_PointerToArray_unsigned_char_push_back_158, METH_O, (const char *)Dtool_PointerToArray_unsigned_char_push_back_158_comment},
  {"pop_back", &Dtool_PointerToArray_unsigned_char_pop_back_159, METH_NOARGS, (const char *)Dtool_PointerToArray_unsigned_char_pop_back_159_comment},
  {"popBack", &Dtool_PointerToArray_unsigned_char_pop_back_159, METH_NOARGS, (const char *)Dtool_PointerToArray_unsigned_char_pop_back_159_comment},
  {"get_element", &Dtool_PointerToArray_unsigned_char_get_element_160, METH_O, (const char *)Dtool_PointerToArray_unsigned_char_get_element_160_comment},
  {"getElement", &Dtool_PointerToArray_unsigned_char_get_element_160, METH_O, (const char *)Dtool_PointerToArray_unsigned_char_get_element_160_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_unsigned_char_set_element_161, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_unsigned_char_set_element_161_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_unsigned_char_set_element_161, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_unsigned_char_set_element_161_comment},
  {"get_data", &Dtool_PointerToArray_unsigned_char_get_data_164, METH_NOARGS, (const char *)Dtool_PointerToArray_unsigned_char_get_data_164_comment},
  {"getData", &Dtool_PointerToArray_unsigned_char_get_data_164, METH_NOARGS, (const char *)Dtool_PointerToArray_unsigned_char_get_data_164_comment},
  {"set_data", &Dtool_PointerToArray_unsigned_char_set_data_165, METH_O, (const char *)Dtool_PointerToArray_unsigned_char_set_data_165_comment},
  {"setData", &Dtool_PointerToArray_unsigned_char_set_data_165, METH_O, (const char *)Dtool_PointerToArray_unsigned_char_set_data_165_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_unsigned_char_get_subdata_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_unsigned_char_get_subdata_166_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_unsigned_char_get_subdata_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_unsigned_char_get_subdata_166_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_unsigned_char_set_subdata_167, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_unsigned_char_set_subdata_167_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_unsigned_char_set_subdata_167, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_unsigned_char_set_subdata_167_comment},
  {"get_ref_count", &Dtool_PointerToArray_unsigned_char_get_ref_count_168, METH_NOARGS, (const char *)Dtool_PointerToArray_unsigned_char_get_ref_count_168_comment},
  {"getRefCount", &Dtool_PointerToArray_unsigned_char_get_ref_count_168, METH_NOARGS, (const char *)Dtool_PointerToArray_unsigned_char_get_ref_count_168_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_unsigned_char_get_node_ref_count_169, METH_NOARGS, (const char *)Dtool_PointerToArray_unsigned_char_get_node_ref_count_169_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_unsigned_char_get_node_ref_count_169, METH_NOARGS, (const char *)Dtool_PointerToArray_unsigned_char_get_node_ref_count_169_comment},
  {"count", &Dtool_PointerToArray_unsigned_char_count_170, METH_O, (const char *)Dtool_PointerToArray_unsigned_char_count_170_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_unsigned_char slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_unsigned_char_getbuffer_171_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< unsigned char > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_unsigned_char.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_unsigned_char slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_unsigned_char_releasebuffer_172_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< unsigned char > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< unsigned char > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_unsigned_char slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_unsigned_char_setitem_163_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< unsigned char > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_unsigned_char index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< unsigned char >::__setitem__(unsigned long int n, unsigned char const &value)
      if (PyLongOrInt_Check(arg)) {
        long param2 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
        if (param2 < 0 || param2 > UCHAR_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned byte",
                       param2);
          return -1;
        }
#endif
        invoke_extension(local_this).__setitem__(index, (unsigned char)param2);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, int value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_unsigned_char slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_unsigned_char_getitem_162_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< unsigned char > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_unsigned_char index out of range");
    return nullptr;
  }
  // 1-unsigned char const &PointerToArray< unsigned char >::__getitem__(unsigned long int n) const
  unsigned char return_value = invoke_extension((const PointerToArray< unsigned char >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_unsigned_char slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_unsigned_char_size_157_sq_length(PyObject *self) {
  PointerToArray< unsigned char > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_unsigned_char, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_unsigned_char = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_unsigned_char = {
  &Dtool_PointerToArray_unsigned_char_size_157_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_unsigned_char_getitem_162_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_unsigned_char_setitem_163_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_unsigned_char = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_unsigned_char = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_unsigned_char_getbuffer_171_bf_getbuffer,
  &Dtool_PointerToArray_unsigned_char_releasebuffer_172_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_unsigned_char = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_unsigned_char = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_unsigned_char",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_unsigned_char,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_unsigned_char,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_unsigned_char,
    &Dtool_SequenceMethods_PointerToArray_unsigned_char,
    &Dtool_MappingMethods_PointerToArray_unsigned_char,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_unsigned_char,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_unsigned_char,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_unsigned_char,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_unsigned_char,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_unsigned_char,
  Dtool_UpcastInterface_PointerToArray_unsigned_char,
  Dtool_DowncastInterface_PointerToArray_unsigned_char,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_unsigned_char,
};

static void Dtool_PyModuleClassInit_PointerToArray_unsigned_char(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_unsigned_char(nullptr);
    Dtool_PointerToArray_unsigned_char._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_unsigned_char);
    Dtool_PointerToArray_unsigned_char._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_unsigned_char._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_unsigned_char) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_unsigned_char)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_unsigned_char);
  }
}

/**
 * Python method tables for MemoryUsage (MemoryUsage)
 */
static PyMethodDef Dtool_Methods_MemoryUsage[] = {
  {"is_tracking", &Dtool_MemoryUsage_is_tracking_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_is_tracking_176_comment},
  {"isTracking", &Dtool_MemoryUsage_is_tracking_176, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_is_tracking_176_comment},
  {"is_counting", &Dtool_MemoryUsage_is_counting_177, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_is_counting_177_comment},
  {"isCounting", &Dtool_MemoryUsage_is_counting_177, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_is_counting_177_comment},
  {"get_current_cpp_size", &Dtool_MemoryUsage_get_current_cpp_size_178, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_current_cpp_size_178_comment},
  {"getCurrentCppSize", &Dtool_MemoryUsage_get_current_cpp_size_178, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_current_cpp_size_178_comment},
  {"get_total_cpp_size", &Dtool_MemoryUsage_get_total_cpp_size_179, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_total_cpp_size_179_comment},
  {"getTotalCppSize", &Dtool_MemoryUsage_get_total_cpp_size_179, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_total_cpp_size_179_comment},
  {"get_panda_heap_single_size", &Dtool_MemoryUsage_get_panda_heap_single_size_180, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_panda_heap_single_size_180_comment},
  {"getPandaHeapSingleSize", &Dtool_MemoryUsage_get_panda_heap_single_size_180, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_panda_heap_single_size_180_comment},
  {"get_panda_heap_array_size", &Dtool_MemoryUsage_get_panda_heap_array_size_181, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_panda_heap_array_size_181_comment},
  {"getPandaHeapArraySize", &Dtool_MemoryUsage_get_panda_heap_array_size_181, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_panda_heap_array_size_181_comment},
  {"get_panda_heap_overhead", &Dtool_MemoryUsage_get_panda_heap_overhead_182, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_panda_heap_overhead_182_comment},
  {"getPandaHeapOverhead", &Dtool_MemoryUsage_get_panda_heap_overhead_182, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_panda_heap_overhead_182_comment},
  {"get_panda_mmap_size", &Dtool_MemoryUsage_get_panda_mmap_size_183, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_panda_mmap_size_183_comment},
  {"getPandaMmapSize", &Dtool_MemoryUsage_get_panda_mmap_size_183, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_panda_mmap_size_183_comment},
  {"get_external_size", &Dtool_MemoryUsage_get_external_size_184, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_external_size_184_comment},
  {"getExternalSize", &Dtool_MemoryUsage_get_external_size_184, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_external_size_184_comment},
  {"get_total_size", &Dtool_MemoryUsage_get_total_size_185, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_total_size_185_comment},
  {"getTotalSize", &Dtool_MemoryUsage_get_total_size_185, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_total_size_185_comment},
  {"get_num_pointers", &Dtool_MemoryUsage_get_num_pointers_186, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_num_pointers_186_comment},
  {"getNumPointers", &Dtool_MemoryUsage_get_num_pointers_186, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_num_pointers_186_comment},
  {"get_pointers", &Dtool_MemoryUsage_get_pointers_187, METH_O | METH_STATIC, (const char *)Dtool_MemoryUsage_get_pointers_187_comment},
  {"getPointers", &Dtool_MemoryUsage_get_pointers_187, METH_O | METH_STATIC, (const char *)Dtool_MemoryUsage_get_pointers_187_comment},
  {"get_pointers_of_type", (PyCFunction) &Dtool_MemoryUsage_get_pointers_of_type_188, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_pointers_of_type_188_comment},
  {"getPointersOfType", (PyCFunction) &Dtool_MemoryUsage_get_pointers_of_type_188, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_pointers_of_type_188_comment},
  {"get_pointers_of_age", (PyCFunction) &Dtool_MemoryUsage_get_pointers_of_age_189, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_pointers_of_age_189_comment},
  {"getPointersOfAge", (PyCFunction) &Dtool_MemoryUsage_get_pointers_of_age_189, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_MemoryUsage_get_pointers_of_age_189_comment},
  {"get_pointers_with_zero_count", &Dtool_MemoryUsage_get_pointers_with_zero_count_190, METH_O | METH_STATIC, (const char *)Dtool_MemoryUsage_get_pointers_with_zero_count_190_comment},
  {"getPointersWithZeroCount", &Dtool_MemoryUsage_get_pointers_with_zero_count_190, METH_O | METH_STATIC, (const char *)Dtool_MemoryUsage_get_pointers_with_zero_count_190_comment},
  {"freeze", &Dtool_MemoryUsage_freeze_191, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_freeze_191_comment},
  {"show_current_types", &Dtool_MemoryUsage_show_current_types_192, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_show_current_types_192_comment},
  {"showCurrentTypes", &Dtool_MemoryUsage_show_current_types_192, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_show_current_types_192_comment},
  {"show_trend_types", &Dtool_MemoryUsage_show_trend_types_193, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_show_trend_types_193_comment},
  {"showTrendTypes", &Dtool_MemoryUsage_show_trend_types_193, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_show_trend_types_193_comment},
  {"show_current_ages", &Dtool_MemoryUsage_show_current_ages_194, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_show_current_ages_194_comment},
  {"showCurrentAges", &Dtool_MemoryUsage_show_current_ages_194, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_show_current_ages_194_comment},
  {"show_trend_ages", &Dtool_MemoryUsage_show_trend_ages_195, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_show_trend_ages_195_comment},
  {"showTrendAges", &Dtool_MemoryUsage_show_trend_ages_195, METH_NOARGS | METH_STATIC, (const char *)Dtool_MemoryUsage_show_trend_ages_195_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_MemoryUsage = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MemoryUsage = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_MemoryUsage = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_MemoryUsage = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_MemoryUsage = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_MemoryUsage = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MemoryUsage",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MemoryUsage,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_MemoryUsage,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MemoryUsage,
    &Dtool_SequenceMethods_MemoryUsage,
    &Dtool_MappingMethods_MemoryUsage,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_MemoryUsage,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used strictly for debugging purposes, specifically for\n"
    " * tracking memory leaks of reference-counted objects: it keeps a record of\n"
    " * every such object currently allocated.\n"
    " *\n"
    " * When compiled with NDEBUG set, this entire class does nothing and compiles\n"
    " * to a stub.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MemoryUsage,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MemoryUsage,
    PyType_GenericAlloc,
    Dtool_new_MemoryUsage,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MemoryUsage,
  Dtool_UpcastInterface_MemoryUsage,
  Dtool_DowncastInterface_MemoryUsage,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MemoryUsage(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_MemoryUsage._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MemoryUsage._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_tracking = {(char *)"tracking", &Dtool_MemoryUsage_tracking_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "tracking", Dtool_NewStaticProperty(&Dtool_MemoryUsage._PyType, &def_tracking));
    static const PyGetSetDef def_counting = {(char *)"counting", &Dtool_MemoryUsage_counting_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "counting", Dtool_NewStaticProperty(&Dtool_MemoryUsage._PyType, &def_counting));
    static const PyGetSetDef def_current_cpp_size = {(char *)"current_cpp_size", &Dtool_MemoryUsage_current_cpp_size_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "current_cpp_size", Dtool_NewStaticProperty(&Dtool_MemoryUsage._PyType, &def_current_cpp_size));
    static const PyGetSetDef def_total_cpp_size = {(char *)"total_cpp_size", &Dtool_MemoryUsage_total_cpp_size_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "total_cpp_size", Dtool_NewStaticProperty(&Dtool_MemoryUsage._PyType, &def_total_cpp_size));
    static const PyGetSetDef def_panda_heap_single_size = {(char *)"panda_heap_single_size", &Dtool_MemoryUsage_panda_heap_single_size_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "panda_heap_single_size", Dtool_NewStaticProperty(&Dtool_MemoryUsage._PyType, &def_panda_heap_single_size));
    static const PyGetSetDef def_panda_heap_array_size = {(char *)"panda_heap_array_size", &Dtool_MemoryUsage_panda_heap_array_size_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "panda_heap_array_size", Dtool_NewStaticProperty(&Dtool_MemoryUsage._PyType, &def_panda_heap_array_size));
    static const PyGetSetDef def_panda_heap_overhead = {(char *)"panda_heap_overhead", &Dtool_MemoryUsage_panda_heap_overhead_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "panda_heap_overhead", Dtool_NewStaticProperty(&Dtool_MemoryUsage._PyType, &def_panda_heap_overhead));
    static const PyGetSetDef def_panda_mmap_size = {(char *)"panda_mmap_size", &Dtool_MemoryUsage_panda_mmap_size_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "panda_mmap_size", Dtool_NewStaticProperty(&Dtool_MemoryUsage._PyType, &def_panda_mmap_size));
    static const PyGetSetDef def_external_size = {(char *)"external_size", &Dtool_MemoryUsage_external_size_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "external_size", Dtool_NewStaticProperty(&Dtool_MemoryUsage._PyType, &def_external_size));
    static const PyGetSetDef def_total_size = {(char *)"total_size", &Dtool_MemoryUsage_total_size_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "total_size", Dtool_NewStaticProperty(&Dtool_MemoryUsage._PyType, &def_total_size));
    if (PyType_Ready((PyTypeObject *)&Dtool_MemoryUsage) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MemoryUsage)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MemoryUsage);
  }
}

/**
 * Python method tables for ReferenceCount (ReferenceCount)
 */
static PyMethodDef Dtool_Methods_ReferenceCount[] = {
  {"get_ref_count", &Dtool_ReferenceCount_get_ref_count_215, METH_NOARGS, (const char *)Dtool_ReferenceCount_get_ref_count_215_comment},
  {"getRefCount", &Dtool_ReferenceCount_get_ref_count_215, METH_NOARGS, (const char *)Dtool_ReferenceCount_get_ref_count_215_comment},
  {"ref", &Dtool_ReferenceCount_ref_216, METH_NOARGS, (const char *)Dtool_ReferenceCount_ref_216_comment},
  {"unref", &Dtool_ReferenceCount_unref_217, METH_NOARGS, (const char *)Dtool_ReferenceCount_unref_217_comment},
  {"test_ref_count_integrity", &Dtool_ReferenceCount_test_ref_count_integrity_220, METH_NOARGS, (const char *)Dtool_ReferenceCount_test_ref_count_integrity_220_comment},
  {"testRefCountIntegrity", &Dtool_ReferenceCount_test_ref_count_integrity_220, METH_NOARGS, (const char *)Dtool_ReferenceCount_test_ref_count_integrity_220_comment},
  {"test_ref_count_nonzero", &Dtool_ReferenceCount_test_ref_count_nonzero_221, METH_NOARGS, (const char *)Dtool_ReferenceCount_test_ref_count_nonzero_221_comment},
  {"testRefCountNonzero", &Dtool_ReferenceCount_test_ref_count_nonzero_221, METH_NOARGS, (const char *)Dtool_ReferenceCount_test_ref_count_nonzero_221_comment},
  {"get_class_type", &Dtool_ReferenceCount_get_class_type_222, METH_NOARGS | METH_STATIC, (const char *)Dtool_ReferenceCount_get_class_type_222_comment},
  {"getClassType", &Dtool_ReferenceCount_get_class_type_222, METH_NOARGS | METH_STATIC, (const char *)Dtool_ReferenceCount_get_class_type_222_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ReferenceCount[] = {
  {(char *)"ref_count", &Dtool_ReferenceCount_ref_count_Getter, nullptr, (char *)
    "// The current reference count.",
    nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ReferenceCount = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ReferenceCount = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ReferenceCount",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ReferenceCount,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ReferenceCount,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ReferenceCount,
    &Dtool_SequenceMethods_ReferenceCount,
    &Dtool_MappingMethods_ReferenceCount,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ReferenceCount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for all things that want to be reference-counted.\n"
    " * ReferenceCount works in conjunction with PointerTo to automatically delete\n"
    " * objects when the last pointer to them goes away.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ReferenceCount,
    nullptr, // tp_members
    Dtool_Properties_ReferenceCount,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ReferenceCount,
    PyType_GenericAlloc,
    Dtool_new_ReferenceCount,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ReferenceCount,
  Dtool_UpcastInterface_ReferenceCount,
  Dtool_DowncastInterface_ReferenceCount,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ReferenceCount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ReferenceCount._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ReferenceCount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ReferenceCount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ReferenceCount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ReferenceCount);
  }
}

/**
 * Python method tables for Buffer (Buffer)
 */
static PyMethodDef Dtool_Methods_Buffer[] = {
  {"get_length", &Dtool_Buffer_get_length_224, METH_NOARGS, (const char *)Dtool_Buffer_get_length_224_comment},
  {"getLength", &Dtool_Buffer_get_length_224, METH_NOARGS, (const char *)Dtool_Buffer_get_length_224_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Buffer = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Buffer = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Buffer = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Buffer = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Buffer = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Buffer = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Buffer",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Buffer,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Buffer,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Buffer,
    &Dtool_SequenceMethods_Buffer,
    &Dtool_MappingMethods_Buffer,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Buffer,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Buffer,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Buffer,
    PyType_GenericAlloc,
    Dtool_new_Buffer,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Buffer,
  Dtool_UpcastInterface_Buffer,
  Dtool_DowncastInterface_Buffer,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Buffer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ReferenceCount(nullptr);
    Dtool_Buffer._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ReferenceCount);
    Dtool_Buffer._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Buffer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Buffer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Buffer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Buffer);
  }
}

/**
 * Python method tables for PStatCollectorForwardBase (PStatCollectorForwardBase)
 */
static PyMethodDef Dtool_Methods_PStatCollectorForwardBase[] = {
  {"add_level", &Dtool_PStatCollectorForwardBase_add_level_234, METH_O, (const char *)Dtool_PStatCollectorForwardBase_add_level_234_comment},
  {"addLevel", &Dtool_PStatCollectorForwardBase_add_level_234, METH_O, (const char *)Dtool_PStatCollectorForwardBase_add_level_234_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PStatCollectorForwardBase = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PStatCollectorForwardBase = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PStatCollectorForwardBase = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PStatCollectorForwardBase = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PStatCollectorForwardBase = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PStatCollectorForwardBase = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PStatCollectorForwardBase",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PStatCollectorForwardBase,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PStatCollectorForwardBase,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PStatCollectorForwardBase,
    &Dtool_SequenceMethods_PStatCollectorForwardBase,
    &Dtool_MappingMethods_PStatCollectorForwardBase,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PStatCollectorForwardBase,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class serves as a cheap forward reference to a PStatCollector, which\n"
    " * is defined in the pstatclient module (and is not directly accessible here\n"
    " * in the express module).\n"
    " *\n"
    " * This is subclassed as PStatCollectorForward, which defines the actual\n"
    " * functionality.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PStatCollectorForwardBase,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PStatCollectorForwardBase,
    PyType_GenericAlloc,
    Dtool_new_PStatCollectorForwardBase,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PStatCollectorForwardBase,
  Dtool_UpcastInterface_PStatCollectorForwardBase,
  Dtool_DowncastInterface_PStatCollectorForwardBase,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PStatCollectorForwardBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ReferenceCount(nullptr);
    Dtool_PStatCollectorForwardBase._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ReferenceCount);
    Dtool_PStatCollectorForwardBase._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PStatCollectorForwardBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PStatCollectorForwardBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PStatCollectorForwardBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PStatCollectorForwardBase);
  }
}

/**
 * Python method tables for NodeReferenceCount (NodeReferenceCount)
 */
static PyMethodDef Dtool_Methods_NodeReferenceCount[] = {
  {"get_node_ref_count", &Dtool_NodeReferenceCount_get_node_ref_count_236, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_get_node_ref_count_236_comment},
  {"getNodeRefCount", &Dtool_NodeReferenceCount_get_node_ref_count_236, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_get_node_ref_count_236_comment},
  {"node_ref", &Dtool_NodeReferenceCount_node_ref_237, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_node_ref_237_comment},
  {"nodeRef", &Dtool_NodeReferenceCount_node_ref_237, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_node_ref_237_comment},
  {"node_unref", &Dtool_NodeReferenceCount_node_unref_238, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_node_unref_238_comment},
  {"nodeUnref", &Dtool_NodeReferenceCount_node_unref_238, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_node_unref_238_comment},
  {"test_ref_count_integrity", &Dtool_NodeReferenceCount_test_ref_count_integrity_239, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_test_ref_count_integrity_239_comment},
  {"testRefCountIntegrity", &Dtool_NodeReferenceCount_test_ref_count_integrity_239, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_test_ref_count_integrity_239_comment},
  {"node_unref_only", &Dtool_NodeReferenceCount_node_unref_only_240, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_node_unref_only_240_comment},
  {"nodeUnrefOnly", &Dtool_NodeReferenceCount_node_unref_only_240, METH_NOARGS, (const char *)Dtool_NodeReferenceCount_node_unref_only_240_comment},
  {"get_class_type", &Dtool_NodeReferenceCount_get_class_type_241, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodeReferenceCount_get_class_type_241_comment},
  {"getClassType", &Dtool_NodeReferenceCount_get_class_type_241, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodeReferenceCount_get_class_type_241_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_NodeReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NodeReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_NodeReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_NodeReferenceCount = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_NodeReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_NodeReferenceCount = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.NodeReferenceCount",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NodeReferenceCount,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_NodeReferenceCount,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_NodeReferenceCount,
    &Dtool_SequenceMethods_NodeReferenceCount,
    &Dtool_MappingMethods_NodeReferenceCount,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_NodeReferenceCount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class specializes ReferenceCount to add an additional counter, called\n"
    " * node_ref_count, for the purposes of counting the number of times the object\n"
    " * is referenced by a \"node\", whatever that may mean in context.\n"
    " *\n"
    " * The new methods node_ref() and node_unref() automatically increment and\n"
    " * decrement the primary reference count as well.  There also exists a\n"
    " * NodePointerTo<> class to maintain the node_ref counters automatically.\n"
    " *\n"
    " * See also CachedTypedWritableReferenceCount, which is similar in principle,\n"
    " * as well as NodeCachedReferenceCount, which combines both of these.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NodeReferenceCount,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NodeReferenceCount,
    PyType_GenericAlloc,
    Dtool_new_NodeReferenceCount,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NodeReferenceCount,
  Dtool_UpcastInterface_NodeReferenceCount,
  Dtool_DowncastInterface_NodeReferenceCount,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_NodeReferenceCount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ReferenceCount(nullptr);
    Dtool_NodeReferenceCount._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ReferenceCount);
    Dtool_NodeReferenceCount._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NodeReferenceCount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NodeReferenceCount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NodeReferenceCount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NodeReferenceCount);
  }
}

/**
 * Python method tables for Datagram (Datagram)
 */
static PyMethodDef Dtool_Methods_Datagram[] = {
  {"assign", &Dtool_Datagram_operator_245, METH_O, (const char *)Dtool_Datagram_operator_245_comment},
  {"clear", &Dtool_Datagram_clear_246, METH_NOARGS, (const char *)Dtool_Datagram_clear_246_comment},
  {"dump_hex", (PyCFunction) &Dtool_Datagram_dump_hex_247, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Datagram_dump_hex_247_comment},
  {"dumpHex", (PyCFunction) &Dtool_Datagram_dump_hex_247, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Datagram_dump_hex_247_comment},
  {"add_bool", &Dtool_Datagram_add_bool_248, METH_O, (const char *)Dtool_Datagram_add_bool_248_comment},
  {"addBool", &Dtool_Datagram_add_bool_248, METH_O, (const char *)Dtool_Datagram_add_bool_248_comment},
  {"add_int8", &Dtool_Datagram_add_int8_249, METH_O, (const char *)Dtool_Datagram_add_int8_249_comment},
  {"addInt8", &Dtool_Datagram_add_int8_249, METH_O, (const char *)Dtool_Datagram_add_int8_249_comment},
  {"add_uint8", &Dtool_Datagram_add_uint8_250, METH_O, (const char *)Dtool_Datagram_add_uint8_250_comment},
  {"addUint8", &Dtool_Datagram_add_uint8_250, METH_O, (const char *)Dtool_Datagram_add_uint8_250_comment},
  {"add_int16", &Dtool_Datagram_add_int16_251, METH_O, (const char *)Dtool_Datagram_add_int16_251_comment},
  {"addInt16", &Dtool_Datagram_add_int16_251, METH_O, (const char *)Dtool_Datagram_add_int16_251_comment},
  {"add_int32", &Dtool_Datagram_add_int32_252, METH_O, (const char *)Dtool_Datagram_add_int32_252_comment},
  {"addInt32", &Dtool_Datagram_add_int32_252, METH_O, (const char *)Dtool_Datagram_add_int32_252_comment},
  {"add_int64", &Dtool_Datagram_add_int64_253, METH_O, (const char *)Dtool_Datagram_add_int64_253_comment},
  {"addInt64", &Dtool_Datagram_add_int64_253, METH_O, (const char *)Dtool_Datagram_add_int64_253_comment},
  {"add_uint16", &Dtool_Datagram_add_uint16_254, METH_O, (const char *)Dtool_Datagram_add_uint16_254_comment},
  {"addUint16", &Dtool_Datagram_add_uint16_254, METH_O, (const char *)Dtool_Datagram_add_uint16_254_comment},
  {"add_uint32", &Dtool_Datagram_add_uint32_255, METH_O, (const char *)Dtool_Datagram_add_uint32_255_comment},
  {"addUint32", &Dtool_Datagram_add_uint32_255, METH_O, (const char *)Dtool_Datagram_add_uint32_255_comment},
  {"add_uint64", &Dtool_Datagram_add_uint64_256, METH_O, (const char *)Dtool_Datagram_add_uint64_256_comment},
  {"addUint64", &Dtool_Datagram_add_uint64_256, METH_O, (const char *)Dtool_Datagram_add_uint64_256_comment},
  {"add_float32", &Dtool_Datagram_add_float32_257, METH_O, (const char *)Dtool_Datagram_add_float32_257_comment},
  {"addFloat32", &Dtool_Datagram_add_float32_257, METH_O, (const char *)Dtool_Datagram_add_float32_257_comment},
  {"add_float64", &Dtool_Datagram_add_float64_258, METH_O, (const char *)Dtool_Datagram_add_float64_258_comment},
  {"addFloat64", &Dtool_Datagram_add_float64_258, METH_O, (const char *)Dtool_Datagram_add_float64_258_comment},
  {"add_stdfloat", &Dtool_Datagram_add_stdfloat_259, METH_O, (const char *)Dtool_Datagram_add_stdfloat_259_comment},
  {"addStdfloat", &Dtool_Datagram_add_stdfloat_259, METH_O, (const char *)Dtool_Datagram_add_stdfloat_259_comment},
  {"add_be_int16", &Dtool_Datagram_add_be_int16_260, METH_O, (const char *)Dtool_Datagram_add_be_int16_260_comment},
  {"addBeInt16", &Dtool_Datagram_add_be_int16_260, METH_O, (const char *)Dtool_Datagram_add_be_int16_260_comment},
  {"add_be_int32", &Dtool_Datagram_add_be_int32_261, METH_O, (const char *)Dtool_Datagram_add_be_int32_261_comment},
  {"addBeInt32", &Dtool_Datagram_add_be_int32_261, METH_O, (const char *)Dtool_Datagram_add_be_int32_261_comment},
  {"add_be_int64", &Dtool_Datagram_add_be_int64_262, METH_O, (const char *)Dtool_Datagram_add_be_int64_262_comment},
  {"addBeInt64", &Dtool_Datagram_add_be_int64_262, METH_O, (const char *)Dtool_Datagram_add_be_int64_262_comment},
  {"add_be_uint16", &Dtool_Datagram_add_be_uint16_263, METH_O, (const char *)Dtool_Datagram_add_be_uint16_263_comment},
  {"addBeUint16", &Dtool_Datagram_add_be_uint16_263, METH_O, (const char *)Dtool_Datagram_add_be_uint16_263_comment},
  {"add_be_uint32", &Dtool_Datagram_add_be_uint32_264, METH_O, (const char *)Dtool_Datagram_add_be_uint32_264_comment},
  {"addBeUint32", &Dtool_Datagram_add_be_uint32_264, METH_O, (const char *)Dtool_Datagram_add_be_uint32_264_comment},
  {"add_be_uint64", &Dtool_Datagram_add_be_uint64_265, METH_O, (const char *)Dtool_Datagram_add_be_uint64_265_comment},
  {"addBeUint64", &Dtool_Datagram_add_be_uint64_265, METH_O, (const char *)Dtool_Datagram_add_be_uint64_265_comment},
  {"add_be_float32", &Dtool_Datagram_add_be_float32_266, METH_O, (const char *)Dtool_Datagram_add_be_float32_266_comment},
  {"addBeFloat32", &Dtool_Datagram_add_be_float32_266, METH_O, (const char *)Dtool_Datagram_add_be_float32_266_comment},
  {"add_be_float64", &Dtool_Datagram_add_be_float64_267, METH_O, (const char *)Dtool_Datagram_add_be_float64_267_comment},
  {"addBeFloat64", &Dtool_Datagram_add_be_float64_267, METH_O, (const char *)Dtool_Datagram_add_be_float64_267_comment},
  {"add_string", &Dtool_Datagram_add_string_268, METH_O, (const char *)Dtool_Datagram_add_string_268_comment},
  {"addString", &Dtool_Datagram_add_string_268, METH_O, (const char *)Dtool_Datagram_add_string_268_comment},
  {"add_string32", &Dtool_Datagram_add_string32_269, METH_O, (const char *)Dtool_Datagram_add_string32_269_comment},
  {"addString32", &Dtool_Datagram_add_string32_269, METH_O, (const char *)Dtool_Datagram_add_string32_269_comment},
  {"add_z_string", &Dtool_Datagram_add_z_string_270, METH_O, (const char *)Dtool_Datagram_add_z_string_270_comment},
  {"addZString", &Dtool_Datagram_add_z_string_270, METH_O, (const char *)Dtool_Datagram_add_z_string_270_comment},
  {"add_fixed_string", (PyCFunction) &Dtool_Datagram_add_fixed_string_271, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Datagram_add_fixed_string_271_comment},
  {"addFixedString", (PyCFunction) &Dtool_Datagram_add_fixed_string_271, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Datagram_add_fixed_string_271_comment},
  {"add_wstring", &Dtool_Datagram_add_wstring_272, METH_O, (const char *)Dtool_Datagram_add_wstring_272_comment},
  {"addWstring", &Dtool_Datagram_add_wstring_272, METH_O, (const char *)Dtool_Datagram_add_wstring_272_comment},
  {"add_blob", &Dtool_Datagram_add_blob_273, METH_O, (const char *)Dtool_Datagram_add_blob_273_comment},
  {"addBlob", &Dtool_Datagram_add_blob_273, METH_O, (const char *)Dtool_Datagram_add_blob_273_comment},
  {"add_blob32", &Dtool_Datagram_add_blob32_274, METH_O, (const char *)Dtool_Datagram_add_blob32_274_comment},
  {"addBlob32", &Dtool_Datagram_add_blob32_274, METH_O, (const char *)Dtool_Datagram_add_blob32_274_comment},
  {"pad_bytes", &Dtool_Datagram_pad_bytes_275, METH_O, (const char *)Dtool_Datagram_pad_bytes_275_comment},
  {"padBytes", &Dtool_Datagram_pad_bytes_275, METH_O, (const char *)Dtool_Datagram_pad_bytes_275_comment},
  {"append_data", &Dtool_Datagram_append_data_276, METH_O, (const char *)Dtool_Datagram_append_data_276_comment},
  {"appendData", &Dtool_Datagram_append_data_276, METH_O, (const char *)Dtool_Datagram_append_data_276_comment},
  {"get_message", &Dtool_Datagram_get_message_277, METH_NOARGS, (const char *)Dtool_Datagram_get_message_277_comment},
  {"getMessage", &Dtool_Datagram_get_message_277, METH_NOARGS, (const char *)Dtool_Datagram_get_message_277_comment},
  {"__bytes__", &Dtool_Datagram_bytes_278, METH_NOARGS, (const char *)Dtool_Datagram_bytes_278_comment},
  {"Bytes", &Dtool_Datagram_bytes_278, METH_NOARGS, (const char *)Dtool_Datagram_bytes_278_comment},
  {"get_length", &Dtool_Datagram_get_length_279, METH_NOARGS, (const char *)Dtool_Datagram_get_length_279_comment},
  {"getLength", &Dtool_Datagram_get_length_279, METH_NOARGS, (const char *)Dtool_Datagram_get_length_279_comment},
  {"set_array", &Dtool_Datagram_set_array_280, METH_O, (const char *)Dtool_Datagram_set_array_280_comment},
  {"setArray", &Dtool_Datagram_set_array_280, METH_O, (const char *)Dtool_Datagram_set_array_280_comment},
  {"copy_array", &Dtool_Datagram_copy_array_281, METH_O, (const char *)Dtool_Datagram_copy_array_281_comment},
  {"copyArray", &Dtool_Datagram_copy_array_281, METH_O, (const char *)Dtool_Datagram_copy_array_281_comment},
  {"get_array", &Dtool_Datagram_get_array_282, METH_NOARGS, (const char *)Dtool_Datagram_get_array_282_comment},
  {"getArray", &Dtool_Datagram_get_array_282, METH_NOARGS, (const char *)Dtool_Datagram_get_array_282_comment},
  {"modify_array", &Dtool_Datagram_modify_array_283, METH_NOARGS, (const char *)Dtool_Datagram_modify_array_283_comment},
  {"modifyArray", &Dtool_Datagram_modify_array_283, METH_NOARGS, (const char *)Dtool_Datagram_modify_array_283_comment},
  {"set_stdfloat_double", &Dtool_Datagram_set_stdfloat_double_284, METH_O, (const char *)Dtool_Datagram_set_stdfloat_double_284_comment},
  {"setStdfloatDouble", &Dtool_Datagram_set_stdfloat_double_284, METH_O, (const char *)Dtool_Datagram_set_stdfloat_double_284_comment},
  {"get_stdfloat_double", &Dtool_Datagram_get_stdfloat_double_285, METH_NOARGS, (const char *)Dtool_Datagram_get_stdfloat_double_285_comment},
  {"getStdfloatDouble", &Dtool_Datagram_get_stdfloat_double_285, METH_NOARGS, (const char *)Dtool_Datagram_get_stdfloat_double_285_comment},
  {"output", &Dtool_Datagram_output_289, METH_O, (const char *)Dtool_Datagram_output_289_comment},
  {"write", (PyCFunction) &Dtool_Datagram_write_290, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Datagram_write_290_comment},
  {"get_class_type", &Dtool_Datagram_get_class_type_291, METH_NOARGS | METH_STATIC, (const char *)Dtool_Datagram_get_class_type_291_comment},
  {"getClassType", &Dtool_Datagram_get_class_type_291, METH_NOARGS | METH_STATIC, (const char *)Dtool_Datagram_get_class_type_291_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     Datagram
//////////////////
static PyObject *Dtool_Repr_Datagram(PyObject *self) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Datagram, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     Datagram
//////////////////
static PyObject *Dtool_Str_Datagram(PyObject *self) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Datagram, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     Datagram
//////////////////
static PyObject *Dtool_RichCompare_Datagram(PyObject *self, PyObject *arg, int op) {
  Datagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Datagram, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool Datagram::operator ==(Datagram const &other) const
      Datagram arg_local;
      Datagram const *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const Datagram*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool Datagram::operator !=(Datagram const &other) const
      Datagram arg_local;
      Datagram const *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const Datagram*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool Datagram::operator <(Datagram const &other) const
      Datagram arg_local;
      Datagram const *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const Datagram*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_Datagram = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Datagram = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Datagram = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Datagram = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Datagram = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Datagram = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Datagram",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Datagram,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Datagram,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    &Dtool_Repr_Datagram,
    &Dtool_NumberMethods_Datagram,
    &Dtool_SequenceMethods_Datagram,
    &Dtool_MappingMethods_Datagram,
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_Datagram,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Datagram,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An ordered list of data elements, formatted in memory for transmission over\n"
    " * a socket or writing to a data file.\n"
    " *\n"
    " * Data elements should be added one at a time, in order, to the Datagram.\n"
    " * The nature and contents of the data elements are totally up to the user.\n"
    " * When a Datagram has been transmitted and received, its data elements may be\n"
    " * extracted using a DatagramIterator; it is up to the caller to know the\n"
    " * correct type of each data element in order.\n"
    " *\n"
    " * A Datagram is itself headerless; it is simply a collection of data\n"
    " * elements.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_Datagram,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Datagram,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Datagram,
    PyType_GenericAlloc,
    Dtool_new_Datagram,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Datagram,
  Dtool_UpcastInterface_Datagram,
  Dtool_DowncastInterface_Datagram,
  nullptr,
  (CoerceFunction)Dtool_Coerce_Datagram,
};

static void Dtool_PyModuleClassInit_Datagram(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != nullptr);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_Datagram._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    Dtool_Datagram._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Datagram._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Datagram) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Datagram)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Datagram);
  }
}

/**
 * Python method tables for DatagramGenerator (DatagramGenerator)
 */
static PyMethodDef Dtool_Methods_DatagramGenerator[] = {
  {"get_datagram", &Dtool_DatagramGenerator_get_datagram_294, METH_O, (const char *)Dtool_DatagramGenerator_get_datagram_294_comment},
  {"getDatagram", &Dtool_DatagramGenerator_get_datagram_294, METH_O, (const char *)Dtool_DatagramGenerator_get_datagram_294_comment},
  {"save_datagram", &Dtool_DatagramGenerator_save_datagram_295, METH_O, (const char *)Dtool_DatagramGenerator_save_datagram_295_comment},
  {"saveDatagram", &Dtool_DatagramGenerator_save_datagram_295, METH_O, (const char *)Dtool_DatagramGenerator_save_datagram_295_comment},
  {"is_eof", &Dtool_DatagramGenerator_is_eof_296, METH_NOARGS, (const char *)Dtool_DatagramGenerator_is_eof_296_comment},
  {"isEof", &Dtool_DatagramGenerator_is_eof_296, METH_NOARGS, (const char *)Dtool_DatagramGenerator_is_eof_296_comment},
  {"is_error", &Dtool_DatagramGenerator_is_error_297, METH_NOARGS, (const char *)Dtool_DatagramGenerator_is_error_297_comment},
  {"isError", &Dtool_DatagramGenerator_is_error_297, METH_NOARGS, (const char *)Dtool_DatagramGenerator_is_error_297_comment},
  {"get_filename", &Dtool_DatagramGenerator_get_filename_298, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_filename_298_comment},
  {"getFilename", &Dtool_DatagramGenerator_get_filename_298, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_filename_298_comment},
  {"get_timestamp", &Dtool_DatagramGenerator_get_timestamp_299, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_timestamp_299_comment},
  {"getTimestamp", &Dtool_DatagramGenerator_get_timestamp_299, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_timestamp_299_comment},
  {"get_file", &Dtool_DatagramGenerator_get_file_300, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_file_300_comment},
  {"getFile", &Dtool_DatagramGenerator_get_file_300, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_file_300_comment},
  {"get_vfile", &Dtool_DatagramGenerator_get_vfile_301, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_vfile_301_comment},
  {"getVfile", &Dtool_DatagramGenerator_get_vfile_301, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_vfile_301_comment},
  {"get_file_pos", &Dtool_DatagramGenerator_get_file_pos_302, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_file_pos_302_comment},
  {"getFilePos", &Dtool_DatagramGenerator_get_file_pos_302, METH_NOARGS, (const char *)Dtool_DatagramGenerator_get_file_pos_302_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DatagramGenerator = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_DatagramGenerator = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DatagramGenerator",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DatagramGenerator,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DatagramGenerator,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class defines the abstract interace to any source of datagrams,\n"
    " * whether it be from a file or from the net.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DatagramGenerator,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DatagramGenerator,
    PyType_GenericAlloc,
    Dtool_new_DatagramGenerator,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DatagramGenerator,
  Dtool_UpcastInterface_DatagramGenerator,
  Dtool_DowncastInterface_DatagramGenerator,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DatagramGenerator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DatagramGenerator._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DatagramGenerator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DatagramGenerator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DatagramGenerator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DatagramGenerator);
  }
}

/**
 * Python method tables for DatagramIterator (DatagramIterator)
 */
static PyMethodDef Dtool_Methods_DatagramIterator[] = {
  {"get_bool", &Dtool_DatagramIterator_get_bool_305, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_bool_305_comment},
  {"getBool", &Dtool_DatagramIterator_get_bool_305, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_bool_305_comment},
  {"get_int8", &Dtool_DatagramIterator_get_int8_306, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_int8_306_comment},
  {"getInt8", &Dtool_DatagramIterator_get_int8_306, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_int8_306_comment},
  {"get_uint8", &Dtool_DatagramIterator_get_uint8_307, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_uint8_307_comment},
  {"getUint8", &Dtool_DatagramIterator_get_uint8_307, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_uint8_307_comment},
  {"get_int16", &Dtool_DatagramIterator_get_int16_308, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_int16_308_comment},
  {"getInt16", &Dtool_DatagramIterator_get_int16_308, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_int16_308_comment},
  {"get_int32", &Dtool_DatagramIterator_get_int32_309, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_int32_309_comment},
  {"getInt32", &Dtool_DatagramIterator_get_int32_309, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_int32_309_comment},
  {"get_int64", &Dtool_DatagramIterator_get_int64_310, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_int64_310_comment},
  {"getInt64", &Dtool_DatagramIterator_get_int64_310, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_int64_310_comment},
  {"get_uint16", &Dtool_DatagramIterator_get_uint16_311, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_uint16_311_comment},
  {"getUint16", &Dtool_DatagramIterator_get_uint16_311, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_uint16_311_comment},
  {"get_uint32", &Dtool_DatagramIterator_get_uint32_312, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_uint32_312_comment},
  {"getUint32", &Dtool_DatagramIterator_get_uint32_312, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_uint32_312_comment},
  {"get_uint64", &Dtool_DatagramIterator_get_uint64_313, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_uint64_313_comment},
  {"getUint64", &Dtool_DatagramIterator_get_uint64_313, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_uint64_313_comment},
  {"get_float32", &Dtool_DatagramIterator_get_float32_314, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_float32_314_comment},
  {"getFloat32", &Dtool_DatagramIterator_get_float32_314, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_float32_314_comment},
  {"get_float64", &Dtool_DatagramIterator_get_float64_315, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_float64_315_comment},
  {"getFloat64", &Dtool_DatagramIterator_get_float64_315, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_float64_315_comment},
  {"get_stdfloat", &Dtool_DatagramIterator_get_stdfloat_316, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_stdfloat_316_comment},
  {"getStdfloat", &Dtool_DatagramIterator_get_stdfloat_316, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_stdfloat_316_comment},
  {"get_be_int16", &Dtool_DatagramIterator_get_be_int16_317, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_int16_317_comment},
  {"getBeInt16", &Dtool_DatagramIterator_get_be_int16_317, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_int16_317_comment},
  {"get_be_int32", &Dtool_DatagramIterator_get_be_int32_318, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_int32_318_comment},
  {"getBeInt32", &Dtool_DatagramIterator_get_be_int32_318, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_int32_318_comment},
  {"get_be_int64", &Dtool_DatagramIterator_get_be_int64_319, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_int64_319_comment},
  {"getBeInt64", &Dtool_DatagramIterator_get_be_int64_319, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_int64_319_comment},
  {"get_be_uint16", &Dtool_DatagramIterator_get_be_uint16_320, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_uint16_320_comment},
  {"getBeUint16", &Dtool_DatagramIterator_get_be_uint16_320, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_uint16_320_comment},
  {"get_be_uint32", &Dtool_DatagramIterator_get_be_uint32_321, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_uint32_321_comment},
  {"getBeUint32", &Dtool_DatagramIterator_get_be_uint32_321, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_uint32_321_comment},
  {"get_be_uint64", &Dtool_DatagramIterator_get_be_uint64_322, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_uint64_322_comment},
  {"getBeUint64", &Dtool_DatagramIterator_get_be_uint64_322, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_uint64_322_comment},
  {"get_be_float32", &Dtool_DatagramIterator_get_be_float32_323, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_float32_323_comment},
  {"getBeFloat32", &Dtool_DatagramIterator_get_be_float32_323, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_float32_323_comment},
  {"get_be_float64", &Dtool_DatagramIterator_get_be_float64_324, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_float64_324_comment},
  {"getBeFloat64", &Dtool_DatagramIterator_get_be_float64_324, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_be_float64_324_comment},
  {"get_string", &Dtool_DatagramIterator_get_string_325, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_string_325_comment},
  {"getString", &Dtool_DatagramIterator_get_string_325, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_string_325_comment},
  {"get_string32", &Dtool_DatagramIterator_get_string32_326, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_string32_326_comment},
  {"getString32", &Dtool_DatagramIterator_get_string32_326, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_string32_326_comment},
  {"get_z_string", &Dtool_DatagramIterator_get_z_string_327, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_z_string_327_comment},
  {"getZString", &Dtool_DatagramIterator_get_z_string_327, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_z_string_327_comment},
  {"get_fixed_string", &Dtool_DatagramIterator_get_fixed_string_328, METH_O, (const char *)Dtool_DatagramIterator_get_fixed_string_328_comment},
  {"getFixedString", &Dtool_DatagramIterator_get_fixed_string_328, METH_O, (const char *)Dtool_DatagramIterator_get_fixed_string_328_comment},
  {"get_wstring", &Dtool_DatagramIterator_get_wstring_329, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_wstring_329_comment},
  {"getWstring", &Dtool_DatagramIterator_get_wstring_329, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_wstring_329_comment},
  {"get_blob", &Dtool_DatagramIterator_get_blob_330, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_blob_330_comment},
  {"getBlob", &Dtool_DatagramIterator_get_blob_330, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_blob_330_comment},
  {"get_blob32", &Dtool_DatagramIterator_get_blob32_331, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_blob32_331_comment},
  {"getBlob32", &Dtool_DatagramIterator_get_blob32_331, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_blob32_331_comment},
  {"skip_bytes", &Dtool_DatagramIterator_skip_bytes_332, METH_O, (const char *)Dtool_DatagramIterator_skip_bytes_332_comment},
  {"skipBytes", &Dtool_DatagramIterator_skip_bytes_332, METH_O, (const char *)Dtool_DatagramIterator_skip_bytes_332_comment},
  {"extract_bytes", &Dtool_DatagramIterator_extract_bytes_333, METH_O, (const char *)Dtool_DatagramIterator_extract_bytes_333_comment},
  {"extractBytes", &Dtool_DatagramIterator_extract_bytes_333, METH_O, (const char *)Dtool_DatagramIterator_extract_bytes_333_comment},
  {"get_remaining_bytes", &Dtool_DatagramIterator_get_remaining_bytes_334, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_remaining_bytes_334_comment},
  {"getRemainingBytes", &Dtool_DatagramIterator_get_remaining_bytes_334, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_remaining_bytes_334_comment},
  {"get_remaining_size", &Dtool_DatagramIterator_get_remaining_size_335, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_remaining_size_335_comment},
  {"getRemainingSize", &Dtool_DatagramIterator_get_remaining_size_335, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_remaining_size_335_comment},
  {"get_datagram", &Dtool_DatagramIterator_get_datagram_336, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_datagram_336_comment},
  {"getDatagram", &Dtool_DatagramIterator_get_datagram_336, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_datagram_336_comment},
  {"get_current_index", &Dtool_DatagramIterator_get_current_index_337, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_current_index_337_comment},
  {"getCurrentIndex", &Dtool_DatagramIterator_get_current_index_337, METH_NOARGS, (const char *)Dtool_DatagramIterator_get_current_index_337_comment},
  {"output", &Dtool_DatagramIterator_output_338, METH_O, (const char *)Dtool_DatagramIterator_output_338_comment},
  {"write", (PyCFunction) &Dtool_DatagramIterator_write_339, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DatagramIterator_write_339_comment},
  {"get_class_type", &Dtool_DatagramIterator_get_class_type_340, METH_NOARGS | METH_STATIC, (const char *)Dtool_DatagramIterator_get_class_type_340_comment},
  {"getClassType", &Dtool_DatagramIterator_get_class_type_340, METH_NOARGS | METH_STATIC, (const char *)Dtool_DatagramIterator_get_class_type_340_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     DatagramIterator
//////////////////
static PyObject *Dtool_Repr_DatagramIterator(PyObject *self) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DatagramIterator, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     DatagramIterator
//////////////////
static PyObject *Dtool_Str_DatagramIterator(PyObject *self) {
  DatagramIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DatagramIterator, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_DatagramIterator = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_DatagramIterator = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DatagramIterator",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DatagramIterator,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_DatagramIterator,
    &Dtool_NumberMethods_DatagramIterator,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_DatagramIterator,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class to retrieve the individual data elements previously stored in a\n"
    " * Datagram.  Elements may be retrieved one at a time; it is up to the caller\n"
    " * to know the correct type and order of each element.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DatagramIterator,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DatagramIterator,
    PyType_GenericAlloc,
    Dtool_new_DatagramIterator,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DatagramIterator,
  Dtool_UpcastInterface_DatagramIterator,
  Dtool_DowncastInterface_DatagramIterator,
  nullptr,
  (CoerceFunction)Dtool_Coerce_DatagramIterator,
};

static void Dtool_PyModuleClassInit_DatagramIterator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DatagramIterator._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DatagramIterator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DatagramIterator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DatagramIterator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DatagramIterator);
  }
}

/**
 * Python method tables for DatagramSink (DatagramSink)
 */
static PyMethodDef Dtool_Methods_DatagramSink[] = {
  {"put_datagram", &Dtool_DatagramSink_put_datagram_344, METH_O, (const char *)Dtool_DatagramSink_put_datagram_344_comment},
  {"putDatagram", &Dtool_DatagramSink_put_datagram_344, METH_O, (const char *)Dtool_DatagramSink_put_datagram_344_comment},
  {"copy_datagram", (PyCFunction) &Dtool_DatagramSink_copy_datagram_345, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DatagramSink_copy_datagram_345_comment},
  {"copyDatagram", (PyCFunction) &Dtool_DatagramSink_copy_datagram_345, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DatagramSink_copy_datagram_345_comment},
  {"is_error", &Dtool_DatagramSink_is_error_346, METH_NOARGS, (const char *)Dtool_DatagramSink_is_error_346_comment},
  {"isError", &Dtool_DatagramSink_is_error_346, METH_NOARGS, (const char *)Dtool_DatagramSink_is_error_346_comment},
  {"flush", &Dtool_DatagramSink_flush_347, METH_NOARGS, (const char *)Dtool_DatagramSink_flush_347_comment},
  {"get_filename", &Dtool_DatagramSink_get_filename_348, METH_NOARGS, (const char *)Dtool_DatagramSink_get_filename_348_comment},
  {"getFilename", &Dtool_DatagramSink_get_filename_348, METH_NOARGS, (const char *)Dtool_DatagramSink_get_filename_348_comment},
  {"get_file", &Dtool_DatagramSink_get_file_349, METH_NOARGS, (const char *)Dtool_DatagramSink_get_file_349_comment},
  {"getFile", &Dtool_DatagramSink_get_file_349, METH_NOARGS, (const char *)Dtool_DatagramSink_get_file_349_comment},
  {"get_file_pos", &Dtool_DatagramSink_get_file_pos_350, METH_NOARGS, (const char *)Dtool_DatagramSink_get_file_pos_350_comment},
  {"getFilePos", &Dtool_DatagramSink_get_file_pos_350, METH_NOARGS, (const char *)Dtool_DatagramSink_get_file_pos_350_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_DatagramSink[] = {
  {(char *)"filename", &Dtool_DatagramSink_filename_Getter, nullptr, nullptr, nullptr},
  {(char *)"file", &Dtool_DatagramSink_file_Getter, nullptr, nullptr, nullptr},
  {(char *)"file_pos", &Dtool_DatagramSink_file_pos_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_DatagramSink = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_DatagramSink = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DatagramSink",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DatagramSink,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DatagramSink,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class defines the abstract interface to sending datagrams to any\n"
    " * target, whether it be into a file or across the net\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DatagramSink,
    nullptr, // tp_members
    Dtool_Properties_DatagramSink,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DatagramSink,
    PyType_GenericAlloc,
    Dtool_new_DatagramSink,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DatagramSink,
  Dtool_UpcastInterface_DatagramSink,
  Dtool_DowncastInterface_DatagramSink,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DatagramSink(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DatagramSink._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DatagramSink._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DatagramSink) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DatagramSink)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DatagramSink);
  }
}

/**
 * Python method tables for FileReference (FileReference)
 */
static PyMethodDef Dtool_Methods_FileReference[] = {
  {"get_filename", &Dtool_FileReference_get_filename_366, METH_NOARGS, (const char *)Dtool_FileReference_get_filename_366_comment},
  {"getFilename", &Dtool_FileReference_get_filename_366, METH_NOARGS, (const char *)Dtool_FileReference_get_filename_366_comment},
  {"get_class_type", &Dtool_FileReference_get_class_type_367, METH_NOARGS | METH_STATIC, (const char *)Dtool_FileReference_get_class_type_367_comment},
  {"getClassType", &Dtool_FileReference_get_class_type_367, METH_NOARGS | METH_STATIC, (const char *)Dtool_FileReference_get_class_type_367_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_FileReference = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_FileReference = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_FileReference = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_FileReference = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_FileReference = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_FileReference = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.FileReference",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_FileReference,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_FileReference,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_FileReference,
    &Dtool_SequenceMethods_FileReference,
    &Dtool_MappingMethods_FileReference,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_FileReference,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Keeps a reference-counted pointer to a file on disk.  As long as the\n"
    " * FileReference is held, someone presumably has a use for this file.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_FileReference,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_FileReference,
    PyType_GenericAlloc,
    Dtool_new_FileReference,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_FileReference,
  Dtool_UpcastInterface_FileReference,
  Dtool_DowncastInterface_FileReference,
  (CoerceFunction)Dtool_ConstCoerce_FileReference,
  (CoerceFunction)Dtool_Coerce_FileReference,
};

static void Dtool_PyModuleClassInit_FileReference(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedReferenceCount(nullptr);
    Dtool_FileReference._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TypedReferenceCount);
    Dtool_FileReference._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_FileReference._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_FileReference) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(FileReference)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_FileReference);
  }
}

/**
 * Python method tables for TypedReferenceCount (TypedReferenceCount)
 */
static PyMethodDef Dtool_Methods_TypedReferenceCount[] = {
  {"get_class_type", &Dtool_TypedReferenceCount_get_class_type_363, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedReferenceCount_get_class_type_363_comment},
  {"getClassType", &Dtool_TypedReferenceCount_get_class_type_363, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedReferenceCount_get_class_type_363_comment},
  {"upcast_to_TypedObject", &Dtool_TypedReferenceCount_upcast_to_TypedObject_359, METH_NOARGS, (const char *)Dtool_TypedReferenceCount_upcast_to_TypedObject_359_comment},
  {"upcastToTypedObject", &Dtool_TypedReferenceCount_upcast_to_TypedObject_359, METH_NOARGS, (const char *)Dtool_TypedReferenceCount_upcast_to_TypedObject_359_comment},
  {"upcast_to_ReferenceCount", &Dtool_TypedReferenceCount_upcast_to_ReferenceCount_361, METH_NOARGS, (const char *)Dtool_TypedReferenceCount_upcast_to_ReferenceCount_361_comment},
  {"upcastToReferenceCount", &Dtool_TypedReferenceCount_upcast_to_ReferenceCount_361, METH_NOARGS, (const char *)Dtool_TypedReferenceCount_upcast_to_ReferenceCount_361_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TypedReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TypedReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TypedReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TypedReferenceCount = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TypedReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TypedReferenceCount = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TypedReferenceCount",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TypedReferenceCount,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TypedReferenceCount,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TypedReferenceCount,
    &Dtool_SequenceMethods_TypedReferenceCount,
    &Dtool_MappingMethods_TypedReferenceCount,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TypedReferenceCount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for things which need to inherit from both TypedObject and\n"
    " * from ReferenceCount.  It's convenient to define this intermediate base\n"
    " * class instead of multiply inheriting from the two classes each time they\n"
    " * are needed, so that we can sensibly pass around pointers to things which\n"
    " * are both TypedObjects and ReferenceCounters.\n"
    " *\n"
    " * See also TypedObject for detailed instructions.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TypedReferenceCount,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TypedReferenceCount,
    PyType_GenericAlloc,
    Dtool_new_TypedReferenceCount,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TypedReferenceCount,
  Dtool_UpcastInterface_TypedReferenceCount,
  Dtool_DowncastInterface_TypedReferenceCount,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TypedReferenceCount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != nullptr);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_PyModuleClassInit_ReferenceCount(nullptr);
    Dtool_TypedReferenceCount._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedObject, (PyTypeObject *)&Dtool_ReferenceCount);
    Dtool_TypedReferenceCount._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TypedReferenceCount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TypedReferenceCount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TypedReferenceCount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TypedReferenceCount);
  }
}

/**
 * Python method tables for Ramfile (Ramfile)
 */
static PyMethodDef Dtool_Methods_Ramfile[] = {
  {"seek", &Dtool_Ramfile_seek_385, METH_O, (const char *)Dtool_Ramfile_seek_385_comment},
  {"tell", &Dtool_Ramfile_tell_386, METH_NOARGS, (const char *)Dtool_Ramfile_tell_386_comment},
  {"read", &Dtool_Ramfile_read_387, METH_O, (const char *)Dtool_Ramfile_read_387_comment},
  {"readline", &Dtool_Ramfile_readline_388, METH_NOARGS, (const char *)Dtool_Ramfile_readline_388_comment},
  {"readlines", &Dtool_Ramfile_readlines_389, METH_NOARGS, (const char *)Dtool_Ramfile_readlines_389_comment},
  {"get_data", &Dtool_Ramfile_get_data_390, METH_NOARGS, (const char *)Dtool_Ramfile_get_data_390_comment},
  {"getData", &Dtool_Ramfile_get_data_390, METH_NOARGS, (const char *)Dtool_Ramfile_get_data_390_comment},
  {"get_data_size", &Dtool_Ramfile_get_data_size_391, METH_NOARGS, (const char *)Dtool_Ramfile_get_data_size_391_comment},
  {"getDataSize", &Dtool_Ramfile_get_data_size_391, METH_NOARGS, (const char *)Dtool_Ramfile_get_data_size_391_comment},
  {"clear", &Dtool_Ramfile_clear_392, METH_NOARGS, (const char *)Dtool_Ramfile_clear_392_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Ramfile = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_Ramfile = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Ramfile",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Ramfile,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Ramfile,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An in-memory buffer specifically designed for downloading files to memory.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Ramfile,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Ramfile,
    PyType_GenericAlloc,
    Dtool_new_Ramfile,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Ramfile,
  Dtool_UpcastInterface_Ramfile,
  Dtool_DowncastInterface_Ramfile,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Ramfile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Ramfile._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Ramfile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Ramfile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Ramfile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Ramfile);
  }
}

/**
 * Python method tables for HashVal (HashVal)
 */
static PyMethodDef Dtool_Methods_HashVal[] = {
  {"assign", &Dtool_HashVal_operator_396, METH_O, (const char *)Dtool_HashVal_operator_396_comment},
  {"compare_to", &Dtool_HashVal_compare_to_400, METH_O, (const char *)Dtool_HashVal_compare_to_400_comment},
  {"compareTo", &Dtool_HashVal_compare_to_400, METH_O, (const char *)Dtool_HashVal_compare_to_400_comment},
  {"merge_with", &Dtool_HashVal_merge_with_401, METH_O, (const char *)Dtool_HashVal_merge_with_401_comment},
  {"mergeWith", &Dtool_HashVal_merge_with_401, METH_O, (const char *)Dtool_HashVal_merge_with_401_comment},
  {"output_dec", &Dtool_HashVal_output_dec_402, METH_O, (const char *)Dtool_HashVal_output_dec_402_comment},
  {"outputDec", &Dtool_HashVal_output_dec_402, METH_O, (const char *)Dtool_HashVal_output_dec_402_comment},
  {"input_dec", &Dtool_HashVal_input_dec_403, METH_O, (const char *)Dtool_HashVal_input_dec_403_comment},
  {"inputDec", &Dtool_HashVal_input_dec_403, METH_O, (const char *)Dtool_HashVal_input_dec_403_comment},
  {"output_hex", &Dtool_HashVal_output_hex_404, METH_O, (const char *)Dtool_HashVal_output_hex_404_comment},
  {"outputHex", &Dtool_HashVal_output_hex_404, METH_O, (const char *)Dtool_HashVal_output_hex_404_comment},
  {"input_hex", &Dtool_HashVal_input_hex_405, METH_O, (const char *)Dtool_HashVal_input_hex_405_comment},
  {"inputHex", &Dtool_HashVal_input_hex_405, METH_O, (const char *)Dtool_HashVal_input_hex_405_comment},
  {"output_binary", &Dtool_HashVal_output_binary_406, METH_O, (const char *)Dtool_HashVal_output_binary_406_comment},
  {"outputBinary", &Dtool_HashVal_output_binary_406, METH_O, (const char *)Dtool_HashVal_output_binary_406_comment},
  {"input_binary", &Dtool_HashVal_input_binary_407, METH_O, (const char *)Dtool_HashVal_input_binary_407_comment},
  {"inputBinary", &Dtool_HashVal_input_binary_407, METH_O, (const char *)Dtool_HashVal_input_binary_407_comment},
  {"output", &Dtool_HashVal_output_408, METH_O, (const char *)Dtool_HashVal_output_408_comment},
  {"as_dec", &Dtool_HashVal_as_dec_409, METH_NOARGS, (const char *)Dtool_HashVal_as_dec_409_comment},
  {"asDec", &Dtool_HashVal_as_dec_409, METH_NOARGS, (const char *)Dtool_HashVal_as_dec_409_comment},
  {"set_from_dec", &Dtool_HashVal_set_from_dec_410, METH_O, (const char *)Dtool_HashVal_set_from_dec_410_comment},
  {"setFromDec", &Dtool_HashVal_set_from_dec_410, METH_O, (const char *)Dtool_HashVal_set_from_dec_410_comment},
  {"as_hex", &Dtool_HashVal_as_hex_411, METH_NOARGS, (const char *)Dtool_HashVal_as_hex_411_comment},
  {"asHex", &Dtool_HashVal_as_hex_411, METH_NOARGS, (const char *)Dtool_HashVal_as_hex_411_comment},
  {"set_from_hex", &Dtool_HashVal_set_from_hex_412, METH_O, (const char *)Dtool_HashVal_set_from_hex_412_comment},
  {"setFromHex", &Dtool_HashVal_set_from_hex_412, METH_O, (const char *)Dtool_HashVal_set_from_hex_412_comment},
  {"as_bin", &Dtool_HashVal_as_bin_413, METH_NOARGS, (const char *)Dtool_HashVal_as_bin_413_comment},
  {"asBin", &Dtool_HashVal_as_bin_413, METH_NOARGS, (const char *)Dtool_HashVal_as_bin_413_comment},
  {"set_from_bin", &Dtool_HashVal_set_from_bin_414, METH_O, (const char *)Dtool_HashVal_set_from_bin_414_comment},
  {"setFromBin", &Dtool_HashVal_set_from_bin_414, METH_O, (const char *)Dtool_HashVal_set_from_bin_414_comment},
  {"write_datagram", &Dtool_HashVal_write_datagram_415, METH_O, (const char *)Dtool_HashVal_write_datagram_415_comment},
  {"writeDatagram", &Dtool_HashVal_write_datagram_415, METH_O, (const char *)Dtool_HashVal_write_datagram_415_comment},
  {"read_datagram", &Dtool_HashVal_read_datagram_416, METH_O, (const char *)Dtool_HashVal_read_datagram_416_comment},
  {"readDatagram", &Dtool_HashVal_read_datagram_416, METH_O, (const char *)Dtool_HashVal_read_datagram_416_comment},
  {"write_stream", &Dtool_HashVal_write_stream_417, METH_O, (const char *)Dtool_HashVal_write_stream_417_comment},
  {"writeStream", &Dtool_HashVal_write_stream_417, METH_O, (const char *)Dtool_HashVal_write_stream_417_comment},
  {"read_stream", &Dtool_HashVal_read_stream_418, METH_O, (const char *)Dtool_HashVal_read_stream_418_comment},
  {"readStream", &Dtool_HashVal_read_stream_418, METH_O, (const char *)Dtool_HashVal_read_stream_418_comment},
  {"hash_file", &Dtool_HashVal_hash_file_419, METH_O, (const char *)Dtool_HashVal_hash_file_419_comment},
  {"hashFile", &Dtool_HashVal_hash_file_419, METH_O, (const char *)Dtool_HashVal_hash_file_419_comment},
  {"hash_stream", &Dtool_HashVal_hash_stream_420, METH_O, (const char *)Dtool_HashVal_hash_stream_420_comment},
  {"hashStream", &Dtool_HashVal_hash_stream_420, METH_O, (const char *)Dtool_HashVal_hash_stream_420_comment},
  {"hash_ramfile", &Dtool_HashVal_hash_ramfile_421, METH_O, (const char *)Dtool_HashVal_hash_ramfile_421_comment},
  {"hashRamfile", &Dtool_HashVal_hash_ramfile_421, METH_O, (const char *)Dtool_HashVal_hash_ramfile_421_comment},
  {"hash_string", &Dtool_HashVal_hash_string_422, METH_O, (const char *)Dtool_HashVal_hash_string_422_comment},
  {"hashString", &Dtool_HashVal_hash_string_422, METH_O, (const char *)Dtool_HashVal_hash_string_422_comment},
  {"hash_bytes", &Dtool_HashVal_hash_bytes_423, METH_O, (const char *)Dtool_HashVal_hash_bytes_423_comment},
  {"hashBytes", &Dtool_HashVal_hash_bytes_423, METH_O, (const char *)Dtool_HashVal_hash_bytes_423_comment},
  {"hash_buffer", (PyCFunction) &Dtool_HashVal_hash_buffer_424, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HashVal_hash_buffer_424_comment},
  {"hashBuffer", (PyCFunction) &Dtool_HashVal_hash_buffer_424, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_HashVal_hash_buffer_424_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// HashVal slot tp_compare -> compare_to
//////////////////
static int Dtool_HashVal_compare_to_400_tp_compare(PyObject *self, PyObject *arg) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HashVal, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int HashVal::compare_to(HashVal const &other) const
  HashVal const *arg_this = (HashVal *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HashVal, 1, "HashVal.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const HashVal*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(HashVal self, const HashVal other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     HashVal
//////////////////
static PyObject *Dtool_Repr_HashVal(PyObject *self) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HashVal, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     HashVal
//////////////////
static PyObject *Dtool_RichCompare_HashVal(PyObject *self, PyObject *arg, int op) {
  HashVal *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_HashVal, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool HashVal::operator ==(HashVal const &other) const
      HashVal const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_HashVal);
      if (arg_this != nullptr) {
        bool return_value = ((*(const HashVal*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool HashVal::operator !=(HashVal const &other) const
      HashVal const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_HashVal);
      if (arg_this != nullptr) {
        bool return_value = ((*(const HashVal*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool HashVal::operator <(HashVal const &other) const
      HashVal const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_HashVal);
      if (arg_this != nullptr) {
        bool return_value = ((*(const HashVal*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_HashVal_compare_to_400_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_HashVal = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_HashVal = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.HashVal",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_HashVal,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_HashVal_compare_to_400_tp_compare,
#endif
    &Dtool_Repr_HashVal,
    &Dtool_NumberMethods_HashVal,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Repr_HashVal,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Stores a 128-bit value that represents the hashed contents (typically MD5)\n"
    " * of a file or buffer.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_HashVal,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_HashVal,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_HashVal,
    PyType_GenericAlloc,
    Dtool_new_HashVal,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_HashVal,
  Dtool_UpcastInterface_HashVal,
  Dtool_DowncastInterface_HashVal,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_HashVal(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_HashVal._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_HashVal._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_HashVal) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(HashVal)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_HashVal);
  }
}

/**
 * Python method tables for MemoryUsagePointers (MemoryUsagePointers)
 */
static PyMethodDef Dtool_Methods_MemoryUsagePointers[] = {
  {"get_num_pointers", &Dtool_MemoryUsagePointers_get_num_pointers_429, METH_NOARGS, (const char *)Dtool_MemoryUsagePointers_get_num_pointers_429_comment},
  {"getNumPointers", &Dtool_MemoryUsagePointers_get_num_pointers_429, METH_NOARGS, (const char *)Dtool_MemoryUsagePointers_get_num_pointers_429_comment},
  {"get_pointer", &Dtool_MemoryUsagePointers_get_pointer_430, METH_O, (const char *)Dtool_MemoryUsagePointers_get_pointer_430_comment},
  {"getPointer", &Dtool_MemoryUsagePointers_get_pointer_430, METH_O, (const char *)Dtool_MemoryUsagePointers_get_pointer_430_comment},
  {"get_typed_pointer", &Dtool_MemoryUsagePointers_get_typed_pointer_432, METH_O, (const char *)Dtool_MemoryUsagePointers_get_typed_pointer_432_comment},
  {"getTypedPointer", &Dtool_MemoryUsagePointers_get_typed_pointer_432, METH_O, (const char *)Dtool_MemoryUsagePointers_get_typed_pointer_432_comment},
  {"get_type", &Dtool_MemoryUsagePointers_get_type_434, METH_O, (const char *)Dtool_MemoryUsagePointers_get_type_434_comment},
  {"getType", &Dtool_MemoryUsagePointers_get_type_434, METH_O, (const char *)Dtool_MemoryUsagePointers_get_type_434_comment},
  {"get_type_name", &Dtool_MemoryUsagePointers_get_type_name_435, METH_O, (const char *)Dtool_MemoryUsagePointers_get_type_name_435_comment},
  {"getTypeName", &Dtool_MemoryUsagePointers_get_type_name_435, METH_O, (const char *)Dtool_MemoryUsagePointers_get_type_name_435_comment},
  {"get_age", &Dtool_MemoryUsagePointers_get_age_436, METH_O, (const char *)Dtool_MemoryUsagePointers_get_age_436_comment},
  {"getAge", &Dtool_MemoryUsagePointers_get_age_436, METH_O, (const char *)Dtool_MemoryUsagePointers_get_age_436_comment},
  {"get_python_pointer", &Dtool_MemoryUsagePointers_get_python_pointer_437, METH_O, (const char *)Dtool_MemoryUsagePointers_get_python_pointer_437_comment},
  {"getPythonPointer", &Dtool_MemoryUsagePointers_get_python_pointer_437, METH_O, (const char *)Dtool_MemoryUsagePointers_get_python_pointer_437_comment},
  {"clear", &Dtool_MemoryUsagePointers_clear_438, METH_NOARGS, (const char *)Dtool_MemoryUsagePointers_clear_438_comment},
  {"output", &Dtool_MemoryUsagePointers_output_439, METH_O, (const char *)Dtool_MemoryUsagePointers_output_439_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_pointers", (PyCFunction) &MakeSeq_MemoryUsagePointers_get_pointers, METH_NOARGS, nullptr},
  { "getPointers", (PyCFunction) &MakeSeq_MemoryUsagePointers_get_pointers, METH_NOARGS, nullptr},
  {"get_typed_pointers", (PyCFunction) &MakeSeq_MemoryUsagePointers_get_typed_pointers, METH_NOARGS, nullptr},
  { "getTypedPointers", (PyCFunction) &MakeSeq_MemoryUsagePointers_get_typed_pointers, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     MemoryUsagePointers
//////////////////
static PyObject *Dtool_Repr_MemoryUsagePointers(PyObject *self) {
  MemoryUsagePointers *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_MemoryUsagePointers, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_MemoryUsagePointers = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_MemoryUsagePointers = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MemoryUsagePointers",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MemoryUsagePointers,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_MemoryUsagePointers,
    &Dtool_NumberMethods_MemoryUsagePointers,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_MemoryUsagePointers,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a list of pointers returned by a MemoryUsage object in response to\n"
    " * some query.\n"
    " *\n"
    " * Warning: once pointers are stored in a MemoryUsagePointers object, they are\n"
    " * reference-counted, and will not be freed until the MemoryUsagePointers\n"
    " * object is freed (or clear() is called on the object).  However, they may\n"
    " * not even be freed then; pointers may leak once they have been added to this\n"
    " * structure.  This is because we don't store enough information in this\n"
    " * structure to correctly free the pointers that have been added.  Since this\n"
    " * is intended primarily as a debugging tool, this is not a major issue.\n"
    " *\n"
    " * This class is just a user interface to talk about pointers stored in a\n"
    " * MemoryUsage object.  It doesn't even exist when compiled with NDEBUG.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MemoryUsagePointers,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MemoryUsagePointers,
    PyType_GenericAlloc,
    Dtool_new_MemoryUsagePointers,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MemoryUsagePointers,
  Dtool_UpcastInterface_MemoryUsagePointers,
  Dtool_DowncastInterface_MemoryUsagePointers,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MemoryUsagePointers(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_MemoryUsagePointers._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MemoryUsagePointers._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MemoryUsagePointers) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MemoryUsagePointers)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MemoryUsagePointers);
  }
}

/**
 * Python method tables for ISubStream (ISubStream)
 */
static PyMethodDef Dtool_Methods_ISubStream[] = {
  {"open", (PyCFunction) &Dtool_ISubStream_open_443, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ISubStream_open_443_comment},
  {"close", &Dtool_ISubStream_close_444, METH_NOARGS, (const char *)Dtool_ISubStream_close_444_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ISubStream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ISubStream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ISubStream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ISubStream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ISubStream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ISubStream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ISubStream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ISubStream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ISubStream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ISubStream,
    &Dtool_SequenceMethods_ISubStream,
    &Dtool_MappingMethods_ISubStream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ISubStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An istream object that presents a subwindow into another istream.  The\n"
    " * first character read from this stream will be the \"start\" character from\n"
    " * the source istream; just before the file pointer reaches the \"end\"\n"
    " * character, eof is returned.\n"
    " *\n"
    " * The source stream must be one that we can randomly seek within.  The\n"
    " * resulting ISubStream will also support arbitrary seeks.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ISubStream,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ISubStream,
    PyType_GenericAlloc,
    Dtool_new_ISubStream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ISubStream,
  Dtool_UpcastInterface_ISubStream,
  Dtool_DowncastInterface_ISubStream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ISubStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_std_istream != nullptr);
    assert(Dtool_Ptr_std_istream->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_std_istream->_Dtool_ModuleClassInit(nullptr);
    Dtool_ISubStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_std_istream);
    Dtool_ISubStream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ISubStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ISubStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ISubStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ISubStream);
  }
}

/**
 * Python method tables for OSubStream (OSubStream)
 */
static PyMethodDef Dtool_Methods_OSubStream[] = {
  {"open", (PyCFunction) &Dtool_OSubStream_open_449, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OSubStream_open_449_comment},
  {"close", &Dtool_OSubStream_close_450, METH_NOARGS, (const char *)Dtool_OSubStream_close_450_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OSubStream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OSubStream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OSubStream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OSubStream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OSubStream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OSubStream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.OSubStream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OSubStream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OSubStream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OSubStream,
    &Dtool_SequenceMethods_OSubStream,
    &Dtool_MappingMethods_OSubStream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OSubStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An ostream object that presents a subwindow into another ostream.  The\n"
    " * first character written to this stream will be the \"start\" character in the\n"
    " * dest istream; no characters may be written to character \"end\" or later\n"
    " * (unless end is zero).\n"
    " *\n"
    " * The dest stream must be one that we can randomly seek within.  The\n"
    " * resulting OSubStream will also support arbitrary seeks.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OSubStream,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OSubStream,
    PyType_GenericAlloc,
    Dtool_new_OSubStream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OSubStream,
  Dtool_UpcastInterface_OSubStream,
  Dtool_DowncastInterface_OSubStream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OSubStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_std_ostream != nullptr);
    assert(Dtool_Ptr_std_ostream->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_std_ostream->_Dtool_ModuleClassInit(nullptr);
    Dtool_OSubStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_std_ostream);
    Dtool_OSubStream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OSubStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OSubStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OSubStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OSubStream);
  }
}

/**
 * Python method tables for SubStream (SubStream)
 */
static PyMethodDef Dtool_Methods_SubStream[] = {
  {"open", (PyCFunction) &Dtool_SubStream_open_455, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SubStream_open_455_comment},
  {"close", &Dtool_SubStream_close_456, METH_NOARGS, (const char *)Dtool_SubStream_close_456_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_SubStream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_SubStream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_SubStream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_SubStream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_SubStream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_SubStream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SubStream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SubStream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_SubStream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_SubStream,
    &Dtool_SequenceMethods_SubStream,
    &Dtool_MappingMethods_SubStream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_SubStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Combined ISubStream and OSubStream for bidirectional I/O.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SubStream,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SubStream,
    PyType_GenericAlloc,
    Dtool_new_SubStream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SubStream,
  Dtool_UpcastInterface_SubStream,
  Dtool_DowncastInterface_SubStream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SubStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_std_iostream != nullptr);
    assert(Dtool_Ptr_std_iostream->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_std_iostream->_Dtool_ModuleClassInit(nullptr);
    Dtool_SubStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_std_iostream);
    Dtool_SubStream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SubStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SubStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SubStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SubStream);
  }
}

/**
 * Python method tables for Multifile (Multifile)
 */
static PyMethodDef Dtool_Methods_Multifile[] = {
  {"open_read", (PyCFunction) &Dtool_Multifile_open_read_460, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_open_read_460_comment},
  {"openRead", (PyCFunction) &Dtool_Multifile_open_read_460, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_open_read_460_comment},
  {"open_write", (PyCFunction) &Dtool_Multifile_open_write_461, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_open_write_461_comment},
  {"openWrite", (PyCFunction) &Dtool_Multifile_open_write_461, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_open_write_461_comment},
  {"open_read_write", (PyCFunction) &Dtool_Multifile_open_read_write_462, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_open_read_write_462_comment},
  {"openReadWrite", (PyCFunction) &Dtool_Multifile_open_read_write_462, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_open_read_write_462_comment},
  {"close", &Dtool_Multifile_close_463, METH_NOARGS, (const char *)Dtool_Multifile_close_463_comment},
  {"get_multifile_name", &Dtool_Multifile_get_multifile_name_464, METH_NOARGS, (const char *)Dtool_Multifile_get_multifile_name_464_comment},
  {"getMultifileName", &Dtool_Multifile_get_multifile_name_464, METH_NOARGS, (const char *)Dtool_Multifile_get_multifile_name_464_comment},
  {"set_multifile_name", &Dtool_Multifile_set_multifile_name_465, METH_O, (const char *)Dtool_Multifile_set_multifile_name_465_comment},
  {"setMultifileName", &Dtool_Multifile_set_multifile_name_465, METH_O, (const char *)Dtool_Multifile_set_multifile_name_465_comment},
  {"is_read_valid", &Dtool_Multifile_is_read_valid_466, METH_NOARGS, (const char *)Dtool_Multifile_is_read_valid_466_comment},
  {"isReadValid", &Dtool_Multifile_is_read_valid_466, METH_NOARGS, (const char *)Dtool_Multifile_is_read_valid_466_comment},
  {"is_write_valid", &Dtool_Multifile_is_write_valid_467, METH_NOARGS, (const char *)Dtool_Multifile_is_write_valid_467_comment},
  {"isWriteValid", &Dtool_Multifile_is_write_valid_467, METH_NOARGS, (const char *)Dtool_Multifile_is_write_valid_467_comment},
  {"needs_repack", &Dtool_Multifile_needs_repack_468, METH_NOARGS, (const char *)Dtool_Multifile_needs_repack_468_comment},
  {"needsRepack", &Dtool_Multifile_needs_repack_468, METH_NOARGS, (const char *)Dtool_Multifile_needs_repack_468_comment},
  {"get_timestamp", &Dtool_Multifile_get_timestamp_469, METH_NOARGS, (const char *)Dtool_Multifile_get_timestamp_469_comment},
  {"getTimestamp", &Dtool_Multifile_get_timestamp_469, METH_NOARGS, (const char *)Dtool_Multifile_get_timestamp_469_comment},
  {"set_record_timestamp", &Dtool_Multifile_set_record_timestamp_470, METH_O, (const char *)Dtool_Multifile_set_record_timestamp_470_comment},
  {"setRecordTimestamp", &Dtool_Multifile_set_record_timestamp_470, METH_O, (const char *)Dtool_Multifile_set_record_timestamp_470_comment},
  {"get_record_timestamp", &Dtool_Multifile_get_record_timestamp_471, METH_NOARGS, (const char *)Dtool_Multifile_get_record_timestamp_471_comment},
  {"getRecordTimestamp", &Dtool_Multifile_get_record_timestamp_471, METH_NOARGS, (const char *)Dtool_Multifile_get_record_timestamp_471_comment},
  {"set_scale_factor", &Dtool_Multifile_set_scale_factor_472, METH_O, (const char *)Dtool_Multifile_set_scale_factor_472_comment},
  {"setScaleFactor", &Dtool_Multifile_set_scale_factor_472, METH_O, (const char *)Dtool_Multifile_set_scale_factor_472_comment},
  {"get_scale_factor", &Dtool_Multifile_get_scale_factor_473, METH_NOARGS, (const char *)Dtool_Multifile_get_scale_factor_473_comment},
  {"getScaleFactor", &Dtool_Multifile_get_scale_factor_473, METH_NOARGS, (const char *)Dtool_Multifile_get_scale_factor_473_comment},
  {"set_encryption_flag", &Dtool_Multifile_set_encryption_flag_474, METH_O, (const char *)Dtool_Multifile_set_encryption_flag_474_comment},
  {"setEncryptionFlag", &Dtool_Multifile_set_encryption_flag_474, METH_O, (const char *)Dtool_Multifile_set_encryption_flag_474_comment},
  {"get_encryption_flag", &Dtool_Multifile_get_encryption_flag_475, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_flag_475_comment},
  {"getEncryptionFlag", &Dtool_Multifile_get_encryption_flag_475, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_flag_475_comment},
  {"set_encryption_password", &Dtool_Multifile_set_encryption_password_476, METH_O, (const char *)Dtool_Multifile_set_encryption_password_476_comment},
  {"setEncryptionPassword", &Dtool_Multifile_set_encryption_password_476, METH_O, (const char *)Dtool_Multifile_set_encryption_password_476_comment},
  {"get_encryption_password", &Dtool_Multifile_get_encryption_password_477, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_password_477_comment},
  {"getEncryptionPassword", &Dtool_Multifile_get_encryption_password_477, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_password_477_comment},
  {"set_encryption_algorithm", &Dtool_Multifile_set_encryption_algorithm_478, METH_O, (const char *)Dtool_Multifile_set_encryption_algorithm_478_comment},
  {"setEncryptionAlgorithm", &Dtool_Multifile_set_encryption_algorithm_478, METH_O, (const char *)Dtool_Multifile_set_encryption_algorithm_478_comment},
  {"get_encryption_algorithm", &Dtool_Multifile_get_encryption_algorithm_479, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_algorithm_479_comment},
  {"getEncryptionAlgorithm", &Dtool_Multifile_get_encryption_algorithm_479, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_algorithm_479_comment},
  {"set_encryption_key_length", &Dtool_Multifile_set_encryption_key_length_480, METH_O, (const char *)Dtool_Multifile_set_encryption_key_length_480_comment},
  {"setEncryptionKeyLength", &Dtool_Multifile_set_encryption_key_length_480, METH_O, (const char *)Dtool_Multifile_set_encryption_key_length_480_comment},
  {"get_encryption_key_length", &Dtool_Multifile_get_encryption_key_length_481, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_key_length_481_comment},
  {"getEncryptionKeyLength", &Dtool_Multifile_get_encryption_key_length_481, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_key_length_481_comment},
  {"set_encryption_iteration_count", &Dtool_Multifile_set_encryption_iteration_count_482, METH_O, (const char *)Dtool_Multifile_set_encryption_iteration_count_482_comment},
  {"setEncryptionIterationCount", &Dtool_Multifile_set_encryption_iteration_count_482, METH_O, (const char *)Dtool_Multifile_set_encryption_iteration_count_482_comment},
  {"get_encryption_iteration_count", &Dtool_Multifile_get_encryption_iteration_count_483, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_iteration_count_483_comment},
  {"getEncryptionIterationCount", &Dtool_Multifile_get_encryption_iteration_count_483, METH_NOARGS, (const char *)Dtool_Multifile_get_encryption_iteration_count_483_comment},
  {"add_subfile", (PyCFunction) &Dtool_Multifile_add_subfile_484, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_add_subfile_484_comment},
  {"addSubfile", (PyCFunction) &Dtool_Multifile_add_subfile_484, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_add_subfile_484_comment},
  {"update_subfile", (PyCFunction) &Dtool_Multifile_update_subfile_485, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_update_subfile_485_comment},
  {"updateSubfile", (PyCFunction) &Dtool_Multifile_update_subfile_485, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_update_subfile_485_comment},
  {"add_signature", (PyCFunction) &Dtool_Multifile_add_signature_486, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_add_signature_486_comment},
  {"addSignature", (PyCFunction) &Dtool_Multifile_add_signature_486, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_add_signature_486_comment},
  {"get_num_signatures", &Dtool_Multifile_get_num_signatures_487, METH_NOARGS, (const char *)Dtool_Multifile_get_num_signatures_487_comment},
  {"getNumSignatures", &Dtool_Multifile_get_num_signatures_487, METH_NOARGS, (const char *)Dtool_Multifile_get_num_signatures_487_comment},
  {"get_signature_subject_name", &Dtool_Multifile_get_signature_subject_name_488, METH_O, (const char *)Dtool_Multifile_get_signature_subject_name_488_comment},
  {"getSignatureSubjectName", &Dtool_Multifile_get_signature_subject_name_488, METH_O, (const char *)Dtool_Multifile_get_signature_subject_name_488_comment},
  {"get_signature_friendly_name", &Dtool_Multifile_get_signature_friendly_name_489, METH_O, (const char *)Dtool_Multifile_get_signature_friendly_name_489_comment},
  {"getSignatureFriendlyName", &Dtool_Multifile_get_signature_friendly_name_489, METH_O, (const char *)Dtool_Multifile_get_signature_friendly_name_489_comment},
  {"get_signature_public_key", &Dtool_Multifile_get_signature_public_key_490, METH_O, (const char *)Dtool_Multifile_get_signature_public_key_490_comment},
  {"getSignaturePublicKey", &Dtool_Multifile_get_signature_public_key_490, METH_O, (const char *)Dtool_Multifile_get_signature_public_key_490_comment},
  {"print_signature_certificate", (PyCFunction) &Dtool_Multifile_print_signature_certificate_491, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_print_signature_certificate_491_comment},
  {"printSignatureCertificate", (PyCFunction) &Dtool_Multifile_print_signature_certificate_491, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_print_signature_certificate_491_comment},
  {"write_signature_certificate", (PyCFunction) &Dtool_Multifile_write_signature_certificate_492, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_write_signature_certificate_492_comment},
  {"writeSignatureCertificate", (PyCFunction) &Dtool_Multifile_write_signature_certificate_492, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_write_signature_certificate_492_comment},
  {"validate_signature_certificate", &Dtool_Multifile_validate_signature_certificate_493, METH_O, (const char *)Dtool_Multifile_validate_signature_certificate_493_comment},
  {"validateSignatureCertificate", &Dtool_Multifile_validate_signature_certificate_493, METH_O, (const char *)Dtool_Multifile_validate_signature_certificate_493_comment},
  {"flush", &Dtool_Multifile_flush_494, METH_NOARGS, (const char *)Dtool_Multifile_flush_494_comment},
  {"repack", &Dtool_Multifile_repack_495, METH_NOARGS, (const char *)Dtool_Multifile_repack_495_comment},
  {"get_num_subfiles", &Dtool_Multifile_get_num_subfiles_496, METH_NOARGS, (const char *)Dtool_Multifile_get_num_subfiles_496_comment},
  {"getNumSubfiles", &Dtool_Multifile_get_num_subfiles_496, METH_NOARGS, (const char *)Dtool_Multifile_get_num_subfiles_496_comment},
  {"find_subfile", &Dtool_Multifile_find_subfile_497, METH_O, (const char *)Dtool_Multifile_find_subfile_497_comment},
  {"findSubfile", &Dtool_Multifile_find_subfile_497, METH_O, (const char *)Dtool_Multifile_find_subfile_497_comment},
  {"has_directory", &Dtool_Multifile_has_directory_498, METH_O, (const char *)Dtool_Multifile_has_directory_498_comment},
  {"hasDirectory", &Dtool_Multifile_has_directory_498, METH_O, (const char *)Dtool_Multifile_has_directory_498_comment},
  {"remove_subfile", &Dtool_Multifile_remove_subfile_500, METH_O, (const char *)Dtool_Multifile_remove_subfile_500_comment},
  {"removeSubfile", &Dtool_Multifile_remove_subfile_500, METH_O, (const char *)Dtool_Multifile_remove_subfile_500_comment},
  {"get_subfile_name", &Dtool_Multifile_get_subfile_name_501, METH_O, (const char *)Dtool_Multifile_get_subfile_name_501_comment},
  {"getSubfileName", &Dtool_Multifile_get_subfile_name_501, METH_O, (const char *)Dtool_Multifile_get_subfile_name_501_comment},
  {"get_subfile_length", &Dtool_Multifile_get_subfile_length_503, METH_O, (const char *)Dtool_Multifile_get_subfile_length_503_comment},
  {"getSubfileLength", &Dtool_Multifile_get_subfile_length_503, METH_O, (const char *)Dtool_Multifile_get_subfile_length_503_comment},
  {"get_subfile_timestamp", &Dtool_Multifile_get_subfile_timestamp_504, METH_O, (const char *)Dtool_Multifile_get_subfile_timestamp_504_comment},
  {"getSubfileTimestamp", &Dtool_Multifile_get_subfile_timestamp_504, METH_O, (const char *)Dtool_Multifile_get_subfile_timestamp_504_comment},
  {"is_subfile_compressed", &Dtool_Multifile_is_subfile_compressed_505, METH_O, (const char *)Dtool_Multifile_is_subfile_compressed_505_comment},
  {"isSubfileCompressed", &Dtool_Multifile_is_subfile_compressed_505, METH_O, (const char *)Dtool_Multifile_is_subfile_compressed_505_comment},
  {"is_subfile_encrypted", &Dtool_Multifile_is_subfile_encrypted_506, METH_O, (const char *)Dtool_Multifile_is_subfile_encrypted_506_comment},
  {"isSubfileEncrypted", &Dtool_Multifile_is_subfile_encrypted_506, METH_O, (const char *)Dtool_Multifile_is_subfile_encrypted_506_comment},
  {"is_subfile_text", &Dtool_Multifile_is_subfile_text_507, METH_O, (const char *)Dtool_Multifile_is_subfile_text_507_comment},
  {"isSubfileText", &Dtool_Multifile_is_subfile_text_507, METH_O, (const char *)Dtool_Multifile_is_subfile_text_507_comment},
  {"get_index_end", &Dtool_Multifile_get_index_end_508, METH_NOARGS, (const char *)Dtool_Multifile_get_index_end_508_comment},
  {"getIndexEnd", &Dtool_Multifile_get_index_end_508, METH_NOARGS, (const char *)Dtool_Multifile_get_index_end_508_comment},
  {"get_subfile_internal_start", &Dtool_Multifile_get_subfile_internal_start_509, METH_O, (const char *)Dtool_Multifile_get_subfile_internal_start_509_comment},
  {"getSubfileInternalStart", &Dtool_Multifile_get_subfile_internal_start_509, METH_O, (const char *)Dtool_Multifile_get_subfile_internal_start_509_comment},
  {"get_subfile_internal_length", &Dtool_Multifile_get_subfile_internal_length_510, METH_O, (const char *)Dtool_Multifile_get_subfile_internal_length_510_comment},
  {"getSubfileInternalLength", &Dtool_Multifile_get_subfile_internal_length_510, METH_O, (const char *)Dtool_Multifile_get_subfile_internal_length_510_comment},
  {"read_subfile", &Dtool_Multifile_read_subfile_511, METH_O, (const char *)Dtool_Multifile_read_subfile_511_comment},
  {"readSubfile", &Dtool_Multifile_read_subfile_511, METH_O, (const char *)Dtool_Multifile_read_subfile_511_comment},
  {"open_read_subfile", &Dtool_Multifile_open_read_subfile_512, METH_O, (const char *)Dtool_Multifile_open_read_subfile_512_comment},
  {"openReadSubfile", &Dtool_Multifile_open_read_subfile_512, METH_O, (const char *)Dtool_Multifile_open_read_subfile_512_comment},
  {"close_read_subfile", &Dtool_Multifile_close_read_subfile_513, METH_O | METH_STATIC, (const char *)Dtool_Multifile_close_read_subfile_513_comment},
  {"closeReadSubfile", &Dtool_Multifile_close_read_subfile_513, METH_O | METH_STATIC, (const char *)Dtool_Multifile_close_read_subfile_513_comment},
  {"extract_subfile", (PyCFunction) &Dtool_Multifile_extract_subfile_514, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_extract_subfile_514_comment},
  {"extractSubfile", (PyCFunction) &Dtool_Multifile_extract_subfile_514, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_extract_subfile_514_comment},
  {"extract_subfile_to", (PyCFunction) &Dtool_Multifile_extract_subfile_to_515, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_extract_subfile_to_515_comment},
  {"extractSubfileTo", (PyCFunction) &Dtool_Multifile_extract_subfile_to_515, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_extract_subfile_to_515_comment},
  {"compare_subfile", (PyCFunction) &Dtool_Multifile_compare_subfile_516, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_compare_subfile_516_comment},
  {"compareSubfile", (PyCFunction) &Dtool_Multifile_compare_subfile_516, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_compare_subfile_516_comment},
  {"output", &Dtool_Multifile_output_517, METH_O, (const char *)Dtool_Multifile_output_517_comment},
  {"ls", (PyCFunction) &Dtool_Multifile_ls_518, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Multifile_ls_518_comment},
  {"get_magic_number", &Dtool_Multifile_get_magic_number_519, METH_NOARGS | METH_STATIC, (const char *)Dtool_Multifile_get_magic_number_519_comment},
  {"getMagicNumber", &Dtool_Multifile_get_magic_number_519, METH_NOARGS | METH_STATIC, (const char *)Dtool_Multifile_get_magic_number_519_comment},
  {"set_header_prefix", &Dtool_Multifile_set_header_prefix_523, METH_O, (const char *)Dtool_Multifile_set_header_prefix_523_comment},
  {"setHeaderPrefix", &Dtool_Multifile_set_header_prefix_523, METH_O, (const char *)Dtool_Multifile_set_header_prefix_523_comment},
  {"get_header_prefix", &Dtool_Multifile_get_header_prefix_524, METH_NOARGS, (const char *)Dtool_Multifile_get_header_prefix_524_comment},
  {"getHeaderPrefix", &Dtool_Multifile_get_header_prefix_524, METH_NOARGS, (const char *)Dtool_Multifile_get_header_prefix_524_comment},
  {"get_subfile_names", (PyCFunction) &MakeSeq_Multifile_get_subfile_names, METH_NOARGS, nullptr},
  { "getSubfileNames", (PyCFunction) &MakeSeq_Multifile_get_subfile_names, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     Multifile
//////////////////
static PyObject *Dtool_Repr_Multifile(PyObject *self) {
  Multifile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Multifile, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_Multifile = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Multifile = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Multifile = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Multifile = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Multifile = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Multifile = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Multifile",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Multifile,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Multifile,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_Multifile,
    &Dtool_NumberMethods_Multifile,
    &Dtool_SequenceMethods_Multifile,
    &Dtool_MappingMethods_Multifile,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_Multifile,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Multifile,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A file that contains a set of files.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Multifile,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Multifile,
    PyType_GenericAlloc,
    Dtool_new_Multifile,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Multifile,
  Dtool_UpcastInterface_Multifile,
  Dtool_DowncastInterface_Multifile,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Multifile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ReferenceCount(nullptr);
    Dtool_Multifile._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ReferenceCount);
    Dtool_Multifile._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Multifile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    static const PyGetSetDef def_magic_number = {(char *)"magic_number", &Dtool_Multifile_magic_number_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "magic_number", Dtool_NewStaticProperty(&Dtool_Multifile._PyType, &def_magic_number));
    if (PyType_Ready((PyTypeObject *)&Dtool_Multifile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Multifile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Multifile);
  }
}

/**
 * Python method tables for Namable (Namable)
 */
static PyMethodDef Dtool_Methods_Namable[] = {
  {"set_name", &Dtool_Namable_set_name_527, METH_O, (const char *)Dtool_Namable_set_name_527_comment},
  {"setName", &Dtool_Namable_set_name_527, METH_O, (const char *)Dtool_Namable_set_name_527_comment},
  {"clear_name", &Dtool_Namable_clear_name_528, METH_NOARGS, (const char *)Dtool_Namable_clear_name_528_comment},
  {"clearName", &Dtool_Namable_clear_name_528, METH_NOARGS, (const char *)Dtool_Namable_clear_name_528_comment},
  {"has_name", &Dtool_Namable_has_name_529, METH_NOARGS, (const char *)Dtool_Namable_has_name_529_comment},
  {"hasName", &Dtool_Namable_has_name_529, METH_NOARGS, (const char *)Dtool_Namable_has_name_529_comment},
  {"get_name", &Dtool_Namable_get_name_530, METH_NOARGS, (const char *)Dtool_Namable_get_name_530_comment},
  {"getName", &Dtool_Namable_get_name_530, METH_NOARGS, (const char *)Dtool_Namable_get_name_530_comment},
  {"output", &Dtool_Namable_output_533, METH_O, (const char *)Dtool_Namable_output_533_comment},
  {"get_class_type", &Dtool_Namable_get_class_type_534, METH_NOARGS | METH_STATIC, (const char *)Dtool_Namable_get_class_type_534_comment},
  {"getClassType", &Dtool_Namable_get_class_type_534, METH_NOARGS | METH_STATIC, (const char *)Dtool_Namable_get_class_type_534_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     Namable
//////////////////
static PyObject *Dtool_Repr_Namable(PyObject *self) {
  Namable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Namable, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_Namable[] = {
  {(char *)"name", &Dtool_Namable_name_Getter, &Dtool_Namable_name_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_Namable = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Namable = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Namable = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Namable = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Namable = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Namable = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Namable",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Namable,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Namable,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_Namable,
    &Dtool_NumberMethods_Namable,
    &Dtool_SequenceMethods_Namable,
    &Dtool_MappingMethods_Namable,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_Namable,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Namable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for all things which can have a name.  The name is either\n"
    " * empty or nonempty, but it is never NULL.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Namable,
    nullptr, // tp_members
    Dtool_Properties_Namable,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Namable,
    PyType_GenericAlloc,
    Dtool_new_Namable,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Namable,
  Dtool_UpcastInterface_Namable,
  Dtool_DowncastInterface_Namable,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Namable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Namable._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Namable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Namable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Namable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Namable);
  }
}

/**
 * Python method tables for OpenSSLWrapper (OpenSSLWrapper)
 */
static PyMethodDef Dtool_Methods_OpenSSLWrapper[] = {
  {"clear_certificates", &Dtool_OpenSSLWrapper_clear_certificates_537, METH_NOARGS, (const char *)Dtool_OpenSSLWrapper_clear_certificates_537_comment},
  {"clearCertificates", &Dtool_OpenSSLWrapper_clear_certificates_537, METH_NOARGS, (const char *)Dtool_OpenSSLWrapper_clear_certificates_537_comment},
  {"load_certificates", &Dtool_OpenSSLWrapper_load_certificates_538, METH_O, (const char *)Dtool_OpenSSLWrapper_load_certificates_538_comment},
  {"loadCertificates", &Dtool_OpenSSLWrapper_load_certificates_538, METH_O, (const char *)Dtool_OpenSSLWrapper_load_certificates_538_comment},
  {"load_certificates_from_pem_ram", (PyCFunction) &Dtool_OpenSSLWrapper_load_certificates_from_pem_ram_539, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OpenSSLWrapper_load_certificates_from_pem_ram_539_comment},
  {"loadCertificatesFromPemRam", (PyCFunction) &Dtool_OpenSSLWrapper_load_certificates_from_pem_ram_539, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OpenSSLWrapper_load_certificates_from_pem_ram_539_comment},
  {"load_certificates_from_der_ram", (PyCFunction) &Dtool_OpenSSLWrapper_load_certificates_from_der_ram_540, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OpenSSLWrapper_load_certificates_from_der_ram_540_comment},
  {"loadCertificatesFromDerRam", (PyCFunction) &Dtool_OpenSSLWrapper_load_certificates_from_der_ram_540, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OpenSSLWrapper_load_certificates_from_der_ram_540_comment},
  {"notify_ssl_errors", &Dtool_OpenSSLWrapper_notify_ssl_errors_542, METH_NOARGS, (const char *)Dtool_OpenSSLWrapper_notify_ssl_errors_542_comment},
  {"notifySslErrors", &Dtool_OpenSSLWrapper_notify_ssl_errors_542, METH_NOARGS, (const char *)Dtool_OpenSSLWrapper_notify_ssl_errors_542_comment},
  {"notify_debug_ssl_errors", &Dtool_OpenSSLWrapper_notify_debug_ssl_errors_543, METH_NOARGS, (const char *)Dtool_OpenSSLWrapper_notify_debug_ssl_errors_543_comment},
  {"notifyDebugSslErrors", &Dtool_OpenSSLWrapper_notify_debug_ssl_errors_543, METH_NOARGS, (const char *)Dtool_OpenSSLWrapper_notify_debug_ssl_errors_543_comment},
  {"get_global_ptr", &Dtool_OpenSSLWrapper_get_global_ptr_544, METH_NOARGS | METH_STATIC, (const char *)Dtool_OpenSSLWrapper_get_global_ptr_544_comment},
  {"getGlobalPtr", &Dtool_OpenSSLWrapper_get_global_ptr_544, METH_NOARGS | METH_STATIC, (const char *)Dtool_OpenSSLWrapper_get_global_ptr_544_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OpenSSLWrapper = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_OpenSSLWrapper = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.OpenSSLWrapper",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OpenSSLWrapper,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OpenSSLWrapper,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Provides an interface wrapper around the OpenSSL library, to ensure that\n"
    " * the library is properly initialized in the application, and to provide some\n"
    " * hooks into global OpenSSL context data.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OpenSSLWrapper,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OpenSSLWrapper,
    PyType_GenericAlloc,
    Dtool_new_OpenSSLWrapper,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OpenSSLWrapper,
  Dtool_UpcastInterface_OpenSSLWrapper,
  Dtool_DowncastInterface_OpenSSLWrapper,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OpenSSLWrapper(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_OpenSSLWrapper._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OpenSSLWrapper._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OpenSSLWrapper) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OpenSSLWrapper)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OpenSSLWrapper);
  }
}

/**
 * Python method tables for SubfileInfo (SubfileInfo)
 */
static PyMethodDef Dtool_Methods_SubfileInfo[] = {
  {"assign", &Dtool_SubfileInfo_operator_547, METH_O, (const char *)Dtool_SubfileInfo_operator_547_comment},
  {"is_empty", &Dtool_SubfileInfo_is_empty_548, METH_NOARGS, (const char *)Dtool_SubfileInfo_is_empty_548_comment},
  {"isEmpty", &Dtool_SubfileInfo_is_empty_548, METH_NOARGS, (const char *)Dtool_SubfileInfo_is_empty_548_comment},
  {"get_file", &Dtool_SubfileInfo_get_file_549, METH_NOARGS, (const char *)Dtool_SubfileInfo_get_file_549_comment},
  {"getFile", &Dtool_SubfileInfo_get_file_549, METH_NOARGS, (const char *)Dtool_SubfileInfo_get_file_549_comment},
  {"get_filename", &Dtool_SubfileInfo_get_filename_550, METH_NOARGS, (const char *)Dtool_SubfileInfo_get_filename_550_comment},
  {"getFilename", &Dtool_SubfileInfo_get_filename_550, METH_NOARGS, (const char *)Dtool_SubfileInfo_get_filename_550_comment},
  {"get_start", &Dtool_SubfileInfo_get_start_551, METH_NOARGS, (const char *)Dtool_SubfileInfo_get_start_551_comment},
  {"getStart", &Dtool_SubfileInfo_get_start_551, METH_NOARGS, (const char *)Dtool_SubfileInfo_get_start_551_comment},
  {"get_size", &Dtool_SubfileInfo_get_size_552, METH_NOARGS, (const char *)Dtool_SubfileInfo_get_size_552_comment},
  {"getSize", &Dtool_SubfileInfo_get_size_552, METH_NOARGS, (const char *)Dtool_SubfileInfo_get_size_552_comment},
  {"output", &Dtool_SubfileInfo_output_553, METH_O, (const char *)Dtool_SubfileInfo_output_553_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     SubfileInfo
//////////////////
static PyObject *Dtool_Repr_SubfileInfo(PyObject *self) {
  SubfileInfo *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SubfileInfo, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_SubfileInfo = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_SubfileInfo = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SubfileInfo",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SubfileInfo,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_SubfileInfo,
    &Dtool_NumberMethods_SubfileInfo,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_SubfileInfo,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class records a particular byte sub-range within an existing file on\n"
    " * disk.  Generally, the filename is understood as a physical file on disk,\n"
    " * and not to be looked up via the vfs.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SubfileInfo,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SubfileInfo,
    PyType_GenericAlloc,
    Dtool_new_SubfileInfo,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SubfileInfo,
  Dtool_UpcastInterface_SubfileInfo,
  Dtool_DowncastInterface_SubfileInfo,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_SubfileInfo(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_SubfileInfo._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SubfileInfo._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SubfileInfo) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SubfileInfo)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SubfileInfo);
  }
}

/**
 * Python method tables for VirtualFile (VirtualFile)
 */
static PyMethodDef Dtool_Methods_VirtualFile[] = {
  {"get_file_system", &Dtool_VirtualFile_get_file_system_556, METH_NOARGS, (const char *)Dtool_VirtualFile_get_file_system_556_comment},
  {"getFileSystem", &Dtool_VirtualFile_get_file_system_556, METH_NOARGS, (const char *)Dtool_VirtualFile_get_file_system_556_comment},
  {"get_filename", &Dtool_VirtualFile_get_filename_557, METH_NOARGS, (const char *)Dtool_VirtualFile_get_filename_557_comment},
  {"getFilename", &Dtool_VirtualFile_get_filename_557, METH_NOARGS, (const char *)Dtool_VirtualFile_get_filename_557_comment},
  {"get_original_filename", &Dtool_VirtualFile_get_original_filename_558, METH_NOARGS, (const char *)Dtool_VirtualFile_get_original_filename_558_comment},
  {"getOriginalFilename", &Dtool_VirtualFile_get_original_filename_558, METH_NOARGS, (const char *)Dtool_VirtualFile_get_original_filename_558_comment},
  {"has_file", &Dtool_VirtualFile_has_file_559, METH_NOARGS, (const char *)Dtool_VirtualFile_has_file_559_comment},
  {"hasFile", &Dtool_VirtualFile_has_file_559, METH_NOARGS, (const char *)Dtool_VirtualFile_has_file_559_comment},
  {"is_directory", &Dtool_VirtualFile_is_directory_560, METH_NOARGS, (const char *)Dtool_VirtualFile_is_directory_560_comment},
  {"isDirectory", &Dtool_VirtualFile_is_directory_560, METH_NOARGS, (const char *)Dtool_VirtualFile_is_directory_560_comment},
  {"is_regular_file", &Dtool_VirtualFile_is_regular_file_561, METH_NOARGS, (const char *)Dtool_VirtualFile_is_regular_file_561_comment},
  {"isRegularFile", &Dtool_VirtualFile_is_regular_file_561, METH_NOARGS, (const char *)Dtool_VirtualFile_is_regular_file_561_comment},
  {"is_writable", &Dtool_VirtualFile_is_writable_562, METH_NOARGS, (const char *)Dtool_VirtualFile_is_writable_562_comment},
  {"isWritable", &Dtool_VirtualFile_is_writable_562, METH_NOARGS, (const char *)Dtool_VirtualFile_is_writable_562_comment},
  {"delete_file", &Dtool_VirtualFile_delete_file_563, METH_NOARGS, (const char *)Dtool_VirtualFile_delete_file_563_comment},
  {"deleteFile", &Dtool_VirtualFile_delete_file_563, METH_NOARGS, (const char *)Dtool_VirtualFile_delete_file_563_comment},
  {"rename_file", &Dtool_VirtualFile_rename_file_564, METH_O, (const char *)Dtool_VirtualFile_rename_file_564_comment},
  {"renameFile", &Dtool_VirtualFile_rename_file_564, METH_O, (const char *)Dtool_VirtualFile_rename_file_564_comment},
  {"copy_file", &Dtool_VirtualFile_copy_file_565, METH_O, (const char *)Dtool_VirtualFile_copy_file_565_comment},
  {"copyFile", &Dtool_VirtualFile_copy_file_565, METH_O, (const char *)Dtool_VirtualFile_copy_file_565_comment},
  {"scan_directory", &Dtool_VirtualFile_scan_directory_566, METH_NOARGS, (const char *)Dtool_VirtualFile_scan_directory_566_comment},
  {"scanDirectory", &Dtool_VirtualFile_scan_directory_566, METH_NOARGS, (const char *)Dtool_VirtualFile_scan_directory_566_comment},
  {"output", &Dtool_VirtualFile_output_567, METH_O, (const char *)Dtool_VirtualFile_output_567_comment},
  {"ls", (PyCFunction) &Dtool_VirtualFile_ls_568, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFile_ls_568_comment},
  {"ls_all", (PyCFunction) &Dtool_VirtualFile_ls_all_569, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFile_ls_all_569_comment},
  {"lsAll", (PyCFunction) &Dtool_VirtualFile_ls_all_569, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFile_ls_all_569_comment},
  {"read_file", &Dtool_VirtualFile_read_file_570, METH_O, (const char *)Dtool_VirtualFile_read_file_570_comment},
  {"readFile", &Dtool_VirtualFile_read_file_570, METH_O, (const char *)Dtool_VirtualFile_read_file_570_comment},
  {"open_read_file", &Dtool_VirtualFile_open_read_file_571, METH_O, (const char *)Dtool_VirtualFile_open_read_file_571_comment},
  {"openReadFile", &Dtool_VirtualFile_open_read_file_571, METH_O, (const char *)Dtool_VirtualFile_open_read_file_571_comment},
  {"close_read_file", &Dtool_VirtualFile_close_read_file_572, METH_O, (const char *)Dtool_VirtualFile_close_read_file_572_comment},
  {"closeReadFile", &Dtool_VirtualFile_close_read_file_572, METH_O, (const char *)Dtool_VirtualFile_close_read_file_572_comment},
  {"was_read_successful", &Dtool_VirtualFile_was_read_successful_573, METH_NOARGS, (const char *)Dtool_VirtualFile_was_read_successful_573_comment},
  {"wasReadSuccessful", &Dtool_VirtualFile_was_read_successful_573, METH_NOARGS, (const char *)Dtool_VirtualFile_was_read_successful_573_comment},
  {"write_file", (PyCFunction) &Dtool_VirtualFile_write_file_574, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFile_write_file_574_comment},
  {"writeFile", (PyCFunction) &Dtool_VirtualFile_write_file_574, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFile_write_file_574_comment},
  {"open_write_file", (PyCFunction) &Dtool_VirtualFile_open_write_file_575, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFile_open_write_file_575_comment},
  {"openWriteFile", (PyCFunction) &Dtool_VirtualFile_open_write_file_575, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFile_open_write_file_575_comment},
  {"open_append_file", &Dtool_VirtualFile_open_append_file_576, METH_NOARGS, (const char *)Dtool_VirtualFile_open_append_file_576_comment},
  {"openAppendFile", &Dtool_VirtualFile_open_append_file_576, METH_NOARGS, (const char *)Dtool_VirtualFile_open_append_file_576_comment},
  {"close_write_file", &Dtool_VirtualFile_close_write_file_577, METH_O, (const char *)Dtool_VirtualFile_close_write_file_577_comment},
  {"closeWriteFile", &Dtool_VirtualFile_close_write_file_577, METH_O, (const char *)Dtool_VirtualFile_close_write_file_577_comment},
  {"open_read_write_file", &Dtool_VirtualFile_open_read_write_file_578, METH_O, (const char *)Dtool_VirtualFile_open_read_write_file_578_comment},
  {"openReadWriteFile", &Dtool_VirtualFile_open_read_write_file_578, METH_O, (const char *)Dtool_VirtualFile_open_read_write_file_578_comment},
  {"open_read_append_file", &Dtool_VirtualFile_open_read_append_file_579, METH_NOARGS, (const char *)Dtool_VirtualFile_open_read_append_file_579_comment},
  {"openReadAppendFile", &Dtool_VirtualFile_open_read_append_file_579, METH_NOARGS, (const char *)Dtool_VirtualFile_open_read_append_file_579_comment},
  {"close_read_write_file", &Dtool_VirtualFile_close_read_write_file_580, METH_O, (const char *)Dtool_VirtualFile_close_read_write_file_580_comment},
  {"closeReadWriteFile", &Dtool_VirtualFile_close_read_write_file_580, METH_O, (const char *)Dtool_VirtualFile_close_read_write_file_580_comment},
  {"get_file_size", &Dtool_VirtualFile_get_file_size_581, METH_VARARGS, (const char *)Dtool_VirtualFile_get_file_size_581_comment},
  {"getFileSize", &Dtool_VirtualFile_get_file_size_581, METH_VARARGS, (const char *)Dtool_VirtualFile_get_file_size_581_comment},
  {"get_timestamp", &Dtool_VirtualFile_get_timestamp_582, METH_NOARGS, (const char *)Dtool_VirtualFile_get_timestamp_582_comment},
  {"getTimestamp", &Dtool_VirtualFile_get_timestamp_582, METH_NOARGS, (const char *)Dtool_VirtualFile_get_timestamp_582_comment},
  {"get_system_info", &Dtool_VirtualFile_get_system_info_583, METH_O, (const char *)Dtool_VirtualFile_get_system_info_583_comment},
  {"getSystemInfo", &Dtool_VirtualFile_get_system_info_583, METH_O, (const char *)Dtool_VirtualFile_get_system_info_583_comment},
  {"get_class_type", &Dtool_VirtualFile_get_class_type_584, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFile_get_class_type_584_comment},
  {"getClassType", &Dtool_VirtualFile_get_class_type_584, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFile_get_class_type_584_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     VirtualFile
//////////////////
static PyObject *Dtool_Repr_VirtualFile(PyObject *self) {
  VirtualFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFile, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_VirtualFile = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFile = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VirtualFile = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VirtualFile = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VirtualFile = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VirtualFile = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VirtualFile",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFile,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VirtualFile,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_VirtualFile,
    &Dtool_NumberMethods_VirtualFile,
    &Dtool_SequenceMethods_VirtualFile,
    &Dtool_MappingMethods_VirtualFile,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_VirtualFile,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VirtualFile,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The abstract base class for a file or directory within the\n"
    " * VirtualFileSystem.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VirtualFile,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VirtualFile,
    PyType_GenericAlloc,
    Dtool_new_VirtualFile,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFile,
  Dtool_UpcastInterface_VirtualFile,
  Dtool_DowncastInterface_VirtualFile,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VirtualFile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedReferenceCount(nullptr);
    Dtool_VirtualFile._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TypedReferenceCount);
    Dtool_VirtualFile._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VirtualFile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFile);
  }
}

/**
 * Python method tables for VirtualFileComposite (VirtualFileComposite)
 */
static PyMethodDef Dtool_Methods_VirtualFileComposite[] = {
  {"get_class_type", &Dtool_VirtualFileComposite_get_class_type_587, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileComposite_get_class_type_587_comment},
  {"getClassType", &Dtool_VirtualFileComposite_get_class_type_587, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileComposite_get_class_type_587_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_VirtualFileComposite = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFileComposite = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VirtualFileComposite = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VirtualFileComposite = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VirtualFileComposite = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VirtualFileComposite = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VirtualFileComposite",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileComposite,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VirtualFileComposite,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_VirtualFileComposite,
    &Dtool_SequenceMethods_VirtualFileComposite,
    &Dtool_MappingMethods_VirtualFileComposite,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VirtualFileComposite,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A composite directory within the VirtualFileSystem: this maps to more than\n"
    " * one directory on different mount points.  The resulting directory appears\n"
    " * to be the union of all the individual simple directories.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VirtualFileComposite,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VirtualFileComposite,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileComposite,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileComposite,
  Dtool_UpcastInterface_VirtualFileComposite,
  Dtool_DowncastInterface_VirtualFileComposite,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VirtualFileComposite(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_VirtualFile(nullptr);
    Dtool_VirtualFileComposite._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_VirtualFile);
    Dtool_VirtualFileComposite._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileComposite._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileComposite) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileComposite)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileComposite);
  }
}

/**
 * Python method tables for VirtualFileMount (VirtualFileMount)
 */
static PyMethodDef Dtool_Methods_VirtualFileMount[] = {
  {"get_file_system", &Dtool_VirtualFileMount_get_file_system_590, METH_NOARGS, (const char *)Dtool_VirtualFileMount_get_file_system_590_comment},
  {"getFileSystem", &Dtool_VirtualFileMount_get_file_system_590, METH_NOARGS, (const char *)Dtool_VirtualFileMount_get_file_system_590_comment},
  {"get_mount_point", &Dtool_VirtualFileMount_get_mount_point_591, METH_NOARGS, (const char *)Dtool_VirtualFileMount_get_mount_point_591_comment},
  {"getMountPoint", &Dtool_VirtualFileMount_get_mount_point_591, METH_NOARGS, (const char *)Dtool_VirtualFileMount_get_mount_point_591_comment},
  {"get_mount_flags", &Dtool_VirtualFileMount_get_mount_flags_592, METH_NOARGS, (const char *)Dtool_VirtualFileMount_get_mount_flags_592_comment},
  {"getMountFlags", &Dtool_VirtualFileMount_get_mount_flags_592, METH_NOARGS, (const char *)Dtool_VirtualFileMount_get_mount_flags_592_comment},
  {"output", &Dtool_VirtualFileMount_output_593, METH_O, (const char *)Dtool_VirtualFileMount_output_593_comment},
  {"write", &Dtool_VirtualFileMount_write_594, METH_O, (const char *)Dtool_VirtualFileMount_write_594_comment},
  {"get_class_type", &Dtool_VirtualFileMount_get_class_type_595, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMount_get_class_type_595_comment},
  {"getClassType", &Dtool_VirtualFileMount_get_class_type_595, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMount_get_class_type_595_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     VirtualFileMount
//////////////////
static PyObject *Dtool_Repr_VirtualFileMount(PyObject *self) {
  VirtualFileMount *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileMount, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     VirtualFileMount
//////////////////
static PyObject *Dtool_Str_VirtualFileMount(PyObject *self) {
  VirtualFileMount *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileMount, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_VirtualFileMount = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFileMount = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VirtualFileMount = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VirtualFileMount = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VirtualFileMount = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VirtualFileMount = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VirtualFileMount",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileMount,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VirtualFileMount,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_VirtualFileMount,
    &Dtool_NumberMethods_VirtualFileMount,
    &Dtool_SequenceMethods_VirtualFileMount,
    &Dtool_MappingMethods_VirtualFileMount,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_VirtualFileMount,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VirtualFileMount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The abstract base class for a mount definition used within a\n"
    " * VirtualFileSystem.  Normally users don't need to monkey with this class\n"
    " * directly.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VirtualFileMount,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VirtualFileMount,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileMount,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileMount,
  Dtool_UpcastInterface_VirtualFileMount,
  Dtool_DowncastInterface_VirtualFileMount,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VirtualFileMount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedReferenceCount(nullptr);
    Dtool_VirtualFileMount._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TypedReferenceCount);
    Dtool_VirtualFileMount._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileMount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileMount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileMount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileMount);
  }
}

/**
 * Python method tables for VirtualFileMountMultifile (VirtualFileMountMultifile)
 */
static PyMethodDef Dtool_Methods_VirtualFileMountMultifile[] = {
  {"get_multifile", &Dtool_VirtualFileMountMultifile_get_multifile_598, METH_NOARGS, (const char *)Dtool_VirtualFileMountMultifile_get_multifile_598_comment},
  {"getMultifile", &Dtool_VirtualFileMountMultifile_get_multifile_598, METH_NOARGS, (const char *)Dtool_VirtualFileMountMultifile_get_multifile_598_comment},
  {"get_class_type", &Dtool_VirtualFileMountMultifile_get_class_type_599, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMountMultifile_get_class_type_599_comment},
  {"getClassType", &Dtool_VirtualFileMountMultifile_get_class_type_599, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMountMultifile_get_class_type_599_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_VirtualFileMountMultifile = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFileMountMultifile = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VirtualFileMountMultifile = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VirtualFileMountMultifile = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VirtualFileMountMultifile = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VirtualFileMountMultifile = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VirtualFileMountMultifile",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileMountMultifile,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VirtualFileMountMultifile,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_VirtualFileMountMultifile,
    &Dtool_SequenceMethods_VirtualFileMountMultifile,
    &Dtool_MappingMethods_VirtualFileMountMultifile,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VirtualFileMountMultifile,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Maps a Multifile's contents into the VirtualFileSystem.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VirtualFileMountMultifile,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VirtualFileMountMultifile,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileMountMultifile,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileMountMultifile,
  Dtool_UpcastInterface_VirtualFileMountMultifile,
  Dtool_DowncastInterface_VirtualFileMountMultifile,
  (CoerceFunction)Dtool_ConstCoerce_VirtualFileMountMultifile,
  (CoerceFunction)Dtool_Coerce_VirtualFileMountMultifile,
};

static void Dtool_PyModuleClassInit_VirtualFileMountMultifile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_VirtualFileMount(nullptr);
    Dtool_VirtualFileMountMultifile._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_VirtualFileMount);
    Dtool_VirtualFileMountMultifile._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileMountMultifile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileMountMultifile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileMountMultifile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileMountMultifile);
  }
}

/**
 * Python method tables for VirtualFileMountRamdisk (VirtualFileMountRamdisk)
 */
static PyMethodDef Dtool_Methods_VirtualFileMountRamdisk[] = {
  {"get_class_type", &Dtool_VirtualFileMountRamdisk_get_class_type_602, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMountRamdisk_get_class_type_602_comment},
  {"getClassType", &Dtool_VirtualFileMountRamdisk_get_class_type_602, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMountRamdisk_get_class_type_602_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_VirtualFileMountRamdisk = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFileMountRamdisk = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VirtualFileMountRamdisk = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VirtualFileMountRamdisk = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VirtualFileMountRamdisk = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VirtualFileMountRamdisk = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VirtualFileMountRamdisk",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileMountRamdisk,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VirtualFileMountRamdisk,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_VirtualFileMountRamdisk,
    &Dtool_SequenceMethods_VirtualFileMountRamdisk,
    &Dtool_MappingMethods_VirtualFileMountRamdisk,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VirtualFileMountRamdisk,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Simulates an actual directory on disk with in-memory storage.  This is\n"
    " * useful mainly for performing high level functions that expect disk I/O\n"
    " * without actually writing files to disk.  Naturally, there are significant\n"
    " * limits to the size of the files that may be written with this system; and\n"
    " * \"files\" written here are not automatically persistent between sessions.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VirtualFileMountRamdisk,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VirtualFileMountRamdisk,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileMountRamdisk,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileMountRamdisk,
  Dtool_UpcastInterface_VirtualFileMountRamdisk,
  Dtool_DowncastInterface_VirtualFileMountRamdisk,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VirtualFileMountRamdisk(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_VirtualFileMount(nullptr);
    Dtool_VirtualFileMountRamdisk._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_VirtualFileMount);
    Dtool_VirtualFileMountRamdisk._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileMountRamdisk._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileMountRamdisk) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileMountRamdisk)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileMountRamdisk);
  }
}

/**
 * Python method tables for VirtualFileMountSystem (VirtualFileMountSystem)
 */
static PyMethodDef Dtool_Methods_VirtualFileMountSystem[] = {
  {"get_physical_filename", &Dtool_VirtualFileMountSystem_get_physical_filename_606, METH_NOARGS, (const char *)Dtool_VirtualFileMountSystem_get_physical_filename_606_comment},
  {"getPhysicalFilename", &Dtool_VirtualFileMountSystem_get_physical_filename_606, METH_NOARGS, (const char *)Dtool_VirtualFileMountSystem_get_physical_filename_606_comment},
  {"get_class_type", &Dtool_VirtualFileMountSystem_get_class_type_607, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMountSystem_get_class_type_607_comment},
  {"getClassType", &Dtool_VirtualFileMountSystem_get_class_type_607, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileMountSystem_get_class_type_607_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_VirtualFileMountSystem = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFileMountSystem = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VirtualFileMountSystem = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VirtualFileMountSystem = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VirtualFileMountSystem = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VirtualFileMountSystem = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VirtualFileMountSystem",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileMountSystem,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VirtualFileMountSystem,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_VirtualFileMountSystem,
    &Dtool_SequenceMethods_VirtualFileMountSystem,
    &Dtool_MappingMethods_VirtualFileMountSystem,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VirtualFileMountSystem,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Maps an actual OS directory into the VirtualFileSystem.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VirtualFileMountSystem,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VirtualFileMountSystem,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileMountSystem,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileMountSystem,
  Dtool_UpcastInterface_VirtualFileMountSystem,
  Dtool_DowncastInterface_VirtualFileMountSystem,
  (CoerceFunction)Dtool_ConstCoerce_VirtualFileMountSystem,
  (CoerceFunction)Dtool_Coerce_VirtualFileMountSystem,
};

static void Dtool_PyModuleClassInit_VirtualFileMountSystem(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_VirtualFileMount(nullptr);
    Dtool_VirtualFileMountSystem._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_VirtualFileMount);
    Dtool_VirtualFileMountSystem._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileMountSystem._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileMountSystem) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileMountSystem)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileMountSystem);
  }
}

/**
 * Python method tables for VirtualFileSimple (VirtualFileSimple)
 */
static PyMethodDef Dtool_Methods_VirtualFileSimple[] = {
  {"get_mount", &Dtool_VirtualFileSimple_get_mount_610, METH_NOARGS, (const char *)Dtool_VirtualFileSimple_get_mount_610_comment},
  {"getMount", &Dtool_VirtualFileSimple_get_mount_610, METH_NOARGS, (const char *)Dtool_VirtualFileSimple_get_mount_610_comment},
  {"is_implicit_pz_file", &Dtool_VirtualFileSimple_is_implicit_pz_file_611, METH_NOARGS, (const char *)Dtool_VirtualFileSimple_is_implicit_pz_file_611_comment},
  {"isImplicitPzFile", &Dtool_VirtualFileSimple_is_implicit_pz_file_611, METH_NOARGS, (const char *)Dtool_VirtualFileSimple_is_implicit_pz_file_611_comment},
  {"get_class_type", &Dtool_VirtualFileSimple_get_class_type_612, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileSimple_get_class_type_612_comment},
  {"getClassType", &Dtool_VirtualFileSimple_get_class_type_612, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileSimple_get_class_type_612_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_VirtualFileSimple = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFileSimple = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VirtualFileSimple = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VirtualFileSimple = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VirtualFileSimple = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VirtualFileSimple = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VirtualFileSimple",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileSimple,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VirtualFileSimple,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_VirtualFileSimple,
    &Dtool_SequenceMethods_VirtualFileSimple,
    &Dtool_MappingMethods_VirtualFileSimple,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VirtualFileSimple,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A simple file or directory within the VirtualFileSystem: this maps to\n"
    " * exactly one file on one mount point.  Most directories, and all regular\n"
    " * files, are of this kind.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VirtualFileSimple,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VirtualFileSimple,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileSimple,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileSimple,
  Dtool_UpcastInterface_VirtualFileSimple,
  Dtool_DowncastInterface_VirtualFileSimple,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VirtualFileSimple(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_VirtualFile(nullptr);
    Dtool_VirtualFileSimple._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_VirtualFile);
    Dtool_VirtualFileSimple._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileSimple._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileSimple) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileSimple)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileSimple);
  }
}

/**
 * Python method tables for TemporaryFile (TemporaryFile)
 */
static PyMethodDef Dtool_Methods_TemporaryFile[] = {
  {"get_class_type", &Dtool_TemporaryFile_get_class_type_616, METH_NOARGS | METH_STATIC, (const char *)Dtool_TemporaryFile_get_class_type_616_comment},
  {"getClassType", &Dtool_TemporaryFile_get_class_type_616, METH_NOARGS | METH_STATIC, (const char *)Dtool_TemporaryFile_get_class_type_616_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TemporaryFile = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TemporaryFile = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TemporaryFile = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TemporaryFile = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TemporaryFile = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TemporaryFile = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TemporaryFile",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TemporaryFile,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TemporaryFile,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TemporaryFile,
    &Dtool_SequenceMethods_TemporaryFile,
    &Dtool_MappingMethods_TemporaryFile,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TemporaryFile,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special kind of FileReference class that automatically deletes\n"
    " * the file in question when it is deleted.  It is not responsible for\n"
    " * creating, opening, or closing the file, however.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TemporaryFile,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TemporaryFile,
    PyType_GenericAlloc,
    Dtool_new_TemporaryFile,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TemporaryFile,
  Dtool_UpcastInterface_TemporaryFile,
  Dtool_DowncastInterface_TemporaryFile,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TemporaryFile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_FileReference(nullptr);
    Dtool_TemporaryFile._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_FileReference);
    Dtool_TemporaryFile._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TemporaryFile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TemporaryFile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TemporaryFile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TemporaryFile);
  }
}

/**
 * Python method tables for IDecompressStream (IDecompressStream)
 */
static PyMethodDef Dtool_Methods_IDecompressStream[] = {
  {"open", (PyCFunction) &Dtool_IDecompressStream_open_619, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_IDecompressStream_open_619_comment},
  {"close", &Dtool_IDecompressStream_close_620, METH_NOARGS, (const char *)Dtool_IDecompressStream_close_620_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_IDecompressStream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_IDecompressStream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_IDecompressStream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_IDecompressStream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_IDecompressStream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_IDecompressStream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.IDecompressStream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_IDecompressStream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_IDecompressStream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_IDecompressStream,
    &Dtool_SequenceMethods_IDecompressStream,
    &Dtool_MappingMethods_IDecompressStream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_IDecompressStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An input stream object that uses zlib to decompress (inflate) the input\n"
    " * from another source stream on-the-fly.\n"
    " *\n"
    " * Attach an IDecompressStream to an existing istream that provides compressed\n"
    " * data, and read the corresponding uncompressed data from the\n"
    " * IDecompressStream.\n"
    " *\n"
    " * Seeking is not supported.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_IDecompressStream,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_IDecompressStream,
    PyType_GenericAlloc,
    Dtool_new_IDecompressStream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_IDecompressStream,
  Dtool_UpcastInterface_IDecompressStream,
  Dtool_DowncastInterface_IDecompressStream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_IDecompressStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_std_istream != nullptr);
    assert(Dtool_Ptr_std_istream->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_std_istream->_Dtool_ModuleClassInit(nullptr);
    Dtool_IDecompressStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_std_istream);
    Dtool_IDecompressStream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_IDecompressStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_IDecompressStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(IDecompressStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_IDecompressStream);
  }
}

/**
 * Python method tables for OCompressStream (OCompressStream)
 */
static PyMethodDef Dtool_Methods_OCompressStream[] = {
  {"open", (PyCFunction) &Dtool_OCompressStream_open_624, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OCompressStream_open_624_comment},
  {"close", &Dtool_OCompressStream_close_625, METH_NOARGS, (const char *)Dtool_OCompressStream_close_625_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OCompressStream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OCompressStream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OCompressStream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OCompressStream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OCompressStream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OCompressStream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.OCompressStream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OCompressStream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OCompressStream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OCompressStream,
    &Dtool_SequenceMethods_OCompressStream,
    &Dtool_MappingMethods_OCompressStream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OCompressStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An input stream object that uses zlib to compress (deflate) data to another\n"
    " * destination stream on-the-fly.\n"
    " *\n"
    " * Attach an OCompressStream to an existing ostream that will accept\n"
    " * compressed data, and write your uncompressed source data to the\n"
    " * OCompressStream.\n"
    " *\n"
    " * Seeking is not supported.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OCompressStream,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OCompressStream,
    PyType_GenericAlloc,
    Dtool_new_OCompressStream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OCompressStream,
  Dtool_UpcastInterface_OCompressStream,
  Dtool_DowncastInterface_OCompressStream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OCompressStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_std_ostream != nullptr);
    assert(Dtool_Ptr_std_ostream->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_std_ostream->_Dtool_ModuleClassInit(nullptr);
    Dtool_OCompressStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_std_ostream);
    Dtool_OCompressStream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OCompressStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OCompressStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OCompressStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OCompressStream);
  }
}

/**
 * Python method tables for VirtualFileList (VirtualFileList)
 */
static PyMethodDef Dtool_Methods_VirtualFileList[] = {
  {"get_num_files", &Dtool_VirtualFileList_get_num_files_628, METH_NOARGS, (const char *)Dtool_VirtualFileList_get_num_files_628_comment},
  {"getNumFiles", &Dtool_VirtualFileList_get_num_files_628, METH_NOARGS, (const char *)Dtool_VirtualFileList_get_num_files_628_comment},
  {"get_file", &Dtool_VirtualFileList_get_file_629, METH_O, (const char *)Dtool_VirtualFileList_get_file_629_comment},
  {"getFile", &Dtool_VirtualFileList_get_file_629, METH_O, (const char *)Dtool_VirtualFileList_get_file_629_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_files", (PyCFunction) &MakeSeq_VirtualFileList_get_files, METH_NOARGS, nullptr},
  { "getFiles", (PyCFunction) &MakeSeq_VirtualFileList_get_files, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// VirtualFileList slot nb_add -> operator +
//////////////////
static PyObject *Dtool_VirtualFileList_operator_634_nb_add(PyObject *self, PyObject *arg) {
  VirtualFileList *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_VirtualFileList, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline VirtualFileList VirtualFileList::operator +(VirtualFileList const &other) const
  VirtualFileList const *arg_this = (VirtualFileList *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VirtualFileList, 1, "VirtualFileList.__add__", true, true);
  if (arg_this != nullptr) {
    VirtualFileList *return_value = new VirtualFileList(((*(const VirtualFileList*)local_this).operator +)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (return_value != nullptr) {
      return_value->ref();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_VirtualFileList, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// VirtualFileList slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_VirtualFileList_operator_633_nb_inplace_add(PyObject *self, PyObject *arg) {
  VirtualFileList *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_VirtualFileList, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void VirtualFileList::operator +=(VirtualFileList const &other)
  VirtualFileList const *arg_this = (VirtualFileList *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_VirtualFileList, 1, "VirtualFileList.__iadd__", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator +=)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// VirtualFileList slot sq_item -> operator []
//////////////////
static PyObject *Dtool_VirtualFileList_operator_631_sq_item(PyObject *self, Py_ssize_t index) {
  VirtualFileList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileList, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "VirtualFileList index out of range");
    return nullptr;
  }
  // 1-inline VirtualFile *VirtualFileList::operator [](std::size_t n) const
  VirtualFile *return_value = ((*(const VirtualFileList*)local_this).operator [])(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_VirtualFile, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(VirtualFileList self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// VirtualFileList slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_VirtualFileList_size_632_sq_length(PyObject *self) {
  VirtualFileList *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileList, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_VirtualFileList = {
  &Dtool_VirtualFileList_operator_634_nb_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  &Dtool_VirtualFileList_operator_633_nb_inplace_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_VirtualFileList = {
  &Dtool_VirtualFileList_size_632_sq_length,
  nullptr,
  nullptr,
  &Dtool_VirtualFileList_operator_631_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_VirtualFileList = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_VirtualFileList = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_VirtualFileList = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_VirtualFileList = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VirtualFileList",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileList,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_VirtualFileList,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_VirtualFileList,
    &Dtool_SequenceMethods_VirtualFileList,
    &Dtool_MappingMethods_VirtualFileList,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_VirtualFileList,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A list of VirtualFiles, as returned by VirtualFile::scan_directory().\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VirtualFileList,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VirtualFileList,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileList,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileList,
  Dtool_UpcastInterface_VirtualFileList,
  Dtool_DowncastInterface_VirtualFileList,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VirtualFileList(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ReferenceCount(nullptr);
    Dtool_VirtualFileList._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ReferenceCount);
    Dtool_VirtualFileList._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileList._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileList) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileList)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileList);
  }
}

/**
 * Python method tables for VirtualFileSystem (VirtualFileSystem)
 */
static PyMethodDef Dtool_Methods_VirtualFileSystem[] = {
  {"mount", (PyCFunction) &Dtool_VirtualFileSystem_mount_640, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_mount_640_comment},
  {"mount_loop", (PyCFunction) &Dtool_VirtualFileSystem_mount_loop_641, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_mount_loop_641_comment},
  {"mountLoop", (PyCFunction) &Dtool_VirtualFileSystem_mount_loop_641, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_mount_loop_641_comment},
  {"unmount", &Dtool_VirtualFileSystem_unmount_642, METH_O, (const char *)Dtool_VirtualFileSystem_unmount_642_comment},
  {"unmount_point", &Dtool_VirtualFileSystem_unmount_point_643, METH_O, (const char *)Dtool_VirtualFileSystem_unmount_point_643_comment},
  {"unmountPoint", &Dtool_VirtualFileSystem_unmount_point_643, METH_O, (const char *)Dtool_VirtualFileSystem_unmount_point_643_comment},
  {"unmount_all", &Dtool_VirtualFileSystem_unmount_all_644, METH_NOARGS, (const char *)Dtool_VirtualFileSystem_unmount_all_644_comment},
  {"unmountAll", &Dtool_VirtualFileSystem_unmount_all_644, METH_NOARGS, (const char *)Dtool_VirtualFileSystem_unmount_all_644_comment},
  {"get_num_mounts", &Dtool_VirtualFileSystem_get_num_mounts_645, METH_NOARGS, (const char *)Dtool_VirtualFileSystem_get_num_mounts_645_comment},
  {"getNumMounts", &Dtool_VirtualFileSystem_get_num_mounts_645, METH_NOARGS, (const char *)Dtool_VirtualFileSystem_get_num_mounts_645_comment},
  {"get_mount", &Dtool_VirtualFileSystem_get_mount_646, METH_O, (const char *)Dtool_VirtualFileSystem_get_mount_646_comment},
  {"getMount", &Dtool_VirtualFileSystem_get_mount_646, METH_O, (const char *)Dtool_VirtualFileSystem_get_mount_646_comment},
  {"chdir", &Dtool_VirtualFileSystem_chdir_659, METH_O, (const char *)Dtool_VirtualFileSystem_chdir_659_comment},
  {"get_cwd", &Dtool_VirtualFileSystem_get_cwd_660, METH_NOARGS, (const char *)Dtool_VirtualFileSystem_get_cwd_660_comment},
  {"getCwd", &Dtool_VirtualFileSystem_get_cwd_660, METH_NOARGS, (const char *)Dtool_VirtualFileSystem_get_cwd_660_comment},
  {"make_directory", &Dtool_VirtualFileSystem_make_directory_661, METH_O, (const char *)Dtool_VirtualFileSystem_make_directory_661_comment},
  {"makeDirectory", &Dtool_VirtualFileSystem_make_directory_661, METH_O, (const char *)Dtool_VirtualFileSystem_make_directory_661_comment},
  {"make_directory_full", &Dtool_VirtualFileSystem_make_directory_full_662, METH_O, (const char *)Dtool_VirtualFileSystem_make_directory_full_662_comment},
  {"makeDirectoryFull", &Dtool_VirtualFileSystem_make_directory_full_662, METH_O, (const char *)Dtool_VirtualFileSystem_make_directory_full_662_comment},
  {"get_file", (PyCFunction) &Dtool_VirtualFileSystem_get_file_663, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_get_file_663_comment},
  {"getFile", (PyCFunction) &Dtool_VirtualFileSystem_get_file_663, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_get_file_663_comment},
  {"create_file", &Dtool_VirtualFileSystem_create_file_664, METH_O, (const char *)Dtool_VirtualFileSystem_create_file_664_comment},
  {"createFile", &Dtool_VirtualFileSystem_create_file_664, METH_O, (const char *)Dtool_VirtualFileSystem_create_file_664_comment},
  {"find_file", (PyCFunction) &Dtool_VirtualFileSystem_find_file_665, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_find_file_665_comment},
  {"findFile", (PyCFunction) &Dtool_VirtualFileSystem_find_file_665, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_find_file_665_comment},
  {"delete_file", &Dtool_VirtualFileSystem_delete_file_666, METH_O, (const char *)Dtool_VirtualFileSystem_delete_file_666_comment},
  {"deleteFile", &Dtool_VirtualFileSystem_delete_file_666, METH_O, (const char *)Dtool_VirtualFileSystem_delete_file_666_comment},
  {"rename_file", (PyCFunction) &Dtool_VirtualFileSystem_rename_file_667, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_rename_file_667_comment},
  {"renameFile", (PyCFunction) &Dtool_VirtualFileSystem_rename_file_667, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_rename_file_667_comment},
  {"copy_file", (PyCFunction) &Dtool_VirtualFileSystem_copy_file_668, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_copy_file_668_comment},
  {"copyFile", (PyCFunction) &Dtool_VirtualFileSystem_copy_file_668, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_copy_file_668_comment},
  {"resolve_filename", (PyCFunction) &Dtool_VirtualFileSystem_resolve_filename_669, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_resolve_filename_669_comment},
  {"resolveFilename", (PyCFunction) &Dtool_VirtualFileSystem_resolve_filename_669, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_resolve_filename_669_comment},
  {"find_all_files", (PyCFunction) &Dtool_VirtualFileSystem_find_all_files_670, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_find_all_files_670_comment},
  {"findAllFiles", (PyCFunction) &Dtool_VirtualFileSystem_find_all_files_670, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_find_all_files_670_comment},
  {"exists", &Dtool_VirtualFileSystem_exists_671, METH_O, (const char *)Dtool_VirtualFileSystem_exists_671_comment},
  {"is_directory", &Dtool_VirtualFileSystem_is_directory_672, METH_O, (const char *)Dtool_VirtualFileSystem_is_directory_672_comment},
  {"isDirectory", &Dtool_VirtualFileSystem_is_directory_672, METH_O, (const char *)Dtool_VirtualFileSystem_is_directory_672_comment},
  {"is_regular_file", &Dtool_VirtualFileSystem_is_regular_file_673, METH_O, (const char *)Dtool_VirtualFileSystem_is_regular_file_673_comment},
  {"isRegularFile", &Dtool_VirtualFileSystem_is_regular_file_673, METH_O, (const char *)Dtool_VirtualFileSystem_is_regular_file_673_comment},
  {"scan_directory", &Dtool_VirtualFileSystem_scan_directory_674, METH_O, (const char *)Dtool_VirtualFileSystem_scan_directory_674_comment},
  {"scanDirectory", &Dtool_VirtualFileSystem_scan_directory_674, METH_O, (const char *)Dtool_VirtualFileSystem_scan_directory_674_comment},
  {"ls", &Dtool_VirtualFileSystem_ls_675, METH_O, (const char *)Dtool_VirtualFileSystem_ls_675_comment},
  {"ls_all", &Dtool_VirtualFileSystem_ls_all_676, METH_O, (const char *)Dtool_VirtualFileSystem_ls_all_676_comment},
  {"lsAll", &Dtool_VirtualFileSystem_ls_all_676, METH_O, (const char *)Dtool_VirtualFileSystem_ls_all_676_comment},
  {"write", &Dtool_VirtualFileSystem_write_677, METH_O, (const char *)Dtool_VirtualFileSystem_write_677_comment},
  {"get_global_ptr", &Dtool_VirtualFileSystem_get_global_ptr_678, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileSystem_get_global_ptr_678_comment},
  {"getGlobalPtr", &Dtool_VirtualFileSystem_get_global_ptr_678, METH_NOARGS | METH_STATIC, (const char *)Dtool_VirtualFileSystem_get_global_ptr_678_comment},
  {"read_file", (PyCFunction) &Dtool_VirtualFileSystem_read_file_679, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_read_file_679_comment},
  {"readFile", (PyCFunction) &Dtool_VirtualFileSystem_read_file_679, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_read_file_679_comment},
  {"open_read_file", (PyCFunction) &Dtool_VirtualFileSystem_open_read_file_680, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_open_read_file_680_comment},
  {"openReadFile", (PyCFunction) &Dtool_VirtualFileSystem_open_read_file_680, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_open_read_file_680_comment},
  {"close_read_file", &Dtool_VirtualFileSystem_close_read_file_681, METH_O | METH_STATIC, (const char *)Dtool_VirtualFileSystem_close_read_file_681_comment},
  {"closeReadFile", &Dtool_VirtualFileSystem_close_read_file_681, METH_O | METH_STATIC, (const char *)Dtool_VirtualFileSystem_close_read_file_681_comment},
  {"write_file", (PyCFunction) &Dtool_VirtualFileSystem_write_file_682, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_write_file_682_comment},
  {"writeFile", (PyCFunction) &Dtool_VirtualFileSystem_write_file_682, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_write_file_682_comment},
  {"open_write_file", (PyCFunction) &Dtool_VirtualFileSystem_open_write_file_683, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_open_write_file_683_comment},
  {"openWriteFile", (PyCFunction) &Dtool_VirtualFileSystem_open_write_file_683, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_open_write_file_683_comment},
  {"open_append_file", &Dtool_VirtualFileSystem_open_append_file_684, METH_O, (const char *)Dtool_VirtualFileSystem_open_append_file_684_comment},
  {"openAppendFile", &Dtool_VirtualFileSystem_open_append_file_684, METH_O, (const char *)Dtool_VirtualFileSystem_open_append_file_684_comment},
  {"close_write_file", &Dtool_VirtualFileSystem_close_write_file_685, METH_O | METH_STATIC, (const char *)Dtool_VirtualFileSystem_close_write_file_685_comment},
  {"closeWriteFile", &Dtool_VirtualFileSystem_close_write_file_685, METH_O | METH_STATIC, (const char *)Dtool_VirtualFileSystem_close_write_file_685_comment},
  {"open_read_write_file", (PyCFunction) &Dtool_VirtualFileSystem_open_read_write_file_686, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_open_read_write_file_686_comment},
  {"openReadWriteFile", (PyCFunction) &Dtool_VirtualFileSystem_open_read_write_file_686, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_VirtualFileSystem_open_read_write_file_686_comment},
  {"open_read_append_file", &Dtool_VirtualFileSystem_open_read_append_file_687, METH_O, (const char *)Dtool_VirtualFileSystem_open_read_append_file_687_comment},
  {"openReadAppendFile", &Dtool_VirtualFileSystem_open_read_append_file_687, METH_O, (const char *)Dtool_VirtualFileSystem_open_read_append_file_687_comment},
  {"close_read_write_file", &Dtool_VirtualFileSystem_close_read_write_file_688, METH_O | METH_STATIC, (const char *)Dtool_VirtualFileSystem_close_read_write_file_688_comment},
  {"closeReadWriteFile", &Dtool_VirtualFileSystem_close_read_write_file_688, METH_O | METH_STATIC, (const char *)Dtool_VirtualFileSystem_close_read_write_file_688_comment},
  {"get_mounts", (PyCFunction) &MakeSeq_VirtualFileSystem_get_mounts, METH_NOARGS, nullptr},
  { "getMounts", (PyCFunction) &MakeSeq_VirtualFileSystem_get_mounts, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     VirtualFileSystem
//////////////////
static PyObject *Dtool_Str_VirtualFileSystem(PyObject *self) {
  VirtualFileSystem *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_VirtualFileSystem, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_VirtualFileSystem[] = {
  {(char *)"mounts", &Dtool_VirtualFileSystem_mounts_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_VirtualFileSystem = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_VirtualFileSystem = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.VirtualFileSystem",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_VirtualFileSystem,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_VirtualFileSystem,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_VirtualFileSystem,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A hierarchy of directories and files that appears to be one continuous file\n"
    " * system, even though the files may originate from several different sources\n"
    " * that may not be related to the actual OS's file system.\n"
    " *\n"
    " * For instance, a VirtualFileSystem can transparently mount one or more\n"
    " * Multifiles as their own subdirectory hierarchies.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_VirtualFileSystem,
    nullptr, // tp_members
    Dtool_Properties_VirtualFileSystem,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_VirtualFileSystem,
    PyType_GenericAlloc,
    Dtool_new_VirtualFileSystem,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_VirtualFileSystem,
  Dtool_UpcastInterface_VirtualFileSystem,
  Dtool_DowncastInterface_VirtualFileSystem,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_VirtualFileSystem(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_VirtualFileSystem._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_VirtualFileSystem._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum VirtualFileSystem::MountFlags;
    PyDict_SetItemString(dict, "MF_read_only", Dtool_WrapValue(VirtualFileSystem::MF_read_only));
    PyDict_SetItemString(dict, "MFReadOnly", Dtool_WrapValue(VirtualFileSystem::MF_read_only));
    if (PyType_Ready((PyTypeObject *)&Dtool_VirtualFileSystem) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(VirtualFileSystem)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_VirtualFileSystem);
  }
}

/**
 * Python method tables for PointerTo_VirtualFileMount (PointerTo_VirtualFileMount)
 */
static PyMethodDef Dtool_Methods_PointerTo_VirtualFileMount[] = {
  {"p", &Dtool_PointerTo_VirtualFileMount_p_654, METH_NOARGS, (const char *)Dtool_PointerTo_VirtualFileMount_p_654_comment},
  {"assign", &Dtool_PointerTo_VirtualFileMount_operator_655, METH_O, (const char *)Dtool_PointerTo_VirtualFileMount_operator_655_comment},
  {"is_null", &Dtool_PointerTo_VirtualFileMount_is_null_656, METH_NOARGS, (const char *)Dtool_PointerTo_VirtualFileMount_is_null_656_comment},
  {"isNull", &Dtool_PointerTo_VirtualFileMount_is_null_656, METH_NOARGS, (const char *)Dtool_PointerTo_VirtualFileMount_is_null_656_comment},
  {"clear", &Dtool_PointerTo_VirtualFileMount_clear_657, METH_NOARGS, (const char *)Dtool_PointerTo_VirtualFileMount_clear_657_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerTo_VirtualFileMount = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerTo_VirtualFileMount = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerTo_VirtualFileMount = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerTo_VirtualFileMount = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerTo_VirtualFileMount = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerTo_VirtualFileMount = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerTo_VirtualFileMount",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerTo_VirtualFileMount,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerTo_VirtualFileMount,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerTo_VirtualFileMount,
    &Dtool_SequenceMethods_PointerTo_VirtualFileMount,
    &Dtool_MappingMethods_PointerTo_VirtualFileMount,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerTo_VirtualFileMount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerTo_VirtualFileMount,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerTo_VirtualFileMount,
    PyType_GenericAlloc,
    Dtool_new_PointerTo_VirtualFileMount,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerTo_VirtualFileMount,
  Dtool_UpcastInterface_PointerTo_VirtualFileMount,
  Dtool_DowncastInterface_PointerTo_VirtualFileMount,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerTo_VirtualFileMount,
};

static void Dtool_PyModuleClassInit_PointerTo_VirtualFileMount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_VirtualFileMount(nullptr);
    Dtool_PointerTo_VirtualFileMount._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_VirtualFileMount);
    Dtool_PointerTo_VirtualFileMount._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerTo_VirtualFileMount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerTo_VirtualFileMount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerTo_VirtualFileMount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerTo_VirtualFileMount);
  }
}

/**
 * Python method tables for PointerToBase_VirtualFileMount (PointerToBase_VirtualFileMount)
 */
static PyMethodDef Dtool_Methods_PointerToBase_VirtualFileMount[] = {
  {"clear", &Dtool_PointerToBase_VirtualFileMount_clear_651, METH_NOARGS, (const char *)Dtool_PointerToBase_VirtualFileMount_clear_651_comment},
  {"output", &Dtool_PointerToBase_VirtualFileMount_output_652, METH_O, (const char *)Dtool_PointerToBase_VirtualFileMount_output_652_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_VirtualFileMount
//////////////////
static PyObject *Dtool_Repr_PointerToBase_VirtualFileMount(PyObject *self) {
  PointerToBase< VirtualFileMount > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_VirtualFileMount, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_VirtualFileMount = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_VirtualFileMount = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_VirtualFileMount = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_VirtualFileMount = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_VirtualFileMount = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_VirtualFileMount = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_VirtualFileMount",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_VirtualFileMount,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_VirtualFileMount,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_VirtualFileMount,
    &Dtool_NumberMethods_PointerToBase_VirtualFileMount,
    &Dtool_SequenceMethods_PointerToBase_VirtualFileMount,
    &Dtool_MappingMethods_PointerToBase_VirtualFileMount,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_VirtualFileMount,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_VirtualFileMount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_VirtualFileMount,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_VirtualFileMount,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_VirtualFileMount,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_VirtualFileMount,
  Dtool_UpcastInterface_PointerToBase_VirtualFileMount,
  Dtool_DowncastInterface_PointerToBase_VirtualFileMount,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_VirtualFileMount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToVoid(nullptr);
    Dtool_PointerToBase_VirtualFileMount._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToVoid);
    Dtool_PointerToBase_VirtualFileMount._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_VirtualFileMount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_VirtualFileMount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_VirtualFileMount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_VirtualFileMount);
  }
}

/**
 * Python method tables for StringStream (StringStream)
 */
static PyMethodDef Dtool_Methods_StringStream[] = {
  {"clear_data", &Dtool_StringStream_clear_data_691, METH_NOARGS, (const char *)Dtool_StringStream_clear_data_691_comment},
  {"clearData", &Dtool_StringStream_clear_data_691, METH_NOARGS, (const char *)Dtool_StringStream_clear_data_691_comment},
  {"get_data_size", &Dtool_StringStream_get_data_size_692, METH_NOARGS, (const char *)Dtool_StringStream_get_data_size_692_comment},
  {"getDataSize", &Dtool_StringStream_get_data_size_692, METH_NOARGS, (const char *)Dtool_StringStream_get_data_size_692_comment},
  {"get_data", &Dtool_StringStream_get_data_693, METH_NOARGS, (const char *)Dtool_StringStream_get_data_693_comment},
  {"getData", &Dtool_StringStream_get_data_693, METH_NOARGS, (const char *)Dtool_StringStream_get_data_693_comment},
  {"set_data", &Dtool_StringStream_set_data_694, METH_O, (const char *)Dtool_StringStream_set_data_694_comment},
  {"setData", &Dtool_StringStream_set_data_694, METH_O, (const char *)Dtool_StringStream_set_data_694_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_StringStream[] = {
  {(char *)"data", &Dtool_StringStream_data_Getter, &Dtool_StringStream_data_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_StringStream = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_StringStream = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_StringStream = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_StringStream = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_StringStream = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_StringStream = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.StringStream",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_StringStream,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_StringStream,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_StringStream,
    &Dtool_SequenceMethods_StringStream,
    &Dtool_MappingMethods_StringStream,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_StringStream,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A bi-directional stream object that reads and writes data to an internal\n"
    " * buffer, which can be retrieved and/or set as a string in Python 2 or a\n"
    " * bytes object in Python 3.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_StringStream,
    nullptr, // tp_members
    Dtool_Properties_StringStream,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_StringStream,
    PyType_GenericAlloc,
    Dtool_new_StringStream,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_StringStream,
  Dtool_UpcastInterface_StringStream,
  Dtool_DowncastInterface_StringStream,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_StringStream(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_std_iostream != nullptr);
    assert(Dtool_Ptr_std_iostream->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_std_iostream->_Dtool_ModuleClassInit(nullptr);
    Dtool_StringStream._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_std_iostream);
    Dtool_StringStream._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_StringStream._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_StringStream) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(StringStream)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_StringStream);
  }
}

/**
 * Python method tables for TrueClock (TrueClock)
 */
static PyMethodDef Dtool_Methods_TrueClock[] = {
  {"get_long_time", &Dtool_TrueClock_get_long_time_701, METH_NOARGS, (const char *)Dtool_TrueClock_get_long_time_701_comment},
  {"getLongTime", &Dtool_TrueClock_get_long_time_701, METH_NOARGS, (const char *)Dtool_TrueClock_get_long_time_701_comment},
  {"get_short_time", &Dtool_TrueClock_get_short_time_704, METH_NOARGS, (const char *)Dtool_TrueClock_get_short_time_704_comment},
  {"getShortTime", &Dtool_TrueClock_get_short_time_704, METH_NOARGS, (const char *)Dtool_TrueClock_get_short_time_704_comment},
  {"get_short_raw_time", &Dtool_TrueClock_get_short_raw_time_706, METH_NOARGS, (const char *)Dtool_TrueClock_get_short_raw_time_706_comment},
  {"getShortRawTime", &Dtool_TrueClock_get_short_raw_time_706, METH_NOARGS, (const char *)Dtool_TrueClock_get_short_raw_time_706_comment},
  {"get_error_count", &Dtool_TrueClock_get_error_count_708, METH_NOARGS, (const char *)Dtool_TrueClock_get_error_count_708_comment},
  {"getErrorCount", &Dtool_TrueClock_get_error_count_708, METH_NOARGS, (const char *)Dtool_TrueClock_get_error_count_708_comment},
  {"get_global_ptr", &Dtool_TrueClock_get_global_ptr_710, METH_NOARGS | METH_STATIC, (const char *)Dtool_TrueClock_get_global_ptr_710_comment},
  {"getGlobalPtr", &Dtool_TrueClock_get_global_ptr_710, METH_NOARGS | METH_STATIC, (const char *)Dtool_TrueClock_get_global_ptr_710_comment},
  {"set_cpu_affinity", &Dtool_TrueClock_set_cpu_affinity_711, METH_O, (const char *)Dtool_TrueClock_set_cpu_affinity_711_comment},
  {"setCpuAffinity", &Dtool_TrueClock_set_cpu_affinity_711, METH_O, (const char *)Dtool_TrueClock_set_cpu_affinity_711_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_TrueClock[] = {
  {(char *)"long_time", &Dtool_TrueClock_long_time_Getter, nullptr, (char *)
    "// get_long_time() returns the most accurate timer we have over a long\n"
    "// interval.  It may not be very precise for measuring short intervals, but\n"
    "// it should not drift substantially over the long haul.",
    nullptr},
  {(char *)"short_time", &Dtool_TrueClock_short_time_Getter, nullptr, (char *)
    "// get_short_time() returns the most precise timer we have over a short\n"
    "// interval.  It may tend to drift over the long haul, but it should have\n"
    "// lots of digits to measure short intervals very precisely.",
    nullptr},
  {(char *)"short_raw_time", &Dtool_TrueClock_short_raw_time_Getter, nullptr, (char *)
    "// get_short_raw_time() is like get_short_time(), but does not apply any\n"
    "// corrections (e.g.  paranoid-clock) to the result returned by the OS.",
    nullptr},
  {(char *)"error_count", &Dtool_TrueClock_error_count_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_TrueClock = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TrueClock = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TrueClock",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TrueClock,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TrueClock,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An interface to whatever real-time clock we might have available in the\n"
    " * current environment.  There is only one TrueClock in existence, and it\n"
    " * constructs itself.\n"
    " *\n"
    " * The TrueClock returns elapsed real time in seconds since some undefined\n"
    " * epoch.  Since it is not defined at what time precisely the clock indicates\n"
    " * zero, this value can only be meaningfully used to measure elapsed time, by\n"
    " * sampling it at two different times and subtracting.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TrueClock,
    nullptr, // tp_members
    Dtool_Properties_TrueClock,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TrueClock,
    PyType_GenericAlloc,
    Dtool_new_TrueClock,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TrueClock,
  Dtool_UpcastInterface_TrueClock,
  Dtool_DowncastInterface_TrueClock,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TrueClock(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TrueClock._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TrueClock._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TrueClock) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TrueClock)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TrueClock);
  }
}

/**
 * Python method tables for Patchfile (Patchfile)
 */
static PyMethodDef Dtool_Methods_Patchfile[] = {
  {"build", (PyCFunction) &Dtool_Patchfile_build_715, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Patchfile_build_715_comment},
  {"read_header", &Dtool_Patchfile_read_header_716, METH_O, (const char *)Dtool_Patchfile_read_header_716_comment},
  {"readHeader", &Dtool_Patchfile_read_header_716, METH_O, (const char *)Dtool_Patchfile_read_header_716_comment},
  {"initiate", (PyCFunction) &Dtool_Patchfile_initiate_717, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Patchfile_initiate_717_comment},
  {"run", &Dtool_Patchfile_run_718, METH_NOARGS, (const char *)Dtool_Patchfile_run_718_comment},
  {"apply", (PyCFunction) &Dtool_Patchfile_apply_719, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Patchfile_apply_719_comment},
  {"get_progress", &Dtool_Patchfile_get_progress_720, METH_NOARGS, (const char *)Dtool_Patchfile_get_progress_720_comment},
  {"getProgress", &Dtool_Patchfile_get_progress_720, METH_NOARGS, (const char *)Dtool_Patchfile_get_progress_720_comment},
  {"set_allow_multifile", &Dtool_Patchfile_set_allow_multifile_724, METH_O, (const char *)Dtool_Patchfile_set_allow_multifile_724_comment},
  {"setAllowMultifile", &Dtool_Patchfile_set_allow_multifile_724, METH_O, (const char *)Dtool_Patchfile_set_allow_multifile_724_comment},
  {"get_allow_multifile", &Dtool_Patchfile_get_allow_multifile_725, METH_NOARGS, (const char *)Dtool_Patchfile_get_allow_multifile_725_comment},
  {"getAllowMultifile", &Dtool_Patchfile_get_allow_multifile_725, METH_NOARGS, (const char *)Dtool_Patchfile_get_allow_multifile_725_comment},
  {"set_footprint_length", &Dtool_Patchfile_set_footprint_length_727, METH_O, (const char *)Dtool_Patchfile_set_footprint_length_727_comment},
  {"setFootprintLength", &Dtool_Patchfile_set_footprint_length_727, METH_O, (const char *)Dtool_Patchfile_set_footprint_length_727_comment},
  {"get_footprint_length", &Dtool_Patchfile_get_footprint_length_728, METH_NOARGS, (const char *)Dtool_Patchfile_get_footprint_length_728_comment},
  {"getFootprintLength", &Dtool_Patchfile_get_footprint_length_728, METH_NOARGS, (const char *)Dtool_Patchfile_get_footprint_length_728_comment},
  {"reset_footprint_length", &Dtool_Patchfile_reset_footprint_length_729, METH_NOARGS, (const char *)Dtool_Patchfile_reset_footprint_length_729_comment},
  {"resetFootprintLength", &Dtool_Patchfile_reset_footprint_length_729, METH_NOARGS, (const char *)Dtool_Patchfile_reset_footprint_length_729_comment},
  {"has_source_hash", &Dtool_Patchfile_has_source_hash_731, METH_NOARGS, (const char *)Dtool_Patchfile_has_source_hash_731_comment},
  {"hasSourceHash", &Dtool_Patchfile_has_source_hash_731, METH_NOARGS, (const char *)Dtool_Patchfile_has_source_hash_731_comment},
  {"get_source_hash", &Dtool_Patchfile_get_source_hash_732, METH_NOARGS, (const char *)Dtool_Patchfile_get_source_hash_732_comment},
  {"getSourceHash", &Dtool_Patchfile_get_source_hash_732, METH_NOARGS, (const char *)Dtool_Patchfile_get_source_hash_732_comment},
  {"get_result_hash", &Dtool_Patchfile_get_result_hash_733, METH_NOARGS, (const char *)Dtool_Patchfile_get_result_hash_733_comment},
  {"getResultHash", &Dtool_Patchfile_get_result_hash_733, METH_NOARGS, (const char *)Dtool_Patchfile_get_result_hash_733_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_Patchfile[] = {
  {(char *)"progress", &Dtool_Patchfile_progress_Getter, nullptr, nullptr, nullptr},
  {(char *)"allow_multifile", &Dtool_Patchfile_allow_multifile_Getter, &Dtool_Patchfile_allow_multifile_Setter, nullptr, nullptr},
  {(char *)"footprint_length", &Dtool_Patchfile_footprint_length_Getter, &Dtool_Patchfile_footprint_length_Setter, nullptr, nullptr},
  {(char *)"source_hash", &Dtool_Patchfile_source_hash_Getter, nullptr, nullptr, nullptr},
  {(char *)"result_hash", &Dtool_Patchfile_result_hash_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_Patchfile = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_Patchfile = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Patchfile",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Patchfile,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Patchfile,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Patchfile,
    nullptr, // tp_members
    Dtool_Properties_Patchfile,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Patchfile,
    PyType_GenericAlloc,
    Dtool_new_Patchfile,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Patchfile,
  Dtool_UpcastInterface_Patchfile,
  Dtool_DowncastInterface_Patchfile,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Patchfile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_Patchfile._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Patchfile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Patchfile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Patchfile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Patchfile);
  }
}

/**
 * Python method tables for WeakPointerToVoid (WeakPointerToVoid)
 */
static PyMethodDef Dtool_Methods_WeakPointerToVoid[] = {
  {"was_deleted", &Dtool_WeakPointerToVoid_was_deleted_739, METH_NOARGS, (const char *)Dtool_WeakPointerToVoid_was_deleted_739_comment},
  {"wasDeleted", &Dtool_WeakPointerToVoid_was_deleted_739, METH_NOARGS, (const char *)Dtool_WeakPointerToVoid_was_deleted_739_comment},
  {"is_valid_pointer", &Dtool_WeakPointerToVoid_is_valid_pointer_740, METH_NOARGS, (const char *)Dtool_WeakPointerToVoid_is_valid_pointer_740_comment},
  {"isValidPointer", &Dtool_WeakPointerToVoid_is_valid_pointer_740, METH_NOARGS, (const char *)Dtool_WeakPointerToVoid_is_valid_pointer_740_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_WeakPointerToVoid = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_WeakPointerToVoid = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_WeakPointerToVoid = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_WeakPointerToVoid = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_WeakPointerToVoid = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_WeakPointerToVoid = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.WeakPointerToVoid",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_WeakPointerToVoid,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_WeakPointerToVoid,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_WeakPointerToVoid,
    &Dtool_SequenceMethods_WeakPointerToVoid,
    &Dtool_MappingMethods_WeakPointerToVoid,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_WeakPointerToVoid,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the specialization of PointerToVoid for weak pointers.  It needs an\n"
    " * additional flag to indicate that the pointer has been deleted.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_WeakPointerToVoid,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_WeakPointerToVoid,
    PyType_GenericAlloc,
    Dtool_new_WeakPointerToVoid,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_WeakPointerToVoid,
  Dtool_UpcastInterface_WeakPointerToVoid,
  Dtool_DowncastInterface_WeakPointerToVoid,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_WeakPointerToVoid(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToVoid(nullptr);
    Dtool_WeakPointerToVoid._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToVoid);
    Dtool_WeakPointerToVoid._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_WeakPointerToVoid._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_WeakPointerToVoid) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(WeakPointerToVoid)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_WeakPointerToVoid);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3express_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    ReferenceCount::init_type();
    TypeHandle handle = ReferenceCount::get_class_type();
    Dtool_ReferenceCount._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ReferenceCount);
  }
  {
    NodeReferenceCount::init_type();
    TypeHandle handle = NodeReferenceCount::get_class_type();
    Dtool_NodeReferenceCount._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_NodeReferenceCount);
  }
  {
    Datagram::init_type();
    TypeHandle handle = Datagram::get_class_type();
    Dtool_Datagram._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Datagram);
  }
  {
    DatagramIterator::init_type();
    TypeHandle handle = DatagramIterator::get_class_type();
    Dtool_DatagramIterator._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_DatagramIterator);
  }
  {
    FileReference::init_type();
    TypeHandle handle = FileReference::get_class_type();
    Dtool_FileReference._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_FileReference);
  }
  {
    TypedReferenceCount::init_type();
    TypeHandle handle = TypedReferenceCount::get_class_type();
    Dtool_TypedReferenceCount._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TypedReferenceCount);
  }
  {
    Namable::init_type();
    TypeHandle handle = Namable::get_class_type();
    Dtool_Namable._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Namable);
  }
  {
    VirtualFile::init_type();
    TypeHandle handle = VirtualFile::get_class_type();
    Dtool_VirtualFile._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_VirtualFile);
  }
  {
    VirtualFileComposite::init_type();
    TypeHandle handle = VirtualFileComposite::get_class_type();
    Dtool_VirtualFileComposite._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_VirtualFileComposite);
  }
  {
    VirtualFileMount::init_type();
    TypeHandle handle = VirtualFileMount::get_class_type();
    Dtool_VirtualFileMount._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_VirtualFileMount);
  }
  {
    VirtualFileMountMultifile::init_type();
    TypeHandle handle = VirtualFileMountMultifile::get_class_type();
    Dtool_VirtualFileMountMultifile._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_VirtualFileMountMultifile);
  }
  {
    VirtualFileMountRamdisk::init_type();
    TypeHandle handle = VirtualFileMountRamdisk::get_class_type();
    Dtool_VirtualFileMountRamdisk._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_VirtualFileMountRamdisk);
  }
  {
    VirtualFileMountSystem::init_type();
    TypeHandle handle = VirtualFileMountSystem::get_class_type();
    Dtool_VirtualFileMountSystem._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_VirtualFileMountSystem);
  }
  {
    VirtualFileSimple::init_type();
    TypeHandle handle = VirtualFileSimple::get_class_type();
    Dtool_VirtualFileSimple._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_VirtualFileSimple);
  }
  {
    TemporaryFile::init_type();
    TypeHandle handle = TemporaryFile::get_class_type();
    Dtool_TemporaryFile._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TemporaryFile);
  }
}

void Dtool_libp3express_BuildInstants(PyObject *module) {
  (void) module;
  // enum ErrorUtilCode
  PyModule_AddObject(module, "EU_http_redirect", Dtool_WrapValue(::EU_http_redirect));
  PyModule_AddObject(module, "EUHttpRedirect", Dtool_WrapValue(::EU_http_redirect));
  PyModule_AddObject(module, "EU_eof", Dtool_WrapValue(::EU_eof));
  PyModule_AddObject(module, "EUEof", Dtool_WrapValue(::EU_eof));
  PyModule_AddObject(module, "EU_network_no_data", Dtool_WrapValue(::EU_network_no_data));
  PyModule_AddObject(module, "EUNetworkNoData", Dtool_WrapValue(::EU_network_no_data));
  PyModule_AddObject(module, "EU_write_ram", Dtool_WrapValue(::EU_write_ram));
  PyModule_AddObject(module, "EUWriteRam", Dtool_WrapValue(::EU_write_ram));
  PyModule_AddObject(module, "EU_write", Dtool_WrapValue(::EU_write));
  PyModule_AddObject(module, "EUWrite", Dtool_WrapValue(::EU_write));
  PyModule_AddObject(module, "EU_ok", Dtool_WrapValue(::EU_ok));
  PyModule_AddObject(module, "EUOk", Dtool_WrapValue(::EU_ok));
  PyModule_AddObject(module, "EU_success", Dtool_WrapValue(::EU_success));
  PyModule_AddObject(module, "EUSuccess", Dtool_WrapValue(::EU_success));
  PyModule_AddObject(module, "EU_error_abort", Dtool_WrapValue(::EU_error_abort));
  PyModule_AddObject(module, "EUErrorAbort", Dtool_WrapValue(::EU_error_abort));
  PyModule_AddObject(module, "EU_error_file_empty", Dtool_WrapValue(::EU_error_file_empty));
  PyModule_AddObject(module, "EUErrorFileEmpty", Dtool_WrapValue(::EU_error_file_empty));
  PyModule_AddObject(module, "EU_error_file_invalid", Dtool_WrapValue(::EU_error_file_invalid));
  PyModule_AddObject(module, "EUErrorFileInvalid", Dtool_WrapValue(::EU_error_file_invalid));
  PyModule_AddObject(module, "EU_error_invalid_checksum", Dtool_WrapValue(::EU_error_invalid_checksum));
  PyModule_AddObject(module, "EUErrorInvalidChecksum", Dtool_WrapValue(::EU_error_invalid_checksum));
  PyModule_AddObject(module, "EU_error_network_dead", Dtool_WrapValue(::EU_error_network_dead));
  PyModule_AddObject(module, "EUErrorNetworkDead", Dtool_WrapValue(::EU_error_network_dead));
  PyModule_AddObject(module, "EU_error_network_unreachable", Dtool_WrapValue(::EU_error_network_unreachable));
  PyModule_AddObject(module, "EUErrorNetworkUnreachable", Dtool_WrapValue(::EU_error_network_unreachable));
  PyModule_AddObject(module, "EU_error_network_disconnected", Dtool_WrapValue(::EU_error_network_disconnected));
  PyModule_AddObject(module, "EUErrorNetworkDisconnected", Dtool_WrapValue(::EU_error_network_disconnected));
  PyModule_AddObject(module, "EU_error_network_timeout", Dtool_WrapValue(::EU_error_network_timeout));
  PyModule_AddObject(module, "EUErrorNetworkTimeout", Dtool_WrapValue(::EU_error_network_timeout));
  PyModule_AddObject(module, "EU_error_network_no_data", Dtool_WrapValue(::EU_error_network_no_data));
  PyModule_AddObject(module, "EUErrorNetworkNoData", Dtool_WrapValue(::EU_error_network_no_data));
  PyModule_AddObject(module, "EU_error_network_disconnected_locally", Dtool_WrapValue(::EU_error_network_disconnected_locally));
  PyModule_AddObject(module, "EUErrorNetworkDisconnectedLocally", Dtool_WrapValue(::EU_error_network_disconnected_locally));
  PyModule_AddObject(module, "EU_error_network_buffer_overflow", Dtool_WrapValue(::EU_error_network_buffer_overflow));
  PyModule_AddObject(module, "EUErrorNetworkBufferOverflow", Dtool_WrapValue(::EU_error_network_buffer_overflow));
  PyModule_AddObject(module, "EU_error_network_disk_quota_exceeded", Dtool_WrapValue(::EU_error_network_disk_quota_exceeded));
  PyModule_AddObject(module, "EUErrorNetworkDiskQuotaExceeded", Dtool_WrapValue(::EU_error_network_disk_quota_exceeded));
  PyModule_AddObject(module, "EU_error_network_remote_host_disconnected", Dtool_WrapValue(::EU_error_network_remote_host_disconnected));
  PyModule_AddObject(module, "EUErrorNetworkRemoteHostDisconnected", Dtool_WrapValue(::EU_error_network_remote_host_disconnected));
  PyModule_AddObject(module, "EU_error_network_remote_host_down", Dtool_WrapValue(::EU_error_network_remote_host_down));
  PyModule_AddObject(module, "EUErrorNetworkRemoteHostDown", Dtool_WrapValue(::EU_error_network_remote_host_down));
  PyModule_AddObject(module, "EU_error_network_remote_host_unreachable", Dtool_WrapValue(::EU_error_network_remote_host_unreachable));
  PyModule_AddObject(module, "EUErrorNetworkRemoteHostUnreachable", Dtool_WrapValue(::EU_error_network_remote_host_unreachable));
  PyModule_AddObject(module, "EU_error_network_remote_host_not_found", Dtool_WrapValue(::EU_error_network_remote_host_not_found));
  PyModule_AddObject(module, "EUErrorNetworkRemoteHostNotFound", Dtool_WrapValue(::EU_error_network_remote_host_not_found));
  PyModule_AddObject(module, "EU_error_network_remote_host_no_response", Dtool_WrapValue(::EU_error_network_remote_host_no_response));
  PyModule_AddObject(module, "EUErrorNetworkRemoteHostNoResponse", Dtool_WrapValue(::EU_error_network_remote_host_no_response));
  PyModule_AddObject(module, "EU_error_write_out_of_files", Dtool_WrapValue(::EU_error_write_out_of_files));
  PyModule_AddObject(module, "EUErrorWriteOutOfFiles", Dtool_WrapValue(::EU_error_write_out_of_files));
  PyModule_AddObject(module, "EU_error_write_out_of_memory", Dtool_WrapValue(::EU_error_write_out_of_memory));
  PyModule_AddObject(module, "EUErrorWriteOutOfMemory", Dtool_WrapValue(::EU_error_write_out_of_memory));
  PyModule_AddObject(module, "EU_error_write_sharing_violation", Dtool_WrapValue(::EU_error_write_sharing_violation));
  PyModule_AddObject(module, "EUErrorWriteSharingViolation", Dtool_WrapValue(::EU_error_write_sharing_violation));
  PyModule_AddObject(module, "EU_error_write_disk_full", Dtool_WrapValue(::EU_error_write_disk_full));
  PyModule_AddObject(module, "EUErrorWriteDiskFull", Dtool_WrapValue(::EU_error_write_disk_full));
  PyModule_AddObject(module, "EU_error_write_disk_not_found", Dtool_WrapValue(::EU_error_write_disk_not_found));
  PyModule_AddObject(module, "EUErrorWriteDiskNotFound", Dtool_WrapValue(::EU_error_write_disk_not_found));
  PyModule_AddObject(module, "EU_error_write_disk_sector_not_found", Dtool_WrapValue(::EU_error_write_disk_sector_not_found));
  PyModule_AddObject(module, "EUErrorWriteDiskSectorNotFound", Dtool_WrapValue(::EU_error_write_disk_sector_not_found));
  PyModule_AddObject(module, "EU_error_write_disk_fault", Dtool_WrapValue(::EU_error_write_disk_fault));
  PyModule_AddObject(module, "EUErrorWriteDiskFault", Dtool_WrapValue(::EU_error_write_disk_fault));
  PyModule_AddObject(module, "EU_error_write_file_rename", Dtool_WrapValue(::EU_error_write_file_rename));
  PyModule_AddObject(module, "EUErrorWriteFileRename", Dtool_WrapValue(::EU_error_write_file_rename));
  PyModule_AddObject(module, "EU_error_http_server_timeout", Dtool_WrapValue(::EU_error_http_server_timeout));
  PyModule_AddObject(module, "EUErrorHttpServerTimeout", Dtool_WrapValue(::EU_error_http_server_timeout));
  PyModule_AddObject(module, "EU_error_http_gateway_timeout", Dtool_WrapValue(::EU_error_http_gateway_timeout));
  PyModule_AddObject(module, "EUErrorHttpGatewayTimeout", Dtool_WrapValue(::EU_error_http_gateway_timeout));
  PyModule_AddObject(module, "EU_error_http_service_unavailable", Dtool_WrapValue(::EU_error_http_service_unavailable));
  PyModule_AddObject(module, "EUErrorHttpServiceUnavailable", Dtool_WrapValue(::EU_error_http_service_unavailable));
  PyModule_AddObject(module, "EU_error_http_proxy_authentication", Dtool_WrapValue(::EU_error_http_proxy_authentication));
  PyModule_AddObject(module, "EUErrorHttpProxyAuthentication", Dtool_WrapValue(::EU_error_http_proxy_authentication));
  PyModule_AddObject(module, "EU_error_zlib", Dtool_WrapValue(::EU_error_zlib));
  PyModule_AddObject(module, "EUErrorZlib", Dtool_WrapValue(::EU_error_zlib));
  // typedef ConstPointerToArray< double > CPTA_double
  Dtool_PyModuleClassInit_ConstPointerToArray_double(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_double);
  PyModule_AddObject(module, "CPTA_double", (PyObject *)&Dtool_ConstPointerToArray_double);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_double);
  PyModule_AddObject(module, "CPTADouble", (PyObject *)&Dtool_ConstPointerToArray_double);
  // ConstPointerToArray< double >
  Dtool_PyModuleClassInit_ConstPointerToArray_double(module);
  PyModule_AddObject(module, "ConstPointerToArray_double", (PyObject *)&Dtool_ConstPointerToArray_double);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_double);
  PyModule_AddObject(module, "ConstPointerToArrayDouble", (PyObject *)&Dtool_ConstPointerToArray_double);
  // PointerToArrayBase< double >
  Dtool_PyModuleClassInit_PointerToArrayBase_double(module);
  PyModule_AddObject(module, "PointerToArrayBase_double", (PyObject *)&Dtool_PointerToArrayBase_double);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_double);
  PyModule_AddObject(module, "PointerToArrayBaseDouble", (PyObject *)&Dtool_PointerToArrayBase_double);
  // PointerToBase< ReferenceCountedVector< double > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_double(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_double", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_double);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_double);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorDouble", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_double);
  // PointerToVoid
  Dtool_PyModuleClassInit_PointerToVoid(module);
  PyModule_AddObject(module, "PointerToVoid", (PyObject *)&Dtool_PointerToVoid);
  // typedef ConstPointerToArray< float > CPTA_float
  Dtool_PyModuleClassInit_ConstPointerToArray_float(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_float);
  PyModule_AddObject(module, "CPTA_float", (PyObject *)&Dtool_ConstPointerToArray_float);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_float);
  PyModule_AddObject(module, "CPTAFloat", (PyObject *)&Dtool_ConstPointerToArray_float);
  // ConstPointerToArray< float >
  Dtool_PyModuleClassInit_ConstPointerToArray_float(module);
  PyModule_AddObject(module, "ConstPointerToArray_float", (PyObject *)&Dtool_ConstPointerToArray_float);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_float);
  PyModule_AddObject(module, "ConstPointerToArrayFloat", (PyObject *)&Dtool_ConstPointerToArray_float);
  // PointerToArrayBase< float >
  Dtool_PyModuleClassInit_PointerToArrayBase_float(module);
  PyModule_AddObject(module, "PointerToArrayBase_float", (PyObject *)&Dtool_PointerToArrayBase_float);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_float);
  PyModule_AddObject(module, "PointerToArrayBaseFloat", (PyObject *)&Dtool_PointerToArrayBase_float);
  // PointerToBase< ReferenceCountedVector< float > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_float(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_float", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_float);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_float);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorFloat", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_float);
  // typedef ConstPointerToArray< int > CPTA_int
  Dtool_PyModuleClassInit_ConstPointerToArray_int(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_int);
  PyModule_AddObject(module, "CPTA_int", (PyObject *)&Dtool_ConstPointerToArray_int);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_int);
  PyModule_AddObject(module, "CPTAInt", (PyObject *)&Dtool_ConstPointerToArray_int);
  // ConstPointerToArray< int >
  Dtool_PyModuleClassInit_ConstPointerToArray_int(module);
  PyModule_AddObject(module, "ConstPointerToArray_int", (PyObject *)&Dtool_ConstPointerToArray_int);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_int);
  PyModule_AddObject(module, "ConstPointerToArrayInt", (PyObject *)&Dtool_ConstPointerToArray_int);
  // PointerToArrayBase< int >
  Dtool_PyModuleClassInit_PointerToArrayBase_int(module);
  PyModule_AddObject(module, "PointerToArrayBase_int", (PyObject *)&Dtool_PointerToArrayBase_int);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_int);
  PyModule_AddObject(module, "PointerToArrayBaseInt", (PyObject *)&Dtool_PointerToArrayBase_int);
  // PointerToBase< ReferenceCountedVector< int > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_int(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_int", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_int);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_int);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorInt", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_int);
  // typedef ConstPointerToArray< unsigned char > CPTA_uchar
  Dtool_PyModuleClassInit_ConstPointerToArray_unsigned_char(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_unsigned_char);
  PyModule_AddObject(module, "CPTA_uchar", (PyObject *)&Dtool_ConstPointerToArray_unsigned_char);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_unsigned_char);
  PyModule_AddObject(module, "CPTAUchar", (PyObject *)&Dtool_ConstPointerToArray_unsigned_char);
  // ConstPointerToArray< unsigned char >
  Dtool_PyModuleClassInit_ConstPointerToArray_unsigned_char(module);
  PyModule_AddObject(module, "ConstPointerToArray_unsigned_char", (PyObject *)&Dtool_ConstPointerToArray_unsigned_char);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_unsigned_char);
  PyModule_AddObject(module, "ConstPointerToArrayUnsignedChar", (PyObject *)&Dtool_ConstPointerToArray_unsigned_char);
  // PointerToArrayBase< unsigned char >
  Dtool_PyModuleClassInit_PointerToArrayBase_unsigned_char(module);
  PyModule_AddObject(module, "PointerToArrayBase_unsigned_char", (PyObject *)&Dtool_PointerToArrayBase_unsigned_char);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_unsigned_char);
  PyModule_AddObject(module, "PointerToArrayBaseUnsignedChar", (PyObject *)&Dtool_PointerToArrayBase_unsigned_char);
  // PointerToBase< ReferenceCountedVector< unsigned char > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_unsigned_char(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_unsigned_char", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_unsigned_char);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorUnsignedChar", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_unsigned_char);
  // typedef PointerToArray< double > PTA_double
  Dtool_PyModuleClassInit_PointerToArray_double(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_double);
  PyModule_AddObject(module, "PTA_double", (PyObject *)&Dtool_PointerToArray_double);
  Py_INCREF(Dtool_Ptr_PointerToArray_double);
  PyModule_AddObject(module, "PTADouble", (PyObject *)&Dtool_PointerToArray_double);
  // PointerToArray< double >
  Dtool_PyModuleClassInit_PointerToArray_double(module);
  PyModule_AddObject(module, "PointerToArray_double", (PyObject *)&Dtool_PointerToArray_double);
  Py_INCREF(Dtool_Ptr_PointerToArray_double);
  PyModule_AddObject(module, "PointerToArrayDouble", (PyObject *)&Dtool_PointerToArray_double);
  // typedef PointerToArray< float > PTA_float
  Dtool_PyModuleClassInit_PointerToArray_float(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_float);
  PyModule_AddObject(module, "PTA_float", (PyObject *)&Dtool_PointerToArray_float);
  Py_INCREF(Dtool_Ptr_PointerToArray_float);
  PyModule_AddObject(module, "PTAFloat", (PyObject *)&Dtool_PointerToArray_float);
  // PointerToArray< float >
  Dtool_PyModuleClassInit_PointerToArray_float(module);
  PyModule_AddObject(module, "PointerToArray_float", (PyObject *)&Dtool_PointerToArray_float);
  Py_INCREF(Dtool_Ptr_PointerToArray_float);
  PyModule_AddObject(module, "PointerToArrayFloat", (PyObject *)&Dtool_PointerToArray_float);
  // typedef PointerToArray< int > PTA_int
  Dtool_PyModuleClassInit_PointerToArray_int(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_int);
  PyModule_AddObject(module, "PTA_int", (PyObject *)&Dtool_PointerToArray_int);
  Py_INCREF(Dtool_Ptr_PointerToArray_int);
  PyModule_AddObject(module, "PTAInt", (PyObject *)&Dtool_PointerToArray_int);
  // PointerToArray< int >
  Dtool_PyModuleClassInit_PointerToArray_int(module);
  PyModule_AddObject(module, "PointerToArray_int", (PyObject *)&Dtool_PointerToArray_int);
  Py_INCREF(Dtool_Ptr_PointerToArray_int);
  PyModule_AddObject(module, "PointerToArrayInt", (PyObject *)&Dtool_PointerToArray_int);
  // typedef PointerToArray< unsigned char > PTA_uchar
  Dtool_PyModuleClassInit_PointerToArray_unsigned_char(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_unsigned_char);
  PyModule_AddObject(module, "PTA_uchar", (PyObject *)&Dtool_PointerToArray_unsigned_char);
  Py_INCREF(Dtool_Ptr_PointerToArray_unsigned_char);
  PyModule_AddObject(module, "PTAUchar", (PyObject *)&Dtool_PointerToArray_unsigned_char);
  // PointerToArray< unsigned char >
  Dtool_PyModuleClassInit_PointerToArray_unsigned_char(module);
  PyModule_AddObject(module, "PointerToArray_unsigned_char", (PyObject *)&Dtool_PointerToArray_unsigned_char);
  Py_INCREF(Dtool_Ptr_PointerToArray_unsigned_char);
  PyModule_AddObject(module, "PointerToArrayUnsignedChar", (PyObject *)&Dtool_PointerToArray_unsigned_char);
  // MemoryUsage
  Dtool_PyModuleClassInit_MemoryUsage(module);
  PyModule_AddObject(module, "MemoryUsage", (PyObject *)&Dtool_MemoryUsage);
  // ReferenceCount
  Dtool_PyModuleClassInit_ReferenceCount(module);
  PyModule_AddObject(module, "ReferenceCount", (PyObject *)&Dtool_ReferenceCount);
  // Buffer
  Dtool_PyModuleClassInit_Buffer(module);
  PyModule_AddObject(module, "Buffer", (PyObject *)&Dtool_Buffer);
  // PStatCollectorForwardBase
  Dtool_PyModuleClassInit_PStatCollectorForwardBase(module);
  PyModule_AddObject(module, "PStatCollectorForwardBase", (PyObject *)&Dtool_PStatCollectorForwardBase);
  // NodeReferenceCount
  Dtool_PyModuleClassInit_NodeReferenceCount(module);
  PyModule_AddObject(module, "NodeReferenceCount", (PyObject *)&Dtool_NodeReferenceCount);
  // Datagram
  Dtool_PyModuleClassInit_Datagram(module);
  PyModule_AddObject(module, "Datagram", (PyObject *)&Dtool_Datagram);
  // DatagramGenerator
  Dtool_PyModuleClassInit_DatagramGenerator(module);
  PyModule_AddObject(module, "DatagramGenerator", (PyObject *)&Dtool_DatagramGenerator);
  // DatagramIterator
  Dtool_PyModuleClassInit_DatagramIterator(module);
  PyModule_AddObject(module, "DatagramIterator", (PyObject *)&Dtool_DatagramIterator);
  // DatagramSink
  Dtool_PyModuleClassInit_DatagramSink(module);
  PyModule_AddObject(module, "DatagramSink", (PyObject *)&Dtool_DatagramSink);
  // FileReference
  Dtool_PyModuleClassInit_FileReference(module);
  PyModule_AddObject(module, "FileReference", (PyObject *)&Dtool_FileReference);
  // TypedReferenceCount
  Dtool_PyModuleClassInit_TypedReferenceCount(module);
  PyModule_AddObject(module, "TypedReferenceCount", (PyObject *)&Dtool_TypedReferenceCount);
  // Ramfile
  Dtool_PyModuleClassInit_Ramfile(module);
  PyModule_AddObject(module, "Ramfile", (PyObject *)&Dtool_Ramfile);
  // HashVal
  Dtool_PyModuleClassInit_HashVal(module);
  PyModule_AddObject(module, "HashVal", (PyObject *)&Dtool_HashVal);
  // MemoryUsagePointers
  Dtool_PyModuleClassInit_MemoryUsagePointers(module);
  PyModule_AddObject(module, "MemoryUsagePointers", (PyObject *)&Dtool_MemoryUsagePointers);
  // ISubStream
  Dtool_PyModuleClassInit_ISubStream(module);
  PyModule_AddObject(module, "ISubStream", (PyObject *)&Dtool_ISubStream);
  // OSubStream
  Dtool_PyModuleClassInit_OSubStream(module);
  PyModule_AddObject(module, "OSubStream", (PyObject *)&Dtool_OSubStream);
  // SubStream
  Dtool_PyModuleClassInit_SubStream(module);
  PyModule_AddObject(module, "SubStream", (PyObject *)&Dtool_SubStream);
  // Multifile
  Dtool_PyModuleClassInit_Multifile(module);
  PyModule_AddObject(module, "Multifile", (PyObject *)&Dtool_Multifile);
  // Namable
  Dtool_PyModuleClassInit_Namable(module);
  PyModule_AddObject(module, "Namable", (PyObject *)&Dtool_Namable);
  // OpenSSLWrapper
  Dtool_PyModuleClassInit_OpenSSLWrapper(module);
  PyModule_AddObject(module, "OpenSSLWrapper", (PyObject *)&Dtool_OpenSSLWrapper);
  // SubfileInfo
  Dtool_PyModuleClassInit_SubfileInfo(module);
  PyModule_AddObject(module, "SubfileInfo", (PyObject *)&Dtool_SubfileInfo);
  // VirtualFile
  Dtool_PyModuleClassInit_VirtualFile(module);
  PyModule_AddObject(module, "VirtualFile", (PyObject *)&Dtool_VirtualFile);
  // VirtualFileComposite
  Dtool_PyModuleClassInit_VirtualFileComposite(module);
  PyModule_AddObject(module, "VirtualFileComposite", (PyObject *)&Dtool_VirtualFileComposite);
  // VirtualFileMount
  Dtool_PyModuleClassInit_VirtualFileMount(module);
  PyModule_AddObject(module, "VirtualFileMount", (PyObject *)&Dtool_VirtualFileMount);
  // VirtualFileMountMultifile
  Dtool_PyModuleClassInit_VirtualFileMountMultifile(module);
  PyModule_AddObject(module, "VirtualFileMountMultifile", (PyObject *)&Dtool_VirtualFileMountMultifile);
  // VirtualFileMountRamdisk
  Dtool_PyModuleClassInit_VirtualFileMountRamdisk(module);
  PyModule_AddObject(module, "VirtualFileMountRamdisk", (PyObject *)&Dtool_VirtualFileMountRamdisk);
  // VirtualFileMountSystem
  Dtool_PyModuleClassInit_VirtualFileMountSystem(module);
  PyModule_AddObject(module, "VirtualFileMountSystem", (PyObject *)&Dtool_VirtualFileMountSystem);
  // VirtualFileSimple
  Dtool_PyModuleClassInit_VirtualFileSimple(module);
  PyModule_AddObject(module, "VirtualFileSimple", (PyObject *)&Dtool_VirtualFileSimple);
  // TemporaryFile
  Dtool_PyModuleClassInit_TemporaryFile(module);
  PyModule_AddObject(module, "TemporaryFile", (PyObject *)&Dtool_TemporaryFile);
  // IDecompressStream
  Dtool_PyModuleClassInit_IDecompressStream(module);
  PyModule_AddObject(module, "IDecompressStream", (PyObject *)&Dtool_IDecompressStream);
  // OCompressStream
  Dtool_PyModuleClassInit_OCompressStream(module);
  PyModule_AddObject(module, "OCompressStream", (PyObject *)&Dtool_OCompressStream);
  // VirtualFileList
  Dtool_PyModuleClassInit_VirtualFileList(module);
  PyModule_AddObject(module, "VirtualFileList", (PyObject *)&Dtool_VirtualFileList);
  // VirtualFileSystem
  Dtool_PyModuleClassInit_VirtualFileSystem(module);
  PyModule_AddObject(module, "VirtualFileSystem", (PyObject *)&Dtool_VirtualFileSystem);
  // PointerTo< VirtualFileMount >
  Dtool_PyModuleClassInit_PointerTo_VirtualFileMount(module);
  PyModule_AddObject(module, "PointerTo_VirtualFileMount", (PyObject *)&Dtool_PointerTo_VirtualFileMount);
  Py_INCREF(Dtool_Ptr_PointerTo_VirtualFileMount);
  PyModule_AddObject(module, "PointerToVirtualFileMount", (PyObject *)&Dtool_PointerTo_VirtualFileMount);
  // PointerToBase< VirtualFileMount >
  Dtool_PyModuleClassInit_PointerToBase_VirtualFileMount(module);
  PyModule_AddObject(module, "PointerToBase_VirtualFileMount", (PyObject *)&Dtool_PointerToBase_VirtualFileMount);
  Py_INCREF(Dtool_Ptr_PointerToBase_VirtualFileMount);
  PyModule_AddObject(module, "PointerToBaseVirtualFileMount", (PyObject *)&Dtool_PointerToBase_VirtualFileMount);
  // StringStream
  Dtool_PyModuleClassInit_StringStream(module);
  PyModule_AddObject(module, "StringStream", (PyObject *)&Dtool_StringStream);
  // TrueClock
  Dtool_PyModuleClassInit_TrueClock(module);
  PyModule_AddObject(module, "TrueClock", (PyObject *)&Dtool_TrueClock);
  // Patchfile
  Dtool_PyModuleClassInit_Patchfile(module);
  PyModule_AddObject(module, "Patchfile", (PyObject *)&Dtool_Patchfile);
  // WeakPointerToVoid
  Dtool_PyModuleClassInit_WeakPointerToVoid(module);
  PyModule_AddObject(module, "WeakPointerToVoid", (PyObject *)&Dtool_WeakPointerToVoid);
  // typedef PointerToArray< float > PTA_stdfloat
  Dtool_PyModuleClassInit_PointerToArray_float(module);
  Py_INCREF((PyObject *)&Dtool_PointerToArray_float);
  PyModule_AddObject(module, "PTA_stdfloat", (PyObject *)&Dtool_PointerToArray_float);
  Py_INCREF(Dtool_Ptr_PointerToArray_float);
  PyModule_AddObject(module, "PTAStdfloat", (PyObject *)&Dtool_PointerToArray_float);
  // typedef ConstPointerToArray< float > CPTA_stdfloat
  Dtool_PyModuleClassInit_ConstPointerToArray_float(module);
  Py_INCREF((PyObject *)&Dtool_ConstPointerToArray_float);
  PyModule_AddObject(module, "CPTA_stdfloat", (PyObject *)&Dtool_ConstPointerToArray_float);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_float);
  PyModule_AddObject(module, "CPTAStdfloat", (PyObject *)&Dtool_ConstPointerToArray_float);
}

static PyMethodDef python_simple_funcs[] = {
  {"compress_string", (PyCFunction) &Dtool_compress_string_226, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_compress_string_226_comment},
  {"compressString", (PyCFunction) &Dtool_compress_string_226, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_compress_string_226_comment},
  {"decompress_string", &Dtool_decompress_string_227, METH_O, (const char *)Dtool_decompress_string_227_comment},
  {"decompressString", &Dtool_decompress_string_227, METH_O, (const char *)Dtool_decompress_string_227_comment},
  {"compress_file", (PyCFunction) &Dtool_compress_file_228, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_compress_file_228_comment},
  {"compressFile", (PyCFunction) &Dtool_compress_file_228, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_compress_file_228_comment},
  {"decompress_file", (PyCFunction) &Dtool_decompress_file_229, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decompress_file_229_comment},
  {"decompressFile", (PyCFunction) &Dtool_decompress_file_229, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decompress_file_229_comment},
  {"compress_stream", (PyCFunction) &Dtool_compress_stream_230, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_compress_stream_230_comment},
  {"compressStream", (PyCFunction) &Dtool_compress_stream_230, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_compress_stream_230_comment},
  {"decompress_stream", (PyCFunction) &Dtool_decompress_stream_231, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decompress_stream_231_comment},
  {"decompressStream", (PyCFunction) &Dtool_decompress_stream_231, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decompress_stream_231_comment},
  {"copy_stream", (PyCFunction) &Dtool_copy_stream_232, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_copy_stream_232_comment},
  {"copyStream", (PyCFunction) &Dtool_copy_stream_232, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_copy_stream_232_comment},
  {"encrypt_string", (PyCFunction) &Dtool_encrypt_string_372, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_encrypt_string_372_comment},
  {"encryptString", (PyCFunction) &Dtool_encrypt_string_372, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_encrypt_string_372_comment},
  {"decrypt_string", (PyCFunction) &Dtool_decrypt_string_373, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decrypt_string_373_comment},
  {"decryptString", (PyCFunction) &Dtool_decrypt_string_373, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decrypt_string_373_comment},
  {"encrypt_file", (PyCFunction) &Dtool_encrypt_file_374, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_encrypt_file_374_comment},
  {"encryptFile", (PyCFunction) &Dtool_encrypt_file_374, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_encrypt_file_374_comment},
  {"decrypt_file", (PyCFunction) &Dtool_decrypt_file_375, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decrypt_file_375_comment},
  {"decryptFile", (PyCFunction) &Dtool_decrypt_file_375, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decrypt_file_375_comment},
  {"encrypt_stream", (PyCFunction) &Dtool_encrypt_stream_376, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_encrypt_stream_376_comment},
  {"encryptStream", (PyCFunction) &Dtool_encrypt_stream_376, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_encrypt_stream_376_comment},
  {"decrypt_stream", (PyCFunction) &Dtool_decrypt_stream_377, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decrypt_stream_377_comment},
  {"decryptStream", (PyCFunction) &Dtool_decrypt_stream_377, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_decrypt_stream_377_comment},
  {"error_to_text", &Dtool_error_to_text_379, METH_O, (const char *)Dtool_error_to_text_379_comment},
  {"errorToText", &Dtool_error_to_text_379, METH_O, (const char *)Dtool_error_to_text_379_comment},
  {"get_write_error", &Dtool_get_write_error_380, METH_NOARGS, (const char *)Dtool_get_write_error_380_comment},
  {"getWriteError", &Dtool_get_write_error_380, METH_NOARGS, (const char *)Dtool_get_write_error_380_comment},
  {"handle_socket_error", &Dtool_handle_socket_error_381, METH_NOARGS, (const char *)Dtool_handle_socket_error_381_comment},
  {"handleSocketError", &Dtool_handle_socket_error_381, METH_NOARGS, (const char *)Dtool_handle_socket_error_381_comment},
  {"get_network_error", &Dtool_get_network_error_382, METH_NOARGS, (const char *)Dtool_get_network_error_382_comment},
  {"getNetworkError", &Dtool_get_network_error_382, METH_NOARGS, (const char *)Dtool_get_network_error_382_comment},
  {"password_hash", (PyCFunction) &Dtool_password_hash_737, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_password_hash_737_comment},
  {"passwordHash", (PyCFunction) &Dtool_password_hash_737, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_password_hash_737_comment},
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3express_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3express_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583612469,  /* file_identifier */
  "libp3express",  /* library_name */
  "vDgf",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3express.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  1556  /* next_index */
};

Configure(_in_configure_libp3express);
ConfigureFn(_in_configure_libp3express) {
  interrogate_request_module(&_in_module_def);
}

