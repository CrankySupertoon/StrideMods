/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/ode -Ipanda/src/ode -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libpandaode_igate.cxx -od built/pandac/input/libpandaode.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/ode -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.ode -library libpandaode config_ode.h odeAMotorJoint.h odeBallJoint.h odeBody.h odeBody_ext.h odeBoxGeom.h odeCappedCylinderGeom.h odeCollisionEntry.h odeContact.h odeContactGeom.h odeContactJoint.h odeCylinderGeom.h odeFixedJoint.h odeGeom.h odeGeom_ext.h odeHashSpace.h odeHinge2Joint.h odeHingeJoint.h odeJoint.h odeJointCollection.h odeJointGroup.h odeJoint_ext.h odeLMotorJoint.h odeMass.h odeNullJoint.h odePlane2dJoint.h odePlaneGeom.h odeQuadTreeSpace.h odeRayGeom.h odeSimpleSpace.h odeSliderJoint.h odeSpace.h odeSpace_ext.h odeSphereGeom.h odeSurfaceParameters.h odeTriMeshData.h odeTriMeshGeom.h odeUniversalJoint.h odeUtil.h odeUtil_ext.h odeWorld.h ode_includes.h p3ode_composite1.cxx p3ode_composite2.cxx p3ode_composite3.cxx p3ode_ext_composite.cxx
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "config_ode.h"
#include "dconfig.h"
#include "dtoolbase.h"
#include "extension.h"
#include "geomNode.h"
#include "geomTriangles.h"
#include "geomTristrips.h"
#include "geomVertexData.h"
#include "geomVertexReader.h"
#include "luse.h"
#include "nodePathCollection.h"
#include "notifyCategoryProxy.h"
#include "odeAMotorJoint.h"
#include "odeBallJoint.h"
#include "odeBody.h"
#include "odeBody_ext.h"
#include "odeBoxGeom.h"
#include "odeCappedCylinderGeom.h"
#include "odeCollisionEntry.h"
#include "odeContact.h"
#include "odeContactGeom.h"
#include "odeContactJoint.h"
#include "odeCylinderGeom.h"
#include "odeFixedJoint.h"
#include "odeGeom.h"
#include "odeGeom_ext.h"
#include "odeHashSpace.h"
#include "odeHinge2Joint.h"
#include "odeHingeJoint.h"
#include "odeJoint.h"
#include "odeJointCollection.h"
#include "odeJointGroup.h"
#include "odeJoint_ext.h"
#include "odeLMotorJoint.h"
#include "odeMass.h"
#include "odeNullJoint.h"
#include "odePlane2dJoint.h"
#include "odePlaneGeom.h"
#include "odeQuadTreeSpace.h"
#include "odeRayGeom.h"
#include "odeSimpleSpace.h"
#include "odeSliderJoint.h"
#include "odeSpace.h"
#include "odeSpace_ext.h"
#include "odeSphereGeom.h"
#include "odeSurfaceParameters.h"
#include "odeTriMeshData.h"
#include "odeTriMeshGeom.h"
#include "odeUniversalJoint.h"
#include "odeUtil.h"
#include "odeUtil_ext.h"
#include "odeWorld.h"
#include "ode_includes.h"
#include "pandabase.h"
#include "py_panda.h"
#include "typedObject.h"
#include "typedReferenceCount.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class dxBody
 */
typedef dxBody dxBody_localtype;
Define_Module_Class_Private(panda3d.ode, dxBody, dxBody_localtype, dxBody);
static struct Dtool_PyTypedObject *const Dtool_Ptr_dxBody = &Dtool_dxBody;
static void Dtool_PyModuleClassInit_dxBody(PyObject *module);

/**
 * Forward declarations for top-level class dxGeom
 */
typedef dxGeom dxGeom_localtype;
Define_Module_Class_Private(panda3d.ode, dxGeom, dxGeom_localtype, dxGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_dxGeom = &Dtool_dxGeom;
static void Dtool_PyModuleClassInit_dxGeom(PyObject *module);

/**
 * Forward declarations for top-level class dxJoint
 */
typedef dxJoint dxJoint_localtype;
Define_Module_Class_Private(panda3d.ode, dxJoint, dxJoint_localtype, dxJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_dxJoint = &Dtool_dxJoint;
static void Dtool_PyModuleClassInit_dxJoint(PyObject *module);

/**
 * Forward declarations for top-level class dxJointGroup
 */
typedef dxJointGroup dxJointGroup_localtype;
Define_Module_Class_Private(panda3d.ode, dxJointGroup, dxJointGroup_localtype, dxJointGroup);
static struct Dtool_PyTypedObject *const Dtool_Ptr_dxJointGroup = &Dtool_dxJointGroup;
static void Dtool_PyModuleClassInit_dxJointGroup(PyObject *module);

/**
 * Forward declarations for top-level class dxSpace
 */
typedef dxSpace dxSpace_localtype;
Define_Module_Class_Private(panda3d.ode, dxSpace, dxSpace_localtype, dxSpace);
static struct Dtool_PyTypedObject *const Dtool_Ptr_dxSpace = &Dtool_dxSpace;
static void Dtool_PyModuleClassInit_dxSpace(PyObject *module);

/**
 * Forward declarations for top-level class dxTriMeshData
 */
typedef dxTriMeshData dxTriMeshData_localtype;
Define_Module_Class_Private(panda3d.ode, dxTriMeshData, dxTriMeshData_localtype, dxTriMeshData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_dxTriMeshData = &Dtool_dxTriMeshData;
static void Dtool_PyModuleClassInit_dxTriMeshData(PyObject *module);

/**
 * Forward declarations for top-level class dxWorld
 */
typedef dxWorld dxWorld_localtype;
Define_Module_Class_Private(panda3d.ode, dxWorld, dxWorld_localtype, dxWorld);
static struct Dtool_PyTypedObject *const Dtool_Ptr_dxWorld = &Dtool_dxWorld;
static void Dtool_PyModuleClassInit_dxWorld(PyObject *module);

/**
 * Forward declarations for top-level class OdeWorld
 */
typedef OdeWorld OdeWorld_localtype;
Define_Module_Class(panda3d.ode, OdeWorld, OdeWorld_localtype, OdeWorld);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeWorld = &Dtool_OdeWorld;
static void Dtool_PyModuleClassInit_OdeWorld(PyObject *module);

/**
 * Forward declarations for top-level class OdeJointGroup
 */
typedef OdeJointGroup OdeJointGroup_localtype;
Define_Module_Class(panda3d.ode, OdeJointGroup, OdeJointGroup_localtype, OdeJointGroup);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeJointGroup = &Dtool_OdeJointGroup;
static void Dtool_PyModuleClassInit_OdeJointGroup(PyObject *module);

/**
 * Forward declarations for top-level class OdeJointFeedback
 */
typedef OdeJointFeedback OdeJointFeedback_localtype;
Define_Module_Class(panda3d.ode, OdeJointFeedback, OdeJointFeedback_localtype, OdeJointFeedback);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeJointFeedback = &Dtool_OdeJointFeedback;
static void Dtool_PyModuleClassInit_OdeJointFeedback(PyObject *module);

/**
 * Forward declarations for top-level class OdeJoint
 */
typedef OdeJoint OdeJoint_localtype;
Define_Module_Class(panda3d.ode, OdeJoint, OdeJoint_localtype, OdeJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeJoint = &Dtool_OdeJoint;
static void Dtool_PyModuleClassInit_OdeJoint(PyObject *module);

/**
 * Forward declarations for top-level class OdeAMotorJoint
 */
typedef OdeAMotorJoint OdeAMotorJoint_localtype;
Define_Module_Class(panda3d.ode, OdeAMotorJoint, OdeAMotorJoint_localtype, OdeAMotorJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeAMotorJoint = &Dtool_OdeAMotorJoint;
static void Dtool_PyModuleClassInit_OdeAMotorJoint(PyObject *module);

/**
 * Forward declarations for top-level class OdeBallJoint
 */
typedef OdeBallJoint OdeBallJoint_localtype;
Define_Module_Class(panda3d.ode, OdeBallJoint, OdeBallJoint_localtype, OdeBallJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeBallJoint = &Dtool_OdeBallJoint;
static void Dtool_PyModuleClassInit_OdeBallJoint(PyObject *module);

/**
 * Forward declarations for top-level class OdeMass
 */
typedef OdeMass OdeMass_localtype;
Define_Module_ClassRef(panda3d.ode, OdeMass, OdeMass_localtype, OdeMass);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeMass = &Dtool_OdeMass;
static void Dtool_PyModuleClassInit_OdeMass(PyObject *module);

/**
 * Forward declarations for top-level class OdeBody
 */
typedef OdeBody OdeBody_localtype;
Define_Module_Class(panda3d.ode, OdeBody, OdeBody_localtype, OdeBody);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeBody = &Dtool_OdeBody;
static void Dtool_PyModuleClassInit_OdeBody(PyObject *module);

/**
 * Forward declarations for top-level class OdeSpace
 */
typedef OdeSpace OdeSpace_localtype;
Define_Module_Class(panda3d.ode, OdeSpace, OdeSpace_localtype, OdeSpace);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeSpace = &Dtool_OdeSpace;
static void Dtool_PyModuleClassInit_OdeSpace(PyObject *module);

/**
 * Forward declarations for top-level class OdeGeom
 */
typedef OdeGeom OdeGeom_localtype;
Define_Module_Class(panda3d.ode, OdeGeom, OdeGeom_localtype, OdeGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeGeom = &Dtool_OdeGeom;
static void Dtool_PyModuleClassInit_OdeGeom(PyObject *module);

/**
 * Forward declarations for top-level class OdeBoxGeom
 */
typedef OdeBoxGeom OdeBoxGeom_localtype;
Define_Module_Class(panda3d.ode, OdeBoxGeom, OdeBoxGeom_localtype, OdeBoxGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeBoxGeom = &Dtool_OdeBoxGeom;
static void Dtool_PyModuleClassInit_OdeBoxGeom(PyObject *module);

/**
 * Forward declarations for top-level class OdeCappedCylinderGeom
 */
typedef OdeCappedCylinderGeom OdeCappedCylinderGeom_localtype;
Define_Module_Class(panda3d.ode, OdeCappedCylinderGeom, OdeCappedCylinderGeom_localtype, OdeCappedCylinderGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeCappedCylinderGeom = &Dtool_OdeCappedCylinderGeom;
static void Dtool_PyModuleClassInit_OdeCappedCylinderGeom(PyObject *module);

/**
 * Forward declarations for top-level class OdeContactGeom
 */
typedef OdeContactGeom OdeContactGeom_localtype;
Define_Module_ClassRef(panda3d.ode, OdeContactGeom, OdeContactGeom_localtype, OdeContactGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeContactGeom = &Dtool_OdeContactGeom;
static void Dtool_PyModuleClassInit_OdeContactGeom(PyObject *module);

/**
 * Forward declarations for top-level class OdeCollisionEntry
 */
typedef OdeCollisionEntry OdeCollisionEntry_localtype;
Define_Module_ClassRef(panda3d.ode, OdeCollisionEntry, OdeCollisionEntry_localtype, OdeCollisionEntry);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeCollisionEntry = &Dtool_OdeCollisionEntry;
static void Dtool_PyModuleClassInit_OdeCollisionEntry(PyObject *module);

/**
 * Forward declarations for top-level class OdeSurfaceParameters
 */
typedef OdeSurfaceParameters OdeSurfaceParameters_localtype;
Define_Module_Class(panda3d.ode, OdeSurfaceParameters, OdeSurfaceParameters_localtype, OdeSurfaceParameters);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeSurfaceParameters = &Dtool_OdeSurfaceParameters;
static void Dtool_PyModuleClassInit_OdeSurfaceParameters(PyObject *module);

/**
 * Forward declarations for top-level class OdeContact
 */
typedef OdeContact OdeContact_localtype;
Define_Module_ClassRef(panda3d.ode, OdeContact, OdeContact_localtype, OdeContact);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeContact = &Dtool_OdeContact;
static void Dtool_PyModuleClassInit_OdeContact(PyObject *module);
bool Dtool_ConstCoerce_OdeContact(PyObject *args, CPT(OdeContact) &coerced);
bool Dtool_Coerce_OdeContact(PyObject *args, PT(OdeContact) &coerced);

/**
 * Forward declarations for top-level class OdeContactJoint
 */
typedef OdeContactJoint OdeContactJoint_localtype;
Define_Module_Class(panda3d.ode, OdeContactJoint, OdeContactJoint_localtype, OdeContactJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeContactJoint = &Dtool_OdeContactJoint;
static void Dtool_PyModuleClassInit_OdeContactJoint(PyObject *module);

/**
 * Forward declarations for top-level class OdeCylinderGeom
 */
typedef OdeCylinderGeom OdeCylinderGeom_localtype;
Define_Module_Class(panda3d.ode, OdeCylinderGeom, OdeCylinderGeom_localtype, OdeCylinderGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeCylinderGeom = &Dtool_OdeCylinderGeom;
static void Dtool_PyModuleClassInit_OdeCylinderGeom(PyObject *module);

/**
 * Forward declarations for top-level class OdeFixedJoint
 */
typedef OdeFixedJoint OdeFixedJoint_localtype;
Define_Module_Class(panda3d.ode, OdeFixedJoint, OdeFixedJoint_localtype, OdeFixedJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeFixedJoint = &Dtool_OdeFixedJoint;
static void Dtool_PyModuleClassInit_OdeFixedJoint(PyObject *module);

/**
 * Forward declarations for top-level class OdeHashSpace
 */
typedef OdeHashSpace OdeHashSpace_localtype;
Define_Module_Class(panda3d.ode, OdeHashSpace, OdeHashSpace_localtype, OdeHashSpace);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeHashSpace = &Dtool_OdeHashSpace;
static void Dtool_PyModuleClassInit_OdeHashSpace(PyObject *module);
OdeHashSpace *Dtool_Coerce_OdeHashSpace(PyObject *args, OdeHashSpace &coerced);

/**
 * Forward declarations for top-level class OdeHinge2Joint
 */
typedef OdeHinge2Joint OdeHinge2Joint_localtype;
Define_Module_Class(panda3d.ode, OdeHinge2Joint, OdeHinge2Joint_localtype, OdeHinge2Joint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeHinge2Joint = &Dtool_OdeHinge2Joint;
static void Dtool_PyModuleClassInit_OdeHinge2Joint(PyObject *module);

/**
 * Forward declarations for top-level class OdeHingeJoint
 */
typedef OdeHingeJoint OdeHingeJoint_localtype;
Define_Module_Class(panda3d.ode, OdeHingeJoint, OdeHingeJoint_localtype, OdeHingeJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeHingeJoint = &Dtool_OdeHingeJoint;
static void Dtool_PyModuleClassInit_OdeHingeJoint(PyObject *module);

/**
 * Forward declarations for top-level class OdeJointCollection
 */
typedef OdeJointCollection OdeJointCollection_localtype;
Define_Module_Class(panda3d.ode, OdeJointCollection, OdeJointCollection_localtype, OdeJointCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeJointCollection = &Dtool_OdeJointCollection;
static void Dtool_PyModuleClassInit_OdeJointCollection(PyObject *module);

/**
 * Forward declarations for top-level class OdeLMotorJoint
 */
typedef OdeLMotorJoint OdeLMotorJoint_localtype;
Define_Module_Class(panda3d.ode, OdeLMotorJoint, OdeLMotorJoint_localtype, OdeLMotorJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeLMotorJoint = &Dtool_OdeLMotorJoint;
static void Dtool_PyModuleClassInit_OdeLMotorJoint(PyObject *module);

/**
 * Forward declarations for top-level class OdeNullJoint
 */
typedef OdeNullJoint OdeNullJoint_localtype;
Define_Module_Class(panda3d.ode, OdeNullJoint, OdeNullJoint_localtype, OdeNullJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeNullJoint = &Dtool_OdeNullJoint;
static void Dtool_PyModuleClassInit_OdeNullJoint(PyObject *module);

/**
 * Forward declarations for top-level class OdePlane2dJoint
 */
typedef OdePlane2dJoint OdePlane2dJoint_localtype;
Define_Module_Class(panda3d.ode, OdePlane2dJoint, OdePlane2dJoint_localtype, OdePlane2dJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdePlane2dJoint = &Dtool_OdePlane2dJoint;
static void Dtool_PyModuleClassInit_OdePlane2dJoint(PyObject *module);

/**
 * Forward declarations for top-level class OdePlaneGeom
 */
typedef OdePlaneGeom OdePlaneGeom_localtype;
Define_Module_Class(panda3d.ode, OdePlaneGeom, OdePlaneGeom_localtype, OdePlaneGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdePlaneGeom = &Dtool_OdePlaneGeom;
static void Dtool_PyModuleClassInit_OdePlaneGeom(PyObject *module);

/**
 * Forward declarations for top-level class OdeQuadTreeSpace
 */
typedef OdeQuadTreeSpace OdeQuadTreeSpace_localtype;
Define_Module_Class(panda3d.ode, OdeQuadTreeSpace, OdeQuadTreeSpace_localtype, OdeQuadTreeSpace);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeQuadTreeSpace = &Dtool_OdeQuadTreeSpace;
static void Dtool_PyModuleClassInit_OdeQuadTreeSpace(PyObject *module);

/**
 * Forward declarations for top-level class OdeRayGeom
 */
typedef OdeRayGeom OdeRayGeom_localtype;
Define_Module_Class(panda3d.ode, OdeRayGeom, OdeRayGeom_localtype, OdeRayGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeRayGeom = &Dtool_OdeRayGeom;
static void Dtool_PyModuleClassInit_OdeRayGeom(PyObject *module);

/**
 * Forward declarations for top-level class OdeSimpleSpace
 */
typedef OdeSimpleSpace OdeSimpleSpace_localtype;
Define_Module_Class(panda3d.ode, OdeSimpleSpace, OdeSimpleSpace_localtype, OdeSimpleSpace);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeSimpleSpace = &Dtool_OdeSimpleSpace;
static void Dtool_PyModuleClassInit_OdeSimpleSpace(PyObject *module);
OdeSimpleSpace *Dtool_Coerce_OdeSimpleSpace(PyObject *args, OdeSimpleSpace &coerced);

/**
 * Forward declarations for top-level class OdeSliderJoint
 */
typedef OdeSliderJoint OdeSliderJoint_localtype;
Define_Module_Class(panda3d.ode, OdeSliderJoint, OdeSliderJoint_localtype, OdeSliderJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeSliderJoint = &Dtool_OdeSliderJoint;
static void Dtool_PyModuleClassInit_OdeSliderJoint(PyObject *module);

/**
 * Forward declarations for top-level class OdeSphereGeom
 */
typedef OdeSphereGeom OdeSphereGeom_localtype;
Define_Module_Class(panda3d.ode, OdeSphereGeom, OdeSphereGeom_localtype, OdeSphereGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeSphereGeom = &Dtool_OdeSphereGeom;
static void Dtool_PyModuleClassInit_OdeSphereGeom(PyObject *module);

/**
 * Forward declarations for top-level class OdeTriMeshData
 */
typedef OdeTriMeshData OdeTriMeshData_localtype;
Define_Module_ClassRef(panda3d.ode, OdeTriMeshData, OdeTriMeshData_localtype, OdeTriMeshData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeTriMeshData = &Dtool_OdeTriMeshData;
static void Dtool_PyModuleClassInit_OdeTriMeshData(PyObject *module);
bool Dtool_ConstCoerce_OdeTriMeshData(PyObject *args, CPT(OdeTriMeshData) &coerced);
bool Dtool_Coerce_OdeTriMeshData(PyObject *args, PT(OdeTriMeshData) &coerced);

/**
 * Forward declarations for top-level class OdeTriMeshGeom
 */
typedef OdeTriMeshGeom OdeTriMeshGeom_localtype;
Define_Module_Class(panda3d.ode, OdeTriMeshGeom, OdeTriMeshGeom_localtype, OdeTriMeshGeom);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeTriMeshGeom = &Dtool_OdeTriMeshGeom;
static void Dtool_PyModuleClassInit_OdeTriMeshGeom(PyObject *module);

/**
 * Forward declarations for top-level class OdeUniversalJoint
 */
typedef OdeUniversalJoint OdeUniversalJoint_localtype;
Define_Module_Class(panda3d.ode, OdeUniversalJoint, OdeUniversalJoint_localtype, OdeUniversalJoint);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeUniversalJoint = &Dtool_OdeUniversalJoint;
static void Dtool_PyModuleClassInit_OdeUniversalJoint(PyObject *module);

/**
 * Forward declarations for top-level class OdeUtil
 */
typedef OdeUtil OdeUtil_localtype;
Define_Module_Class(panda3d.ode, OdeUtil, OdeUtil_localtype, OdeUtil);
static struct Dtool_PyTypedObject *const Dtool_Ptr_OdeUtil = &Dtool_OdeUtil;
static void Dtool_PyModuleClassInit_OdeUtil(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"dxBody", &Dtool_dxBody},
  {"dxGeom", &Dtool_dxGeom},
  {"dxJoint", &Dtool_dxJoint},
  {"dxJointGroup", &Dtool_dxJointGroup},
  {"dxSpace", &Dtool_dxSpace},
  {"dxTriMeshData", &Dtool_dxTriMeshData},
  {"dxWorld", &Dtool_dxWorld},
  {"OdeWorld", &Dtool_OdeWorld},
  {"OdeJointGroup", &Dtool_OdeJointGroup},
  {"OdeJointFeedback", &Dtool_OdeJointFeedback},
  {"OdeJoint", &Dtool_OdeJoint},
  {"OdeAMotorJoint", &Dtool_OdeAMotorJoint},
  {"OdeBallJoint", &Dtool_OdeBallJoint},
  {"OdeMass", &Dtool_OdeMass},
  {"OdeBody", &Dtool_OdeBody},
  {"OdeSpace", &Dtool_OdeSpace},
  {"OdeGeom", &Dtool_OdeGeom},
  {"OdeBoxGeom", &Dtool_OdeBoxGeom},
  {"OdeCappedCylinderGeom", &Dtool_OdeCappedCylinderGeom},
  {"OdeContactGeom", &Dtool_OdeContactGeom},
  {"OdeCollisionEntry", &Dtool_OdeCollisionEntry},
  {"OdeSurfaceParameters", &Dtool_OdeSurfaceParameters},
  {"OdeContact", &Dtool_OdeContact},
  {"OdeContactJoint", &Dtool_OdeContactJoint},
  {"OdeCylinderGeom", &Dtool_OdeCylinderGeom},
  {"OdeFixedJoint", &Dtool_OdeFixedJoint},
  {"OdeHashSpace", &Dtool_OdeHashSpace},
  {"OdeHinge2Joint", &Dtool_OdeHinge2Joint},
  {"OdeHingeJoint", &Dtool_OdeHingeJoint},
  {"OdeJointCollection", &Dtool_OdeJointCollection},
  {"OdeLMotorJoint", &Dtool_OdeLMotorJoint},
  {"OdeNullJoint", &Dtool_OdeNullJoint},
  {"OdePlane2dJoint", &Dtool_OdePlane2dJoint},
  {"OdePlaneGeom", &Dtool_OdePlaneGeom},
  {"OdeQuadTreeSpace", &Dtool_OdeQuadTreeSpace},
  {"OdeRayGeom", &Dtool_OdeRayGeom},
  {"OdeSimpleSpace", &Dtool_OdeSimpleSpace},
  {"OdeSliderJoint", &Dtool_OdeSliderJoint},
  {"OdeSphereGeom", &Dtool_OdeSphereGeom},
  {"OdeTriMeshData", &Dtool_OdeTriMeshData},
  {"OdeTriMeshGeom", &Dtool_OdeTriMeshGeom},
  {"OdeUniversalJoint", &Dtool_OdeUniversalJoint},
  {"OdeUtil", &Dtool_OdeUtil},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[1].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[2].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[3].type)
  {"LVecBase3f", nullptr},
#define Dtool_Ptr_LVecBase3f (imports[4].type)
  {"LVector3f", nullptr},
#define Dtool_Ptr_LVector3f (imports[5].type)
  {"LPoint3f", nullptr},
#define Dtool_Ptr_LPoint3f (imports[6].type)
  {"LVecBase4f", nullptr},
#define Dtool_Ptr_LVecBase4f (imports[7].type)
  {"LMatrix3f", nullptr},
#define Dtool_Ptr_LMatrix3f (imports[8].type)
  {"LQuaternionf", nullptr},
#define Dtool_Ptr_LQuaternionf (imports[9].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[10].type)
  {"BitMask< uint32_t, 32 >", nullptr},
#define Dtool_Ptr_BitMask_uint32_t_32 (imports[11].type)
  {"NodePath", nullptr},
#define Dtool_Ptr_NodePath (imports[12].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LMatrix3f
#ifndef LINK_ALL_STATIC
inline static LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced) {
  nassertr(Dtool_Ptr_LMatrix3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix3f *(*)(PyObject *, LMatrix3f &))Dtool_Ptr_LMatrix3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3f = &Dtool_LMatrix3f;
extern LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced);
#endif
// LQuaternionf
#ifndef LINK_ALL_STATIC
inline static LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced) {
  nassertr(Dtool_Ptr_LQuaternionf != nullptr, nullptr);
  nassertr(Dtool_Ptr_LQuaternionf->_Dtool_Coerce != nullptr, nullptr);
  return ((LQuaternionf *(*)(PyObject *, LQuaternionf &))Dtool_Ptr_LQuaternionf->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LQuaternionf;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LQuaternionf = &Dtool_LQuaternionf;
extern LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced);
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// BitMask< uint32_t, 32 >
#ifndef LINK_ALL_STATIC
inline static BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced) {
  nassertr(Dtool_Ptr_BitMask_uint32_t_32 != nullptr, nullptr);
  nassertr(Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce != nullptr, nullptr);
  return ((BitMask< uint32_t, 32 > *(*)(PyObject *, BitMask< uint32_t, 32 > &))Dtool_Ptr_BitMask_uint32_t_32->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_BitMask_uint32_t_32;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint32_t_32 = &Dtool_BitMask_uint32_t_32;
extern BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced);
#endif
// NodePath
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class dxBody
 */
static int Dtool_Init_dxBody(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_dxBody(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_dxBody) {
    printf("dxBody ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  dxBody *local_this = (dxBody *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_dxBody) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_dxBody(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_dxBody) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class dxGeom
 */
static int Dtool_Init_dxGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_dxGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_dxGeom) {
    printf("dxGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  dxGeom *local_this = (dxGeom *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_dxGeom) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_dxGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_dxGeom) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class dxJoint
 */
static int Dtool_Init_dxJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_dxJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_dxJoint) {
    printf("dxJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  dxJoint *local_this = (dxJoint *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_dxJoint) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_dxJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_dxJoint) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class dxJointGroup
 */
static int Dtool_Init_dxJointGroup(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_dxJointGroup(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_dxJointGroup) {
    printf("dxJointGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  dxJointGroup *local_this = (dxJointGroup *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_dxJointGroup) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_dxJointGroup(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_dxJointGroup) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class dxSpace
 */
static int Dtool_Init_dxSpace(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_dxSpace(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_dxSpace) {
    printf("dxSpace ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  dxSpace *local_this = (dxSpace *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_dxSpace) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_dxSpace(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_dxSpace) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class dxTriMeshData
 */
static int Dtool_Init_dxTriMeshData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_dxTriMeshData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_dxTriMeshData) {
    printf("dxTriMeshData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  dxTriMeshData *local_this = (dxTriMeshData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_dxTriMeshData) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_dxTriMeshData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_dxTriMeshData) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class dxWorld
 */
static int Dtool_Init_dxWorld(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_dxWorld(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_dxWorld) {
    printf("dxWorld ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  dxWorld *local_this = (dxWorld *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_dxWorld) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_dxWorld(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_dxWorld) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeWorld
 */
/**
 * Python function wrapper for:
 * void OdeWorld::destroy(void)
 */
static PyObject *Dtool_OdeWorld_destroy_11(PyObject *self, PyObject *) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.destroy")) {
    return nullptr;
  }
  // 1-void OdeWorld::destroy(void)
  ((*local_this).destroy)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_destroy_11_comment =
  "C++ Interface:\n"
  "destroy(const OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_destroy_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool OdeWorld::is_empty(void) const
 */
static PyObject *Dtool_OdeWorld_is_empty_12(PyObject *self, PyObject *) {
  OdeWorld *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeWorld)) {
    return nullptr;
  }
  // 1-inline bool OdeWorld::is_empty(void) const
  bool return_value = ((*(const OdeWorld*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_is_empty_12_comment =
  "C++ Interface:\n"
  "is_empty(OdeWorld self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ID is 0, meaning the OdeWorld does not point to a valid\n"
  " * world.  It is an error to call a method on an empty world.  Note that an\n"
  " * empty OdeWorld also evaluates to False.\n"
  " */";
#else
static const char *Dtool_OdeWorld_is_empty_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dWorldID OdeWorld::get_id(void) const
 */
static PyObject *Dtool_OdeWorld_get_id_13(PyObject *self, PyObject *) {
  OdeWorld *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeWorld)) {
    return nullptr;
  }
  // 1-inline dWorldID OdeWorld::get_id(void) const
  dWorldID return_value = ((*(const OdeWorld*)local_this).get_id)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_dxWorld, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_id_13_comment =
  "C++ Interface:\n"
  "get_id(OdeWorld self)\n"
  "\n"
  "/**\n"
  " * Returns the underlying dWorldID.\n"
  " */";
#else
static const char *Dtool_OdeWorld_get_id_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_gravity(LVecBase3f const &vec)
 * inline void OdeWorld::set_gravity(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeWorld_set_gravity_14(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_gravity")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "vec")) {
        // 1-inline void OdeWorld::set_gravity(LVecBase3f const &vec)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeWorld.set_gravity", "LVecBase3f");
        }
        ((*local_this).set_gravity)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeWorld::set_gravity(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_gravity", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_gravity)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_gravity() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gravity(const OdeWorld self, const LVecBase3f vec)\n"
      "set_gravity(const OdeWorld self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_gravity_14_comment =
  "C++ Interface:\n"
  "set_gravity(const OdeWorld self, const LVecBase3f vec)\n"
  "set_gravity(const OdeWorld self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeWorld_set_gravity_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_erp(dReal erp)
 */
static PyObject *Dtool_OdeWorld_set_erp_15(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_erp")) {
    return nullptr;
  }
  // 1-inline void OdeWorld::set_erp(dReal erp)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_erp)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_erp(const OdeWorld self, float erp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_erp_15_comment =
  "C++ Interface:\n"
  "set_erp(const OdeWorld self, float erp)\n";
#else
static const char *Dtool_OdeWorld_set_erp_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_cfm(dReal cfm)
 */
static PyObject *Dtool_OdeWorld_set_cfm_16(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_cfm")) {
    return nullptr;
  }
  // 1-inline void OdeWorld::set_cfm(dReal cfm)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_cfm)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cfm(const OdeWorld self, float cfm)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_cfm_16_comment =
  "C++ Interface:\n"
  "set_cfm(const OdeWorld self, float cfm)\n";
#else
static const char *Dtool_OdeWorld_set_cfm_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_quick_step_num_iterations(int num)
 */
static PyObject *Dtool_OdeWorld_set_quick_step_num_iterations_17(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_quick_step_num_iterations")) {
    return nullptr;
  }
  // 1-inline void OdeWorld::set_quick_step_num_iterations(int num)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_quick_step_num_iterations)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_quick_step_num_iterations(const OdeWorld self, int num)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_quick_step_num_iterations_17_comment =
  "C++ Interface:\n"
  "set_quick_step_num_iterations(const OdeWorld self, int num)\n";
#else
static const char *Dtool_OdeWorld_set_quick_step_num_iterations_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_quick_step_w(dReal over_relaxation)
 */
static PyObject *Dtool_OdeWorld_set_quick_step_w_18(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_quick_step_w")) {
    return nullptr;
  }
  // 1-inline void OdeWorld::set_quick_step_w(dReal over_relaxation)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_quick_step_w)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_quick_step_w(const OdeWorld self, float over_relaxation)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_quick_step_w_18_comment =
  "C++ Interface:\n"
  "set_quick_step_w(const OdeWorld self, float over_relaxation)\n";
#else
static const char *Dtool_OdeWorld_set_quick_step_w_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_contact_max_correcting_vel(dReal vel)
 */
static PyObject *Dtool_OdeWorld_set_contact_max_correcting_vel_19(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_contact_max_correcting_vel")) {
    return nullptr;
  }
  // 1-inline void OdeWorld::set_contact_max_correcting_vel(dReal vel)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_contact_max_correcting_vel)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_contact_max_correcting_vel(const OdeWorld self, float vel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_contact_max_correcting_vel_19_comment =
  "C++ Interface:\n"
  "set_contact_max_correcting_vel(const OdeWorld self, float vel)\n";
#else
static const char *Dtool_OdeWorld_set_contact_max_correcting_vel_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_contact_surface_layer(dReal depth)
 */
static PyObject *Dtool_OdeWorld_set_contact_surface_layer_20(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_contact_surface_layer")) {
    return nullptr;
  }
  // 1-inline void OdeWorld::set_contact_surface_layer(dReal depth)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_contact_surface_layer)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_contact_surface_layer(const OdeWorld self, float depth)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_contact_surface_layer_20_comment =
  "C++ Interface:\n"
  "set_contact_surface_layer(const OdeWorld self, float depth)\n";
#else
static const char *Dtool_OdeWorld_set_contact_surface_layer_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_auto_disable_linear_threshold(dReal linear_threshold)
 */
static PyObject *Dtool_OdeWorld_set_auto_disable_linear_threshold_21(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_auto_disable_linear_threshold")) {
    return nullptr;
  }
  // 1-inline void OdeWorld::set_auto_disable_linear_threshold(dReal linear_threshold)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_auto_disable_linear_threshold)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_linear_threshold(const OdeWorld self, float linear_threshold)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_auto_disable_linear_threshold_21_comment =
  "C++ Interface:\n"
  "set_auto_disable_linear_threshold(const OdeWorld self, float linear_threshold)\n";
#else
static const char *Dtool_OdeWorld_set_auto_disable_linear_threshold_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_auto_disable_angular_threshold(dReal angular_threshold)
 */
static PyObject *Dtool_OdeWorld_set_auto_disable_angular_threshold_22(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_auto_disable_angular_threshold")) {
    return nullptr;
  }
  // 1-inline void OdeWorld::set_auto_disable_angular_threshold(dReal angular_threshold)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_auto_disable_angular_threshold)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_angular_threshold(const OdeWorld self, float angular_threshold)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_auto_disable_angular_threshold_22_comment =
  "C++ Interface:\n"
  "set_auto_disable_angular_threshold(const OdeWorld self, float angular_threshold)\n";
#else
static const char *Dtool_OdeWorld_set_auto_disable_angular_threshold_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_auto_disable_steps(int steps)
 */
static PyObject *Dtool_OdeWorld_set_auto_disable_steps_23(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_auto_disable_steps")) {
    return nullptr;
  }
  // 1-inline void OdeWorld::set_auto_disable_steps(int steps)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_auto_disable_steps)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_steps(const OdeWorld self, int steps)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_auto_disable_steps_23_comment =
  "C++ Interface:\n"
  "set_auto_disable_steps(const OdeWorld self, int steps)\n";
#else
static const char *Dtool_OdeWorld_set_auto_disable_steps_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_auto_disable_time(dReal time)
 */
static PyObject *Dtool_OdeWorld_set_auto_disable_time_24(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_auto_disable_time")) {
    return nullptr;
  }
  // 1-inline void OdeWorld::set_auto_disable_time(dReal time)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_auto_disable_time)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_time(const OdeWorld self, float time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_auto_disable_time_24_comment =
  "C++ Interface:\n"
  "set_auto_disable_time(const OdeWorld self, float time)\n";
#else
static const char *Dtool_OdeWorld_set_auto_disable_time_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::set_auto_disable_flag(int do_auto_disable)
 */
static PyObject *Dtool_OdeWorld_set_auto_disable_flag_25(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_auto_disable_flag")) {
    return nullptr;
  }
  // 1-inline void OdeWorld::set_auto_disable_flag(int do_auto_disable)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_auto_disable_flag)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_flag(const OdeWorld self, int do_auto_disable)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_auto_disable_flag_25_comment =
  "C++ Interface:\n"
  "set_auto_disable_flag(const OdeWorld self, int do_auto_disable)\n";
#else
static const char *Dtool_OdeWorld_set_auto_disable_flag_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeWorld::get_gravity(void) const
 */
static PyObject *Dtool_OdeWorld_get_gravity_26(PyObject *self, PyObject *) {
  OdeWorld *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeWorld)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeWorld::get_gravity(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeWorld*)local_this).get_gravity)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_gravity_26_comment =
  "C++ Interface:\n"
  "get_gravity(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_gravity_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeWorld::get_erp(void) const
 */
static PyObject *Dtool_OdeWorld_get_erp_27(PyObject *self, PyObject *) {
  OdeWorld *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeWorld)) {
    return nullptr;
  }
  // 1-inline dReal OdeWorld::get_erp(void) const
  dReal return_value = ((*(const OdeWorld*)local_this).get_erp)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_erp_27_comment =
  "C++ Interface:\n"
  "get_erp(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_erp_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeWorld::get_cfm(void) const
 */
static PyObject *Dtool_OdeWorld_get_cfm_28(PyObject *self, PyObject *) {
  OdeWorld *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeWorld)) {
    return nullptr;
  }
  // 1-inline dReal OdeWorld::get_cfm(void) const
  dReal return_value = ((*(const OdeWorld*)local_this).get_cfm)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_cfm_28_comment =
  "C++ Interface:\n"
  "get_cfm(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_cfm_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeWorld::get_quick_step_num_iterations(void) const
 */
static PyObject *Dtool_OdeWorld_get_quick_step_num_iterations_29(PyObject *self, PyObject *) {
  OdeWorld *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeWorld)) {
    return nullptr;
  }
  // 1-inline int OdeWorld::get_quick_step_num_iterations(void) const
  int return_value = ((*(const OdeWorld*)local_this).get_quick_step_num_iterations)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_quick_step_num_iterations_29_comment =
  "C++ Interface:\n"
  "get_quick_step_num_iterations(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_quick_step_num_iterations_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeWorld::get_quick_step_w(void) const
 */
static PyObject *Dtool_OdeWorld_get_quick_step_w_30(PyObject *self, PyObject *) {
  OdeWorld *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeWorld)) {
    return nullptr;
  }
  // 1-inline dReal OdeWorld::get_quick_step_w(void) const
  dReal return_value = ((*(const OdeWorld*)local_this).get_quick_step_w)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_quick_step_w_30_comment =
  "C++ Interface:\n"
  "get_quick_step_w(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_quick_step_w_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeWorld::get_contact_max_correcting_vel(void) const
 */
static PyObject *Dtool_OdeWorld_get_contact_max_correcting_vel_31(PyObject *self, PyObject *) {
  OdeWorld *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeWorld)) {
    return nullptr;
  }
  // 1-inline dReal OdeWorld::get_contact_max_correcting_vel(void) const
  dReal return_value = ((*(const OdeWorld*)local_this).get_contact_max_correcting_vel)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_contact_max_correcting_vel_31_comment =
  "C++ Interface:\n"
  "get_contact_max_correcting_vel(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_contact_max_correcting_vel_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeWorld::get_contact_surface_layer(void) const
 */
static PyObject *Dtool_OdeWorld_get_contact_surface_layer_32(PyObject *self, PyObject *) {
  OdeWorld *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeWorld)) {
    return nullptr;
  }
  // 1-inline dReal OdeWorld::get_contact_surface_layer(void) const
  dReal return_value = ((*(const OdeWorld*)local_this).get_contact_surface_layer)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_contact_surface_layer_32_comment =
  "C++ Interface:\n"
  "get_contact_surface_layer(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_contact_surface_layer_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeWorld::get_auto_disable_linear_threshold(void) const
 */
static PyObject *Dtool_OdeWorld_get_auto_disable_linear_threshold_33(PyObject *self, PyObject *) {
  OdeWorld *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeWorld)) {
    return nullptr;
  }
  // 1-inline dReal OdeWorld::get_auto_disable_linear_threshold(void) const
  dReal return_value = ((*(const OdeWorld*)local_this).get_auto_disable_linear_threshold)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_auto_disable_linear_threshold_33_comment =
  "C++ Interface:\n"
  "get_auto_disable_linear_threshold(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_auto_disable_linear_threshold_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeWorld::get_auto_disable_angular_threshold(void) const
 */
static PyObject *Dtool_OdeWorld_get_auto_disable_angular_threshold_34(PyObject *self, PyObject *) {
  OdeWorld *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeWorld)) {
    return nullptr;
  }
  // 1-inline dReal OdeWorld::get_auto_disable_angular_threshold(void) const
  dReal return_value = ((*(const OdeWorld*)local_this).get_auto_disable_angular_threshold)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_auto_disable_angular_threshold_34_comment =
  "C++ Interface:\n"
  "get_auto_disable_angular_threshold(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_auto_disable_angular_threshold_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeWorld::get_auto_disable_steps(void) const
 */
static PyObject *Dtool_OdeWorld_get_auto_disable_steps_35(PyObject *self, PyObject *) {
  OdeWorld *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeWorld)) {
    return nullptr;
  }
  // 1-inline int OdeWorld::get_auto_disable_steps(void) const
  int return_value = ((*(const OdeWorld*)local_this).get_auto_disable_steps)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_auto_disable_steps_35_comment =
  "C++ Interface:\n"
  "get_auto_disable_steps(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_auto_disable_steps_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeWorld::get_auto_disable_time(void) const
 */
static PyObject *Dtool_OdeWorld_get_auto_disable_time_36(PyObject *self, PyObject *) {
  OdeWorld *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeWorld)) {
    return nullptr;
  }
  // 1-inline dReal OdeWorld::get_auto_disable_time(void) const
  dReal return_value = ((*(const OdeWorld*)local_this).get_auto_disable_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_auto_disable_time_36_comment =
  "C++ Interface:\n"
  "get_auto_disable_time(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_auto_disable_time_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeWorld::get_auto_disable_flag(void) const
 */
static PyObject *Dtool_OdeWorld_get_auto_disable_flag_37(PyObject *self, PyObject *) {
  OdeWorld *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeWorld)) {
    return nullptr;
  }
  // 1-inline int OdeWorld::get_auto_disable_flag(void) const
  int return_value = ((*(const OdeWorld*)local_this).get_auto_disable_flag)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_auto_disable_flag_37_comment =
  "C++ Interface:\n"
  "get_auto_disable_flag(OdeWorld self)\n";
#else
static const char *Dtool_OdeWorld_get_auto_disable_flag_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeWorld::impulse_to_force(dReal stepsize, LVecBase3f const &impulse)
 * inline LVecBase3f OdeWorld::impulse_to_force(dReal stepsize, dReal ix, dReal iy, dReal iz)
 */
static PyObject *Dtool_OdeWorld_impulse_to_force_38(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.impulse_to_force")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline LVecBase3f OdeWorld::impulse_to_force(dReal stepsize, LVecBase3f const &impulse)
      float param1;
      PyObject *param2;
      static const char *keyword_list[] = {"stepsize", "impulse", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:impulse_to_force", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeWorld.impulse_to_force", "LVecBase3f");
        }
        LVecBase3f *return_value = new LVecBase3f(((*local_this).impulse_to_force)((dReal)param1, *param2_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-inline LVecBase3f OdeWorld::impulse_to_force(dReal stepsize, dReal ix, dReal iy, dReal iz)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"stepsize", "ix", "iy", "iz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:impulse_to_force", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        LVecBase3f *return_value = new LVecBase3f(((*local_this).impulse_to_force)((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "impulse_to_force() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "impulse_to_force(const OdeWorld self, float stepsize, const LVecBase3f impulse)\n"
      "impulse_to_force(const OdeWorld self, float stepsize, float ix, float iy, float iz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_impulse_to_force_38_comment =
  "C++ Interface:\n"
  "impulse_to_force(const OdeWorld self, float stepsize, const LVecBase3f impulse)\n"
  "impulse_to_force(const OdeWorld self, float stepsize, float ix, float iy, float iz)\n";
#else
static const char *Dtool_OdeWorld_impulse_to_force_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::step(dReal stepsize)
 */
static PyObject *Dtool_OdeWorld_step_39(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.step")) {
    return nullptr;
  }
  // 1-inline void OdeWorld::step(dReal stepsize)
  if (PyNumber_Check(arg)) {
    ((*local_this).step)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "step(const OdeWorld self, float stepsize)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_step_39_comment =
  "C++ Interface:\n"
  "step(const OdeWorld self, float stepsize)\n";
#else
static const char *Dtool_OdeWorld_step_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeWorld::quick_step(dReal stepsize)
 */
static PyObject *Dtool_OdeWorld_quick_step_40(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.quick_step")) {
    return nullptr;
  }
  // 1-inline void OdeWorld::quick_step(dReal stepsize)
  if (PyNumber_Check(arg)) {
    ((*local_this).quick_step)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "quick_step(const OdeWorld self, float stepsize)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_quick_step_40_comment =
  "C++ Interface:\n"
  "quick_step(const OdeWorld self, float stepsize)\n";
#else
static const char *Dtool_OdeWorld_quick_step_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeWorld::compare_to(OdeWorld const &other) const
 */
static PyObject *Dtool_OdeWorld_compare_to_41(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeWorld)) {
    return nullptr;
  }
  // 1-inline int OdeWorld::compare_to(OdeWorld const &other) const
  OdeWorld const *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 1, "OdeWorld.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const OdeWorld*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(OdeWorld self, const OdeWorld other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_compare_to_41_comment =
  "C++ Interface:\n"
  "compare_to(OdeWorld self, const OdeWorld other)\n";
#else
static const char *Dtool_OdeWorld_compare_to_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeWorld::init_surface_table(uint8_t num_surfaces)
 */
static PyObject *Dtool_OdeWorld_init_surface_table_42(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.init_surface_table")) {
    return nullptr;
  }
  // 1-void OdeWorld::init_surface_table(uint8_t num_surfaces)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > UCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned byte",
                          param1);
    }
#endif
    ((*local_this).init_surface_table)((uint8_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "init_surface_table(const OdeWorld self, int num_surfaces)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_init_surface_table_42_comment =
  "C++ Interface:\n"
  "init_surface_table(const OdeWorld self, int num_surfaces)\n";
#else
static const char *Dtool_OdeWorld_init_surface_table_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeWorld::add_body_dampening(OdeBody &body, int surface)
 */
static PyObject *Dtool_OdeWorld_add_body_dampening_43(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.add_body_dampening")) {
    return nullptr;
  }
  // 1-void OdeWorld::add_body_dampening(OdeBody &body, int surface)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"body", "surface", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:add_body_dampening", (char **)keyword_list, &param1, &param2)) {
    OdeBody *param1_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeBody, 1, "OdeWorld.add_body_dampening", false, true);
    if (param1_this != nullptr) {
      ((*local_this).add_body_dampening)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_body_dampening(const OdeWorld self, OdeBody body, int surface)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_add_body_dampening_43_comment =
  "C++ Interface:\n"
  "add_body_dampening(const OdeWorld self, OdeBody body, int surface)\n"
  "\n"
  "// void assign_surface_body(OdeBody& body, int surface);";
#else
static const char *Dtool_OdeWorld_add_body_dampening_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeWorld::set_surface_entry(uint8_t pos1, uint8_t pos2, dReal mu, dReal bounce, dReal bounce_vel, dReal soft_erp, dReal soft_cfm, dReal slip, dReal dampen)
 */
static PyObject *Dtool_OdeWorld_set_surface_entry_44(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.set_surface_entry")) {
    return nullptr;
  }
  // 1-void OdeWorld::set_surface_entry(uint8_t pos1, uint8_t pos2, dReal mu, dReal bounce, dReal bounce_vel, dReal soft_erp, dReal soft_cfm, dReal slip, dReal dampen)
  long param1;
  long param2;
  float param3;
  float param4;
  float param5;
  float param6;
  float param7;
  float param8;
  float param9;
  static const char *keyword_list[] = {"pos1", "pos2", "mu", "bounce", "bounce_vel", "soft_erp", "soft_cfm", "slip", "dampen", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "llfffffff:set_surface_entry", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9)) {
#ifndef NDEBUG
    if (param1 < 0 || param1 > UCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned byte",
                          param1);
    }
#endif
#ifndef NDEBUG
    if (param2 < 0 || param2 > UCHAR_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned byte",
                          param2);
    }
#endif
    ((*local_this).set_surface_entry)((uint8_t)param1, (uint8_t)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6, (dReal)param7, (dReal)param8, (dReal)param9);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_surface_entry(const OdeWorld self, int pos1, int pos2, float mu, float bounce, float bounce_vel, float soft_erp, float soft_cfm, float slip, float dampen)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_set_surface_entry_44_comment =
  "C++ Interface:\n"
  "set_surface_entry(const OdeWorld self, int pos1, int pos2, float mu, float bounce, float bounce_vel, float soft_erp, float soft_cfm, float slip, float dampen)\n";
#else
static const char *Dtool_OdeWorld_set_surface_entry_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * float OdeWorld::apply_dampening(float dt, OdeBody &body)
 */
static PyObject *Dtool_OdeWorld_apply_dampening_45(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeWorld, (void **)&local_this, "OdeWorld.apply_dampening")) {
    return nullptr;
  }
  // 1-float OdeWorld::apply_dampening(float dt, OdeBody &body)
  float param1;
  PyObject *param2;
  static const char *keyword_list[] = {"dt", "body", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:apply_dampening", (char **)keyword_list, &param1, &param2)) {
    OdeBody *param2_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_OdeBody, 2, "OdeWorld.apply_dampening", false, true);
    if (param2_this != nullptr) {
      float return_value = ((*local_this).apply_dampening)((float)param1, *param2_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_dampening(const OdeWorld self, float dt, OdeBody body)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_apply_dampening_45_comment =
  "C++ Interface:\n"
  "apply_dampening(const OdeWorld self, float dt, OdeBody body)\n";
#else
static const char *Dtool_OdeWorld_apply_dampening_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeWorld::get_class_type(void)
 */
static PyObject *Dtool_OdeWorld_get_class_type_47(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeWorld::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeWorld::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeWorld_get_class_type_47_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeWorld_get_class_type_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeWorld::OdeWorld(void)
 * OdeWorld::OdeWorld(OdeWorld const &copy)
 */
static int Dtool_Init_OdeWorld(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-OdeWorld::OdeWorld(void)
      OdeWorld *return_value = new OdeWorld();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeWorld, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-OdeWorld::OdeWorld(OdeWorld const &copy)
        OdeWorld const *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeWorld.OdeWorld", true, true);
        if (arg_this != nullptr) {
          OdeWorld *return_value = new OdeWorld(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeWorld, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeWorld() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeWorld()\n"
      "OdeWorld(const OdeWorld copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeWorld(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeWorld) {
    printf("OdeWorld ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeWorld *local_this = (OdeWorld *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeWorld) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeWorld(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeWorld) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeWorld*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeJointGroup
 */
/**
 * Python function wrapper for:
 * void OdeJointGroup::destroy(void)
 */
static PyObject *Dtool_OdeJointGroup_destroy_50(PyObject *self, PyObject *) {
  OdeJointGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJointGroup, (void **)&local_this, "OdeJointGroup.destroy")) {
    return nullptr;
  }
  // 1-void OdeJointGroup::destroy(void)
  ((*local_this).destroy)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeJointGroup_destroy_50_comment =
  "C++ Interface:\n"
  "destroy(const OdeJointGroup self)\n";
#else
static const char *Dtool_OdeJointGroup_destroy_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dJointGroupID OdeJointGroup::get_id(void) const
 */
static PyObject *Dtool_OdeJointGroup_get_id_51(PyObject *self, PyObject *) {
  OdeJointGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJointGroup)) {
    return nullptr;
  }
  // 1-inline dJointGroupID OdeJointGroup::get_id(void) const
  dJointGroupID return_value = ((*(const OdeJointGroup*)local_this).get_id)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_dxJointGroup, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeJointGroup_get_id_51_comment =
  "C++ Interface:\n"
  "get_id(OdeJointGroup self)\n";
#else
static const char *Dtool_OdeJointGroup_get_id_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeJointGroup::empty(void) const
 */
static PyObject *Dtool_OdeJointGroup_empty_52(PyObject *self, PyObject *) {
  OdeJointGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJointGroup)) {
    return nullptr;
  }
  // 1-inline void OdeJointGroup::empty(void) const
  ((*(const OdeJointGroup*)local_this).empty)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeJointGroup_empty_52_comment =
  "C++ Interface:\n"
  "empty(OdeJointGroup self)\n";
#else
static const char *Dtool_OdeJointGroup_empty_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeJointGroup::compare_to(OdeJointGroup const &other) const
 */
static PyObject *Dtool_OdeJointGroup_compare_to_53(PyObject *self, PyObject *arg) {
  OdeJointGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJointGroup)) {
    return nullptr;
  }
  // 1-inline int OdeJointGroup::compare_to(OdeJointGroup const &other) const
  OdeJointGroup const *arg_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointGroup, 1, "OdeJointGroup.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const OdeJointGroup*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(OdeJointGroup self, const OdeJointGroup other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeJointGroup_compare_to_53_comment =
  "C++ Interface:\n"
  "compare_to(OdeJointGroup self, const OdeJointGroup other)\n";
#else
static const char *Dtool_OdeJointGroup_compare_to_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeJointGroup::get_class_type(void)
 */
static PyObject *Dtool_OdeJointGroup_get_class_type_54(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeJointGroup::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeJointGroup::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeJointGroup_get_class_type_54_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeJointGroup_get_class_type_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeJointGroup::OdeJointGroup(void)
 */
static int Dtool_Init_OdeJointGroup(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("OdeJointGroup() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "OdeJointGroup() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-OdeJointGroup::OdeJointGroup(void)
  OdeJointGroup *return_value = new OdeJointGroup();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeJointGroup, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeJointGroup()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeJointGroup(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeJointGroup) {
    printf("OdeJointGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeJointGroup *local_this = (OdeJointGroup *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeJointGroup) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeJointGroup(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeJointGroup) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeJointGroup*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeJointFeedback
 */
/**
 * Python function wrapper for:
 * inline LVector3f const OdeJointFeedback::get_force1(void) const
 */
static PyObject *Dtool_OdeJointFeedback_get_force1_57(PyObject *self, PyObject *) {
  OdeJointFeedback *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJointFeedback)) {
    return nullptr;
  }
  // 1-inline LVector3f const OdeJointFeedback::get_force1(void) const
  LVector3f const *return_value = new LVector3f const(((*(const OdeJointFeedback*)local_this).get_force1)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, true);
}

#ifndef NDEBUG
static const char *Dtool_OdeJointFeedback_get_force1_57_comment =
  "C++ Interface:\n"
  "get_force1(OdeJointFeedback self)\n";
#else
static const char *Dtool_OdeJointFeedback_get_force1_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3f const OdeJointFeedback::get_force2(void) const
 */
static PyObject *Dtool_OdeJointFeedback_get_force2_58(PyObject *self, PyObject *) {
  OdeJointFeedback *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJointFeedback)) {
    return nullptr;
  }
  // 1-inline LVector3f const OdeJointFeedback::get_force2(void) const
  LVector3f const *return_value = new LVector3f const(((*(const OdeJointFeedback*)local_this).get_force2)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, true);
}

#ifndef NDEBUG
static const char *Dtool_OdeJointFeedback_get_force2_58_comment =
  "C++ Interface:\n"
  "get_force2(OdeJointFeedback self)\n";
#else
static const char *Dtool_OdeJointFeedback_get_force2_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3f const OdeJointFeedback::get_torque1(void) const
 */
static PyObject *Dtool_OdeJointFeedback_get_torque1_59(PyObject *self, PyObject *) {
  OdeJointFeedback *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJointFeedback)) {
    return nullptr;
  }
  // 1-inline LVector3f const OdeJointFeedback::get_torque1(void) const
  LVector3f const *return_value = new LVector3f const(((*(const OdeJointFeedback*)local_this).get_torque1)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, true);
}

#ifndef NDEBUG
static const char *Dtool_OdeJointFeedback_get_torque1_59_comment =
  "C++ Interface:\n"
  "get_torque1(OdeJointFeedback self)\n";
#else
static const char *Dtool_OdeJointFeedback_get_torque1_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3f const OdeJointFeedback::get_torque2(void) const
 */
static PyObject *Dtool_OdeJointFeedback_get_torque2_60(PyObject *self, PyObject *) {
  OdeJointFeedback *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJointFeedback)) {
    return nullptr;
  }
  // 1-inline LVector3f const OdeJointFeedback::get_torque2(void) const
  LVector3f const *return_value = new LVector3f const(((*(const OdeJointFeedback*)local_this).get_torque2)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, true);
}

#ifndef NDEBUG
static const char *Dtool_OdeJointFeedback_get_torque2_60_comment =
  "C++ Interface:\n"
  "get_torque2(OdeJointFeedback self)\n";
#else
static const char *Dtool_OdeJointFeedback_get_torque2_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OdeJointFeedback::OdeJointFeedback(void) = default
 * inline OdeJointFeedback::OdeJointFeedback(OdeJointFeedback const &) = default
 */
static int Dtool_Init_OdeJointFeedback(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("OdeJointFeedback() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline OdeJointFeedback::OdeJointFeedback(void) = default
      OdeJointFeedback *return_value = new OdeJointFeedback();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeJointFeedback, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline OdeJointFeedback::OdeJointFeedback(OdeJointFeedback const &) = default
      OdeJointFeedback const *arg_this = (OdeJointFeedback *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointFeedback, 0, "OdeJointFeedback.OdeJointFeedback", true, true);
      if (arg_this != nullptr) {
        OdeJointFeedback *return_value = new OdeJointFeedback(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeJointFeedback, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeJointFeedback() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeJointFeedback()\n"
      "OdeJointFeedback(const OdeJointFeedback param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeJointFeedback(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeJointFeedback) {
    printf("OdeJointFeedback ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeJointFeedback *local_this = (OdeJointFeedback *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeJointFeedback) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeJointFeedback(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeJointFeedback) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeJoint
 */
/**
 * Python function wrapper for:
 * void OdeJoint::destroy(void)
 */
static PyObject *Dtool_OdeJoint_destroy_65(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJoint, (void **)&local_this, "OdeJoint.destroy")) {
    return nullptr;
  }
  // 1-void OdeJoint::destroy(void)
  ((*local_this).destroy)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_destroy_65_comment =
  "C++ Interface:\n"
  "destroy(const OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_destroy_65_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool OdeJoint::is_empty(void) const
 */
static PyObject *Dtool_OdeJoint_is_empty_66(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-inline bool OdeJoint::is_empty(void) const
  bool return_value = ((*(const OdeJoint*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_is_empty_66_comment =
  "C++ Interface:\n"
  "is_empty(OdeJoint self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ID is 0, meaning the OdeJoint does not point to a valid\n"
  " * joint.  It is an error to call a method on an empty joint.  Note that an\n"
  " * empty OdeJoint also evaluates to False.\n"
  " */";
#else
static const char *Dtool_OdeJoint_is_empty_66_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dJointID OdeJoint::get_id(void) const
 */
static PyObject *Dtool_OdeJoint_get_id_67(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-inline dJointID OdeJoint::get_id(void) const
  dJointID return_value = ((*(const OdeJoint*)local_this).get_id)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_dxJoint, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_get_id_67_comment =
  "C++ Interface:\n"
  "get_id(OdeJoint self)\n"
  "\n"
  "/**\n"
  " * Returns the underlying dJointID.\n"
  " */";
#else
static const char *Dtool_OdeJoint_get_id_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeJoint::get_joint_type(void) const
 */
static PyObject *Dtool_OdeJoint_get_joint_type_68(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-inline int OdeJoint::get_joint_type(void) const
  int return_value = ((*(const OdeJoint*)local_this).get_joint_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_get_joint_type_68_comment =
  "C++ Interface:\n"
  "get_joint_type(OdeJoint self)\n"
  "\n"
  "/* INLINE void *get_data(); */";
#else
static const char *Dtool_OdeJoint_get_joint_type_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeBody OdeJoint::get_body(int index) const
 */
static PyObject *Dtool_OdeJoint_get_body_69(PyObject *self, PyObject *arg) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-OdeBody OdeJoint::get_body(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    OdeBody *return_value = new OdeBody(((*(const OdeJoint*)local_this).get_body)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeBody, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_body(OdeJoint self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_get_body_69_comment =
  "C++ Interface:\n"
  "get_body(OdeJoint self, int index)\n";
#else
static const char *Dtool_OdeJoint_get_body_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeJoint::set_feedback(OdeJointFeedback *)
 * inline void OdeJoint::set_feedback(bool flag = true)
 */
static PyObject *Dtool_OdeJoint_set_feedback_70(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJoint, (void **)&local_this, "OdeJoint.set_feedback")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void OdeJoint::set_feedback(bool flag)
      ((*local_this).set_feedback)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      {
        // -2 inline void OdeJoint::set_feedback(OdeJointFeedback *)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds)) {
          OdeJointFeedback *param1_this = (OdeJointFeedback *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointFeedback, 1, "OdeJoint.set_feedback", false, false);
          if (param1_this != nullptr) {
            ((*local_this).set_feedback)(param1_this);
            return Dtool_Return_None();
          }
        }
      }

      {
        // -2 inline void OdeJoint::set_feedback(bool flag)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "flag")) {
          ((*local_this).set_feedback)((PyObject_IsTrue(param1) != 0));
          return Dtool_Return_None();
        }
      }

      // No coercion possible: inline void OdeJoint::set_feedback(OdeJointFeedback *)
      // No coercion possible: inline void OdeJoint::set_feedback(bool flag)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_feedback() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_feedback(const OdeJoint self)\n"
      "set_feedback(const OdeJoint self, OdeJointFeedback param0)\n"
      "set_feedback(const OdeJoint self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_set_feedback_70_comment =
  "C++ Interface:\n"
  "set_feedback(const OdeJoint self)\n"
  "set_feedback(const OdeJoint self, OdeJointFeedback param0)\n"
  "set_feedback(const OdeJoint self, bool flag)\n";
#else
static const char *Dtool_OdeJoint_set_feedback_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OdeJointFeedback *OdeJoint::get_feedback(void)
 */
static PyObject *Dtool_OdeJoint_get_feedback_71(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJoint, (void **)&local_this, "OdeJoint.get_feedback")) {
    return nullptr;
  }
  // 1-inline OdeJointFeedback *OdeJoint::get_feedback(void)
  OdeJointFeedback *return_value = ((*local_this).get_feedback)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OdeJointFeedback, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_get_feedback_71_comment =
  "C++ Interface:\n"
  "get_feedback(const OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_get_feedback_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeJoint::attach(PyObject *body1, PyObject *body2)
 */
static PyObject *Dtool_OdeJoint_attach_72(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJoint, (void **)&local_this, "OdeJoint.attach")) {
    return nullptr;
  }
  // 1-void OdeJoint::attach(PyObject *body1, PyObject *body2)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"body1", "body2", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:attach", (char **)keyword_list, &param1, &param2)) {
    invoke_extension(local_this).attach(param1, param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach(const OdeJoint self, object body1, object body2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_attach_72_comment =
  "C++ Interface:\n"
  "attach(const OdeJoint self, object body1, object body2)\n";
#else
static const char *Dtool_OdeJoint_attach_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeJoint::attach_bodies(OdeBody const &body1, OdeBody const &body2)
 */
static PyObject *Dtool_OdeJoint_attach_bodies_73(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJoint, (void **)&local_this, "OdeJoint.attach_bodies")) {
    return nullptr;
  }
  // 1-void OdeJoint::attach_bodies(OdeBody const &body1, OdeBody const &body2)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"body1", "body2", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:attach_bodies", (char **)keyword_list, &param1, &param2)) {
    OdeBody const *param1_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeBody, 1, "OdeJoint.attach_bodies", true, true);
    OdeBody const *param2_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_OdeBody, 2, "OdeJoint.attach_bodies", true, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*local_this).attach_bodies)(*param1_this, *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_bodies(const OdeJoint self, const OdeBody body1, const OdeBody body2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_attach_bodies_73_comment =
  "C++ Interface:\n"
  "attach_bodies(const OdeJoint self, const OdeBody body1, const OdeBody body2)\n"
  "\n"
  "/**\n"
  " * Attaches two OdeBody objects to this joint.  Order is important.  Consider\n"
  " * using the OdeJoint::attach extension function if you're using the Python\n"
  " * interface.\n"
  " */";
#else
static const char *Dtool_OdeJoint_attach_bodies_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeJoint::attach_body(OdeBody const &body, int index)
 */
static PyObject *Dtool_OdeJoint_attach_body_74(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJoint, (void **)&local_this, "OdeJoint.attach_body")) {
    return nullptr;
  }
  // 1-void OdeJoint::attach_body(OdeBody const &body, int index)
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"body", "index", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:attach_body", (char **)keyword_list, &param1, &param2)) {
    OdeBody const *param1_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeBody, 1, "OdeJoint.attach_body", true, true);
    if (param1_this != nullptr) {
      ((*local_this).attach_body)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_body(const OdeJoint self, const OdeBody body, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_attach_body_74_comment =
  "C++ Interface:\n"
  "attach_body(const OdeJoint self, const OdeBody body, int index)\n"
  "\n"
  "/**\n"
  " * Attaches a single OdeBody to this joint at the specified index (0 or 1).\n"
  " * The other index will be set to the environment (null). Consider using the\n"
  " * OdeJoint::attach extension function if you're using the Python interface.\n"
  " */";
#else
static const char *Dtool_OdeJoint_attach_body_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeJoint::detach(void)
 */
static PyObject *Dtool_OdeJoint_detach_75(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJoint, (void **)&local_this, "OdeJoint.detach")) {
    return nullptr;
  }
  // 1-void OdeJoint::detach(void)
  ((*local_this).detach)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_detach_75_comment =
  "C++ Interface:\n"
  "detach(const OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_detach_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void OdeJoint::write(std::ostream &out = ::std::cout, unsigned int indent = 0) const
 */
static PyObject *Dtool_OdeJoint_write_76(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-virtual void OdeJoint::write(std::ostream &out = ::std::cout, unsigned int indent = 0) const
  PyObject *param1 = nullptr;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|Ok:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this;
    if (param1 == nullptr) {
      param1_this = &(std::cout);
    } else {
      param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "OdeJoint.write", false, true);
    }
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*(const OdeJoint*)local_this).write)(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(OdeJoint self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_write_76_comment =
  "C++ Interface:\n"
  "write(OdeJoint self, ostream out, int indent)\n";
#else
static const char *Dtool_OdeJoint_write_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeJoint::compare_to(OdeJoint const &other) const
 */
static PyObject *Dtool_OdeJoint_compare_to_77(PyObject *self, PyObject *arg) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-inline int OdeJoint::compare_to(OdeJoint const &other) const
  OdeJoint const *arg_this = (OdeJoint *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJoint, 1, "OdeJoint.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const OdeJoint*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(OdeJoint self, const OdeJoint other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_compare_to_77_comment =
  "C++ Interface:\n"
  "compare_to(OdeJoint self, const OdeJoint other)\n";
#else
static const char *Dtool_OdeJoint_compare_to_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *OdeJoint::convert(void) const
 */
static PyObject *Dtool_OdeJoint_convert_80(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-PyObject *OdeJoint::convert(void) const
  PyObject *return_value = invoke_extension((const OdeJoint*)local_this).convert();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_80_comment =
  "C++ Interface:\n"
  "convert(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeBallJoint OdeJoint::convert_to_ball(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_ball_81(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-OdeBallJoint OdeJoint::convert_to_ball(void) const
  OdeBallJoint *return_value = new OdeBallJoint(((*(const OdeJoint*)local_this).convert_to_ball)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeBallJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_ball_81_comment =
  "C++ Interface:\n"
  "convert_to_ball(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_ball_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeHingeJoint OdeJoint::convert_to_hinge(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_hinge_82(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-OdeHingeJoint OdeJoint::convert_to_hinge(void) const
  OdeHingeJoint *return_value = new OdeHingeJoint(((*(const OdeJoint*)local_this).convert_to_hinge)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeHingeJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_hinge_82_comment =
  "C++ Interface:\n"
  "convert_to_hinge(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_hinge_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeSliderJoint OdeJoint::convert_to_slider(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_slider_83(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-OdeSliderJoint OdeJoint::convert_to_slider(void) const
  OdeSliderJoint *return_value = new OdeSliderJoint(((*(const OdeJoint*)local_this).convert_to_slider)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeSliderJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_slider_83_comment =
  "C++ Interface:\n"
  "convert_to_slider(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_slider_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeContactJoint OdeJoint::convert_to_contact(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_contact_84(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-OdeContactJoint OdeJoint::convert_to_contact(void) const
  OdeContactJoint *return_value = new OdeContactJoint(((*(const OdeJoint*)local_this).convert_to_contact)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeContactJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_contact_84_comment =
  "C++ Interface:\n"
  "convert_to_contact(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_contact_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeUniversalJoint OdeJoint::convert_to_universal(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_universal_85(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-OdeUniversalJoint OdeJoint::convert_to_universal(void) const
  OdeUniversalJoint *return_value = new OdeUniversalJoint(((*(const OdeJoint*)local_this).convert_to_universal)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeUniversalJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_universal_85_comment =
  "C++ Interface:\n"
  "convert_to_universal(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_universal_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeHinge2Joint OdeJoint::convert_to_hinge2(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_hinge2_86(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-OdeHinge2Joint OdeJoint::convert_to_hinge2(void) const
  OdeHinge2Joint *return_value = new OdeHinge2Joint(((*(const OdeJoint*)local_this).convert_to_hinge2)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeHinge2Joint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_hinge2_86_comment =
  "C++ Interface:\n"
  "convert_to_hinge2(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_hinge2_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeFixedJoint OdeJoint::convert_to_fixed(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_fixed_87(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-OdeFixedJoint OdeJoint::convert_to_fixed(void) const
  OdeFixedJoint *return_value = new OdeFixedJoint(((*(const OdeJoint*)local_this).convert_to_fixed)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeFixedJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_fixed_87_comment =
  "C++ Interface:\n"
  "convert_to_fixed(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_fixed_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeNullJoint OdeJoint::convert_to_null(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_null_88(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-OdeNullJoint OdeJoint::convert_to_null(void) const
  OdeNullJoint *return_value = new OdeNullJoint(((*(const OdeJoint*)local_this).convert_to_null)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeNullJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_null_88_comment =
  "C++ Interface:\n"
  "convert_to_null(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_null_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeAMotorJoint OdeJoint::convert_to_a_motor(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_a_motor_89(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-OdeAMotorJoint OdeJoint::convert_to_a_motor(void) const
  OdeAMotorJoint *return_value = new OdeAMotorJoint(((*(const OdeJoint*)local_this).convert_to_a_motor)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeAMotorJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_a_motor_89_comment =
  "C++ Interface:\n"
  "convert_to_a_motor(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_a_motor_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeLMotorJoint OdeJoint::convert_to_l_motor(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_l_motor_90(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-OdeLMotorJoint OdeJoint::convert_to_l_motor(void) const
  OdeLMotorJoint *return_value = new OdeLMotorJoint(((*(const OdeJoint*)local_this).convert_to_l_motor)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeLMotorJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_l_motor_90_comment =
  "C++ Interface:\n"
  "convert_to_l_motor(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_l_motor_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdePlane2dJoint OdeJoint::convert_to_plane2d(void) const
 */
static PyObject *Dtool_OdeJoint_convert_to_plane2d_91(PyObject *self, PyObject *) {
  OdeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJoint)) {
    return nullptr;
  }
  // 1-OdePlane2dJoint OdeJoint::convert_to_plane2d(void) const
  OdePlane2dJoint *return_value = new OdePlane2dJoint(((*(const OdeJoint*)local_this).convert_to_plane2d)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdePlane2dJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_convert_to_plane2d_91_comment =
  "C++ Interface:\n"
  "convert_to_plane2d(OdeJoint self)\n";
#else
static const char *Dtool_OdeJoint_convert_to_plane2d_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeJoint_get_class_type_92(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeJoint::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeJoint_get_class_type_92_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeJoint_get_class_type_92_comment = nullptr;
#endif

static int Dtool_Init_OdeJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_OdeJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeJoint) {
    printf("OdeJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeJoint *local_this = (OdeJoint *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeJoint*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeAMotorJoint
 */
/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_num_axes(int num)
 */
static PyObject *Dtool_OdeAMotorJoint_set_num_axes_95(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_num_axes")) {
    return nullptr;
  }
  // 1-inline void OdeAMotorJoint::set_num_axes(int num)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_num_axes)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_axes(const OdeAMotorJoint self, int num)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_num_axes_95_comment =
  "C++ Interface:\n"
  "set_num_axes(const OdeAMotorJoint self, int num)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_num_axes_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_axis(int anum, int rel, LVecBase3f const &axis)
 * inline void OdeAMotorJoint::set_axis(int anum, int rel, dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeAMotorJoint_set_axis_96(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_axis")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-inline void OdeAMotorJoint::set_axis(int anum, int rel, LVecBase3f const &axis)
      int param1;
      int param2;
      PyObject *param3;
      static const char *keyword_list[] = {"anum", "rel", "axis", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_axis", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase3f param3_local;
        LVecBase3f const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "OdeAMotorJoint.set_axis", "LVecBase3f");
        }
        ((*local_this).set_axis)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 5:
    {
      // 1-inline void OdeAMotorJoint::set_axis(int anum, int rel, dReal x, dReal y, dReal z)
      int param1;
      int param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"anum", "rel", "x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iifff:set_axis", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        ((*local_this).set_axis)((int)param1, (int)param2, (dReal)param3, (dReal)param4, (dReal)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis() takes 4 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis(const OdeAMotorJoint self, int anum, int rel, const LVecBase3f axis)\n"
      "set_axis(const OdeAMotorJoint self, int anum, int rel, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_axis_96_comment =
  "C++ Interface:\n"
  "set_axis(const OdeAMotorJoint self, int anum, int rel, const LVecBase3f axis)\n"
  "set_axis(const OdeAMotorJoint self, int anum, int rel, float x, float y, float z)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_axis_96_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_angle(int anum, dReal angle)
 */
static PyObject *Dtool_OdeAMotorJoint_set_angle_97(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_angle")) {
    return nullptr;
  }
  // 1-inline void OdeAMotorJoint::set_angle(int anum, dReal angle)
  int param1;
  float param2;
  static const char *keyword_list[] = {"anum", "angle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_angle", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_angle)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_angle(const OdeAMotorJoint self, int anum, float angle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_angle_97_comment =
  "C++ Interface:\n"
  "set_angle(const OdeAMotorJoint self, int anum, float angle)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_angle_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_mode(int mode)
 */
static PyObject *Dtool_OdeAMotorJoint_set_mode_98(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_mode")) {
    return nullptr;
  }
  // 1-inline void OdeAMotorJoint::set_mode(int mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_mode)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mode(const OdeAMotorJoint self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_mode_98_comment =
  "C++ Interface:\n"
  "set_mode(const OdeAMotorJoint self, int mode)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_mode_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::add_torques(dReal torque1, dReal torque2, dReal torque3)
 */
static PyObject *Dtool_OdeAMotorJoint_add_torques_99(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.add_torques")) {
    return nullptr;
  }
  // 1-inline void OdeAMotorJoint::add_torques(dReal torque1, dReal torque2, dReal torque3)
  float param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"torque1", "torque2", "torque3", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_torques", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).add_torques)((dReal)param1, (dReal)param2, (dReal)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_torques(const OdeAMotorJoint self, float torque1, float torque2, float torque3)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_add_torques_99_comment =
  "C++ Interface:\n"
  "add_torques(const OdeAMotorJoint self, float torque1, float torque2, float torque3)\n";
#else
static const char *Dtool_OdeAMotorJoint_add_torques_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeAMotorJoint::get_num_axes(void) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_num_axes_100(PyObject *self, PyObject *) {
  OdeAMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeAMotorJoint)) {
    return nullptr;
  }
  // 1-inline int OdeAMotorJoint::get_num_axes(void) const
  int return_value = ((*(const OdeAMotorJoint*)local_this).get_num_axes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_num_axes_100_comment =
  "C++ Interface:\n"
  "get_num_axes(OdeAMotorJoint self)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_num_axes_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeAMotorJoint::get_axis(int anum) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_axis_101(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeAMotorJoint)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeAMotorJoint::get_axis(int anum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3f *return_value = new LVecBase3f(((*(const OdeAMotorJoint*)local_this).get_axis)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_axis(OdeAMotorJoint self, int anum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_axis_101_comment =
  "C++ Interface:\n"
  "get_axis(OdeAMotorJoint self, int anum)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_axis_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeAMotorJoint::get_axis_rel(int anum) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_axis_rel_103(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeAMotorJoint)) {
    return nullptr;
  }
  // 1-inline int OdeAMotorJoint::get_axis_rel(int anum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const OdeAMotorJoint*)local_this).get_axis_rel)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_axis_rel(OdeAMotorJoint self, int anum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_axis_rel_103_comment =
  "C++ Interface:\n"
  "get_axis_rel(OdeAMotorJoint self, int anum)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_axis_rel_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_angle(int anum) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_angle_104(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeAMotorJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeAMotorJoint::get_angle(int anum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeAMotorJoint*)local_this).get_angle)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_angle(OdeAMotorJoint self, int anum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_angle_104_comment =
  "C++ Interface:\n"
  "get_angle(OdeAMotorJoint self, int anum)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_angle_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_angle_rate(int anum) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_angle_rate_105(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeAMotorJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeAMotorJoint::get_angle_rate(int anum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeAMotorJoint*)local_this).get_angle_rate)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_angle_rate(OdeAMotorJoint self, int anum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_angle_rate_105_comment =
  "C++ Interface:\n"
  "get_angle_rate(OdeAMotorJoint self, int anum)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_angle_rate_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeAMotorJoint::get_mode(void) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_mode_106(PyObject *self, PyObject *) {
  OdeAMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeAMotorJoint)) {
    return nullptr;
  }
  // 1-inline int OdeAMotorJoint::get_mode(void) const
  int return_value = ((*(const OdeAMotorJoint*)local_this).get_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_mode_106_comment =
  "C++ Interface:\n"
  "get_mode(OdeAMotorJoint self)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_mode_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_lo_stop(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_lo_stop_107(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_lo_stop")) {
    return nullptr;
  }
  // 1-inline void OdeAMotorJoint::set_param_lo_stop(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_lo_stop", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_lo_stop)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_lo_stop(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_lo_stop_107_comment =
  "C++ Interface:\n"
  "set_param_lo_stop(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_lo_stop_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_hi_stop(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_hi_stop_108(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_hi_stop")) {
    return nullptr;
  }
  // 1-inline void OdeAMotorJoint::set_param_hi_stop(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_hi_stop", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_hi_stop)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_hi_stop(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_hi_stop_108_comment =
  "C++ Interface:\n"
  "set_param_hi_stop(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_hi_stop_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_vel(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_vel_109(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_vel")) {
    return nullptr;
  }
  // 1-inline void OdeAMotorJoint::set_param_vel(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_vel", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_vel)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_vel(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_vel_109_comment =
  "C++ Interface:\n"
  "set_param_vel(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_vel_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_f_max(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_f_max_110(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_f_max")) {
    return nullptr;
  }
  // 1-inline void OdeAMotorJoint::set_param_f_max(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_f_max", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_f_max)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_f_max(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_f_max_110_comment =
  "C++ Interface:\n"
  "set_param_f_max(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_f_max_110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_fudge_factor(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_fudge_factor_111(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_fudge_factor")) {
    return nullptr;
  }
  // 1-inline void OdeAMotorJoint::set_param_fudge_factor(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_fudge_factor", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_fudge_factor)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_fudge_factor(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_fudge_factor_111_comment =
  "C++ Interface:\n"
  "set_param_fudge_factor(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_fudge_factor_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_bounce(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_bounce_112(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_bounce")) {
    return nullptr;
  }
  // 1-inline void OdeAMotorJoint::set_param_bounce(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_bounce", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_bounce)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_bounce(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_bounce_112_comment =
  "C++ Interface:\n"
  "set_param_bounce(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_bounce_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_CFM(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_CFM_113(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_CFM")) {
    return nullptr;
  }
  // 1-inline void OdeAMotorJoint::set_param_CFM(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_CFM", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_CFM)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_CFM(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_CFM_113_comment =
  "C++ Interface:\n"
  "set_param_CFM(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_CFM_113_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_stop_ERP(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_stop_ERP_114(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_stop_ERP")) {
    return nullptr;
  }
  // 1-inline void OdeAMotorJoint::set_param_stop_ERP(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_stop_ERP", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_stop_ERP)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_ERP(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_stop_ERP_114_comment =
  "C++ Interface:\n"
  "set_param_stop_ERP(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_stop_ERP_114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeAMotorJoint::set_param_stop_CFM(int axis, dReal val)
 */
static PyObject *Dtool_OdeAMotorJoint_set_param_stop_CFM_115(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeAMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeAMotorJoint, (void **)&local_this, "OdeAMotorJoint.set_param_stop_CFM")) {
    return nullptr;
  }
  // 1-inline void OdeAMotorJoint::set_param_stop_CFM(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_stop_CFM", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_stop_CFM)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_CFM(const OdeAMotorJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_set_param_stop_CFM_115_comment =
  "C++ Interface:\n"
  "set_param_stop_CFM(const OdeAMotorJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeAMotorJoint_set_param_stop_CFM_115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_lo_stop(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_lo_stop_116(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeAMotorJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_lo_stop(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeAMotorJoint*)local_this).get_param_lo_stop)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_lo_stop(OdeAMotorJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_lo_stop_116_comment =
  "C++ Interface:\n"
  "get_param_lo_stop(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_lo_stop_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_hi_stop(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_hi_stop_117(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeAMotorJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_hi_stop(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeAMotorJoint*)local_this).get_param_hi_stop)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_hi_stop(OdeAMotorJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_hi_stop_117_comment =
  "C++ Interface:\n"
  "get_param_hi_stop(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_hi_stop_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_vel(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_vel_118(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeAMotorJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_vel(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeAMotorJoint*)local_this).get_param_vel)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_vel(OdeAMotorJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_vel_118_comment =
  "C++ Interface:\n"
  "get_param_vel(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_vel_118_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_f_max(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_f_max_119(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeAMotorJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_f_max(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeAMotorJoint*)local_this).get_param_f_max)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_f_max(OdeAMotorJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_f_max_119_comment =
  "C++ Interface:\n"
  "get_param_f_max(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_f_max_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_fudge_factor(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_fudge_factor_120(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeAMotorJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_fudge_factor(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeAMotorJoint*)local_this).get_param_fudge_factor)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_fudge_factor(OdeAMotorJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_fudge_factor_120_comment =
  "C++ Interface:\n"
  "get_param_fudge_factor(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_fudge_factor_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_bounce(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_bounce_121(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeAMotorJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_bounce(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeAMotorJoint*)local_this).get_param_bounce)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_bounce(OdeAMotorJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_bounce_121_comment =
  "C++ Interface:\n"
  "get_param_bounce(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_bounce_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_CFM(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_CFM_122(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeAMotorJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_CFM(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeAMotorJoint*)local_this).get_param_CFM)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_CFM(OdeAMotorJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_CFM_122_comment =
  "C++ Interface:\n"
  "get_param_CFM(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_CFM_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_stop_ERP(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_stop_ERP_123(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeAMotorJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_stop_ERP(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeAMotorJoint*)local_this).get_param_stop_ERP)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_stop_ERP(OdeAMotorJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_stop_ERP_123_comment =
  "C++ Interface:\n"
  "get_param_stop_ERP(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_stop_ERP_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeAMotorJoint::get_param_stop_CFM(int axis) const
 */
static PyObject *Dtool_OdeAMotorJoint_get_param_stop_CFM_124(PyObject *self, PyObject *arg) {
  OdeAMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeAMotorJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeAMotorJoint::get_param_stop_CFM(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeAMotorJoint*)local_this).get_param_stop_CFM)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_stop_CFM(OdeAMotorJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_param_stop_CFM_124_comment =
  "C++ Interface:\n"
  "get_param_stop_CFM(OdeAMotorJoint self, int axis)\n";
#else
static const char *Dtool_OdeAMotorJoint_get_param_stop_CFM_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeAMotorJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeAMotorJoint_get_class_type_125(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeAMotorJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeAMotorJoint::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeAMotorJoint_get_class_type_125_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeAMotorJoint_get_class_type_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeAMotorJoint::OdeAMotorJoint(OdeWorld &world)
 * OdeAMotorJoint::OdeAMotorJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeAMotorJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "world")) {
        // 1-OdeAMotorJoint::OdeAMotorJoint(OdeWorld &world)
        OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeAMotorJoint.OdeAMotorJoint", false, true);
        if (arg_this != nullptr) {
          OdeAMotorJoint *return_value = new OdeAMotorJoint(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeAMotorJoint, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-OdeAMotorJoint::OdeAMotorJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeAMotorJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeAMotorJoint.OdeAMotorJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeAMotorJoint.OdeAMotorJoint", false, true);
        if (param0_this != nullptr && param1_this != nullptr) {
          OdeAMotorJoint *return_value = new OdeAMotorJoint(*param0_this, *param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeAMotorJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeAMotorJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeAMotorJoint(OdeWorld world)\n"
      "OdeAMotorJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_OdeAMotorJoint_get_axes(PyObject *self, PyObject *) {
  OdeAMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeAMotorJoint, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_axes)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_OdeAMotorJoint_get_axis_101(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_OdeAMotorJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeAMotorJoint) {
    printf("OdeAMotorJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeAMotorJoint *local_this = (OdeAMotorJoint *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeAMotorJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeAMotorJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeAMotorJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeAMotorJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeAMotorJoint*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeBallJoint
 */
/**
 * Python function wrapper for:
 * inline void OdeBallJoint::set_anchor(LVecBase3f const &anchor)
 * inline void OdeBallJoint::set_anchor(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBallJoint_set_anchor_128(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBallJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBallJoint, (void **)&local_this, "OdeBallJoint.set_anchor")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "anchor")) {
        // 1-inline void OdeBallJoint::set_anchor(LVecBase3f const &anchor)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBallJoint.set_anchor", "LVecBase3f");
        }
        ((*local_this).set_anchor)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeBallJoint::set_anchor(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_anchor", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_anchor)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_anchor() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anchor(const OdeBallJoint self, const LVecBase3f anchor)\n"
      "set_anchor(const OdeBallJoint self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBallJoint_set_anchor_128_comment =
  "C++ Interface:\n"
  "set_anchor(const OdeBallJoint self, const LVecBase3f anchor)\n"
  "set_anchor(const OdeBallJoint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBallJoint_set_anchor_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBallJoint::set_anchor2(LVecBase3f const &anchor)
 * inline void OdeBallJoint::set_anchor2(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBallJoint_set_anchor2_129(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBallJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBallJoint, (void **)&local_this, "OdeBallJoint.set_anchor2")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "anchor")) {
        // 1-inline void OdeBallJoint::set_anchor2(LVecBase3f const &anchor)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBallJoint.set_anchor2", "LVecBase3f");
        }
        ((*local_this).set_anchor2)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeBallJoint::set_anchor2(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_anchor2", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_anchor2)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_anchor2() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anchor2(const OdeBallJoint self, const LVecBase3f anchor)\n"
      "set_anchor2(const OdeBallJoint self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBallJoint_set_anchor2_129_comment =
  "C++ Interface:\n"
  "set_anchor2(const OdeBallJoint self, const LVecBase3f anchor)\n"
  "set_anchor2(const OdeBallJoint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBallJoint_set_anchor2_129_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBallJoint::get_anchor(void) const
 */
static PyObject *Dtool_OdeBallJoint_get_anchor_130(PyObject *self, PyObject *) {
  OdeBallJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBallJoint)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeBallJoint::get_anchor(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeBallJoint*)local_this).get_anchor)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBallJoint_get_anchor_130_comment =
  "C++ Interface:\n"
  "get_anchor(OdeBallJoint self)\n";
#else
static const char *Dtool_OdeBallJoint_get_anchor_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBallJoint::get_anchor2(void) const
 */
static PyObject *Dtool_OdeBallJoint_get_anchor2_131(PyObject *self, PyObject *) {
  OdeBallJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBallJoint)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeBallJoint::get_anchor2(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeBallJoint*)local_this).get_anchor2)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBallJoint_get_anchor2_131_comment =
  "C++ Interface:\n"
  "get_anchor2(OdeBallJoint self)\n";
#else
static const char *Dtool_OdeBallJoint_get_anchor2_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeBallJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeBallJoint_get_class_type_132(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeBallJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeBallJoint::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBallJoint_get_class_type_132_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeBallJoint_get_class_type_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeBallJoint::OdeBallJoint(OdeWorld &world)
 * OdeBallJoint::OdeBallJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeBallJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "world")) {
        // 1-OdeBallJoint::OdeBallJoint(OdeWorld &world)
        OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeBallJoint.OdeBallJoint", false, true);
        if (arg_this != nullptr) {
          OdeBallJoint *return_value = new OdeBallJoint(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeBallJoint, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-OdeBallJoint::OdeBallJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeBallJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeBallJoint.OdeBallJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeBallJoint.OdeBallJoint", false, true);
        if (param0_this != nullptr && param1_this != nullptr) {
          OdeBallJoint *return_value = new OdeBallJoint(*param0_this, *param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeBallJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeBallJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeBallJoint(OdeWorld world)\n"
      "OdeBallJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeBallJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeBallJoint) {
    printf("OdeBallJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeBallJoint *local_this = (OdeBallJoint *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeBallJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeBallJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeBallJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeBallJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeBallJoint*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeMass
 */
/**
 * Python function wrapper for:
 * inline int OdeMass::check(void)
 */
static PyObject *Dtool_OdeMass_check_136(PyObject *self, PyObject *) {
  OdeMass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.check")) {
    return nullptr;
  }
  // 1-inline int OdeMass::check(void)
  int return_value = ((*local_this).check)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_check_136_comment =
  "C++ Interface:\n"
  "check(const OdeMass self)\n";
#else
static const char *Dtool_OdeMass_check_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_zero(void)
 */
static PyObject *Dtool_OdeMass_set_zero_137(PyObject *self, PyObject *) {
  OdeMass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_zero")) {
    return nullptr;
  }
  // 1-inline void OdeMass::set_zero(void)
  ((*local_this).set_zero)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_zero_137_comment =
  "C++ Interface:\n"
  "set_zero(const OdeMass self)\n";
#else
static const char *Dtool_OdeMass_set_zero_137_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_parameters(dReal themass, LVecBase3f const &center, LMatrix3f const &r)
 * inline void OdeMass::set_parameters(dReal themass, dReal cgx, dReal cgy, dReal cgz, dReal I11, dReal I22, dReal I33, dReal I12, dReal I13, dReal I23)
 */
static PyObject *Dtool_OdeMass_set_parameters_138(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_parameters")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-inline void OdeMass::set_parameters(dReal themass, LVecBase3f const &center, LMatrix3f const &r)
      float param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"themass", "center", "r", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fOO:set_parameters", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeMass.set_parameters", "LVecBase3f");
        }
        LMatrix3f param3_local;
        LMatrix3f const *param3_this = Dtool_Coerce_LMatrix3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "OdeMass.set_parameters", "LMatrix3f");
        }
        ((*local_this).set_parameters)((dReal)param1, *param2_this, *param3_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 10:
    {
      // 1-inline void OdeMass::set_parameters(dReal themass, dReal cgx, dReal cgy, dReal cgz, dReal I11, dReal I22, dReal I33, dReal I12, dReal I13, dReal I23)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      float param7;
      float param8;
      float param9;
      float param10;
      static const char *keyword_list[] = {"themass", "cgx", "cgy", "cgz", "I11", "I22", "I33", "I12", "I13", "I23", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffffffff:set_parameters", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10)) {
        ((*local_this).set_parameters)((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6, (dReal)param7, (dReal)param8, (dReal)param9, (dReal)param10);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_parameters() takes 4 or 11 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_parameters(const OdeMass self, float themass, const LVecBase3f center, const LMatrix3f r)\n"
      "set_parameters(const OdeMass self, float themass, float cgx, float cgy, float cgz, float I11, float I22, float I33, float I12, float I13, float I23)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_parameters_138_comment =
  "C++ Interface:\n"
  "set_parameters(const OdeMass self, float themass, const LVecBase3f center, const LMatrix3f r)\n"
  "set_parameters(const OdeMass self, float themass, float cgx, float cgy, float cgz, float I11, float I22, float I33, float I12, float I13, float I23)\n";
#else
static const char *Dtool_OdeMass_set_parameters_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_sphere(dReal density, dReal radius)
 */
static PyObject *Dtool_OdeMass_set_sphere_139(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_sphere")) {
    return nullptr;
  }
  // 1-inline void OdeMass::set_sphere(dReal density, dReal radius)
  float param1;
  float param2;
  static const char *keyword_list[] = {"density", "radius", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_sphere", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_sphere)((dReal)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sphere(const OdeMass self, float density, float radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_sphere_139_comment =
  "C++ Interface:\n"
  "set_sphere(const OdeMass self, float density, float radius)\n";
#else
static const char *Dtool_OdeMass_set_sphere_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_sphere_total(dReal total_mass, dReal radius)
 */
static PyObject *Dtool_OdeMass_set_sphere_total_140(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_sphere_total")) {
    return nullptr;
  }
  // 1-inline void OdeMass::set_sphere_total(dReal total_mass, dReal radius)
  float param1;
  float param2;
  static const char *keyword_list[] = {"total_mass", "radius", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_sphere_total", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_sphere_total)((dReal)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_sphere_total(const OdeMass self, float total_mass, float radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_sphere_total_140_comment =
  "C++ Interface:\n"
  "set_sphere_total(const OdeMass self, float total_mass, float radius)\n";
#else
static const char *Dtool_OdeMass_set_sphere_total_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_capsule(dReal density, int direction, dReal radius, dReal length)
 */
static PyObject *Dtool_OdeMass_set_capsule_141(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_capsule")) {
    return nullptr;
  }
  // 1-inline void OdeMass::set_capsule(dReal density, int direction, dReal radius, dReal length)
  float param1;
  int param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"density", "direction", "radius", "length", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fiff:set_capsule", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).set_capsule)((dReal)param1, (int)param2, (dReal)param3, (dReal)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_capsule(const OdeMass self, float density, int direction, float radius, float length)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_capsule_141_comment =
  "C++ Interface:\n"
  "set_capsule(const OdeMass self, float density, int direction, float radius, float length)\n";
#else
static const char *Dtool_OdeMass_set_capsule_141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_capsule_total(dReal total_mass, int direction, dReal radius, dReal length)
 */
static PyObject *Dtool_OdeMass_set_capsule_total_142(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_capsule_total")) {
    return nullptr;
  }
  // 1-inline void OdeMass::set_capsule_total(dReal total_mass, int direction, dReal radius, dReal length)
  float param1;
  int param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"total_mass", "direction", "radius", "length", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fiff:set_capsule_total", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).set_capsule_total)((dReal)param1, (int)param2, (dReal)param3, (dReal)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_capsule_total(const OdeMass self, float total_mass, int direction, float radius, float length)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_capsule_total_142_comment =
  "C++ Interface:\n"
  "set_capsule_total(const OdeMass self, float total_mass, int direction, float radius, float length)\n";
#else
static const char *Dtool_OdeMass_set_capsule_total_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_cylinder(dReal density, int direction, dReal radius, dReal length)
 */
static PyObject *Dtool_OdeMass_set_cylinder_143(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_cylinder")) {
    return nullptr;
  }
  // 1-inline void OdeMass::set_cylinder(dReal density, int direction, dReal radius, dReal length)
  float param1;
  int param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"density", "direction", "radius", "length", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fiff:set_cylinder", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).set_cylinder)((dReal)param1, (int)param2, (dReal)param3, (dReal)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cylinder(const OdeMass self, float density, int direction, float radius, float length)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_cylinder_143_comment =
  "C++ Interface:\n"
  "set_cylinder(const OdeMass self, float density, int direction, float radius, float length)\n";
#else
static const char *Dtool_OdeMass_set_cylinder_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_cylinder_total(dReal total_mass, int direction, dReal radius, dReal length)
 */
static PyObject *Dtool_OdeMass_set_cylinder_total_144(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_cylinder_total")) {
    return nullptr;
  }
  // 1-inline void OdeMass::set_cylinder_total(dReal total_mass, int direction, dReal radius, dReal length)
  float param1;
  int param2;
  float param3;
  float param4;
  static const char *keyword_list[] = {"total_mass", "direction", "radius", "length", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fiff:set_cylinder_total", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).set_cylinder_total)((dReal)param1, (int)param2, (dReal)param3, (dReal)param4);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cylinder_total(const OdeMass self, float total_mass, int direction, float radius, float length)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_cylinder_total_144_comment =
  "C++ Interface:\n"
  "set_cylinder_total(const OdeMass self, float total_mass, int direction, float radius, float length)\n";
#else
static const char *Dtool_OdeMass_set_cylinder_total_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_box(dReal density, LVecBase3f const &size)
 * inline void OdeMass::set_box(dReal density, dReal lx, dReal ly, dReal lz)
 */
static PyObject *Dtool_OdeMass_set_box_145(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_box")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeMass::set_box(dReal density, LVecBase3f const &size)
      float param1;
      PyObject *param2;
      static const char *keyword_list[] = {"density", "size", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:set_box", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeMass.set_box", "LVecBase3f");
        }
        ((*local_this).set_box)((dReal)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void OdeMass::set_box(dReal density, dReal lx, dReal ly, dReal lz)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"density", "lx", "ly", "lz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_box", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_box)((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_box() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_box(const OdeMass self, float density, const LVecBase3f size)\n"
      "set_box(const OdeMass self, float density, float lx, float ly, float lz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_box_145_comment =
  "C++ Interface:\n"
  "set_box(const OdeMass self, float density, const LVecBase3f size)\n"
  "set_box(const OdeMass self, float density, float lx, float ly, float lz)\n";
#else
static const char *Dtool_OdeMass_set_box_145_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::set_box_total(dReal total_mass, LVecBase3f const &size)
 * inline void OdeMass::set_box_total(dReal total_mass, dReal lx, dReal ly, dReal lz)
 */
static PyObject *Dtool_OdeMass_set_box_total_146(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.set_box_total")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeMass::set_box_total(dReal total_mass, LVecBase3f const &size)
      float param1;
      PyObject *param2;
      static const char *keyword_list[] = {"total_mass", "size", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:set_box_total", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeMass.set_box_total", "LVecBase3f");
        }
        ((*local_this).set_box_total)((dReal)param1, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void OdeMass::set_box_total(dReal total_mass, dReal lx, dReal ly, dReal lz)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"total_mass", "lx", "ly", "lz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_box_total", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_box_total)((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_box_total() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_box_total(const OdeMass self, float total_mass, const LVecBase3f size)\n"
      "set_box_total(const OdeMass self, float total_mass, float lx, float ly, float lz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_set_box_total_146_comment =
  "C++ Interface:\n"
  "set_box_total(const OdeMass self, float total_mass, const LVecBase3f size)\n"
  "set_box_total(const OdeMass self, float total_mass, float lx, float ly, float lz)\n";
#else
static const char *Dtool_OdeMass_set_box_total_146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::adjust(dReal newmass)
 */
static PyObject *Dtool_OdeMass_adjust_147(PyObject *self, PyObject *arg) {
  OdeMass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.adjust")) {
    return nullptr;
  }
  // 1-inline void OdeMass::adjust(dReal newmass)
  if (PyNumber_Check(arg)) {
    ((*local_this).adjust)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "adjust(const OdeMass self, float newmass)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_adjust_147_comment =
  "C++ Interface:\n"
  "adjust(const OdeMass self, float newmass)\n";
#else
static const char *Dtool_OdeMass_adjust_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::translate(LVecBase3f const &pos)
 * inline void OdeMass::translate(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeMass_translate_148(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.translate")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-inline void OdeMass::translate(LVecBase3f const &pos)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeMass.translate", "LVecBase3f");
        }
        ((*local_this).translate)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeMass::translate(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:translate", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).translate)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "translate() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "translate(const OdeMass self, const LVecBase3f pos)\n"
      "translate(const OdeMass self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_translate_148_comment =
  "C++ Interface:\n"
  "translate(const OdeMass self, const LVecBase3f pos)\n"
  "translate(const OdeMass self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeMass_translate_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::rotate(LMatrix3f const &r)
 */
static PyObject *Dtool_OdeMass_rotate_149(PyObject *self, PyObject *arg) {
  OdeMass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.rotate")) {
    return nullptr;
  }
  // 1-inline void OdeMass::rotate(LMatrix3f const &r)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeMass.rotate", "LMatrix3f");
  }
  ((*local_this).rotate)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rotate(const OdeMass self, const LMatrix3f r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_rotate_149_comment =
  "C++ Interface:\n"
  "rotate(const OdeMass self, const LMatrix3f r)\n";
#else
static const char *Dtool_OdeMass_rotate_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeMass::add(OdeMass &other)
 */
static PyObject *Dtool_OdeMass_add_150(PyObject *self, PyObject *arg) {
  OdeMass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeMass, (void **)&local_this, "OdeMass.add")) {
    return nullptr;
  }
  // 1-inline void OdeMass::add(OdeMass &other)
  OdeMass *arg_this = (OdeMass *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeMass, 1, "OdeMass.add", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add(const OdeMass self, OdeMass other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_add_150_comment =
  "C++ Interface:\n"
  "add(const OdeMass self, OdeMass other)\n";
#else
static const char *Dtool_OdeMass_add_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeMass::get_magnitude(void) const
 */
static PyObject *Dtool_OdeMass_get_magnitude_151(PyObject *self, PyObject *) {
  OdeMass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeMass)) {
    return nullptr;
  }
  // 1-inline dReal OdeMass::get_magnitude(void) const
  dReal return_value = ((*(const OdeMass*)local_this).get_magnitude)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_get_magnitude_151_comment =
  "C++ Interface:\n"
  "get_magnitude(OdeMass self)\n";
#else
static const char *Dtool_OdeMass_get_magnitude_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeMass::get_center(void) const
 */
static PyObject *Dtool_OdeMass_get_center_152(PyObject *self, PyObject *) {
  OdeMass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeMass)) {
    return nullptr;
  }
  // 1-inline LPoint3f OdeMass::get_center(void) const
  LPoint3f *return_value = new LPoint3f(((*(const OdeMass*)local_this).get_center)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_get_center_152_comment =
  "C++ Interface:\n"
  "get_center(OdeMass self)\n";
#else
static const char *Dtool_OdeMass_get_center_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3f OdeMass::get_inertial_tensor(void) const
 */
static PyObject *Dtool_OdeMass_get_inertial_tensor_153(PyObject *self, PyObject *) {
  OdeMass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeMass)) {
    return nullptr;
  }
  // 1-inline LMatrix3f OdeMass::get_inertial_tensor(void) const
  LMatrix3f *return_value = new LMatrix3f(((*(const OdeMass*)local_this).get_inertial_tensor)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_get_inertial_tensor_153_comment =
  "C++ Interface:\n"
  "get_inertial_tensor(OdeMass self)\n";
#else
static const char *Dtool_OdeMass_get_inertial_tensor_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void OdeMass::write(std::ostream &out = ::std::cout, unsigned int indent = 0) const
 */
static PyObject *Dtool_OdeMass_write_154(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeMass *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeMass)) {
    return nullptr;
  }
  // 1-virtual void OdeMass::write(std::ostream &out = ::std::cout, unsigned int indent = 0) const
  PyObject *param1 = nullptr;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|Ok:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this;
    if (param1 == nullptr) {
      param1_this = &(std::cout);
    } else {
      param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "OdeMass.write", false, true);
    }
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*(const OdeMass*)local_this).write)(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(OdeMass self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_write_154_comment =
  "C++ Interface:\n"
  "write(OdeMass self, ostream out, int indent)\n";
#else
static const char *Dtool_OdeMass_write_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeMass::get_class_type(void)
 */
static PyObject *Dtool_OdeMass_get_class_type_155(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeMass::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeMass::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeMass_get_class_type_155_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeMass_get_class_type_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeMass::OdeMass(void)
 * OdeMass::OdeMass(OdeMass const &copy)
 */
static int Dtool_Init_OdeMass(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-OdeMass::OdeMass(void)
      OdeMass *return_value = new OdeMass();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeMass, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-OdeMass::OdeMass(OdeMass const &copy)
        OdeMass const *arg_this = (OdeMass *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeMass, 0, "OdeMass.OdeMass", true, true);
        if (arg_this != nullptr) {
          OdeMass *return_value = new OdeMass(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeMass, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeMass() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeMass()\n"
      "OdeMass(const OdeMass copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeMass(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeMass) {
    printf("OdeMass ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeMass *local_this = (OdeMass *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeMass) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeMass(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeMass) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (OdeMass*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeMass*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (OdeMass*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeBody
 */
/**
 * Python function wrapper for:
 * void OdeBody::destroy(void)
 */
static PyObject *Dtool_OdeBody_destroy_158(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.destroy")) {
    return nullptr;
  }
  // 1-void OdeBody::destroy(void)
  ((*local_this).destroy)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_destroy_158_comment =
  "C++ Interface:\n"
  "destroy(const OdeBody self)\n";
#else
static const char *Dtool_OdeBody_destroy_158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool OdeBody::is_empty(void) const
 */
static PyObject *Dtool_OdeBody_is_empty_159(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline bool OdeBody::is_empty(void) const
  bool return_value = ((*(const OdeBody*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_is_empty_159_comment =
  "C++ Interface:\n"
  "is_empty(OdeBody self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ID is 0, meaning the OdeBody does not point to a valid\n"
  " * body.  It is an error to call a method on an empty body.  Note that an\n"
  " * empty OdeBody also evaluates to False.\n"
  " */";
#else
static const char *Dtool_OdeBody_is_empty_159_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dBodyID OdeBody::get_id(void) const
 */
static PyObject *Dtool_OdeBody_get_id_160(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline dBodyID OdeBody::get_id(void) const
  dBodyID return_value = ((*(const OdeBody*)local_this).get_id)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_dxBody, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_id_160_comment =
  "C++ Interface:\n"
  "get_id(OdeBody self)\n"
  "\n"
  "/**\n"
  " * Returns the underlying dBodyID.\n"
  " */";
#else
static const char *Dtool_OdeBody_get_id_160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_auto_disable_linear_threshold(dReal linear_threshold)
 */
static PyObject *Dtool_OdeBody_set_auto_disable_linear_threshold_161(PyObject *self, PyObject *arg) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_auto_disable_linear_threshold")) {
    return nullptr;
  }
  // 1-inline void OdeBody::set_auto_disable_linear_threshold(dReal linear_threshold)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_auto_disable_linear_threshold)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_linear_threshold(const OdeBody self, float linear_threshold)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_auto_disable_linear_threshold_161_comment =
  "C++ Interface:\n"
  "set_auto_disable_linear_threshold(const OdeBody self, float linear_threshold)\n";
#else
static const char *Dtool_OdeBody_set_auto_disable_linear_threshold_161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_auto_disable_angular_threshold(dReal angular_threshold)
 */
static PyObject *Dtool_OdeBody_set_auto_disable_angular_threshold_162(PyObject *self, PyObject *arg) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_auto_disable_angular_threshold")) {
    return nullptr;
  }
  // 1-inline void OdeBody::set_auto_disable_angular_threshold(dReal angular_threshold)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_auto_disable_angular_threshold)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_angular_threshold(const OdeBody self, float angular_threshold)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_auto_disable_angular_threshold_162_comment =
  "C++ Interface:\n"
  "set_auto_disable_angular_threshold(const OdeBody self, float angular_threshold)\n";
#else
static const char *Dtool_OdeBody_set_auto_disable_angular_threshold_162_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_auto_disable_steps(int steps)
 */
static PyObject *Dtool_OdeBody_set_auto_disable_steps_163(PyObject *self, PyObject *arg) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_auto_disable_steps")) {
    return nullptr;
  }
  // 1-inline void OdeBody::set_auto_disable_steps(int steps)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_auto_disable_steps)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_steps(const OdeBody self, int steps)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_auto_disable_steps_163_comment =
  "C++ Interface:\n"
  "set_auto_disable_steps(const OdeBody self, int steps)\n";
#else
static const char *Dtool_OdeBody_set_auto_disable_steps_163_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_auto_disable_time(dReal time)
 */
static PyObject *Dtool_OdeBody_set_auto_disable_time_164(PyObject *self, PyObject *arg) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_auto_disable_time")) {
    return nullptr;
  }
  // 1-inline void OdeBody::set_auto_disable_time(dReal time)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_auto_disable_time)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_time(const OdeBody self, float time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_auto_disable_time_164_comment =
  "C++ Interface:\n"
  "set_auto_disable_time(const OdeBody self, float time)\n";
#else
static const char *Dtool_OdeBody_set_auto_disable_time_164_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_auto_disable_flag(int do_auto_disable)
 */
static PyObject *Dtool_OdeBody_set_auto_disable_flag_165(PyObject *self, PyObject *arg) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_auto_disable_flag")) {
    return nullptr;
  }
  // 1-inline void OdeBody::set_auto_disable_flag(int do_auto_disable)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_auto_disable_flag)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_disable_flag(const OdeBody self, int do_auto_disable)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_auto_disable_flag_165_comment =
  "C++ Interface:\n"
  "set_auto_disable_flag(const OdeBody self, int do_auto_disable)\n";
#else
static const char *Dtool_OdeBody_set_auto_disable_flag_165_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_auto_disable_defaults(void)
 */
static PyObject *Dtool_OdeBody_set_auto_disable_defaults_166(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_auto_disable_defaults")) {
    return nullptr;
  }
  // 1-inline void OdeBody::set_auto_disable_defaults(void)
  ((*local_this).set_auto_disable_defaults)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_auto_disable_defaults_166_comment =
  "C++ Interface:\n"
  "set_auto_disable_defaults(const OdeBody self)\n";
#else
static const char *Dtool_OdeBody_set_auto_disable_defaults_166_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeBody::set_data(PyObject *data)
 */
static PyObject *Dtool_OdeBody_set_data_167(PyObject *self, PyObject *arg) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_data")) {
    return nullptr;
  }
  // 1-void OdeBody::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const OdeBody self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_data_167_comment =
  "C++ Interface:\n"
  "set_data(const OdeBody self, object data)\n";
#else
static const char *Dtool_OdeBody_set_data_167_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_position(LVecBase3f const &pos)
 * inline void OdeBody::set_position(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBody_set_position_168(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_position")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-inline void OdeBody::set_position(LVecBase3f const &pos)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.set_position", "LVecBase3f");
        }
        ((*local_this).set_position)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::set_position(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_position", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_position)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_position() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_position(const OdeBody self, const LVecBase3f pos)\n"
      "set_position(const OdeBody self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_position_168_comment =
  "C++ Interface:\n"
  "set_position(const OdeBody self, const LVecBase3f pos)\n"
  "set_position(const OdeBody self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBody_set_position_168_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_rotation(LMatrix3f const &r)
 */
static PyObject *Dtool_OdeBody_set_rotation_169(PyObject *self, PyObject *arg) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_rotation")) {
    return nullptr;
  }
  // 1-inline void OdeBody::set_rotation(LMatrix3f const &r)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.set_rotation", "LMatrix3f");
  }
  ((*local_this).set_rotation)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rotation(const OdeBody self, const LMatrix3f r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_rotation_169_comment =
  "C++ Interface:\n"
  "set_rotation(const OdeBody self, const LMatrix3f r)\n";
#else
static const char *Dtool_OdeBody_set_rotation_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_quaternion(LQuaternionf const &q)
 */
static PyObject *Dtool_OdeBody_set_quaternion_170(PyObject *self, PyObject *arg) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_quaternion")) {
    return nullptr;
  }
  // 1-inline void OdeBody::set_quaternion(LQuaternionf const &q)
  LQuaternionf arg_local;
  LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.set_quaternion", "LQuaternionf");
  }
  ((*local_this).set_quaternion)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_quaternion(const OdeBody self, const LQuaternionf q)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_quaternion_170_comment =
  "C++ Interface:\n"
  "set_quaternion(const OdeBody self, const LQuaternionf q)\n";
#else
static const char *Dtool_OdeBody_set_quaternion_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_linear_vel(LVecBase3f const &vel)
 * inline void OdeBody::set_linear_vel(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBody_set_linear_vel_171(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_linear_vel")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "vel")) {
        // 1-inline void OdeBody::set_linear_vel(LVecBase3f const &vel)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.set_linear_vel", "LVecBase3f");
        }
        ((*local_this).set_linear_vel)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::set_linear_vel(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_linear_vel", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_linear_vel)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_linear_vel() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_linear_vel(const OdeBody self, const LVecBase3f vel)\n"
      "set_linear_vel(const OdeBody self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_linear_vel_171_comment =
  "C++ Interface:\n"
  "set_linear_vel(const OdeBody self, const LVecBase3f vel)\n"
  "set_linear_vel(const OdeBody self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBody_set_linear_vel_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_angular_vel(LVecBase3f const &vel)
 * inline void OdeBody::set_angular_vel(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBody_set_angular_vel_172(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_angular_vel")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "vel")) {
        // 1-inline void OdeBody::set_angular_vel(LVecBase3f const &vel)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.set_angular_vel", "LVecBase3f");
        }
        ((*local_this).set_angular_vel)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::set_angular_vel(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_angular_vel", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_angular_vel)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_angular_vel() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_angular_vel(const OdeBody self, const LVecBase3f vel)\n"
      "set_angular_vel(const OdeBody self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_angular_vel_172_comment =
  "C++ Interface:\n"
  "set_angular_vel(const OdeBody self, const LVecBase3f vel)\n"
  "set_angular_vel(const OdeBody self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBody_set_angular_vel_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_mass(OdeMass &mass)
 */
static PyObject *Dtool_OdeBody_set_mass_173(PyObject *self, PyObject *arg) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_mass")) {
    return nullptr;
  }
  // 1-inline void OdeBody::set_mass(OdeMass &mass)
  OdeMass *arg_this = (OdeMass *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeMass, 1, "OdeBody.set_mass", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_mass)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mass(const OdeBody self, OdeMass mass)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_mass_173_comment =
  "C++ Interface:\n"
  "set_mass(const OdeBody self, OdeMass mass)\n";
#else
static const char *Dtool_OdeBody_set_mass_173_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeBody::get_auto_disable_linear_threshold(void) const
 */
static PyObject *Dtool_OdeBody_get_auto_disable_linear_threshold_174(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline dReal OdeBody::get_auto_disable_linear_threshold(void) const
  dReal return_value = ((*(const OdeBody*)local_this).get_auto_disable_linear_threshold)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_auto_disable_linear_threshold_174_comment =
  "C++ Interface:\n"
  "get_auto_disable_linear_threshold(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_auto_disable_linear_threshold_174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeBody::get_auto_disable_angular_threshold(void) const
 */
static PyObject *Dtool_OdeBody_get_auto_disable_angular_threshold_175(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline dReal OdeBody::get_auto_disable_angular_threshold(void) const
  dReal return_value = ((*(const OdeBody*)local_this).get_auto_disable_angular_threshold)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_auto_disable_angular_threshold_175_comment =
  "C++ Interface:\n"
  "get_auto_disable_angular_threshold(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_auto_disable_angular_threshold_175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeBody::get_auto_disable_steps(void) const
 */
static PyObject *Dtool_OdeBody_get_auto_disable_steps_176(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline int OdeBody::get_auto_disable_steps(void) const
  int return_value = ((*(const OdeBody*)local_this).get_auto_disable_steps)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_auto_disable_steps_176_comment =
  "C++ Interface:\n"
  "get_auto_disable_steps(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_auto_disable_steps_176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeBody::get_auto_disable_time(void) const
 */
static PyObject *Dtool_OdeBody_get_auto_disable_time_177(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline dReal OdeBody::get_auto_disable_time(void) const
  dReal return_value = ((*(const OdeBody*)local_this).get_auto_disable_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_auto_disable_time_177_comment =
  "C++ Interface:\n"
  "get_auto_disable_time(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_auto_disable_time_177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeBody::get_auto_disable_flag(void) const
 */
static PyObject *Dtool_OdeBody_get_auto_disable_flag_178(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline int OdeBody::get_auto_disable_flag(void) const
  int return_value = ((*(const OdeBody*)local_this).get_auto_disable_flag)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_auto_disable_flag_178_comment =
  "C++ Interface:\n"
  "get_auto_disable_flag(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_auto_disable_flag_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *OdeBody::get_data(void) const
 */
static PyObject *Dtool_OdeBody_get_data_179(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-PyObject *OdeBody::get_data(void) const
  PyObject *return_value = invoke_extension((const OdeBody*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_data_179_comment =
  "C++ Interface:\n"
  "get_data(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_data_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBody::get_position(void) const
 */
static PyObject *Dtool_OdeBody_get_position_180(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeBody::get_position(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeBody*)local_this).get_position)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_position_180_comment =
  "C++ Interface:\n"
  "get_position(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_position_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3f OdeBody::get_rotation(void) const
 */
static PyObject *Dtool_OdeBody_get_rotation_181(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline LMatrix3f OdeBody::get_rotation(void) const
  LMatrix3f *return_value = new LMatrix3f(((*(const OdeBody*)local_this).get_rotation)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_rotation_181_comment =
  "C++ Interface:\n"
  "get_rotation(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_rotation_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4f OdeBody::get_quaternion(void) const
 */
static PyObject *Dtool_OdeBody_get_quaternion_182(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline LVecBase4f OdeBody::get_quaternion(void) const
  LVecBase4f *return_value = new LVecBase4f(((*(const OdeBody*)local_this).get_quaternion)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_quaternion_182_comment =
  "C++ Interface:\n"
  "get_quaternion(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_quaternion_182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBody::get_linear_vel(void) const
 */
static PyObject *Dtool_OdeBody_get_linear_vel_183(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeBody::get_linear_vel(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeBody*)local_this).get_linear_vel)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_linear_vel_183_comment =
  "C++ Interface:\n"
  "get_linear_vel(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_linear_vel_183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBody::get_angular_vel(void) const
 */
static PyObject *Dtool_OdeBody_get_angular_vel_184(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeBody::get_angular_vel(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeBody*)local_this).get_angular_vel)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_angular_vel_184_comment =
  "C++ Interface:\n"
  "get_angular_vel(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_angular_vel_184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OdeMass OdeBody::get_mass(void) const
 */
static PyObject *Dtool_OdeBody_get_mass_185(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline OdeMass OdeBody::get_mass(void) const
  OdeMass *return_value = new OdeMass(((*(const OdeBody*)local_this).get_mass)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeMass, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_mass_185_comment =
  "C++ Interface:\n"
  "get_mass(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_mass_185_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::add_force(LVecBase3f const &f)
 * inline void OdeBody::add_force(dReal fx, dReal fy, dReal fz)
 */
static PyObject *Dtool_OdeBody_add_force_186(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.add_force")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "f")) {
        // 1-inline void OdeBody::add_force(LVecBase3f const &f)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.add_force", "LVecBase3f");
        }
        ((*local_this).add_force)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::add_force(dReal fx, dReal fy, dReal fz)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"fx", "fy", "fz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_force", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).add_force)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_force() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_force(const OdeBody self, const LVecBase3f f)\n"
      "add_force(const OdeBody self, float fx, float fy, float fz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_add_force_186_comment =
  "C++ Interface:\n"
  "add_force(const OdeBody self, const LVecBase3f f)\n"
  "add_force(const OdeBody self, float fx, float fy, float fz)\n";
#else
static const char *Dtool_OdeBody_add_force_186_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::add_torque(LVecBase3f const &f)
 * inline void OdeBody::add_torque(dReal fx, dReal fy, dReal fz)
 */
static PyObject *Dtool_OdeBody_add_torque_187(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.add_torque")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "f")) {
        // 1-inline void OdeBody::add_torque(LVecBase3f const &f)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.add_torque", "LVecBase3f");
        }
        ((*local_this).add_torque)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::add_torque(dReal fx, dReal fy, dReal fz)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"fx", "fy", "fz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_torque", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).add_torque)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_torque() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_torque(const OdeBody self, const LVecBase3f f)\n"
      "add_torque(const OdeBody self, float fx, float fy, float fz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_add_torque_187_comment =
  "C++ Interface:\n"
  "add_torque(const OdeBody self, const LVecBase3f f)\n"
  "add_torque(const OdeBody self, float fx, float fy, float fz)\n";
#else
static const char *Dtool_OdeBody_add_torque_187_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::add_rel_force(LVecBase3f const &f)
 * inline void OdeBody::add_rel_force(dReal fx, dReal fy, dReal fz)
 */
static PyObject *Dtool_OdeBody_add_rel_force_188(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.add_rel_force")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "f")) {
        // 1-inline void OdeBody::add_rel_force(LVecBase3f const &f)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.add_rel_force", "LVecBase3f");
        }
        ((*local_this).add_rel_force)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::add_rel_force(dReal fx, dReal fy, dReal fz)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"fx", "fy", "fz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_rel_force", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).add_rel_force)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_rel_force() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_rel_force(const OdeBody self, const LVecBase3f f)\n"
      "add_rel_force(const OdeBody self, float fx, float fy, float fz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_add_rel_force_188_comment =
  "C++ Interface:\n"
  "add_rel_force(const OdeBody self, const LVecBase3f f)\n"
  "add_rel_force(const OdeBody self, float fx, float fy, float fz)\n";
#else
static const char *Dtool_OdeBody_add_rel_force_188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::add_rel_torque(LVecBase3f const &f)
 * inline void OdeBody::add_rel_torque(dReal fx, dReal fy, dReal fz)
 */
static PyObject *Dtool_OdeBody_add_rel_torque_189(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.add_rel_torque")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "f")) {
        // 1-inline void OdeBody::add_rel_torque(LVecBase3f const &f)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.add_rel_torque", "LVecBase3f");
        }
        ((*local_this).add_rel_torque)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::add_rel_torque(dReal fx, dReal fy, dReal fz)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"fx", "fy", "fz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:add_rel_torque", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).add_rel_torque)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_rel_torque() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_rel_torque(const OdeBody self, const LVecBase3f f)\n"
      "add_rel_torque(const OdeBody self, float fx, float fy, float fz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_add_rel_torque_189_comment =
  "C++ Interface:\n"
  "add_rel_torque(const OdeBody self, const LVecBase3f f)\n"
  "add_rel_torque(const OdeBody self, float fx, float fy, float fz)\n";
#else
static const char *Dtool_OdeBody_add_rel_torque_189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::add_force_at_pos(LVecBase3f const &f, LVecBase3f const &pos)
 * inline void OdeBody::add_force_at_pos(dReal fx, dReal fy, dReal fz, dReal px, dReal py, dReal pz)
 */
static PyObject *Dtool_OdeBody_add_force_at_pos_190(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.add_force_at_pos")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeBody::add_force_at_pos(LVecBase3f const &f, LVecBase3f const &pos)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"f", "pos", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_force_at_pos", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "OdeBody.add_force_at_pos", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeBody.add_force_at_pos", "LVecBase3f");
        }
        ((*local_this).add_force_at_pos)(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void OdeBody::add_force_at_pos(dReal fx, dReal fy, dReal fz, dReal px, dReal py, dReal pz)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"fx", "fy", "fz", "px", "py", "pz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:add_force_at_pos", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        ((*local_this).add_force_at_pos)((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_force_at_pos() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_force_at_pos(const OdeBody self, const LVecBase3f f, const LVecBase3f pos)\n"
      "add_force_at_pos(const OdeBody self, float fx, float fy, float fz, float px, float py, float pz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_add_force_at_pos_190_comment =
  "C++ Interface:\n"
  "add_force_at_pos(const OdeBody self, const LVecBase3f f, const LVecBase3f pos)\n"
  "add_force_at_pos(const OdeBody self, float fx, float fy, float fz, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_add_force_at_pos_190_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::add_force_at_rel_pos(LVecBase3f const &f, LVecBase3f const &pos)
 * inline void OdeBody::add_force_at_rel_pos(dReal fx, dReal fy, dReal fz, dReal px, dReal py, dReal pz)
 */
static PyObject *Dtool_OdeBody_add_force_at_rel_pos_191(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.add_force_at_rel_pos")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeBody::add_force_at_rel_pos(LVecBase3f const &f, LVecBase3f const &pos)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"f", "pos", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_force_at_rel_pos", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "OdeBody.add_force_at_rel_pos", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeBody.add_force_at_rel_pos", "LVecBase3f");
        }
        ((*local_this).add_force_at_rel_pos)(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void OdeBody::add_force_at_rel_pos(dReal fx, dReal fy, dReal fz, dReal px, dReal py, dReal pz)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"fx", "fy", "fz", "px", "py", "pz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:add_force_at_rel_pos", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        ((*local_this).add_force_at_rel_pos)((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_force_at_rel_pos() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_force_at_rel_pos(const OdeBody self, const LVecBase3f f, const LVecBase3f pos)\n"
      "add_force_at_rel_pos(const OdeBody self, float fx, float fy, float fz, float px, float py, float pz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_add_force_at_rel_pos_191_comment =
  "C++ Interface:\n"
  "add_force_at_rel_pos(const OdeBody self, const LVecBase3f f, const LVecBase3f pos)\n"
  "add_force_at_rel_pos(const OdeBody self, float fx, float fy, float fz, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_add_force_at_rel_pos_191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::add_rel_force_at_pos(LVecBase3f const &f, LVecBase3f const &pos)
 * inline void OdeBody::add_rel_force_at_pos(dReal fx, dReal fy, dReal fz, dReal px, dReal py, dReal pz)
 */
static PyObject *Dtool_OdeBody_add_rel_force_at_pos_192(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.add_rel_force_at_pos")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeBody::add_rel_force_at_pos(LVecBase3f const &f, LVecBase3f const &pos)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"f", "pos", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_rel_force_at_pos", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "OdeBody.add_rel_force_at_pos", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeBody.add_rel_force_at_pos", "LVecBase3f");
        }
        ((*local_this).add_rel_force_at_pos)(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void OdeBody::add_rel_force_at_pos(dReal fx, dReal fy, dReal fz, dReal px, dReal py, dReal pz)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"fx", "fy", "fz", "px", "py", "pz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:add_rel_force_at_pos", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        ((*local_this).add_rel_force_at_pos)((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_rel_force_at_pos() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_rel_force_at_pos(const OdeBody self, const LVecBase3f f, const LVecBase3f pos)\n"
      "add_rel_force_at_pos(const OdeBody self, float fx, float fy, float fz, float px, float py, float pz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_add_rel_force_at_pos_192_comment =
  "C++ Interface:\n"
  "add_rel_force_at_pos(const OdeBody self, const LVecBase3f f, const LVecBase3f pos)\n"
  "add_rel_force_at_pos(const OdeBody self, float fx, float fy, float fz, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_add_rel_force_at_pos_192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::add_rel_force_at_rel_pos(LVecBase3f const &f, LVecBase3f const &pos)
 * inline void OdeBody::add_rel_force_at_rel_pos(dReal fx, dReal fy, dReal fz, dReal px, dReal py, dReal pz)
 */
static PyObject *Dtool_OdeBody_add_rel_force_at_rel_pos_193(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.add_rel_force_at_rel_pos")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeBody::add_rel_force_at_rel_pos(LVecBase3f const &f, LVecBase3f const &pos)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"f", "pos", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_rel_force_at_rel_pos", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "OdeBody.add_rel_force_at_rel_pos", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeBody.add_rel_force_at_rel_pos", "LVecBase3f");
        }
        ((*local_this).add_rel_force_at_rel_pos)(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void OdeBody::add_rel_force_at_rel_pos(dReal fx, dReal fy, dReal fz, dReal px, dReal py, dReal pz)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"fx", "fy", "fz", "px", "py", "pz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:add_rel_force_at_rel_pos", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        ((*local_this).add_rel_force_at_rel_pos)((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add_rel_force_at_rel_pos() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_rel_force_at_rel_pos(const OdeBody self, const LVecBase3f f, const LVecBase3f pos)\n"
      "add_rel_force_at_rel_pos(const OdeBody self, float fx, float fy, float fz, float px, float py, float pz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_add_rel_force_at_rel_pos_193_comment =
  "C++ Interface:\n"
  "add_rel_force_at_rel_pos(const OdeBody self, const LVecBase3f f, const LVecBase3f pos)\n"
  "add_rel_force_at_rel_pos(const OdeBody self, float fx, float fy, float fz, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_add_rel_force_at_rel_pos_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_force(LVecBase3f const &f)
 * inline void OdeBody::set_force(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBody_set_force_194(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_force")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "f")) {
        // 1-inline void OdeBody::set_force(LVecBase3f const &f)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.set_force", "LVecBase3f");
        }
        ((*local_this).set_force)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::set_force(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_force", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_force)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_force() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_force(const OdeBody self, const LVecBase3f f)\n"
      "set_force(const OdeBody self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_force_194_comment =
  "C++ Interface:\n"
  "set_force(const OdeBody self, const LVecBase3f f)\n"
  "set_force(const OdeBody self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBody_set_force_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_torque(LVecBase3f const &f)
 * inline void OdeBody::set_torque(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBody_set_torque_195(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_torque")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "f")) {
        // 1-inline void OdeBody::set_torque(LVecBase3f const &f)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.set_torque", "LVecBase3f");
        }
        ((*local_this).set_torque)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::set_torque(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_torque", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_torque)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_torque() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_torque(const OdeBody self, const LVecBase3f f)\n"
      "set_torque(const OdeBody self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_torque_195_comment =
  "C++ Interface:\n"
  "set_torque(const OdeBody self, const LVecBase3f f)\n"
  "set_torque(const OdeBody self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBody_set_torque_195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeBody::get_rel_point_pos(LVecBase3f const &pos) const
 * inline LPoint3f OdeBody::get_rel_point_pos(dReal px, dReal py, dReal pz) const
 */
static PyObject *Dtool_OdeBody_get_rel_point_pos_196(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-inline LPoint3f OdeBody::get_rel_point_pos(LVecBase3f const &pos) const
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.get_rel_point_pos", "LVecBase3f");
        }
        LPoint3f *return_value = new LPoint3f(((*(const OdeBody*)local_this).get_rel_point_pos)(*arg_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LPoint3f OdeBody::get_rel_point_pos(dReal px, dReal py, dReal pz) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"px", "py", "pz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:get_rel_point_pos", (char **)keyword_list, &param1, &param2, &param3)) {
        LPoint3f *return_value = new LPoint3f(((*(const OdeBody*)local_this).get_rel_point_pos)((dReal)param1, (dReal)param2, (dReal)param3));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_rel_point_pos() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_rel_point_pos(OdeBody self, const LVecBase3f pos)\n"
      "get_rel_point_pos(OdeBody self, float px, float py, float pz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_rel_point_pos_196_comment =
  "C++ Interface:\n"
  "get_rel_point_pos(OdeBody self, const LVecBase3f pos)\n"
  "get_rel_point_pos(OdeBody self, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_get_rel_point_pos_196_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeBody::get_rel_point_vel(LVecBase3f const &pos) const
 * inline LPoint3f OdeBody::get_rel_point_vel(dReal px, dReal py, dReal pz) const
 */
static PyObject *Dtool_OdeBody_get_rel_point_vel_197(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-inline LPoint3f OdeBody::get_rel_point_vel(LVecBase3f const &pos) const
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.get_rel_point_vel", "LVecBase3f");
        }
        LPoint3f *return_value = new LPoint3f(((*(const OdeBody*)local_this).get_rel_point_vel)(*arg_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LPoint3f OdeBody::get_rel_point_vel(dReal px, dReal py, dReal pz) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"px", "py", "pz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:get_rel_point_vel", (char **)keyword_list, &param1, &param2, &param3)) {
        LPoint3f *return_value = new LPoint3f(((*(const OdeBody*)local_this).get_rel_point_vel)((dReal)param1, (dReal)param2, (dReal)param3));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_rel_point_vel() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_rel_point_vel(OdeBody self, const LVecBase3f pos)\n"
      "get_rel_point_vel(OdeBody self, float px, float py, float pz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_rel_point_vel_197_comment =
  "C++ Interface:\n"
  "get_rel_point_vel(OdeBody self, const LVecBase3f pos)\n"
  "get_rel_point_vel(OdeBody self, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_get_rel_point_vel_197_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeBody::get_point_vel(LVecBase3f const &pos) const
 * inline LPoint3f OdeBody::get_point_vel(dReal px, dReal py, dReal pz) const
 */
static PyObject *Dtool_OdeBody_get_point_vel_198(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-inline LPoint3f OdeBody::get_point_vel(LVecBase3f const &pos) const
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.get_point_vel", "LVecBase3f");
        }
        LPoint3f *return_value = new LPoint3f(((*(const OdeBody*)local_this).get_point_vel)(*arg_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LPoint3f OdeBody::get_point_vel(dReal px, dReal py, dReal pz) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"px", "py", "pz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:get_point_vel", (char **)keyword_list, &param1, &param2, &param3)) {
        LPoint3f *return_value = new LPoint3f(((*(const OdeBody*)local_this).get_point_vel)((dReal)param1, (dReal)param2, (dReal)param3));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_point_vel() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point_vel(OdeBody self, const LVecBase3f pos)\n"
      "get_point_vel(OdeBody self, float px, float py, float pz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_point_vel_198_comment =
  "C++ Interface:\n"
  "get_point_vel(OdeBody self, const LVecBase3f pos)\n"
  "get_point_vel(OdeBody self, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_get_point_vel_198_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeBody::get_pos_rel_point(LVecBase3f const &pos) const
 * inline LPoint3f OdeBody::get_pos_rel_point(dReal px, dReal py, dReal pz) const
 */
static PyObject *Dtool_OdeBody_get_pos_rel_point_199(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-inline LPoint3f OdeBody::get_pos_rel_point(LVecBase3f const &pos) const
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.get_pos_rel_point", "LVecBase3f");
        }
        LPoint3f *return_value = new LPoint3f(((*(const OdeBody*)local_this).get_pos_rel_point)(*arg_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LPoint3f OdeBody::get_pos_rel_point(dReal px, dReal py, dReal pz) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"px", "py", "pz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:get_pos_rel_point", (char **)keyword_list, &param1, &param2, &param3)) {
        LPoint3f *return_value = new LPoint3f(((*(const OdeBody*)local_this).get_pos_rel_point)((dReal)param1, (dReal)param2, (dReal)param3));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_pos_rel_point() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pos_rel_point(OdeBody self, const LVecBase3f pos)\n"
      "get_pos_rel_point(OdeBody self, float px, float py, float pz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_pos_rel_point_199_comment =
  "C++ Interface:\n"
  "get_pos_rel_point(OdeBody self, const LVecBase3f pos)\n"
  "get_pos_rel_point(OdeBody self, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_get_pos_rel_point_199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBody::vector_to_world(LVecBase3f const &pos) const
 * inline LVecBase3f OdeBody::vector_to_world(dReal px, dReal py, dReal pz) const
 */
static PyObject *Dtool_OdeBody_vector_to_world_200(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-inline LVecBase3f OdeBody::vector_to_world(LVecBase3f const &pos) const
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.vector_to_world", "LVecBase3f");
        }
        LVecBase3f *return_value = new LVecBase3f(((*(const OdeBody*)local_this).vector_to_world)(*arg_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LVecBase3f OdeBody::vector_to_world(dReal px, dReal py, dReal pz) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"px", "py", "pz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:vector_to_world", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase3f *return_value = new LVecBase3f(((*(const OdeBody*)local_this).vector_to_world)((dReal)param1, (dReal)param2, (dReal)param3));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "vector_to_world() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "vector_to_world(OdeBody self, const LVecBase3f pos)\n"
      "vector_to_world(OdeBody self, float px, float py, float pz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_vector_to_world_200_comment =
  "C++ Interface:\n"
  "vector_to_world(OdeBody self, const LVecBase3f pos)\n"
  "vector_to_world(OdeBody self, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_vector_to_world_200_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBody::vector_from_world(LVecBase3f const &pos) const
 * inline LVecBase3f OdeBody::vector_from_world(dReal px, dReal py, dReal pz) const
 */
static PyObject *Dtool_OdeBody_vector_from_world_201(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-inline LVecBase3f OdeBody::vector_from_world(LVecBase3f const &pos) const
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.vector_from_world", "LVecBase3f");
        }
        LVecBase3f *return_value = new LVecBase3f(((*(const OdeBody*)local_this).vector_from_world)(*arg_this));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline LVecBase3f OdeBody::vector_from_world(dReal px, dReal py, dReal pz) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"px", "py", "pz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:vector_from_world", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase3f *return_value = new LVecBase3f(((*(const OdeBody*)local_this).vector_from_world)((dReal)param1, (dReal)param2, (dReal)param3));
        if (return_value == nullptr) {
          return PyErr_NoMemory();
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return nullptr;
        }
        return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "vector_from_world() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "vector_from_world(OdeBody self, const LVecBase3f pos)\n"
      "vector_from_world(OdeBody self, float px, float py, float pz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_vector_from_world_201_comment =
  "C++ Interface:\n"
  "vector_from_world(OdeBody self, const LVecBase3f pos)\n"
  "vector_from_world(OdeBody self, float px, float py, float pz)\n";
#else
static const char *Dtool_OdeBody_vector_from_world_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_finite_rotation_mode(int mode)
 */
static PyObject *Dtool_OdeBody_set_finite_rotation_mode_202(PyObject *self, PyObject *arg) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_finite_rotation_mode")) {
    return nullptr;
  }
  // 1-inline void OdeBody::set_finite_rotation_mode(int mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_finite_rotation_mode)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_finite_rotation_mode(const OdeBody self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_finite_rotation_mode_202_comment =
  "C++ Interface:\n"
  "set_finite_rotation_mode(const OdeBody self, int mode)\n";
#else
static const char *Dtool_OdeBody_set_finite_rotation_mode_202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_finite_rotation_axis(LVecBase3f const &axis)
 * inline void OdeBody::set_finite_rotation_axis(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBody_set_finite_rotation_axis_203(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_finite_rotation_axis")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "axis")) {
        // 1-inline void OdeBody::set_finite_rotation_axis(LVecBase3f const &axis)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBody.set_finite_rotation_axis", "LVecBase3f");
        }
        ((*local_this).set_finite_rotation_axis)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeBody::set_finite_rotation_axis(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_finite_rotation_axis", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_finite_rotation_axis)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_finite_rotation_axis() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_finite_rotation_axis(const OdeBody self, const LVecBase3f axis)\n"
      "set_finite_rotation_axis(const OdeBody self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_finite_rotation_axis_203_comment =
  "C++ Interface:\n"
  "set_finite_rotation_axis(const OdeBody self, const LVecBase3f axis)\n"
  "set_finite_rotation_axis(const OdeBody self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBody_set_finite_rotation_axis_203_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeBody::get_finite_rotation_mode(void) const
 */
static PyObject *Dtool_OdeBody_get_finite_rotation_mode_204(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline int OdeBody::get_finite_rotation_mode(void) const
  int return_value = ((*(const OdeBody*)local_this).get_finite_rotation_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_finite_rotation_mode_204_comment =
  "C++ Interface:\n"
  "get_finite_rotation_mode(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_finite_rotation_mode_204_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBody::get_finite_rotation_axis(void) const
 */
static PyObject *Dtool_OdeBody_get_finite_rotation_axis_205(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeBody::get_finite_rotation_axis(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeBody*)local_this).get_finite_rotation_axis)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_finite_rotation_axis_205_comment =
  "C++ Interface:\n"
  "get_finite_rotation_axis(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_finite_rotation_axis_205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeBody::get_num_joints(void) const
 */
static PyObject *Dtool_OdeBody_get_num_joints_206(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline int OdeBody::get_num_joints(void) const
  int return_value = ((*(const OdeBody*)local_this).get_num_joints)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_num_joints_206_comment =
  "C++ Interface:\n"
  "get_num_joints(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_num_joints_206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeJoint OdeBody::get_joint(int index) const
 */
static PyObject *Dtool_OdeBody_get_joint_207(PyObject *self, PyObject *arg) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-OdeJoint OdeBody::get_joint(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    OdeJoint *return_value = new OdeJoint(((*(const OdeBody*)local_this).get_joint)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeJoint, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_joint(OdeBody self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_joint_207_comment =
  "C++ Interface:\n"
  "get_joint(OdeBody self, int index)\n";
#else
static const char *Dtool_OdeBody_get_joint_207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *OdeBody::get_converted_joint(int i) const
 */
static PyObject *Dtool_OdeBody_get_converted_joint_209(PyObject *self, PyObject *arg) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline PyObject *OdeBody::get_converted_joint(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PyObject *return_value = invoke_extension((const OdeBody*)local_this).get_converted_joint((int)arg_val);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_converted_joint(OdeBody self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_converted_joint_209_comment =
  "C++ Interface:\n"
  "get_converted_joint(OdeBody self, int i)\n";
#else
static const char *Dtool_OdeBody_get_converted_joint_209_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::enable(void)
 */
static PyObject *Dtool_OdeBody_enable_214(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.enable")) {
    return nullptr;
  }
  // 1-inline void OdeBody::enable(void)
  ((*local_this).enable)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_enable_214_comment =
  "C++ Interface:\n"
  "enable(const OdeBody self)\n";
#else
static const char *Dtool_OdeBody_enable_214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::disable(void)
 */
static PyObject *Dtool_OdeBody_disable_215(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.disable")) {
    return nullptr;
  }
  // 1-inline void OdeBody::disable(void)
  ((*local_this).disable)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_disable_215_comment =
  "C++ Interface:\n"
  "disable(const OdeBody self)\n";
#else
static const char *Dtool_OdeBody_disable_215_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeBody::is_enabled(void) const
 */
static PyObject *Dtool_OdeBody_is_enabled_216(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline int OdeBody::is_enabled(void) const
  int return_value = ((*(const OdeBody*)local_this).is_enabled)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_is_enabled_216_comment =
  "C++ Interface:\n"
  "is_enabled(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_is_enabled_216_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeBody::set_gravity_mode(int mode)
 */
static PyObject *Dtool_OdeBody_set_gravity_mode_217(PyObject *self, PyObject *arg) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBody, (void **)&local_this, "OdeBody.set_gravity_mode")) {
    return nullptr;
  }
  // 1-inline void OdeBody::set_gravity_mode(int mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_gravity_mode)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_gravity_mode(const OdeBody self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_set_gravity_mode_217_comment =
  "C++ Interface:\n"
  "set_gravity_mode(const OdeBody self, int mode)\n";
#else
static const char *Dtool_OdeBody_set_gravity_mode_217_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeBody::get_gravity_mode(void) const
 */
static PyObject *Dtool_OdeBody_get_gravity_mode_218(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline int OdeBody::get_gravity_mode(void) const
  int return_value = ((*(const OdeBody*)local_this).get_gravity_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_gravity_mode_218_comment =
  "C++ Interface:\n"
  "get_gravity_mode(OdeBody self)\n";
#else
static const char *Dtool_OdeBody_get_gravity_mode_218_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void OdeBody::write(std::ostream &out = ::std::cout, unsigned int indent = 0) const
 */
static PyObject *Dtool_OdeBody_write_219(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-virtual void OdeBody::write(std::ostream &out = ::std::cout, unsigned int indent = 0) const
  PyObject *param1 = nullptr;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|Ok:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this;
    if (param1 == nullptr) {
      param1_this = &(std::cout);
    } else {
      param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "OdeBody.write", false, true);
    }
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*(const OdeBody*)local_this).write)(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(OdeBody self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_write_219_comment =
  "C++ Interface:\n"
  "write(OdeBody self, ostream out, int indent)\n";
#else
static const char *Dtool_OdeBody_write_219_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeBody::compare_to(OdeBody const &other) const
 */
static PyObject *Dtool_OdeBody_compare_to_221(PyObject *self, PyObject *arg) {
  OdeBody *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeBody)) {
    return nullptr;
  }
  // 1-inline int OdeBody::compare_to(OdeBody const &other) const
  OdeBody const *arg_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeBody, 1, "OdeBody.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const OdeBody*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(OdeBody self, const OdeBody other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_compare_to_221_comment =
  "C++ Interface:\n"
  "compare_to(OdeBody self, const OdeBody other)\n";
#else
static const char *Dtool_OdeBody_compare_to_221_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeBody::get_class_type(void)
 */
static PyObject *Dtool_OdeBody_get_class_type_222(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeBody::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeBody::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBody_get_class_type_222_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeBody_get_class_type_222_comment = nullptr;
#endif

/**
 * sequence length function for property OdeBody::joints
 */
static Py_ssize_t Dtool_OdeBody_joints_Len(PyObject *self) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_joints)();
}

/**
 * sequence getter for property OdeBody::joints
 */
static PyObject *Dtool_OdeBody_joints_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_joints)()) {
    PyErr_SetString(PyExc_IndexError, "OdeBody.joints[] index out of range");
    return nullptr;
  }
  // 1-inline PyObject *OdeBody::get_converted_joint(int i) const
  PyObject *return_value = invoke_extension((const OdeBody*)local_this).get_converted_joint(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_converted_joint(OdeBody self, index)\n");
  }
}

static PyObject *Dtool_OdeBody_joints_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "OdeBody.joints");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_OdeBody_joints_Len;
    wrap->_getitem_func = &Dtool_OdeBody_joints_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * OdeBody::OdeBody(OdeWorld &world)
 */
static int Dtool_Init_OdeBody(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "OdeBody() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "world")) {
    // 1-OdeBody::OdeBody(OdeWorld &world)
    OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeBody.OdeBody", false, true);
    if (arg_this != nullptr) {
      OdeBody *return_value = new OdeBody(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeBody, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeBody(OdeWorld world)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_OdeBody_get_joints(PyObject *self, PyObject *) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_joints)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_OdeBody_get_joint_207(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_OdeBody(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeBody) {
    printf("OdeBody ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeBody *local_this = (OdeBody *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeBody) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeBody(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeBody) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeBody*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeSpace
 */
/**
 * Python function wrapper for:
 * void OdeSpace::destroy(void)
 */
static PyObject *Dtool_OdeSpace_destroy_224(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.destroy")) {
    return nullptr;
  }
  // 1-void OdeSpace::destroy(void)
  ((*local_this).destroy)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_destroy_224_comment =
  "C++ Interface:\n"
  "destroy(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_destroy_224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool OdeSpace::is_empty(void) const
 */
static PyObject *Dtool_OdeSpace_is_empty_225(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSpace)) {
    return nullptr;
  }
  // 1-inline bool OdeSpace::is_empty(void) const
  bool return_value = ((*(const OdeSpace*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_is_empty_225_comment =
  "C++ Interface:\n"
  "is_empty(OdeSpace self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ID is 0, meaning the OdeSpace does not point to a valid\n"
  " * space.  It is an error to call a method on an empty space.  Note that an\n"
  " * empty OdeSpace also evaluates to False.\n"
  " */";
#else
static const char *Dtool_OdeSpace_is_empty_225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSpace::set_cleanup(int mode)
 */
static PyObject *Dtool_OdeSpace_set_cleanup_226(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.set_cleanup")) {
    return nullptr;
  }
  // 1-inline void OdeSpace::set_cleanup(int mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_cleanup)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cleanup(const OdeSpace self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_set_cleanup_226_comment =
  "C++ Interface:\n"
  "set_cleanup(const OdeSpace self, int mode)\n";
#else
static const char *Dtool_OdeSpace_set_cleanup_226_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeSpace::get_cleanup(void) const
 */
static PyObject *Dtool_OdeSpace_get_cleanup_227(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSpace)) {
    return nullptr;
  }
  // 1-inline int OdeSpace::get_cleanup(void) const
  int return_value = ((*(const OdeSpace*)local_this).get_cleanup)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_cleanup_227_comment =
  "C++ Interface:\n"
  "get_cleanup(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_cleanup_227_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int OdeSpace::query(OdeGeom const &geom) const
 * int OdeSpace::query(OdeSpace const &space) const
 */
static PyObject *Dtool_OdeSpace_query_228(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSpace)) {
    return nullptr;
  }
  {
    // -2 int OdeSpace::query(OdeGeom const &geom) const
    OdeGeom const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_OdeGeom);
    if (arg_this != nullptr) {
      int return_value = ((*(const OdeSpace*)local_this).query)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 int OdeSpace::query(OdeSpace const &space) const
    OdeSpace const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_OdeSpace);
    if (arg_this != nullptr) {
      int return_value = ((*(const OdeSpace*)local_this).query)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: int OdeSpace::query(OdeGeom const &geom) const
  // No coercion possible: int OdeSpace::query(OdeSpace const &space) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "query(OdeSpace self, const OdeGeom geom)\n"
      "query(OdeSpace self, const OdeSpace space)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_query_228_comment =
  "C++ Interface:\n"
  "query(OdeSpace self, const OdeGeom geom)\n"
  "query(OdeSpace self, const OdeSpace space)\n";
#else
static const char *Dtool_OdeSpace_query_228_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeSpace::get_num_geoms(void) const
 */
static PyObject *Dtool_OdeSpace_get_num_geoms_229(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSpace)) {
    return nullptr;
  }
  // 1-inline int OdeSpace::get_num_geoms(void) const
  int return_value = ((*(const OdeSpace*)local_this).get_num_geoms)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_num_geoms_229_comment =
  "C++ Interface:\n"
  "get_num_geoms(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_num_geoms_229_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSpace::get_AABB(LVecBase3f &min, LVecBase3f &max) const
 */
static PyObject *Dtool_OdeSpace_get_AABB_230(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeSpace *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSpace)) {
    return nullptr;
  }
  // 1-inline void OdeSpace::get_AABB(LVecBase3f &min, LVecBase3f &max) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"min", "max", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_AABB", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param1_local;
    LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "OdeSpace.get_AABB", "LVecBase3f");
    }
    LVecBase3f param2_local;
    LVecBase3f *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "OdeSpace.get_AABB", "LVecBase3f");
    }
    ((*(const OdeSpace*)local_this).get_AABB)(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_AABB(OdeSpace self, LVecBase3f min, LVecBase3f max)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_AABB_230_comment =
  "C++ Interface:\n"
  "get_AABB(OdeSpace self, LVecBase3f min, LVecBase3f max)\n";
#else
static const char *Dtool_OdeSpace_get_AABB_230_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *OdeSpace::get_AA_bounds(void) const
 */
static PyObject *Dtool_OdeSpace_get_AA_bounds_231(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSpace)) {
    return nullptr;
  }
  // 1-inline PyObject *OdeSpace::get_AA_bounds(void) const
  PyObject *return_value = invoke_extension((const OdeSpace*)local_this).get_AA_bounds();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_AA_bounds_231_comment =
  "C++ Interface:\n"
  "get_AA_bounds(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_AA_bounds_231_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeSpace::is_space(void)
 */
static PyObject *Dtool_OdeSpace_is_space_232(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.is_space")) {
    return nullptr;
  }
  // 1-inline int OdeSpace::is_space(void)
  int return_value = ((*local_this).is_space)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_is_space_232_comment =
  "C++ Interface:\n"
  "is_space(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_is_space_232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeSpace::get_class(void) const
 */
static PyObject *Dtool_OdeSpace_get_class_233(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSpace)) {
    return nullptr;
  }
  // 1-inline int OdeSpace::get_class(void) const
  int return_value = ((*(const OdeSpace*)local_this).get_class)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_class_233_comment =
  "C++ Interface:\n"
  "get_class(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_class_233_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSpace::set_category_bits(BitMask32 const &bits)
 */
static PyObject *Dtool_OdeSpace_set_category_bits_234(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.set_category_bits")) {
    return nullptr;
  }
  // 1-inline void OdeSpace::set_category_bits(BitMask32 const &bits)
  BitMask< uint32_t, 32 > arg_local;
  BitMask32 const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeSpace.set_category_bits", "BitMask");
  }
  ((*local_this).set_category_bits)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_category_bits(const OdeSpace self, const BitMask bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_set_category_bits_234_comment =
  "C++ Interface:\n"
  "set_category_bits(const OdeSpace self, const BitMask bits)\n";
#else
static const char *Dtool_OdeSpace_set_category_bits_234_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSpace::set_collide_bits(BitMask32 const &bits)
 */
static PyObject *Dtool_OdeSpace_set_collide_bits_235(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.set_collide_bits")) {
    return nullptr;
  }
  // 1-inline void OdeSpace::set_collide_bits(BitMask32 const &bits)
  BitMask< uint32_t, 32 > arg_local;
  BitMask32 const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeSpace.set_collide_bits", "BitMask");
  }
  ((*local_this).set_collide_bits)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collide_bits(const OdeSpace self, const BitMask bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_set_collide_bits_235_comment =
  "C++ Interface:\n"
  "set_collide_bits(const OdeSpace self, const BitMask bits)\n";
#else
static const char *Dtool_OdeSpace_set_collide_bits_235_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask32 OdeSpace::get_category_bits(void)
 */
static PyObject *Dtool_OdeSpace_get_category_bits_236(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.get_category_bits")) {
    return nullptr;
  }
  // 1-inline BitMask32 OdeSpace::get_category_bits(void)
  BitMask32 *return_value = new BitMask32(((*local_this).get_category_bits)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_category_bits_236_comment =
  "C++ Interface:\n"
  "get_category_bits(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_category_bits_236_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask32 OdeSpace::get_collide_bits(void)
 */
static PyObject *Dtool_OdeSpace_get_collide_bits_237(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.get_collide_bits")) {
    return nullptr;
  }
  // 1-inline BitMask32 OdeSpace::get_collide_bits(void)
  BitMask32 *return_value = new BitMask32(((*local_this).get_collide_bits)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_collide_bits_237_comment =
  "C++ Interface:\n"
  "get_collide_bits(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_collide_bits_237_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSpace::enable(void)
 */
static PyObject *Dtool_OdeSpace_enable_238(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.enable")) {
    return nullptr;
  }
  // 1-inline void OdeSpace::enable(void)
  ((*local_this).enable)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_enable_238_comment =
  "C++ Interface:\n"
  "enable(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_enable_238_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSpace::disable(void)
 */
static PyObject *Dtool_OdeSpace_disable_239(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.disable")) {
    return nullptr;
  }
  // 1-inline void OdeSpace::disable(void)
  ((*local_this).disable)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_disable_239_comment =
  "C++ Interface:\n"
  "disable(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_disable_239_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeSpace::is_enabled(void)
 */
static PyObject *Dtool_OdeSpace_is_enabled_240(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.is_enabled")) {
    return nullptr;
  }
  // 1-inline int OdeSpace::is_enabled(void)
  int return_value = ((*local_this).is_enabled)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_is_enabled_240_comment =
  "C++ Interface:\n"
  "is_enabled(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_is_enabled_240_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeSpace::set_auto_collide_world(OdeWorld &)
 */
static PyObject *Dtool_OdeSpace_set_auto_collide_world_241(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.set_auto_collide_world")) {
    return nullptr;
  }
  // 1-void OdeSpace::set_auto_collide_world(OdeWorld &)
  OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 1, "OdeSpace.set_auto_collide_world", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_auto_collide_world)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_collide_world(const OdeSpace self, OdeWorld param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_set_auto_collide_world_241_comment =
  "C++ Interface:\n"
  "set_auto_collide_world(const OdeSpace self, OdeWorld param0)\n";
#else
static const char *Dtool_OdeSpace_set_auto_collide_world_241_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeSpace::set_auto_collide_joint_group(OdeJointGroup &)
 */
static PyObject *Dtool_OdeSpace_set_auto_collide_joint_group_242(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.set_auto_collide_joint_group")) {
    return nullptr;
  }
  // 1-void OdeSpace::set_auto_collide_joint_group(OdeJointGroup &)
  OdeJointGroup *arg_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointGroup, 1, "OdeSpace.set_auto_collide_joint_group", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_auto_collide_joint_group)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_collide_joint_group(const OdeSpace self, OdeJointGroup param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_set_auto_collide_joint_group_242_comment =
  "C++ Interface:\n"
  "set_auto_collide_joint_group(const OdeSpace self, OdeJointGroup param0)\n";
#else
static const char *Dtool_OdeSpace_set_auto_collide_joint_group_242_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeSpace::add(OdeGeom &geom)
 * void OdeSpace::add(OdeSpace &space)
 */
static PyObject *Dtool_OdeSpace_add_243(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.add")) {
    return nullptr;
  }
  {
    // -2 void OdeSpace::add(OdeGeom &geom)
    OdeGeom *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeSpace.add", false, false);
    if (arg_this != nullptr) {
      ((*local_this).add)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void OdeSpace::add(OdeSpace &space)
    OdeSpace *arg_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeSpace, 1, "OdeSpace.add", false, false);
    if (arg_this != nullptr) {
      ((*local_this).add)(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void OdeSpace::add(OdeGeom &geom)
  // No coercion possible: void OdeSpace::add(OdeSpace &space)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add(const OdeSpace self, OdeGeom geom)\n"
      "add(const OdeSpace self, OdeSpace space)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_add_243_comment =
  "C++ Interface:\n"
  "add(const OdeSpace self, OdeGeom geom)\n"
  "add(const OdeSpace self, OdeSpace space)\n";
#else
static const char *Dtool_OdeSpace_add_243_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeSpace::remove(OdeGeom &geom)
 * void OdeSpace::remove(OdeSpace &space)
 */
static PyObject *Dtool_OdeSpace_remove_244(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.remove")) {
    return nullptr;
  }
  {
    // -2 void OdeSpace::remove(OdeGeom &geom)
    OdeGeom *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeSpace.remove", false, false);
    if (arg_this != nullptr) {
      ((*local_this).remove)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void OdeSpace::remove(OdeSpace &space)
    OdeSpace *arg_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeSpace, 1, "OdeSpace.remove", false, false);
    if (arg_this != nullptr) {
      ((*local_this).remove)(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void OdeSpace::remove(OdeGeom &geom)
  // No coercion possible: void OdeSpace::remove(OdeSpace &space)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove(const OdeSpace self, OdeGeom geom)\n"
      "remove(const OdeSpace self, OdeSpace space)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_remove_244_comment =
  "C++ Interface:\n"
  "remove(const OdeSpace self, OdeGeom geom)\n"
  "remove(const OdeSpace self, OdeSpace space)\n";
#else
static const char *Dtool_OdeSpace_remove_244_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeSpace::clean(void)
 */
static PyObject *Dtool_OdeSpace_clean_245(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.clean")) {
    return nullptr;
  }
  // 1-void OdeSpace::clean(void)
  ((*local_this).clean)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_clean_245_comment =
  "C++ Interface:\n"
  "clean(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_clean_245_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeGeom OdeSpace::get_geom(int i)
 */
static PyObject *Dtool_OdeSpace_get_geom_246(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.get_geom")) {
    return nullptr;
  }
  // 1-OdeGeom OdeSpace::get_geom(int i)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    OdeGeom *return_value = new OdeGeom(((*local_this).get_geom)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeGeom, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_geom(const OdeSpace self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_geom_246_comment =
  "C++ Interface:\n"
  "get_geom(const OdeSpace self, int i)\n";
#else
static const char *Dtool_OdeSpace_get_geom_246_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OdeSpace OdeSpace::get_space(void) const
 */
static PyObject *Dtool_OdeSpace_get_space_247(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSpace)) {
    return nullptr;
  }
  // 1-inline OdeSpace OdeSpace::get_space(void) const
  OdeSpace *return_value = new OdeSpace(((*(const OdeSpace*)local_this).get_space)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeSpace, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_space_247_comment =
  "C++ Interface:\n"
  "get_space(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_space_247_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void OdeSpace::write(std::ostream &out = ::std::cout, unsigned int indent = 0) const
 */
static PyObject *Dtool_OdeSpace_write_248(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeSpace *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSpace)) {
    return nullptr;
  }
  // 1-virtual void OdeSpace::write(std::ostream &out = ::std::cout, unsigned int indent = 0) const
  PyObject *param1 = nullptr;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|Ok:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this;
    if (param1 == nullptr) {
      param1_this = &(std::cout);
    } else {
      param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "OdeSpace.write", false, true);
    }
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*(const OdeSpace*)local_this).write)(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(OdeSpace self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_write_248_comment =
  "C++ Interface:\n"
  "write(OdeSpace self, ostream out, int indent)\n";
#else
static const char *Dtool_OdeSpace_write_248_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeSimpleSpace OdeSpace::convert_to_simple_space(void) const
 */
static PyObject *Dtool_OdeSpace_convert_to_simple_space_250(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSpace)) {
    return nullptr;
  }
  // 1-OdeSimpleSpace OdeSpace::convert_to_simple_space(void) const
  OdeSimpleSpace *return_value = new OdeSimpleSpace(((*(const OdeSpace*)local_this).convert_to_simple_space)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeSimpleSpace, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_convert_to_simple_space_250_comment =
  "C++ Interface:\n"
  "convert_to_simple_space(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_convert_to_simple_space_250_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeHashSpace OdeSpace::convert_to_hash_space(void) const
 */
static PyObject *Dtool_OdeSpace_convert_to_hash_space_251(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSpace)) {
    return nullptr;
  }
  // 1-OdeHashSpace OdeSpace::convert_to_hash_space(void) const
  OdeHashSpace *return_value = new OdeHashSpace(((*(const OdeSpace*)local_this).convert_to_hash_space)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeHashSpace, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_convert_to_hash_space_251_comment =
  "C++ Interface:\n"
  "convert_to_hash_space(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_convert_to_hash_space_251_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeQuadTreeSpace OdeSpace::convert_to_quad_tree_space(void) const
 */
static PyObject *Dtool_OdeSpace_convert_to_quad_tree_space_252(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSpace)) {
    return nullptr;
  }
  // 1-OdeQuadTreeSpace OdeSpace::convert_to_quad_tree_space(void) const
  OdeQuadTreeSpace *return_value = new OdeQuadTreeSpace(((*(const OdeSpace*)local_this).convert_to_quad_tree_space)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeQuadTreeSpace, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_convert_to_quad_tree_space_252_comment =
  "C++ Interface:\n"
  "convert_to_quad_tree_space(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_convert_to_quad_tree_space_252_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *OdeSpace::convert(void) const
 */
static PyObject *Dtool_OdeSpace_convert_253(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSpace)) {
    return nullptr;
  }
  // 1-PyObject *OdeSpace::convert(void) const
  PyObject *return_value = invoke_extension((const OdeSpace*)local_this).convert();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_convert_253_comment =
  "C++ Interface:\n"
  "convert(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_convert_253_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *OdeSpace::get_converted_geom(int i) const
 */
static PyObject *Dtool_OdeSpace_get_converted_geom_254(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSpace)) {
    return nullptr;
  }
  // 1-inline PyObject *OdeSpace::get_converted_geom(int i) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PyObject *return_value = invoke_extension((const OdeSpace*)local_this).get_converted_geom((int)arg_val);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_converted_geom(OdeSpace self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_converted_geom_254_comment =
  "C++ Interface:\n"
  "get_converted_geom(OdeSpace self, int i)\n";
#else
static const char *Dtool_OdeSpace_get_converted_geom_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *OdeSpace::get_converted_space(void) const
 */
static PyObject *Dtool_OdeSpace_get_converted_space_255(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSpace)) {
    return nullptr;
  }
  // 1-inline PyObject *OdeSpace::get_converted_space(void) const
  PyObject *return_value = invoke_extension((const OdeSpace*)local_this).get_converted_space();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_converted_space_255_comment =
  "C++ Interface:\n"
  "get_converted_space(OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_converted_space_255_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeSpace::auto_collide(void)
 */
static PyObject *Dtool_OdeSpace_auto_collide_256(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.auto_collide")) {
    return nullptr;
  }
  // 1-void OdeSpace::auto_collide(void)
  ((*local_this).auto_collide)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_auto_collide_256_comment =
  "C++ Interface:\n"
  "auto_collide(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_auto_collide_256_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int OdeSpace::collide(PyObject *arg, PyObject *near_callback)
 */
static PyObject *Dtool_OdeSpace_collide_257(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.collide")) {
    return nullptr;
  }
  // 1-int OdeSpace::collide(PyObject *arg, PyObject *near_callback)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"arg", "near_callback", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:collide", (char **)keyword_list, &param1, &param2)) {
    int return_value = invoke_extension(local_this).collide(param1, param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "collide(const OdeSpace self, object arg, object near_callback)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_collide_257_comment =
  "C++ Interface:\n"
  "collide(const OdeSpace self, object arg, object near_callback)\n";
#else
static const char *Dtool_OdeSpace_collide_257_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int OdeSpace::set_collide_id(OdeGeom &geom, int collide_id)
 * int OdeSpace::set_collide_id(int collide_id, dGeomID id)
 */
static PyObject *Dtool_OdeSpace_set_collide_id_258(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.set_collide_id")) {
    return nullptr;
  }
  {
    // -2 int OdeSpace::set_collide_id(OdeGeom &geom, int collide_id)
    PyObject *param1;
    int param2;
    static const char *keyword_list[] = {"geom", "collide_id", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_collide_id", (char **)keyword_list, &param1, &param2)) {
      OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeGeom, 1, "OdeSpace.set_collide_id", false, false);
      if (param1_this != nullptr) {
        int return_value = ((*local_this).set_collide_id)(*param1_this, (int)param2);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 int OdeSpace::set_collide_id(int collide_id, dGeomID id)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"collide_id", "id", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_collide_id", (char **)keyword_list, &param1, &param2)) {
      dGeomID param2_this = (dxGeom *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_dxGeom, 2, "OdeSpace.set_collide_id", false, false);
      if (param2_this != nullptr) {
        int return_value = ((*local_this).set_collide_id)((int)param1, param2_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: int OdeSpace::set_collide_id(OdeGeom &geom, int collide_id)
  // No coercion possible: int OdeSpace::set_collide_id(int collide_id, dGeomID id)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collide_id(const OdeSpace self, OdeGeom geom, int collide_id)\n"
      "set_collide_id(const OdeSpace self, int collide_id, dxGeom id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_set_collide_id_258_comment =
  "C++ Interface:\n"
  "set_collide_id(const OdeSpace self, OdeGeom geom, int collide_id)\n"
  "set_collide_id(const OdeSpace self, int collide_id, dxGeom id)\n";
#else
static const char *Dtool_OdeSpace_set_collide_id_258_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeSpace::set_surface_type(OdeGeom &geom, int surface_type)
 * void OdeSpace::set_surface_type(int surface_type, dGeomID id)
 */
static PyObject *Dtool_OdeSpace_set_surface_type_259(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.set_surface_type")) {
    return nullptr;
  }
  {
    // -2 void OdeSpace::set_surface_type(OdeGeom &geom, int surface_type)
    PyObject *param1;
    int param2;
    static const char *keyword_list[] = {"geom", "surface_type", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_surface_type", (char **)keyword_list, &param1, &param2)) {
      OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeGeom, 1, "OdeSpace.set_surface_type", false, false);
      if (param1_this != nullptr) {
        ((*local_this).set_surface_type)(*param1_this, (int)param2);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void OdeSpace::set_surface_type(int surface_type, dGeomID id)
    int param1;
    PyObject *param2;
    static const char *keyword_list[] = {"surface_type", "id", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_surface_type", (char **)keyword_list, &param1, &param2)) {
      dGeomID param2_this = (dxGeom *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_dxGeom, 2, "OdeSpace.set_surface_type", false, false);
      if (param2_this != nullptr) {
        ((*local_this).set_surface_type)((int)param1, param2_this);
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: void OdeSpace::set_surface_type(OdeGeom &geom, int surface_type)
  // No coercion possible: void OdeSpace::set_surface_type(int surface_type, dGeomID id)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_surface_type(const OdeSpace self, OdeGeom geom, int surface_type)\n"
      "set_surface_type(const OdeSpace self, int surface_type, dxGeom id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_set_surface_type_259_comment =
  "C++ Interface:\n"
  "set_surface_type(const OdeSpace self, OdeGeom geom, int surface_type)\n"
  "set_surface_type(const OdeSpace self, int surface_type, dxGeom id)\n";
#else
static const char *Dtool_OdeSpace_set_surface_type_259_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int OdeSpace::get_surface_type(OdeGeom &geom)
 * int OdeSpace::get_surface_type(dGeomID o1)
 */
static PyObject *Dtool_OdeSpace_get_surface_type_260(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.get_surface_type")) {
    return nullptr;
  }
  {
    // -2 int OdeSpace::get_surface_type(OdeGeom &geom)
    OdeGeom *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeSpace.get_surface_type", false, false);
    if (arg_this != nullptr) {
      int return_value = ((*local_this).get_surface_type)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 int OdeSpace::get_surface_type(dGeomID o1)
    dGeomID arg_this = (dxGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_dxGeom, 1, "OdeSpace.get_surface_type", false, false);
    if (arg_this != nullptr) {
      int return_value = ((*local_this).get_surface_type)(arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: int OdeSpace::get_surface_type(OdeGeom &geom)
  // No coercion possible: int OdeSpace::get_surface_type(dGeomID o1)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_surface_type(const OdeSpace self, OdeGeom geom)\n"
      "get_surface_type(const OdeSpace self, dxGeom o1)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_surface_type_260_comment =
  "C++ Interface:\n"
  "get_surface_type(const OdeSpace self, OdeGeom geom)\n"
  "get_surface_type(const OdeSpace self, dxGeom o1)\n";
#else
static const char *Dtool_OdeSpace_get_surface_type_260_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int OdeSpace::get_collide_id(OdeGeom &geom)
 * int OdeSpace::get_collide_id(dGeomID o1)
 */
static PyObject *Dtool_OdeSpace_get_collide_id_261(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.get_collide_id")) {
    return nullptr;
  }
  {
    // -2 int OdeSpace::get_collide_id(OdeGeom &geom)
    OdeGeom *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeSpace.get_collide_id", false, false);
    if (arg_this != nullptr) {
      int return_value = ((*local_this).get_collide_id)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 int OdeSpace::get_collide_id(dGeomID o1)
    dGeomID arg_this = (dxGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_dxGeom, 1, "OdeSpace.get_collide_id", false, false);
    if (arg_this != nullptr) {
      int return_value = ((*local_this).get_collide_id)(arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: int OdeSpace::get_collide_id(OdeGeom &geom)
  // No coercion possible: int OdeSpace::get_collide_id(dGeomID o1)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_collide_id(const OdeSpace self, OdeGeom geom)\n"
      "get_collide_id(const OdeSpace self, dxGeom o1)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_collide_id_261_comment =
  "C++ Interface:\n"
  "get_collide_id(const OdeSpace self, OdeGeom geom)\n"
  "get_collide_id(const OdeSpace self, dxGeom o1)\n";
#else
static const char *Dtool_OdeSpace_get_collide_id_261_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSpace::set_collision_event(std::string const &event_name)
 */
static PyObject *Dtool_OdeSpace_set_collision_event_262(PyObject *self, PyObject *arg) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.set_collision_event")) {
    return nullptr;
  }
  // 1-inline void OdeSpace::set_collision_event(std::string const &event_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_collision_event)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collision_event(const OdeSpace self, str event_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_set_collision_event_262_comment =
  "C++ Interface:\n"
  "set_collision_event(const OdeSpace self, str event_name)\n";
#else
static const char *Dtool_OdeSpace_set_collision_event_262_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string OdeSpace::get_collision_event(void)
 */
static PyObject *Dtool_OdeSpace_get_collision_event_263(PyObject *self, PyObject *) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSpace, (void **)&local_this, "OdeSpace.get_collision_event")) {
    return nullptr;
  }
  // 1-inline std::string OdeSpace::get_collision_event(void)
  std::string return_value = ((*local_this).get_collision_event)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_collision_event_263_comment =
  "C++ Interface:\n"
  "get_collision_event(const OdeSpace self)\n";
#else
static const char *Dtool_OdeSpace_get_collision_event_263_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeSpace::get_class_type(void)
 */
static PyObject *Dtool_OdeSpace_get_class_type_264(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeSpace::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeSpace::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeSpace_get_class_type_264_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeSpace_get_class_type_264_comment = nullptr;
#endif

static int Dtool_Init_OdeSpace(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_OdeSpace(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeSpace) {
    printf("OdeSpace ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeSpace *local_this = (OdeSpace *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeSpace) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeSpace(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeSpace) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeSpace*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeGeom
 */
/**
 * Python function wrapper for:
 * void OdeGeom::destroy(void)
 */
static PyObject *Dtool_OdeGeom_destroy_267(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.destroy")) {
    return nullptr;
  }
  // 1-void OdeGeom::destroy(void)
  ((*local_this).destroy)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_destroy_267_comment =
  "C++ Interface:\n"
  "destroy(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_destroy_267_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool OdeGeom::is_empty(void) const
 */
static PyObject *Dtool_OdeGeom_is_empty_268(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-inline bool OdeGeom::is_empty(void) const
  bool return_value = ((*(const OdeGeom*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_is_empty_268_comment =
  "C++ Interface:\n"
  "is_empty(OdeGeom self)\n"
  "\n"
  "/**\n"
  " * Returns true if the ID is 0, meaning the OdeGeom does not point to a valid\n"
  " * geom.  It is an error to call a method on an empty geom.  Note that an\n"
  " * empty OdeGeom also evaluates to False.\n"
  " */";
#else
static const char *Dtool_OdeGeom_is_empty_268_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dGeomID OdeGeom::get_id(void) const
 */
static PyObject *Dtool_OdeGeom_get_id_269(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-inline dGeomID OdeGeom::get_id(void) const
  dGeomID return_value = ((*(const OdeGeom*)local_this).get_id)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_dxGeom, false, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_id_269_comment =
  "C++ Interface:\n"
  "get_id(OdeGeom self)\n"
  "\n"
  "/**\n"
  " * Returns the underlying dGeomID.\n"
  " */";
#else
static const char *Dtool_OdeGeom_get_id_269_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_body(OdeBody &body)
 */
static PyObject *Dtool_OdeGeom_set_body_270(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_body")) {
    return nullptr;
  }
  // 1-inline void OdeGeom::set_body(OdeBody &body)
  OdeBody *arg_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeBody, 1, "OdeGeom.set_body", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_body)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_body(const OdeGeom self, OdeBody body)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_body_270_comment =
  "C++ Interface:\n"
  "set_body(const OdeGeom self, OdeBody body)\n"
  "\n"
  "// INLINE void set_data(void* data);";
#else
static const char *Dtool_OdeGeom_set_body_270_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool OdeGeom::has_body(void) const
 */
static PyObject *Dtool_OdeGeom_has_body_271(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-inline bool OdeGeom::has_body(void) const
  bool return_value = ((*(const OdeGeom*)local_this).has_body)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_has_body_271_comment =
  "C++ Interface:\n"
  "has_body(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_has_body_271_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OdeBody OdeGeom::get_body(void) const
 */
static PyObject *Dtool_OdeGeom_get_body_272(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-inline OdeBody OdeGeom::get_body(void) const
  OdeBody *return_value = new OdeBody(((*(const OdeGeom*)local_this).get_body)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeBody, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_body_272_comment =
  "C++ Interface:\n"
  "get_body(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_body_272_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_position(LVecBase3f const &pos)
 * inline void OdeGeom::set_position(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeGeom_set_position_273(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_position")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-inline void OdeGeom::set_position(LVecBase3f const &pos)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_position", "LVecBase3f");
        }
        ((*local_this).set_position)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeGeom::set_position(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_position", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_position)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_position() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_position(const OdeGeom self, const LVecBase3f pos)\n"
      "set_position(const OdeGeom self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_position_273_comment =
  "C++ Interface:\n"
  "set_position(const OdeGeom self, const LVecBase3f pos)\n"
  "set_position(const OdeGeom self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeGeom_set_position_273_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_rotation(LMatrix3f const &r)
 */
static PyObject *Dtool_OdeGeom_set_rotation_274(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_rotation")) {
    return nullptr;
  }
  // 1-inline void OdeGeom::set_rotation(LMatrix3f const &r)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_rotation", "LMatrix3f");
  }
  ((*local_this).set_rotation)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rotation(const OdeGeom self, const LMatrix3f r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_rotation_274_comment =
  "C++ Interface:\n"
  "set_rotation(const OdeGeom self, const LMatrix3f r)\n";
#else
static const char *Dtool_OdeGeom_set_rotation_274_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_quaternion(LQuaternionf const &q)
 */
static PyObject *Dtool_OdeGeom_set_quaternion_275(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_quaternion")) {
    return nullptr;
  }
  // 1-inline void OdeGeom::set_quaternion(LQuaternionf const &q)
  LQuaternionf arg_local;
  LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_quaternion", "LQuaternionf");
  }
  ((*local_this).set_quaternion)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_quaternion(const OdeGeom self, const LQuaternionf q)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_quaternion_275_comment =
  "C++ Interface:\n"
  "set_quaternion(const OdeGeom self, const LQuaternionf q)\n";
#else
static const char *Dtool_OdeGeom_set_quaternion_275_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeGeom::get_position(void) const
 */
static PyObject *Dtool_OdeGeom_get_position_276(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-inline LPoint3f OdeGeom::get_position(void) const
  LPoint3f *return_value = new LPoint3f(((*(const OdeGeom*)local_this).get_position)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_position_276_comment =
  "C++ Interface:\n"
  "get_position(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_position_276_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3f OdeGeom::get_rotation(void) const
 */
static PyObject *Dtool_OdeGeom_get_rotation_277(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-inline LMatrix3f OdeGeom::get_rotation(void) const
  LMatrix3f *return_value = new LMatrix3f(((*(const OdeGeom*)local_this).get_rotation)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_rotation_277_comment =
  "C++ Interface:\n"
  "get_rotation(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_rotation_277_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LQuaternionf OdeGeom::get_quaternion(void) const
 */
static PyObject *Dtool_OdeGeom_get_quaternion_278(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-inline LQuaternionf OdeGeom::get_quaternion(void) const
  LQuaternionf *return_value = new LQuaternionf(((*(const OdeGeom*)local_this).get_quaternion)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_quaternion_278_comment =
  "C++ Interface:\n"
  "get_quaternion(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_quaternion_278_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::get_AABB(LVecBase3f &min, LVecBase3f &max) const
 */
static PyObject *Dtool_OdeGeom_get_AABB_279(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-inline void OdeGeom::get_AABB(LVecBase3f &min, LVecBase3f &max) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"min", "max", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_AABB", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param1_local;
    LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "OdeGeom.get_AABB", "LVecBase3f");
    }
    LVecBase3f param2_local;
    LVecBase3f *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "OdeGeom.get_AABB", "LVecBase3f");
    }
    ((*(const OdeGeom*)local_this).get_AABB)(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_AABB(OdeGeom self, LVecBase3f min, LVecBase3f max)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_AABB_279_comment =
  "C++ Interface:\n"
  "get_AABB(OdeGeom self, LVecBase3f min, LVecBase3f max)\n";
#else
static const char *Dtool_OdeGeom_get_AABB_279_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *OdeGeom::get_AA_bounds(void) const
 */
static PyObject *Dtool_OdeGeom_get_AA_bounds_280(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-inline PyObject *OdeGeom::get_AA_bounds(void) const
  PyObject *return_value = invoke_extension((const OdeGeom*)local_this).get_AA_bounds();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_AA_bounds_280_comment =
  "C++ Interface:\n"
  "get_AA_bounds(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_AA_bounds_280_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeGeom::is_space(void)
 */
static PyObject *Dtool_OdeGeom_is_space_281(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.is_space")) {
    return nullptr;
  }
  // 1-inline int OdeGeom::is_space(void)
  int return_value = ((*local_this).is_space)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_is_space_281_comment =
  "C++ Interface:\n"
  "is_space(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_is_space_281_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeGeom::get_class(void) const
 */
static PyObject *Dtool_OdeGeom_get_class_282(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-inline int OdeGeom::get_class(void) const
  int return_value = ((*(const OdeGeom*)local_this).get_class)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_class_282_comment =
  "C++ Interface:\n"
  "get_class(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_class_282_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_category_bits(BitMask32 const &bits)
 */
static PyObject *Dtool_OdeGeom_set_category_bits_283(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_category_bits")) {
    return nullptr;
  }
  // 1-inline void OdeGeom::set_category_bits(BitMask32 const &bits)
  BitMask< uint32_t, 32 > arg_local;
  BitMask32 const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_category_bits", "BitMask");
  }
  ((*local_this).set_category_bits)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_category_bits(const OdeGeom self, const BitMask bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_category_bits_283_comment =
  "C++ Interface:\n"
  "set_category_bits(const OdeGeom self, const BitMask bits)\n";
#else
static const char *Dtool_OdeGeom_set_category_bits_283_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_collide_bits(BitMask32 const &bits)
 */
static PyObject *Dtool_OdeGeom_set_collide_bits_284(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_collide_bits")) {
    return nullptr;
  }
  // 1-inline void OdeGeom::set_collide_bits(BitMask32 const &bits)
  BitMask< uint32_t, 32 > arg_local;
  BitMask32 const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_collide_bits", "BitMask");
  }
  ((*local_this).set_collide_bits)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collide_bits(const OdeGeom self, const BitMask bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_collide_bits_284_comment =
  "C++ Interface:\n"
  "set_collide_bits(const OdeGeom self, const BitMask bits)\n";
#else
static const char *Dtool_OdeGeom_set_collide_bits_284_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask32 OdeGeom::get_category_bits(void)
 */
static PyObject *Dtool_OdeGeom_get_category_bits_285(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.get_category_bits")) {
    return nullptr;
  }
  // 1-inline BitMask32 OdeGeom::get_category_bits(void)
  BitMask32 *return_value = new BitMask32(((*local_this).get_category_bits)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_category_bits_285_comment =
  "C++ Interface:\n"
  "get_category_bits(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_category_bits_285_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask32 OdeGeom::get_collide_bits(void)
 */
static PyObject *Dtool_OdeGeom_get_collide_bits_286(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.get_collide_bits")) {
    return nullptr;
  }
  // 1-inline BitMask32 OdeGeom::get_collide_bits(void)
  BitMask32 *return_value = new BitMask32(((*local_this).get_collide_bits)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_collide_bits_286_comment =
  "C++ Interface:\n"
  "get_collide_bits(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_collide_bits_286_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::enable(void)
 */
static PyObject *Dtool_OdeGeom_enable_287(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.enable")) {
    return nullptr;
  }
  // 1-inline void OdeGeom::enable(void)
  ((*local_this).enable)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_enable_287_comment =
  "C++ Interface:\n"
  "enable(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_enable_287_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::disable(void)
 */
static PyObject *Dtool_OdeGeom_disable_288(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.disable")) {
    return nullptr;
  }
  // 1-inline void OdeGeom::disable(void)
  ((*local_this).disable)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_disable_288_comment =
  "C++ Interface:\n"
  "disable(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_disable_288_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeGeom::is_enabled(void)
 */
static PyObject *Dtool_OdeGeom_is_enabled_289(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.is_enabled")) {
    return nullptr;
  }
  // 1-inline int OdeGeom::is_enabled(void)
  int return_value = ((*local_this).is_enabled)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_is_enabled_289_comment =
  "C++ Interface:\n"
  "is_enabled(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_is_enabled_289_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_offset_position(LVecBase3f const &pos)
 * inline void OdeGeom::set_offset_position(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeGeom_set_offset_position_290(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_offset_position")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-inline void OdeGeom::set_offset_position(LVecBase3f const &pos)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_offset_position", "LVecBase3f");
        }
        ((*local_this).set_offset_position)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeGeom::set_offset_position(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_offset_position", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_offset_position)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_offset_position() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset_position(const OdeGeom self, const LVecBase3f pos)\n"
      "set_offset_position(const OdeGeom self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_offset_position_290_comment =
  "C++ Interface:\n"
  "set_offset_position(const OdeGeom self, const LVecBase3f pos)\n"
  "set_offset_position(const OdeGeom self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeGeom_set_offset_position_290_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_offset_rotation(LMatrix3f const &r)
 */
static PyObject *Dtool_OdeGeom_set_offset_rotation_291(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_offset_rotation")) {
    return nullptr;
  }
  // 1-inline void OdeGeom::set_offset_rotation(LMatrix3f const &r)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_offset_rotation", "LMatrix3f");
  }
  ((*local_this).set_offset_rotation)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset_rotation(const OdeGeom self, const LMatrix3f r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_offset_rotation_291_comment =
  "C++ Interface:\n"
  "set_offset_rotation(const OdeGeom self, const LMatrix3f r)\n";
#else
static const char *Dtool_OdeGeom_set_offset_rotation_291_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_offset_quaternion(LQuaternionf const &q)
 */
static PyObject *Dtool_OdeGeom_set_offset_quaternion_292(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_offset_quaternion")) {
    return nullptr;
  }
  // 1-inline void OdeGeom::set_offset_quaternion(LQuaternionf const &q)
  LQuaternionf arg_local;
  LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_offset_quaternion", "LQuaternionf");
  }
  ((*local_this).set_offset_quaternion)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset_quaternion(const OdeGeom self, const LQuaternionf q)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_offset_quaternion_292_comment =
  "C++ Interface:\n"
  "set_offset_quaternion(const OdeGeom self, const LQuaternionf q)\n";
#else
static const char *Dtool_OdeGeom_set_offset_quaternion_292_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_offset_world_position(LVecBase3f const &pos)
 * inline void OdeGeom::set_offset_world_position(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeGeom_set_offset_world_position_293(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_offset_world_position")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-inline void OdeGeom::set_offset_world_position(LVecBase3f const &pos)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_offset_world_position", "LVecBase3f");
        }
        ((*local_this).set_offset_world_position)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeGeom::set_offset_world_position(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_offset_world_position", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_offset_world_position)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_offset_world_position() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset_world_position(const OdeGeom self, const LVecBase3f pos)\n"
      "set_offset_world_position(const OdeGeom self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_offset_world_position_293_comment =
  "C++ Interface:\n"
  "set_offset_world_position(const OdeGeom self, const LVecBase3f pos)\n"
  "set_offset_world_position(const OdeGeom self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeGeom_set_offset_world_position_293_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_offset_world_rotation(LMatrix3f const &r)
 */
static PyObject *Dtool_OdeGeom_set_offset_world_rotation_294(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_offset_world_rotation")) {
    return nullptr;
  }
  // 1-inline void OdeGeom::set_offset_world_rotation(LMatrix3f const &r)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_offset_world_rotation", "LMatrix3f");
  }
  ((*local_this).set_offset_world_rotation)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset_world_rotation(const OdeGeom self, const LMatrix3f r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_offset_world_rotation_294_comment =
  "C++ Interface:\n"
  "set_offset_world_rotation(const OdeGeom self, const LMatrix3f r)\n";
#else
static const char *Dtool_OdeGeom_set_offset_world_rotation_294_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::set_offset_world_quaternion(LQuaternionf const &q)
 */
static PyObject *Dtool_OdeGeom_set_offset_world_quaternion_295(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.set_offset_world_quaternion")) {
    return nullptr;
  }
  // 1-inline void OdeGeom::set_offset_world_quaternion(LQuaternionf const &q)
  LQuaternionf arg_local;
  LQuaternionf const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeGeom.set_offset_world_quaternion", "LQuaternionf");
  }
  ((*local_this).set_offset_world_quaternion)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_offset_world_quaternion(const OdeGeom self, const LQuaternionf q)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_set_offset_world_quaternion_295_comment =
  "C++ Interface:\n"
  "set_offset_world_quaternion(const OdeGeom self, const LQuaternionf q)\n";
#else
static const char *Dtool_OdeGeom_set_offset_world_quaternion_295_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeGeom::clear_offset(void)
 */
static PyObject *Dtool_OdeGeom_clear_offset_296(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.clear_offset")) {
    return nullptr;
  }
  // 1-inline void OdeGeom::clear_offset(void)
  ((*local_this).clear_offset)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_clear_offset_296_comment =
  "C++ Interface:\n"
  "clear_offset(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_clear_offset_296_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeGeom::is_offset(void)
 */
static PyObject *Dtool_OdeGeom_is_offset_297(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeGeom, (void **)&local_this, "OdeGeom.is_offset")) {
    return nullptr;
  }
  // 1-inline int OdeGeom::is_offset(void)
  int return_value = ((*local_this).is_offset)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_is_offset_297_comment =
  "C++ Interface:\n"
  "is_offset(const OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_is_offset_297_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeGeom::get_offset_position(void) const
 */
static PyObject *Dtool_OdeGeom_get_offset_position_298(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-inline LPoint3f OdeGeom::get_offset_position(void) const
  LPoint3f *return_value = new LPoint3f(((*(const OdeGeom*)local_this).get_offset_position)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_offset_position_298_comment =
  "C++ Interface:\n"
  "get_offset_position(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_offset_position_298_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3f OdeGeom::get_offset_rotation(void) const
 */
static PyObject *Dtool_OdeGeom_get_offset_rotation_299(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-inline LMatrix3f OdeGeom::get_offset_rotation(void) const
  LMatrix3f *return_value = new LMatrix3f(((*(const OdeGeom*)local_this).get_offset_rotation)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_offset_rotation_299_comment =
  "C++ Interface:\n"
  "get_offset_rotation(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_offset_rotation_299_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LQuaternionf OdeGeom::get_offset_quaternion(void) const
 */
static PyObject *Dtool_OdeGeom_get_offset_quaternion_300(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-inline LQuaternionf OdeGeom::get_offset_quaternion(void) const
  LQuaternionf *return_value = new LQuaternionf(((*(const OdeGeom*)local_this).get_offset_quaternion)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LQuaternionf, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_offset_quaternion_300_comment =
  "C++ Interface:\n"
  "get_offset_quaternion(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_offset_quaternion_300_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeSpace OdeGeom::get_space(void) const
 */
static PyObject *Dtool_OdeGeom_get_space_301(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-OdeSpace OdeGeom::get_space(void) const
  OdeSpace *return_value = new OdeSpace(((*(const OdeGeom*)local_this).get_space)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeSpace, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_space_301_comment =
  "C++ Interface:\n"
  "get_space(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_space_301_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PyObject *OdeGeom::get_converted_space(void) const
 */
static PyObject *Dtool_OdeGeom_get_converted_space_302(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-inline PyObject *OdeGeom::get_converted_space(void) const
  PyObject *return_value = invoke_extension((const OdeGeom*)local_this).get_converted_space();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_converted_space_302_comment =
  "C++ Interface:\n"
  "get_converted_space(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_get_converted_space_302_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void OdeGeom::write(std::ostream &out = ::std::cout, unsigned int indent = 0) const
 */
static PyObject *Dtool_OdeGeom_write_303(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-virtual void OdeGeom::write(std::ostream &out = ::std::cout, unsigned int indent = 0) const
  PyObject *param1 = nullptr;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|Ok:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this;
    if (param1 == nullptr) {
      param1_this = &(std::cout);
    } else {
      param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "OdeGeom.write", false, true);
    }
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*(const OdeGeom*)local_this).write)(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(OdeGeom self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_write_303_comment =
  "C++ Interface:\n"
  "write(OdeGeom self, ostream out, int indent)\n";
#else
static const char *Dtool_OdeGeom_write_303_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeGeom::compare_to(OdeGeom const &other) const
 */
static PyObject *Dtool_OdeGeom_compare_to_305(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-inline int OdeGeom::compare_to(OdeGeom const &other) const
  OdeGeom const *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeGeom.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const OdeGeom*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(OdeGeom self, const OdeGeom other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_compare_to_305_comment =
  "C++ Interface:\n"
  "compare_to(OdeGeom self, const OdeGeom other)\n";
#else
static const char *Dtool_OdeGeom_compare_to_305_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *OdeGeom::convert(void) const
 */
static PyObject *Dtool_OdeGeom_convert_306(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-PyObject *OdeGeom::convert(void) const
  PyObject *return_value = invoke_extension((const OdeGeom*)local_this).convert();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_306_comment =
  "C++ Interface:\n"
  "convert(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_306_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeBoxGeom OdeGeom::convert_to_box(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_box_307(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-OdeBoxGeom OdeGeom::convert_to_box(void) const
  OdeBoxGeom *return_value = new OdeBoxGeom(((*(const OdeGeom*)local_this).convert_to_box)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeBoxGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_box_307_comment =
  "C++ Interface:\n"
  "convert_to_box(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_to_box_307_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeCappedCylinderGeom OdeGeom::convert_to_capped_cylinder(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_capped_cylinder_308(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-OdeCappedCylinderGeom OdeGeom::convert_to_capped_cylinder(void) const
  OdeCappedCylinderGeom *return_value = new OdeCappedCylinderGeom(((*(const OdeGeom*)local_this).convert_to_capped_cylinder)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeCappedCylinderGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_capped_cylinder_308_comment =
  "C++ Interface:\n"
  "convert_to_capped_cylinder(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_to_capped_cylinder_308_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeCylinderGeom OdeGeom::convert_to_cylinder(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_cylinder_309(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-OdeCylinderGeom OdeGeom::convert_to_cylinder(void) const
  OdeCylinderGeom *return_value = new OdeCylinderGeom(((*(const OdeGeom*)local_this).convert_to_cylinder)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeCylinderGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_cylinder_309_comment =
  "C++ Interface:\n"
  "convert_to_cylinder(OdeGeom self)\n"
  "\n"
  "// OdeConvexGeom convert_to_convex() const;";
#else
static const char *Dtool_OdeGeom_convert_to_cylinder_309_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdePlaneGeom OdeGeom::convert_to_plane(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_plane_310(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-OdePlaneGeom OdeGeom::convert_to_plane(void) const
  OdePlaneGeom *return_value = new OdePlaneGeom(((*(const OdeGeom*)local_this).convert_to_plane)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdePlaneGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_plane_310_comment =
  "C++ Interface:\n"
  "convert_to_plane(OdeGeom self)\n"
  "\n"
  "// OdeHeightfieldGeom convert_to_heightfield() const;";
#else
static const char *Dtool_OdeGeom_convert_to_plane_310_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeRayGeom OdeGeom::convert_to_ray(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_ray_311(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-OdeRayGeom OdeGeom::convert_to_ray(void) const
  OdeRayGeom *return_value = new OdeRayGeom(((*(const OdeGeom*)local_this).convert_to_ray)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeRayGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_ray_311_comment =
  "C++ Interface:\n"
  "convert_to_ray(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_to_ray_311_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeSphereGeom OdeGeom::convert_to_sphere(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_sphere_312(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-OdeSphereGeom OdeGeom::convert_to_sphere(void) const
  OdeSphereGeom *return_value = new OdeSphereGeom(((*(const OdeGeom*)local_this).convert_to_sphere)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeSphereGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_sphere_312_comment =
  "C++ Interface:\n"
  "convert_to_sphere(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_to_sphere_312_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeTriMeshGeom OdeGeom::convert_to_tri_mesh(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_tri_mesh_313(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-OdeTriMeshGeom OdeGeom::convert_to_tri_mesh(void) const
  OdeTriMeshGeom *return_value = new OdeTriMeshGeom(((*(const OdeGeom*)local_this).convert_to_tri_mesh)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeTriMeshGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_tri_mesh_313_comment =
  "C++ Interface:\n"
  "convert_to_tri_mesh(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_to_tri_mesh_313_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeSimpleSpace OdeGeom::convert_to_simple_space(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_simple_space_314(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-OdeSimpleSpace OdeGeom::convert_to_simple_space(void) const
  OdeSimpleSpace *return_value = new OdeSimpleSpace(((*(const OdeGeom*)local_this).convert_to_simple_space)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeSimpleSpace, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_simple_space_314_comment =
  "C++ Interface:\n"
  "convert_to_simple_space(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_to_simple_space_314_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeHashSpace OdeGeom::convert_to_hash_space(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_hash_space_315(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-OdeHashSpace OdeGeom::convert_to_hash_space(void) const
  OdeHashSpace *return_value = new OdeHashSpace(((*(const OdeGeom*)local_this).convert_to_hash_space)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeHashSpace, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_hash_space_315_comment =
  "C++ Interface:\n"
  "convert_to_hash_space(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_to_hash_space_315_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeQuadTreeSpace OdeGeom::convert_to_quad_tree_space(void) const
 */
static PyObject *Dtool_OdeGeom_convert_to_quad_tree_space_316(PyObject *self, PyObject *) {
  OdeGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeGeom)) {
    return nullptr;
  }
  // 1-OdeQuadTreeSpace OdeGeom::convert_to_quad_tree_space(void) const
  OdeQuadTreeSpace *return_value = new OdeQuadTreeSpace(((*(const OdeGeom*)local_this).convert_to_quad_tree_space)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeQuadTreeSpace, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_convert_to_quad_tree_space_316_comment =
  "C++ Interface:\n"
  "convert_to_quad_tree_space(OdeGeom self)\n";
#else
static const char *Dtool_OdeGeom_convert_to_quad_tree_space_316_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeGeom::get_class_type(void)
 */
static PyObject *Dtool_OdeGeom_get_class_type_317(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeGeom::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeGeom_get_class_type_317_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeGeom_get_class_type_317_comment = nullptr;
#endif

static int Dtool_Init_OdeGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_OdeGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeGeom) {
    printf("OdeGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeGeom *local_this = (OdeGeom *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeGeom*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeBoxGeom
 */
/**
 * Python function wrapper for:
 * inline void OdeBoxGeom::set_lengths(LVecBase3f const &size)
 * inline void OdeBoxGeom::set_lengths(dReal lx, dReal ly, dReal lz)
 */
static PyObject *Dtool_OdeBoxGeom_set_lengths_320(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBoxGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBoxGeom, (void **)&local_this, "OdeBoxGeom.set_lengths")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "size")) {
        // 1-inline void OdeBoxGeom::set_lengths(LVecBase3f const &size)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBoxGeom.set_lengths", "LVecBase3f");
        }
        ((*local_this).set_lengths)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeBoxGeom::set_lengths(dReal lx, dReal ly, dReal lz)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"lx", "ly", "lz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_lengths", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_lengths)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_lengths() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_lengths(const OdeBoxGeom self, const LVecBase3f size)\n"
      "set_lengths(const OdeBoxGeom self, float lx, float ly, float lz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBoxGeom_set_lengths_320_comment =
  "C++ Interface:\n"
  "set_lengths(const OdeBoxGeom self, const LVecBase3f size)\n"
  "set_lengths(const OdeBoxGeom self, float lx, float ly, float lz)\n";
#else
static const char *Dtool_OdeBoxGeom_set_lengths_320_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeBoxGeom::get_lengths(void)
 */
static PyObject *Dtool_OdeBoxGeom_get_lengths_321(PyObject *self, PyObject *) {
  OdeBoxGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBoxGeom, (void **)&local_this, "OdeBoxGeom.get_lengths")) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeBoxGeom::get_lengths(void)
  LVecBase3f *return_value = new LVecBase3f(((*local_this).get_lengths)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBoxGeom_get_lengths_321_comment =
  "C++ Interface:\n"
  "get_lengths(const OdeBoxGeom self)\n";
#else
static const char *Dtool_OdeBoxGeom_get_lengths_321_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeBoxGeom::get_point_depth(LPoint3f const &p)
 * inline dReal OdeBoxGeom::get_point_depth(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeBoxGeom_get_point_depth_322(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeBoxGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeBoxGeom, (void **)&local_this, "OdeBoxGeom.get_point_depth")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "p")) {
        // 1-inline dReal OdeBoxGeom::get_point_depth(LPoint3f const &p)
        LPoint3f arg_local;
        LPoint3f const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeBoxGeom.get_point_depth", "LPoint3f");
        }
        dReal return_value = ((*local_this).get_point_depth)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-inline dReal OdeBoxGeom::get_point_depth(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:get_point_depth", (char **)keyword_list, &param1, &param2, &param3)) {
        dReal return_value = ((*local_this).get_point_depth)((dReal)param1, (dReal)param2, (dReal)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_point_depth() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point_depth(const OdeBoxGeom self, const LPoint3f p)\n"
      "get_point_depth(const OdeBoxGeom self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeBoxGeom_get_point_depth_322_comment =
  "C++ Interface:\n"
  "get_point_depth(const OdeBoxGeom self, const LPoint3f p)\n"
  "get_point_depth(const OdeBoxGeom self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeBoxGeom_get_point_depth_322_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeBoxGeom::get_class_type(void)
 */
static PyObject *Dtool_OdeBoxGeom_get_class_type_323(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeBoxGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeBoxGeom::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeBoxGeom_get_class_type_323_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeBoxGeom_get_class_type_323_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeBoxGeom::OdeBoxGeom(OdeSpace &space, LVecBase3f const &size)
 * OdeBoxGeom::OdeBoxGeom(OdeSpace &space, dReal lx, dReal ly, dReal lz)
 * OdeBoxGeom::OdeBoxGeom(dReal lx, dReal ly, dReal lz)
 */
static int Dtool_Init_OdeBoxGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-OdeBoxGeom::OdeBoxGeom(OdeSpace &space, LVecBase3f const &size)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"space", "size", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeBoxGeom", (char **)keyword_list, &param0, &param1)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeBoxGeom.OdeBoxGeom", false, true);
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "OdeBoxGeom.OdeBoxGeom", "LVecBase3f");
          return -1;
        }
        if (param0_this != nullptr) {
          OdeBoxGeom *return_value = new OdeBoxGeom(*param0_this, *param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeBoxGeom, true, false);
        }
      }
    }
    break;
  case 3:
    {
      // 1-OdeBoxGeom::OdeBoxGeom(dReal lx, dReal ly, dReal lz)
      float param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"lx", "ly", "lz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:OdeBoxGeom", (char **)keyword_list, &param0, &param1, &param2)) {
        OdeBoxGeom *return_value = new OdeBoxGeom((dReal)param0, (dReal)param1, (dReal)param2);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeBoxGeom, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-OdeBoxGeom::OdeBoxGeom(OdeSpace &space, dReal lx, dReal ly, dReal lz)
      PyObject *param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"space", "lx", "ly", "lz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offf:OdeBoxGeom", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeBoxGeom.OdeBoxGeom", false, true);
        if (param0_this != nullptr) {
          OdeBoxGeom *return_value = new OdeBoxGeom(*param0_this, (dReal)param1, (dReal)param2, (dReal)param3);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeBoxGeom, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeBoxGeom() takes 2, 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeBoxGeom(OdeSpace space, const LVecBase3f size)\n"
      "OdeBoxGeom(float lx, float ly, float lz)\n"
      "OdeBoxGeom(OdeSpace space, float lx, float ly, float lz)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeBoxGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeBoxGeom) {
    printf("OdeBoxGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeBoxGeom *local_this = (OdeBoxGeom *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeBoxGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeGeom) {
    return (OdeGeom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeGeom *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeBoxGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeBoxGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeGeom) {
    OdeGeom* other_this = (OdeGeom*)from_this;
    return (OdeBoxGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeBoxGeom*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeCappedCylinderGeom
 */
/**
 * Python function wrapper for:
 * inline void OdeCappedCylinderGeom::set_params(dReal radius, dReal length)
 */
static PyObject *Dtool_OdeCappedCylinderGeom_set_params_326(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeCappedCylinderGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeCappedCylinderGeom, (void **)&local_this, "OdeCappedCylinderGeom.set_params")) {
    return nullptr;
  }
  // 1-inline void OdeCappedCylinderGeom::set_params(dReal radius, dReal length)
  float param1;
  float param2;
  static const char *keyword_list[] = {"radius", "length", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_params", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_params)((dReal)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_params(const OdeCappedCylinderGeom self, float radius, float length)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeCappedCylinderGeom_set_params_326_comment =
  "C++ Interface:\n"
  "set_params(const OdeCappedCylinderGeom self, float radius, float length)\n";
#else
static const char *Dtool_OdeCappedCylinderGeom_set_params_326_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeCappedCylinderGeom::get_radius(void) const
 */
static PyObject *Dtool_OdeCappedCylinderGeom_get_radius_328(PyObject *self, PyObject *) {
  OdeCappedCylinderGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeCappedCylinderGeom)) {
    return nullptr;
  }
  // 1-inline dReal OdeCappedCylinderGeom::get_radius(void) const
  dReal return_value = ((*(const OdeCappedCylinderGeom*)local_this).get_radius)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeCappedCylinderGeom_get_radius_328_comment =
  "C++ Interface:\n"
  "get_radius(OdeCappedCylinderGeom self)\n";
#else
static const char *Dtool_OdeCappedCylinderGeom_get_radius_328_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeCappedCylinderGeom::get_length(void) const
 */
static PyObject *Dtool_OdeCappedCylinderGeom_get_length_329(PyObject *self, PyObject *) {
  OdeCappedCylinderGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeCappedCylinderGeom)) {
    return nullptr;
  }
  // 1-inline dReal OdeCappedCylinderGeom::get_length(void) const
  dReal return_value = ((*(const OdeCappedCylinderGeom*)local_this).get_length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeCappedCylinderGeom_get_length_329_comment =
  "C++ Interface:\n"
  "get_length(OdeCappedCylinderGeom self)\n";
#else
static const char *Dtool_OdeCappedCylinderGeom_get_length_329_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeCappedCylinderGeom::get_point_depth(LPoint3f const &p) const
 * inline dReal OdeCappedCylinderGeom::get_point_depth(dReal x, dReal y, dReal z) const
 */
static PyObject *Dtool_OdeCappedCylinderGeom_get_point_depth_330(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeCappedCylinderGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeCappedCylinderGeom)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "p")) {
        // 1-inline dReal OdeCappedCylinderGeom::get_point_depth(LPoint3f const &p) const
        LPoint3f arg_local;
        LPoint3f const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeCappedCylinderGeom.get_point_depth", "LPoint3f");
        }
        dReal return_value = ((*(const OdeCappedCylinderGeom*)local_this).get_point_depth)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-inline dReal OdeCappedCylinderGeom::get_point_depth(dReal x, dReal y, dReal z) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:get_point_depth", (char **)keyword_list, &param1, &param2, &param3)) {
        dReal return_value = ((*(const OdeCappedCylinderGeom*)local_this).get_point_depth)((dReal)param1, (dReal)param2, (dReal)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_point_depth() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point_depth(OdeCappedCylinderGeom self, const LPoint3f p)\n"
      "get_point_depth(OdeCappedCylinderGeom self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeCappedCylinderGeom_get_point_depth_330_comment =
  "C++ Interface:\n"
  "get_point_depth(OdeCappedCylinderGeom self, const LPoint3f p)\n"
  "get_point_depth(OdeCappedCylinderGeom self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeCappedCylinderGeom_get_point_depth_330_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeCappedCylinderGeom::get_class_type(void)
 */
static PyObject *Dtool_OdeCappedCylinderGeom_get_class_type_331(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeCappedCylinderGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeCappedCylinderGeom::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeCappedCylinderGeom_get_class_type_331_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeCappedCylinderGeom_get_class_type_331_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeCappedCylinderGeom::OdeCappedCylinderGeom(OdeSpace &space, dReal radius, dReal length)
 * OdeCappedCylinderGeom::OdeCappedCylinderGeom(dReal radius, dReal length)
 */
static int Dtool_Init_OdeCappedCylinderGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-OdeCappedCylinderGeom::OdeCappedCylinderGeom(dReal radius, dReal length)
      float param0;
      float param1;
      static const char *keyword_list[] = {"radius", "length", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:OdeCappedCylinderGeom", (char **)keyword_list, &param0, &param1)) {
        OdeCappedCylinderGeom *return_value = new OdeCappedCylinderGeom((dReal)param0, (dReal)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeCappedCylinderGeom, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-OdeCappedCylinderGeom::OdeCappedCylinderGeom(OdeSpace &space, dReal radius, dReal length)
      PyObject *param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"space", "radius", "length", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:OdeCappedCylinderGeom", (char **)keyword_list, &param0, &param1, &param2)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeCappedCylinderGeom.OdeCappedCylinderGeom", false, true);
        if (param0_this != nullptr) {
          OdeCappedCylinderGeom *return_value = new OdeCappedCylinderGeom(*param0_this, (dReal)param1, (dReal)param2);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeCappedCylinderGeom, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeCappedCylinderGeom() takes 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeCappedCylinderGeom(float radius, float length)\n"
      "OdeCappedCylinderGeom(OdeSpace space, float radius, float length)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeCappedCylinderGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeCappedCylinderGeom) {
    printf("OdeCappedCylinderGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeCappedCylinderGeom *local_this = (OdeCappedCylinderGeom *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeCappedCylinderGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeGeom) {
    return (OdeGeom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeGeom *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeCappedCylinderGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeCappedCylinderGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeGeom) {
    OdeGeom* other_this = (OdeGeom*)from_this;
    return (OdeCappedCylinderGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeCappedCylinderGeom*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeContactGeom
 */
/**
 * Python function wrapper for:
 * inline LVecBase3f OdeContactGeom::get_pos(void) const
 */
static PyObject *Dtool_OdeContactGeom_get_pos_334(PyObject *self, PyObject *) {
  OdeContactGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeContactGeom)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeContactGeom::get_pos(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeContactGeom*)local_this).get_pos)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_get_pos_334_comment =
  "C++ Interface:\n"
  "get_pos(OdeContactGeom self)\n";
#else
static const char *Dtool_OdeContactGeom_get_pos_334_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeContactGeom::get_normal(void) const
 */
static PyObject *Dtool_OdeContactGeom_get_normal_335(PyObject *self, PyObject *) {
  OdeContactGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeContactGeom)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeContactGeom::get_normal(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeContactGeom*)local_this).get_normal)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_get_normal_335_comment =
  "C++ Interface:\n"
  "get_normal(OdeContactGeom self)\n";
#else
static const char *Dtool_OdeContactGeom_get_normal_335_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeContactGeom::get_depth(void) const
 */
static PyObject *Dtool_OdeContactGeom_get_depth_336(PyObject *self, PyObject *) {
  OdeContactGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeContactGeom)) {
    return nullptr;
  }
  // 1-inline dReal OdeContactGeom::get_depth(void) const
  dReal return_value = ((*(const OdeContactGeom*)local_this).get_depth)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_get_depth_336_comment =
  "C++ Interface:\n"
  "get_depth(OdeContactGeom self)\n";
#else
static const char *Dtool_OdeContactGeom_get_depth_336_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OdeGeom OdeContactGeom::get_g1(void) const
 */
static PyObject *Dtool_OdeContactGeom_get_g1_337(PyObject *self, PyObject *) {
  OdeContactGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeContactGeom)) {
    return nullptr;
  }
  // 1-inline OdeGeom OdeContactGeom::get_g1(void) const
  OdeGeom *return_value = new OdeGeom(((*(const OdeContactGeom*)local_this).get_g1)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_get_g1_337_comment =
  "C++ Interface:\n"
  "get_g1(OdeContactGeom self)\n";
#else
static const char *Dtool_OdeContactGeom_get_g1_337_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OdeGeom OdeContactGeom::get_g2(void) const
 */
static PyObject *Dtool_OdeContactGeom_get_g2_338(PyObject *self, PyObject *) {
  OdeContactGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeContactGeom)) {
    return nullptr;
  }
  // 1-inline OdeGeom OdeContactGeom::get_g2(void) const
  OdeGeom *return_value = new OdeGeom(((*(const OdeContactGeom*)local_this).get_g2)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_get_g2_338_comment =
  "C++ Interface:\n"
  "get_g2(OdeContactGeom self)\n";
#else
static const char *Dtool_OdeContactGeom_get_g2_338_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeContactGeom::get_side1(void) const
 */
static PyObject *Dtool_OdeContactGeom_get_side1_339(PyObject *self, PyObject *) {
  OdeContactGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeContactGeom)) {
    return nullptr;
  }
  // 1-inline int OdeContactGeom::get_side1(void) const
  int return_value = ((*(const OdeContactGeom*)local_this).get_side1)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_get_side1_339_comment =
  "C++ Interface:\n"
  "get_side1(OdeContactGeom self)\n";
#else
static const char *Dtool_OdeContactGeom_get_side1_339_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeContactGeom::get_side2(void) const
 */
static PyObject *Dtool_OdeContactGeom_get_side2_340(PyObject *self, PyObject *) {
  OdeContactGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeContactGeom)) {
    return nullptr;
  }
  // 1-inline int OdeContactGeom::get_side2(void) const
  int return_value = ((*(const OdeContactGeom*)local_this).get_side2)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_get_side2_340_comment =
  "C++ Interface:\n"
  "get_side2(OdeContactGeom self)\n";
#else
static const char *Dtool_OdeContactGeom_get_side2_340_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeContactGeom::set_pos(LVecBase3f const &pos)
 */
static PyObject *Dtool_OdeContactGeom_set_pos_341(PyObject *self, PyObject *arg) {
  OdeContactGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContactGeom, (void **)&local_this, "OdeContactGeom.set_pos")) {
    return nullptr;
  }
  // 1-inline void OdeContactGeom::set_pos(LVecBase3f const &pos)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeContactGeom.set_pos", "LVecBase3f");
  }
  ((*local_this).set_pos)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos(const OdeContactGeom self, const LVecBase3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_set_pos_341_comment =
  "C++ Interface:\n"
  "set_pos(const OdeContactGeom self, const LVecBase3f pos)\n";
#else
static const char *Dtool_OdeContactGeom_set_pos_341_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeContactGeom::set_normal(LVecBase3f const &normal)
 */
static PyObject *Dtool_OdeContactGeom_set_normal_342(PyObject *self, PyObject *arg) {
  OdeContactGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContactGeom, (void **)&local_this, "OdeContactGeom.set_normal")) {
    return nullptr;
  }
  // 1-inline void OdeContactGeom::set_normal(LVecBase3f const &normal)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeContactGeom.set_normal", "LVecBase3f");
  }
  ((*local_this).set_normal)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_normal(const OdeContactGeom self, const LVecBase3f normal)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_set_normal_342_comment =
  "C++ Interface:\n"
  "set_normal(const OdeContactGeom self, const LVecBase3f normal)\n";
#else
static const char *Dtool_OdeContactGeom_set_normal_342_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeContactGeom::set_depth(dReal const depth)
 */
static PyObject *Dtool_OdeContactGeom_set_depth_343(PyObject *self, PyObject *arg) {
  OdeContactGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContactGeom, (void **)&local_this, "OdeContactGeom.set_depth")) {
    return nullptr;
  }
  // 1-inline void OdeContactGeom::set_depth(dReal const depth)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_depth)((dReal const)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_depth(const OdeContactGeom self, float depth)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_set_depth_343_comment =
  "C++ Interface:\n"
  "set_depth(const OdeContactGeom self, float depth)\n";
#else
static const char *Dtool_OdeContactGeom_set_depth_343_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeContactGeom::set_g1(OdeGeom const &geom)
 */
static PyObject *Dtool_OdeContactGeom_set_g1_344(PyObject *self, PyObject *arg) {
  OdeContactGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContactGeom, (void **)&local_this, "OdeContactGeom.set_g1")) {
    return nullptr;
  }
  // 1-inline void OdeContactGeom::set_g1(OdeGeom const &geom)
  OdeGeom const *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeContactGeom.set_g1", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_g1)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_g1(const OdeContactGeom self, const OdeGeom geom)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_set_g1_344_comment =
  "C++ Interface:\n"
  "set_g1(const OdeContactGeom self, const OdeGeom geom)\n";
#else
static const char *Dtool_OdeContactGeom_set_g1_344_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeContactGeom::set_g2(OdeGeom const &geom)
 */
static PyObject *Dtool_OdeContactGeom_set_g2_345(PyObject *self, PyObject *arg) {
  OdeContactGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContactGeom, (void **)&local_this, "OdeContactGeom.set_g2")) {
    return nullptr;
  }
  // 1-inline void OdeContactGeom::set_g2(OdeGeom const &geom)
  OdeGeom const *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeContactGeom.set_g2", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_g2)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_g2(const OdeContactGeom self, const OdeGeom geom)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_set_g2_345_comment =
  "C++ Interface:\n"
  "set_g2(const OdeContactGeom self, const OdeGeom geom)\n";
#else
static const char *Dtool_OdeContactGeom_set_g2_345_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeContactGeom::get_class_type(void)
 */
static PyObject *Dtool_OdeContactGeom_get_class_type_346(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeContactGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeContactGeom::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeContactGeom_get_class_type_346_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeContactGeom_get_class_type_346_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeContactGeom::OdeContactGeom(void)
 * OdeContactGeom::OdeContactGeom(OdeContactGeom const &copy)
 */
static int Dtool_Init_OdeContactGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-OdeContactGeom::OdeContactGeom(void)
      OdeContactGeom *return_value = new OdeContactGeom();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeContactGeom, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-OdeContactGeom::OdeContactGeom(OdeContactGeom const &copy)
        OdeContactGeom const *arg_this = (OdeContactGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeContactGeom, 0, "OdeContactGeom.OdeContactGeom", true, true);
        if (arg_this != nullptr) {
          OdeContactGeom *return_value = new OdeContactGeom(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeContactGeom, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeContactGeom() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeContactGeom()\n"
      "OdeContactGeom(const OdeContactGeom copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeContactGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeContactGeom) {
    printf("OdeContactGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeContactGeom *local_this = (OdeContactGeom *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeContactGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeContactGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeContactGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (OdeContactGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeContactGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (OdeContactGeom*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeCollisionEntry
 */
/**
 * Python function wrapper for:
 * inline OdeGeom OdeCollisionEntry::get_geom1(void) const
 */
static PyObject *Dtool_OdeCollisionEntry_get_geom1_348(PyObject *self, PyObject *) {
  OdeCollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeCollisionEntry)) {
    return nullptr;
  }
  // 1-inline OdeGeom OdeCollisionEntry::get_geom1(void) const
  OdeGeom *return_value = new OdeGeom(((*(const OdeCollisionEntry*)local_this).get_geom1)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_get_geom1_348_comment =
  "C++ Interface:\n"
  "get_geom1(OdeCollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the first geom in the collision.\n"
  " */";
#else
static const char *Dtool_OdeCollisionEntry_get_geom1_348_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OdeGeom OdeCollisionEntry::get_geom2(void) const
 */
static PyObject *Dtool_OdeCollisionEntry_get_geom2_349(PyObject *self, PyObject *) {
  OdeCollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeCollisionEntry)) {
    return nullptr;
  }
  // 1-inline OdeGeom OdeCollisionEntry::get_geom2(void) const
  OdeGeom *return_value = new OdeGeom(((*(const OdeCollisionEntry*)local_this).get_geom2)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_get_geom2_349_comment =
  "C++ Interface:\n"
  "get_geom2(OdeCollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the second geom in the collision.\n"
  " */";
#else
static const char *Dtool_OdeCollisionEntry_get_geom2_349_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OdeBody OdeCollisionEntry::get_body1(void) const
 */
static PyObject *Dtool_OdeCollisionEntry_get_body1_350(PyObject *self, PyObject *) {
  OdeCollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeCollisionEntry)) {
    return nullptr;
  }
  // 1-inline OdeBody OdeCollisionEntry::get_body1(void) const
  OdeBody *return_value = new OdeBody(((*(const OdeCollisionEntry*)local_this).get_body1)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeBody, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_get_body1_350_comment =
  "C++ Interface:\n"
  "get_body1(OdeCollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the first body in the collision.\n"
  " */";
#else
static const char *Dtool_OdeCollisionEntry_get_body1_350_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OdeBody OdeCollisionEntry::get_body2(void) const
 */
static PyObject *Dtool_OdeCollisionEntry_get_body2_351(PyObject *self, PyObject *) {
  OdeCollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeCollisionEntry)) {
    return nullptr;
  }
  // 1-inline OdeBody OdeCollisionEntry::get_body2(void) const
  OdeBody *return_value = new OdeBody(((*(const OdeCollisionEntry*)local_this).get_body2)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeBody, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_get_body2_351_comment =
  "C++ Interface:\n"
  "get_body2(OdeCollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the second body in the collision.\n"
  " */";
#else
static const char *Dtool_OdeCollisionEntry_get_body2_351_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t OdeCollisionEntry::get_num_contacts(void) const
 */
static PyObject *Dtool_OdeCollisionEntry_get_num_contacts_352(PyObject *self, PyObject *) {
  OdeCollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeCollisionEntry)) {
    return nullptr;
  }
  // 1-inline std::size_t OdeCollisionEntry::get_num_contacts(void) const
  std::size_t return_value = ((*(const OdeCollisionEntry*)local_this).get_num_contacts)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_get_num_contacts_352_comment =
  "C++ Interface:\n"
  "get_num_contacts(OdeCollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns the number of contacts in the collision.\n"
  " */";
#else
static const char *Dtool_OdeCollisionEntry_get_num_contacts_352_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeCollisionEntry::get_contact_point(std::size_t n) const
 */
static PyObject *Dtool_OdeCollisionEntry_get_contact_point_353(PyObject *self, PyObject *arg) {
  OdeCollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeCollisionEntry)) {
    return nullptr;
  }
  // 1-inline LPoint3f OdeCollisionEntry::get_contact_point(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    LPoint3f *return_value = new LPoint3f(((*(const OdeCollisionEntry*)local_this).get_contact_point)(arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_contact_point(OdeCollisionEntry self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_get_contact_point_353_comment =
  "C++ Interface:\n"
  "get_contact_point(OdeCollisionEntry self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth contact point in the collision.  This does exactly the same\n"
  " * as get_contact_geom(n).get_pos().\n"
  " */";
#else
static const char *Dtool_OdeCollisionEntry_get_contact_point_353_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OdeContactGeom OdeCollisionEntry::get_contact_geom(std::size_t n) const
 */
static PyObject *Dtool_OdeCollisionEntry_get_contact_geom_354(PyObject *self, PyObject *arg) {
  OdeCollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeCollisionEntry)) {
    return nullptr;
  }
  // 1-inline OdeContactGeom OdeCollisionEntry::get_contact_geom(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    OdeContactGeom *return_value = new OdeContactGeom(((*(const OdeCollisionEntry*)local_this).get_contact_geom)(arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeContactGeom, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_contact_geom(OdeCollisionEntry self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_get_contact_geom_354_comment =
  "C++ Interface:\n"
  "get_contact_geom(OdeCollisionEntry self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth contact geom in the collision.\n"
  " */";
#else
static const char *Dtool_OdeCollisionEntry_get_contact_geom_354_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool OdeCollisionEntry::is_empty(void) const
 */
static PyObject *Dtool_OdeCollisionEntry_is_empty_359(PyObject *self, PyObject *) {
  OdeCollisionEntry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeCollisionEntry)) {
    return nullptr;
  }
  // 1-inline bool OdeCollisionEntry::is_empty(void) const
  bool return_value = ((*(const OdeCollisionEntry*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_is_empty_359_comment =
  "C++ Interface:\n"
  "is_empty(OdeCollisionEntry self)\n"
  "\n"
  "/**\n"
  " * Returns true if the entry holds no contacts.\n"
  " */";
#else
static const char *Dtool_OdeCollisionEntry_is_empty_359_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeCollisionEntry::get_class_type(void)
 */
static PyObject *Dtool_OdeCollisionEntry_get_class_type_360(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeCollisionEntry::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeCollisionEntry::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeCollisionEntry_get_class_type_360_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeCollisionEntry_get_class_type_360_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OdeCollisionEntry::OdeCollisionEntry(OdeCollisionEntry const &) = default
 */
static int Dtool_Init_OdeCollisionEntry(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("OdeCollisionEntry() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline OdeCollisionEntry::OdeCollisionEntry(OdeCollisionEntry const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    OdeCollisionEntry const *param0_this = (OdeCollisionEntry *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeCollisionEntry, 0, "OdeCollisionEntry.OdeCollisionEntry", true, true);
    if (param0_this != nullptr) {
      OdeCollisionEntry *return_value = new OdeCollisionEntry(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeCollisionEntry, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeCollisionEntry(const OdeCollisionEntry param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_OdeCollisionEntry_get_contact_points(PyObject *self, PyObject *) {
  OdeCollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCollisionEntry, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_contacts)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_OdeCollisionEntry_get_contact_point_353(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_OdeCollisionEntry_get_contact_geoms(PyObject *self, PyObject *) {
  OdeCollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCollisionEntry, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_contacts)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_OdeCollisionEntry_get_contact_geom_354(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_OdeCollisionEntry(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeCollisionEntry) {
    printf("OdeCollisionEntry ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeCollisionEntry *local_this = (OdeCollisionEntry *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeCollisionEntry) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeCollisionEntry(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeCollisionEntry) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (OdeCollisionEntry*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeCollisionEntry*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (OdeCollisionEntry*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeSurfaceParameters
 */
/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_mode(int mode)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_mode_365(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_mode")) {
    return nullptr;
  }
  // 1-inline void OdeSurfaceParameters::set_mode(int mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_mode)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mode(const OdeSurfaceParameters self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_mode_365_comment =
  "C++ Interface:\n"
  "set_mode(const OdeSurfaceParameters self, int mode)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_mode_365_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_mu(dReal mu)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_mu_366(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_mu")) {
    return nullptr;
  }
  // 1-inline void OdeSurfaceParameters::set_mu(dReal mu)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_mu)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mu(const OdeSurfaceParameters self, float mu)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_mu_366_comment =
  "C++ Interface:\n"
  "set_mu(const OdeSurfaceParameters self, float mu)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_mu_366_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_mu2(dReal mu2)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_mu2_367(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_mu2")) {
    return nullptr;
  }
  // 1-inline void OdeSurfaceParameters::set_mu2(dReal mu2)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_mu2)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mu2(const OdeSurfaceParameters self, float mu2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_mu2_367_comment =
  "C++ Interface:\n"
  "set_mu2(const OdeSurfaceParameters self, float mu2)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_mu2_367_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_bounce(dReal bounce)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_bounce_368(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_bounce")) {
    return nullptr;
  }
  // 1-inline void OdeSurfaceParameters::set_bounce(dReal bounce)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_bounce)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bounce(const OdeSurfaceParameters self, float bounce)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_bounce_368_comment =
  "C++ Interface:\n"
  "set_bounce(const OdeSurfaceParameters self, float bounce)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_bounce_368_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_bounce_vel(dReal bounce_vel)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_bounce_vel_369(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_bounce_vel")) {
    return nullptr;
  }
  // 1-inline void OdeSurfaceParameters::set_bounce_vel(dReal bounce_vel)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_bounce_vel)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bounce_vel(const OdeSurfaceParameters self, float bounce_vel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_bounce_vel_369_comment =
  "C++ Interface:\n"
  "set_bounce_vel(const OdeSurfaceParameters self, float bounce_vel)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_bounce_vel_369_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_soft_erp(dReal soft_erp)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_soft_erp_370(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_soft_erp")) {
    return nullptr;
  }
  // 1-inline void OdeSurfaceParameters::set_soft_erp(dReal soft_erp)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_soft_erp)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_soft_erp(const OdeSurfaceParameters self, float soft_erp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_soft_erp_370_comment =
  "C++ Interface:\n"
  "set_soft_erp(const OdeSurfaceParameters self, float soft_erp)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_soft_erp_370_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_soft_cfm(dReal soft_cfm)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_soft_cfm_371(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_soft_cfm")) {
    return nullptr;
  }
  // 1-inline void OdeSurfaceParameters::set_soft_cfm(dReal soft_cfm)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_soft_cfm)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_soft_cfm(const OdeSurfaceParameters self, float soft_cfm)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_soft_cfm_371_comment =
  "C++ Interface:\n"
  "set_soft_cfm(const OdeSurfaceParameters self, float soft_cfm)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_soft_cfm_371_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_motion1(dReal motion)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_motion1_372(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_motion1")) {
    return nullptr;
  }
  // 1-inline void OdeSurfaceParameters::set_motion1(dReal motion)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_motion1)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_motion1(const OdeSurfaceParameters self, float motion)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_motion1_372_comment =
  "C++ Interface:\n"
  "set_motion1(const OdeSurfaceParameters self, float motion)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_motion1_372_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_motion2(dReal motion)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_motion2_373(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_motion2")) {
    return nullptr;
  }
  // 1-inline void OdeSurfaceParameters::set_motion2(dReal motion)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_motion2)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_motion2(const OdeSurfaceParameters self, float motion)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_motion2_373_comment =
  "C++ Interface:\n"
  "set_motion2(const OdeSurfaceParameters self, float motion)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_motion2_373_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_slip1(dReal slip)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_slip1_374(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_slip1")) {
    return nullptr;
  }
  // 1-inline void OdeSurfaceParameters::set_slip1(dReal slip)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_slip1)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_slip1(const OdeSurfaceParameters self, float slip)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_slip1_374_comment =
  "C++ Interface:\n"
  "set_slip1(const OdeSurfaceParameters self, float slip)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_slip1_374_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSurfaceParameters::set_slip2(dReal slip)
 */
static PyObject *Dtool_OdeSurfaceParameters_set_slip2_375(PyObject *self, PyObject *arg) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSurfaceParameters, (void **)&local_this, "OdeSurfaceParameters.set_slip2")) {
    return nullptr;
  }
  // 1-inline void OdeSurfaceParameters::set_slip2(dReal slip)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_slip2)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_slip2(const OdeSurfaceParameters self, float slip)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_set_slip2_375_comment =
  "C++ Interface:\n"
  "set_slip2(const OdeSurfaceParameters self, float slip)\n";
#else
static const char *Dtool_OdeSurfaceParameters_set_slip2_375_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeSurfaceParameters::get_mode(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_mode_376(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSurfaceParameters)) {
    return nullptr;
  }
  // 1-inline int OdeSurfaceParameters::get_mode(void) const
  int return_value = ((*(const OdeSurfaceParameters*)local_this).get_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_mode_376_comment =
  "C++ Interface:\n"
  "get_mode(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_mode_376_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_mu(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_mu_377(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSurfaceParameters)) {
    return nullptr;
  }
  // 1-inline dReal OdeSurfaceParameters::get_mu(void) const
  dReal return_value = ((*(const OdeSurfaceParameters*)local_this).get_mu)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_mu_377_comment =
  "C++ Interface:\n"
  "get_mu(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_mu_377_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_mu2(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_mu2_378(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSurfaceParameters)) {
    return nullptr;
  }
  // 1-inline dReal OdeSurfaceParameters::get_mu2(void) const
  dReal return_value = ((*(const OdeSurfaceParameters*)local_this).get_mu2)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_mu2_378_comment =
  "C++ Interface:\n"
  "get_mu2(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_mu2_378_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_bounce(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_bounce_379(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSurfaceParameters)) {
    return nullptr;
  }
  // 1-inline dReal OdeSurfaceParameters::get_bounce(void) const
  dReal return_value = ((*(const OdeSurfaceParameters*)local_this).get_bounce)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_bounce_379_comment =
  "C++ Interface:\n"
  "get_bounce(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_bounce_379_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_bounce_vel(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_bounce_vel_380(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSurfaceParameters)) {
    return nullptr;
  }
  // 1-inline dReal OdeSurfaceParameters::get_bounce_vel(void) const
  dReal return_value = ((*(const OdeSurfaceParameters*)local_this).get_bounce_vel)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_bounce_vel_380_comment =
  "C++ Interface:\n"
  "get_bounce_vel(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_bounce_vel_380_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_soft_erp(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_soft_erp_381(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSurfaceParameters)) {
    return nullptr;
  }
  // 1-inline dReal OdeSurfaceParameters::get_soft_erp(void) const
  dReal return_value = ((*(const OdeSurfaceParameters*)local_this).get_soft_erp)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_soft_erp_381_comment =
  "C++ Interface:\n"
  "get_soft_erp(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_soft_erp_381_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_soft_cfm(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_soft_cfm_382(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSurfaceParameters)) {
    return nullptr;
  }
  // 1-inline dReal OdeSurfaceParameters::get_soft_cfm(void) const
  dReal return_value = ((*(const OdeSurfaceParameters*)local_this).get_soft_cfm)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_soft_cfm_382_comment =
  "C++ Interface:\n"
  "get_soft_cfm(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_soft_cfm_382_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_motion1(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_motion1_383(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSurfaceParameters)) {
    return nullptr;
  }
  // 1-inline dReal OdeSurfaceParameters::get_motion1(void) const
  dReal return_value = ((*(const OdeSurfaceParameters*)local_this).get_motion1)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_motion1_383_comment =
  "C++ Interface:\n"
  "get_motion1(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_motion1_383_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_motion2(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_motion2_384(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSurfaceParameters)) {
    return nullptr;
  }
  // 1-inline dReal OdeSurfaceParameters::get_motion2(void) const
  dReal return_value = ((*(const OdeSurfaceParameters*)local_this).get_motion2)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_motion2_384_comment =
  "C++ Interface:\n"
  "get_motion2(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_motion2_384_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_slip1(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_slip1_385(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSurfaceParameters)) {
    return nullptr;
  }
  // 1-inline dReal OdeSurfaceParameters::get_slip1(void) const
  dReal return_value = ((*(const OdeSurfaceParameters*)local_this).get_slip1)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_slip1_385_comment =
  "C++ Interface:\n"
  "get_slip1(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_slip1_385_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSurfaceParameters::get_slip2(void) const
 */
static PyObject *Dtool_OdeSurfaceParameters_get_slip2_386(PyObject *self, PyObject *) {
  OdeSurfaceParameters *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSurfaceParameters)) {
    return nullptr;
  }
  // 1-inline dReal OdeSurfaceParameters::get_slip2(void) const
  dReal return_value = ((*(const OdeSurfaceParameters*)local_this).get_slip2)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_slip2_386_comment =
  "C++ Interface:\n"
  "get_slip2(OdeSurfaceParameters self)\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_slip2_386_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeSurfaceParameters::get_class_type(void)
 */
static PyObject *Dtool_OdeSurfaceParameters_get_class_type_387(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeSurfaceParameters::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeSurfaceParameters::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeSurfaceParameters_get_class_type_387_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeSurfaceParameters_get_class_type_387_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeSurfaceParameters::OdeSurfaceParameters(int mode = 0, dReal mu = 0)
 */
static int Dtool_Init_OdeSurfaceParameters(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-OdeSurfaceParameters::OdeSurfaceParameters(int mode = 0, dReal mu = 0)
  int param0 = 0;
  float param1 = 0;
  static const char *keyword_list[] = {"mode", "mu", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|if:OdeSurfaceParameters", (char **)keyword_list, &param0, &param1)) {
    OdeSurfaceParameters *return_value = new OdeSurfaceParameters((int)param0, (dReal)param1);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSurfaceParameters, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeSurfaceParameters(int mode, float mu)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeSurfaceParameters(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeSurfaceParameters) {
    printf("OdeSurfaceParameters ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeSurfaceParameters *local_this = (OdeSurfaceParameters *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeSurfaceParameters) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeSurfaceParameters(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeSurfaceParameters) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeSurfaceParameters*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeContact
 */
/**
 * Python function wrapper for:
 * inline OdeSurfaceParameters OdeContact::get_surface(void) const
 */
static PyObject *Dtool_OdeContact_get_surface_390(PyObject *self, PyObject *) {
  OdeContact *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeContact)) {
    return nullptr;
  }
  // 1-inline OdeSurfaceParameters OdeContact::get_surface(void) const
  OdeSurfaceParameters *return_value = new OdeSurfaceParameters(((*(const OdeContact*)local_this).get_surface)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeSurfaceParameters, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeContact_get_surface_390_comment =
  "C++ Interface:\n"
  "get_surface(OdeContact self)\n";
#else
static const char *Dtool_OdeContact_get_surface_390_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OdeContactGeom OdeContact::get_geom(void)
 */
static PyObject *Dtool_OdeContact_get_geom_391(PyObject *self, PyObject *) {
  OdeContact *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContact, (void **)&local_this, "OdeContact.get_geom")) {
    return nullptr;
  }
  // 1-inline OdeContactGeom OdeContact::get_geom(void)
  OdeContactGeom *return_value = new OdeContactGeom(((*local_this).get_geom)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeContactGeom, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeContact_get_geom_391_comment =
  "C++ Interface:\n"
  "get_geom(const OdeContact self)\n";
#else
static const char *Dtool_OdeContact_get_geom_391_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeContact::get_fdir1(void) const
 */
static PyObject *Dtool_OdeContact_get_fdir1_392(PyObject *self, PyObject *) {
  OdeContact *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeContact)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeContact::get_fdir1(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeContact*)local_this).get_fdir1)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeContact_get_fdir1_392_comment =
  "C++ Interface:\n"
  "get_fdir1(OdeContact self)\n";
#else
static const char *Dtool_OdeContact_get_fdir1_392_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeContact::set_surface(OdeSurfaceParameters const &surface_parameters)
 */
static PyObject *Dtool_OdeContact_set_surface_393(PyObject *self, PyObject *arg) {
  OdeContact *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContact, (void **)&local_this, "OdeContact.set_surface")) {
    return nullptr;
  }
  // 1-inline void OdeContact::set_surface(OdeSurfaceParameters const &surface_parameters)
  OdeSurfaceParameters const *arg_this = (OdeSurfaceParameters *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeSurfaceParameters, 1, "OdeContact.set_surface", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_surface)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_surface(const OdeContact self, const OdeSurfaceParameters surface_parameters)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeContact_set_surface_393_comment =
  "C++ Interface:\n"
  "set_surface(const OdeContact self, const OdeSurfaceParameters surface_parameters)\n";
#else
static const char *Dtool_OdeContact_set_surface_393_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeContact::set_geom(OdeContactGeom const &contact_geom)
 */
static PyObject *Dtool_OdeContact_set_geom_394(PyObject *self, PyObject *arg) {
  OdeContact *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContact, (void **)&local_this, "OdeContact.set_geom")) {
    return nullptr;
  }
  // 1-inline void OdeContact::set_geom(OdeContactGeom const &contact_geom)
  OdeContactGeom const *arg_this = (OdeContactGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeContactGeom, 1, "OdeContact.set_geom", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_geom)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_geom(const OdeContact self, const OdeContactGeom contact_geom)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeContact_set_geom_394_comment =
  "C++ Interface:\n"
  "set_geom(const OdeContact self, const OdeContactGeom contact_geom)\n";
#else
static const char *Dtool_OdeContact_set_geom_394_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeContact::set_fdir1(LVecBase3f const &fdir1)
 */
static PyObject *Dtool_OdeContact_set_fdir1_395(PyObject *self, PyObject *arg) {
  OdeContact *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeContact, (void **)&local_this, "OdeContact.set_fdir1")) {
    return nullptr;
  }
  // 1-inline void OdeContact::set_fdir1(LVecBase3f const &fdir1)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeContact.set_fdir1", "LVecBase3f");
  }
  ((*local_this).set_fdir1)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_fdir1(const OdeContact self, const LVecBase3f fdir1)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeContact_set_fdir1_395_comment =
  "C++ Interface:\n"
  "set_fdir1(const OdeContact self, const LVecBase3f fdir1)\n";
#else
static const char *Dtool_OdeContact_set_fdir1_395_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeContact::get_class_type(void)
 */
static PyObject *Dtool_OdeContact_get_class_type_396(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeContact::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeContact::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeContact_get_class_type_396_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeContact_get_class_type_396_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeContact::OdeContact(void)
 * Rejected Remap [OdeContact::OdeContact(dContact const &contact)]
 */
static int Dtool_Init_OdeContact(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("OdeContact() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "OdeContact() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-OdeContact::OdeContact(void)
  OdeContact *return_value = new OdeContact();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeContact, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeContact()\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeContact(PyObject *args, CPT(OdeContact) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_OdeContact)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_OdeContact(PyObject *args, PT(OdeContact) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_OdeContact)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeContact(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeContact) {
    printf("OdeContact ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeContact *local_this = (OdeContact *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeContact) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeContact(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeContact) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (OdeContact*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeContact*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (OdeContact*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeContactJoint
 */
/**
 * Python function wrapper for:
 * static TypeHandle OdeContactJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeContactJoint_get_class_type_399(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeContactJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeContactJoint::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeContactJoint_get_class_type_399_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeContactJoint_get_class_type_399_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeContactJoint::OdeContactJoint(OdeWorld &world, OdeContact const &contact)
 * OdeContactJoint::OdeContactJoint(OdeWorld &world, OdeJointGroup &joint_group, OdeContact const &contact)
 */
static int Dtool_Init_OdeContactJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-OdeContactJoint::OdeContactJoint(OdeWorld &world, OdeContact const &contact)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "contact", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeContactJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeContactJoint.OdeContactJoint", false, true);
        CPT(OdeContact) param1_this;
        if (!Dtool_ConstCoerce_OdeContact(param1, param1_this)) {
          Dtool_Raise_ArgTypeError(param1, 1, "OdeContactJoint.OdeContactJoint", "OdeContact");
          return -1;
        }
        if (param0_this != nullptr) {
          OdeContactJoint *return_value = new OdeContactJoint(*param0_this, *std::move(param1_this));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeContactJoint, true, false);
        }
      }
    }
    break;
  case 3:
    {
      // 1-OdeContactJoint::OdeContactJoint(OdeWorld &world, OdeJointGroup &joint_group, OdeContact const &contact)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"world", "joint_group", "contact", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:OdeContactJoint", (char **)keyword_list, &param0, &param1, &param2)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeContactJoint.OdeContactJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeContactJoint.OdeContactJoint", false, true);
        CPT(OdeContact) param2_this;
        if (!Dtool_ConstCoerce_OdeContact(param2, param2_this)) {
          Dtool_Raise_ArgTypeError(param2, 2, "OdeContactJoint.OdeContactJoint", "OdeContact");
          return -1;
        }
        if (param0_this != nullptr && param1_this != nullptr) {
          OdeContactJoint *return_value = new OdeContactJoint(*param0_this, *param1_this, *std::move(param2_this));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeContactJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeContactJoint() takes 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeContactJoint(OdeWorld world, const OdeContact contact)\n"
      "OdeContactJoint(OdeWorld world, OdeJointGroup joint_group, const OdeContact contact)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeContactJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeContactJoint) {
    printf("OdeContactJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeContactJoint *local_this = (OdeContactJoint *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeContactJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeContactJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeContactJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeContactJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeContactJoint*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeCylinderGeom
 */
/**
 * Python function wrapper for:
 * inline void OdeCylinderGeom::set_params(dReal radius, dReal length)
 */
static PyObject *Dtool_OdeCylinderGeom_set_params_402(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeCylinderGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeCylinderGeom, (void **)&local_this, "OdeCylinderGeom.set_params")) {
    return nullptr;
  }
  // 1-inline void OdeCylinderGeom::set_params(dReal radius, dReal length)
  float param1;
  float param2;
  static const char *keyword_list[] = {"radius", "length", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_params", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_params)((dReal)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_params(const OdeCylinderGeom self, float radius, float length)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeCylinderGeom_set_params_402_comment =
  "C++ Interface:\n"
  "set_params(const OdeCylinderGeom self, float radius, float length)\n";
#else
static const char *Dtool_OdeCylinderGeom_set_params_402_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeCylinderGeom::get_radius(void) const
 */
static PyObject *Dtool_OdeCylinderGeom_get_radius_404(PyObject *self, PyObject *) {
  OdeCylinderGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeCylinderGeom)) {
    return nullptr;
  }
  // 1-inline dReal OdeCylinderGeom::get_radius(void) const
  dReal return_value = ((*(const OdeCylinderGeom*)local_this).get_radius)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeCylinderGeom_get_radius_404_comment =
  "C++ Interface:\n"
  "get_radius(OdeCylinderGeom self)\n";
#else
static const char *Dtool_OdeCylinderGeom_get_radius_404_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeCylinderGeom::get_length(void) const
 */
static PyObject *Dtool_OdeCylinderGeom_get_length_405(PyObject *self, PyObject *) {
  OdeCylinderGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeCylinderGeom)) {
    return nullptr;
  }
  // 1-inline dReal OdeCylinderGeom::get_length(void) const
  dReal return_value = ((*(const OdeCylinderGeom*)local_this).get_length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeCylinderGeom_get_length_405_comment =
  "C++ Interface:\n"
  "get_length(OdeCylinderGeom self)\n";
#else
static const char *Dtool_OdeCylinderGeom_get_length_405_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeCylinderGeom::get_class_type(void)
 */
static PyObject *Dtool_OdeCylinderGeom_get_class_type_406(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeCylinderGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeCylinderGeom::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeCylinderGeom_get_class_type_406_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeCylinderGeom_get_class_type_406_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeCylinderGeom::OdeCylinderGeom(OdeSpace &space, dReal radius, dReal length)
 * OdeCylinderGeom::OdeCylinderGeom(dReal radius, dReal length)
 */
static int Dtool_Init_OdeCylinderGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-OdeCylinderGeom::OdeCylinderGeom(dReal radius, dReal length)
      float param0;
      float param1;
      static const char *keyword_list[] = {"radius", "length", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:OdeCylinderGeom", (char **)keyword_list, &param0, &param1)) {
        OdeCylinderGeom *return_value = new OdeCylinderGeom((dReal)param0, (dReal)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeCylinderGeom, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-OdeCylinderGeom::OdeCylinderGeom(OdeSpace &space, dReal radius, dReal length)
      PyObject *param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"space", "radius", "length", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Off:OdeCylinderGeom", (char **)keyword_list, &param0, &param1, &param2)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeCylinderGeom.OdeCylinderGeom", false, true);
        if (param0_this != nullptr) {
          OdeCylinderGeom *return_value = new OdeCylinderGeom(*param0_this, (dReal)param1, (dReal)param2);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeCylinderGeom, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeCylinderGeom() takes 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeCylinderGeom(float radius, float length)\n"
      "OdeCylinderGeom(OdeSpace space, float radius, float length)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeCylinderGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeCylinderGeom) {
    printf("OdeCylinderGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeCylinderGeom *local_this = (OdeCylinderGeom *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeCylinderGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeGeom) {
    return (OdeGeom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeGeom *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeCylinderGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeCylinderGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeGeom) {
    OdeGeom* other_this = (OdeGeom*)from_this;
    return (OdeCylinderGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeCylinderGeom*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeFixedJoint
 */
/**
 * Python function wrapper for:
 * inline void OdeFixedJoint::set(void)
 */
static PyObject *Dtool_OdeFixedJoint_set_409(PyObject *self, PyObject *) {
  OdeFixedJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeFixedJoint, (void **)&local_this, "OdeFixedJoint.set")) {
    return nullptr;
  }
  // 1-inline void OdeFixedJoint::set(void)
  ((*local_this).set)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeFixedJoint_set_409_comment =
  "C++ Interface:\n"
  "set(const OdeFixedJoint self)\n";
#else
static const char *Dtool_OdeFixedJoint_set_409_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeFixedJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeFixedJoint_get_class_type_410(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeFixedJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeFixedJoint::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeFixedJoint_get_class_type_410_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeFixedJoint_get_class_type_410_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeFixedJoint::OdeFixedJoint(OdeWorld &world)
 * OdeFixedJoint::OdeFixedJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeFixedJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "world")) {
        // 1-OdeFixedJoint::OdeFixedJoint(OdeWorld &world)
        OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeFixedJoint.OdeFixedJoint", false, true);
        if (arg_this != nullptr) {
          OdeFixedJoint *return_value = new OdeFixedJoint(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeFixedJoint, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-OdeFixedJoint::OdeFixedJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeFixedJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeFixedJoint.OdeFixedJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeFixedJoint.OdeFixedJoint", false, true);
        if (param0_this != nullptr && param1_this != nullptr) {
          OdeFixedJoint *return_value = new OdeFixedJoint(*param0_this, *param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeFixedJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeFixedJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeFixedJoint(OdeWorld world)\n"
      "OdeFixedJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeFixedJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeFixedJoint) {
    printf("OdeFixedJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeFixedJoint *local_this = (OdeFixedJoint *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeFixedJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeFixedJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeFixedJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeFixedJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeFixedJoint*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeHashSpace
 */
/**
 * Python function wrapper for:
 * inline void OdeHashSpace::set_levels(int minlevel, int maxlevel)
 */
static PyObject *Dtool_OdeHashSpace_set_levels_413(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHashSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHashSpace, (void **)&local_this, "OdeHashSpace.set_levels")) {
    return nullptr;
  }
  // 1-inline void OdeHashSpace::set_levels(int minlevel, int maxlevel)
  int param1;
  int param2;
  static const char *keyword_list[] = {"minlevel", "maxlevel", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_levels", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_levels)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_levels(const OdeHashSpace self, int minlevel, int maxlevel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHashSpace_set_levels_413_comment =
  "C++ Interface:\n"
  "set_levels(const OdeHashSpace self, int minlevel, int maxlevel)\n";
#else
static const char *Dtool_OdeHashSpace_set_levels_413_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeHashSpace::get_min_level(void) const
 */
static PyObject *Dtool_OdeHashSpace_get_min_level_414(PyObject *self, PyObject *) {
  OdeHashSpace *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHashSpace)) {
    return nullptr;
  }
  // 1-inline int OdeHashSpace::get_min_level(void) const
  int return_value = ((*(const OdeHashSpace*)local_this).get_min_level)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHashSpace_get_min_level_414_comment =
  "C++ Interface:\n"
  "get_min_level(OdeHashSpace self)\n";
#else
static const char *Dtool_OdeHashSpace_get_min_level_414_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeHashSpace::get_max_level(void) const
 */
static PyObject *Dtool_OdeHashSpace_get_max_level_415(PyObject *self, PyObject *) {
  OdeHashSpace *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHashSpace)) {
    return nullptr;
  }
  // 1-inline int OdeHashSpace::get_max_level(void) const
  int return_value = ((*(const OdeHashSpace*)local_this).get_max_level)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHashSpace_get_max_level_415_comment =
  "C++ Interface:\n"
  "get_max_level(OdeHashSpace self)\n";
#else
static const char *Dtool_OdeHashSpace_get_max_level_415_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeHashSpace::get_class_type(void)
 */
static PyObject *Dtool_OdeHashSpace_get_class_type_416(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeHashSpace::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeHashSpace::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHashSpace_get_class_type_416_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeHashSpace_get_class_type_416_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeHashSpace::OdeHashSpace(void)
 * OdeHashSpace::OdeHashSpace(OdeSpace &space)
 */
static int Dtool_Init_OdeHashSpace(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-OdeHashSpace::OdeHashSpace(void)
      OdeHashSpace *return_value = new OdeHashSpace();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHashSpace, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "space")) {
        // 1-OdeHashSpace::OdeHashSpace(OdeSpace &space)
        OdeSpace *arg_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeSpace, 0, "OdeHashSpace.OdeHashSpace", false, true);
        if (arg_this != nullptr) {
          OdeHashSpace *return_value = new OdeHashSpace(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHashSpace, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeHashSpace() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeHashSpace()\n"
      "OdeHashSpace(OdeSpace space)\n");
  }
  return -1;
}

OdeHashSpace *Dtool_Coerce_OdeHashSpace(PyObject *args, OdeHashSpace &coerced) {
  OdeHashSpace *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_OdeHashSpace)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const OdeHashSpace *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeHashSpace::OdeHashSpace(OdeSpace &space)
    OdeSpace *arg_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeSpace, 0, "OdeHashSpace.OdeHashSpace", false, false);
    if (arg_this != nullptr) {
      coerced = OdeHashSpace(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_OdeHashSpace(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeHashSpace) {
    printf("OdeHashSpace ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeHashSpace *local_this = (OdeHashSpace *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeHashSpace) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeSpace) {
    return (OdeSpace *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeSpace *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeHashSpace(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeHashSpace) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeSpace) {
    OdeSpace* other_this = (OdeSpace*)from_this;
    return (OdeHashSpace*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeHashSpace*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeHinge2Joint
 */
/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_anchor(LVecBase3f const &anchor)
 * inline void OdeHinge2Joint::set_anchor(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeHinge2Joint_set_anchor_419(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_anchor")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "anchor")) {
        // 1-inline void OdeHinge2Joint::set_anchor(LVecBase3f const &anchor)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeHinge2Joint.set_anchor", "LVecBase3f");
        }
        ((*local_this).set_anchor)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeHinge2Joint::set_anchor(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_anchor", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_anchor)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_anchor() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anchor(const OdeHinge2Joint self, const LVecBase3f anchor)\n"
      "set_anchor(const OdeHinge2Joint self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_anchor_419_comment =
  "C++ Interface:\n"
  "set_anchor(const OdeHinge2Joint self, const LVecBase3f anchor)\n"
  "set_anchor(const OdeHinge2Joint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_anchor_419_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_axis1(LVecBase3f const &axis)
 * inline void OdeHinge2Joint::set_axis1(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeHinge2Joint_set_axis1_420(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_axis1")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "axis")) {
        // 1-inline void OdeHinge2Joint::set_axis1(LVecBase3f const &axis)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeHinge2Joint.set_axis1", "LVecBase3f");
        }
        ((*local_this).set_axis1)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeHinge2Joint::set_axis1(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_axis1", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_axis1)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis1() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis1(const OdeHinge2Joint self, const LVecBase3f axis)\n"
      "set_axis1(const OdeHinge2Joint self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_axis1_420_comment =
  "C++ Interface:\n"
  "set_axis1(const OdeHinge2Joint self, const LVecBase3f axis)\n"
  "set_axis1(const OdeHinge2Joint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_axis1_420_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_axis2(LVecBase3f const &axis)
 * inline void OdeHinge2Joint::set_axis2(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeHinge2Joint_set_axis2_421(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_axis2")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "axis")) {
        // 1-inline void OdeHinge2Joint::set_axis2(LVecBase3f const &axis)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeHinge2Joint.set_axis2", "LVecBase3f");
        }
        ((*local_this).set_axis2)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeHinge2Joint::set_axis2(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_axis2", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_axis2)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis2() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis2(const OdeHinge2Joint self, const LVecBase3f axis)\n"
      "set_axis2(const OdeHinge2Joint self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_axis2_421_comment =
  "C++ Interface:\n"
  "set_axis2(const OdeHinge2Joint self, const LVecBase3f axis)\n"
  "set_axis2(const OdeHinge2Joint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_axis2_421_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::add_torques(dReal torque1, dReal torque2)
 */
static PyObject *Dtool_OdeHinge2Joint_add_torques_422(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.add_torques")) {
    return nullptr;
  }
  // 1-inline void OdeHinge2Joint::add_torques(dReal torque1, dReal torque2)
  float param1;
  float param2;
  static const char *keyword_list[] = {"torque1", "torque2", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:add_torques", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).add_torques)((dReal)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_torques(const OdeHinge2Joint self, float torque1, float torque2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_add_torques_422_comment =
  "C++ Interface:\n"
  "add_torques(const OdeHinge2Joint self, float torque1, float torque2)\n";
#else
static const char *Dtool_OdeHinge2Joint_add_torques_422_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeHinge2Joint::get_anchor(void) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_anchor_423(PyObject *self, PyObject *) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeHinge2Joint::get_anchor(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeHinge2Joint*)local_this).get_anchor)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_anchor_423_comment =
  "C++ Interface:\n"
  "get_anchor(OdeHinge2Joint self)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_anchor_423_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeHinge2Joint::get_anchor2(void) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_anchor2_424(PyObject *self, PyObject *) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeHinge2Joint::get_anchor2(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeHinge2Joint*)local_this).get_anchor2)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_anchor2_424_comment =
  "C++ Interface:\n"
  "get_anchor2(OdeHinge2Joint self)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_anchor2_424_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeHinge2Joint::get_axis1(void) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_axis1_425(PyObject *self, PyObject *) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeHinge2Joint::get_axis1(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeHinge2Joint*)local_this).get_axis1)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_axis1_425_comment =
  "C++ Interface:\n"
  "get_axis1(OdeHinge2Joint self)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_axis1_425_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeHinge2Joint::get_axis2(void) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_axis2_426(PyObject *self, PyObject *) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeHinge2Joint::get_axis2(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeHinge2Joint*)local_this).get_axis2)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_axis2_426_comment =
  "C++ Interface:\n"
  "get_axis2(OdeHinge2Joint self)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_axis2_426_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_angle1(void) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_angle1_427(PyObject *self, PyObject *) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHinge2Joint::get_angle1(void) const
  dReal return_value = ((*(const OdeHinge2Joint*)local_this).get_angle1)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_angle1_427_comment =
  "C++ Interface:\n"
  "get_angle1(OdeHinge2Joint self)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_angle1_427_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_angle1_rate(void) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_angle1_rate_428(PyObject *self, PyObject *) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHinge2Joint::get_angle1_rate(void) const
  dReal return_value = ((*(const OdeHinge2Joint*)local_this).get_angle1_rate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_angle1_rate_428_comment =
  "C++ Interface:\n"
  "get_angle1_rate(OdeHinge2Joint self)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_angle1_rate_428_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_angle2_rate(void) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_angle2_rate_429(PyObject *self, PyObject *) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHinge2Joint::get_angle2_rate(void) const
  dReal return_value = ((*(const OdeHinge2Joint*)local_this).get_angle2_rate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_angle2_rate_429_comment =
  "C++ Interface:\n"
  "get_angle2_rate(OdeHinge2Joint self)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_angle2_rate_429_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_lo_stop(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_lo_stop_430(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_lo_stop")) {
    return nullptr;
  }
  // 1-inline void OdeHinge2Joint::set_param_lo_stop(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_lo_stop", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_lo_stop)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_lo_stop(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_lo_stop_430_comment =
  "C++ Interface:\n"
  "set_param_lo_stop(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_lo_stop_430_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_hi_stop(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_hi_stop_431(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_hi_stop")) {
    return nullptr;
  }
  // 1-inline void OdeHinge2Joint::set_param_hi_stop(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_hi_stop", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_hi_stop)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_hi_stop(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_hi_stop_431_comment =
  "C++ Interface:\n"
  "set_param_hi_stop(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_hi_stop_431_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_vel(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_vel_432(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_vel")) {
    return nullptr;
  }
  // 1-inline void OdeHinge2Joint::set_param_vel(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_vel", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_vel)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_vel(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_vel_432_comment =
  "C++ Interface:\n"
  "set_param_vel(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_vel_432_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_f_max(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_f_max_433(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_f_max")) {
    return nullptr;
  }
  // 1-inline void OdeHinge2Joint::set_param_f_max(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_f_max", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_f_max)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_f_max(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_f_max_433_comment =
  "C++ Interface:\n"
  "set_param_f_max(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_f_max_433_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_fudge_factor(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_fudge_factor_434(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_fudge_factor")) {
    return nullptr;
  }
  // 1-inline void OdeHinge2Joint::set_param_fudge_factor(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_fudge_factor", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_fudge_factor)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_fudge_factor(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_fudge_factor_434_comment =
  "C++ Interface:\n"
  "set_param_fudge_factor(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_fudge_factor_434_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_bounce(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_bounce_435(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_bounce")) {
    return nullptr;
  }
  // 1-inline void OdeHinge2Joint::set_param_bounce(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_bounce", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_bounce)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_bounce(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_bounce_435_comment =
  "C++ Interface:\n"
  "set_param_bounce(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_bounce_435_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_CFM(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_CFM_436(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_CFM")) {
    return nullptr;
  }
  // 1-inline void OdeHinge2Joint::set_param_CFM(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_CFM", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_CFM)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_CFM(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_CFM_436_comment =
  "C++ Interface:\n"
  "set_param_CFM(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_CFM_436_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_stop_ERP(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_stop_ERP_437(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_stop_ERP")) {
    return nullptr;
  }
  // 1-inline void OdeHinge2Joint::set_param_stop_ERP(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_stop_ERP", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_stop_ERP)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_ERP(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_stop_ERP_437_comment =
  "C++ Interface:\n"
  "set_param_stop_ERP(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_stop_ERP_437_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_stop_CFM(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_stop_CFM_438(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_stop_CFM")) {
    return nullptr;
  }
  // 1-inline void OdeHinge2Joint::set_param_stop_CFM(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_stop_CFM", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_stop_CFM)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_CFM(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_stop_CFM_438_comment =
  "C++ Interface:\n"
  "set_param_stop_CFM(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_stop_CFM_438_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_suspension_ERP(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_suspension_ERP_439(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_suspension_ERP")) {
    return nullptr;
  }
  // 1-inline void OdeHinge2Joint::set_param_suspension_ERP(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_suspension_ERP", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_suspension_ERP)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_suspension_ERP(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_suspension_ERP_439_comment =
  "C++ Interface:\n"
  "set_param_suspension_ERP(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_suspension_ERP_439_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHinge2Joint::set_param_suspension_CFM(int axis, dReal val)
 */
static PyObject *Dtool_OdeHinge2Joint_set_param_suspension_CFM_440(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHinge2Joint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHinge2Joint, (void **)&local_this, "OdeHinge2Joint.set_param_suspension_CFM")) {
    return nullptr;
  }
  // 1-inline void OdeHinge2Joint::set_param_suspension_CFM(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_suspension_CFM", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_suspension_CFM)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_suspension_CFM(const OdeHinge2Joint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_set_param_suspension_CFM_440_comment =
  "C++ Interface:\n"
  "set_param_suspension_CFM(const OdeHinge2Joint self, int axis, float val)\n";
#else
static const char *Dtool_OdeHinge2Joint_set_param_suspension_CFM_440_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_lo_stop(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_lo_stop_441(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_lo_stop(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeHinge2Joint*)local_this).get_param_lo_stop)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_lo_stop(OdeHinge2Joint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_lo_stop_441_comment =
  "C++ Interface:\n"
  "get_param_lo_stop(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_lo_stop_441_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_hi_stop(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_hi_stop_442(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_hi_stop(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeHinge2Joint*)local_this).get_param_hi_stop)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_hi_stop(OdeHinge2Joint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_hi_stop_442_comment =
  "C++ Interface:\n"
  "get_param_hi_stop(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_hi_stop_442_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_vel(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_vel_443(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_vel(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeHinge2Joint*)local_this).get_param_vel)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_vel(OdeHinge2Joint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_vel_443_comment =
  "C++ Interface:\n"
  "get_param_vel(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_vel_443_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_f_max(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_f_max_444(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_f_max(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeHinge2Joint*)local_this).get_param_f_max)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_f_max(OdeHinge2Joint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_f_max_444_comment =
  "C++ Interface:\n"
  "get_param_f_max(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_f_max_444_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_fudge_factor(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_fudge_factor_445(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_fudge_factor(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeHinge2Joint*)local_this).get_param_fudge_factor)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_fudge_factor(OdeHinge2Joint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_fudge_factor_445_comment =
  "C++ Interface:\n"
  "get_param_fudge_factor(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_fudge_factor_445_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_bounce(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_bounce_446(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_bounce(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeHinge2Joint*)local_this).get_param_bounce)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_bounce(OdeHinge2Joint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_bounce_446_comment =
  "C++ Interface:\n"
  "get_param_bounce(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_bounce_446_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_CFM(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_CFM_447(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_CFM(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeHinge2Joint*)local_this).get_param_CFM)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_CFM(OdeHinge2Joint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_CFM_447_comment =
  "C++ Interface:\n"
  "get_param_CFM(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_CFM_447_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_stop_ERP(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_stop_ERP_448(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_stop_ERP(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeHinge2Joint*)local_this).get_param_stop_ERP)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_stop_ERP(OdeHinge2Joint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_stop_ERP_448_comment =
  "C++ Interface:\n"
  "get_param_stop_ERP(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_stop_ERP_448_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_stop_CFM(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_stop_CFM_449(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_stop_CFM(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeHinge2Joint*)local_this).get_param_stop_CFM)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_stop_CFM(OdeHinge2Joint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_stop_CFM_449_comment =
  "C++ Interface:\n"
  "get_param_stop_CFM(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_stop_CFM_449_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_suspension_ERP(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_suspension_ERP_450(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_suspension_ERP(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeHinge2Joint*)local_this).get_param_suspension_ERP)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_suspension_ERP(OdeHinge2Joint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_suspension_ERP_450_comment =
  "C++ Interface:\n"
  "get_param_suspension_ERP(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_suspension_ERP_450_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHinge2Joint::get_param_suspension_CFM(int axis) const
 */
static PyObject *Dtool_OdeHinge2Joint_get_param_suspension_CFM_451(PyObject *self, PyObject *arg) {
  OdeHinge2Joint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHinge2Joint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHinge2Joint::get_param_suspension_CFM(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeHinge2Joint*)local_this).get_param_suspension_CFM)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_suspension_CFM(OdeHinge2Joint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_param_suspension_CFM_451_comment =
  "C++ Interface:\n"
  "get_param_suspension_CFM(OdeHinge2Joint self, int axis)\n";
#else
static const char *Dtool_OdeHinge2Joint_get_param_suspension_CFM_451_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeHinge2Joint::get_class_type(void)
 */
static PyObject *Dtool_OdeHinge2Joint_get_class_type_452(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeHinge2Joint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeHinge2Joint::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHinge2Joint_get_class_type_452_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeHinge2Joint_get_class_type_452_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeHinge2Joint::OdeHinge2Joint(OdeWorld &world)
 * OdeHinge2Joint::OdeHinge2Joint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeHinge2Joint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "world")) {
        // 1-OdeHinge2Joint::OdeHinge2Joint(OdeWorld &world)
        OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeHinge2Joint.OdeHinge2Joint", false, true);
        if (arg_this != nullptr) {
          OdeHinge2Joint *return_value = new OdeHinge2Joint(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHinge2Joint, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-OdeHinge2Joint::OdeHinge2Joint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeHinge2Joint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeHinge2Joint.OdeHinge2Joint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeHinge2Joint.OdeHinge2Joint", false, true);
        if (param0_this != nullptr && param1_this != nullptr) {
          OdeHinge2Joint *return_value = new OdeHinge2Joint(*param0_this, *param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHinge2Joint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeHinge2Joint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeHinge2Joint(OdeWorld world)\n"
      "OdeHinge2Joint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeHinge2Joint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeHinge2Joint) {
    printf("OdeHinge2Joint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeHinge2Joint *local_this = (OdeHinge2Joint *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeHinge2Joint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeHinge2Joint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeHinge2Joint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeHinge2Joint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeHinge2Joint*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeHingeJoint
 */
/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_anchor(LVecBase3f const &anchor)
 * inline void OdeHingeJoint::set_anchor(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeHingeJoint_set_anchor_455(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHingeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_anchor")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "anchor")) {
        // 1-inline void OdeHingeJoint::set_anchor(LVecBase3f const &anchor)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeHingeJoint.set_anchor", "LVecBase3f");
        }
        ((*local_this).set_anchor)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeHingeJoint::set_anchor(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_anchor", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_anchor)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_anchor() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anchor(const OdeHingeJoint self, const LVecBase3f anchor)\n"
      "set_anchor(const OdeHingeJoint self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_anchor_455_comment =
  "C++ Interface:\n"
  "set_anchor(const OdeHingeJoint self, const LVecBase3f anchor)\n"
  "set_anchor(const OdeHingeJoint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeHingeJoint_set_anchor_455_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_anchor_delta(LVecBase3f const &anchor, LVecBase3f const &vec)
 * inline void OdeHingeJoint::set_anchor_delta(dReal x, dReal y, dReal z, dReal ax, dReal ay, dReal az)
 */
static PyObject *Dtool_OdeHingeJoint_set_anchor_delta_456(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHingeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_anchor_delta")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeHingeJoint::set_anchor_delta(LVecBase3f const &anchor, LVecBase3f const &vec)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"anchor", "vec", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_anchor_delta", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "OdeHingeJoint.set_anchor_delta", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeHingeJoint.set_anchor_delta", "LVecBase3f");
        }
        ((*local_this).set_anchor_delta)(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void OdeHingeJoint::set_anchor_delta(dReal x, dReal y, dReal z, dReal ax, dReal ay, dReal az)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"x", "y", "z", "ax", "ay", "az", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:set_anchor_delta", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        ((*local_this).set_anchor_delta)((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_anchor_delta() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anchor_delta(const OdeHingeJoint self, const LVecBase3f anchor, const LVecBase3f vec)\n"
      "set_anchor_delta(const OdeHingeJoint self, float x, float y, float z, float ax, float ay, float az)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_anchor_delta_456_comment =
  "C++ Interface:\n"
  "set_anchor_delta(const OdeHingeJoint self, const LVecBase3f anchor, const LVecBase3f vec)\n"
  "set_anchor_delta(const OdeHingeJoint self, float x, float y, float z, float ax, float ay, float az)\n";
#else
static const char *Dtool_OdeHingeJoint_set_anchor_delta_456_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_axis(LVecBase3f const &axis)
 * inline void OdeHingeJoint::set_axis(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeHingeJoint_set_axis_457(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeHingeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_axis")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "axis")) {
        // 1-inline void OdeHingeJoint::set_axis(LVecBase3f const &axis)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeHingeJoint.set_axis", "LVecBase3f");
        }
        ((*local_this).set_axis)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeHingeJoint::set_axis(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_axis", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_axis)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis(const OdeHingeJoint self, const LVecBase3f axis)\n"
      "set_axis(const OdeHingeJoint self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_axis_457_comment =
  "C++ Interface:\n"
  "set_axis(const OdeHingeJoint self, const LVecBase3f axis)\n"
  "set_axis(const OdeHingeJoint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeHingeJoint_set_axis_457_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::add_torque(dReal torque)
 */
static PyObject *Dtool_OdeHingeJoint_add_torque_458(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.add_torque")) {
    return nullptr;
  }
  // 1-inline void OdeHingeJoint::add_torque(dReal torque)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_torque)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_torque(const OdeHingeJoint self, float torque)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_add_torque_458_comment =
  "C++ Interface:\n"
  "add_torque(const OdeHingeJoint self, float torque)\n";
#else
static const char *Dtool_OdeHingeJoint_add_torque_458_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeHingeJoint::get_anchor(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_anchor_459(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHingeJoint)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeHingeJoint::get_anchor(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeHingeJoint*)local_this).get_anchor)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_anchor_459_comment =
  "C++ Interface:\n"
  "get_anchor(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_anchor_459_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeHingeJoint::get_anchor2(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_anchor2_460(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHingeJoint)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeHingeJoint::get_anchor2(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeHingeJoint*)local_this).get_anchor2)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_anchor2_460_comment =
  "C++ Interface:\n"
  "get_anchor2(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_anchor2_460_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeHingeJoint::get_axis(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_axis_461(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHingeJoint)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeHingeJoint::get_axis(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeHingeJoint*)local_this).get_axis)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_axis_461_comment =
  "C++ Interface:\n"
  "get_axis(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_axis_461_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_angle(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_angle_462(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHingeJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHingeJoint::get_angle(void) const
  dReal return_value = ((*(const OdeHingeJoint*)local_this).get_angle)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_angle_462_comment =
  "C++ Interface:\n"
  "get_angle(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_angle_462_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_angle_rate(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_angle_rate_463(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHingeJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHingeJoint::get_angle_rate(void) const
  dReal return_value = ((*(const OdeHingeJoint*)local_this).get_angle_rate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_angle_rate_463_comment =
  "C++ Interface:\n"
  "get_angle_rate(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_angle_rate_463_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_lo_stop(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_lo_stop_464(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_lo_stop")) {
    return nullptr;
  }
  // 1-inline void OdeHingeJoint::set_param_lo_stop(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_lo_stop)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_lo_stop(const OdeHingeJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_lo_stop_464_comment =
  "C++ Interface:\n"
  "set_param_lo_stop(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_lo_stop_464_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_hi_stop(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_hi_stop_465(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_hi_stop")) {
    return nullptr;
  }
  // 1-inline void OdeHingeJoint::set_param_hi_stop(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_hi_stop)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_hi_stop(const OdeHingeJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_hi_stop_465_comment =
  "C++ Interface:\n"
  "set_param_hi_stop(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_hi_stop_465_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_vel(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_vel_466(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_vel")) {
    return nullptr;
  }
  // 1-inline void OdeHingeJoint::set_param_vel(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_vel)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_vel(const OdeHingeJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_vel_466_comment =
  "C++ Interface:\n"
  "set_param_vel(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_vel_466_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_f_max(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_f_max_467(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_f_max")) {
    return nullptr;
  }
  // 1-inline void OdeHingeJoint::set_param_f_max(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_f_max)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_f_max(const OdeHingeJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_f_max_467_comment =
  "C++ Interface:\n"
  "set_param_f_max(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_f_max_467_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_fudge_factor(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_fudge_factor_468(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_fudge_factor")) {
    return nullptr;
  }
  // 1-inline void OdeHingeJoint::set_param_fudge_factor(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_fudge_factor)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_fudge_factor(const OdeHingeJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_fudge_factor_468_comment =
  "C++ Interface:\n"
  "set_param_fudge_factor(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_fudge_factor_468_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_bounce(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_bounce_469(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_bounce")) {
    return nullptr;
  }
  // 1-inline void OdeHingeJoint::set_param_bounce(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_bounce)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_bounce(const OdeHingeJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_bounce_469_comment =
  "C++ Interface:\n"
  "set_param_bounce(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_bounce_469_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_CFM(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_CFM_470(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_CFM")) {
    return nullptr;
  }
  // 1-inline void OdeHingeJoint::set_param_CFM(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_CFM)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_CFM(const OdeHingeJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_CFM_470_comment =
  "C++ Interface:\n"
  "set_param_CFM(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_CFM_470_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_stop_ERP(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_stop_ERP_471(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_stop_ERP")) {
    return nullptr;
  }
  // 1-inline void OdeHingeJoint::set_param_stop_ERP(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_stop_ERP)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_ERP(const OdeHingeJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_stop_ERP_471_comment =
  "C++ Interface:\n"
  "set_param_stop_ERP(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_stop_ERP_471_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeHingeJoint::set_param_stop_CFM(dReal val)
 */
static PyObject *Dtool_OdeHingeJoint_set_param_stop_CFM_472(PyObject *self, PyObject *arg) {
  OdeHingeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeHingeJoint, (void **)&local_this, "OdeHingeJoint.set_param_stop_CFM")) {
    return nullptr;
  }
  // 1-inline void OdeHingeJoint::set_param_stop_CFM(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_stop_CFM)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_CFM(const OdeHingeJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_set_param_stop_CFM_472_comment =
  "C++ Interface:\n"
  "set_param_stop_CFM(const OdeHingeJoint self, float val)\n";
#else
static const char *Dtool_OdeHingeJoint_set_param_stop_CFM_472_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_lo_stop(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_lo_stop_473(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHingeJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHingeJoint::get_param_lo_stop(void) const
  dReal return_value = ((*(const OdeHingeJoint*)local_this).get_param_lo_stop)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_lo_stop_473_comment =
  "C++ Interface:\n"
  "get_param_lo_stop(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_lo_stop_473_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_hi_stop(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_hi_stop_474(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHingeJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHingeJoint::get_param_hi_stop(void) const
  dReal return_value = ((*(const OdeHingeJoint*)local_this).get_param_hi_stop)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_hi_stop_474_comment =
  "C++ Interface:\n"
  "get_param_hi_stop(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_hi_stop_474_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_vel(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_vel_475(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHingeJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHingeJoint::get_param_vel(void) const
  dReal return_value = ((*(const OdeHingeJoint*)local_this).get_param_vel)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_vel_475_comment =
  "C++ Interface:\n"
  "get_param_vel(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_vel_475_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_f_max(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_f_max_476(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHingeJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHingeJoint::get_param_f_max(void) const
  dReal return_value = ((*(const OdeHingeJoint*)local_this).get_param_f_max)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_f_max_476_comment =
  "C++ Interface:\n"
  "get_param_f_max(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_f_max_476_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_fudge_factor(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_fudge_factor_477(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHingeJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHingeJoint::get_param_fudge_factor(void) const
  dReal return_value = ((*(const OdeHingeJoint*)local_this).get_param_fudge_factor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_fudge_factor_477_comment =
  "C++ Interface:\n"
  "get_param_fudge_factor(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_fudge_factor_477_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_bounce(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_bounce_478(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHingeJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHingeJoint::get_param_bounce(void) const
  dReal return_value = ((*(const OdeHingeJoint*)local_this).get_param_bounce)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_bounce_478_comment =
  "C++ Interface:\n"
  "get_param_bounce(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_bounce_478_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_CFM(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_CFM_479(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHingeJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHingeJoint::get_param_CFM(void) const
  dReal return_value = ((*(const OdeHingeJoint*)local_this).get_param_CFM)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_CFM_479_comment =
  "C++ Interface:\n"
  "get_param_CFM(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_CFM_479_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_stop_ERP(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_stop_ERP_480(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHingeJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHingeJoint::get_param_stop_ERP(void) const
  dReal return_value = ((*(const OdeHingeJoint*)local_this).get_param_stop_ERP)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_stop_ERP_480_comment =
  "C++ Interface:\n"
  "get_param_stop_ERP(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_stop_ERP_480_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeHingeJoint::get_param_stop_CFM(void) const
 */
static PyObject *Dtool_OdeHingeJoint_get_param_stop_CFM_481(PyObject *self, PyObject *) {
  OdeHingeJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeHingeJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeHingeJoint::get_param_stop_CFM(void) const
  dReal return_value = ((*(const OdeHingeJoint*)local_this).get_param_stop_CFM)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_param_stop_CFM_481_comment =
  "C++ Interface:\n"
  "get_param_stop_CFM(OdeHingeJoint self)\n";
#else
static const char *Dtool_OdeHingeJoint_get_param_stop_CFM_481_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeHingeJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeHingeJoint_get_class_type_482(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeHingeJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeHingeJoint::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeHingeJoint_get_class_type_482_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeHingeJoint_get_class_type_482_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeHingeJoint::OdeHingeJoint(OdeWorld &world)
 * OdeHingeJoint::OdeHingeJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeHingeJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "world")) {
        // 1-OdeHingeJoint::OdeHingeJoint(OdeWorld &world)
        OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeHingeJoint.OdeHingeJoint", false, true);
        if (arg_this != nullptr) {
          OdeHingeJoint *return_value = new OdeHingeJoint(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHingeJoint, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-OdeHingeJoint::OdeHingeJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeHingeJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeHingeJoint.OdeHingeJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeHingeJoint.OdeHingeJoint", false, true);
        if (param0_this != nullptr && param1_this != nullptr) {
          OdeHingeJoint *return_value = new OdeHingeJoint(*param0_this, *param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeHingeJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeHingeJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeHingeJoint(OdeWorld world)\n"
      "OdeHingeJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeHingeJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeHingeJoint) {
    printf("OdeHingeJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeHingeJoint *local_this = (OdeHingeJoint *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeHingeJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeHingeJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeHingeJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeHingeJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeHingeJoint*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeJointCollection
 */
/**
 * Python function wrapper for:
 * void OdeJointCollection::operator =(OdeJointCollection const &copy)
 */
static PyObject *Dtool_OdeJointCollection_operator_485(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJointCollection, (void **)&local_this, "OdeJointCollection.assign")) {
    return nullptr;
  }
  // 1-void OdeJointCollection::operator =(OdeJointCollection const &copy)
  OdeJointCollection const *arg_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointCollection, 1, "OdeJointCollection.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    OdeJointCollection *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OdeJointCollection, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const OdeJointCollection self, const OdeJointCollection copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_operator_485_comment =
  "C++ Interface:\n"
  "assign(const OdeJointCollection self, const OdeJointCollection copy)\n";
#else
static const char *Dtool_OdeJointCollection_operator_485_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeJointCollection::add_joint(OdeJoint const &joint)
 */
static PyObject *Dtool_OdeJointCollection_add_joint_487(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJointCollection, (void **)&local_this, "OdeJointCollection.add_joint")) {
    return nullptr;
  }
  // 1-void OdeJointCollection::add_joint(OdeJoint const &joint)
  OdeJoint const *arg_this = (OdeJoint *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJoint, 1, "OdeJointCollection.add_joint", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_joint)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_joint(const OdeJointCollection self, const OdeJoint joint)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_add_joint_487_comment =
  "C++ Interface:\n"
  "add_joint(const OdeJointCollection self, const OdeJoint joint)\n";
#else
static const char *Dtool_OdeJointCollection_add_joint_487_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool OdeJointCollection::remove_joint(OdeJoint const &joint)
 */
static PyObject *Dtool_OdeJointCollection_remove_joint_488(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJointCollection, (void **)&local_this, "OdeJointCollection.remove_joint")) {
    return nullptr;
  }
  // 1-bool OdeJointCollection::remove_joint(OdeJoint const &joint)
  OdeJoint const *arg_this = (OdeJoint *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJoint, 1, "OdeJointCollection.remove_joint", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).remove_joint)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_joint(const OdeJointCollection self, const OdeJoint joint)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_remove_joint_488_comment =
  "C++ Interface:\n"
  "remove_joint(const OdeJointCollection self, const OdeJoint joint)\n";
#else
static const char *Dtool_OdeJointCollection_remove_joint_488_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeJointCollection::add_joints_from(OdeJointCollection const &other)
 */
static PyObject *Dtool_OdeJointCollection_add_joints_from_489(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJointCollection, (void **)&local_this, "OdeJointCollection.add_joints_from")) {
    return nullptr;
  }
  // 1-void OdeJointCollection::add_joints_from(OdeJointCollection const &other)
  OdeJointCollection const *arg_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointCollection, 1, "OdeJointCollection.add_joints_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_joints_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_joints_from(const OdeJointCollection self, const OdeJointCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_add_joints_from_489_comment =
  "C++ Interface:\n"
  "add_joints_from(const OdeJointCollection self, const OdeJointCollection other)\n";
#else
static const char *Dtool_OdeJointCollection_add_joints_from_489_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeJointCollection::remove_joints_from(OdeJointCollection const &other)
 */
static PyObject *Dtool_OdeJointCollection_remove_joints_from_490(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJointCollection, (void **)&local_this, "OdeJointCollection.remove_joints_from")) {
    return nullptr;
  }
  // 1-void OdeJointCollection::remove_joints_from(OdeJointCollection const &other)
  OdeJointCollection const *arg_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointCollection, 1, "OdeJointCollection.remove_joints_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_joints_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_joints_from(const OdeJointCollection self, const OdeJointCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_remove_joints_from_490_comment =
  "C++ Interface:\n"
  "remove_joints_from(const OdeJointCollection self, const OdeJointCollection other)\n";
#else
static const char *Dtool_OdeJointCollection_remove_joints_from_490_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeJointCollection::remove_duplicate_joints(void)
 */
static PyObject *Dtool_OdeJointCollection_remove_duplicate_joints_491(PyObject *self, PyObject *) {
  OdeJointCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJointCollection, (void **)&local_this, "OdeJointCollection.remove_duplicate_joints")) {
    return nullptr;
  }
  // 1-void OdeJointCollection::remove_duplicate_joints(void)
  ((*local_this).remove_duplicate_joints)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_remove_duplicate_joints_491_comment =
  "C++ Interface:\n"
  "remove_duplicate_joints(const OdeJointCollection self)\n";
#else
static const char *Dtool_OdeJointCollection_remove_duplicate_joints_491_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool OdeJointCollection::has_joint(OdeJoint const &joint) const
 */
static PyObject *Dtool_OdeJointCollection_has_joint_492(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJointCollection)) {
    return nullptr;
  }
  // 1-bool OdeJointCollection::has_joint(OdeJoint const &joint) const
  OdeJoint const *arg_this = (OdeJoint *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJoint, 1, "OdeJointCollection.has_joint", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const OdeJointCollection*)local_this).has_joint)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_joint(OdeJointCollection self, const OdeJoint joint)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_has_joint_492_comment =
  "C++ Interface:\n"
  "has_joint(OdeJointCollection self, const OdeJoint joint)\n";
#else
static const char *Dtool_OdeJointCollection_has_joint_492_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeJointCollection::clear(void)
 */
static PyObject *Dtool_OdeJointCollection_clear_493(PyObject *self, PyObject *) {
  OdeJointCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeJointCollection, (void **)&local_this, "OdeJointCollection.clear")) {
    return nullptr;
  }
  // 1-void OdeJointCollection::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_clear_493_comment =
  "C++ Interface:\n"
  "clear(const OdeJointCollection self)\n";
#else
static const char *Dtool_OdeJointCollection_clear_493_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool OdeJointCollection::is_empty(void) const
 */
static PyObject *Dtool_OdeJointCollection_is_empty_494(PyObject *self, PyObject *) {
  OdeJointCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJointCollection)) {
    return nullptr;
  }
  // 1-bool OdeJointCollection::is_empty(void) const
  bool return_value = ((*(const OdeJointCollection*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_is_empty_494_comment =
  "C++ Interface:\n"
  "is_empty(OdeJointCollection self)\n";
#else
static const char *Dtool_OdeJointCollection_is_empty_494_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int OdeJointCollection::get_num_joints(void) const
 */
static PyObject *Dtool_OdeJointCollection_get_num_joints_495(PyObject *self, PyObject *) {
  OdeJointCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJointCollection)) {
    return nullptr;
  }
  // 1-int OdeJointCollection::get_num_joints(void) const
  int return_value = ((*(const OdeJointCollection*)local_this).get_num_joints)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_get_num_joints_495_comment =
  "C++ Interface:\n"
  "get_num_joints(OdeJointCollection self)\n";
#else
static const char *Dtool_OdeJointCollection_get_num_joints_495_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeJoint OdeJointCollection::get_joint(int index) const
 */
static PyObject *Dtool_OdeJointCollection_get_joint_496(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeJointCollection)) {
    return nullptr;
  }
  // 1-OdeJoint OdeJointCollection::get_joint(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    OdeJoint *return_value = new OdeJoint(((*(const OdeJointCollection*)local_this).get_joint)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeJoint, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_joint(OdeJointCollection self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeJointCollection_get_joint_496_comment =
  "C++ Interface:\n"
  "get_joint(OdeJointCollection self, int index)\n";
#else
static const char *Dtool_OdeJointCollection_get_joint_496_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeJointCollection::OdeJointCollection(void)
 * OdeJointCollection::OdeJointCollection(OdeJointCollection const &copy)
 */
static int Dtool_Init_OdeJointCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-OdeJointCollection::OdeJointCollection(void)
      OdeJointCollection *return_value = new OdeJointCollection();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeJointCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-OdeJointCollection::OdeJointCollection(OdeJointCollection const &copy)
        OdeJointCollection const *arg_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointCollection, 0, "OdeJointCollection.OdeJointCollection", true, true);
        if (arg_this != nullptr) {
          OdeJointCollection *return_value = new OdeJointCollection(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeJointCollection, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeJointCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeJointCollection()\n"
      "OdeJointCollection(const OdeJointCollection copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_OdeJointCollection_get_joints(PyObject *self, PyObject *) {
  OdeJointCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointCollection, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_joints)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_OdeJointCollection_get_joint_496(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_OdeJointCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeJointCollection) {
    printf("OdeJointCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeJointCollection *local_this = (OdeJointCollection *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeJointCollection) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeJointCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeJointCollection) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeLMotorJoint
 */
/**
 * Python function wrapper for:
 * inline void OdeLMotorJoint::set_num_axes(int num)
 */
static PyObject *Dtool_OdeLMotorJoint_set_num_axes_504(PyObject *self, PyObject *arg) {
  OdeLMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeLMotorJoint, (void **)&local_this, "OdeLMotorJoint.set_num_axes")) {
    return nullptr;
  }
  // 1-inline void OdeLMotorJoint::set_num_axes(int num)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_num_axes)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_num_axes(const OdeLMotorJoint self, int num)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeLMotorJoint_set_num_axes_504_comment =
  "C++ Interface:\n"
  "set_num_axes(const OdeLMotorJoint self, int num)\n";
#else
static const char *Dtool_OdeLMotorJoint_set_num_axes_504_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeLMotorJoint::set_axis(int anum, int rel, LVecBase3f const &axis)
 * inline void OdeLMotorJoint::set_axis(int anum, int rel, dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeLMotorJoint_set_axis_505(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeLMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeLMotorJoint, (void **)&local_this, "OdeLMotorJoint.set_axis")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-inline void OdeLMotorJoint::set_axis(int anum, int rel, LVecBase3f const &axis)
      int param1;
      int param2;
      PyObject *param3;
      static const char *keyword_list[] = {"anum", "rel", "axis", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iiO:set_axis", (char **)keyword_list, &param1, &param2, &param3)) {
        LVecBase3f param3_local;
        LVecBase3f const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "OdeLMotorJoint.set_axis", "LVecBase3f");
        }
        ((*local_this).set_axis)((int)param1, (int)param2, *param3_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 5:
    {
      // 1-inline void OdeLMotorJoint::set_axis(int anum, int rel, dReal x, dReal y, dReal z)
      int param1;
      int param2;
      float param3;
      float param4;
      float param5;
      static const char *keyword_list[] = {"anum", "rel", "x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "iifff:set_axis", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
        ((*local_this).set_axis)((int)param1, (int)param2, (dReal)param3, (dReal)param4, (dReal)param5);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis() takes 4 or 6 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis(const OdeLMotorJoint self, int anum, int rel, const LVecBase3f axis)\n"
      "set_axis(const OdeLMotorJoint self, int anum, int rel, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeLMotorJoint_set_axis_505_comment =
  "C++ Interface:\n"
  "set_axis(const OdeLMotorJoint self, int anum, int rel, const LVecBase3f axis)\n"
  "set_axis(const OdeLMotorJoint self, int anum, int rel, float x, float y, float z)\n";
#else
static const char *Dtool_OdeLMotorJoint_set_axis_505_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeLMotorJoint::set_param(int parameter, dReal value)
 */
static PyObject *Dtool_OdeLMotorJoint_set_param_506(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeLMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeLMotorJoint, (void **)&local_this, "OdeLMotorJoint.set_param")) {
    return nullptr;
  }
  // 1-inline void OdeLMotorJoint::set_param(int parameter, dReal value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"parameter", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param(const OdeLMotorJoint self, int parameter, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeLMotorJoint_set_param_506_comment =
  "C++ Interface:\n"
  "set_param(const OdeLMotorJoint self, int parameter, float value)\n";
#else
static const char *Dtool_OdeLMotorJoint_set_param_506_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeLMotorJoint::get_num_axes(void) const
 */
static PyObject *Dtool_OdeLMotorJoint_get_num_axes_507(PyObject *self, PyObject *) {
  OdeLMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeLMotorJoint)) {
    return nullptr;
  }
  // 1-inline int OdeLMotorJoint::get_num_axes(void) const
  int return_value = ((*(const OdeLMotorJoint*)local_this).get_num_axes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeLMotorJoint_get_num_axes_507_comment =
  "C++ Interface:\n"
  "get_num_axes(OdeLMotorJoint self)\n";
#else
static const char *Dtool_OdeLMotorJoint_get_num_axes_507_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeLMotorJoint::get_axis(int anum) const
 */
static PyObject *Dtool_OdeLMotorJoint_get_axis_508(PyObject *self, PyObject *arg) {
  OdeLMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeLMotorJoint)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeLMotorJoint::get_axis(int anum) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    LVecBase3f *return_value = new LVecBase3f(((*(const OdeLMotorJoint*)local_this).get_axis)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_axis(OdeLMotorJoint self, int anum)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeLMotorJoint_get_axis_508_comment =
  "C++ Interface:\n"
  "get_axis(OdeLMotorJoint self, int anum)\n";
#else
static const char *Dtool_OdeLMotorJoint_get_axis_508_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeLMotorJoint::get_param(int parameter) const
 */
static PyObject *Dtool_OdeLMotorJoint_get_param_510(PyObject *self, PyObject *arg) {
  OdeLMotorJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeLMotorJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeLMotorJoint::get_param(int parameter) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeLMotorJoint*)local_this).get_param)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param(OdeLMotorJoint self, int parameter)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeLMotorJoint_get_param_510_comment =
  "C++ Interface:\n"
  "get_param(OdeLMotorJoint self, int parameter)\n";
#else
static const char *Dtool_OdeLMotorJoint_get_param_510_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeLMotorJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeLMotorJoint_get_class_type_511(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeLMotorJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeLMotorJoint::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeLMotorJoint_get_class_type_511_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeLMotorJoint_get_class_type_511_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeLMotorJoint::OdeLMotorJoint(OdeWorld &world)
 * OdeLMotorJoint::OdeLMotorJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeLMotorJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "world")) {
        // 1-OdeLMotorJoint::OdeLMotorJoint(OdeWorld &world)
        OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeLMotorJoint.OdeLMotorJoint", false, true);
        if (arg_this != nullptr) {
          OdeLMotorJoint *return_value = new OdeLMotorJoint(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeLMotorJoint, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-OdeLMotorJoint::OdeLMotorJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeLMotorJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeLMotorJoint.OdeLMotorJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeLMotorJoint.OdeLMotorJoint", false, true);
        if (param0_this != nullptr && param1_this != nullptr) {
          OdeLMotorJoint *return_value = new OdeLMotorJoint(*param0_this, *param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeLMotorJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeLMotorJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeLMotorJoint(OdeWorld world)\n"
      "OdeLMotorJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_OdeLMotorJoint_get_axes(PyObject *self, PyObject *) {
  OdeLMotorJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeLMotorJoint, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_axes)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_OdeLMotorJoint_get_axis_508(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_OdeLMotorJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeLMotorJoint) {
    printf("OdeLMotorJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeLMotorJoint *local_this = (OdeLMotorJoint *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeLMotorJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeLMotorJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeLMotorJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeLMotorJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeLMotorJoint*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeNullJoint
 */
/**
 * Python function wrapper for:
 * static TypeHandle OdeNullJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeNullJoint_get_class_type_514(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeNullJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeNullJoint::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeNullJoint_get_class_type_514_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeNullJoint_get_class_type_514_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeNullJoint::OdeNullJoint(OdeWorld &world)
 * OdeNullJoint::OdeNullJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeNullJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "world")) {
        // 1-OdeNullJoint::OdeNullJoint(OdeWorld &world)
        OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeNullJoint.OdeNullJoint", false, true);
        if (arg_this != nullptr) {
          OdeNullJoint *return_value = new OdeNullJoint(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeNullJoint, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-OdeNullJoint::OdeNullJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeNullJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeNullJoint.OdeNullJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeNullJoint.OdeNullJoint", false, true);
        if (param0_this != nullptr && param1_this != nullptr) {
          OdeNullJoint *return_value = new OdeNullJoint(*param0_this, *param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeNullJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeNullJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeNullJoint(OdeWorld world)\n"
      "OdeNullJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeNullJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeNullJoint) {
    printf("OdeNullJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeNullJoint *local_this = (OdeNullJoint *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeNullJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeNullJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeNullJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeNullJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeNullJoint*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdePlane2dJoint
 */
/**
 * Python function wrapper for:
 * inline void OdePlane2dJoint::set_x_param(int parameter, dReal value)
 */
static PyObject *Dtool_OdePlane2dJoint_set_x_param_517(PyObject *self, PyObject *args, PyObject *kwds) {
  OdePlane2dJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdePlane2dJoint, (void **)&local_this, "OdePlane2dJoint.set_x_param")) {
    return nullptr;
  }
  // 1-inline void OdePlane2dJoint::set_x_param(int parameter, dReal value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"parameter", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_x_param", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_x_param)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x_param(const OdePlane2dJoint self, int parameter, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdePlane2dJoint_set_x_param_517_comment =
  "C++ Interface:\n"
  "set_x_param(const OdePlane2dJoint self, int parameter, float value)\n";
#else
static const char *Dtool_OdePlane2dJoint_set_x_param_517_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdePlane2dJoint::set_y_param(int parameter, dReal value)
 */
static PyObject *Dtool_OdePlane2dJoint_set_y_param_518(PyObject *self, PyObject *args, PyObject *kwds) {
  OdePlane2dJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdePlane2dJoint, (void **)&local_this, "OdePlane2dJoint.set_y_param")) {
    return nullptr;
  }
  // 1-inline void OdePlane2dJoint::set_y_param(int parameter, dReal value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"parameter", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_y_param", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_y_param)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y_param(const OdePlane2dJoint self, int parameter, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdePlane2dJoint_set_y_param_518_comment =
  "C++ Interface:\n"
  "set_y_param(const OdePlane2dJoint self, int parameter, float value)\n";
#else
static const char *Dtool_OdePlane2dJoint_set_y_param_518_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdePlane2dJoint::set_angle_param(int parameter, dReal value)
 */
static PyObject *Dtool_OdePlane2dJoint_set_angle_param_519(PyObject *self, PyObject *args, PyObject *kwds) {
  OdePlane2dJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdePlane2dJoint, (void **)&local_this, "OdePlane2dJoint.set_angle_param")) {
    return nullptr;
  }
  // 1-inline void OdePlane2dJoint::set_angle_param(int parameter, dReal value)
  int param1;
  float param2;
  static const char *keyword_list[] = {"parameter", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_angle_param", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_angle_param)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_angle_param(const OdePlane2dJoint self, int parameter, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdePlane2dJoint_set_angle_param_519_comment =
  "C++ Interface:\n"
  "set_angle_param(const OdePlane2dJoint self, int parameter, float value)\n";
#else
static const char *Dtool_OdePlane2dJoint_set_angle_param_519_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdePlane2dJoint::get_class_type(void)
 */
static PyObject *Dtool_OdePlane2dJoint_get_class_type_520(PyObject *, PyObject *) {
  // 1-static TypeHandle OdePlane2dJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdePlane2dJoint::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdePlane2dJoint_get_class_type_520_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdePlane2dJoint_get_class_type_520_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdePlane2dJoint::OdePlane2dJoint(OdeWorld &world)
 * OdePlane2dJoint::OdePlane2dJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdePlane2dJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "world")) {
        // 1-OdePlane2dJoint::OdePlane2dJoint(OdeWorld &world)
        OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdePlane2dJoint.OdePlane2dJoint", false, true);
        if (arg_this != nullptr) {
          OdePlane2dJoint *return_value = new OdePlane2dJoint(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdePlane2dJoint, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-OdePlane2dJoint::OdePlane2dJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdePlane2dJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdePlane2dJoint.OdePlane2dJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdePlane2dJoint.OdePlane2dJoint", false, true);
        if (param0_this != nullptr && param1_this != nullptr) {
          OdePlane2dJoint *return_value = new OdePlane2dJoint(*param0_this, *param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdePlane2dJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdePlane2dJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdePlane2dJoint(OdeWorld world)\n"
      "OdePlane2dJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdePlane2dJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdePlane2dJoint) {
    printf("OdePlane2dJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdePlane2dJoint *local_this = (OdePlane2dJoint *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdePlane2dJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdePlane2dJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdePlane2dJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdePlane2dJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdePlane2dJoint*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdePlaneGeom
 */
/**
 * Python function wrapper for:
 * inline void OdePlaneGeom::set_params(LVecBase4f const &params)
 * inline void OdePlaneGeom::set_params(dReal a, dReal b, dReal c, dReal d)
 */
static PyObject *Dtool_OdePlaneGeom_set_params_523(PyObject *self, PyObject *args, PyObject *kwds) {
  OdePlaneGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdePlaneGeom, (void **)&local_this, "OdePlaneGeom.set_params")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "params")) {
        // 1-inline void OdePlaneGeom::set_params(LVecBase4f const &params)
        LVecBase4f arg_local;
        LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdePlaneGeom.set_params", "LVecBase4f");
        }
        ((*local_this).set_params)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void OdePlaneGeom::set_params(dReal a, dReal b, dReal c, dReal d)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"a", "b", "c", "d", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_params", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_params)((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_params() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_params(const OdePlaneGeom self, const LVecBase4f params)\n"
      "set_params(const OdePlaneGeom self, float a, float b, float c, float d)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdePlaneGeom_set_params_523_comment =
  "C++ Interface:\n"
  "set_params(const OdePlaneGeom self, const LVecBase4f params)\n"
  "set_params(const OdePlaneGeom self, float a, float b, float c, float d)\n";
#else
static const char *Dtool_OdePlaneGeom_set_params_523_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4f OdePlaneGeom::get_params(void) const
 */
static PyObject *Dtool_OdePlaneGeom_get_params_524(PyObject *self, PyObject *) {
  OdePlaneGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdePlaneGeom)) {
    return nullptr;
  }
  // 1-inline LVecBase4f OdePlaneGeom::get_params(void) const
  LVecBase4f *return_value = new LVecBase4f(((*(const OdePlaneGeom*)local_this).get_params)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdePlaneGeom_get_params_524_comment =
  "C++ Interface:\n"
  "get_params(OdePlaneGeom self)\n";
#else
static const char *Dtool_OdePlaneGeom_get_params_524_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdePlaneGeom::get_point_depth(LPoint3f const &p) const
 * inline dReal OdePlaneGeom::get_point_depth(dReal x, dReal y, dReal z) const
 */
static PyObject *Dtool_OdePlaneGeom_get_point_depth_525(PyObject *self, PyObject *args, PyObject *kwds) {
  OdePlaneGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdePlaneGeom)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "p")) {
        // 1-inline dReal OdePlaneGeom::get_point_depth(LPoint3f const &p) const
        LPoint3f arg_local;
        LPoint3f const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdePlaneGeom.get_point_depth", "LPoint3f");
        }
        dReal return_value = ((*(const OdePlaneGeom*)local_this).get_point_depth)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-inline dReal OdePlaneGeom::get_point_depth(dReal x, dReal y, dReal z) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:get_point_depth", (char **)keyword_list, &param1, &param2, &param3)) {
        dReal return_value = ((*(const OdePlaneGeom*)local_this).get_point_depth)((dReal)param1, (dReal)param2, (dReal)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_point_depth() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point_depth(OdePlaneGeom self, const LPoint3f p)\n"
      "get_point_depth(OdePlaneGeom self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdePlaneGeom_get_point_depth_525_comment =
  "C++ Interface:\n"
  "get_point_depth(OdePlaneGeom self, const LPoint3f p)\n"
  "get_point_depth(OdePlaneGeom self, float x, float y, float z)\n";
#else
static const char *Dtool_OdePlaneGeom_get_point_depth_525_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdePlaneGeom::get_class_type(void)
 */
static PyObject *Dtool_OdePlaneGeom_get_class_type_526(PyObject *, PyObject *) {
  // 1-static TypeHandle OdePlaneGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdePlaneGeom::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdePlaneGeom_get_class_type_526_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdePlaneGeom_get_class_type_526_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdePlaneGeom::OdePlaneGeom(LVecBase4f const &params)
 * OdePlaneGeom::OdePlaneGeom(OdeSpace &space, LVecBase4f const &params)
 * OdePlaneGeom::OdePlaneGeom(OdeSpace &space, dReal a, dReal b, dReal c, dReal d)
 * OdePlaneGeom::OdePlaneGeom(dReal a, dReal b, dReal c, dReal d)
 */
static int Dtool_Init_OdePlaneGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "params")) {
        // 1-OdePlaneGeom::OdePlaneGeom(LVecBase4f const &params)
        LVecBase4f arg_local;
        LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          Dtool_Raise_ArgTypeError(arg, 0, "OdePlaneGeom.OdePlaneGeom", "LVecBase4f");
          return -1;
        }
        OdePlaneGeom *return_value = new OdePlaneGeom(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdePlaneGeom, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-OdePlaneGeom::OdePlaneGeom(OdeSpace &space, LVecBase4f const &params)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"space", "params", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdePlaneGeom", (char **)keyword_list, &param0, &param1)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdePlaneGeom.OdePlaneGeom", false, true);
        LVecBase4f param1_local;
        LVecBase4f const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "OdePlaneGeom.OdePlaneGeom", "LVecBase4f");
          return -1;
        }
        if (param0_this != nullptr) {
          OdePlaneGeom *return_value = new OdePlaneGeom(*param0_this, *param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdePlaneGeom, true, false);
        }
      }
    }
    break;
  case 4:
    {
      // 1-OdePlaneGeom::OdePlaneGeom(dReal a, dReal b, dReal c, dReal d)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"a", "b", "c", "d", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:OdePlaneGeom", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        OdePlaneGeom *return_value = new OdePlaneGeom((dReal)param0, (dReal)param1, (dReal)param2, (dReal)param3);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdePlaneGeom, true, false);
      }
    }
    break;
  case 5:
    {
      // 1-OdePlaneGeom::OdePlaneGeom(OdeSpace &space, dReal a, dReal b, dReal c, dReal d)
      PyObject *param0;
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"space", "a", "b", "c", "d", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Offff:OdePlaneGeom", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdePlaneGeom.OdePlaneGeom", false, true);
        if (param0_this != nullptr) {
          OdePlaneGeom *return_value = new OdePlaneGeom(*param0_this, (dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdePlaneGeom, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdePlaneGeom() takes 1, 2, 4 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdePlaneGeom(const LVecBase4f params)\n"
      "OdePlaneGeom(OdeSpace space, const LVecBase4f params)\n"
      "OdePlaneGeom(float a, float b, float c, float d)\n"
      "OdePlaneGeom(OdeSpace space, float a, float b, float c, float d)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdePlaneGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdePlaneGeom) {
    printf("OdePlaneGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdePlaneGeom *local_this = (OdePlaneGeom *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdePlaneGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeGeom) {
    return (OdeGeom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeGeom *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdePlaneGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdePlaneGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeGeom) {
    OdeGeom* other_this = (OdeGeom*)from_this;
    return (OdePlaneGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdePlaneGeom*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeQuadTreeSpace
 */
/**
 * Python function wrapper for:
 * static TypeHandle OdeQuadTreeSpace::get_class_type(void)
 */
static PyObject *Dtool_OdeQuadTreeSpace_get_class_type_529(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeQuadTreeSpace::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeQuadTreeSpace::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeQuadTreeSpace_get_class_type_529_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeQuadTreeSpace_get_class_type_529_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeQuadTreeSpace::OdeQuadTreeSpace(LPoint3f const &center, LVecBase3f const &extents, int const depth)
 * OdeQuadTreeSpace::OdeQuadTreeSpace(OdeSpace &space, LPoint3f const &center, LVecBase3f const &extents, int const depth)
 */
static int Dtool_Init_OdeQuadTreeSpace(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 3:
    {
      // 1-OdeQuadTreeSpace::OdeQuadTreeSpace(LPoint3f const &center, LVecBase3f const &extents, int const depth)
      PyObject *param0;
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"center", "extents", "depth", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:OdeQuadTreeSpace", (char **)keyword_list, &param0, &param1, &param2)) {
        LPoint3f param0_local;
        LPoint3f const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "OdeQuadTreeSpace.OdeQuadTreeSpace", "LPoint3f");
          return -1;
        }
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "OdeQuadTreeSpace.OdeQuadTreeSpace", "LVecBase3f");
          return -1;
        }
        OdeQuadTreeSpace *return_value = new OdeQuadTreeSpace(*param0_this, *param1_this, (int const)param2);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeQuadTreeSpace, true, false);
      }
    }
    break;
  case 4:
    {
      // 1-OdeQuadTreeSpace::OdeQuadTreeSpace(OdeSpace &space, LPoint3f const &center, LVecBase3f const &extents, int const depth)
      PyObject *param0;
      PyObject *param1;
      PyObject *param2;
      int param3;
      static const char *keyword_list[] = {"space", "center", "extents", "depth", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOi:OdeQuadTreeSpace", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeQuadTreeSpace.OdeQuadTreeSpace", false, true);
        LPoint3f param1_local;
        LPoint3f const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "OdeQuadTreeSpace.OdeQuadTreeSpace", "LPoint3f");
          return -1;
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param2, 2, "OdeQuadTreeSpace.OdeQuadTreeSpace", "LVecBase3f");
          return -1;
        }
        if (param0_this != nullptr) {
          OdeQuadTreeSpace *return_value = new OdeQuadTreeSpace(*param0_this, *param1_this, *param2_this, (int const)param3);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeQuadTreeSpace, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeQuadTreeSpace() takes 3 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeQuadTreeSpace(const LPoint3f center, const LVecBase3f extents, int depth)\n"
      "OdeQuadTreeSpace(OdeSpace space, const LPoint3f center, const LVecBase3f extents, int depth)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeQuadTreeSpace(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeQuadTreeSpace) {
    printf("OdeQuadTreeSpace ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeQuadTreeSpace *local_this = (OdeQuadTreeSpace *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeQuadTreeSpace) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeSpace) {
    return (OdeSpace *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeSpace *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeQuadTreeSpace(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeQuadTreeSpace) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeSpace) {
    OdeSpace* other_this = (OdeSpace*)from_this;
    return (OdeQuadTreeSpace*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeQuadTreeSpace*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeRayGeom
 */
/**
 * Python function wrapper for:
 * inline void OdeRayGeom::set_length(dReal length)
 */
static PyObject *Dtool_OdeRayGeom_set_length_532(PyObject *self, PyObject *arg) {
  OdeRayGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeRayGeom, (void **)&local_this, "OdeRayGeom.set_length")) {
    return nullptr;
  }
  // 1-inline void OdeRayGeom::set_length(dReal length)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_length)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_length(const OdeRayGeom self, float length)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_set_length_532_comment =
  "C++ Interface:\n"
  "set_length(const OdeRayGeom self, float length)\n";
#else
static const char *Dtool_OdeRayGeom_set_length_532_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeRayGeom::get_length(void)
 */
static PyObject *Dtool_OdeRayGeom_get_length_533(PyObject *self, PyObject *) {
  OdeRayGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeRayGeom, (void **)&local_this, "OdeRayGeom.get_length")) {
    return nullptr;
  }
  // 1-inline dReal OdeRayGeom::get_length(void)
  dReal return_value = ((*local_this).get_length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_get_length_533_comment =
  "C++ Interface:\n"
  "get_length(const OdeRayGeom self)\n";
#else
static const char *Dtool_OdeRayGeom_get_length_533_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeRayGeom::set(LVecBase3f const &start, LVecBase3f const &dir)
 * inline void OdeRayGeom::set(dReal px, dReal py, dReal pz, dReal dx, dReal dy, dReal dz)
 */
static PyObject *Dtool_OdeRayGeom_set_534(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeRayGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeRayGeom, (void **)&local_this, "OdeRayGeom.set")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeRayGeom::set(LVecBase3f const &start, LVecBase3f const &dir)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"start", "dir", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "OdeRayGeom.set", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeRayGeom.set", "LVecBase3f");
        }
        ((*local_this).set)(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void OdeRayGeom::set(dReal px, dReal py, dReal pz, dReal dx, dReal dy, dReal dz)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"px", "py", "pz", "dx", "dy", "dz", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:set", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        ((*local_this).set)((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set(const OdeRayGeom self, const LVecBase3f start, const LVecBase3f dir)\n"
      "set(const OdeRayGeom self, float px, float py, float pz, float dx, float dy, float dz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_set_534_comment =
  "C++ Interface:\n"
  "set(const OdeRayGeom self, const LVecBase3f start, const LVecBase3f dir)\n"
  "set(const OdeRayGeom self, float px, float py, float pz, float dx, float dy, float dz)\n";
#else
static const char *Dtool_OdeRayGeom_set_534_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeRayGeom::get(LVecBase3f &start, LVecBase3f &dir) const
 */
static PyObject *Dtool_OdeRayGeom_get_535(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeRayGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeRayGeom)) {
    return nullptr;
  }
  // 1-inline void OdeRayGeom::get(LVecBase3f &start, LVecBase3f &dir) const
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"start", "dir", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param1_local;
    LVecBase3f *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "OdeRayGeom.get", "LVecBase3f");
    }
    LVecBase3f param2_local;
    LVecBase3f *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "OdeRayGeom.get", "LVecBase3f");
    }
    ((*(const OdeRayGeom*)local_this).get)(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get(OdeRayGeom self, LVecBase3f start, LVecBase3f dir)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_get_535_comment =
  "C++ Interface:\n"
  "get(OdeRayGeom self, LVecBase3f start, LVecBase3f dir)\n";
#else
static const char *Dtool_OdeRayGeom_get_535_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeRayGeom::get_start(void) const
 */
static PyObject *Dtool_OdeRayGeom_get_start_536(PyObject *self, PyObject *) {
  OdeRayGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeRayGeom)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeRayGeom::get_start(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeRayGeom*)local_this).get_start)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_get_start_536_comment =
  "C++ Interface:\n"
  "get_start(OdeRayGeom self)\n";
#else
static const char *Dtool_OdeRayGeom_get_start_536_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeRayGeom::get_direction(void) const
 */
static PyObject *Dtool_OdeRayGeom_get_direction_537(PyObject *self, PyObject *) {
  OdeRayGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeRayGeom)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeRayGeom::get_direction(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeRayGeom*)local_this).get_direction)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_get_direction_537_comment =
  "C++ Interface:\n"
  "get_direction(OdeRayGeom self)\n";
#else
static const char *Dtool_OdeRayGeom_get_direction_537_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeRayGeom::set_params(int first_contact, int backface_cull)
 */
static PyObject *Dtool_OdeRayGeom_set_params_538(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeRayGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeRayGeom, (void **)&local_this, "OdeRayGeom.set_params")) {
    return nullptr;
  }
  // 1-inline void OdeRayGeom::set_params(int first_contact, int backface_cull)
  int param1;
  int param2;
  static const char *keyword_list[] = {"first_contact", "backface_cull", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_params", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_params)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_params(const OdeRayGeom self, int first_contact, int backface_cull)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_set_params_538_comment =
  "C++ Interface:\n"
  "set_params(const OdeRayGeom self, int first_contact, int backface_cull)\n";
#else
static const char *Dtool_OdeRayGeom_set_params_538_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeRayGeom::get_first_contact(void) const
 */
static PyObject *Dtool_OdeRayGeom_get_first_contact_540(PyObject *self, PyObject *) {
  OdeRayGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeRayGeom)) {
    return nullptr;
  }
  // 1-inline int OdeRayGeom::get_first_contact(void) const
  int return_value = ((*(const OdeRayGeom*)local_this).get_first_contact)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_get_first_contact_540_comment =
  "C++ Interface:\n"
  "get_first_contact(OdeRayGeom self)\n";
#else
static const char *Dtool_OdeRayGeom_get_first_contact_540_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeRayGeom::get_backface_cull(void) const
 */
static PyObject *Dtool_OdeRayGeom_get_backface_cull_541(PyObject *self, PyObject *) {
  OdeRayGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeRayGeom)) {
    return nullptr;
  }
  // 1-inline int OdeRayGeom::get_backface_cull(void) const
  int return_value = ((*(const OdeRayGeom*)local_this).get_backface_cull)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_get_backface_cull_541_comment =
  "C++ Interface:\n"
  "get_backface_cull(OdeRayGeom self)\n";
#else
static const char *Dtool_OdeRayGeom_get_backface_cull_541_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeRayGeom::set_closest_hit(int closest_hit)
 */
static PyObject *Dtool_OdeRayGeom_set_closest_hit_542(PyObject *self, PyObject *arg) {
  OdeRayGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeRayGeom, (void **)&local_this, "OdeRayGeom.set_closest_hit")) {
    return nullptr;
  }
  // 1-inline void OdeRayGeom::set_closest_hit(int closest_hit)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_closest_hit)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_closest_hit(const OdeRayGeom self, int closest_hit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_set_closest_hit_542_comment =
  "C++ Interface:\n"
  "set_closest_hit(const OdeRayGeom self, int closest_hit)\n";
#else
static const char *Dtool_OdeRayGeom_set_closest_hit_542_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeRayGeom::get_closest_hit(void)
 */
static PyObject *Dtool_OdeRayGeom_get_closest_hit_543(PyObject *self, PyObject *) {
  OdeRayGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeRayGeom, (void **)&local_this, "OdeRayGeom.get_closest_hit")) {
    return nullptr;
  }
  // 1-inline int OdeRayGeom::get_closest_hit(void)
  int return_value = ((*local_this).get_closest_hit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_get_closest_hit_543_comment =
  "C++ Interface:\n"
  "get_closest_hit(const OdeRayGeom self)\n";
#else
static const char *Dtool_OdeRayGeom_get_closest_hit_543_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeRayGeom::get_class_type(void)
 */
static PyObject *Dtool_OdeRayGeom_get_class_type_544(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeRayGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeRayGeom::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeRayGeom_get_class_type_544_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeRayGeom_get_class_type_544_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeRayGeom::OdeRayGeom(OdeSpace &space, dReal length)
 * OdeRayGeom::OdeRayGeom(dReal length)
 */
static int Dtool_Init_OdeRayGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "length")) {
        // 1-OdeRayGeom::OdeRayGeom(dReal length)
        if (PyNumber_Check(arg)) {
          OdeRayGeom *return_value = new OdeRayGeom((dReal)PyFloat_AsDouble(arg));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeRayGeom, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-OdeRayGeom::OdeRayGeom(OdeSpace &space, dReal length)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"space", "length", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:OdeRayGeom", (char **)keyword_list, &param0, &param1)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeRayGeom.OdeRayGeom", false, true);
        if (param0_this != nullptr) {
          OdeRayGeom *return_value = new OdeRayGeom(*param0_this, (dReal)param1);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeRayGeom, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeRayGeom() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeRayGeom(float length)\n"
      "OdeRayGeom(OdeSpace space, float length)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeRayGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeRayGeom) {
    printf("OdeRayGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeRayGeom *local_this = (OdeRayGeom *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeRayGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeGeom) {
    return (OdeGeom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeGeom *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeRayGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeRayGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeGeom) {
    OdeGeom* other_this = (OdeGeom*)from_this;
    return (OdeRayGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeRayGeom*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeSimpleSpace
 */
/**
 * Python function wrapper for:
 * static TypeHandle OdeSimpleSpace::get_class_type(void)
 */
static PyObject *Dtool_OdeSimpleSpace_get_class_type_547(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeSimpleSpace::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeSimpleSpace::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeSimpleSpace_get_class_type_547_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeSimpleSpace_get_class_type_547_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeSimpleSpace::OdeSimpleSpace(void)
 * OdeSimpleSpace::OdeSimpleSpace(OdeSpace &space)
 */
static int Dtool_Init_OdeSimpleSpace(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-OdeSimpleSpace::OdeSimpleSpace(void)
      OdeSimpleSpace *return_value = new OdeSimpleSpace();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSimpleSpace, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "space")) {
        // 1-OdeSimpleSpace::OdeSimpleSpace(OdeSpace &space)
        OdeSpace *arg_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeSpace, 0, "OdeSimpleSpace.OdeSimpleSpace", false, true);
        if (arg_this != nullptr) {
          OdeSimpleSpace *return_value = new OdeSimpleSpace(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSimpleSpace, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeSimpleSpace() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeSimpleSpace()\n"
      "OdeSimpleSpace(OdeSpace space)\n");
  }
  return -1;
}

OdeSimpleSpace *Dtool_Coerce_OdeSimpleSpace(PyObject *args, OdeSimpleSpace &coerced) {
  OdeSimpleSpace *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_OdeSimpleSpace)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const OdeSimpleSpace *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeSimpleSpace::OdeSimpleSpace(OdeSpace &space)
    OdeSpace *arg_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeSpace, 0, "OdeSimpleSpace.OdeSimpleSpace", false, false);
    if (arg_this != nullptr) {
      coerced = OdeSimpleSpace(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_OdeSimpleSpace(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeSimpleSpace) {
    printf("OdeSimpleSpace ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeSimpleSpace *local_this = (OdeSimpleSpace *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeSimpleSpace) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeSpace) {
    return (OdeSpace *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeSpace *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeSimpleSpace(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeSimpleSpace) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeSpace) {
    OdeSpace* other_this = (OdeSpace*)from_this;
    return (OdeSimpleSpace*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeSimpleSpace*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeSliderJoint
 */
/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_axis(LVecBase3f const &axis)
 * inline void OdeSliderJoint::set_axis(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeSliderJoint_set_axis_550(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeSliderJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_axis")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "axis")) {
        // 1-inline void OdeSliderJoint::set_axis(LVecBase3f const &axis)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeSliderJoint.set_axis", "LVecBase3f");
        }
        ((*local_this).set_axis)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeSliderJoint::set_axis(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_axis", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_axis)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis(const OdeSliderJoint self, const LVecBase3f axis)\n"
      "set_axis(const OdeSliderJoint self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_axis_550_comment =
  "C++ Interface:\n"
  "set_axis(const OdeSliderJoint self, const LVecBase3f axis)\n"
  "set_axis(const OdeSliderJoint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeSliderJoint_set_axis_550_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_axis_delta(LVecBase3f const &axis, LVecBase3f const &vec)
 * inline void OdeSliderJoint::set_axis_delta(dReal x, dReal y, dReal z, dReal ax, dReal ay, dReal az)
 */
static PyObject *Dtool_OdeSliderJoint_set_axis_delta_551(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeSliderJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_axis_delta")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void OdeSliderJoint::set_axis_delta(LVecBase3f const &axis, LVecBase3f const &vec)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"axis", "vec", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_axis_delta", (char **)keyword_list, &param1, &param2)) {
        LVecBase3f param1_local;
        LVecBase3f const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "OdeSliderJoint.set_axis_delta", "LVecBase3f");
        }
        LVecBase3f param2_local;
        LVecBase3f const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "OdeSliderJoint.set_axis_delta", "LVecBase3f");
        }
        ((*local_this).set_axis_delta)(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 6:
    {
      // 1-inline void OdeSliderJoint::set_axis_delta(dReal x, dReal y, dReal z, dReal ax, dReal ay, dReal az)
      float param1;
      float param2;
      float param3;
      float param4;
      float param5;
      float param6;
      static const char *keyword_list[] = {"x", "y", "z", "ax", "ay", "az", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffffff:set_axis_delta", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5, &param6)) {
        ((*local_this).set_axis_delta)((dReal)param1, (dReal)param2, (dReal)param3, (dReal)param4, (dReal)param5, (dReal)param6);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis_delta() takes 3 or 7 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis_delta(const OdeSliderJoint self, const LVecBase3f axis, const LVecBase3f vec)\n"
      "set_axis_delta(const OdeSliderJoint self, float x, float y, float z, float ax, float ay, float az)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_axis_delta_551_comment =
  "C++ Interface:\n"
  "set_axis_delta(const OdeSliderJoint self, const LVecBase3f axis, const LVecBase3f vec)\n"
  "set_axis_delta(const OdeSliderJoint self, float x, float y, float z, float ax, float ay, float az)\n";
#else
static const char *Dtool_OdeSliderJoint_set_axis_delta_551_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::add_force(dReal force)
 */
static PyObject *Dtool_OdeSliderJoint_add_force_552(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.add_force")) {
    return nullptr;
  }
  // 1-inline void OdeSliderJoint::add_force(dReal force)
  if (PyNumber_Check(arg)) {
    ((*local_this).add_force)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_force(const OdeSliderJoint self, float force)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_add_force_552_comment =
  "C++ Interface:\n"
  "add_force(const OdeSliderJoint self, float force)\n";
#else
static const char *Dtool_OdeSliderJoint_add_force_552_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_position(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_position_553(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSliderJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeSliderJoint::get_position(void) const
  dReal return_value = ((*(const OdeSliderJoint*)local_this).get_position)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_position_553_comment =
  "C++ Interface:\n"
  "get_position(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_position_553_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_position_rate(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_position_rate_554(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSliderJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeSliderJoint::get_position_rate(void) const
  dReal return_value = ((*(const OdeSliderJoint*)local_this).get_position_rate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_position_rate_554_comment =
  "C++ Interface:\n"
  "get_position_rate(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_position_rate_554_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeSliderJoint::get_axis(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_axis_555(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSliderJoint)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeSliderJoint::get_axis(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeSliderJoint*)local_this).get_axis)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_axis_555_comment =
  "C++ Interface:\n"
  "get_axis(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_axis_555_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_lo_stop(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_lo_stop_556(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_lo_stop")) {
    return nullptr;
  }
  // 1-inline void OdeSliderJoint::set_param_lo_stop(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_lo_stop)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_lo_stop(const OdeSliderJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_lo_stop_556_comment =
  "C++ Interface:\n"
  "set_param_lo_stop(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_lo_stop_556_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_hi_stop(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_hi_stop_557(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_hi_stop")) {
    return nullptr;
  }
  // 1-inline void OdeSliderJoint::set_param_hi_stop(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_hi_stop)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_hi_stop(const OdeSliderJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_hi_stop_557_comment =
  "C++ Interface:\n"
  "set_param_hi_stop(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_hi_stop_557_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_vel(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_vel_558(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_vel")) {
    return nullptr;
  }
  // 1-inline void OdeSliderJoint::set_param_vel(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_vel)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_vel(const OdeSliderJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_vel_558_comment =
  "C++ Interface:\n"
  "set_param_vel(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_vel_558_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_f_max(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_f_max_559(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_f_max")) {
    return nullptr;
  }
  // 1-inline void OdeSliderJoint::set_param_f_max(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_f_max)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_f_max(const OdeSliderJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_f_max_559_comment =
  "C++ Interface:\n"
  "set_param_f_max(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_f_max_559_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_fudge_factor(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_fudge_factor_560(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_fudge_factor")) {
    return nullptr;
  }
  // 1-inline void OdeSliderJoint::set_param_fudge_factor(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_fudge_factor)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_fudge_factor(const OdeSliderJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_fudge_factor_560_comment =
  "C++ Interface:\n"
  "set_param_fudge_factor(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_fudge_factor_560_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_bounce(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_bounce_561(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_bounce")) {
    return nullptr;
  }
  // 1-inline void OdeSliderJoint::set_param_bounce(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_bounce)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_bounce(const OdeSliderJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_bounce_561_comment =
  "C++ Interface:\n"
  "set_param_bounce(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_bounce_561_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_CFM(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_CFM_562(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_CFM")) {
    return nullptr;
  }
  // 1-inline void OdeSliderJoint::set_param_CFM(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_CFM)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_CFM(const OdeSliderJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_CFM_562_comment =
  "C++ Interface:\n"
  "set_param_CFM(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_CFM_562_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_stop_ERP(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_stop_ERP_563(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_stop_ERP")) {
    return nullptr;
  }
  // 1-inline void OdeSliderJoint::set_param_stop_ERP(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_stop_ERP)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_ERP(const OdeSliderJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_stop_ERP_563_comment =
  "C++ Interface:\n"
  "set_param_stop_ERP(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_stop_ERP_563_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeSliderJoint::set_param_stop_CFM(dReal val)
 */
static PyObject *Dtool_OdeSliderJoint_set_param_stop_CFM_564(PyObject *self, PyObject *arg) {
  OdeSliderJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSliderJoint, (void **)&local_this, "OdeSliderJoint.set_param_stop_CFM")) {
    return nullptr;
  }
  // 1-inline void OdeSliderJoint::set_param_stop_CFM(dReal val)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_param_stop_CFM)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_CFM(const OdeSliderJoint self, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_set_param_stop_CFM_564_comment =
  "C++ Interface:\n"
  "set_param_stop_CFM(const OdeSliderJoint self, float val)\n";
#else
static const char *Dtool_OdeSliderJoint_set_param_stop_CFM_564_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_lo_stop(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_lo_stop_565(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSliderJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeSliderJoint::get_param_lo_stop(void) const
  dReal return_value = ((*(const OdeSliderJoint*)local_this).get_param_lo_stop)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_lo_stop_565_comment =
  "C++ Interface:\n"
  "get_param_lo_stop(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_lo_stop_565_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_hi_stop(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_hi_stop_566(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSliderJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeSliderJoint::get_param_hi_stop(void) const
  dReal return_value = ((*(const OdeSliderJoint*)local_this).get_param_hi_stop)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_hi_stop_566_comment =
  "C++ Interface:\n"
  "get_param_hi_stop(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_hi_stop_566_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_vel(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_vel_567(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSliderJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeSliderJoint::get_param_vel(void) const
  dReal return_value = ((*(const OdeSliderJoint*)local_this).get_param_vel)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_vel_567_comment =
  "C++ Interface:\n"
  "get_param_vel(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_vel_567_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_f_max(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_f_max_568(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSliderJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeSliderJoint::get_param_f_max(void) const
  dReal return_value = ((*(const OdeSliderJoint*)local_this).get_param_f_max)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_f_max_568_comment =
  "C++ Interface:\n"
  "get_param_f_max(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_f_max_568_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_fudge_factor(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_fudge_factor_569(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSliderJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeSliderJoint::get_param_fudge_factor(void) const
  dReal return_value = ((*(const OdeSliderJoint*)local_this).get_param_fudge_factor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_fudge_factor_569_comment =
  "C++ Interface:\n"
  "get_param_fudge_factor(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_fudge_factor_569_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_bounce(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_bounce_570(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSliderJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeSliderJoint::get_param_bounce(void) const
  dReal return_value = ((*(const OdeSliderJoint*)local_this).get_param_bounce)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_bounce_570_comment =
  "C++ Interface:\n"
  "get_param_bounce(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_bounce_570_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_CFM(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_CFM_571(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSliderJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeSliderJoint::get_param_CFM(void) const
  dReal return_value = ((*(const OdeSliderJoint*)local_this).get_param_CFM)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_CFM_571_comment =
  "C++ Interface:\n"
  "get_param_CFM(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_CFM_571_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_stop_ERP(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_stop_ERP_572(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSliderJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeSliderJoint::get_param_stop_ERP(void) const
  dReal return_value = ((*(const OdeSliderJoint*)local_this).get_param_stop_ERP)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_stop_ERP_572_comment =
  "C++ Interface:\n"
  "get_param_stop_ERP(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_stop_ERP_572_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSliderJoint::get_param_stop_CFM(void) const
 */
static PyObject *Dtool_OdeSliderJoint_get_param_stop_CFM_573(PyObject *self, PyObject *) {
  OdeSliderJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSliderJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeSliderJoint::get_param_stop_CFM(void) const
  dReal return_value = ((*(const OdeSliderJoint*)local_this).get_param_stop_CFM)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_param_stop_CFM_573_comment =
  "C++ Interface:\n"
  "get_param_stop_CFM(OdeSliderJoint self)\n";
#else
static const char *Dtool_OdeSliderJoint_get_param_stop_CFM_573_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeSliderJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeSliderJoint_get_class_type_574(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeSliderJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeSliderJoint::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeSliderJoint_get_class_type_574_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeSliderJoint_get_class_type_574_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeSliderJoint::OdeSliderJoint(OdeWorld &world)
 * OdeSliderJoint::OdeSliderJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeSliderJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "world")) {
        // 1-OdeSliderJoint::OdeSliderJoint(OdeWorld &world)
        OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeSliderJoint.OdeSliderJoint", false, true);
        if (arg_this != nullptr) {
          OdeSliderJoint *return_value = new OdeSliderJoint(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSliderJoint, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-OdeSliderJoint::OdeSliderJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeSliderJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeSliderJoint.OdeSliderJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeSliderJoint.OdeSliderJoint", false, true);
        if (param0_this != nullptr && param1_this != nullptr) {
          OdeSliderJoint *return_value = new OdeSliderJoint(*param0_this, *param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSliderJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeSliderJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeSliderJoint(OdeWorld world)\n"
      "OdeSliderJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeSliderJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeSliderJoint) {
    printf("OdeSliderJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeSliderJoint *local_this = (OdeSliderJoint *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeSliderJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeSliderJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeSliderJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeSliderJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeSliderJoint*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeSphereGeom
 */
/**
 * Python function wrapper for:
 * inline void OdeSphereGeom::set_radius(dReal radius)
 */
static PyObject *Dtool_OdeSphereGeom_set_radius_577(PyObject *self, PyObject *arg) {
  OdeSphereGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeSphereGeom, (void **)&local_this, "OdeSphereGeom.set_radius")) {
    return nullptr;
  }
  // 1-inline void OdeSphereGeom::set_radius(dReal radius)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_radius)((dReal)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const OdeSphereGeom self, float radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSphereGeom_set_radius_577_comment =
  "C++ Interface:\n"
  "set_radius(const OdeSphereGeom self, float radius)\n";
#else
static const char *Dtool_OdeSphereGeom_set_radius_577_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSphereGeom::get_radius(void) const
 */
static PyObject *Dtool_OdeSphereGeom_get_radius_578(PyObject *self, PyObject *) {
  OdeSphereGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSphereGeom)) {
    return nullptr;
  }
  // 1-inline dReal OdeSphereGeom::get_radius(void) const
  dReal return_value = ((*(const OdeSphereGeom*)local_this).get_radius)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeSphereGeom_get_radius_578_comment =
  "C++ Interface:\n"
  "get_radius(OdeSphereGeom self)\n";
#else
static const char *Dtool_OdeSphereGeom_get_radius_578_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeSphereGeom::get_point_depth(LPoint3f const &p) const
 * inline dReal OdeSphereGeom::get_point_depth(dReal x, dReal y, dReal z) const
 */
static PyObject *Dtool_OdeSphereGeom_get_point_depth_579(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeSphereGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeSphereGeom)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "p")) {
        // 1-inline dReal OdeSphereGeom::get_point_depth(LPoint3f const &p) const
        LPoint3f arg_local;
        LPoint3f const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeSphereGeom.get_point_depth", "LPoint3f");
        }
        dReal return_value = ((*(const OdeSphereGeom*)local_this).get_point_depth)(*arg_this);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-inline dReal OdeSphereGeom::get_point_depth(dReal x, dReal y, dReal z) const
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:get_point_depth", (char **)keyword_list, &param1, &param2, &param3)) {
        dReal return_value = ((*(const OdeSphereGeom*)local_this).get_point_depth)((dReal)param1, (dReal)param2, (dReal)param3);
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_point_depth() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point_depth(OdeSphereGeom self, const LPoint3f p)\n"
      "get_point_depth(OdeSphereGeom self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeSphereGeom_get_point_depth_579_comment =
  "C++ Interface:\n"
  "get_point_depth(OdeSphereGeom self, const LPoint3f p)\n"
  "get_point_depth(OdeSphereGeom self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeSphereGeom_get_point_depth_579_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeSphereGeom::get_class_type(void)
 */
static PyObject *Dtool_OdeSphereGeom_get_class_type_580(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeSphereGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeSphereGeom::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeSphereGeom_get_class_type_580_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeSphereGeom_get_class_type_580_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeSphereGeom::OdeSphereGeom(OdeGeom &geom)
 * OdeSphereGeom::OdeSphereGeom(OdeSpace &space, dReal radius)
 * OdeSphereGeom::OdeSphereGeom(dReal radius)
 */
static int Dtool_Init_OdeSphereGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 OdeSphereGeom::OdeSphereGeom(OdeGeom &geom)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "geom")) {
          OdeGeom *param0_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeGeom, 0, "OdeSphereGeom.OdeSphereGeom", false, false);
          if (param0_this != nullptr) {
            OdeSphereGeom *return_value = new OdeSphereGeom(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSphereGeom, true, false);
          }
        }
      }

      {
        // -2 OdeSphereGeom::OdeSphereGeom(dReal radius)
        float param0;
        static const char *keyword_list[] = {"radius", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f:OdeSphereGeom", (char **)keyword_list, &param0)) {
          OdeSphereGeom *return_value = new OdeSphereGeom((dReal)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSphereGeom, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: OdeSphereGeom::OdeSphereGeom(OdeGeom &geom)
      // No coercion possible: OdeSphereGeom::OdeSphereGeom(dReal radius)
    }
    break;
  case 2:
    {
      // 1-OdeSphereGeom::OdeSphereGeom(OdeSpace &space, dReal radius)
      PyObject *param0;
      float param1;
      static const char *keyword_list[] = {"space", "radius", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:OdeSphereGeom", (char **)keyword_list, &param0, &param1)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeSphereGeom.OdeSphereGeom", false, true);
        if (param0_this != nullptr) {
          OdeSphereGeom *return_value = new OdeSphereGeom(*param0_this, (dReal)param1);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeSphereGeom, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeSphereGeom() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeSphereGeom(OdeGeom geom)\n"
      "OdeSphereGeom(float radius)\n"
      "OdeSphereGeom(OdeSpace space, float radius)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeSphereGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeSphereGeom) {
    printf("OdeSphereGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeSphereGeom *local_this = (OdeSphereGeom *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeSphereGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeGeom) {
    return (OdeGeom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeGeom *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeSphereGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeSphereGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeGeom) {
    OdeGeom* other_this = (OdeGeom*)from_this;
    return (OdeSphereGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeSphereGeom*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeTriMeshData
 */
/**
 * Python function wrapper for:
 * void OdeTriMeshData::destroy(void)
 */
static PyObject *Dtool_OdeTriMeshData_destroy_584(PyObject *self, PyObject *) {
  OdeTriMeshData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeTriMeshData, (void **)&local_this, "OdeTriMeshData.destroy")) {
    return nullptr;
  }
  // 1-void OdeTriMeshData::destroy(void)
  ((*local_this).destroy)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshData_destroy_584_comment =
  "C++ Interface:\n"
  "destroy(const OdeTriMeshData self)\n";
#else
static const char *Dtool_OdeTriMeshData_destroy_584_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void OdeTriMeshData::write(std::ostream &out = ::std::cout, unsigned int indent = 0) const
 */
static PyObject *Dtool_OdeTriMeshData_write_585(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeTriMeshData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeTriMeshData)) {
    return nullptr;
  }
  // 1-virtual void OdeTriMeshData::write(std::ostream &out = ::std::cout, unsigned int indent = 0) const
  PyObject *param1 = nullptr;
  unsigned long param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|Ok:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this;
    if (param1 == nullptr) {
      param1_this = &(std::cout);
    } else {
      param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "OdeTriMeshData.write", false, true);
    }
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*(const OdeTriMeshData*)local_this).write)(*param1_this, (unsigned int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(OdeTriMeshData self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshData_write_585_comment =
  "C++ Interface:\n"
  "write(OdeTriMeshData self, ostream out, int indent)\n";
#else
static const char *Dtool_OdeTriMeshData_write_585_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void OdeTriMeshData::write_faces(std::ostream &out) const
 */
static PyObject *Dtool_OdeTriMeshData_write_faces_586(PyObject *self, PyObject *arg) {
  OdeTriMeshData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeTriMeshData)) {
    return nullptr;
  }
  // 1-void OdeTriMeshData::write_faces(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "OdeTriMeshData.write_faces", false, true);
  if (arg_this != nullptr) {
    ((*(const OdeTriMeshData*)local_this).write_faces)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_faces(OdeTriMeshData self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshData_write_faces_586_comment =
  "C++ Interface:\n"
  "write_faces(OdeTriMeshData self, ostream out)\n";
#else
static const char *Dtool_OdeTriMeshData_write_faces_586_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeTriMeshData::get_class_type(void)
 */
static PyObject *Dtool_OdeTriMeshData_get_class_type_587(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeTriMeshData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeTriMeshData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshData_get_class_type_587_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeTriMeshData_get_class_type_587_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeTriMeshData::OdeTriMeshData(NodePath const &model, bool use_normals = false)
 */
static int Dtool_Init_OdeTriMeshData(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-OdeTriMeshData::OdeTriMeshData(NodePath const &model, bool use_normals = false)
  PyObject *param0;
  PyObject *param1 = Py_False;
  static const char *keyword_list[] = {"model", "use_normals", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:OdeTriMeshData", (char **)keyword_list, &param0, &param1)) {
    NodePath const *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_NodePath, 0, "OdeTriMeshData.OdeTriMeshData", true, true);
    if (param0_this != nullptr) {
      OdeTriMeshData *return_value = new OdeTriMeshData(*param0_this, (PyObject_IsTrue(param1) != 0));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeTriMeshData, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeTriMeshData(const NodePath model, bool use_normals)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_OdeTriMeshData(PyObject *args, CPT(OdeTriMeshData) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_OdeTriMeshData)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeTriMeshData::OdeTriMeshData(NodePath const &model, bool use_normals)
    NodePath const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
    if (arg_this != nullptr) {
      OdeTriMeshData *return_value = new OdeTriMeshData(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeTriMeshData::OdeTriMeshData(NodePath const &model, bool use_normals)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeTriMeshData", 2, 2, &param0, &param1)) {
        NodePath const *param0_this = nullptr;
        DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_NodePath);
        if (param0_this != nullptr) {
          OdeTriMeshData *return_value = new OdeTriMeshData(*param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_OdeTriMeshData(PyObject *args, PT(OdeTriMeshData) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_OdeTriMeshData)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-OdeTriMeshData::OdeTriMeshData(NodePath const &model, bool use_normals)
    NodePath const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NodePath);
    if (arg_this != nullptr) {
      OdeTriMeshData *return_value = new OdeTriMeshData(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-OdeTriMeshData::OdeTriMeshData(NodePath const &model, bool use_normals)
      PyObject *param0;
      PyObject *param1;
      if (PyArg_UnpackTuple(args, "OdeTriMeshData", 2, 2, &param0, &param1)) {
        NodePath const *param0_this = nullptr;
        DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_NodePath);
        if (param0_this != nullptr) {
          OdeTriMeshData *return_value = new OdeTriMeshData(*param0_this, (PyObject_IsTrue(param1) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_OdeTriMeshData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeTriMeshData) {
    printf("OdeTriMeshData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeTriMeshData *local_this = (OdeTriMeshData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeTriMeshData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeTriMeshData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeTriMeshData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (OdeTriMeshData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeTriMeshData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (OdeTriMeshData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeTriMeshGeom
 */
/**
 * Python function wrapper for:
 * void OdeTriMeshGeom::destroy(void)
 */
static PyObject *Dtool_OdeTriMeshGeom_destroy_590(PyObject *self, PyObject *) {
  OdeTriMeshGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeTriMeshGeom, (void **)&local_this, "OdeTriMeshGeom.destroy")) {
    return nullptr;
  }
  // 1-void OdeTriMeshGeom::destroy(void)
  ((*local_this).destroy)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_destroy_590_comment =
  "C++ Interface:\n"
  "destroy(const OdeTriMeshGeom self)\n";
#else
static const char *Dtool_OdeTriMeshGeom_destroy_590_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeTriMeshGeom::set_tri_mesh_data(OdeTriMeshData &data)
 */
static PyObject *Dtool_OdeTriMeshGeom_set_tri_mesh_data_591(PyObject *self, PyObject *arg) {
  OdeTriMeshGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeTriMeshGeom, (void **)&local_this, "OdeTriMeshGeom.set_tri_mesh_data")) {
    return nullptr;
  }
  // 1-inline void OdeTriMeshGeom::set_tri_mesh_data(OdeTriMeshData &data)
  PT(OdeTriMeshData) arg_this;
  if (!Dtool_Coerce_OdeTriMeshData(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeTriMeshGeom.set_tri_mesh_data", "OdeTriMeshData");
  }
  ((*local_this).set_tri_mesh_data)(*std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tri_mesh_data(const OdeTriMeshGeom self, OdeTriMeshData data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_set_tri_mesh_data_591_comment =
  "C++ Interface:\n"
  "set_tri_mesh_data(const OdeTriMeshGeom self, OdeTriMeshData data)\n";
#else
static const char *Dtool_OdeTriMeshGeom_set_tri_mesh_data_591_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< OdeTriMeshData > OdeTriMeshGeom::get_tri_mesh_data(void) const
 */
static PyObject *Dtool_OdeTriMeshGeom_get_tri_mesh_data_592(PyObject *self, PyObject *) {
  OdeTriMeshGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeTriMeshGeom)) {
    return nullptr;
  }
  // 1-inline PointerTo< OdeTriMeshData > OdeTriMeshGeom::get_tri_mesh_data(void) const
  PointerTo< OdeTriMeshData > return_value = ((*(const OdeTriMeshGeom*)local_this).get_tri_mesh_data)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  OdeTriMeshData *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_OdeTriMeshData, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_get_tri_mesh_data_592_comment =
  "C++ Interface:\n"
  "get_tri_mesh_data(OdeTriMeshGeom self)\n";
#else
static const char *Dtool_OdeTriMeshGeom_get_tri_mesh_data_592_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeTriMeshGeom::set_data(OdeTriMeshData &data)
 */
static PyObject *Dtool_OdeTriMeshGeom_set_data_593(PyObject *self, PyObject *arg) {
  OdeTriMeshGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeTriMeshGeom, (void **)&local_this, "OdeTriMeshGeom.set_data")) {
    return nullptr;
  }
  // 1-inline void OdeTriMeshGeom::set_data(OdeTriMeshData &data)
  PT(OdeTriMeshData) arg_this;
  if (!Dtool_Coerce_OdeTriMeshData(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "OdeTriMeshGeom.set_data", "OdeTriMeshData");
  }
  ((*local_this).set_data)(*std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const OdeTriMeshGeom self, OdeTriMeshData data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_set_data_593_comment =
  "C++ Interface:\n"
  "set_data(const OdeTriMeshGeom self, OdeTriMeshData data)\n";
#else
static const char *Dtool_OdeTriMeshGeom_set_data_593_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< OdeTriMeshData > OdeTriMeshGeom::get_data(void) const
 */
static PyObject *Dtool_OdeTriMeshGeom_get_data_594(PyObject *self, PyObject *) {
  OdeTriMeshGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeTriMeshGeom)) {
    return nullptr;
  }
  // 1-inline PointerTo< OdeTriMeshData > OdeTriMeshGeom::get_data(void) const
  PointerTo< OdeTriMeshData > return_value = ((*(const OdeTriMeshGeom*)local_this).get_data)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  OdeTriMeshData *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_OdeTriMeshData, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_get_data_594_comment =
  "C++ Interface:\n"
  "get_data(OdeTriMeshGeom self)\n";
#else
static const char *Dtool_OdeTriMeshGeom_get_data_594_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeTriMeshGeom::enable_TC(int geom_class, int enable)
 */
static PyObject *Dtool_OdeTriMeshGeom_enable_TC_595(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeTriMeshGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeTriMeshGeom, (void **)&local_this, "OdeTriMeshGeom.enable_TC")) {
    return nullptr;
  }
  // 1-inline void OdeTriMeshGeom::enable_TC(int geom_class, int enable)
  int param1;
  int param2;
  static const char *keyword_list[] = {"geom_class", "enable", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:enable_TC", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).enable_TC)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "enable_TC(const OdeTriMeshGeom self, int geom_class, int enable)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_enable_TC_595_comment =
  "C++ Interface:\n"
  "enable_TC(const OdeTriMeshGeom self, int geom_class, int enable)\n";
#else
static const char *Dtool_OdeTriMeshGeom_enable_TC_595_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeTriMeshGeom::is_TC_enabled(int geom_class) const
 */
static PyObject *Dtool_OdeTriMeshGeom_is_TC_enabled_596(PyObject *self, PyObject *arg) {
  OdeTriMeshGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeTriMeshGeom)) {
    return nullptr;
  }
  // 1-inline int OdeTriMeshGeom::is_TC_enabled(int geom_class) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const OdeTriMeshGeom*)local_this).is_TC_enabled)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_TC_enabled(OdeTriMeshGeom self, int geom_class)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_is_TC_enabled_596_comment =
  "C++ Interface:\n"
  "is_TC_enabled(OdeTriMeshGeom self, int geom_class)\n";
#else
static const char *Dtool_OdeTriMeshGeom_is_TC_enabled_596_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeTriMeshGeom::clear_TC_cache(OdeGeom const &geom)
 */
static PyObject *Dtool_OdeTriMeshGeom_clear_TC_cache_597(PyObject *self, PyObject *arg) {
  OdeTriMeshGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeTriMeshGeom, (void **)&local_this, "OdeTriMeshGeom.clear_TC_cache")) {
    return nullptr;
  }
  // 1-inline void OdeTriMeshGeom::clear_TC_cache(OdeGeom const &geom)
  OdeGeom const *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeTriMeshGeom.clear_TC_cache", true, true);
  if (arg_this != nullptr) {
    ((*local_this).clear_TC_cache)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_TC_cache(const OdeTriMeshGeom self, const OdeGeom geom)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_clear_TC_cache_597_comment =
  "C++ Interface:\n"
  "clear_TC_cache(const OdeTriMeshGeom self, const OdeGeom geom)\n";
#else
static const char *Dtool_OdeTriMeshGeom_clear_TC_cache_597_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeTriMeshGeom::get_triangle(int face_index, LPoint3f &v0, LPoint3f &v1, LPoint3f &v2) const
 */
static PyObject *Dtool_OdeTriMeshGeom_get_triangle_598(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeTriMeshGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeTriMeshGeom)) {
    return nullptr;
  }
  // 1-inline void OdeTriMeshGeom::get_triangle(int face_index, LPoint3f &v0, LPoint3f &v1, LPoint3f &v2) const
  int param1;
  PyObject *param2;
  PyObject *param3;
  PyObject *param4;
  static const char *keyword_list[] = {"face_index", "v0", "v1", "v2", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iOOO:get_triangle", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    LPoint3f param2_local;
    LPoint3f *param2_this = Dtool_Coerce_LPoint3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "OdeTriMeshGeom.get_triangle", "LPoint3f");
    }
    LPoint3f param3_local;
    LPoint3f *param3_this = Dtool_Coerce_LPoint3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "OdeTriMeshGeom.get_triangle", "LPoint3f");
    }
    LPoint3f param4_local;
    LPoint3f *param4_this = Dtool_Coerce_LPoint3f(param4, param4_local);
    if (!(param4_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param4, 4, "OdeTriMeshGeom.get_triangle", "LPoint3f");
    }
    ((*(const OdeTriMeshGeom*)local_this).get_triangle)((int)param1, *param2_this, *param3_this, *param4_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_triangle(OdeTriMeshGeom self, int face_index, LPoint3f v0, LPoint3f v1, LPoint3f v2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_get_triangle_598_comment =
  "C++ Interface:\n"
  "get_triangle(OdeTriMeshGeom self, int face_index, LPoint3f v0, LPoint3f v1, LPoint3f v2)\n";
#else
static const char *Dtool_OdeTriMeshGeom_get_triangle_598_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3f OdeTriMeshGeom::get_point(int face_index, dReal u, dReal v) const
 */
static PyObject *Dtool_OdeTriMeshGeom_get_point_599(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeTriMeshGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeTriMeshGeom)) {
    return nullptr;
  }
  // 1-inline LPoint3f OdeTriMeshGeom::get_point(int face_index, dReal u, dReal v) const
  int param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"face_index", "u", "v", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iff:get_point", (char **)keyword_list, &param1, &param2, &param3)) {
    LPoint3f *return_value = new LPoint3f(((*(const OdeTriMeshGeom*)local_this).get_point)((int)param1, (dReal)param2, (dReal)param3));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_point(OdeTriMeshGeom self, int face_index, float u, float v)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_get_point_599_comment =
  "C++ Interface:\n"
  "get_point(OdeTriMeshGeom self, int face_index, float u, float v)\n";
#else
static const char *Dtool_OdeTriMeshGeom_get_point_599_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int OdeTriMeshGeom::get_num_triangles(void) const
 */
static PyObject *Dtool_OdeTriMeshGeom_get_num_triangles_600(PyObject *self, PyObject *) {
  OdeTriMeshGeom *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeTriMeshGeom)) {
    return nullptr;
  }
  // 1-inline int OdeTriMeshGeom::get_num_triangles(void) const
  int return_value = ((*(const OdeTriMeshGeom*)local_this).get_num_triangles)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_get_num_triangles_600_comment =
  "C++ Interface:\n"
  "get_num_triangles(OdeTriMeshGeom self)\n";
#else
static const char *Dtool_OdeTriMeshGeom_get_num_triangles_600_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeTriMeshGeom::get_class_type(void)
 */
static PyObject *Dtool_OdeTriMeshGeom_get_class_type_601(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeTriMeshGeom::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeTriMeshGeom::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeTriMeshGeom_get_class_type_601_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeTriMeshGeom_get_class_type_601_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeTriMeshGeom::OdeTriMeshGeom(OdeSpace &space, OdeTriMeshData &data)
 * OdeTriMeshGeom::OdeTriMeshGeom(OdeTriMeshData &data)
 * OdeTriMeshGeom::OdeTriMeshGeom(OdeTriMeshGeom const &copy)
 */
static int Dtool_Init_OdeTriMeshGeom(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 OdeTriMeshGeom::OdeTriMeshGeom(OdeTriMeshGeom const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          OdeTriMeshGeom const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_OdeTriMeshGeom);
          if (param0_this != nullptr) {
            OdeTriMeshGeom *return_value = new OdeTriMeshGeom(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeTriMeshGeom, true, false);
          }
        }
      }

      // No coercion possible: OdeTriMeshGeom::OdeTriMeshGeom(OdeTriMeshGeom const &copy)
      {
        // -2 OdeTriMeshGeom::OdeTriMeshGeom(OdeTriMeshData &data)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "data")) {
          PT(OdeTriMeshData) param0_this;
          if (Dtool_Coerce_OdeTriMeshData(param0, param0_this)) {
            OdeTriMeshGeom *return_value = new OdeTriMeshGeom(*std::move(param0_this));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeTriMeshGeom, true, false);
          }
        }
      }

    }
    break;
  case 2:
    {
      // 1-OdeTriMeshGeom::OdeTriMeshGeom(OdeSpace &space, OdeTriMeshData &data)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"space", "data", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeTriMeshGeom", (char **)keyword_list, &param0, &param1)) {
        OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeSpace, 0, "OdeTriMeshGeom.OdeTriMeshGeom", false, true);
        PT(OdeTriMeshData) param1_this;
        if (!Dtool_Coerce_OdeTriMeshData(param1, param1_this)) {
          Dtool_Raise_ArgTypeError(param1, 1, "OdeTriMeshGeom.OdeTriMeshGeom", "OdeTriMeshData");
          return -1;
        }
        if (param0_this != nullptr) {
          OdeTriMeshGeom *return_value = new OdeTriMeshGeom(*param0_this, *std::move(param1_this));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeTriMeshGeom, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeTriMeshGeom() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeTriMeshGeom(const OdeTriMeshGeom copy)\n"
      "OdeTriMeshGeom(OdeSpace space, OdeTriMeshData data)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeTriMeshGeom(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeTriMeshGeom) {
    printf("OdeTriMeshGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeTriMeshGeom *local_this = (OdeTriMeshGeom *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeTriMeshGeom) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeGeom) {
    return (OdeGeom *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeGeom *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeTriMeshGeom(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeTriMeshGeom) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeGeom) {
    OdeGeom* other_this = (OdeGeom*)from_this;
    return (OdeTriMeshGeom*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeTriMeshGeom*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeUniversalJoint
 */
/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_anchor(LVecBase3f const &anchor)
 * inline void OdeUniversalJoint::set_anchor(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeUniversalJoint_set_anchor_604(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_anchor")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "anchor")) {
        // 1-inline void OdeUniversalJoint::set_anchor(LVecBase3f const &anchor)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeUniversalJoint.set_anchor", "LVecBase3f");
        }
        ((*local_this).set_anchor)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeUniversalJoint::set_anchor(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_anchor", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_anchor)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_anchor() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anchor(const OdeUniversalJoint self, const LVecBase3f anchor)\n"
      "set_anchor(const OdeUniversalJoint self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_anchor_604_comment =
  "C++ Interface:\n"
  "set_anchor(const OdeUniversalJoint self, const LVecBase3f anchor)\n"
  "set_anchor(const OdeUniversalJoint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_anchor_604_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_axis1(LVecBase3f const &axis)
 * inline void OdeUniversalJoint::set_axis1(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeUniversalJoint_set_axis1_605(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_axis1")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "axis")) {
        // 1-inline void OdeUniversalJoint::set_axis1(LVecBase3f const &axis)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeUniversalJoint.set_axis1", "LVecBase3f");
        }
        ((*local_this).set_axis1)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeUniversalJoint::set_axis1(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_axis1", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_axis1)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis1() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis1(const OdeUniversalJoint self, const LVecBase3f axis)\n"
      "set_axis1(const OdeUniversalJoint self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_axis1_605_comment =
  "C++ Interface:\n"
  "set_axis1(const OdeUniversalJoint self, const LVecBase3f axis)\n"
  "set_axis1(const OdeUniversalJoint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_axis1_605_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_axis2(LVecBase3f const &axis)
 * inline void OdeUniversalJoint::set_axis2(dReal x, dReal y, dReal z)
 */
static PyObject *Dtool_OdeUniversalJoint_set_axis2_606(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_axis2")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "axis")) {
        // 1-inline void OdeUniversalJoint::set_axis2(LVecBase3f const &axis)
        LVecBase3f arg_local;
        LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "OdeUniversalJoint.set_axis2", "LVecBase3f");
        }
        ((*local_this).set_axis2)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void OdeUniversalJoint::set_axis2(dReal x, dReal y, dReal z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_axis2", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_axis2)((dReal)param1, (dReal)param2, (dReal)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_axis2() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_axis2(const OdeUniversalJoint self, const LVecBase3f axis)\n"
      "set_axis2(const OdeUniversalJoint self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_axis2_606_comment =
  "C++ Interface:\n"
  "set_axis2(const OdeUniversalJoint self, const LVecBase3f axis)\n"
  "set_axis2(const OdeUniversalJoint self, float x, float y, float z)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_axis2_606_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::add_torques(dReal torque1, dReal torque2)
 */
static PyObject *Dtool_OdeUniversalJoint_add_torques_607(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.add_torques")) {
    return nullptr;
  }
  // 1-inline void OdeUniversalJoint::add_torques(dReal torque1, dReal torque2)
  float param1;
  float param2;
  static const char *keyword_list[] = {"torque1", "torque2", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:add_torques", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).add_torques)((dReal)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_torques(const OdeUniversalJoint self, float torque1, float torque2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_add_torques_607_comment =
  "C++ Interface:\n"
  "add_torques(const OdeUniversalJoint self, float torque1, float torque2)\n";
#else
static const char *Dtool_OdeUniversalJoint_add_torques_607_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeUniversalJoint::get_anchor(void) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_anchor_608(PyObject *self, PyObject *) {
  OdeUniversalJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeUniversalJoint)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeUniversalJoint::get_anchor(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeUniversalJoint*)local_this).get_anchor)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_anchor_608_comment =
  "C++ Interface:\n"
  "get_anchor(OdeUniversalJoint self)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_anchor_608_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeUniversalJoint::get_anchor2(void) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_anchor2_609(PyObject *self, PyObject *) {
  OdeUniversalJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeUniversalJoint)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeUniversalJoint::get_anchor2(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeUniversalJoint*)local_this).get_anchor2)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_anchor2_609_comment =
  "C++ Interface:\n"
  "get_anchor2(OdeUniversalJoint self)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_anchor2_609_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeUniversalJoint::get_axis1(void) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_axis1_610(PyObject *self, PyObject *) {
  OdeUniversalJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeUniversalJoint)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeUniversalJoint::get_axis1(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeUniversalJoint*)local_this).get_axis1)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_axis1_610_comment =
  "C++ Interface:\n"
  "get_axis1(OdeUniversalJoint self)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_axis1_610_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f OdeUniversalJoint::get_axis2(void) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_axis2_611(PyObject *self, PyObject *) {
  OdeUniversalJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeUniversalJoint)) {
    return nullptr;
  }
  // 1-inline LVecBase3f OdeUniversalJoint::get_axis2(void) const
  LVecBase3f *return_value = new LVecBase3f(((*(const OdeUniversalJoint*)local_this).get_axis2)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_axis2_611_comment =
  "C++ Interface:\n"
  "get_axis2(OdeUniversalJoint self)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_axis2_611_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_angle1(void) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_angle1_612(PyObject *self, PyObject *) {
  OdeUniversalJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeUniversalJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeUniversalJoint::get_angle1(void) const
  dReal return_value = ((*(const OdeUniversalJoint*)local_this).get_angle1)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_angle1_612_comment =
  "C++ Interface:\n"
  "get_angle1(OdeUniversalJoint self)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_angle1_612_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_angle2(void) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_angle2_613(PyObject *self, PyObject *) {
  OdeUniversalJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeUniversalJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeUniversalJoint::get_angle2(void) const
  dReal return_value = ((*(const OdeUniversalJoint*)local_this).get_angle2)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_angle2_613_comment =
  "C++ Interface:\n"
  "get_angle2(OdeUniversalJoint self)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_angle2_613_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_angle1_rate(void) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_angle1_rate_614(PyObject *self, PyObject *) {
  OdeUniversalJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeUniversalJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeUniversalJoint::get_angle1_rate(void) const
  dReal return_value = ((*(const OdeUniversalJoint*)local_this).get_angle1_rate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_angle1_rate_614_comment =
  "C++ Interface:\n"
  "get_angle1_rate(OdeUniversalJoint self)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_angle1_rate_614_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_angle2_rate(void) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_angle2_rate_615(PyObject *self, PyObject *) {
  OdeUniversalJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeUniversalJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeUniversalJoint::get_angle2_rate(void) const
  dReal return_value = ((*(const OdeUniversalJoint*)local_this).get_angle2_rate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_angle2_rate_615_comment =
  "C++ Interface:\n"
  "get_angle2_rate(OdeUniversalJoint self)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_angle2_rate_615_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_lo_stop(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_lo_stop_616(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_lo_stop")) {
    return nullptr;
  }
  // 1-inline void OdeUniversalJoint::set_param_lo_stop(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_lo_stop", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_lo_stop)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_lo_stop(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_lo_stop_616_comment =
  "C++ Interface:\n"
  "set_param_lo_stop(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_lo_stop_616_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_hi_stop(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_hi_stop_617(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_hi_stop")) {
    return nullptr;
  }
  // 1-inline void OdeUniversalJoint::set_param_hi_stop(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_hi_stop", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_hi_stop)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_hi_stop(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_hi_stop_617_comment =
  "C++ Interface:\n"
  "set_param_hi_stop(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_hi_stop_617_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_vel(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_vel_618(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_vel")) {
    return nullptr;
  }
  // 1-inline void OdeUniversalJoint::set_param_vel(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_vel", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_vel)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_vel(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_vel_618_comment =
  "C++ Interface:\n"
  "set_param_vel(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_vel_618_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_f_max(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_f_max_619(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_f_max")) {
    return nullptr;
  }
  // 1-inline void OdeUniversalJoint::set_param_f_max(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_f_max", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_f_max)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_f_max(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_f_max_619_comment =
  "C++ Interface:\n"
  "set_param_f_max(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_f_max_619_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_fudge_factor(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_fudge_factor_620(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_fudge_factor")) {
    return nullptr;
  }
  // 1-inline void OdeUniversalJoint::set_param_fudge_factor(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_fudge_factor", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_fudge_factor)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_fudge_factor(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_fudge_factor_620_comment =
  "C++ Interface:\n"
  "set_param_fudge_factor(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_fudge_factor_620_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_bounce(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_bounce_621(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_bounce")) {
    return nullptr;
  }
  // 1-inline void OdeUniversalJoint::set_param_bounce(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_bounce", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_bounce)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_bounce(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_bounce_621_comment =
  "C++ Interface:\n"
  "set_param_bounce(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_bounce_621_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_CFM(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_CFM_622(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_CFM")) {
    return nullptr;
  }
  // 1-inline void OdeUniversalJoint::set_param_CFM(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_CFM", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_CFM)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_CFM(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_CFM_622_comment =
  "C++ Interface:\n"
  "set_param_CFM(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_CFM_622_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_stop_ERP(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_stop_ERP_623(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_stop_ERP")) {
    return nullptr;
  }
  // 1-inline void OdeUniversalJoint::set_param_stop_ERP(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_stop_ERP", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_stop_ERP)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_ERP(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_stop_ERP_623_comment =
  "C++ Interface:\n"
  "set_param_stop_ERP(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_stop_ERP_623_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void OdeUniversalJoint::set_param_stop_CFM(int axis, dReal val)
 */
static PyObject *Dtool_OdeUniversalJoint_set_param_stop_CFM_624(PyObject *self, PyObject *args, PyObject *kwds) {
  OdeUniversalJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_OdeUniversalJoint, (void **)&local_this, "OdeUniversalJoint.set_param_stop_CFM")) {
    return nullptr;
  }
  // 1-inline void OdeUniversalJoint::set_param_stop_CFM(int axis, dReal val)
  int param1;
  float param2;
  static const char *keyword_list[] = {"axis", "val", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "if:set_param_stop_CFM", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_param_stop_CFM)((int)param1, (dReal)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_param_stop_CFM(const OdeUniversalJoint self, int axis, float val)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_set_param_stop_CFM_624_comment =
  "C++ Interface:\n"
  "set_param_stop_CFM(const OdeUniversalJoint self, int axis, float val)\n";
#else
static const char *Dtool_OdeUniversalJoint_set_param_stop_CFM_624_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_lo_stop(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_lo_stop_625(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeUniversalJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_lo_stop(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeUniversalJoint*)local_this).get_param_lo_stop)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_lo_stop(OdeUniversalJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_lo_stop_625_comment =
  "C++ Interface:\n"
  "get_param_lo_stop(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_lo_stop_625_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_hi_stop(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_hi_stop_626(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeUniversalJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_hi_stop(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeUniversalJoint*)local_this).get_param_hi_stop)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_hi_stop(OdeUniversalJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_hi_stop_626_comment =
  "C++ Interface:\n"
  "get_param_hi_stop(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_hi_stop_626_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_vel(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_vel_627(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeUniversalJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_vel(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeUniversalJoint*)local_this).get_param_vel)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_vel(OdeUniversalJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_vel_627_comment =
  "C++ Interface:\n"
  "get_param_vel(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_vel_627_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_f_max(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_f_max_628(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeUniversalJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_f_max(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeUniversalJoint*)local_this).get_param_f_max)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_f_max(OdeUniversalJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_f_max_628_comment =
  "C++ Interface:\n"
  "get_param_f_max(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_f_max_628_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_fudge_factor(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_fudge_factor_629(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeUniversalJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_fudge_factor(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeUniversalJoint*)local_this).get_param_fudge_factor)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_fudge_factor(OdeUniversalJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_fudge_factor_629_comment =
  "C++ Interface:\n"
  "get_param_fudge_factor(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_fudge_factor_629_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_bounce(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_bounce_630(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeUniversalJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_bounce(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeUniversalJoint*)local_this).get_param_bounce)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_bounce(OdeUniversalJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_bounce_630_comment =
  "C++ Interface:\n"
  "get_param_bounce(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_bounce_630_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_CFM(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_CFM_631(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeUniversalJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_CFM(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeUniversalJoint*)local_this).get_param_CFM)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_CFM(OdeUniversalJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_CFM_631_comment =
  "C++ Interface:\n"
  "get_param_CFM(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_CFM_631_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_stop_ERP(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_stop_ERP_632(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeUniversalJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_stop_ERP(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeUniversalJoint*)local_this).get_param_stop_ERP)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_stop_ERP(OdeUniversalJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_stop_ERP_632_comment =
  "C++ Interface:\n"
  "get_param_stop_ERP(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_stop_ERP_632_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline dReal OdeUniversalJoint::get_param_stop_CFM(int axis) const
 */
static PyObject *Dtool_OdeUniversalJoint_get_param_stop_CFM_633(PyObject *self, PyObject *arg) {
  OdeUniversalJoint *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_OdeUniversalJoint)) {
    return nullptr;
  }
  // 1-inline dReal OdeUniversalJoint::get_param_stop_CFM(int axis) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    dReal return_value = ((*(const OdeUniversalJoint*)local_this).get_param_stop_CFM)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_param_stop_CFM(OdeUniversalJoint self, int axis)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_param_stop_CFM_633_comment =
  "C++ Interface:\n"
  "get_param_stop_CFM(OdeUniversalJoint self, int axis)\n";
#else
static const char *Dtool_OdeUniversalJoint_get_param_stop_CFM_633_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle OdeUniversalJoint::get_class_type(void)
 */
static PyObject *Dtool_OdeUniversalJoint_get_class_type_634(PyObject *, PyObject *) {
  // 1-static TypeHandle OdeUniversalJoint::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((OdeUniversalJoint::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_OdeUniversalJoint_get_class_type_634_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_OdeUniversalJoint_get_class_type_634_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * OdeUniversalJoint::OdeUniversalJoint(OdeWorld &world)
 * OdeUniversalJoint::OdeUniversalJoint(OdeWorld &world, OdeJointGroup &joint_group)
 */
static int Dtool_Init_OdeUniversalJoint(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "world")) {
        // 1-OdeUniversalJoint::OdeUniversalJoint(OdeWorld &world)
        OdeWorld *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 0, "OdeUniversalJoint.OdeUniversalJoint", false, true);
        if (arg_this != nullptr) {
          OdeUniversalJoint *return_value = new OdeUniversalJoint(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeUniversalJoint, true, false);
        }
      }
    }
    break;
  case 2:
    {
      // 1-OdeUniversalJoint::OdeUniversalJoint(OdeWorld &world, OdeJointGroup &joint_group)
      PyObject *param0;
      PyObject *param1;
      static const char *keyword_list[] = {"world", "joint_group", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:OdeUniversalJoint", (char **)keyword_list, &param0, &param1)) {
        OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeWorld, 0, "OdeUniversalJoint.OdeUniversalJoint", false, true);
        OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeJointGroup, 1, "OdeUniversalJoint.OdeUniversalJoint", false, true);
        if (param0_this != nullptr && param1_this != nullptr) {
          OdeUniversalJoint *return_value = new OdeUniversalJoint(*param0_this, *param1_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeUniversalJoint, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeUniversalJoint() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeUniversalJoint(OdeWorld world)\n"
      "OdeUniversalJoint(OdeWorld world, OdeJointGroup joint_group)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeUniversalJoint(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeUniversalJoint) {
    printf("OdeUniversalJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeUniversalJoint *local_this = (OdeUniversalJoint *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeUniversalJoint) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_OdeJoint) {
    return (OdeJoint *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(OdeJoint *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeUniversalJoint(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeUniversalJoint) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_OdeJoint) {
    OdeJoint* other_this = (OdeJoint*)from_this;
    return (OdeUniversalJoint*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (OdeUniversalJoint*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class OdeUtil
 */
/**
 * Python function wrapper for:
 * static OdeJoint OdeUtil::get_connecting_joint(OdeBody const &body1, OdeBody const &body2)
 */
static PyObject *Dtool_OdeUtil_get_connecting_joint_636(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static OdeJoint OdeUtil::get_connecting_joint(OdeBody const &body1, OdeBody const &body2)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"body1", "body2", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_connecting_joint", (char **)keyword_list, &param0, &param1)) {
    OdeBody const *param0_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeBody, 0, "OdeUtil.get_connecting_joint", true, true);
    OdeBody const *param1_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeBody, 1, "OdeUtil.get_connecting_joint", true, true);
    if (param0_this != nullptr && param1_this != nullptr) {
      OdeJoint *return_value = new OdeJoint((OdeUtil::get_connecting_joint)(*param0_this, *param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeJoint, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_connecting_joint(const OdeBody body1, const OdeBody body2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_get_connecting_joint_636_comment =
  "C++ Interface:\n"
  "get_connecting_joint(const OdeBody body1, const OdeBody body2)\n"
  "\n"
  "/**\n"
  " * Returns the joint that connects the given bodies.\n"
  " */";
#else
static const char *Dtool_OdeUtil_get_connecting_joint_636_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static OdeJointCollection OdeUtil::get_connecting_joint_list(OdeBody const &body1, OdeBody const &body2)
 */
static PyObject *Dtool_OdeUtil_get_connecting_joint_list_637(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static OdeJointCollection OdeUtil::get_connecting_joint_list(OdeBody const &body1, OdeBody const &body2)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"body1", "body2", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:get_connecting_joint_list", (char **)keyword_list, &param0, &param1)) {
    OdeBody const *param0_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeBody, 0, "OdeUtil.get_connecting_joint_list", true, true);
    OdeBody const *param1_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeBody, 1, "OdeUtil.get_connecting_joint_list", true, true);
    if (param0_this != nullptr && param1_this != nullptr) {
      OdeJointCollection *return_value = new OdeJointCollection((OdeUtil::get_connecting_joint_list)(*param0_this, *param1_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OdeJointCollection, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_connecting_joint_list(const OdeBody body1, const OdeBody body2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_get_connecting_joint_list_637_comment =
  "C++ Interface:\n"
  "get_connecting_joint_list(const OdeBody body1, const OdeBody body2)\n"
  "\n"
  "/**\n"
  " * Returns a collection of joints connecting the specified bodies.\n"
  " */";
#else
static const char *Dtool_OdeUtil_get_connecting_joint_list_637_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int OdeUtil::are_connected(OdeBody const &body1, OdeBody const &body2)
 */
static PyObject *Dtool_OdeUtil_are_connected_638(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static int OdeUtil::are_connected(OdeBody const &body1, OdeBody const &body2)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"body1", "body2", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:are_connected", (char **)keyword_list, &param0, &param1)) {
    OdeBody const *param0_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeBody, 0, "OdeUtil.are_connected", true, true);
    OdeBody const *param1_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeBody, 1, "OdeUtil.are_connected", true, true);
    if (param0_this != nullptr && param1_this != nullptr) {
      int return_value = (OdeUtil::are_connected)(*param0_this, *param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "are_connected(const OdeBody body1, const OdeBody body2)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_are_connected_638_comment =
  "C++ Interface:\n"
  "are_connected(const OdeBody body1, const OdeBody body2)\n"
  "\n"
  "/**\n"
  " * Returns 1 if the given bodies are connected by a joint, returns 0\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_OdeUtil_are_connected_638_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int OdeUtil::are_connected_excluding(OdeBody const &body1, OdeBody const &body2, int const joint_type)
 */
static PyObject *Dtool_OdeUtil_are_connected_excluding_639(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static int OdeUtil::are_connected_excluding(OdeBody const &body1, OdeBody const &body2, int const joint_type)
  PyObject *param0;
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"body1", "body2", "joint_type", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOi:are_connected_excluding", (char **)keyword_list, &param0, &param1, &param2)) {
    OdeBody const *param0_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeBody, 0, "OdeUtil.are_connected_excluding", true, true);
    OdeBody const *param1_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeBody, 1, "OdeUtil.are_connected_excluding", true, true);
    if (param0_this != nullptr && param1_this != nullptr) {
      int return_value = (OdeUtil::are_connected_excluding)(*param0_this, *param1_this, (int const)param2);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "are_connected_excluding(const OdeBody body1, const OdeBody body2, int joint_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_are_connected_excluding_639_comment =
  "C++ Interface:\n"
  "are_connected_excluding(const OdeBody body1, const OdeBody body2, int joint_type)\n"
  "\n"
  "/**\n"
  " * Returns 1 if the given bodies are connected by a joint that does not match\n"
  " * the given joint_type, returns 0 otherwise.  This is useful for deciding\n"
  " * whether to add contact joints between two bodies: if they are already\n"
  " * connected by non-contact joints then it may not be appropriate to add\n"
  " * contacts, however it is okay to add more contact between bodies that\n"
  " * already have contacts.\n"
  " */";
#else
static const char *Dtool_OdeUtil_are_connected_excluding_639_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< OdeCollisionEntry > OdeUtil::collide(OdeGeom const &geom1, OdeGeom const &geom2, short int const max_contacts = 150)
 */
static PyObject *Dtool_OdeUtil_collide_640(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< OdeCollisionEntry > OdeUtil::collide(OdeGeom const &geom1, OdeGeom const &geom2, short int const max_contacts = 150)
  PyObject *param0;
  PyObject *param1;
  short param2 = 150;
  static const char *keyword_list[] = {"geom1", "geom2", "max_contacts", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|h:collide", (char **)keyword_list, &param0, &param1, &param2)) {
    OdeGeom const *param0_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeGeom, 0, "OdeUtil.collide", true, true);
    OdeGeom const *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeGeom, 1, "OdeUtil.collide", true, true);
    if (param0_this != nullptr && param1_this != nullptr) {
      PointerTo< OdeCollisionEntry > return_value = (OdeUtil::collide)(*param0_this, *param1_this, (short int const)param2);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      OdeCollisionEntry *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_OdeCollisionEntry, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "collide(const OdeGeom geom1, const OdeGeom geom2, int max_contacts)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_collide_640_comment =
  "C++ Interface:\n"
  "collide(const OdeGeom geom1, const OdeGeom geom2, int max_contacts)\n"
  "\n"
  "/**\n"
  " * Given two geometry objects that potentially touch (geom1 and geom2),\n"
  " * generate contact information for them.  Returns an OdeCollisionEntry.\n"
  " */";
#else
static const char *Dtool_OdeUtil_collide_640_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int OdeUtil::collide2(OdeGeom const &geom1, OdeGeom const &geom2, PyObject *arg, PyObject *callback)
 */
static PyObject *Dtool_OdeUtil_collide2_641(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static int OdeUtil::collide2(OdeGeom const &geom1, OdeGeom const &geom2, PyObject *arg, PyObject *callback)
  PyObject *param0;
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"geom1", "geom2", "arg", "callback", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:collide2", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
    OdeGeom const *param0_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_OdeGeom, 0, "OdeUtil.collide2", true, true);
    OdeGeom const *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_OdeGeom, 1, "OdeUtil.collide2", true, true);
    if (param0_this != nullptr && param1_this != nullptr) {
      int return_value = Extension<OdeUtil>::collide2(*param0_this, *param1_this, param2, param3);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "collide2(const OdeGeom geom1, const OdeGeom geom2, object arg, object callback)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_collide2_641_comment =
  "C++ Interface:\n"
  "collide2(const OdeGeom geom1, const OdeGeom geom2, object arg, object callback)\n";
#else
static const char *Dtool_OdeUtil_collide2_641_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static OdeGeom OdeUtil::space_to_geom(OdeSpace const &space)
 */
static PyObject *Dtool_OdeUtil_space_to_geom_642(PyObject *, PyObject *arg) {
  // 1-static OdeGeom OdeUtil::space_to_geom(OdeSpace const &space)
  OdeSpace const *arg_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeSpace, 0, "OdeUtil.space_to_geom", true, true);
  if (arg_this != nullptr) {
    OdeGeom *return_value = new OdeGeom((OdeUtil::space_to_geom)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeGeom, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "space_to_geom(const OdeSpace space)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_space_to_geom_642_comment =
  "C++ Interface:\n"
  "space_to_geom(const OdeSpace space)\n";
#else
static const char *Dtool_OdeUtil_space_to_geom_642_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static dReal OdeUtil::get_infinity(void)
 */
static PyObject *Dtool_OdeUtil_get_infinity_643(PyObject *, PyObject *) {
  // 1-static dReal OdeUtil::get_infinity(void)
  dReal return_value = (OdeUtil::get_infinity)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_get_infinity_643_comment =
  "C++ Interface:\n"
  "get_infinity()\n"
  "\n"
  "// RAU we can't access OC_infinity as constants are not exposed in python";
#else
static const char *Dtool_OdeUtil_get_infinity_643_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static int OdeUtil::rand_get_seed(void)
 */
static PyObject *Dtool_OdeUtil_rand_get_seed_644(PyObject *, PyObject *) {
  // 1-static int OdeUtil::rand_get_seed(void)
  int return_value = (OdeUtil::rand_get_seed)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_rand_get_seed_644_comment =
  "C++ Interface:\n"
  "rand_get_seed()\n";
#else
static const char *Dtool_OdeUtil_rand_get_seed_644_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void OdeUtil::rand_set_seed(int s)
 */
static PyObject *Dtool_OdeUtil_rand_set_seed_645(PyObject *, PyObject *arg) {
  // 1-static void OdeUtil::rand_set_seed(int s)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    (OdeUtil::rand_set_seed)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "rand_set_seed(int s)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_OdeUtil_rand_set_seed_645_comment =
  "C++ Interface:\n"
  "rand_set_seed(int s)\n";
#else
static const char *Dtool_OdeUtil_rand_set_seed_645_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline OdeUtil::OdeUtil(void) = default
 * inline OdeUtil::OdeUtil(OdeUtil const &) = default
 */
static int Dtool_Init_OdeUtil(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("OdeUtil() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline OdeUtil::OdeUtil(void) = default
      OdeUtil *return_value = new OdeUtil();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeUtil, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline OdeUtil::OdeUtil(OdeUtil const &) = default
      OdeUtil const *arg_this = (OdeUtil *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeUtil, 0, "OdeUtil.OdeUtil", true, true);
      if (arg_this != nullptr) {
        OdeUtil *return_value = new OdeUtil(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_OdeUtil, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "OdeUtil() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "OdeUtil()\n"
      "OdeUtil(const OdeUtil param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_OdeUtil(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_OdeUtil) {
    printf("OdeUtil ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  OdeUtil *local_this = (OdeUtil *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_OdeUtil) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_OdeUtil(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_OdeUtil) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python method tables for dxBody (dxBody)
 */
static PyMethodDef Dtool_Methods_dxBody[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_dxBody = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_dxBody = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.dxBody",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_dxBody,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_dxBody,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_dxBody,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_dxBody,
    PyType_GenericAlloc,
    Dtool_new_dxBody,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_dxBody,
  Dtool_UpcastInterface_dxBody,
  Dtool_DowncastInterface_dxBody,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_dxBody(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_dxBody._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_dxBody._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_dxBody) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(dxBody)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_dxBody);
  }
}

/**
 * Python method tables for dxGeom (dxGeom)
 */
static PyMethodDef Dtool_Methods_dxGeom[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_dxGeom = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_dxGeom = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.dxGeom",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_dxGeom,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_dxGeom,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_dxGeom,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_dxGeom,
    PyType_GenericAlloc,
    Dtool_new_dxGeom,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_dxGeom,
  Dtool_UpcastInterface_dxGeom,
  Dtool_DowncastInterface_dxGeom,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_dxGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_dxGeom._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_dxGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_dxGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(dxGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_dxGeom);
  }
}

/**
 * Python method tables for dxJoint (dxJoint)
 */
static PyMethodDef Dtool_Methods_dxJoint[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_dxJoint = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_dxJoint = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.dxJoint",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_dxJoint,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_dxJoint,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_dxJoint,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_dxJoint,
    PyType_GenericAlloc,
    Dtool_new_dxJoint,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_dxJoint,
  Dtool_UpcastInterface_dxJoint,
  Dtool_DowncastInterface_dxJoint,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_dxJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_dxJoint._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_dxJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_dxJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(dxJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_dxJoint);
  }
}

/**
 * Python method tables for dxJointGroup (dxJointGroup)
 */
static PyMethodDef Dtool_Methods_dxJointGroup[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_dxJointGroup = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_dxJointGroup = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.dxJointGroup",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_dxJointGroup,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_dxJointGroup,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_dxJointGroup,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_dxJointGroup,
    PyType_GenericAlloc,
    Dtool_new_dxJointGroup,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_dxJointGroup,
  Dtool_UpcastInterface_dxJointGroup,
  Dtool_DowncastInterface_dxJointGroup,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_dxJointGroup(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_dxJointGroup._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_dxJointGroup._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_dxJointGroup) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(dxJointGroup)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_dxJointGroup);
  }
}

/**
 * Python method tables for dxSpace (dxSpace)
 */
static PyMethodDef Dtool_Methods_dxSpace[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_dxSpace = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_dxSpace = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.dxSpace",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_dxSpace,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_dxSpace,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_dxSpace,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_dxSpace,
    PyType_GenericAlloc,
    Dtool_new_dxSpace,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_dxSpace,
  Dtool_UpcastInterface_dxSpace,
  Dtool_DowncastInterface_dxSpace,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_dxSpace(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_dxSpace._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_dxSpace._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_dxSpace) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(dxSpace)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_dxSpace);
  }
}

/**
 * Python method tables for dxTriMeshData (dxTriMeshData)
 */
static PyMethodDef Dtool_Methods_dxTriMeshData[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_dxTriMeshData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_dxTriMeshData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.dxTriMeshData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_dxTriMeshData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_dxTriMeshData,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_dxTriMeshData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_dxTriMeshData,
    PyType_GenericAlloc,
    Dtool_new_dxTriMeshData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_dxTriMeshData,
  Dtool_UpcastInterface_dxTriMeshData,
  Dtool_DowncastInterface_dxTriMeshData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_dxTriMeshData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_dxTriMeshData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_dxTriMeshData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_dxTriMeshData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(dxTriMeshData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_dxTriMeshData);
  }
}

/**
 * Python method tables for dxWorld (dxWorld)
 */
static PyMethodDef Dtool_Methods_dxWorld[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_dxWorld = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_dxWorld = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.dxWorld",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_dxWorld,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_dxWorld,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_dxWorld,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_dxWorld,
    PyType_GenericAlloc,
    Dtool_new_dxWorld,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_dxWorld,
  Dtool_UpcastInterface_dxWorld,
  Dtool_DowncastInterface_dxWorld,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_dxWorld(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_dxWorld._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_dxWorld._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_dxWorld) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(dxWorld)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_dxWorld);
  }
}

/**
 * Python method tables for OdeWorld (OdeWorld)
 */
static PyMethodDef Dtool_Methods_OdeWorld[] = {
  {"destroy", &Dtool_OdeWorld_destroy_11, METH_NOARGS, (const char *)Dtool_OdeWorld_destroy_11_comment},
  {"is_empty", &Dtool_OdeWorld_is_empty_12, METH_NOARGS, (const char *)Dtool_OdeWorld_is_empty_12_comment},
  {"isEmpty", &Dtool_OdeWorld_is_empty_12, METH_NOARGS, (const char *)Dtool_OdeWorld_is_empty_12_comment},
  {"get_id", &Dtool_OdeWorld_get_id_13, METH_NOARGS, (const char *)Dtool_OdeWorld_get_id_13_comment},
  {"getId", &Dtool_OdeWorld_get_id_13, METH_NOARGS, (const char *)Dtool_OdeWorld_get_id_13_comment},
  {"set_gravity", (PyCFunction) &Dtool_OdeWorld_set_gravity_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_set_gravity_14_comment},
  {"setGravity", (PyCFunction) &Dtool_OdeWorld_set_gravity_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_set_gravity_14_comment},
  {"set_erp", &Dtool_OdeWorld_set_erp_15, METH_O, (const char *)Dtool_OdeWorld_set_erp_15_comment},
  {"setErp", &Dtool_OdeWorld_set_erp_15, METH_O, (const char *)Dtool_OdeWorld_set_erp_15_comment},
  {"set_cfm", &Dtool_OdeWorld_set_cfm_16, METH_O, (const char *)Dtool_OdeWorld_set_cfm_16_comment},
  {"setCfm", &Dtool_OdeWorld_set_cfm_16, METH_O, (const char *)Dtool_OdeWorld_set_cfm_16_comment},
  {"set_quick_step_num_iterations", &Dtool_OdeWorld_set_quick_step_num_iterations_17, METH_O, (const char *)Dtool_OdeWorld_set_quick_step_num_iterations_17_comment},
  {"setQuickStepNumIterations", &Dtool_OdeWorld_set_quick_step_num_iterations_17, METH_O, (const char *)Dtool_OdeWorld_set_quick_step_num_iterations_17_comment},
  {"set_quick_step_w", &Dtool_OdeWorld_set_quick_step_w_18, METH_O, (const char *)Dtool_OdeWorld_set_quick_step_w_18_comment},
  {"setQuickStepW", &Dtool_OdeWorld_set_quick_step_w_18, METH_O, (const char *)Dtool_OdeWorld_set_quick_step_w_18_comment},
  {"set_contact_max_correcting_vel", &Dtool_OdeWorld_set_contact_max_correcting_vel_19, METH_O, (const char *)Dtool_OdeWorld_set_contact_max_correcting_vel_19_comment},
  {"setContactMaxCorrectingVel", &Dtool_OdeWorld_set_contact_max_correcting_vel_19, METH_O, (const char *)Dtool_OdeWorld_set_contact_max_correcting_vel_19_comment},
  {"set_contact_surface_layer", &Dtool_OdeWorld_set_contact_surface_layer_20, METH_O, (const char *)Dtool_OdeWorld_set_contact_surface_layer_20_comment},
  {"setContactSurfaceLayer", &Dtool_OdeWorld_set_contact_surface_layer_20, METH_O, (const char *)Dtool_OdeWorld_set_contact_surface_layer_20_comment},
  {"set_auto_disable_linear_threshold", &Dtool_OdeWorld_set_auto_disable_linear_threshold_21, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_linear_threshold_21_comment},
  {"setAutoDisableLinearThreshold", &Dtool_OdeWorld_set_auto_disable_linear_threshold_21, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_linear_threshold_21_comment},
  {"set_auto_disable_angular_threshold", &Dtool_OdeWorld_set_auto_disable_angular_threshold_22, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_angular_threshold_22_comment},
  {"setAutoDisableAngularThreshold", &Dtool_OdeWorld_set_auto_disable_angular_threshold_22, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_angular_threshold_22_comment},
  {"set_auto_disable_steps", &Dtool_OdeWorld_set_auto_disable_steps_23, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_steps_23_comment},
  {"setAutoDisableSteps", &Dtool_OdeWorld_set_auto_disable_steps_23, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_steps_23_comment},
  {"set_auto_disable_time", &Dtool_OdeWorld_set_auto_disable_time_24, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_time_24_comment},
  {"setAutoDisableTime", &Dtool_OdeWorld_set_auto_disable_time_24, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_time_24_comment},
  {"set_auto_disable_flag", &Dtool_OdeWorld_set_auto_disable_flag_25, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_flag_25_comment},
  {"setAutoDisableFlag", &Dtool_OdeWorld_set_auto_disable_flag_25, METH_O, (const char *)Dtool_OdeWorld_set_auto_disable_flag_25_comment},
  {"get_gravity", &Dtool_OdeWorld_get_gravity_26, METH_NOARGS, (const char *)Dtool_OdeWorld_get_gravity_26_comment},
  {"getGravity", &Dtool_OdeWorld_get_gravity_26, METH_NOARGS, (const char *)Dtool_OdeWorld_get_gravity_26_comment},
  {"get_erp", &Dtool_OdeWorld_get_erp_27, METH_NOARGS, (const char *)Dtool_OdeWorld_get_erp_27_comment},
  {"getErp", &Dtool_OdeWorld_get_erp_27, METH_NOARGS, (const char *)Dtool_OdeWorld_get_erp_27_comment},
  {"get_cfm", &Dtool_OdeWorld_get_cfm_28, METH_NOARGS, (const char *)Dtool_OdeWorld_get_cfm_28_comment},
  {"getCfm", &Dtool_OdeWorld_get_cfm_28, METH_NOARGS, (const char *)Dtool_OdeWorld_get_cfm_28_comment},
  {"get_quick_step_num_iterations", &Dtool_OdeWorld_get_quick_step_num_iterations_29, METH_NOARGS, (const char *)Dtool_OdeWorld_get_quick_step_num_iterations_29_comment},
  {"getQuickStepNumIterations", &Dtool_OdeWorld_get_quick_step_num_iterations_29, METH_NOARGS, (const char *)Dtool_OdeWorld_get_quick_step_num_iterations_29_comment},
  {"get_quick_step_w", &Dtool_OdeWorld_get_quick_step_w_30, METH_NOARGS, (const char *)Dtool_OdeWorld_get_quick_step_w_30_comment},
  {"getQuickStepW", &Dtool_OdeWorld_get_quick_step_w_30, METH_NOARGS, (const char *)Dtool_OdeWorld_get_quick_step_w_30_comment},
  {"get_contact_max_correcting_vel", &Dtool_OdeWorld_get_contact_max_correcting_vel_31, METH_NOARGS, (const char *)Dtool_OdeWorld_get_contact_max_correcting_vel_31_comment},
  {"getContactMaxCorrectingVel", &Dtool_OdeWorld_get_contact_max_correcting_vel_31, METH_NOARGS, (const char *)Dtool_OdeWorld_get_contact_max_correcting_vel_31_comment},
  {"get_contact_surface_layer", &Dtool_OdeWorld_get_contact_surface_layer_32, METH_NOARGS, (const char *)Dtool_OdeWorld_get_contact_surface_layer_32_comment},
  {"getContactSurfaceLayer", &Dtool_OdeWorld_get_contact_surface_layer_32, METH_NOARGS, (const char *)Dtool_OdeWorld_get_contact_surface_layer_32_comment},
  {"get_auto_disable_linear_threshold", &Dtool_OdeWorld_get_auto_disable_linear_threshold_33, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_linear_threshold_33_comment},
  {"getAutoDisableLinearThreshold", &Dtool_OdeWorld_get_auto_disable_linear_threshold_33, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_linear_threshold_33_comment},
  {"get_auto_disable_angular_threshold", &Dtool_OdeWorld_get_auto_disable_angular_threshold_34, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_angular_threshold_34_comment},
  {"getAutoDisableAngularThreshold", &Dtool_OdeWorld_get_auto_disable_angular_threshold_34, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_angular_threshold_34_comment},
  {"get_auto_disable_steps", &Dtool_OdeWorld_get_auto_disable_steps_35, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_steps_35_comment},
  {"getAutoDisableSteps", &Dtool_OdeWorld_get_auto_disable_steps_35, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_steps_35_comment},
  {"get_auto_disable_time", &Dtool_OdeWorld_get_auto_disable_time_36, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_time_36_comment},
  {"getAutoDisableTime", &Dtool_OdeWorld_get_auto_disable_time_36, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_time_36_comment},
  {"get_auto_disable_flag", &Dtool_OdeWorld_get_auto_disable_flag_37, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_flag_37_comment},
  {"getAutoDisableFlag", &Dtool_OdeWorld_get_auto_disable_flag_37, METH_NOARGS, (const char *)Dtool_OdeWorld_get_auto_disable_flag_37_comment},
  {"impulse_to_force", (PyCFunction) &Dtool_OdeWorld_impulse_to_force_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_impulse_to_force_38_comment},
  {"impulseToForce", (PyCFunction) &Dtool_OdeWorld_impulse_to_force_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_impulse_to_force_38_comment},
  {"step", &Dtool_OdeWorld_step_39, METH_O, (const char *)Dtool_OdeWorld_step_39_comment},
  {"quick_step", &Dtool_OdeWorld_quick_step_40, METH_O, (const char *)Dtool_OdeWorld_quick_step_40_comment},
  {"quickStep", &Dtool_OdeWorld_quick_step_40, METH_O, (const char *)Dtool_OdeWorld_quick_step_40_comment},
  {"compare_to", &Dtool_OdeWorld_compare_to_41, METH_O, (const char *)Dtool_OdeWorld_compare_to_41_comment},
  {"compareTo", &Dtool_OdeWorld_compare_to_41, METH_O, (const char *)Dtool_OdeWorld_compare_to_41_comment},
  {"init_surface_table", &Dtool_OdeWorld_init_surface_table_42, METH_O, (const char *)Dtool_OdeWorld_init_surface_table_42_comment},
  {"initSurfaceTable", &Dtool_OdeWorld_init_surface_table_42, METH_O, (const char *)Dtool_OdeWorld_init_surface_table_42_comment},
  {"add_body_dampening", (PyCFunction) &Dtool_OdeWorld_add_body_dampening_43, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_add_body_dampening_43_comment},
  {"addBodyDampening", (PyCFunction) &Dtool_OdeWorld_add_body_dampening_43, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_add_body_dampening_43_comment},
  {"set_surface_entry", (PyCFunction) &Dtool_OdeWorld_set_surface_entry_44, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_set_surface_entry_44_comment},
  {"setSurfaceEntry", (PyCFunction) &Dtool_OdeWorld_set_surface_entry_44, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_set_surface_entry_44_comment},
  {"apply_dampening", (PyCFunction) &Dtool_OdeWorld_apply_dampening_45, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_apply_dampening_45_comment},
  {"applyDampening", (PyCFunction) &Dtool_OdeWorld_apply_dampening_45, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeWorld_apply_dampening_45_comment},
  {"get_class_type", &Dtool_OdeWorld_get_class_type_47, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeWorld_get_class_type_47_comment},
  {"getClassType", &Dtool_OdeWorld_get_class_type_47, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeWorld_get_class_type_47_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeWorld slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_OdeWorld_operator_typecast_bool_46_nb_bool(PyObject *self) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeWorld slot tp_compare -> compare_to
//////////////////
static int Dtool_OdeWorld_compare_to_41_tp_compare(PyObject *self, PyObject *arg) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int OdeWorld::compare_to(OdeWorld const &other) const
  OdeWorld const *arg_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeWorld, 1, "OdeWorld.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const OdeWorld*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(OdeWorld self, const OdeWorld other)\n");
  }
  return -1;
}

//////////////////
//  A rich comparison function
//     OdeWorld
//////////////////
static PyObject *Dtool_RichCompare_OdeWorld(PyObject *self, PyObject *arg, int op) {
  OdeWorld *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeWorld, (void **)&local_this)) {
    return nullptr;
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_OdeWorld_compare_to_41_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_OdeWorld = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_OdeWorld_operator_typecast_bool_46_nb_bool,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeWorld = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeWorld = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeWorld = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeWorld = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeWorld = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeWorld",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeWorld,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeWorld,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_OdeWorld_compare_to_41_tp_compare,
#endif
    nullptr,
    &Dtool_NumberMethods_OdeWorld,
    &Dtool_SequenceMethods_OdeWorld,
    &Dtool_MappingMethods_OdeWorld,
    &DtoolInstance_HashPointer,
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeWorld,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_OdeWorld,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeWorld,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeWorld,
    PyType_GenericAlloc,
    Dtool_new_OdeWorld,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeWorld,
  Dtool_UpcastInterface_OdeWorld,
  Dtool_DowncastInterface_OdeWorld,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeWorld(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != nullptr);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_OdeWorld._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    Dtool_OdeWorld._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeWorld._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeWorld) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeWorld)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeWorld);
  }
}

/**
 * Python method tables for OdeJointGroup (OdeJointGroup)
 */
static PyMethodDef Dtool_Methods_OdeJointGroup[] = {
  {"destroy", &Dtool_OdeJointGroup_destroy_50, METH_NOARGS, (const char *)Dtool_OdeJointGroup_destroy_50_comment},
  {"get_id", &Dtool_OdeJointGroup_get_id_51, METH_NOARGS, (const char *)Dtool_OdeJointGroup_get_id_51_comment},
  {"getId", &Dtool_OdeJointGroup_get_id_51, METH_NOARGS, (const char *)Dtool_OdeJointGroup_get_id_51_comment},
  {"empty", &Dtool_OdeJointGroup_empty_52, METH_NOARGS, (const char *)Dtool_OdeJointGroup_empty_52_comment},
  {"compare_to", &Dtool_OdeJointGroup_compare_to_53, METH_O, (const char *)Dtool_OdeJointGroup_compare_to_53_comment},
  {"compareTo", &Dtool_OdeJointGroup_compare_to_53, METH_O, (const char *)Dtool_OdeJointGroup_compare_to_53_comment},
  {"get_class_type", &Dtool_OdeJointGroup_get_class_type_54, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeJointGroup_get_class_type_54_comment},
  {"getClassType", &Dtool_OdeJointGroup_get_class_type_54, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeJointGroup_get_class_type_54_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeJointGroup slot tp_compare -> compare_to
//////////////////
static int Dtool_OdeJointGroup_compare_to_53_tp_compare(PyObject *self, PyObject *arg) {
  OdeJointGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointGroup, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int OdeJointGroup::compare_to(OdeJointGroup const &other) const
  OdeJointGroup const *arg_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointGroup, 1, "OdeJointGroup.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const OdeJointGroup*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(OdeJointGroup self, const OdeJointGroup other)\n");
  }
  return -1;
}

//////////////////
//  A rich comparison function
//     OdeJointGroup
//////////////////
static PyObject *Dtool_RichCompare_OdeJointGroup(PyObject *self, PyObject *arg, int op) {
  OdeJointGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointGroup, (void **)&local_this)) {
    return nullptr;
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_OdeJointGroup_compare_to_53_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_OdeJointGroup = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeJointGroup = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeJointGroup = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeJointGroup = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeJointGroup = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeJointGroup = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeJointGroup",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeJointGroup,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeJointGroup,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_OdeJointGroup_compare_to_53_tp_compare,
#endif
    nullptr,
    &Dtool_NumberMethods_OdeJointGroup,
    &Dtool_SequenceMethods_OdeJointGroup,
    &Dtool_MappingMethods_OdeJointGroup,
    &DtoolInstance_HashPointer,
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeJointGroup,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_OdeJointGroup,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeJointGroup,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeJointGroup,
    PyType_GenericAlloc,
    Dtool_new_OdeJointGroup,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeJointGroup,
  Dtool_UpcastInterface_OdeJointGroup,
  Dtool_DowncastInterface_OdeJointGroup,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeJointGroup(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != nullptr);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_OdeJointGroup._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    Dtool_OdeJointGroup._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeJointGroup._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeJointGroup) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeJointGroup)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeJointGroup);
  }
}

/**
 * Python method tables for OdeJointFeedback (OdeJointFeedback)
 */
static PyMethodDef Dtool_Methods_OdeJointFeedback[] = {
  {"get_force1", &Dtool_OdeJointFeedback_get_force1_57, METH_NOARGS, (const char *)Dtool_OdeJointFeedback_get_force1_57_comment},
  {"getForce1", &Dtool_OdeJointFeedback_get_force1_57, METH_NOARGS, (const char *)Dtool_OdeJointFeedback_get_force1_57_comment},
  {"get_force2", &Dtool_OdeJointFeedback_get_force2_58, METH_NOARGS, (const char *)Dtool_OdeJointFeedback_get_force2_58_comment},
  {"getForce2", &Dtool_OdeJointFeedback_get_force2_58, METH_NOARGS, (const char *)Dtool_OdeJointFeedback_get_force2_58_comment},
  {"get_torque1", &Dtool_OdeJointFeedback_get_torque1_59, METH_NOARGS, (const char *)Dtool_OdeJointFeedback_get_torque1_59_comment},
  {"getTorque1", &Dtool_OdeJointFeedback_get_torque1_59, METH_NOARGS, (const char *)Dtool_OdeJointFeedback_get_torque1_59_comment},
  {"get_torque2", &Dtool_OdeJointFeedback_get_torque2_60, METH_NOARGS, (const char *)Dtool_OdeJointFeedback_get_torque2_60_comment},
  {"getTorque2", &Dtool_OdeJointFeedback_get_torque2_60, METH_NOARGS, (const char *)Dtool_OdeJointFeedback_get_torque2_60_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeJointFeedback = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeJointFeedback = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeJointFeedback = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeJointFeedback = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeJointFeedback = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeJointFeedback = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeJointFeedback",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeJointFeedback,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeJointFeedback,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeJointFeedback,
    &Dtool_SequenceMethods_OdeJointFeedback,
    &Dtool_MappingMethods_OdeJointFeedback,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeJointFeedback,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeJointFeedback,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeJointFeedback,
    PyType_GenericAlloc,
    Dtool_new_OdeJointFeedback,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeJointFeedback,
  Dtool_UpcastInterface_OdeJointFeedback,
  Dtool_DowncastInterface_OdeJointFeedback,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeJointFeedback(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_OdeJointFeedback._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeJointFeedback._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeJointFeedback) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeJointFeedback)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeJointFeedback);
  }
}

/**
 * Python method tables for OdeJoint (OdeJoint)
 */
static PyMethodDef Dtool_Methods_OdeJoint[] = {
  {"destroy", &Dtool_OdeJoint_destroy_65, METH_NOARGS, (const char *)Dtool_OdeJoint_destroy_65_comment},
  {"is_empty", &Dtool_OdeJoint_is_empty_66, METH_NOARGS, (const char *)Dtool_OdeJoint_is_empty_66_comment},
  {"isEmpty", &Dtool_OdeJoint_is_empty_66, METH_NOARGS, (const char *)Dtool_OdeJoint_is_empty_66_comment},
  {"get_id", &Dtool_OdeJoint_get_id_67, METH_NOARGS, (const char *)Dtool_OdeJoint_get_id_67_comment},
  {"getId", &Dtool_OdeJoint_get_id_67, METH_NOARGS, (const char *)Dtool_OdeJoint_get_id_67_comment},
  {"get_joint_type", &Dtool_OdeJoint_get_joint_type_68, METH_NOARGS, (const char *)Dtool_OdeJoint_get_joint_type_68_comment},
  {"getJointType", &Dtool_OdeJoint_get_joint_type_68, METH_NOARGS, (const char *)Dtool_OdeJoint_get_joint_type_68_comment},
  {"get_body", &Dtool_OdeJoint_get_body_69, METH_O, (const char *)Dtool_OdeJoint_get_body_69_comment},
  {"getBody", &Dtool_OdeJoint_get_body_69, METH_O, (const char *)Dtool_OdeJoint_get_body_69_comment},
  {"set_feedback", (PyCFunction) &Dtool_OdeJoint_set_feedback_70, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeJoint_set_feedback_70_comment},
  {"setFeedback", (PyCFunction) &Dtool_OdeJoint_set_feedback_70, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeJoint_set_feedback_70_comment},
  {"get_feedback", &Dtool_OdeJoint_get_feedback_71, METH_NOARGS, (const char *)Dtool_OdeJoint_get_feedback_71_comment},
  {"getFeedback", &Dtool_OdeJoint_get_feedback_71, METH_NOARGS, (const char *)Dtool_OdeJoint_get_feedback_71_comment},
  {"attach", (PyCFunction) &Dtool_OdeJoint_attach_72, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeJoint_attach_72_comment},
  {"attach_bodies", (PyCFunction) &Dtool_OdeJoint_attach_bodies_73, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeJoint_attach_bodies_73_comment},
  {"attachBodies", (PyCFunction) &Dtool_OdeJoint_attach_bodies_73, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeJoint_attach_bodies_73_comment},
  {"attach_body", (PyCFunction) &Dtool_OdeJoint_attach_body_74, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeJoint_attach_body_74_comment},
  {"attachBody", (PyCFunction) &Dtool_OdeJoint_attach_body_74, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeJoint_attach_body_74_comment},
  {"detach", &Dtool_OdeJoint_detach_75, METH_NOARGS, (const char *)Dtool_OdeJoint_detach_75_comment},
  {"write", (PyCFunction) &Dtool_OdeJoint_write_76, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeJoint_write_76_comment},
  {"compare_to", &Dtool_OdeJoint_compare_to_77, METH_O, (const char *)Dtool_OdeJoint_compare_to_77_comment},
  {"compareTo", &Dtool_OdeJoint_compare_to_77, METH_O, (const char *)Dtool_OdeJoint_compare_to_77_comment},
  {"convert", &Dtool_OdeJoint_convert_80, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_80_comment},
  {"convert_to_ball", &Dtool_OdeJoint_convert_to_ball_81, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_ball_81_comment},
  {"convertToBall", &Dtool_OdeJoint_convert_to_ball_81, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_ball_81_comment},
  {"convert_to_hinge", &Dtool_OdeJoint_convert_to_hinge_82, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_hinge_82_comment},
  {"convertToHinge", &Dtool_OdeJoint_convert_to_hinge_82, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_hinge_82_comment},
  {"convert_to_slider", &Dtool_OdeJoint_convert_to_slider_83, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_slider_83_comment},
  {"convertToSlider", &Dtool_OdeJoint_convert_to_slider_83, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_slider_83_comment},
  {"convert_to_contact", &Dtool_OdeJoint_convert_to_contact_84, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_contact_84_comment},
  {"convertToContact", &Dtool_OdeJoint_convert_to_contact_84, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_contact_84_comment},
  {"convert_to_universal", &Dtool_OdeJoint_convert_to_universal_85, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_universal_85_comment},
  {"convertToUniversal", &Dtool_OdeJoint_convert_to_universal_85, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_universal_85_comment},
  {"convert_to_hinge2", &Dtool_OdeJoint_convert_to_hinge2_86, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_hinge2_86_comment},
  {"convertToHinge2", &Dtool_OdeJoint_convert_to_hinge2_86, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_hinge2_86_comment},
  {"convert_to_fixed", &Dtool_OdeJoint_convert_to_fixed_87, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_fixed_87_comment},
  {"convertToFixed", &Dtool_OdeJoint_convert_to_fixed_87, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_fixed_87_comment},
  {"convert_to_null", &Dtool_OdeJoint_convert_to_null_88, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_null_88_comment},
  {"convertToNull", &Dtool_OdeJoint_convert_to_null_88, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_null_88_comment},
  {"convert_to_a_motor", &Dtool_OdeJoint_convert_to_a_motor_89, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_a_motor_89_comment},
  {"convertToAMotor", &Dtool_OdeJoint_convert_to_a_motor_89, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_a_motor_89_comment},
  {"convert_to_l_motor", &Dtool_OdeJoint_convert_to_l_motor_90, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_l_motor_90_comment},
  {"convertToLMotor", &Dtool_OdeJoint_convert_to_l_motor_90, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_l_motor_90_comment},
  {"convert_to_plane2d", &Dtool_OdeJoint_convert_to_plane2d_91, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_plane2d_91_comment},
  {"convertToPlane2d", &Dtool_OdeJoint_convert_to_plane2d_91, METH_NOARGS, (const char *)Dtool_OdeJoint_convert_to_plane2d_91_comment},
  {"get_class_type", &Dtool_OdeJoint_get_class_type_92, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeJoint_get_class_type_92_comment},
  {"getClassType", &Dtool_OdeJoint_get_class_type_92, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeJoint_get_class_type_92_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeJoint slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_OdeJoint_operator_typecast_bool_79_nb_bool(PyObject *self) {
  OdeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeJoint slot tp_compare -> compare_to
//////////////////
static int Dtool_OdeJoint_compare_to_77_tp_compare(PyObject *self, PyObject *arg) {
  OdeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int OdeJoint::compare_to(OdeJoint const &other) const
  OdeJoint const *arg_this = (OdeJoint *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJoint, 1, "OdeJoint.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const OdeJoint*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(OdeJoint self, const OdeJoint other)\n");
  }
  return -1;
}

//////////////////
//  A __str__ function
//     OdeJoint
//////////////////
static PyObject *Dtool_Str_OdeJoint(PyObject *self) {
  OdeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     OdeJoint
//////////////////
static PyObject *Dtool_RichCompare_OdeJoint(PyObject *self, PyObject *arg, int op) {
  OdeJoint *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJoint, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool OdeJoint::operator ==(OdeJoint const &other) const
      OdeJoint const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_OdeJoint);
      if (arg_this != nullptr) {
        bool return_value = ((*(const OdeJoint*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_OdeJoint_compare_to_77_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_OdeJoint = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_OdeJoint_operator_typecast_bool_79_nb_bool,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeJoint = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeJoint = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeJoint = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeJoint = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeJoint = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeJoint",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeJoint,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeJoint,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_OdeJoint_compare_to_77_tp_compare,
#endif
    nullptr,
    &Dtool_NumberMethods_OdeJoint,
    &Dtool_SequenceMethods_OdeJoint,
    &Dtool_MappingMethods_OdeJoint,
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_OdeJoint,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_OdeJoint,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeJoint,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeJoint,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeJoint,
  Dtool_UpcastInterface_OdeJoint,
  Dtool_DowncastInterface_OdeJoint,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != nullptr);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_OdeJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    Dtool_OdeJoint._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(25);
    Dtool_OdeJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum OdeJoint::JointType;
    PyDict_SetItemString(dict, "JT_none", Dtool_WrapValue(OdeJoint::JT_none));
    PyDict_SetItemString(dict, "JTNone", Dtool_WrapValue(OdeJoint::JT_none));
    PyDict_SetItemString(dict, "JT_ball", Dtool_WrapValue(OdeJoint::JT_ball));
    PyDict_SetItemString(dict, "JTBall", Dtool_WrapValue(OdeJoint::JT_ball));
    PyDict_SetItemString(dict, "JT_hinge", Dtool_WrapValue(OdeJoint::JT_hinge));
    PyDict_SetItemString(dict, "JTHinge", Dtool_WrapValue(OdeJoint::JT_hinge));
    PyDict_SetItemString(dict, "JT_slider", Dtool_WrapValue(OdeJoint::JT_slider));
    PyDict_SetItemString(dict, "JTSlider", Dtool_WrapValue(OdeJoint::JT_slider));
    PyDict_SetItemString(dict, "JT_contact", Dtool_WrapValue(OdeJoint::JT_contact));
    PyDict_SetItemString(dict, "JTContact", Dtool_WrapValue(OdeJoint::JT_contact));
    PyDict_SetItemString(dict, "JT_universal", Dtool_WrapValue(OdeJoint::JT_universal));
    PyDict_SetItemString(dict, "JTUniversal", Dtool_WrapValue(OdeJoint::JT_universal));
    PyDict_SetItemString(dict, "JT_hinge2", Dtool_WrapValue(OdeJoint::JT_hinge2));
    PyDict_SetItemString(dict, "JTHinge2", Dtool_WrapValue(OdeJoint::JT_hinge2));
    PyDict_SetItemString(dict, "JT_fixed", Dtool_WrapValue(OdeJoint::JT_fixed));
    PyDict_SetItemString(dict, "JTFixed", Dtool_WrapValue(OdeJoint::JT_fixed));
    PyDict_SetItemString(dict, "JT_null", Dtool_WrapValue(OdeJoint::JT_null));
    PyDict_SetItemString(dict, "JTNull", Dtool_WrapValue(OdeJoint::JT_null));
    PyDict_SetItemString(dict, "JT_a_motor", Dtool_WrapValue(OdeJoint::JT_a_motor));
    PyDict_SetItemString(dict, "JTAMotor", Dtool_WrapValue(OdeJoint::JT_a_motor));
    PyDict_SetItemString(dict, "JT_l_motor", Dtool_WrapValue(OdeJoint::JT_l_motor));
    PyDict_SetItemString(dict, "JTLMotor", Dtool_WrapValue(OdeJoint::JT_l_motor));
    PyDict_SetItemString(dict, "JT_plane2d", Dtool_WrapValue(OdeJoint::JT_plane2d));
    PyDict_SetItemString(dict, "JTPlane2d", Dtool_WrapValue(OdeJoint::JT_plane2d));
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeJoint);
  }
}

/**
 * Python method tables for OdeAMotorJoint (OdeAMotorJoint)
 */
static PyMethodDef Dtool_Methods_OdeAMotorJoint[] = {
  {"set_num_axes", &Dtool_OdeAMotorJoint_set_num_axes_95, METH_O, (const char *)Dtool_OdeAMotorJoint_set_num_axes_95_comment},
  {"setNumAxes", &Dtool_OdeAMotorJoint_set_num_axes_95, METH_O, (const char *)Dtool_OdeAMotorJoint_set_num_axes_95_comment},
  {"set_axis", (PyCFunction) &Dtool_OdeAMotorJoint_set_axis_96, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_axis_96_comment},
  {"setAxis", (PyCFunction) &Dtool_OdeAMotorJoint_set_axis_96, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_axis_96_comment},
  {"set_angle", (PyCFunction) &Dtool_OdeAMotorJoint_set_angle_97, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_angle_97_comment},
  {"setAngle", (PyCFunction) &Dtool_OdeAMotorJoint_set_angle_97, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_angle_97_comment},
  {"set_mode", &Dtool_OdeAMotorJoint_set_mode_98, METH_O, (const char *)Dtool_OdeAMotorJoint_set_mode_98_comment},
  {"setMode", &Dtool_OdeAMotorJoint_set_mode_98, METH_O, (const char *)Dtool_OdeAMotorJoint_set_mode_98_comment},
  {"add_torques", (PyCFunction) &Dtool_OdeAMotorJoint_add_torques_99, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_add_torques_99_comment},
  {"addTorques", (PyCFunction) &Dtool_OdeAMotorJoint_add_torques_99, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_add_torques_99_comment},
  {"get_num_axes", &Dtool_OdeAMotorJoint_get_num_axes_100, METH_NOARGS, (const char *)Dtool_OdeAMotorJoint_get_num_axes_100_comment},
  {"getNumAxes", &Dtool_OdeAMotorJoint_get_num_axes_100, METH_NOARGS, (const char *)Dtool_OdeAMotorJoint_get_num_axes_100_comment},
  {"get_axis", &Dtool_OdeAMotorJoint_get_axis_101, METH_O, (const char *)Dtool_OdeAMotorJoint_get_axis_101_comment},
  {"getAxis", &Dtool_OdeAMotorJoint_get_axis_101, METH_O, (const char *)Dtool_OdeAMotorJoint_get_axis_101_comment},
  {"get_axis_rel", &Dtool_OdeAMotorJoint_get_axis_rel_103, METH_O, (const char *)Dtool_OdeAMotorJoint_get_axis_rel_103_comment},
  {"getAxisRel", &Dtool_OdeAMotorJoint_get_axis_rel_103, METH_O, (const char *)Dtool_OdeAMotorJoint_get_axis_rel_103_comment},
  {"get_angle", &Dtool_OdeAMotorJoint_get_angle_104, METH_O, (const char *)Dtool_OdeAMotorJoint_get_angle_104_comment},
  {"getAngle", &Dtool_OdeAMotorJoint_get_angle_104, METH_O, (const char *)Dtool_OdeAMotorJoint_get_angle_104_comment},
  {"get_angle_rate", &Dtool_OdeAMotorJoint_get_angle_rate_105, METH_O, (const char *)Dtool_OdeAMotorJoint_get_angle_rate_105_comment},
  {"getAngleRate", &Dtool_OdeAMotorJoint_get_angle_rate_105, METH_O, (const char *)Dtool_OdeAMotorJoint_get_angle_rate_105_comment},
  {"get_mode", &Dtool_OdeAMotorJoint_get_mode_106, METH_NOARGS, (const char *)Dtool_OdeAMotorJoint_get_mode_106_comment},
  {"getMode", &Dtool_OdeAMotorJoint_get_mode_106, METH_NOARGS, (const char *)Dtool_OdeAMotorJoint_get_mode_106_comment},
  {"set_param_lo_stop", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_lo_stop_107, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_lo_stop_107_comment},
  {"setParamLoStop", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_lo_stop_107, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_lo_stop_107_comment},
  {"set_param_hi_stop", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_hi_stop_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_hi_stop_108_comment},
  {"setParamHiStop", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_hi_stop_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_hi_stop_108_comment},
  {"set_param_vel", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_vel_109, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_vel_109_comment},
  {"setParamVel", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_vel_109, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_vel_109_comment},
  {"set_param_f_max", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_f_max_110, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_f_max_110_comment},
  {"setParamFMax", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_f_max_110, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_f_max_110_comment},
  {"set_param_fudge_factor", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_fudge_factor_111, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_fudge_factor_111_comment},
  {"setParamFudgeFactor", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_fudge_factor_111, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_fudge_factor_111_comment},
  {"set_param_bounce", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_bounce_112, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_bounce_112_comment},
  {"setParamBounce", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_bounce_112, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_bounce_112_comment},
  {"set_param_CFM", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_CFM_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_CFM_113_comment},
  {"setParamCFM", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_CFM_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_CFM_113_comment},
  {"set_param_stop_ERP", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_stop_ERP_114, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_stop_ERP_114_comment},
  {"setParamStopERP", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_stop_ERP_114, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_stop_ERP_114_comment},
  {"set_param_stop_CFM", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_stop_CFM_115, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_stop_CFM_115_comment},
  {"setParamStopCFM", (PyCFunction) &Dtool_OdeAMotorJoint_set_param_stop_CFM_115, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeAMotorJoint_set_param_stop_CFM_115_comment},
  {"get_param_lo_stop", &Dtool_OdeAMotorJoint_get_param_lo_stop_116, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_lo_stop_116_comment},
  {"getParamLoStop", &Dtool_OdeAMotorJoint_get_param_lo_stop_116, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_lo_stop_116_comment},
  {"get_param_hi_stop", &Dtool_OdeAMotorJoint_get_param_hi_stop_117, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_hi_stop_117_comment},
  {"getParamHiStop", &Dtool_OdeAMotorJoint_get_param_hi_stop_117, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_hi_stop_117_comment},
  {"get_param_vel", &Dtool_OdeAMotorJoint_get_param_vel_118, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_vel_118_comment},
  {"getParamVel", &Dtool_OdeAMotorJoint_get_param_vel_118, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_vel_118_comment},
  {"get_param_f_max", &Dtool_OdeAMotorJoint_get_param_f_max_119, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_f_max_119_comment},
  {"getParamFMax", &Dtool_OdeAMotorJoint_get_param_f_max_119, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_f_max_119_comment},
  {"get_param_fudge_factor", &Dtool_OdeAMotorJoint_get_param_fudge_factor_120, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_fudge_factor_120_comment},
  {"getParamFudgeFactor", &Dtool_OdeAMotorJoint_get_param_fudge_factor_120, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_fudge_factor_120_comment},
  {"get_param_bounce", &Dtool_OdeAMotorJoint_get_param_bounce_121, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_bounce_121_comment},
  {"getParamBounce", &Dtool_OdeAMotorJoint_get_param_bounce_121, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_bounce_121_comment},
  {"get_param_CFM", &Dtool_OdeAMotorJoint_get_param_CFM_122, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_CFM_122_comment},
  {"getParamCFM", &Dtool_OdeAMotorJoint_get_param_CFM_122, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_CFM_122_comment},
  {"get_param_stop_ERP", &Dtool_OdeAMotorJoint_get_param_stop_ERP_123, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_stop_ERP_123_comment},
  {"getParamStopERP", &Dtool_OdeAMotorJoint_get_param_stop_ERP_123, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_stop_ERP_123_comment},
  {"get_param_stop_CFM", &Dtool_OdeAMotorJoint_get_param_stop_CFM_124, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_stop_CFM_124_comment},
  {"getParamStopCFM", &Dtool_OdeAMotorJoint_get_param_stop_CFM_124, METH_O, (const char *)Dtool_OdeAMotorJoint_get_param_stop_CFM_124_comment},
  {"get_class_type", &Dtool_OdeAMotorJoint_get_class_type_125, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeAMotorJoint_get_class_type_125_comment},
  {"getClassType", &Dtool_OdeAMotorJoint_get_class_type_125, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeAMotorJoint_get_class_type_125_comment},
  {"get_axes", (PyCFunction) &MakeSeq_OdeAMotorJoint_get_axes, METH_NOARGS, nullptr},
  { "getAxes", (PyCFunction) &MakeSeq_OdeAMotorJoint_get_axes, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeAMotorJoint = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeAMotorJoint = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeAMotorJoint = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeAMotorJoint = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeAMotorJoint = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeAMotorJoint = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeAMotorJoint",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeAMotorJoint,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeAMotorJoint,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeAMotorJoint,
    &Dtool_SequenceMethods_OdeAMotorJoint,
    &Dtool_MappingMethods_OdeAMotorJoint,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeAMotorJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeAMotorJoint,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeAMotorJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeAMotorJoint,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeAMotorJoint,
  Dtool_UpcastInterface_OdeAMotorJoint,
  Dtool_DowncastInterface_OdeAMotorJoint,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeAMotorJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(nullptr);
    Dtool_OdeAMotorJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    Dtool_OdeAMotorJoint._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeAMotorJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeAMotorJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeAMotorJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeAMotorJoint);
  }
}

/**
 * Python method tables for OdeBallJoint (OdeBallJoint)
 */
static PyMethodDef Dtool_Methods_OdeBallJoint[] = {
  {"set_anchor", (PyCFunction) &Dtool_OdeBallJoint_set_anchor_128, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBallJoint_set_anchor_128_comment},
  {"setAnchor", (PyCFunction) &Dtool_OdeBallJoint_set_anchor_128, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBallJoint_set_anchor_128_comment},
  {"set_anchor2", (PyCFunction) &Dtool_OdeBallJoint_set_anchor2_129, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBallJoint_set_anchor2_129_comment},
  {"setAnchor2", (PyCFunction) &Dtool_OdeBallJoint_set_anchor2_129, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBallJoint_set_anchor2_129_comment},
  {"get_anchor", &Dtool_OdeBallJoint_get_anchor_130, METH_NOARGS, (const char *)Dtool_OdeBallJoint_get_anchor_130_comment},
  {"getAnchor", &Dtool_OdeBallJoint_get_anchor_130, METH_NOARGS, (const char *)Dtool_OdeBallJoint_get_anchor_130_comment},
  {"get_anchor2", &Dtool_OdeBallJoint_get_anchor2_131, METH_NOARGS, (const char *)Dtool_OdeBallJoint_get_anchor2_131_comment},
  {"getAnchor2", &Dtool_OdeBallJoint_get_anchor2_131, METH_NOARGS, (const char *)Dtool_OdeBallJoint_get_anchor2_131_comment},
  {"get_class_type", &Dtool_OdeBallJoint_get_class_type_132, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeBallJoint_get_class_type_132_comment},
  {"getClassType", &Dtool_OdeBallJoint_get_class_type_132, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeBallJoint_get_class_type_132_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeBallJoint = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeBallJoint = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeBallJoint = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeBallJoint = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeBallJoint = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeBallJoint = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeBallJoint",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeBallJoint,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeBallJoint,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeBallJoint,
    &Dtool_SequenceMethods_OdeBallJoint,
    &Dtool_MappingMethods_OdeBallJoint,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeBallJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeBallJoint,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeBallJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeBallJoint,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeBallJoint,
  Dtool_UpcastInterface_OdeBallJoint,
  Dtool_DowncastInterface_OdeBallJoint,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeBallJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(nullptr);
    Dtool_OdeBallJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    Dtool_OdeBallJoint._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeBallJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeBallJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeBallJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeBallJoint);
  }
}

/**
 * Python method tables for OdeMass (OdeMass)
 */
static PyMethodDef Dtool_Methods_OdeMass[] = {
  {"check", &Dtool_OdeMass_check_136, METH_NOARGS, (const char *)Dtool_OdeMass_check_136_comment},
  {"set_zero", &Dtool_OdeMass_set_zero_137, METH_NOARGS, (const char *)Dtool_OdeMass_set_zero_137_comment},
  {"setZero", &Dtool_OdeMass_set_zero_137, METH_NOARGS, (const char *)Dtool_OdeMass_set_zero_137_comment},
  {"set_parameters", (PyCFunction) &Dtool_OdeMass_set_parameters_138, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_parameters_138_comment},
  {"setParameters", (PyCFunction) &Dtool_OdeMass_set_parameters_138, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_parameters_138_comment},
  {"set_sphere", (PyCFunction) &Dtool_OdeMass_set_sphere_139, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_sphere_139_comment},
  {"setSphere", (PyCFunction) &Dtool_OdeMass_set_sphere_139, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_sphere_139_comment},
  {"set_sphere_total", (PyCFunction) &Dtool_OdeMass_set_sphere_total_140, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_sphere_total_140_comment},
  {"setSphereTotal", (PyCFunction) &Dtool_OdeMass_set_sphere_total_140, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_sphere_total_140_comment},
  {"set_capsule", (PyCFunction) &Dtool_OdeMass_set_capsule_141, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_capsule_141_comment},
  {"setCapsule", (PyCFunction) &Dtool_OdeMass_set_capsule_141, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_capsule_141_comment},
  {"set_capsule_total", (PyCFunction) &Dtool_OdeMass_set_capsule_total_142, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_capsule_total_142_comment},
  {"setCapsuleTotal", (PyCFunction) &Dtool_OdeMass_set_capsule_total_142, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_capsule_total_142_comment},
  {"set_cylinder", (PyCFunction) &Dtool_OdeMass_set_cylinder_143, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_cylinder_143_comment},
  {"setCylinder", (PyCFunction) &Dtool_OdeMass_set_cylinder_143, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_cylinder_143_comment},
  {"set_cylinder_total", (PyCFunction) &Dtool_OdeMass_set_cylinder_total_144, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_cylinder_total_144_comment},
  {"setCylinderTotal", (PyCFunction) &Dtool_OdeMass_set_cylinder_total_144, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_cylinder_total_144_comment},
  {"set_box", (PyCFunction) &Dtool_OdeMass_set_box_145, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_box_145_comment},
  {"setBox", (PyCFunction) &Dtool_OdeMass_set_box_145, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_box_145_comment},
  {"set_box_total", (PyCFunction) &Dtool_OdeMass_set_box_total_146, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_box_total_146_comment},
  {"setBoxTotal", (PyCFunction) &Dtool_OdeMass_set_box_total_146, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_set_box_total_146_comment},
  {"adjust", &Dtool_OdeMass_adjust_147, METH_O, (const char *)Dtool_OdeMass_adjust_147_comment},
  {"translate", (PyCFunction) &Dtool_OdeMass_translate_148, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_translate_148_comment},
  {"rotate", &Dtool_OdeMass_rotate_149, METH_O, (const char *)Dtool_OdeMass_rotate_149_comment},
  {"add", &Dtool_OdeMass_add_150, METH_O, (const char *)Dtool_OdeMass_add_150_comment},
  {"get_magnitude", &Dtool_OdeMass_get_magnitude_151, METH_NOARGS, (const char *)Dtool_OdeMass_get_magnitude_151_comment},
  {"getMagnitude", &Dtool_OdeMass_get_magnitude_151, METH_NOARGS, (const char *)Dtool_OdeMass_get_magnitude_151_comment},
  {"get_center", &Dtool_OdeMass_get_center_152, METH_NOARGS, (const char *)Dtool_OdeMass_get_center_152_comment},
  {"getCenter", &Dtool_OdeMass_get_center_152, METH_NOARGS, (const char *)Dtool_OdeMass_get_center_152_comment},
  {"get_inertial_tensor", &Dtool_OdeMass_get_inertial_tensor_153, METH_NOARGS, (const char *)Dtool_OdeMass_get_inertial_tensor_153_comment},
  {"getInertialTensor", &Dtool_OdeMass_get_inertial_tensor_153, METH_NOARGS, (const char *)Dtool_OdeMass_get_inertial_tensor_153_comment},
  {"write", (PyCFunction) &Dtool_OdeMass_write_154, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeMass_write_154_comment},
  {"get_class_type", &Dtool_OdeMass_get_class_type_155, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeMass_get_class_type_155_comment},
  {"getClassType", &Dtool_OdeMass_get_class_type_155, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeMass_get_class_type_155_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     OdeMass
//////////////////
static PyObject *Dtool_Str_OdeMass(PyObject *self) {
  OdeMass *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeMass, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_OdeMass = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeMass = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeMass = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeMass = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeMass = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeMass = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeMass",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeMass,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeMass,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeMass,
    &Dtool_SequenceMethods_OdeMass,
    &Dtool_MappingMethods_OdeMass,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_OdeMass,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeMass,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeMass,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeMass,
    PyType_GenericAlloc,
    Dtool_new_OdeMass,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeMass,
  Dtool_UpcastInterface_OdeMass,
  Dtool_DowncastInterface_OdeMass,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeMass(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_OdeMass._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_OdeMass._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeMass._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeMass) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeMass)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeMass);
  }
}

/**
 * Python method tables for OdeBody (OdeBody)
 */
static PyMethodDef Dtool_Methods_OdeBody[] = {
  {"destroy", &Dtool_OdeBody_destroy_158, METH_NOARGS, (const char *)Dtool_OdeBody_destroy_158_comment},
  {"is_empty", &Dtool_OdeBody_is_empty_159, METH_NOARGS, (const char *)Dtool_OdeBody_is_empty_159_comment},
  {"isEmpty", &Dtool_OdeBody_is_empty_159, METH_NOARGS, (const char *)Dtool_OdeBody_is_empty_159_comment},
  {"get_id", &Dtool_OdeBody_get_id_160, METH_NOARGS, (const char *)Dtool_OdeBody_get_id_160_comment},
  {"getId", &Dtool_OdeBody_get_id_160, METH_NOARGS, (const char *)Dtool_OdeBody_get_id_160_comment},
  {"set_auto_disable_linear_threshold", &Dtool_OdeBody_set_auto_disable_linear_threshold_161, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_linear_threshold_161_comment},
  {"setAutoDisableLinearThreshold", &Dtool_OdeBody_set_auto_disable_linear_threshold_161, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_linear_threshold_161_comment},
  {"set_auto_disable_angular_threshold", &Dtool_OdeBody_set_auto_disable_angular_threshold_162, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_angular_threshold_162_comment},
  {"setAutoDisableAngularThreshold", &Dtool_OdeBody_set_auto_disable_angular_threshold_162, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_angular_threshold_162_comment},
  {"set_auto_disable_steps", &Dtool_OdeBody_set_auto_disable_steps_163, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_steps_163_comment},
  {"setAutoDisableSteps", &Dtool_OdeBody_set_auto_disable_steps_163, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_steps_163_comment},
  {"set_auto_disable_time", &Dtool_OdeBody_set_auto_disable_time_164, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_time_164_comment},
  {"setAutoDisableTime", &Dtool_OdeBody_set_auto_disable_time_164, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_time_164_comment},
  {"set_auto_disable_flag", &Dtool_OdeBody_set_auto_disable_flag_165, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_flag_165_comment},
  {"setAutoDisableFlag", &Dtool_OdeBody_set_auto_disable_flag_165, METH_O, (const char *)Dtool_OdeBody_set_auto_disable_flag_165_comment},
  {"set_auto_disable_defaults", &Dtool_OdeBody_set_auto_disable_defaults_166, METH_NOARGS, (const char *)Dtool_OdeBody_set_auto_disable_defaults_166_comment},
  {"setAutoDisableDefaults", &Dtool_OdeBody_set_auto_disable_defaults_166, METH_NOARGS, (const char *)Dtool_OdeBody_set_auto_disable_defaults_166_comment},
  {"set_data", &Dtool_OdeBody_set_data_167, METH_O, (const char *)Dtool_OdeBody_set_data_167_comment},
  {"setData", &Dtool_OdeBody_set_data_167, METH_O, (const char *)Dtool_OdeBody_set_data_167_comment},
  {"set_position", (PyCFunction) &Dtool_OdeBody_set_position_168, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_position_168_comment},
  {"setPosition", (PyCFunction) &Dtool_OdeBody_set_position_168, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_position_168_comment},
  {"set_rotation", &Dtool_OdeBody_set_rotation_169, METH_O, (const char *)Dtool_OdeBody_set_rotation_169_comment},
  {"setRotation", &Dtool_OdeBody_set_rotation_169, METH_O, (const char *)Dtool_OdeBody_set_rotation_169_comment},
  {"set_quaternion", &Dtool_OdeBody_set_quaternion_170, METH_O, (const char *)Dtool_OdeBody_set_quaternion_170_comment},
  {"setQuaternion", &Dtool_OdeBody_set_quaternion_170, METH_O, (const char *)Dtool_OdeBody_set_quaternion_170_comment},
  {"set_linear_vel", (PyCFunction) &Dtool_OdeBody_set_linear_vel_171, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_linear_vel_171_comment},
  {"setLinearVel", (PyCFunction) &Dtool_OdeBody_set_linear_vel_171, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_linear_vel_171_comment},
  {"set_angular_vel", (PyCFunction) &Dtool_OdeBody_set_angular_vel_172, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_angular_vel_172_comment},
  {"setAngularVel", (PyCFunction) &Dtool_OdeBody_set_angular_vel_172, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_angular_vel_172_comment},
  {"set_mass", &Dtool_OdeBody_set_mass_173, METH_O, (const char *)Dtool_OdeBody_set_mass_173_comment},
  {"setMass", &Dtool_OdeBody_set_mass_173, METH_O, (const char *)Dtool_OdeBody_set_mass_173_comment},
  {"get_auto_disable_linear_threshold", &Dtool_OdeBody_get_auto_disable_linear_threshold_174, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_linear_threshold_174_comment},
  {"getAutoDisableLinearThreshold", &Dtool_OdeBody_get_auto_disable_linear_threshold_174, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_linear_threshold_174_comment},
  {"get_auto_disable_angular_threshold", &Dtool_OdeBody_get_auto_disable_angular_threshold_175, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_angular_threshold_175_comment},
  {"getAutoDisableAngularThreshold", &Dtool_OdeBody_get_auto_disable_angular_threshold_175, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_angular_threshold_175_comment},
  {"get_auto_disable_steps", &Dtool_OdeBody_get_auto_disable_steps_176, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_steps_176_comment},
  {"getAutoDisableSteps", &Dtool_OdeBody_get_auto_disable_steps_176, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_steps_176_comment},
  {"get_auto_disable_time", &Dtool_OdeBody_get_auto_disable_time_177, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_time_177_comment},
  {"getAutoDisableTime", &Dtool_OdeBody_get_auto_disable_time_177, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_time_177_comment},
  {"get_auto_disable_flag", &Dtool_OdeBody_get_auto_disable_flag_178, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_flag_178_comment},
  {"getAutoDisableFlag", &Dtool_OdeBody_get_auto_disable_flag_178, METH_NOARGS, (const char *)Dtool_OdeBody_get_auto_disable_flag_178_comment},
  {"get_data", &Dtool_OdeBody_get_data_179, METH_NOARGS, (const char *)Dtool_OdeBody_get_data_179_comment},
  {"getData", &Dtool_OdeBody_get_data_179, METH_NOARGS, (const char *)Dtool_OdeBody_get_data_179_comment},
  {"get_position", &Dtool_OdeBody_get_position_180, METH_NOARGS, (const char *)Dtool_OdeBody_get_position_180_comment},
  {"getPosition", &Dtool_OdeBody_get_position_180, METH_NOARGS, (const char *)Dtool_OdeBody_get_position_180_comment},
  {"get_rotation", &Dtool_OdeBody_get_rotation_181, METH_NOARGS, (const char *)Dtool_OdeBody_get_rotation_181_comment},
  {"getRotation", &Dtool_OdeBody_get_rotation_181, METH_NOARGS, (const char *)Dtool_OdeBody_get_rotation_181_comment},
  {"get_quaternion", &Dtool_OdeBody_get_quaternion_182, METH_NOARGS, (const char *)Dtool_OdeBody_get_quaternion_182_comment},
  {"getQuaternion", &Dtool_OdeBody_get_quaternion_182, METH_NOARGS, (const char *)Dtool_OdeBody_get_quaternion_182_comment},
  {"get_linear_vel", &Dtool_OdeBody_get_linear_vel_183, METH_NOARGS, (const char *)Dtool_OdeBody_get_linear_vel_183_comment},
  {"getLinearVel", &Dtool_OdeBody_get_linear_vel_183, METH_NOARGS, (const char *)Dtool_OdeBody_get_linear_vel_183_comment},
  {"get_angular_vel", &Dtool_OdeBody_get_angular_vel_184, METH_NOARGS, (const char *)Dtool_OdeBody_get_angular_vel_184_comment},
  {"getAngularVel", &Dtool_OdeBody_get_angular_vel_184, METH_NOARGS, (const char *)Dtool_OdeBody_get_angular_vel_184_comment},
  {"get_mass", &Dtool_OdeBody_get_mass_185, METH_NOARGS, (const char *)Dtool_OdeBody_get_mass_185_comment},
  {"getMass", &Dtool_OdeBody_get_mass_185, METH_NOARGS, (const char *)Dtool_OdeBody_get_mass_185_comment},
  {"add_force", (PyCFunction) &Dtool_OdeBody_add_force_186, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_force_186_comment},
  {"addForce", (PyCFunction) &Dtool_OdeBody_add_force_186, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_force_186_comment},
  {"add_torque", (PyCFunction) &Dtool_OdeBody_add_torque_187, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_torque_187_comment},
  {"addTorque", (PyCFunction) &Dtool_OdeBody_add_torque_187, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_torque_187_comment},
  {"add_rel_force", (PyCFunction) &Dtool_OdeBody_add_rel_force_188, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_rel_force_188_comment},
  {"addRelForce", (PyCFunction) &Dtool_OdeBody_add_rel_force_188, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_rel_force_188_comment},
  {"add_rel_torque", (PyCFunction) &Dtool_OdeBody_add_rel_torque_189, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_rel_torque_189_comment},
  {"addRelTorque", (PyCFunction) &Dtool_OdeBody_add_rel_torque_189, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_rel_torque_189_comment},
  {"add_force_at_pos", (PyCFunction) &Dtool_OdeBody_add_force_at_pos_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_force_at_pos_190_comment},
  {"addForceAtPos", (PyCFunction) &Dtool_OdeBody_add_force_at_pos_190, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_force_at_pos_190_comment},
  {"add_force_at_rel_pos", (PyCFunction) &Dtool_OdeBody_add_force_at_rel_pos_191, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_force_at_rel_pos_191_comment},
  {"addForceAtRelPos", (PyCFunction) &Dtool_OdeBody_add_force_at_rel_pos_191, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_force_at_rel_pos_191_comment},
  {"add_rel_force_at_pos", (PyCFunction) &Dtool_OdeBody_add_rel_force_at_pos_192, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_rel_force_at_pos_192_comment},
  {"addRelForceAtPos", (PyCFunction) &Dtool_OdeBody_add_rel_force_at_pos_192, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_rel_force_at_pos_192_comment},
  {"add_rel_force_at_rel_pos", (PyCFunction) &Dtool_OdeBody_add_rel_force_at_rel_pos_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_rel_force_at_rel_pos_193_comment},
  {"addRelForceAtRelPos", (PyCFunction) &Dtool_OdeBody_add_rel_force_at_rel_pos_193, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_add_rel_force_at_rel_pos_193_comment},
  {"set_force", (PyCFunction) &Dtool_OdeBody_set_force_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_force_194_comment},
  {"setForce", (PyCFunction) &Dtool_OdeBody_set_force_194, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_force_194_comment},
  {"set_torque", (PyCFunction) &Dtool_OdeBody_set_torque_195, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_torque_195_comment},
  {"setTorque", (PyCFunction) &Dtool_OdeBody_set_torque_195, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_torque_195_comment},
  {"get_rel_point_pos", (PyCFunction) &Dtool_OdeBody_get_rel_point_pos_196, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_get_rel_point_pos_196_comment},
  {"getRelPointPos", (PyCFunction) &Dtool_OdeBody_get_rel_point_pos_196, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_get_rel_point_pos_196_comment},
  {"get_rel_point_vel", (PyCFunction) &Dtool_OdeBody_get_rel_point_vel_197, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_get_rel_point_vel_197_comment},
  {"getRelPointVel", (PyCFunction) &Dtool_OdeBody_get_rel_point_vel_197, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_get_rel_point_vel_197_comment},
  {"get_point_vel", (PyCFunction) &Dtool_OdeBody_get_point_vel_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_get_point_vel_198_comment},
  {"getPointVel", (PyCFunction) &Dtool_OdeBody_get_point_vel_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_get_point_vel_198_comment},
  {"get_pos_rel_point", (PyCFunction) &Dtool_OdeBody_get_pos_rel_point_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_get_pos_rel_point_199_comment},
  {"getPosRelPoint", (PyCFunction) &Dtool_OdeBody_get_pos_rel_point_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_get_pos_rel_point_199_comment},
  {"vector_to_world", (PyCFunction) &Dtool_OdeBody_vector_to_world_200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_vector_to_world_200_comment},
  {"vectorToWorld", (PyCFunction) &Dtool_OdeBody_vector_to_world_200, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_vector_to_world_200_comment},
  {"vector_from_world", (PyCFunction) &Dtool_OdeBody_vector_from_world_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_vector_from_world_201_comment},
  {"vectorFromWorld", (PyCFunction) &Dtool_OdeBody_vector_from_world_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_vector_from_world_201_comment},
  {"set_finite_rotation_mode", &Dtool_OdeBody_set_finite_rotation_mode_202, METH_O, (const char *)Dtool_OdeBody_set_finite_rotation_mode_202_comment},
  {"setFiniteRotationMode", &Dtool_OdeBody_set_finite_rotation_mode_202, METH_O, (const char *)Dtool_OdeBody_set_finite_rotation_mode_202_comment},
  {"set_finite_rotation_axis", (PyCFunction) &Dtool_OdeBody_set_finite_rotation_axis_203, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_finite_rotation_axis_203_comment},
  {"setFiniteRotationAxis", (PyCFunction) &Dtool_OdeBody_set_finite_rotation_axis_203, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_set_finite_rotation_axis_203_comment},
  {"get_finite_rotation_mode", &Dtool_OdeBody_get_finite_rotation_mode_204, METH_NOARGS, (const char *)Dtool_OdeBody_get_finite_rotation_mode_204_comment},
  {"getFiniteRotationMode", &Dtool_OdeBody_get_finite_rotation_mode_204, METH_NOARGS, (const char *)Dtool_OdeBody_get_finite_rotation_mode_204_comment},
  {"get_finite_rotation_axis", &Dtool_OdeBody_get_finite_rotation_axis_205, METH_NOARGS, (const char *)Dtool_OdeBody_get_finite_rotation_axis_205_comment},
  {"getFiniteRotationAxis", &Dtool_OdeBody_get_finite_rotation_axis_205, METH_NOARGS, (const char *)Dtool_OdeBody_get_finite_rotation_axis_205_comment},
  {"get_num_joints", &Dtool_OdeBody_get_num_joints_206, METH_NOARGS, (const char *)Dtool_OdeBody_get_num_joints_206_comment},
  {"getNumJoints", &Dtool_OdeBody_get_num_joints_206, METH_NOARGS, (const char *)Dtool_OdeBody_get_num_joints_206_comment},
  {"get_joint", &Dtool_OdeBody_get_joint_207, METH_O, (const char *)Dtool_OdeBody_get_joint_207_comment},
  {"getJoint", &Dtool_OdeBody_get_joint_207, METH_O, (const char *)Dtool_OdeBody_get_joint_207_comment},
  {"get_converted_joint", &Dtool_OdeBody_get_converted_joint_209, METH_O, (const char *)Dtool_OdeBody_get_converted_joint_209_comment},
  {"getConvertedJoint", &Dtool_OdeBody_get_converted_joint_209, METH_O, (const char *)Dtool_OdeBody_get_converted_joint_209_comment},
  {"enable", &Dtool_OdeBody_enable_214, METH_NOARGS, (const char *)Dtool_OdeBody_enable_214_comment},
  {"disable", &Dtool_OdeBody_disable_215, METH_NOARGS, (const char *)Dtool_OdeBody_disable_215_comment},
  {"is_enabled", &Dtool_OdeBody_is_enabled_216, METH_NOARGS, (const char *)Dtool_OdeBody_is_enabled_216_comment},
  {"isEnabled", &Dtool_OdeBody_is_enabled_216, METH_NOARGS, (const char *)Dtool_OdeBody_is_enabled_216_comment},
  {"set_gravity_mode", &Dtool_OdeBody_set_gravity_mode_217, METH_O, (const char *)Dtool_OdeBody_set_gravity_mode_217_comment},
  {"setGravityMode", &Dtool_OdeBody_set_gravity_mode_217, METH_O, (const char *)Dtool_OdeBody_set_gravity_mode_217_comment},
  {"get_gravity_mode", &Dtool_OdeBody_get_gravity_mode_218, METH_NOARGS, (const char *)Dtool_OdeBody_get_gravity_mode_218_comment},
  {"getGravityMode", &Dtool_OdeBody_get_gravity_mode_218, METH_NOARGS, (const char *)Dtool_OdeBody_get_gravity_mode_218_comment},
  {"write", (PyCFunction) &Dtool_OdeBody_write_219, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBody_write_219_comment},
  {"compare_to", &Dtool_OdeBody_compare_to_221, METH_O, (const char *)Dtool_OdeBody_compare_to_221_comment},
  {"compareTo", &Dtool_OdeBody_compare_to_221, METH_O, (const char *)Dtool_OdeBody_compare_to_221_comment},
  {"get_class_type", &Dtool_OdeBody_get_class_type_222, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeBody_get_class_type_222_comment},
  {"getClassType", &Dtool_OdeBody_get_class_type_222, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeBody_get_class_type_222_comment},
  {"get_joints", (PyCFunction) &MakeSeq_OdeBody_get_joints, METH_NOARGS, nullptr},
  { "getJoints", (PyCFunction) &MakeSeq_OdeBody_get_joints, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeBody slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_OdeBody_operator_typecast_bool_220_nb_bool(PyObject *self) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeBody slot tp_compare -> compare_to
//////////////////
static int Dtool_OdeBody_compare_to_221_tp_compare(PyObject *self, PyObject *arg) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int OdeBody::compare_to(OdeBody const &other) const
  OdeBody const *arg_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeBody, 1, "OdeBody.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const OdeBody*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(OdeBody self, const OdeBody other)\n");
  }
  return -1;
}

//////////////////
//  A __str__ function
//     OdeBody
//////////////////
static PyObject *Dtool_Str_OdeBody(PyObject *self) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     OdeBody
//////////////////
static PyObject *Dtool_RichCompare_OdeBody(PyObject *self, PyObject *arg, int op) {
  OdeBody *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeBody, (void **)&local_this)) {
    return nullptr;
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_OdeBody_compare_to_221_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_OdeBody[] = {
  {(char *)"joints", &Dtool_OdeBody_joints_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_OdeBody = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_OdeBody_operator_typecast_bool_220_nb_bool,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeBody = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeBody = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeBody = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeBody = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeBody = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeBody",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeBody,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeBody,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_OdeBody_compare_to_221_tp_compare,
#endif
    nullptr,
    &Dtool_NumberMethods_OdeBody,
    &Dtool_SequenceMethods_OdeBody,
    &Dtool_MappingMethods_OdeBody,
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_OdeBody,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeBody,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_OdeBody,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeBody,
    nullptr, // tp_members
    Dtool_Properties_OdeBody,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeBody,
    PyType_GenericAlloc,
    Dtool_new_OdeBody,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeBody,
  Dtool_UpcastInterface_OdeBody,
  Dtool_DowncastInterface_OdeBody,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeBody(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != nullptr);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_OdeBody._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    Dtool_OdeBody._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeBody._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeBody) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeBody)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeBody);
  }
}

/**
 * Python method tables for OdeSpace (OdeSpace)
 */
static PyMethodDef Dtool_Methods_OdeSpace[] = {
  {"destroy", &Dtool_OdeSpace_destroy_224, METH_NOARGS, (const char *)Dtool_OdeSpace_destroy_224_comment},
  {"is_empty", &Dtool_OdeSpace_is_empty_225, METH_NOARGS, (const char *)Dtool_OdeSpace_is_empty_225_comment},
  {"isEmpty", &Dtool_OdeSpace_is_empty_225, METH_NOARGS, (const char *)Dtool_OdeSpace_is_empty_225_comment},
  {"set_cleanup", &Dtool_OdeSpace_set_cleanup_226, METH_O, (const char *)Dtool_OdeSpace_set_cleanup_226_comment},
  {"setCleanup", &Dtool_OdeSpace_set_cleanup_226, METH_O, (const char *)Dtool_OdeSpace_set_cleanup_226_comment},
  {"get_cleanup", &Dtool_OdeSpace_get_cleanup_227, METH_NOARGS, (const char *)Dtool_OdeSpace_get_cleanup_227_comment},
  {"getCleanup", &Dtool_OdeSpace_get_cleanup_227, METH_NOARGS, (const char *)Dtool_OdeSpace_get_cleanup_227_comment},
  {"query", &Dtool_OdeSpace_query_228, METH_O, (const char *)Dtool_OdeSpace_query_228_comment},
  {"get_num_geoms", &Dtool_OdeSpace_get_num_geoms_229, METH_NOARGS, (const char *)Dtool_OdeSpace_get_num_geoms_229_comment},
  {"getNumGeoms", &Dtool_OdeSpace_get_num_geoms_229, METH_NOARGS, (const char *)Dtool_OdeSpace_get_num_geoms_229_comment},
  {"get_AABB", (PyCFunction) &Dtool_OdeSpace_get_AABB_230, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSpace_get_AABB_230_comment},
  {"getAABB", (PyCFunction) &Dtool_OdeSpace_get_AABB_230, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSpace_get_AABB_230_comment},
  {"get_AA_bounds", &Dtool_OdeSpace_get_AA_bounds_231, METH_NOARGS, (const char *)Dtool_OdeSpace_get_AA_bounds_231_comment},
  {"getAABounds", &Dtool_OdeSpace_get_AA_bounds_231, METH_NOARGS, (const char *)Dtool_OdeSpace_get_AA_bounds_231_comment},
  {"is_space", &Dtool_OdeSpace_is_space_232, METH_NOARGS, (const char *)Dtool_OdeSpace_is_space_232_comment},
  {"isSpace", &Dtool_OdeSpace_is_space_232, METH_NOARGS, (const char *)Dtool_OdeSpace_is_space_232_comment},
  {"get_class", &Dtool_OdeSpace_get_class_233, METH_NOARGS, (const char *)Dtool_OdeSpace_get_class_233_comment},
  {"getClass", &Dtool_OdeSpace_get_class_233, METH_NOARGS, (const char *)Dtool_OdeSpace_get_class_233_comment},
  {"set_category_bits", &Dtool_OdeSpace_set_category_bits_234, METH_O, (const char *)Dtool_OdeSpace_set_category_bits_234_comment},
  {"setCategoryBits", &Dtool_OdeSpace_set_category_bits_234, METH_O, (const char *)Dtool_OdeSpace_set_category_bits_234_comment},
  {"set_collide_bits", &Dtool_OdeSpace_set_collide_bits_235, METH_O, (const char *)Dtool_OdeSpace_set_collide_bits_235_comment},
  {"setCollideBits", &Dtool_OdeSpace_set_collide_bits_235, METH_O, (const char *)Dtool_OdeSpace_set_collide_bits_235_comment},
  {"get_category_bits", &Dtool_OdeSpace_get_category_bits_236, METH_NOARGS, (const char *)Dtool_OdeSpace_get_category_bits_236_comment},
  {"getCategoryBits", &Dtool_OdeSpace_get_category_bits_236, METH_NOARGS, (const char *)Dtool_OdeSpace_get_category_bits_236_comment},
  {"get_collide_bits", &Dtool_OdeSpace_get_collide_bits_237, METH_NOARGS, (const char *)Dtool_OdeSpace_get_collide_bits_237_comment},
  {"getCollideBits", &Dtool_OdeSpace_get_collide_bits_237, METH_NOARGS, (const char *)Dtool_OdeSpace_get_collide_bits_237_comment},
  {"enable", &Dtool_OdeSpace_enable_238, METH_NOARGS, (const char *)Dtool_OdeSpace_enable_238_comment},
  {"disable", &Dtool_OdeSpace_disable_239, METH_NOARGS, (const char *)Dtool_OdeSpace_disable_239_comment},
  {"is_enabled", &Dtool_OdeSpace_is_enabled_240, METH_NOARGS, (const char *)Dtool_OdeSpace_is_enabled_240_comment},
  {"isEnabled", &Dtool_OdeSpace_is_enabled_240, METH_NOARGS, (const char *)Dtool_OdeSpace_is_enabled_240_comment},
  {"set_auto_collide_world", &Dtool_OdeSpace_set_auto_collide_world_241, METH_O, (const char *)Dtool_OdeSpace_set_auto_collide_world_241_comment},
  {"setAutoCollideWorld", &Dtool_OdeSpace_set_auto_collide_world_241, METH_O, (const char *)Dtool_OdeSpace_set_auto_collide_world_241_comment},
  {"set_auto_collide_joint_group", &Dtool_OdeSpace_set_auto_collide_joint_group_242, METH_O, (const char *)Dtool_OdeSpace_set_auto_collide_joint_group_242_comment},
  {"setAutoCollideJointGroup", &Dtool_OdeSpace_set_auto_collide_joint_group_242, METH_O, (const char *)Dtool_OdeSpace_set_auto_collide_joint_group_242_comment},
  {"add", &Dtool_OdeSpace_add_243, METH_O, (const char *)Dtool_OdeSpace_add_243_comment},
  {"remove", &Dtool_OdeSpace_remove_244, METH_O, (const char *)Dtool_OdeSpace_remove_244_comment},
  {"clean", &Dtool_OdeSpace_clean_245, METH_NOARGS, (const char *)Dtool_OdeSpace_clean_245_comment},
  {"get_geom", &Dtool_OdeSpace_get_geom_246, METH_O, (const char *)Dtool_OdeSpace_get_geom_246_comment},
  {"getGeom", &Dtool_OdeSpace_get_geom_246, METH_O, (const char *)Dtool_OdeSpace_get_geom_246_comment},
  {"get_space", &Dtool_OdeSpace_get_space_247, METH_NOARGS, (const char *)Dtool_OdeSpace_get_space_247_comment},
  {"getSpace", &Dtool_OdeSpace_get_space_247, METH_NOARGS, (const char *)Dtool_OdeSpace_get_space_247_comment},
  {"write", (PyCFunction) &Dtool_OdeSpace_write_248, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSpace_write_248_comment},
  {"convert_to_simple_space", &Dtool_OdeSpace_convert_to_simple_space_250, METH_NOARGS, (const char *)Dtool_OdeSpace_convert_to_simple_space_250_comment},
  {"convertToSimpleSpace", &Dtool_OdeSpace_convert_to_simple_space_250, METH_NOARGS, (const char *)Dtool_OdeSpace_convert_to_simple_space_250_comment},
  {"convert_to_hash_space", &Dtool_OdeSpace_convert_to_hash_space_251, METH_NOARGS, (const char *)Dtool_OdeSpace_convert_to_hash_space_251_comment},
  {"convertToHashSpace", &Dtool_OdeSpace_convert_to_hash_space_251, METH_NOARGS, (const char *)Dtool_OdeSpace_convert_to_hash_space_251_comment},
  {"convert_to_quad_tree_space", &Dtool_OdeSpace_convert_to_quad_tree_space_252, METH_NOARGS, (const char *)Dtool_OdeSpace_convert_to_quad_tree_space_252_comment},
  {"convertToQuadTreeSpace", &Dtool_OdeSpace_convert_to_quad_tree_space_252, METH_NOARGS, (const char *)Dtool_OdeSpace_convert_to_quad_tree_space_252_comment},
  {"convert", &Dtool_OdeSpace_convert_253, METH_NOARGS, (const char *)Dtool_OdeSpace_convert_253_comment},
  {"get_converted_geom", &Dtool_OdeSpace_get_converted_geom_254, METH_O, (const char *)Dtool_OdeSpace_get_converted_geom_254_comment},
  {"getConvertedGeom", &Dtool_OdeSpace_get_converted_geom_254, METH_O, (const char *)Dtool_OdeSpace_get_converted_geom_254_comment},
  {"get_converted_space", &Dtool_OdeSpace_get_converted_space_255, METH_NOARGS, (const char *)Dtool_OdeSpace_get_converted_space_255_comment},
  {"getConvertedSpace", &Dtool_OdeSpace_get_converted_space_255, METH_NOARGS, (const char *)Dtool_OdeSpace_get_converted_space_255_comment},
  {"auto_collide", &Dtool_OdeSpace_auto_collide_256, METH_NOARGS, (const char *)Dtool_OdeSpace_auto_collide_256_comment},
  {"autoCollide", &Dtool_OdeSpace_auto_collide_256, METH_NOARGS, (const char *)Dtool_OdeSpace_auto_collide_256_comment},
  {"collide", (PyCFunction) &Dtool_OdeSpace_collide_257, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSpace_collide_257_comment},
  {"set_collide_id", (PyCFunction) &Dtool_OdeSpace_set_collide_id_258, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSpace_set_collide_id_258_comment},
  {"setCollideId", (PyCFunction) &Dtool_OdeSpace_set_collide_id_258, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSpace_set_collide_id_258_comment},
  {"set_surface_type", (PyCFunction) &Dtool_OdeSpace_set_surface_type_259, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSpace_set_surface_type_259_comment},
  {"setSurfaceType", (PyCFunction) &Dtool_OdeSpace_set_surface_type_259, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSpace_set_surface_type_259_comment},
  {"get_surface_type", &Dtool_OdeSpace_get_surface_type_260, METH_O, (const char *)Dtool_OdeSpace_get_surface_type_260_comment},
  {"getSurfaceType", &Dtool_OdeSpace_get_surface_type_260, METH_O, (const char *)Dtool_OdeSpace_get_surface_type_260_comment},
  {"get_collide_id", &Dtool_OdeSpace_get_collide_id_261, METH_O, (const char *)Dtool_OdeSpace_get_collide_id_261_comment},
  {"getCollideId", &Dtool_OdeSpace_get_collide_id_261, METH_O, (const char *)Dtool_OdeSpace_get_collide_id_261_comment},
  {"set_collision_event", &Dtool_OdeSpace_set_collision_event_262, METH_O, (const char *)Dtool_OdeSpace_set_collision_event_262_comment},
  {"setCollisionEvent", &Dtool_OdeSpace_set_collision_event_262, METH_O, (const char *)Dtool_OdeSpace_set_collision_event_262_comment},
  {"get_collision_event", &Dtool_OdeSpace_get_collision_event_263, METH_NOARGS, (const char *)Dtool_OdeSpace_get_collision_event_263_comment},
  {"getCollisionEvent", &Dtool_OdeSpace_get_collision_event_263, METH_NOARGS, (const char *)Dtool_OdeSpace_get_collision_event_263_comment},
  {"get_class_type", &Dtool_OdeSpace_get_class_type_264, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSpace_get_class_type_264_comment},
  {"getClassType", &Dtool_OdeSpace_get_class_type_264, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSpace_get_class_type_264_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeSpace slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_OdeSpace_operator_typecast_bool_249_nb_bool(PyObject *self) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
//  A __str__ function
//     OdeSpace
//////////////////
static PyObject *Dtool_Str_OdeSpace(PyObject *self) {
  OdeSpace *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeSpace, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_OdeSpace = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_OdeSpace_operator_typecast_bool_249_nb_bool,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeSpace = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeSpace = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeSpace = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeSpace = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeSpace = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeSpace",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeSpace,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeSpace,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeSpace,
    &Dtool_SequenceMethods_OdeSpace,
    &Dtool_MappingMethods_OdeSpace,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_OdeSpace,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeSpace,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeSpace,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeSpace,
    PyType_GenericAlloc,
    Dtool_new_OdeSpace,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeSpace,
  Dtool_UpcastInterface_OdeSpace,
  Dtool_DowncastInterface_OdeSpace,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeSpace(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != nullptr);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_OdeSpace._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    Dtool_OdeSpace._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeSpace._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeSpace) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeSpace)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeSpace);
  }
}

/**
 * Python method tables for OdeGeom (OdeGeom)
 */
static PyMethodDef Dtool_Methods_OdeGeom[] = {
  {"destroy", &Dtool_OdeGeom_destroy_267, METH_NOARGS, (const char *)Dtool_OdeGeom_destroy_267_comment},
  {"is_empty", &Dtool_OdeGeom_is_empty_268, METH_NOARGS, (const char *)Dtool_OdeGeom_is_empty_268_comment},
  {"isEmpty", &Dtool_OdeGeom_is_empty_268, METH_NOARGS, (const char *)Dtool_OdeGeom_is_empty_268_comment},
  {"get_id", &Dtool_OdeGeom_get_id_269, METH_NOARGS, (const char *)Dtool_OdeGeom_get_id_269_comment},
  {"getId", &Dtool_OdeGeom_get_id_269, METH_NOARGS, (const char *)Dtool_OdeGeom_get_id_269_comment},
  {"set_body", &Dtool_OdeGeom_set_body_270, METH_O, (const char *)Dtool_OdeGeom_set_body_270_comment},
  {"setBody", &Dtool_OdeGeom_set_body_270, METH_O, (const char *)Dtool_OdeGeom_set_body_270_comment},
  {"has_body", &Dtool_OdeGeom_has_body_271, METH_NOARGS, (const char *)Dtool_OdeGeom_has_body_271_comment},
  {"hasBody", &Dtool_OdeGeom_has_body_271, METH_NOARGS, (const char *)Dtool_OdeGeom_has_body_271_comment},
  {"get_body", &Dtool_OdeGeom_get_body_272, METH_NOARGS, (const char *)Dtool_OdeGeom_get_body_272_comment},
  {"getBody", &Dtool_OdeGeom_get_body_272, METH_NOARGS, (const char *)Dtool_OdeGeom_get_body_272_comment},
  {"set_position", (PyCFunction) &Dtool_OdeGeom_set_position_273, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_set_position_273_comment},
  {"setPosition", (PyCFunction) &Dtool_OdeGeom_set_position_273, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_set_position_273_comment},
  {"set_rotation", &Dtool_OdeGeom_set_rotation_274, METH_O, (const char *)Dtool_OdeGeom_set_rotation_274_comment},
  {"setRotation", &Dtool_OdeGeom_set_rotation_274, METH_O, (const char *)Dtool_OdeGeom_set_rotation_274_comment},
  {"set_quaternion", &Dtool_OdeGeom_set_quaternion_275, METH_O, (const char *)Dtool_OdeGeom_set_quaternion_275_comment},
  {"setQuaternion", &Dtool_OdeGeom_set_quaternion_275, METH_O, (const char *)Dtool_OdeGeom_set_quaternion_275_comment},
  {"get_position", &Dtool_OdeGeom_get_position_276, METH_NOARGS, (const char *)Dtool_OdeGeom_get_position_276_comment},
  {"getPosition", &Dtool_OdeGeom_get_position_276, METH_NOARGS, (const char *)Dtool_OdeGeom_get_position_276_comment},
  {"get_rotation", &Dtool_OdeGeom_get_rotation_277, METH_NOARGS, (const char *)Dtool_OdeGeom_get_rotation_277_comment},
  {"getRotation", &Dtool_OdeGeom_get_rotation_277, METH_NOARGS, (const char *)Dtool_OdeGeom_get_rotation_277_comment},
  {"get_quaternion", &Dtool_OdeGeom_get_quaternion_278, METH_NOARGS, (const char *)Dtool_OdeGeom_get_quaternion_278_comment},
  {"getQuaternion", &Dtool_OdeGeom_get_quaternion_278, METH_NOARGS, (const char *)Dtool_OdeGeom_get_quaternion_278_comment},
  {"get_AABB", (PyCFunction) &Dtool_OdeGeom_get_AABB_279, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_get_AABB_279_comment},
  {"getAABB", (PyCFunction) &Dtool_OdeGeom_get_AABB_279, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_get_AABB_279_comment},
  {"get_AA_bounds", &Dtool_OdeGeom_get_AA_bounds_280, METH_NOARGS, (const char *)Dtool_OdeGeom_get_AA_bounds_280_comment},
  {"getAABounds", &Dtool_OdeGeom_get_AA_bounds_280, METH_NOARGS, (const char *)Dtool_OdeGeom_get_AA_bounds_280_comment},
  {"is_space", &Dtool_OdeGeom_is_space_281, METH_NOARGS, (const char *)Dtool_OdeGeom_is_space_281_comment},
  {"isSpace", &Dtool_OdeGeom_is_space_281, METH_NOARGS, (const char *)Dtool_OdeGeom_is_space_281_comment},
  {"get_class", &Dtool_OdeGeom_get_class_282, METH_NOARGS, (const char *)Dtool_OdeGeom_get_class_282_comment},
  {"getClass", &Dtool_OdeGeom_get_class_282, METH_NOARGS, (const char *)Dtool_OdeGeom_get_class_282_comment},
  {"set_category_bits", &Dtool_OdeGeom_set_category_bits_283, METH_O, (const char *)Dtool_OdeGeom_set_category_bits_283_comment},
  {"setCategoryBits", &Dtool_OdeGeom_set_category_bits_283, METH_O, (const char *)Dtool_OdeGeom_set_category_bits_283_comment},
  {"set_collide_bits", &Dtool_OdeGeom_set_collide_bits_284, METH_O, (const char *)Dtool_OdeGeom_set_collide_bits_284_comment},
  {"setCollideBits", &Dtool_OdeGeom_set_collide_bits_284, METH_O, (const char *)Dtool_OdeGeom_set_collide_bits_284_comment},
  {"get_category_bits", &Dtool_OdeGeom_get_category_bits_285, METH_NOARGS, (const char *)Dtool_OdeGeom_get_category_bits_285_comment},
  {"getCategoryBits", &Dtool_OdeGeom_get_category_bits_285, METH_NOARGS, (const char *)Dtool_OdeGeom_get_category_bits_285_comment},
  {"get_collide_bits", &Dtool_OdeGeom_get_collide_bits_286, METH_NOARGS, (const char *)Dtool_OdeGeom_get_collide_bits_286_comment},
  {"getCollideBits", &Dtool_OdeGeom_get_collide_bits_286, METH_NOARGS, (const char *)Dtool_OdeGeom_get_collide_bits_286_comment},
  {"enable", &Dtool_OdeGeom_enable_287, METH_NOARGS, (const char *)Dtool_OdeGeom_enable_287_comment},
  {"disable", &Dtool_OdeGeom_disable_288, METH_NOARGS, (const char *)Dtool_OdeGeom_disable_288_comment},
  {"is_enabled", &Dtool_OdeGeom_is_enabled_289, METH_NOARGS, (const char *)Dtool_OdeGeom_is_enabled_289_comment},
  {"isEnabled", &Dtool_OdeGeom_is_enabled_289, METH_NOARGS, (const char *)Dtool_OdeGeom_is_enabled_289_comment},
  {"set_offset_position", (PyCFunction) &Dtool_OdeGeom_set_offset_position_290, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_set_offset_position_290_comment},
  {"setOffsetPosition", (PyCFunction) &Dtool_OdeGeom_set_offset_position_290, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_set_offset_position_290_comment},
  {"set_offset_rotation", &Dtool_OdeGeom_set_offset_rotation_291, METH_O, (const char *)Dtool_OdeGeom_set_offset_rotation_291_comment},
  {"setOffsetRotation", &Dtool_OdeGeom_set_offset_rotation_291, METH_O, (const char *)Dtool_OdeGeom_set_offset_rotation_291_comment},
  {"set_offset_quaternion", &Dtool_OdeGeom_set_offset_quaternion_292, METH_O, (const char *)Dtool_OdeGeom_set_offset_quaternion_292_comment},
  {"setOffsetQuaternion", &Dtool_OdeGeom_set_offset_quaternion_292, METH_O, (const char *)Dtool_OdeGeom_set_offset_quaternion_292_comment},
  {"set_offset_world_position", (PyCFunction) &Dtool_OdeGeom_set_offset_world_position_293, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_set_offset_world_position_293_comment},
  {"setOffsetWorldPosition", (PyCFunction) &Dtool_OdeGeom_set_offset_world_position_293, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_set_offset_world_position_293_comment},
  {"set_offset_world_rotation", &Dtool_OdeGeom_set_offset_world_rotation_294, METH_O, (const char *)Dtool_OdeGeom_set_offset_world_rotation_294_comment},
  {"setOffsetWorldRotation", &Dtool_OdeGeom_set_offset_world_rotation_294, METH_O, (const char *)Dtool_OdeGeom_set_offset_world_rotation_294_comment},
  {"set_offset_world_quaternion", &Dtool_OdeGeom_set_offset_world_quaternion_295, METH_O, (const char *)Dtool_OdeGeom_set_offset_world_quaternion_295_comment},
  {"setOffsetWorldQuaternion", &Dtool_OdeGeom_set_offset_world_quaternion_295, METH_O, (const char *)Dtool_OdeGeom_set_offset_world_quaternion_295_comment},
  {"clear_offset", &Dtool_OdeGeom_clear_offset_296, METH_NOARGS, (const char *)Dtool_OdeGeom_clear_offset_296_comment},
  {"clearOffset", &Dtool_OdeGeom_clear_offset_296, METH_NOARGS, (const char *)Dtool_OdeGeom_clear_offset_296_comment},
  {"is_offset", &Dtool_OdeGeom_is_offset_297, METH_NOARGS, (const char *)Dtool_OdeGeom_is_offset_297_comment},
  {"isOffset", &Dtool_OdeGeom_is_offset_297, METH_NOARGS, (const char *)Dtool_OdeGeom_is_offset_297_comment},
  {"get_offset_position", &Dtool_OdeGeom_get_offset_position_298, METH_NOARGS, (const char *)Dtool_OdeGeom_get_offset_position_298_comment},
  {"getOffsetPosition", &Dtool_OdeGeom_get_offset_position_298, METH_NOARGS, (const char *)Dtool_OdeGeom_get_offset_position_298_comment},
  {"get_offset_rotation", &Dtool_OdeGeom_get_offset_rotation_299, METH_NOARGS, (const char *)Dtool_OdeGeom_get_offset_rotation_299_comment},
  {"getOffsetRotation", &Dtool_OdeGeom_get_offset_rotation_299, METH_NOARGS, (const char *)Dtool_OdeGeom_get_offset_rotation_299_comment},
  {"get_offset_quaternion", &Dtool_OdeGeom_get_offset_quaternion_300, METH_NOARGS, (const char *)Dtool_OdeGeom_get_offset_quaternion_300_comment},
  {"getOffsetQuaternion", &Dtool_OdeGeom_get_offset_quaternion_300, METH_NOARGS, (const char *)Dtool_OdeGeom_get_offset_quaternion_300_comment},
  {"get_space", &Dtool_OdeGeom_get_space_301, METH_NOARGS, (const char *)Dtool_OdeGeom_get_space_301_comment},
  {"getSpace", &Dtool_OdeGeom_get_space_301, METH_NOARGS, (const char *)Dtool_OdeGeom_get_space_301_comment},
  {"get_converted_space", &Dtool_OdeGeom_get_converted_space_302, METH_NOARGS, (const char *)Dtool_OdeGeom_get_converted_space_302_comment},
  {"getConvertedSpace", &Dtool_OdeGeom_get_converted_space_302, METH_NOARGS, (const char *)Dtool_OdeGeom_get_converted_space_302_comment},
  {"write", (PyCFunction) &Dtool_OdeGeom_write_303, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeGeom_write_303_comment},
  {"compare_to", &Dtool_OdeGeom_compare_to_305, METH_O, (const char *)Dtool_OdeGeom_compare_to_305_comment},
  {"compareTo", &Dtool_OdeGeom_compare_to_305, METH_O, (const char *)Dtool_OdeGeom_compare_to_305_comment},
  {"convert", &Dtool_OdeGeom_convert_306, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_306_comment},
  {"convert_to_box", &Dtool_OdeGeom_convert_to_box_307, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_box_307_comment},
  {"convertToBox", &Dtool_OdeGeom_convert_to_box_307, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_box_307_comment},
  {"convert_to_capped_cylinder", &Dtool_OdeGeom_convert_to_capped_cylinder_308, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_capped_cylinder_308_comment},
  {"convertToCappedCylinder", &Dtool_OdeGeom_convert_to_capped_cylinder_308, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_capped_cylinder_308_comment},
  {"convert_to_cylinder", &Dtool_OdeGeom_convert_to_cylinder_309, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_cylinder_309_comment},
  {"convertToCylinder", &Dtool_OdeGeom_convert_to_cylinder_309, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_cylinder_309_comment},
  {"convert_to_plane", &Dtool_OdeGeom_convert_to_plane_310, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_plane_310_comment},
  {"convertToPlane", &Dtool_OdeGeom_convert_to_plane_310, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_plane_310_comment},
  {"convert_to_ray", &Dtool_OdeGeom_convert_to_ray_311, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_ray_311_comment},
  {"convertToRay", &Dtool_OdeGeom_convert_to_ray_311, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_ray_311_comment},
  {"convert_to_sphere", &Dtool_OdeGeom_convert_to_sphere_312, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_sphere_312_comment},
  {"convertToSphere", &Dtool_OdeGeom_convert_to_sphere_312, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_sphere_312_comment},
  {"convert_to_tri_mesh", &Dtool_OdeGeom_convert_to_tri_mesh_313, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_tri_mesh_313_comment},
  {"convertToTriMesh", &Dtool_OdeGeom_convert_to_tri_mesh_313, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_tri_mesh_313_comment},
  {"convert_to_simple_space", &Dtool_OdeGeom_convert_to_simple_space_314, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_simple_space_314_comment},
  {"convertToSimpleSpace", &Dtool_OdeGeom_convert_to_simple_space_314, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_simple_space_314_comment},
  {"convert_to_hash_space", &Dtool_OdeGeom_convert_to_hash_space_315, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_hash_space_315_comment},
  {"convertToHashSpace", &Dtool_OdeGeom_convert_to_hash_space_315, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_hash_space_315_comment},
  {"convert_to_quad_tree_space", &Dtool_OdeGeom_convert_to_quad_tree_space_316, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_quad_tree_space_316_comment},
  {"convertToQuadTreeSpace", &Dtool_OdeGeom_convert_to_quad_tree_space_316, METH_NOARGS, (const char *)Dtool_OdeGeom_convert_to_quad_tree_space_316_comment},
  {"get_class_type", &Dtool_OdeGeom_get_class_type_317, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeGeom_get_class_type_317_comment},
  {"getClassType", &Dtool_OdeGeom_get_class_type_317, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeGeom_get_class_type_317_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeGeom slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_OdeGeom_operator_typecast_bool_304_nb_bool(PyObject *self) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeGeom slot tp_compare -> compare_to
//////////////////
static int Dtool_OdeGeom_compare_to_305_tp_compare(PyObject *self, PyObject *arg) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int OdeGeom::compare_to(OdeGeom const &other) const
  OdeGeom const *arg_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeGeom, 1, "OdeGeom.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const OdeGeom*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(OdeGeom self, const OdeGeom other)\n");
  }
  return -1;
}

//////////////////
//  A __str__ function
//     OdeGeom
//////////////////
static PyObject *Dtool_Str_OdeGeom(PyObject *self) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     OdeGeom
//////////////////
static PyObject *Dtool_RichCompare_OdeGeom(PyObject *self, PyObject *arg, int op) {
  OdeGeom *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeGeom, (void **)&local_this)) {
    return nullptr;
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_OdeGeom_compare_to_305_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_OdeGeom = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_OdeGeom_operator_typecast_bool_304_nb_bool,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeGeom = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeGeom = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeGeom = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeGeom = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeGeom = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeGeom",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeGeom,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeGeom,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_OdeGeom_compare_to_305_tp_compare,
#endif
    nullptr,
    &Dtool_NumberMethods_OdeGeom,
    &Dtool_SequenceMethods_OdeGeom,
    &Dtool_MappingMethods_OdeGeom,
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_OdeGeom,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_OdeGeom,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeGeom,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeGeom,
    PyType_GenericAlloc,
    Dtool_new_OdeGeom,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeGeom,
  Dtool_UpcastInterface_OdeGeom,
  Dtool_DowncastInterface_OdeGeom,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != nullptr);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_OdeGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    Dtool_OdeGeom._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(21);
    Dtool_OdeGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum OdeGeom::GeomClass;
    PyDict_SetItemString(dict, "GC_sphere", Dtool_WrapValue(OdeGeom::GC_sphere));
    PyDict_SetItemString(dict, "GCSphere", Dtool_WrapValue(OdeGeom::GC_sphere));
    PyDict_SetItemString(dict, "GC_box", Dtool_WrapValue(OdeGeom::GC_box));
    PyDict_SetItemString(dict, "GCBox", Dtool_WrapValue(OdeGeom::GC_box));
    PyDict_SetItemString(dict, "GC_capped_cylinder", Dtool_WrapValue(OdeGeom::GC_capped_cylinder));
    PyDict_SetItemString(dict, "GCCappedCylinder", Dtool_WrapValue(OdeGeom::GC_capped_cylinder));
    PyDict_SetItemString(dict, "GC_cylinder", Dtool_WrapValue(OdeGeom::GC_cylinder));
    PyDict_SetItemString(dict, "GCCylinder", Dtool_WrapValue(OdeGeom::GC_cylinder));
    PyDict_SetItemString(dict, "GC_plane", Dtool_WrapValue(OdeGeom::GC_plane));
    PyDict_SetItemString(dict, "GCPlane", Dtool_WrapValue(OdeGeom::GC_plane));
    PyDict_SetItemString(dict, "GC_ray", Dtool_WrapValue(OdeGeom::GC_ray));
    PyDict_SetItemString(dict, "GCRay", Dtool_WrapValue(OdeGeom::GC_ray));
    PyDict_SetItemString(dict, "GC_tri_mesh", Dtool_WrapValue(OdeGeom::GC_tri_mesh));
    PyDict_SetItemString(dict, "GCTriMesh", Dtool_WrapValue(OdeGeom::GC_tri_mesh));
    PyDict_SetItemString(dict, "GC_simple_space", Dtool_WrapValue(OdeGeom::GC_simple_space));
    PyDict_SetItemString(dict, "GCSimpleSpace", Dtool_WrapValue(OdeGeom::GC_simple_space));
    PyDict_SetItemString(dict, "GC_hash_space", Dtool_WrapValue(OdeGeom::GC_hash_space));
    PyDict_SetItemString(dict, "GCHashSpace", Dtool_WrapValue(OdeGeom::GC_hash_space));
    PyDict_SetItemString(dict, "GC_quad_tree_space", Dtool_WrapValue(OdeGeom::GC_quad_tree_space));
    PyDict_SetItemString(dict, "GCQuadTreeSpace", Dtool_WrapValue(OdeGeom::GC_quad_tree_space));
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeGeom);
  }
}

/**
 * Python method tables for OdeBoxGeom (OdeBoxGeom)
 */
static PyMethodDef Dtool_Methods_OdeBoxGeom[] = {
  {"set_lengths", (PyCFunction) &Dtool_OdeBoxGeom_set_lengths_320, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBoxGeom_set_lengths_320_comment},
  {"setLengths", (PyCFunction) &Dtool_OdeBoxGeom_set_lengths_320, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBoxGeom_set_lengths_320_comment},
  {"get_lengths", &Dtool_OdeBoxGeom_get_lengths_321, METH_NOARGS, (const char *)Dtool_OdeBoxGeom_get_lengths_321_comment},
  {"getLengths", &Dtool_OdeBoxGeom_get_lengths_321, METH_NOARGS, (const char *)Dtool_OdeBoxGeom_get_lengths_321_comment},
  {"get_point_depth", (PyCFunction) &Dtool_OdeBoxGeom_get_point_depth_322, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBoxGeom_get_point_depth_322_comment},
  {"getPointDepth", (PyCFunction) &Dtool_OdeBoxGeom_get_point_depth_322, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeBoxGeom_get_point_depth_322_comment},
  {"get_class_type", &Dtool_OdeBoxGeom_get_class_type_323, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeBoxGeom_get_class_type_323_comment},
  {"getClassType", &Dtool_OdeBoxGeom_get_class_type_323, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeBoxGeom_get_class_type_323_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeBoxGeom = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeBoxGeom = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeBoxGeom = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeBoxGeom = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeBoxGeom = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeBoxGeom = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeBoxGeom",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeBoxGeom,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeBoxGeom,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeBoxGeom,
    &Dtool_SequenceMethods_OdeBoxGeom,
    &Dtool_MappingMethods_OdeBoxGeom,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeBoxGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeBoxGeom,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeBoxGeom,
    PyType_GenericAlloc,
    Dtool_new_OdeBoxGeom,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeBoxGeom,
  Dtool_UpcastInterface_OdeBoxGeom,
  Dtool_DowncastInterface_OdeBoxGeom,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeBoxGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeGeom(nullptr);
    Dtool_OdeBoxGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeGeom);
    Dtool_OdeBoxGeom._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeBoxGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeBoxGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeBoxGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeBoxGeom);
  }
}

/**
 * Python method tables for OdeCappedCylinderGeom (OdeCappedCylinderGeom)
 */
static PyMethodDef Dtool_Methods_OdeCappedCylinderGeom[] = {
  {"set_params", (PyCFunction) &Dtool_OdeCappedCylinderGeom_set_params_326, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeCappedCylinderGeom_set_params_326_comment},
  {"setParams", (PyCFunction) &Dtool_OdeCappedCylinderGeom_set_params_326, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeCappedCylinderGeom_set_params_326_comment},
  {"get_radius", &Dtool_OdeCappedCylinderGeom_get_radius_328, METH_NOARGS, (const char *)Dtool_OdeCappedCylinderGeom_get_radius_328_comment},
  {"getRadius", &Dtool_OdeCappedCylinderGeom_get_radius_328, METH_NOARGS, (const char *)Dtool_OdeCappedCylinderGeom_get_radius_328_comment},
  {"get_length", &Dtool_OdeCappedCylinderGeom_get_length_329, METH_NOARGS, (const char *)Dtool_OdeCappedCylinderGeom_get_length_329_comment},
  {"getLength", &Dtool_OdeCappedCylinderGeom_get_length_329, METH_NOARGS, (const char *)Dtool_OdeCappedCylinderGeom_get_length_329_comment},
  {"get_point_depth", (PyCFunction) &Dtool_OdeCappedCylinderGeom_get_point_depth_330, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeCappedCylinderGeom_get_point_depth_330_comment},
  {"getPointDepth", (PyCFunction) &Dtool_OdeCappedCylinderGeom_get_point_depth_330, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeCappedCylinderGeom_get_point_depth_330_comment},
  {"get_class_type", &Dtool_OdeCappedCylinderGeom_get_class_type_331, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeCappedCylinderGeom_get_class_type_331_comment},
  {"getClassType", &Dtool_OdeCappedCylinderGeom_get_class_type_331, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeCappedCylinderGeom_get_class_type_331_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeCappedCylinderGeom = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeCappedCylinderGeom = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeCappedCylinderGeom = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeCappedCylinderGeom = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeCappedCylinderGeom = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeCappedCylinderGeom = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeCappedCylinderGeom",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeCappedCylinderGeom,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeCappedCylinderGeom,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeCappedCylinderGeom,
    &Dtool_SequenceMethods_OdeCappedCylinderGeom,
    &Dtool_MappingMethods_OdeCappedCylinderGeom,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeCappedCylinderGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeCappedCylinderGeom,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeCappedCylinderGeom,
    PyType_GenericAlloc,
    Dtool_new_OdeCappedCylinderGeom,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeCappedCylinderGeom,
  Dtool_UpcastInterface_OdeCappedCylinderGeom,
  Dtool_DowncastInterface_OdeCappedCylinderGeom,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeCappedCylinderGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeGeom(nullptr);
    Dtool_OdeCappedCylinderGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeGeom);
    Dtool_OdeCappedCylinderGeom._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeCappedCylinderGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeCappedCylinderGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeCappedCylinderGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeCappedCylinderGeom);
  }
}

/**
 * Python method tables for OdeContactGeom (OdeContactGeom)
 */
static PyMethodDef Dtool_Methods_OdeContactGeom[] = {
  {"get_pos", &Dtool_OdeContactGeom_get_pos_334, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_pos_334_comment},
  {"getPos", &Dtool_OdeContactGeom_get_pos_334, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_pos_334_comment},
  {"get_normal", &Dtool_OdeContactGeom_get_normal_335, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_normal_335_comment},
  {"getNormal", &Dtool_OdeContactGeom_get_normal_335, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_normal_335_comment},
  {"get_depth", &Dtool_OdeContactGeom_get_depth_336, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_depth_336_comment},
  {"getDepth", &Dtool_OdeContactGeom_get_depth_336, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_depth_336_comment},
  {"get_g1", &Dtool_OdeContactGeom_get_g1_337, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_g1_337_comment},
  {"getG1", &Dtool_OdeContactGeom_get_g1_337, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_g1_337_comment},
  {"get_g2", &Dtool_OdeContactGeom_get_g2_338, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_g2_338_comment},
  {"getG2", &Dtool_OdeContactGeom_get_g2_338, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_g2_338_comment},
  {"get_side1", &Dtool_OdeContactGeom_get_side1_339, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_side1_339_comment},
  {"getSide1", &Dtool_OdeContactGeom_get_side1_339, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_side1_339_comment},
  {"get_side2", &Dtool_OdeContactGeom_get_side2_340, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_side2_340_comment},
  {"getSide2", &Dtool_OdeContactGeom_get_side2_340, METH_NOARGS, (const char *)Dtool_OdeContactGeom_get_side2_340_comment},
  {"set_pos", &Dtool_OdeContactGeom_set_pos_341, METH_O, (const char *)Dtool_OdeContactGeom_set_pos_341_comment},
  {"setPos", &Dtool_OdeContactGeom_set_pos_341, METH_O, (const char *)Dtool_OdeContactGeom_set_pos_341_comment},
  {"set_normal", &Dtool_OdeContactGeom_set_normal_342, METH_O, (const char *)Dtool_OdeContactGeom_set_normal_342_comment},
  {"setNormal", &Dtool_OdeContactGeom_set_normal_342, METH_O, (const char *)Dtool_OdeContactGeom_set_normal_342_comment},
  {"set_depth", &Dtool_OdeContactGeom_set_depth_343, METH_O, (const char *)Dtool_OdeContactGeom_set_depth_343_comment},
  {"setDepth", &Dtool_OdeContactGeom_set_depth_343, METH_O, (const char *)Dtool_OdeContactGeom_set_depth_343_comment},
  {"set_g1", &Dtool_OdeContactGeom_set_g1_344, METH_O, (const char *)Dtool_OdeContactGeom_set_g1_344_comment},
  {"setG1", &Dtool_OdeContactGeom_set_g1_344, METH_O, (const char *)Dtool_OdeContactGeom_set_g1_344_comment},
  {"set_g2", &Dtool_OdeContactGeom_set_g2_345, METH_O, (const char *)Dtool_OdeContactGeom_set_g2_345_comment},
  {"setG2", &Dtool_OdeContactGeom_set_g2_345, METH_O, (const char *)Dtool_OdeContactGeom_set_g2_345_comment},
  {"get_class_type", &Dtool_OdeContactGeom_get_class_type_346, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeContactGeom_get_class_type_346_comment},
  {"getClassType", &Dtool_OdeContactGeom_get_class_type_346, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeContactGeom_get_class_type_346_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeContactGeom = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeContactGeom = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeContactGeom = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeContactGeom = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeContactGeom = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeContactGeom = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeContactGeom",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeContactGeom,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeContactGeom,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeContactGeom,
    &Dtool_SequenceMethods_OdeContactGeom,
    &Dtool_MappingMethods_OdeContactGeom,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeContactGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeContactGeom,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeContactGeom,
    PyType_GenericAlloc,
    Dtool_new_OdeContactGeom,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeContactGeom,
  Dtool_UpcastInterface_OdeContactGeom,
  Dtool_DowncastInterface_OdeContactGeom,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeContactGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_OdeContactGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_OdeContactGeom._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeContactGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeContactGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeContactGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeContactGeom);
  }
}

/**
 * Python method tables for OdeCollisionEntry (OdeCollisionEntry)
 */
static PyMethodDef Dtool_Methods_OdeCollisionEntry[] = {
  {"get_geom1", &Dtool_OdeCollisionEntry_get_geom1_348, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_geom1_348_comment},
  {"getGeom1", &Dtool_OdeCollisionEntry_get_geom1_348, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_geom1_348_comment},
  {"get_geom2", &Dtool_OdeCollisionEntry_get_geom2_349, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_geom2_349_comment},
  {"getGeom2", &Dtool_OdeCollisionEntry_get_geom2_349, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_geom2_349_comment},
  {"get_body1", &Dtool_OdeCollisionEntry_get_body1_350, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_body1_350_comment},
  {"getBody1", &Dtool_OdeCollisionEntry_get_body1_350, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_body1_350_comment},
  {"get_body2", &Dtool_OdeCollisionEntry_get_body2_351, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_body2_351_comment},
  {"getBody2", &Dtool_OdeCollisionEntry_get_body2_351, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_body2_351_comment},
  {"get_num_contacts", &Dtool_OdeCollisionEntry_get_num_contacts_352, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_num_contacts_352_comment},
  {"getNumContacts", &Dtool_OdeCollisionEntry_get_num_contacts_352, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_get_num_contacts_352_comment},
  {"get_contact_point", &Dtool_OdeCollisionEntry_get_contact_point_353, METH_O, (const char *)Dtool_OdeCollisionEntry_get_contact_point_353_comment},
  {"getContactPoint", &Dtool_OdeCollisionEntry_get_contact_point_353, METH_O, (const char *)Dtool_OdeCollisionEntry_get_contact_point_353_comment},
  {"get_contact_geom", &Dtool_OdeCollisionEntry_get_contact_geom_354, METH_O, (const char *)Dtool_OdeCollisionEntry_get_contact_geom_354_comment},
  {"getContactGeom", &Dtool_OdeCollisionEntry_get_contact_geom_354, METH_O, (const char *)Dtool_OdeCollisionEntry_get_contact_geom_354_comment},
  {"is_empty", &Dtool_OdeCollisionEntry_is_empty_359, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_is_empty_359_comment},
  {"isEmpty", &Dtool_OdeCollisionEntry_is_empty_359, METH_NOARGS, (const char *)Dtool_OdeCollisionEntry_is_empty_359_comment},
  {"get_class_type", &Dtool_OdeCollisionEntry_get_class_type_360, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeCollisionEntry_get_class_type_360_comment},
  {"getClassType", &Dtool_OdeCollisionEntry_get_class_type_360, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeCollisionEntry_get_class_type_360_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_contact_points", (PyCFunction) &MakeSeq_OdeCollisionEntry_get_contact_points, METH_NOARGS, nullptr},
  { "getContactPoints", (PyCFunction) &MakeSeq_OdeCollisionEntry_get_contact_points, METH_NOARGS, nullptr},
  {"get_contact_geoms", (PyCFunction) &MakeSeq_OdeCollisionEntry_get_contact_geoms, METH_NOARGS, nullptr},
  { "getContactGeoms", (PyCFunction) &MakeSeq_OdeCollisionEntry_get_contact_geoms, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeCollisionEntry slot mp_subscript -> operator []
//////////////////
static PyObject *Dtool_OdeCollisionEntry_operator_355_mp_subscript(PyObject *self, PyObject *arg) {
  OdeCollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCollisionEntry, (void **)&local_this)) {
    return nullptr;
  }
  // 1-inline OdeContactGeom OdeCollisionEntry::operator [](std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    OdeContactGeom *return_value = new OdeContactGeom(((*(const OdeCollisionEntry*)local_this).operator [])(arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (return_value != nullptr) {
      return_value->ref();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return Dtool_Raise_AssertionError();
    }
#endif
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeContactGeom, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(OdeCollisionEntry self, int n)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeCollisionEntry slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_OdeCollisionEntry_operator_typecast_bool_358_nb_bool(PyObject *self) {
  OdeCollisionEntry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeCollisionEntry, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

static PyNumberMethods Dtool_NumberMethods_OdeCollisionEntry = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_OdeCollisionEntry_operator_typecast_bool_358_nb_bool,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeCollisionEntry = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeCollisionEntry = {
  nullptr,
  &Dtool_OdeCollisionEntry_operator_355_mp_subscript,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeCollisionEntry = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeCollisionEntry = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeCollisionEntry = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeCollisionEntry",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeCollisionEntry,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeCollisionEntry,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeCollisionEntry,
    &Dtool_SequenceMethods_OdeCollisionEntry,
    &Dtool_MappingMethods_OdeCollisionEntry,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeCollisionEntry,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class used to hold information about a collision that has occurred.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeCollisionEntry,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeCollisionEntry,
    PyType_GenericAlloc,
    Dtool_new_OdeCollisionEntry,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeCollisionEntry,
  Dtool_UpcastInterface_OdeCollisionEntry,
  Dtool_DowncastInterface_OdeCollisionEntry,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeCollisionEntry(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_OdeCollisionEntry._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_OdeCollisionEntry._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeCollisionEntry._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeCollisionEntry) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeCollisionEntry)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeCollisionEntry);
  }
}

/**
 * Python method tables for OdeSurfaceParameters (OdeSurfaceParameters)
 */
static PyMethodDef Dtool_Methods_OdeSurfaceParameters[] = {
  {"set_mode", &Dtool_OdeSurfaceParameters_set_mode_365, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_mode_365_comment},
  {"setMode", &Dtool_OdeSurfaceParameters_set_mode_365, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_mode_365_comment},
  {"set_mu", &Dtool_OdeSurfaceParameters_set_mu_366, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_mu_366_comment},
  {"setMu", &Dtool_OdeSurfaceParameters_set_mu_366, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_mu_366_comment},
  {"set_mu2", &Dtool_OdeSurfaceParameters_set_mu2_367, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_mu2_367_comment},
  {"setMu2", &Dtool_OdeSurfaceParameters_set_mu2_367, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_mu2_367_comment},
  {"set_bounce", &Dtool_OdeSurfaceParameters_set_bounce_368, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_bounce_368_comment},
  {"setBounce", &Dtool_OdeSurfaceParameters_set_bounce_368, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_bounce_368_comment},
  {"set_bounce_vel", &Dtool_OdeSurfaceParameters_set_bounce_vel_369, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_bounce_vel_369_comment},
  {"setBounceVel", &Dtool_OdeSurfaceParameters_set_bounce_vel_369, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_bounce_vel_369_comment},
  {"set_soft_erp", &Dtool_OdeSurfaceParameters_set_soft_erp_370, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_soft_erp_370_comment},
  {"setSoftErp", &Dtool_OdeSurfaceParameters_set_soft_erp_370, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_soft_erp_370_comment},
  {"set_soft_cfm", &Dtool_OdeSurfaceParameters_set_soft_cfm_371, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_soft_cfm_371_comment},
  {"setSoftCfm", &Dtool_OdeSurfaceParameters_set_soft_cfm_371, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_soft_cfm_371_comment},
  {"set_motion1", &Dtool_OdeSurfaceParameters_set_motion1_372, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_motion1_372_comment},
  {"setMotion1", &Dtool_OdeSurfaceParameters_set_motion1_372, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_motion1_372_comment},
  {"set_motion2", &Dtool_OdeSurfaceParameters_set_motion2_373, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_motion2_373_comment},
  {"setMotion2", &Dtool_OdeSurfaceParameters_set_motion2_373, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_motion2_373_comment},
  {"set_slip1", &Dtool_OdeSurfaceParameters_set_slip1_374, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_slip1_374_comment},
  {"setSlip1", &Dtool_OdeSurfaceParameters_set_slip1_374, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_slip1_374_comment},
  {"set_slip2", &Dtool_OdeSurfaceParameters_set_slip2_375, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_slip2_375_comment},
  {"setSlip2", &Dtool_OdeSurfaceParameters_set_slip2_375, METH_O, (const char *)Dtool_OdeSurfaceParameters_set_slip2_375_comment},
  {"get_mode", &Dtool_OdeSurfaceParameters_get_mode_376, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_mode_376_comment},
  {"getMode", &Dtool_OdeSurfaceParameters_get_mode_376, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_mode_376_comment},
  {"get_mu", &Dtool_OdeSurfaceParameters_get_mu_377, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_mu_377_comment},
  {"getMu", &Dtool_OdeSurfaceParameters_get_mu_377, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_mu_377_comment},
  {"get_mu2", &Dtool_OdeSurfaceParameters_get_mu2_378, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_mu2_378_comment},
  {"getMu2", &Dtool_OdeSurfaceParameters_get_mu2_378, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_mu2_378_comment},
  {"get_bounce", &Dtool_OdeSurfaceParameters_get_bounce_379, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_bounce_379_comment},
  {"getBounce", &Dtool_OdeSurfaceParameters_get_bounce_379, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_bounce_379_comment},
  {"get_bounce_vel", &Dtool_OdeSurfaceParameters_get_bounce_vel_380, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_bounce_vel_380_comment},
  {"getBounceVel", &Dtool_OdeSurfaceParameters_get_bounce_vel_380, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_bounce_vel_380_comment},
  {"get_soft_erp", &Dtool_OdeSurfaceParameters_get_soft_erp_381, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_soft_erp_381_comment},
  {"getSoftErp", &Dtool_OdeSurfaceParameters_get_soft_erp_381, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_soft_erp_381_comment},
  {"get_soft_cfm", &Dtool_OdeSurfaceParameters_get_soft_cfm_382, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_soft_cfm_382_comment},
  {"getSoftCfm", &Dtool_OdeSurfaceParameters_get_soft_cfm_382, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_soft_cfm_382_comment},
  {"get_motion1", &Dtool_OdeSurfaceParameters_get_motion1_383, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_motion1_383_comment},
  {"getMotion1", &Dtool_OdeSurfaceParameters_get_motion1_383, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_motion1_383_comment},
  {"get_motion2", &Dtool_OdeSurfaceParameters_get_motion2_384, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_motion2_384_comment},
  {"getMotion2", &Dtool_OdeSurfaceParameters_get_motion2_384, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_motion2_384_comment},
  {"get_slip1", &Dtool_OdeSurfaceParameters_get_slip1_385, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_slip1_385_comment},
  {"getSlip1", &Dtool_OdeSurfaceParameters_get_slip1_385, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_slip1_385_comment},
  {"get_slip2", &Dtool_OdeSurfaceParameters_get_slip2_386, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_slip2_386_comment},
  {"getSlip2", &Dtool_OdeSurfaceParameters_get_slip2_386, METH_NOARGS, (const char *)Dtool_OdeSurfaceParameters_get_slip2_386_comment},
  {"get_class_type", &Dtool_OdeSurfaceParameters_get_class_type_387, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSurfaceParameters_get_class_type_387_comment},
  {"getClassType", &Dtool_OdeSurfaceParameters_get_class_type_387, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSurfaceParameters_get_class_type_387_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeSurfaceParameters = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeSurfaceParameters = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeSurfaceParameters = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeSurfaceParameters = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeSurfaceParameters = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeSurfaceParameters = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeSurfaceParameters",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeSurfaceParameters,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeSurfaceParameters,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeSurfaceParameters,
    &Dtool_SequenceMethods_OdeSurfaceParameters,
    &Dtool_MappingMethods_OdeSurfaceParameters,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeSurfaceParameters,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeSurfaceParameters,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeSurfaceParameters,
    PyType_GenericAlloc,
    Dtool_new_OdeSurfaceParameters,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeSurfaceParameters,
  Dtool_UpcastInterface_OdeSurfaceParameters,
  Dtool_DowncastInterface_OdeSurfaceParameters,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeSurfaceParameters(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != nullptr);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_OdeSurfaceParameters._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    Dtool_OdeSurfaceParameters._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(27);
    Dtool_OdeSurfaceParameters._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum OdeSurfaceParameters::ModeFlags;
    PyDict_SetItemString(dict, "MF_contact_mu2", Dtool_WrapValue(OdeSurfaceParameters::MF_contact_mu2));
    PyDict_SetItemString(dict, "MFContactMu2", Dtool_WrapValue(OdeSurfaceParameters::MF_contact_mu2));
    PyDict_SetItemString(dict, "MF_contactFDir1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactFDir1));
    PyDict_SetItemString(dict, "MFContactFDir1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactFDir1));
    PyDict_SetItemString(dict, "MF_contactBounce", Dtool_WrapValue(OdeSurfaceParameters::MF_contactBounce));
    PyDict_SetItemString(dict, "MFContactBounce", Dtool_WrapValue(OdeSurfaceParameters::MF_contactBounce));
    PyDict_SetItemString(dict, "MF_contactSoftERP", Dtool_WrapValue(OdeSurfaceParameters::MF_contactSoftERP));
    PyDict_SetItemString(dict, "MFContactSoftERP", Dtool_WrapValue(OdeSurfaceParameters::MF_contactSoftERP));
    PyDict_SetItemString(dict, "MF_contactSoftCFM", Dtool_WrapValue(OdeSurfaceParameters::MF_contactSoftCFM));
    PyDict_SetItemString(dict, "MFContactSoftCFM", Dtool_WrapValue(OdeSurfaceParameters::MF_contactSoftCFM));
    PyDict_SetItemString(dict, "MF_contactMotion1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactMotion1));
    PyDict_SetItemString(dict, "MFContactMotion1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactMotion1));
    PyDict_SetItemString(dict, "MF_contactMotion2", Dtool_WrapValue(OdeSurfaceParameters::MF_contactMotion2));
    PyDict_SetItemString(dict, "MFContactMotion2", Dtool_WrapValue(OdeSurfaceParameters::MF_contactMotion2));
    PyDict_SetItemString(dict, "MF_contactSlip1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactSlip1));
    PyDict_SetItemString(dict, "MFContactSlip1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactSlip1));
    PyDict_SetItemString(dict, "MF_contactSlip2", Dtool_WrapValue(OdeSurfaceParameters::MF_contactSlip2));
    PyDict_SetItemString(dict, "MFContactSlip2", Dtool_WrapValue(OdeSurfaceParameters::MF_contactSlip2));
    PyDict_SetItemString(dict, "MF_contactApprox0", Dtool_WrapValue(OdeSurfaceParameters::MF_contactApprox0));
    PyDict_SetItemString(dict, "MFContactApprox0", Dtool_WrapValue(OdeSurfaceParameters::MF_contactApprox0));
    PyDict_SetItemString(dict, "MF_contactApprox1_1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactApprox1_1));
    PyDict_SetItemString(dict, "MFContactApprox11", Dtool_WrapValue(OdeSurfaceParameters::MF_contactApprox1_1));
    PyDict_SetItemString(dict, "MF_contactApprox1_2", Dtool_WrapValue(OdeSurfaceParameters::MF_contactApprox1_2));
    PyDict_SetItemString(dict, "MFContactApprox12", Dtool_WrapValue(OdeSurfaceParameters::MF_contactApprox1_2));
    PyDict_SetItemString(dict, "MF_contactApprox1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactApprox1));
    PyDict_SetItemString(dict, "MFContactApprox1", Dtool_WrapValue(OdeSurfaceParameters::MF_contactApprox1));
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeSurfaceParameters) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeSurfaceParameters)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeSurfaceParameters);
  }
}

/**
 * Python method tables for OdeContact (OdeContact)
 */
static PyMethodDef Dtool_Methods_OdeContact[] = {
  {"get_surface", &Dtool_OdeContact_get_surface_390, METH_NOARGS, (const char *)Dtool_OdeContact_get_surface_390_comment},
  {"getSurface", &Dtool_OdeContact_get_surface_390, METH_NOARGS, (const char *)Dtool_OdeContact_get_surface_390_comment},
  {"get_geom", &Dtool_OdeContact_get_geom_391, METH_NOARGS, (const char *)Dtool_OdeContact_get_geom_391_comment},
  {"getGeom", &Dtool_OdeContact_get_geom_391, METH_NOARGS, (const char *)Dtool_OdeContact_get_geom_391_comment},
  {"get_fdir1", &Dtool_OdeContact_get_fdir1_392, METH_NOARGS, (const char *)Dtool_OdeContact_get_fdir1_392_comment},
  {"getFdir1", &Dtool_OdeContact_get_fdir1_392, METH_NOARGS, (const char *)Dtool_OdeContact_get_fdir1_392_comment},
  {"set_surface", &Dtool_OdeContact_set_surface_393, METH_O, (const char *)Dtool_OdeContact_set_surface_393_comment},
  {"setSurface", &Dtool_OdeContact_set_surface_393, METH_O, (const char *)Dtool_OdeContact_set_surface_393_comment},
  {"set_geom", &Dtool_OdeContact_set_geom_394, METH_O, (const char *)Dtool_OdeContact_set_geom_394_comment},
  {"setGeom", &Dtool_OdeContact_set_geom_394, METH_O, (const char *)Dtool_OdeContact_set_geom_394_comment},
  {"set_fdir1", &Dtool_OdeContact_set_fdir1_395, METH_O, (const char *)Dtool_OdeContact_set_fdir1_395_comment},
  {"setFdir1", &Dtool_OdeContact_set_fdir1_395, METH_O, (const char *)Dtool_OdeContact_set_fdir1_395_comment},
  {"get_class_type", &Dtool_OdeContact_get_class_type_396, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeContact_get_class_type_396_comment},
  {"getClassType", &Dtool_OdeContact_get_class_type_396, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeContact_get_class_type_396_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeContact = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeContact = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeContact = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeContact = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeContact = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeContact = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeContact",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeContact,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeContact,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeContact,
    &Dtool_SequenceMethods_OdeContact,
    &Dtool_MappingMethods_OdeContact,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeContact,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeContact,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeContact,
    PyType_GenericAlloc,
    Dtool_new_OdeContact,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeContact,
  Dtool_UpcastInterface_OdeContact,
  Dtool_DowncastInterface_OdeContact,
  (CoerceFunction)Dtool_ConstCoerce_OdeContact,
  (CoerceFunction)Dtool_Coerce_OdeContact,
};

static void Dtool_PyModuleClassInit_OdeContact(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_OdeContact._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_OdeContact._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeContact._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeContact) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeContact)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeContact);
  }
}

/**
 * Python method tables for OdeContactJoint (OdeContactJoint)
 */
static PyMethodDef Dtool_Methods_OdeContactJoint[] = {
  {"get_class_type", &Dtool_OdeContactJoint_get_class_type_399, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeContactJoint_get_class_type_399_comment},
  {"getClassType", &Dtool_OdeContactJoint_get_class_type_399, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeContactJoint_get_class_type_399_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeContactJoint = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeContactJoint = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeContactJoint = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeContactJoint = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeContactJoint = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeContactJoint = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeContactJoint",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeContactJoint,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeContactJoint,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeContactJoint,
    &Dtool_SequenceMethods_OdeContactJoint,
    &Dtool_MappingMethods_OdeContactJoint,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeContactJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeContactJoint,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeContactJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeContactJoint,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeContactJoint,
  Dtool_UpcastInterface_OdeContactJoint,
  Dtool_DowncastInterface_OdeContactJoint,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeContactJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(nullptr);
    Dtool_OdeContactJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    Dtool_OdeContactJoint._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeContactJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeContactJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeContactJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeContactJoint);
  }
}

/**
 * Python method tables for OdeCylinderGeom (OdeCylinderGeom)
 */
static PyMethodDef Dtool_Methods_OdeCylinderGeom[] = {
  {"set_params", (PyCFunction) &Dtool_OdeCylinderGeom_set_params_402, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeCylinderGeom_set_params_402_comment},
  {"setParams", (PyCFunction) &Dtool_OdeCylinderGeom_set_params_402, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeCylinderGeom_set_params_402_comment},
  {"get_radius", &Dtool_OdeCylinderGeom_get_radius_404, METH_NOARGS, (const char *)Dtool_OdeCylinderGeom_get_radius_404_comment},
  {"getRadius", &Dtool_OdeCylinderGeom_get_radius_404, METH_NOARGS, (const char *)Dtool_OdeCylinderGeom_get_radius_404_comment},
  {"get_length", &Dtool_OdeCylinderGeom_get_length_405, METH_NOARGS, (const char *)Dtool_OdeCylinderGeom_get_length_405_comment},
  {"getLength", &Dtool_OdeCylinderGeom_get_length_405, METH_NOARGS, (const char *)Dtool_OdeCylinderGeom_get_length_405_comment},
  {"get_class_type", &Dtool_OdeCylinderGeom_get_class_type_406, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeCylinderGeom_get_class_type_406_comment},
  {"getClassType", &Dtool_OdeCylinderGeom_get_class_type_406, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeCylinderGeom_get_class_type_406_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeCylinderGeom = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeCylinderGeom = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeCylinderGeom = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeCylinderGeom = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeCylinderGeom = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeCylinderGeom = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeCylinderGeom",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeCylinderGeom,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeCylinderGeom,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeCylinderGeom,
    &Dtool_SequenceMethods_OdeCylinderGeom,
    &Dtool_MappingMethods_OdeCylinderGeom,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeCylinderGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeCylinderGeom,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeCylinderGeom,
    PyType_GenericAlloc,
    Dtool_new_OdeCylinderGeom,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeCylinderGeom,
  Dtool_UpcastInterface_OdeCylinderGeom,
  Dtool_DowncastInterface_OdeCylinderGeom,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeCylinderGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeGeom(nullptr);
    Dtool_OdeCylinderGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeGeom);
    Dtool_OdeCylinderGeom._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeCylinderGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeCylinderGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeCylinderGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeCylinderGeom);
  }
}

/**
 * Python method tables for OdeFixedJoint (OdeFixedJoint)
 */
static PyMethodDef Dtool_Methods_OdeFixedJoint[] = {
  {"set", &Dtool_OdeFixedJoint_set_409, METH_NOARGS, (const char *)Dtool_OdeFixedJoint_set_409_comment},
  {"get_class_type", &Dtool_OdeFixedJoint_get_class_type_410, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeFixedJoint_get_class_type_410_comment},
  {"getClassType", &Dtool_OdeFixedJoint_get_class_type_410, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeFixedJoint_get_class_type_410_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeFixedJoint = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeFixedJoint = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeFixedJoint = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeFixedJoint = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeFixedJoint = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeFixedJoint = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeFixedJoint",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeFixedJoint,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeFixedJoint,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeFixedJoint,
    &Dtool_SequenceMethods_OdeFixedJoint,
    &Dtool_MappingMethods_OdeFixedJoint,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeFixedJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeFixedJoint,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeFixedJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeFixedJoint,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeFixedJoint,
  Dtool_UpcastInterface_OdeFixedJoint,
  Dtool_DowncastInterface_OdeFixedJoint,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeFixedJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(nullptr);
    Dtool_OdeFixedJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    Dtool_OdeFixedJoint._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeFixedJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeFixedJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeFixedJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeFixedJoint);
  }
}

/**
 * Python method tables for OdeHashSpace (OdeHashSpace)
 */
static PyMethodDef Dtool_Methods_OdeHashSpace[] = {
  {"set_levels", (PyCFunction) &Dtool_OdeHashSpace_set_levels_413, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHashSpace_set_levels_413_comment},
  {"setLevels", (PyCFunction) &Dtool_OdeHashSpace_set_levels_413, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHashSpace_set_levels_413_comment},
  {"get_min_level", &Dtool_OdeHashSpace_get_min_level_414, METH_NOARGS, (const char *)Dtool_OdeHashSpace_get_min_level_414_comment},
  {"getMinLevel", &Dtool_OdeHashSpace_get_min_level_414, METH_NOARGS, (const char *)Dtool_OdeHashSpace_get_min_level_414_comment},
  {"get_max_level", &Dtool_OdeHashSpace_get_max_level_415, METH_NOARGS, (const char *)Dtool_OdeHashSpace_get_max_level_415_comment},
  {"getMaxLevel", &Dtool_OdeHashSpace_get_max_level_415, METH_NOARGS, (const char *)Dtool_OdeHashSpace_get_max_level_415_comment},
  {"get_class_type", &Dtool_OdeHashSpace_get_class_type_416, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeHashSpace_get_class_type_416_comment},
  {"getClassType", &Dtool_OdeHashSpace_get_class_type_416, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeHashSpace_get_class_type_416_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeHashSpace = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeHashSpace = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeHashSpace = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeHashSpace = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeHashSpace = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeHashSpace = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeHashSpace",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeHashSpace,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeHashSpace,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeHashSpace,
    &Dtool_SequenceMethods_OdeHashSpace,
    &Dtool_MappingMethods_OdeHashSpace,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeHashSpace,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeHashSpace,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeHashSpace,
    PyType_GenericAlloc,
    Dtool_new_OdeHashSpace,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeHashSpace,
  Dtool_UpcastInterface_OdeHashSpace,
  Dtool_DowncastInterface_OdeHashSpace,
  nullptr,
  (CoerceFunction)Dtool_Coerce_OdeHashSpace,
};

static void Dtool_PyModuleClassInit_OdeHashSpace(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeSpace(nullptr);
    Dtool_OdeHashSpace._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeSpace);
    Dtool_OdeHashSpace._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeHashSpace._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeHashSpace) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeHashSpace)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeHashSpace);
  }
}

/**
 * Python method tables for OdeHinge2Joint (OdeHinge2Joint)
 */
static PyMethodDef Dtool_Methods_OdeHinge2Joint[] = {
  {"set_anchor", (PyCFunction) &Dtool_OdeHinge2Joint_set_anchor_419, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_anchor_419_comment},
  {"setAnchor", (PyCFunction) &Dtool_OdeHinge2Joint_set_anchor_419, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_anchor_419_comment},
  {"set_axis1", (PyCFunction) &Dtool_OdeHinge2Joint_set_axis1_420, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_axis1_420_comment},
  {"setAxis1", (PyCFunction) &Dtool_OdeHinge2Joint_set_axis1_420, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_axis1_420_comment},
  {"set_axis2", (PyCFunction) &Dtool_OdeHinge2Joint_set_axis2_421, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_axis2_421_comment},
  {"setAxis2", (PyCFunction) &Dtool_OdeHinge2Joint_set_axis2_421, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_axis2_421_comment},
  {"add_torques", (PyCFunction) &Dtool_OdeHinge2Joint_add_torques_422, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_add_torques_422_comment},
  {"addTorques", (PyCFunction) &Dtool_OdeHinge2Joint_add_torques_422, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_add_torques_422_comment},
  {"get_anchor", &Dtool_OdeHinge2Joint_get_anchor_423, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_anchor_423_comment},
  {"getAnchor", &Dtool_OdeHinge2Joint_get_anchor_423, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_anchor_423_comment},
  {"get_anchor2", &Dtool_OdeHinge2Joint_get_anchor2_424, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_anchor2_424_comment},
  {"getAnchor2", &Dtool_OdeHinge2Joint_get_anchor2_424, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_anchor2_424_comment},
  {"get_axis1", &Dtool_OdeHinge2Joint_get_axis1_425, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_axis1_425_comment},
  {"getAxis1", &Dtool_OdeHinge2Joint_get_axis1_425, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_axis1_425_comment},
  {"get_axis2", &Dtool_OdeHinge2Joint_get_axis2_426, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_axis2_426_comment},
  {"getAxis2", &Dtool_OdeHinge2Joint_get_axis2_426, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_axis2_426_comment},
  {"get_angle1", &Dtool_OdeHinge2Joint_get_angle1_427, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_angle1_427_comment},
  {"getAngle1", &Dtool_OdeHinge2Joint_get_angle1_427, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_angle1_427_comment},
  {"get_angle1_rate", &Dtool_OdeHinge2Joint_get_angle1_rate_428, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_angle1_rate_428_comment},
  {"getAngle1Rate", &Dtool_OdeHinge2Joint_get_angle1_rate_428, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_angle1_rate_428_comment},
  {"get_angle2_rate", &Dtool_OdeHinge2Joint_get_angle2_rate_429, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_angle2_rate_429_comment},
  {"getAngle2Rate", &Dtool_OdeHinge2Joint_get_angle2_rate_429, METH_NOARGS, (const char *)Dtool_OdeHinge2Joint_get_angle2_rate_429_comment},
  {"set_param_lo_stop", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_lo_stop_430, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_lo_stop_430_comment},
  {"setParamLoStop", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_lo_stop_430, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_lo_stop_430_comment},
  {"set_param_hi_stop", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_hi_stop_431, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_hi_stop_431_comment},
  {"setParamHiStop", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_hi_stop_431, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_hi_stop_431_comment},
  {"set_param_vel", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_vel_432, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_vel_432_comment},
  {"setParamVel", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_vel_432, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_vel_432_comment},
  {"set_param_f_max", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_f_max_433, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_f_max_433_comment},
  {"setParamFMax", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_f_max_433, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_f_max_433_comment},
  {"set_param_fudge_factor", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_fudge_factor_434, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_fudge_factor_434_comment},
  {"setParamFudgeFactor", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_fudge_factor_434, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_fudge_factor_434_comment},
  {"set_param_bounce", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_bounce_435, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_bounce_435_comment},
  {"setParamBounce", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_bounce_435, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_bounce_435_comment},
  {"set_param_CFM", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_CFM_436, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_CFM_436_comment},
  {"setParamCFM", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_CFM_436, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_CFM_436_comment},
  {"set_param_stop_ERP", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_stop_ERP_437, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_stop_ERP_437_comment},
  {"setParamStopERP", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_stop_ERP_437, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_stop_ERP_437_comment},
  {"set_param_stop_CFM", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_stop_CFM_438, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_stop_CFM_438_comment},
  {"setParamStopCFM", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_stop_CFM_438, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_stop_CFM_438_comment},
  {"set_param_suspension_ERP", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_suspension_ERP_439, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_suspension_ERP_439_comment},
  {"setParamSuspensionERP", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_suspension_ERP_439, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_suspension_ERP_439_comment},
  {"set_param_suspension_CFM", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_suspension_CFM_440, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_suspension_CFM_440_comment},
  {"setParamSuspensionCFM", (PyCFunction) &Dtool_OdeHinge2Joint_set_param_suspension_CFM_440, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHinge2Joint_set_param_suspension_CFM_440_comment},
  {"get_param_lo_stop", &Dtool_OdeHinge2Joint_get_param_lo_stop_441, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_lo_stop_441_comment},
  {"getParamLoStop", &Dtool_OdeHinge2Joint_get_param_lo_stop_441, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_lo_stop_441_comment},
  {"get_param_hi_stop", &Dtool_OdeHinge2Joint_get_param_hi_stop_442, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_hi_stop_442_comment},
  {"getParamHiStop", &Dtool_OdeHinge2Joint_get_param_hi_stop_442, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_hi_stop_442_comment},
  {"get_param_vel", &Dtool_OdeHinge2Joint_get_param_vel_443, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_vel_443_comment},
  {"getParamVel", &Dtool_OdeHinge2Joint_get_param_vel_443, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_vel_443_comment},
  {"get_param_f_max", &Dtool_OdeHinge2Joint_get_param_f_max_444, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_f_max_444_comment},
  {"getParamFMax", &Dtool_OdeHinge2Joint_get_param_f_max_444, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_f_max_444_comment},
  {"get_param_fudge_factor", &Dtool_OdeHinge2Joint_get_param_fudge_factor_445, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_fudge_factor_445_comment},
  {"getParamFudgeFactor", &Dtool_OdeHinge2Joint_get_param_fudge_factor_445, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_fudge_factor_445_comment},
  {"get_param_bounce", &Dtool_OdeHinge2Joint_get_param_bounce_446, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_bounce_446_comment},
  {"getParamBounce", &Dtool_OdeHinge2Joint_get_param_bounce_446, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_bounce_446_comment},
  {"get_param_CFM", &Dtool_OdeHinge2Joint_get_param_CFM_447, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_CFM_447_comment},
  {"getParamCFM", &Dtool_OdeHinge2Joint_get_param_CFM_447, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_CFM_447_comment},
  {"get_param_stop_ERP", &Dtool_OdeHinge2Joint_get_param_stop_ERP_448, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_stop_ERP_448_comment},
  {"getParamStopERP", &Dtool_OdeHinge2Joint_get_param_stop_ERP_448, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_stop_ERP_448_comment},
  {"get_param_stop_CFM", &Dtool_OdeHinge2Joint_get_param_stop_CFM_449, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_stop_CFM_449_comment},
  {"getParamStopCFM", &Dtool_OdeHinge2Joint_get_param_stop_CFM_449, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_stop_CFM_449_comment},
  {"get_param_suspension_ERP", &Dtool_OdeHinge2Joint_get_param_suspension_ERP_450, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_suspension_ERP_450_comment},
  {"getParamSuspensionERP", &Dtool_OdeHinge2Joint_get_param_suspension_ERP_450, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_suspension_ERP_450_comment},
  {"get_param_suspension_CFM", &Dtool_OdeHinge2Joint_get_param_suspension_CFM_451, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_suspension_CFM_451_comment},
  {"getParamSuspensionCFM", &Dtool_OdeHinge2Joint_get_param_suspension_CFM_451, METH_O, (const char *)Dtool_OdeHinge2Joint_get_param_suspension_CFM_451_comment},
  {"get_class_type", &Dtool_OdeHinge2Joint_get_class_type_452, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeHinge2Joint_get_class_type_452_comment},
  {"getClassType", &Dtool_OdeHinge2Joint_get_class_type_452, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeHinge2Joint_get_class_type_452_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeHinge2Joint = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeHinge2Joint = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeHinge2Joint = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeHinge2Joint = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeHinge2Joint = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeHinge2Joint = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeHinge2Joint",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeHinge2Joint,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeHinge2Joint,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeHinge2Joint,
    &Dtool_SequenceMethods_OdeHinge2Joint,
    &Dtool_MappingMethods_OdeHinge2Joint,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeHinge2Joint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeHinge2Joint,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeHinge2Joint,
    PyType_GenericAlloc,
    Dtool_new_OdeHinge2Joint,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeHinge2Joint,
  Dtool_UpcastInterface_OdeHinge2Joint,
  Dtool_DowncastInterface_OdeHinge2Joint,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeHinge2Joint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(nullptr);
    Dtool_OdeHinge2Joint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    Dtool_OdeHinge2Joint._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeHinge2Joint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeHinge2Joint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeHinge2Joint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeHinge2Joint);
  }
}

/**
 * Python method tables for OdeHingeJoint (OdeHingeJoint)
 */
static PyMethodDef Dtool_Methods_OdeHingeJoint[] = {
  {"set_anchor", (PyCFunction) &Dtool_OdeHingeJoint_set_anchor_455, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHingeJoint_set_anchor_455_comment},
  {"setAnchor", (PyCFunction) &Dtool_OdeHingeJoint_set_anchor_455, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHingeJoint_set_anchor_455_comment},
  {"set_anchor_delta", (PyCFunction) &Dtool_OdeHingeJoint_set_anchor_delta_456, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHingeJoint_set_anchor_delta_456_comment},
  {"setAnchorDelta", (PyCFunction) &Dtool_OdeHingeJoint_set_anchor_delta_456, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHingeJoint_set_anchor_delta_456_comment},
  {"set_axis", (PyCFunction) &Dtool_OdeHingeJoint_set_axis_457, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHingeJoint_set_axis_457_comment},
  {"setAxis", (PyCFunction) &Dtool_OdeHingeJoint_set_axis_457, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeHingeJoint_set_axis_457_comment},
  {"add_torque", &Dtool_OdeHingeJoint_add_torque_458, METH_O, (const char *)Dtool_OdeHingeJoint_add_torque_458_comment},
  {"addTorque", &Dtool_OdeHingeJoint_add_torque_458, METH_O, (const char *)Dtool_OdeHingeJoint_add_torque_458_comment},
  {"get_anchor", &Dtool_OdeHingeJoint_get_anchor_459, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_anchor_459_comment},
  {"getAnchor", &Dtool_OdeHingeJoint_get_anchor_459, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_anchor_459_comment},
  {"get_anchor2", &Dtool_OdeHingeJoint_get_anchor2_460, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_anchor2_460_comment},
  {"getAnchor2", &Dtool_OdeHingeJoint_get_anchor2_460, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_anchor2_460_comment},
  {"get_axis", &Dtool_OdeHingeJoint_get_axis_461, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_axis_461_comment},
  {"getAxis", &Dtool_OdeHingeJoint_get_axis_461, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_axis_461_comment},
  {"get_angle", &Dtool_OdeHingeJoint_get_angle_462, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_angle_462_comment},
  {"getAngle", &Dtool_OdeHingeJoint_get_angle_462, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_angle_462_comment},
  {"get_angle_rate", &Dtool_OdeHingeJoint_get_angle_rate_463, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_angle_rate_463_comment},
  {"getAngleRate", &Dtool_OdeHingeJoint_get_angle_rate_463, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_angle_rate_463_comment},
  {"set_param_lo_stop", &Dtool_OdeHingeJoint_set_param_lo_stop_464, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_lo_stop_464_comment},
  {"setParamLoStop", &Dtool_OdeHingeJoint_set_param_lo_stop_464, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_lo_stop_464_comment},
  {"set_param_hi_stop", &Dtool_OdeHingeJoint_set_param_hi_stop_465, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_hi_stop_465_comment},
  {"setParamHiStop", &Dtool_OdeHingeJoint_set_param_hi_stop_465, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_hi_stop_465_comment},
  {"set_param_vel", &Dtool_OdeHingeJoint_set_param_vel_466, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_vel_466_comment},
  {"setParamVel", &Dtool_OdeHingeJoint_set_param_vel_466, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_vel_466_comment},
  {"set_param_f_max", &Dtool_OdeHingeJoint_set_param_f_max_467, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_f_max_467_comment},
  {"setParamFMax", &Dtool_OdeHingeJoint_set_param_f_max_467, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_f_max_467_comment},
  {"set_param_fudge_factor", &Dtool_OdeHingeJoint_set_param_fudge_factor_468, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_fudge_factor_468_comment},
  {"setParamFudgeFactor", &Dtool_OdeHingeJoint_set_param_fudge_factor_468, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_fudge_factor_468_comment},
  {"set_param_bounce", &Dtool_OdeHingeJoint_set_param_bounce_469, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_bounce_469_comment},
  {"setParamBounce", &Dtool_OdeHingeJoint_set_param_bounce_469, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_bounce_469_comment},
  {"set_param_CFM", &Dtool_OdeHingeJoint_set_param_CFM_470, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_CFM_470_comment},
  {"setParamCFM", &Dtool_OdeHingeJoint_set_param_CFM_470, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_CFM_470_comment},
  {"set_param_stop_ERP", &Dtool_OdeHingeJoint_set_param_stop_ERP_471, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_stop_ERP_471_comment},
  {"setParamStopERP", &Dtool_OdeHingeJoint_set_param_stop_ERP_471, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_stop_ERP_471_comment},
  {"set_param_stop_CFM", &Dtool_OdeHingeJoint_set_param_stop_CFM_472, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_stop_CFM_472_comment},
  {"setParamStopCFM", &Dtool_OdeHingeJoint_set_param_stop_CFM_472, METH_O, (const char *)Dtool_OdeHingeJoint_set_param_stop_CFM_472_comment},
  {"get_param_lo_stop", &Dtool_OdeHingeJoint_get_param_lo_stop_473, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_lo_stop_473_comment},
  {"getParamLoStop", &Dtool_OdeHingeJoint_get_param_lo_stop_473, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_lo_stop_473_comment},
  {"get_param_hi_stop", &Dtool_OdeHingeJoint_get_param_hi_stop_474, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_hi_stop_474_comment},
  {"getParamHiStop", &Dtool_OdeHingeJoint_get_param_hi_stop_474, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_hi_stop_474_comment},
  {"get_param_vel", &Dtool_OdeHingeJoint_get_param_vel_475, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_vel_475_comment},
  {"getParamVel", &Dtool_OdeHingeJoint_get_param_vel_475, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_vel_475_comment},
  {"get_param_f_max", &Dtool_OdeHingeJoint_get_param_f_max_476, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_f_max_476_comment},
  {"getParamFMax", &Dtool_OdeHingeJoint_get_param_f_max_476, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_f_max_476_comment},
  {"get_param_fudge_factor", &Dtool_OdeHingeJoint_get_param_fudge_factor_477, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_fudge_factor_477_comment},
  {"getParamFudgeFactor", &Dtool_OdeHingeJoint_get_param_fudge_factor_477, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_fudge_factor_477_comment},
  {"get_param_bounce", &Dtool_OdeHingeJoint_get_param_bounce_478, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_bounce_478_comment},
  {"getParamBounce", &Dtool_OdeHingeJoint_get_param_bounce_478, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_bounce_478_comment},
  {"get_param_CFM", &Dtool_OdeHingeJoint_get_param_CFM_479, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_CFM_479_comment},
  {"getParamCFM", &Dtool_OdeHingeJoint_get_param_CFM_479, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_CFM_479_comment},
  {"get_param_stop_ERP", &Dtool_OdeHingeJoint_get_param_stop_ERP_480, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_stop_ERP_480_comment},
  {"getParamStopERP", &Dtool_OdeHingeJoint_get_param_stop_ERP_480, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_stop_ERP_480_comment},
  {"get_param_stop_CFM", &Dtool_OdeHingeJoint_get_param_stop_CFM_481, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_stop_CFM_481_comment},
  {"getParamStopCFM", &Dtool_OdeHingeJoint_get_param_stop_CFM_481, METH_NOARGS, (const char *)Dtool_OdeHingeJoint_get_param_stop_CFM_481_comment},
  {"get_class_type", &Dtool_OdeHingeJoint_get_class_type_482, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeHingeJoint_get_class_type_482_comment},
  {"getClassType", &Dtool_OdeHingeJoint_get_class_type_482, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeHingeJoint_get_class_type_482_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeHingeJoint = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeHingeJoint = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeHingeJoint = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeHingeJoint = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeHingeJoint = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeHingeJoint = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeHingeJoint",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeHingeJoint,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeHingeJoint,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeHingeJoint,
    &Dtool_SequenceMethods_OdeHingeJoint,
    &Dtool_MappingMethods_OdeHingeJoint,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeHingeJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeHingeJoint,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeHingeJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeHingeJoint,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeHingeJoint,
  Dtool_UpcastInterface_OdeHingeJoint,
  Dtool_DowncastInterface_OdeHingeJoint,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeHingeJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(nullptr);
    Dtool_OdeHingeJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    Dtool_OdeHingeJoint._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeHingeJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeHingeJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeHingeJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeHingeJoint);
  }
}

/**
 * Python method tables for OdeJointCollection (OdeJointCollection)
 */
static PyMethodDef Dtool_Methods_OdeJointCollection[] = {
  {"assign", &Dtool_OdeJointCollection_operator_485, METH_O, (const char *)Dtool_OdeJointCollection_operator_485_comment},
  {"add_joint", &Dtool_OdeJointCollection_add_joint_487, METH_O, (const char *)Dtool_OdeJointCollection_add_joint_487_comment},
  {"addJoint", &Dtool_OdeJointCollection_add_joint_487, METH_O, (const char *)Dtool_OdeJointCollection_add_joint_487_comment},
  {"remove_joint", &Dtool_OdeJointCollection_remove_joint_488, METH_O, (const char *)Dtool_OdeJointCollection_remove_joint_488_comment},
  {"removeJoint", &Dtool_OdeJointCollection_remove_joint_488, METH_O, (const char *)Dtool_OdeJointCollection_remove_joint_488_comment},
  {"add_joints_from", &Dtool_OdeJointCollection_add_joints_from_489, METH_O, (const char *)Dtool_OdeJointCollection_add_joints_from_489_comment},
  {"addJointsFrom", &Dtool_OdeJointCollection_add_joints_from_489, METH_O, (const char *)Dtool_OdeJointCollection_add_joints_from_489_comment},
  {"remove_joints_from", &Dtool_OdeJointCollection_remove_joints_from_490, METH_O, (const char *)Dtool_OdeJointCollection_remove_joints_from_490_comment},
  {"removeJointsFrom", &Dtool_OdeJointCollection_remove_joints_from_490, METH_O, (const char *)Dtool_OdeJointCollection_remove_joints_from_490_comment},
  {"remove_duplicate_joints", &Dtool_OdeJointCollection_remove_duplicate_joints_491, METH_NOARGS, (const char *)Dtool_OdeJointCollection_remove_duplicate_joints_491_comment},
  {"removeDuplicateJoints", &Dtool_OdeJointCollection_remove_duplicate_joints_491, METH_NOARGS, (const char *)Dtool_OdeJointCollection_remove_duplicate_joints_491_comment},
  {"has_joint", &Dtool_OdeJointCollection_has_joint_492, METH_O, (const char *)Dtool_OdeJointCollection_has_joint_492_comment},
  {"hasJoint", &Dtool_OdeJointCollection_has_joint_492, METH_O, (const char *)Dtool_OdeJointCollection_has_joint_492_comment},
  {"clear", &Dtool_OdeJointCollection_clear_493, METH_NOARGS, (const char *)Dtool_OdeJointCollection_clear_493_comment},
  {"is_empty", &Dtool_OdeJointCollection_is_empty_494, METH_NOARGS, (const char *)Dtool_OdeJointCollection_is_empty_494_comment},
  {"isEmpty", &Dtool_OdeJointCollection_is_empty_494, METH_NOARGS, (const char *)Dtool_OdeJointCollection_is_empty_494_comment},
  {"get_num_joints", &Dtool_OdeJointCollection_get_num_joints_495, METH_NOARGS, (const char *)Dtool_OdeJointCollection_get_num_joints_495_comment},
  {"getNumJoints", &Dtool_OdeJointCollection_get_num_joints_495, METH_NOARGS, (const char *)Dtool_OdeJointCollection_get_num_joints_495_comment},
  {"get_joint", &Dtool_OdeJointCollection_get_joint_496, METH_O, (const char *)Dtool_OdeJointCollection_get_joint_496_comment},
  {"getJoint", &Dtool_OdeJointCollection_get_joint_496, METH_O, (const char *)Dtool_OdeJointCollection_get_joint_496_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_joints", (PyCFunction) &MakeSeq_OdeJointCollection_get_joints, METH_NOARGS, nullptr},
  { "getJoints", (PyCFunction) &MakeSeq_OdeJointCollection_get_joints, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeJointCollection slot nb_add -> operator +
//////////////////
static PyObject *Dtool_OdeJointCollection_operator_501_nb_add(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_OdeJointCollection, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline OdeJointCollection OdeJointCollection::operator +(OdeJointCollection const &other) const
  OdeJointCollection const *arg_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointCollection, 1, "OdeJointCollection.__add__", true, true);
  if (arg_this != nullptr) {
    OdeJointCollection *return_value = new OdeJointCollection(((*(const OdeJointCollection*)local_this).operator +)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_OdeJointCollection, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeJointCollection slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_OdeJointCollection_operator_500_nb_inplace_add(PyObject *self, PyObject *arg) {
  OdeJointCollection *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_OdeJointCollection, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void OdeJointCollection::operator +=(OdeJointCollection const &other)
  OdeJointCollection const *arg_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_OdeJointCollection, 1, "OdeJointCollection.__iadd__", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator +=)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeJointCollection slot sq_item -> operator []
//////////////////
static PyObject *Dtool_OdeJointCollection_operator_498_sq_item(PyObject *self, Py_ssize_t index) {
  OdeJointCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointCollection, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "OdeJointCollection index out of range");
    return nullptr;
  }
  // 1-OdeJoint OdeJointCollection::operator [](int index) const
  OdeJoint *return_value = new OdeJoint(((*(const OdeJointCollection*)local_this).operator [])(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_OdeJoint, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(OdeJointCollection self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// OdeJointCollection slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_OdeJointCollection_size_499_sq_length(PyObject *self) {
  OdeJointCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeJointCollection, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_OdeJointCollection = {
  &Dtool_OdeJointCollection_operator_501_nb_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  &Dtool_OdeJointCollection_operator_500_nb_inplace_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeJointCollection = {
  &Dtool_OdeJointCollection_size_499_sq_length,
  nullptr,
  nullptr,
  &Dtool_OdeJointCollection_operator_498_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_OdeJointCollection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeJointCollection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeJointCollection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeJointCollection,
    &Dtool_SequenceMethods_OdeJointCollection,
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeJointCollection,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeJointCollection,
    PyType_GenericAlloc,
    Dtool_new_OdeJointCollection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeJointCollection,
  Dtool_UpcastInterface_OdeJointCollection,
  Dtool_DowncastInterface_OdeJointCollection,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeJointCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_OdeJointCollection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeJointCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeJointCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeJointCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeJointCollection);
  }
}

/**
 * Python method tables for OdeLMotorJoint (OdeLMotorJoint)
 */
static PyMethodDef Dtool_Methods_OdeLMotorJoint[] = {
  {"set_num_axes", &Dtool_OdeLMotorJoint_set_num_axes_504, METH_O, (const char *)Dtool_OdeLMotorJoint_set_num_axes_504_comment},
  {"setNumAxes", &Dtool_OdeLMotorJoint_set_num_axes_504, METH_O, (const char *)Dtool_OdeLMotorJoint_set_num_axes_504_comment},
  {"set_axis", (PyCFunction) &Dtool_OdeLMotorJoint_set_axis_505, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeLMotorJoint_set_axis_505_comment},
  {"setAxis", (PyCFunction) &Dtool_OdeLMotorJoint_set_axis_505, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeLMotorJoint_set_axis_505_comment},
  {"set_param", (PyCFunction) &Dtool_OdeLMotorJoint_set_param_506, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeLMotorJoint_set_param_506_comment},
  {"setParam", (PyCFunction) &Dtool_OdeLMotorJoint_set_param_506, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeLMotorJoint_set_param_506_comment},
  {"get_num_axes", &Dtool_OdeLMotorJoint_get_num_axes_507, METH_NOARGS, (const char *)Dtool_OdeLMotorJoint_get_num_axes_507_comment},
  {"getNumAxes", &Dtool_OdeLMotorJoint_get_num_axes_507, METH_NOARGS, (const char *)Dtool_OdeLMotorJoint_get_num_axes_507_comment},
  {"get_axis", &Dtool_OdeLMotorJoint_get_axis_508, METH_O, (const char *)Dtool_OdeLMotorJoint_get_axis_508_comment},
  {"getAxis", &Dtool_OdeLMotorJoint_get_axis_508, METH_O, (const char *)Dtool_OdeLMotorJoint_get_axis_508_comment},
  {"get_param", &Dtool_OdeLMotorJoint_get_param_510, METH_O, (const char *)Dtool_OdeLMotorJoint_get_param_510_comment},
  {"getParam", &Dtool_OdeLMotorJoint_get_param_510, METH_O, (const char *)Dtool_OdeLMotorJoint_get_param_510_comment},
  {"get_class_type", &Dtool_OdeLMotorJoint_get_class_type_511, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeLMotorJoint_get_class_type_511_comment},
  {"getClassType", &Dtool_OdeLMotorJoint_get_class_type_511, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeLMotorJoint_get_class_type_511_comment},
  {"get_axes", (PyCFunction) &MakeSeq_OdeLMotorJoint_get_axes, METH_NOARGS, nullptr},
  { "getAxes", (PyCFunction) &MakeSeq_OdeLMotorJoint_get_axes, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeLMotorJoint = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeLMotorJoint = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeLMotorJoint = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeLMotorJoint = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeLMotorJoint = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeLMotorJoint = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeLMotorJoint",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeLMotorJoint,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeLMotorJoint,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeLMotorJoint,
    &Dtool_SequenceMethods_OdeLMotorJoint,
    &Dtool_MappingMethods_OdeLMotorJoint,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeLMotorJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeLMotorJoint,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeLMotorJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeLMotorJoint,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeLMotorJoint,
  Dtool_UpcastInterface_OdeLMotorJoint,
  Dtool_DowncastInterface_OdeLMotorJoint,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeLMotorJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(nullptr);
    Dtool_OdeLMotorJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    Dtool_OdeLMotorJoint._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeLMotorJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeLMotorJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeLMotorJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeLMotorJoint);
  }
}

/**
 * Python method tables for OdeNullJoint (OdeNullJoint)
 */
static PyMethodDef Dtool_Methods_OdeNullJoint[] = {
  {"get_class_type", &Dtool_OdeNullJoint_get_class_type_514, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeNullJoint_get_class_type_514_comment},
  {"getClassType", &Dtool_OdeNullJoint_get_class_type_514, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeNullJoint_get_class_type_514_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeNullJoint = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeNullJoint = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeNullJoint = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeNullJoint = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeNullJoint = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeNullJoint = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeNullJoint",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeNullJoint,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeNullJoint,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeNullJoint,
    &Dtool_SequenceMethods_OdeNullJoint,
    &Dtool_MappingMethods_OdeNullJoint,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeNullJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeNullJoint,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeNullJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeNullJoint,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeNullJoint,
  Dtool_UpcastInterface_OdeNullJoint,
  Dtool_DowncastInterface_OdeNullJoint,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeNullJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(nullptr);
    Dtool_OdeNullJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    Dtool_OdeNullJoint._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeNullJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeNullJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeNullJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeNullJoint);
  }
}

/**
 * Python method tables for OdePlane2dJoint (OdePlane2dJoint)
 */
static PyMethodDef Dtool_Methods_OdePlane2dJoint[] = {
  {"set_x_param", (PyCFunction) &Dtool_OdePlane2dJoint_set_x_param_517, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlane2dJoint_set_x_param_517_comment},
  {"setXParam", (PyCFunction) &Dtool_OdePlane2dJoint_set_x_param_517, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlane2dJoint_set_x_param_517_comment},
  {"set_y_param", (PyCFunction) &Dtool_OdePlane2dJoint_set_y_param_518, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlane2dJoint_set_y_param_518_comment},
  {"setYParam", (PyCFunction) &Dtool_OdePlane2dJoint_set_y_param_518, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlane2dJoint_set_y_param_518_comment},
  {"set_angle_param", (PyCFunction) &Dtool_OdePlane2dJoint_set_angle_param_519, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlane2dJoint_set_angle_param_519_comment},
  {"setAngleParam", (PyCFunction) &Dtool_OdePlane2dJoint_set_angle_param_519, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlane2dJoint_set_angle_param_519_comment},
  {"get_class_type", &Dtool_OdePlane2dJoint_get_class_type_520, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdePlane2dJoint_get_class_type_520_comment},
  {"getClassType", &Dtool_OdePlane2dJoint_get_class_type_520, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdePlane2dJoint_get_class_type_520_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdePlane2dJoint = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdePlane2dJoint = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdePlane2dJoint = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdePlane2dJoint = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdePlane2dJoint = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdePlane2dJoint = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdePlane2dJoint",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdePlane2dJoint,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdePlane2dJoint,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdePlane2dJoint,
    &Dtool_SequenceMethods_OdePlane2dJoint,
    &Dtool_MappingMethods_OdePlane2dJoint,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdePlane2dJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdePlane2dJoint,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdePlane2dJoint,
    PyType_GenericAlloc,
    Dtool_new_OdePlane2dJoint,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdePlane2dJoint,
  Dtool_UpcastInterface_OdePlane2dJoint,
  Dtool_DowncastInterface_OdePlane2dJoint,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdePlane2dJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(nullptr);
    Dtool_OdePlane2dJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    Dtool_OdePlane2dJoint._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdePlane2dJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdePlane2dJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdePlane2dJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdePlane2dJoint);
  }
}

/**
 * Python method tables for OdePlaneGeom (OdePlaneGeom)
 */
static PyMethodDef Dtool_Methods_OdePlaneGeom[] = {
  {"set_params", (PyCFunction) &Dtool_OdePlaneGeom_set_params_523, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlaneGeom_set_params_523_comment},
  {"setParams", (PyCFunction) &Dtool_OdePlaneGeom_set_params_523, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlaneGeom_set_params_523_comment},
  {"get_params", &Dtool_OdePlaneGeom_get_params_524, METH_NOARGS, (const char *)Dtool_OdePlaneGeom_get_params_524_comment},
  {"getParams", &Dtool_OdePlaneGeom_get_params_524, METH_NOARGS, (const char *)Dtool_OdePlaneGeom_get_params_524_comment},
  {"get_point_depth", (PyCFunction) &Dtool_OdePlaneGeom_get_point_depth_525, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlaneGeom_get_point_depth_525_comment},
  {"getPointDepth", (PyCFunction) &Dtool_OdePlaneGeom_get_point_depth_525, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdePlaneGeom_get_point_depth_525_comment},
  {"get_class_type", &Dtool_OdePlaneGeom_get_class_type_526, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdePlaneGeom_get_class_type_526_comment},
  {"getClassType", &Dtool_OdePlaneGeom_get_class_type_526, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdePlaneGeom_get_class_type_526_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdePlaneGeom = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdePlaneGeom = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdePlaneGeom = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdePlaneGeom = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdePlaneGeom = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdePlaneGeom = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdePlaneGeom",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdePlaneGeom,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdePlaneGeom,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdePlaneGeom,
    &Dtool_SequenceMethods_OdePlaneGeom,
    &Dtool_MappingMethods_OdePlaneGeom,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdePlaneGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdePlaneGeom,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdePlaneGeom,
    PyType_GenericAlloc,
    Dtool_new_OdePlaneGeom,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdePlaneGeom,
  Dtool_UpcastInterface_OdePlaneGeom,
  Dtool_DowncastInterface_OdePlaneGeom,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdePlaneGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeGeom(nullptr);
    Dtool_OdePlaneGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeGeom);
    Dtool_OdePlaneGeom._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdePlaneGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdePlaneGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdePlaneGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdePlaneGeom);
  }
}

/**
 * Python method tables for OdeQuadTreeSpace (OdeQuadTreeSpace)
 */
static PyMethodDef Dtool_Methods_OdeQuadTreeSpace[] = {
  {"get_class_type", &Dtool_OdeQuadTreeSpace_get_class_type_529, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeQuadTreeSpace_get_class_type_529_comment},
  {"getClassType", &Dtool_OdeQuadTreeSpace_get_class_type_529, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeQuadTreeSpace_get_class_type_529_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeQuadTreeSpace = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeQuadTreeSpace = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeQuadTreeSpace = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeQuadTreeSpace = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeQuadTreeSpace = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeQuadTreeSpace = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeQuadTreeSpace",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeQuadTreeSpace,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeQuadTreeSpace,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeQuadTreeSpace,
    &Dtool_SequenceMethods_OdeQuadTreeSpace,
    &Dtool_MappingMethods_OdeQuadTreeSpace,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeQuadTreeSpace,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeQuadTreeSpace,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeQuadTreeSpace,
    PyType_GenericAlloc,
    Dtool_new_OdeQuadTreeSpace,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeQuadTreeSpace,
  Dtool_UpcastInterface_OdeQuadTreeSpace,
  Dtool_DowncastInterface_OdeQuadTreeSpace,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeQuadTreeSpace(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeSpace(nullptr);
    Dtool_OdeQuadTreeSpace._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeSpace);
    Dtool_OdeQuadTreeSpace._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeQuadTreeSpace._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeQuadTreeSpace) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeQuadTreeSpace)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeQuadTreeSpace);
  }
}

/**
 * Python method tables for OdeRayGeom (OdeRayGeom)
 */
static PyMethodDef Dtool_Methods_OdeRayGeom[] = {
  {"set_length", &Dtool_OdeRayGeom_set_length_532, METH_O, (const char *)Dtool_OdeRayGeom_set_length_532_comment},
  {"setLength", &Dtool_OdeRayGeom_set_length_532, METH_O, (const char *)Dtool_OdeRayGeom_set_length_532_comment},
  {"get_length", &Dtool_OdeRayGeom_get_length_533, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_length_533_comment},
  {"getLength", &Dtool_OdeRayGeom_get_length_533, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_length_533_comment},
  {"set", (PyCFunction) &Dtool_OdeRayGeom_set_534, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeRayGeom_set_534_comment},
  {"get", (PyCFunction) &Dtool_OdeRayGeom_get_535, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeRayGeom_get_535_comment},
  {"get_start", &Dtool_OdeRayGeom_get_start_536, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_start_536_comment},
  {"getStart", &Dtool_OdeRayGeom_get_start_536, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_start_536_comment},
  {"get_direction", &Dtool_OdeRayGeom_get_direction_537, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_direction_537_comment},
  {"getDirection", &Dtool_OdeRayGeom_get_direction_537, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_direction_537_comment},
  {"set_params", (PyCFunction) &Dtool_OdeRayGeom_set_params_538, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeRayGeom_set_params_538_comment},
  {"setParams", (PyCFunction) &Dtool_OdeRayGeom_set_params_538, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeRayGeom_set_params_538_comment},
  {"get_first_contact", &Dtool_OdeRayGeom_get_first_contact_540, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_first_contact_540_comment},
  {"getFirstContact", &Dtool_OdeRayGeom_get_first_contact_540, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_first_contact_540_comment},
  {"get_backface_cull", &Dtool_OdeRayGeom_get_backface_cull_541, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_backface_cull_541_comment},
  {"getBackfaceCull", &Dtool_OdeRayGeom_get_backface_cull_541, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_backface_cull_541_comment},
  {"set_closest_hit", &Dtool_OdeRayGeom_set_closest_hit_542, METH_O, (const char *)Dtool_OdeRayGeom_set_closest_hit_542_comment},
  {"setClosestHit", &Dtool_OdeRayGeom_set_closest_hit_542, METH_O, (const char *)Dtool_OdeRayGeom_set_closest_hit_542_comment},
  {"get_closest_hit", &Dtool_OdeRayGeom_get_closest_hit_543, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_closest_hit_543_comment},
  {"getClosestHit", &Dtool_OdeRayGeom_get_closest_hit_543, METH_NOARGS, (const char *)Dtool_OdeRayGeom_get_closest_hit_543_comment},
  {"get_class_type", &Dtool_OdeRayGeom_get_class_type_544, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeRayGeom_get_class_type_544_comment},
  {"getClassType", &Dtool_OdeRayGeom_get_class_type_544, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeRayGeom_get_class_type_544_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeRayGeom = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeRayGeom = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeRayGeom = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeRayGeom = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeRayGeom = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeRayGeom = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeRayGeom",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeRayGeom,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeRayGeom,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeRayGeom,
    &Dtool_SequenceMethods_OdeRayGeom,
    &Dtool_MappingMethods_OdeRayGeom,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeRayGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeRayGeom,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeRayGeom,
    PyType_GenericAlloc,
    Dtool_new_OdeRayGeom,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeRayGeom,
  Dtool_UpcastInterface_OdeRayGeom,
  Dtool_DowncastInterface_OdeRayGeom,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeRayGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeGeom(nullptr);
    Dtool_OdeRayGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeGeom);
    Dtool_OdeRayGeom._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeRayGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeRayGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeRayGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeRayGeom);
  }
}

/**
 * Python method tables for OdeSimpleSpace (OdeSimpleSpace)
 */
static PyMethodDef Dtool_Methods_OdeSimpleSpace[] = {
  {"get_class_type", &Dtool_OdeSimpleSpace_get_class_type_547, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSimpleSpace_get_class_type_547_comment},
  {"getClassType", &Dtool_OdeSimpleSpace_get_class_type_547, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSimpleSpace_get_class_type_547_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeSimpleSpace = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeSimpleSpace = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeSimpleSpace = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeSimpleSpace = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeSimpleSpace = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeSimpleSpace = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeSimpleSpace",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeSimpleSpace,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeSimpleSpace,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeSimpleSpace,
    &Dtool_SequenceMethods_OdeSimpleSpace,
    &Dtool_MappingMethods_OdeSimpleSpace,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeSimpleSpace,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeSimpleSpace,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeSimpleSpace,
    PyType_GenericAlloc,
    Dtool_new_OdeSimpleSpace,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeSimpleSpace,
  Dtool_UpcastInterface_OdeSimpleSpace,
  Dtool_DowncastInterface_OdeSimpleSpace,
  nullptr,
  (CoerceFunction)Dtool_Coerce_OdeSimpleSpace,
};

static void Dtool_PyModuleClassInit_OdeSimpleSpace(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeSpace(nullptr);
    Dtool_OdeSimpleSpace._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeSpace);
    Dtool_OdeSimpleSpace._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeSimpleSpace._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeSimpleSpace) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeSimpleSpace)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeSimpleSpace);
  }
}

/**
 * Python method tables for OdeSliderJoint (OdeSliderJoint)
 */
static PyMethodDef Dtool_Methods_OdeSliderJoint[] = {
  {"set_axis", (PyCFunction) &Dtool_OdeSliderJoint_set_axis_550, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSliderJoint_set_axis_550_comment},
  {"setAxis", (PyCFunction) &Dtool_OdeSliderJoint_set_axis_550, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSliderJoint_set_axis_550_comment},
  {"set_axis_delta", (PyCFunction) &Dtool_OdeSliderJoint_set_axis_delta_551, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSliderJoint_set_axis_delta_551_comment},
  {"setAxisDelta", (PyCFunction) &Dtool_OdeSliderJoint_set_axis_delta_551, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSliderJoint_set_axis_delta_551_comment},
  {"add_force", &Dtool_OdeSliderJoint_add_force_552, METH_O, (const char *)Dtool_OdeSliderJoint_add_force_552_comment},
  {"addForce", &Dtool_OdeSliderJoint_add_force_552, METH_O, (const char *)Dtool_OdeSliderJoint_add_force_552_comment},
  {"get_position", &Dtool_OdeSliderJoint_get_position_553, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_position_553_comment},
  {"getPosition", &Dtool_OdeSliderJoint_get_position_553, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_position_553_comment},
  {"get_position_rate", &Dtool_OdeSliderJoint_get_position_rate_554, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_position_rate_554_comment},
  {"getPositionRate", &Dtool_OdeSliderJoint_get_position_rate_554, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_position_rate_554_comment},
  {"get_axis", &Dtool_OdeSliderJoint_get_axis_555, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_axis_555_comment},
  {"getAxis", &Dtool_OdeSliderJoint_get_axis_555, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_axis_555_comment},
  {"set_param_lo_stop", &Dtool_OdeSliderJoint_set_param_lo_stop_556, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_lo_stop_556_comment},
  {"setParamLoStop", &Dtool_OdeSliderJoint_set_param_lo_stop_556, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_lo_stop_556_comment},
  {"set_param_hi_stop", &Dtool_OdeSliderJoint_set_param_hi_stop_557, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_hi_stop_557_comment},
  {"setParamHiStop", &Dtool_OdeSliderJoint_set_param_hi_stop_557, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_hi_stop_557_comment},
  {"set_param_vel", &Dtool_OdeSliderJoint_set_param_vel_558, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_vel_558_comment},
  {"setParamVel", &Dtool_OdeSliderJoint_set_param_vel_558, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_vel_558_comment},
  {"set_param_f_max", &Dtool_OdeSliderJoint_set_param_f_max_559, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_f_max_559_comment},
  {"setParamFMax", &Dtool_OdeSliderJoint_set_param_f_max_559, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_f_max_559_comment},
  {"set_param_fudge_factor", &Dtool_OdeSliderJoint_set_param_fudge_factor_560, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_fudge_factor_560_comment},
  {"setParamFudgeFactor", &Dtool_OdeSliderJoint_set_param_fudge_factor_560, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_fudge_factor_560_comment},
  {"set_param_bounce", &Dtool_OdeSliderJoint_set_param_bounce_561, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_bounce_561_comment},
  {"setParamBounce", &Dtool_OdeSliderJoint_set_param_bounce_561, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_bounce_561_comment},
  {"set_param_CFM", &Dtool_OdeSliderJoint_set_param_CFM_562, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_CFM_562_comment},
  {"setParamCFM", &Dtool_OdeSliderJoint_set_param_CFM_562, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_CFM_562_comment},
  {"set_param_stop_ERP", &Dtool_OdeSliderJoint_set_param_stop_ERP_563, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_stop_ERP_563_comment},
  {"setParamStopERP", &Dtool_OdeSliderJoint_set_param_stop_ERP_563, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_stop_ERP_563_comment},
  {"set_param_stop_CFM", &Dtool_OdeSliderJoint_set_param_stop_CFM_564, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_stop_CFM_564_comment},
  {"setParamStopCFM", &Dtool_OdeSliderJoint_set_param_stop_CFM_564, METH_O, (const char *)Dtool_OdeSliderJoint_set_param_stop_CFM_564_comment},
  {"get_param_lo_stop", &Dtool_OdeSliderJoint_get_param_lo_stop_565, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_lo_stop_565_comment},
  {"getParamLoStop", &Dtool_OdeSliderJoint_get_param_lo_stop_565, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_lo_stop_565_comment},
  {"get_param_hi_stop", &Dtool_OdeSliderJoint_get_param_hi_stop_566, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_hi_stop_566_comment},
  {"getParamHiStop", &Dtool_OdeSliderJoint_get_param_hi_stop_566, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_hi_stop_566_comment},
  {"get_param_vel", &Dtool_OdeSliderJoint_get_param_vel_567, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_vel_567_comment},
  {"getParamVel", &Dtool_OdeSliderJoint_get_param_vel_567, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_vel_567_comment},
  {"get_param_f_max", &Dtool_OdeSliderJoint_get_param_f_max_568, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_f_max_568_comment},
  {"getParamFMax", &Dtool_OdeSliderJoint_get_param_f_max_568, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_f_max_568_comment},
  {"get_param_fudge_factor", &Dtool_OdeSliderJoint_get_param_fudge_factor_569, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_fudge_factor_569_comment},
  {"getParamFudgeFactor", &Dtool_OdeSliderJoint_get_param_fudge_factor_569, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_fudge_factor_569_comment},
  {"get_param_bounce", &Dtool_OdeSliderJoint_get_param_bounce_570, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_bounce_570_comment},
  {"getParamBounce", &Dtool_OdeSliderJoint_get_param_bounce_570, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_bounce_570_comment},
  {"get_param_CFM", &Dtool_OdeSliderJoint_get_param_CFM_571, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_CFM_571_comment},
  {"getParamCFM", &Dtool_OdeSliderJoint_get_param_CFM_571, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_CFM_571_comment},
  {"get_param_stop_ERP", &Dtool_OdeSliderJoint_get_param_stop_ERP_572, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_stop_ERP_572_comment},
  {"getParamStopERP", &Dtool_OdeSliderJoint_get_param_stop_ERP_572, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_stop_ERP_572_comment},
  {"get_param_stop_CFM", &Dtool_OdeSliderJoint_get_param_stop_CFM_573, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_stop_CFM_573_comment},
  {"getParamStopCFM", &Dtool_OdeSliderJoint_get_param_stop_CFM_573, METH_NOARGS, (const char *)Dtool_OdeSliderJoint_get_param_stop_CFM_573_comment},
  {"get_class_type", &Dtool_OdeSliderJoint_get_class_type_574, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSliderJoint_get_class_type_574_comment},
  {"getClassType", &Dtool_OdeSliderJoint_get_class_type_574, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSliderJoint_get_class_type_574_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeSliderJoint = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeSliderJoint = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeSliderJoint = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeSliderJoint = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeSliderJoint = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeSliderJoint = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeSliderJoint",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeSliderJoint,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeSliderJoint,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeSliderJoint,
    &Dtool_SequenceMethods_OdeSliderJoint,
    &Dtool_MappingMethods_OdeSliderJoint,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeSliderJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeSliderJoint,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeSliderJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeSliderJoint,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeSliderJoint,
  Dtool_UpcastInterface_OdeSliderJoint,
  Dtool_DowncastInterface_OdeSliderJoint,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeSliderJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(nullptr);
    Dtool_OdeSliderJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    Dtool_OdeSliderJoint._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeSliderJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeSliderJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeSliderJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeSliderJoint);
  }
}

/**
 * Python method tables for OdeSphereGeom (OdeSphereGeom)
 */
static PyMethodDef Dtool_Methods_OdeSphereGeom[] = {
  {"set_radius", &Dtool_OdeSphereGeom_set_radius_577, METH_O, (const char *)Dtool_OdeSphereGeom_set_radius_577_comment},
  {"setRadius", &Dtool_OdeSphereGeom_set_radius_577, METH_O, (const char *)Dtool_OdeSphereGeom_set_radius_577_comment},
  {"get_radius", &Dtool_OdeSphereGeom_get_radius_578, METH_NOARGS, (const char *)Dtool_OdeSphereGeom_get_radius_578_comment},
  {"getRadius", &Dtool_OdeSphereGeom_get_radius_578, METH_NOARGS, (const char *)Dtool_OdeSphereGeom_get_radius_578_comment},
  {"get_point_depth", (PyCFunction) &Dtool_OdeSphereGeom_get_point_depth_579, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSphereGeom_get_point_depth_579_comment},
  {"getPointDepth", (PyCFunction) &Dtool_OdeSphereGeom_get_point_depth_579, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeSphereGeom_get_point_depth_579_comment},
  {"get_class_type", &Dtool_OdeSphereGeom_get_class_type_580, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSphereGeom_get_class_type_580_comment},
  {"getClassType", &Dtool_OdeSphereGeom_get_class_type_580, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeSphereGeom_get_class_type_580_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeSphereGeom = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeSphereGeom = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeSphereGeom = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeSphereGeom = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeSphereGeom = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeSphereGeom = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeSphereGeom",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeSphereGeom,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeSphereGeom,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeSphereGeom,
    &Dtool_SequenceMethods_OdeSphereGeom,
    &Dtool_MappingMethods_OdeSphereGeom,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeSphereGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeSphereGeom,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeSphereGeom,
    PyType_GenericAlloc,
    Dtool_new_OdeSphereGeom,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeSphereGeom,
  Dtool_UpcastInterface_OdeSphereGeom,
  Dtool_DowncastInterface_OdeSphereGeom,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeSphereGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeGeom(nullptr);
    Dtool_OdeSphereGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeGeom);
    Dtool_OdeSphereGeom._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeSphereGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeSphereGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeSphereGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeSphereGeom);
  }
}

/**
 * Python method tables for OdeTriMeshData (OdeTriMeshData)
 */
static PyMethodDef Dtool_Methods_OdeTriMeshData[] = {
  {"destroy", &Dtool_OdeTriMeshData_destroy_584, METH_NOARGS, (const char *)Dtool_OdeTriMeshData_destroy_584_comment},
  {"write", (PyCFunction) &Dtool_OdeTriMeshData_write_585, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeTriMeshData_write_585_comment},
  {"write_faces", &Dtool_OdeTriMeshData_write_faces_586, METH_O, (const char *)Dtool_OdeTriMeshData_write_faces_586_comment},
  {"writeFaces", &Dtool_OdeTriMeshData_write_faces_586, METH_O, (const char *)Dtool_OdeTriMeshData_write_faces_586_comment},
  {"get_class_type", &Dtool_OdeTriMeshData_get_class_type_587, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeTriMeshData_get_class_type_587_comment},
  {"getClassType", &Dtool_OdeTriMeshData_get_class_type_587, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeTriMeshData_get_class_type_587_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     OdeTriMeshData
//////////////////
static PyObject *Dtool_Str_OdeTriMeshData(PyObject *self) {
  OdeTriMeshData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_OdeTriMeshData, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_OdeTriMeshData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeTriMeshData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeTriMeshData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeTriMeshData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeTriMeshData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeTriMeshData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeTriMeshData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeTriMeshData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeTriMeshData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeTriMeshData,
    &Dtool_SequenceMethods_OdeTriMeshData,
    &Dtool_MappingMethods_OdeTriMeshData,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_OdeTriMeshData,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeTriMeshData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeTriMeshData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeTriMeshData,
    PyType_GenericAlloc,
    Dtool_new_OdeTriMeshData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeTriMeshData,
  Dtool_UpcastInterface_OdeTriMeshData,
  Dtool_DowncastInterface_OdeTriMeshData,
  (CoerceFunction)Dtool_ConstCoerce_OdeTriMeshData,
  (CoerceFunction)Dtool_Coerce_OdeTriMeshData,
};

static void Dtool_PyModuleClassInit_OdeTriMeshData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_OdeTriMeshData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_OdeTriMeshData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeTriMeshData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum OdeTriMeshData::DataType;
    PyDict_SetItemString(dict, "DT_face_normals", Dtool_WrapValue(OdeTriMeshData::DT_face_normals));
    PyDict_SetItemString(dict, "DTFaceNormals", Dtool_WrapValue(OdeTriMeshData::DT_face_normals));
    PyDict_SetItemString(dict, "DT_last_transformation", Dtool_WrapValue(OdeTriMeshData::DT_last_transformation));
    PyDict_SetItemString(dict, "DTLastTransformation", Dtool_WrapValue(OdeTriMeshData::DT_last_transformation));
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeTriMeshData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeTriMeshData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeTriMeshData);
  }
}

/**
 * Python method tables for OdeTriMeshGeom (OdeTriMeshGeom)
 */
static PyMethodDef Dtool_Methods_OdeTriMeshGeom[] = {
  {"destroy", &Dtool_OdeTriMeshGeom_destroy_590, METH_NOARGS, (const char *)Dtool_OdeTriMeshGeom_destroy_590_comment},
  {"set_tri_mesh_data", &Dtool_OdeTriMeshGeom_set_tri_mesh_data_591, METH_O, (const char *)Dtool_OdeTriMeshGeom_set_tri_mesh_data_591_comment},
  {"setTriMeshData", &Dtool_OdeTriMeshGeom_set_tri_mesh_data_591, METH_O, (const char *)Dtool_OdeTriMeshGeom_set_tri_mesh_data_591_comment},
  {"get_tri_mesh_data", &Dtool_OdeTriMeshGeom_get_tri_mesh_data_592, METH_NOARGS, (const char *)Dtool_OdeTriMeshGeom_get_tri_mesh_data_592_comment},
  {"getTriMeshData", &Dtool_OdeTriMeshGeom_get_tri_mesh_data_592, METH_NOARGS, (const char *)Dtool_OdeTriMeshGeom_get_tri_mesh_data_592_comment},
  {"set_data", &Dtool_OdeTriMeshGeom_set_data_593, METH_O, (const char *)Dtool_OdeTriMeshGeom_set_data_593_comment},
  {"setData", &Dtool_OdeTriMeshGeom_set_data_593, METH_O, (const char *)Dtool_OdeTriMeshGeom_set_data_593_comment},
  {"get_data", &Dtool_OdeTriMeshGeom_get_data_594, METH_NOARGS, (const char *)Dtool_OdeTriMeshGeom_get_data_594_comment},
  {"getData", &Dtool_OdeTriMeshGeom_get_data_594, METH_NOARGS, (const char *)Dtool_OdeTriMeshGeom_get_data_594_comment},
  {"enable_TC", (PyCFunction) &Dtool_OdeTriMeshGeom_enable_TC_595, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeTriMeshGeom_enable_TC_595_comment},
  {"enableTC", (PyCFunction) &Dtool_OdeTriMeshGeom_enable_TC_595, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeTriMeshGeom_enable_TC_595_comment},
  {"is_TC_enabled", &Dtool_OdeTriMeshGeom_is_TC_enabled_596, METH_O, (const char *)Dtool_OdeTriMeshGeom_is_TC_enabled_596_comment},
  {"isTCEnabled", &Dtool_OdeTriMeshGeom_is_TC_enabled_596, METH_O, (const char *)Dtool_OdeTriMeshGeom_is_TC_enabled_596_comment},
  {"clear_TC_cache", &Dtool_OdeTriMeshGeom_clear_TC_cache_597, METH_O, (const char *)Dtool_OdeTriMeshGeom_clear_TC_cache_597_comment},
  {"clearTCCache", &Dtool_OdeTriMeshGeom_clear_TC_cache_597, METH_O, (const char *)Dtool_OdeTriMeshGeom_clear_TC_cache_597_comment},
  {"get_triangle", (PyCFunction) &Dtool_OdeTriMeshGeom_get_triangle_598, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeTriMeshGeom_get_triangle_598_comment},
  {"getTriangle", (PyCFunction) &Dtool_OdeTriMeshGeom_get_triangle_598, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeTriMeshGeom_get_triangle_598_comment},
  {"get_point", (PyCFunction) &Dtool_OdeTriMeshGeom_get_point_599, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeTriMeshGeom_get_point_599_comment},
  {"getPoint", (PyCFunction) &Dtool_OdeTriMeshGeom_get_point_599, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeTriMeshGeom_get_point_599_comment},
  {"get_num_triangles", &Dtool_OdeTriMeshGeom_get_num_triangles_600, METH_NOARGS, (const char *)Dtool_OdeTriMeshGeom_get_num_triangles_600_comment},
  {"getNumTriangles", &Dtool_OdeTriMeshGeom_get_num_triangles_600, METH_NOARGS, (const char *)Dtool_OdeTriMeshGeom_get_num_triangles_600_comment},
  {"get_class_type", &Dtool_OdeTriMeshGeom_get_class_type_601, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeTriMeshGeom_get_class_type_601_comment},
  {"getClassType", &Dtool_OdeTriMeshGeom_get_class_type_601, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeTriMeshGeom_get_class_type_601_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeTriMeshGeom = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeTriMeshGeom = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeTriMeshGeom = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeTriMeshGeom = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeTriMeshGeom = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeTriMeshGeom = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeTriMeshGeom",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeTriMeshGeom,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeTriMeshGeom,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeTriMeshGeom,
    &Dtool_SequenceMethods_OdeTriMeshGeom,
    &Dtool_MappingMethods_OdeTriMeshGeom,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeTriMeshGeom,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeTriMeshGeom,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeTriMeshGeom,
    PyType_GenericAlloc,
    Dtool_new_OdeTriMeshGeom,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeTriMeshGeom,
  Dtool_UpcastInterface_OdeTriMeshGeom,
  Dtool_DowncastInterface_OdeTriMeshGeom,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeTriMeshGeom(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeGeom(nullptr);
    Dtool_OdeTriMeshGeom._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeGeom);
    Dtool_OdeTriMeshGeom._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeTriMeshGeom._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeTriMeshGeom) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeTriMeshGeom)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeTriMeshGeom);
  }
}

/**
 * Python method tables for OdeUniversalJoint (OdeUniversalJoint)
 */
static PyMethodDef Dtool_Methods_OdeUniversalJoint[] = {
  {"set_anchor", (PyCFunction) &Dtool_OdeUniversalJoint_set_anchor_604, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_anchor_604_comment},
  {"setAnchor", (PyCFunction) &Dtool_OdeUniversalJoint_set_anchor_604, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_anchor_604_comment},
  {"set_axis1", (PyCFunction) &Dtool_OdeUniversalJoint_set_axis1_605, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_axis1_605_comment},
  {"setAxis1", (PyCFunction) &Dtool_OdeUniversalJoint_set_axis1_605, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_axis1_605_comment},
  {"set_axis2", (PyCFunction) &Dtool_OdeUniversalJoint_set_axis2_606, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_axis2_606_comment},
  {"setAxis2", (PyCFunction) &Dtool_OdeUniversalJoint_set_axis2_606, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_axis2_606_comment},
  {"add_torques", (PyCFunction) &Dtool_OdeUniversalJoint_add_torques_607, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_add_torques_607_comment},
  {"addTorques", (PyCFunction) &Dtool_OdeUniversalJoint_add_torques_607, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_add_torques_607_comment},
  {"get_anchor", &Dtool_OdeUniversalJoint_get_anchor_608, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_anchor_608_comment},
  {"getAnchor", &Dtool_OdeUniversalJoint_get_anchor_608, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_anchor_608_comment},
  {"get_anchor2", &Dtool_OdeUniversalJoint_get_anchor2_609, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_anchor2_609_comment},
  {"getAnchor2", &Dtool_OdeUniversalJoint_get_anchor2_609, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_anchor2_609_comment},
  {"get_axis1", &Dtool_OdeUniversalJoint_get_axis1_610, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_axis1_610_comment},
  {"getAxis1", &Dtool_OdeUniversalJoint_get_axis1_610, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_axis1_610_comment},
  {"get_axis2", &Dtool_OdeUniversalJoint_get_axis2_611, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_axis2_611_comment},
  {"getAxis2", &Dtool_OdeUniversalJoint_get_axis2_611, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_axis2_611_comment},
  {"get_angle1", &Dtool_OdeUniversalJoint_get_angle1_612, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_angle1_612_comment},
  {"getAngle1", &Dtool_OdeUniversalJoint_get_angle1_612, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_angle1_612_comment},
  {"get_angle2", &Dtool_OdeUniversalJoint_get_angle2_613, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_angle2_613_comment},
  {"getAngle2", &Dtool_OdeUniversalJoint_get_angle2_613, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_angle2_613_comment},
  {"get_angle1_rate", &Dtool_OdeUniversalJoint_get_angle1_rate_614, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_angle1_rate_614_comment},
  {"getAngle1Rate", &Dtool_OdeUniversalJoint_get_angle1_rate_614, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_angle1_rate_614_comment},
  {"get_angle2_rate", &Dtool_OdeUniversalJoint_get_angle2_rate_615, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_angle2_rate_615_comment},
  {"getAngle2Rate", &Dtool_OdeUniversalJoint_get_angle2_rate_615, METH_NOARGS, (const char *)Dtool_OdeUniversalJoint_get_angle2_rate_615_comment},
  {"set_param_lo_stop", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_lo_stop_616, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_lo_stop_616_comment},
  {"setParamLoStop", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_lo_stop_616, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_lo_stop_616_comment},
  {"set_param_hi_stop", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_hi_stop_617, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_hi_stop_617_comment},
  {"setParamHiStop", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_hi_stop_617, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_hi_stop_617_comment},
  {"set_param_vel", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_vel_618, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_vel_618_comment},
  {"setParamVel", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_vel_618, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_vel_618_comment},
  {"set_param_f_max", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_f_max_619, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_f_max_619_comment},
  {"setParamFMax", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_f_max_619, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_f_max_619_comment},
  {"set_param_fudge_factor", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_fudge_factor_620, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_fudge_factor_620_comment},
  {"setParamFudgeFactor", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_fudge_factor_620, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_fudge_factor_620_comment},
  {"set_param_bounce", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_bounce_621, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_bounce_621_comment},
  {"setParamBounce", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_bounce_621, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_bounce_621_comment},
  {"set_param_CFM", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_CFM_622, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_CFM_622_comment},
  {"setParamCFM", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_CFM_622, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_CFM_622_comment},
  {"set_param_stop_ERP", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_stop_ERP_623, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_stop_ERP_623_comment},
  {"setParamStopERP", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_stop_ERP_623, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_stop_ERP_623_comment},
  {"set_param_stop_CFM", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_stop_CFM_624, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_stop_CFM_624_comment},
  {"setParamStopCFM", (PyCFunction) &Dtool_OdeUniversalJoint_set_param_stop_CFM_624, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_OdeUniversalJoint_set_param_stop_CFM_624_comment},
  {"get_param_lo_stop", &Dtool_OdeUniversalJoint_get_param_lo_stop_625, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_lo_stop_625_comment},
  {"getParamLoStop", &Dtool_OdeUniversalJoint_get_param_lo_stop_625, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_lo_stop_625_comment},
  {"get_param_hi_stop", &Dtool_OdeUniversalJoint_get_param_hi_stop_626, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_hi_stop_626_comment},
  {"getParamHiStop", &Dtool_OdeUniversalJoint_get_param_hi_stop_626, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_hi_stop_626_comment},
  {"get_param_vel", &Dtool_OdeUniversalJoint_get_param_vel_627, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_vel_627_comment},
  {"getParamVel", &Dtool_OdeUniversalJoint_get_param_vel_627, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_vel_627_comment},
  {"get_param_f_max", &Dtool_OdeUniversalJoint_get_param_f_max_628, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_f_max_628_comment},
  {"getParamFMax", &Dtool_OdeUniversalJoint_get_param_f_max_628, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_f_max_628_comment},
  {"get_param_fudge_factor", &Dtool_OdeUniversalJoint_get_param_fudge_factor_629, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_fudge_factor_629_comment},
  {"getParamFudgeFactor", &Dtool_OdeUniversalJoint_get_param_fudge_factor_629, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_fudge_factor_629_comment},
  {"get_param_bounce", &Dtool_OdeUniversalJoint_get_param_bounce_630, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_bounce_630_comment},
  {"getParamBounce", &Dtool_OdeUniversalJoint_get_param_bounce_630, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_bounce_630_comment},
  {"get_param_CFM", &Dtool_OdeUniversalJoint_get_param_CFM_631, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_CFM_631_comment},
  {"getParamCFM", &Dtool_OdeUniversalJoint_get_param_CFM_631, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_CFM_631_comment},
  {"get_param_stop_ERP", &Dtool_OdeUniversalJoint_get_param_stop_ERP_632, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_stop_ERP_632_comment},
  {"getParamStopERP", &Dtool_OdeUniversalJoint_get_param_stop_ERP_632, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_stop_ERP_632_comment},
  {"get_param_stop_CFM", &Dtool_OdeUniversalJoint_get_param_stop_CFM_633, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_stop_CFM_633_comment},
  {"getParamStopCFM", &Dtool_OdeUniversalJoint_get_param_stop_CFM_633, METH_O, (const char *)Dtool_OdeUniversalJoint_get_param_stop_CFM_633_comment},
  {"get_class_type", &Dtool_OdeUniversalJoint_get_class_type_634, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeUniversalJoint_get_class_type_634_comment},
  {"getClassType", &Dtool_OdeUniversalJoint_get_class_type_634, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeUniversalJoint_get_class_type_634_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeUniversalJoint = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_OdeUniversalJoint = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_OdeUniversalJoint = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_OdeUniversalJoint = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_OdeUniversalJoint = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_OdeUniversalJoint = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeUniversalJoint",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeUniversalJoint,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_OdeUniversalJoint,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeUniversalJoint,
    &Dtool_SequenceMethods_OdeUniversalJoint,
    &Dtool_MappingMethods_OdeUniversalJoint,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_OdeUniversalJoint,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeUniversalJoint,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeUniversalJoint,
    PyType_GenericAlloc,
    Dtool_new_OdeUniversalJoint,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeUniversalJoint,
  Dtool_UpcastInterface_OdeUniversalJoint,
  Dtool_DowncastInterface_OdeUniversalJoint,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeUniversalJoint(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_OdeJoint(nullptr);
    Dtool_OdeUniversalJoint._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_OdeJoint);
    Dtool_OdeUniversalJoint._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeUniversalJoint._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeUniversalJoint) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeUniversalJoint)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeUniversalJoint);
  }
}

/**
 * Python method tables for OdeUtil (OdeUtil)
 */
static PyMethodDef Dtool_Methods_OdeUtil[] = {
  {"get_connecting_joint", (PyCFunction) &Dtool_OdeUtil_get_connecting_joint_636, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_get_connecting_joint_636_comment},
  {"getConnectingJoint", (PyCFunction) &Dtool_OdeUtil_get_connecting_joint_636, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_get_connecting_joint_636_comment},
  {"get_connecting_joint_list", (PyCFunction) &Dtool_OdeUtil_get_connecting_joint_list_637, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_get_connecting_joint_list_637_comment},
  {"getConnectingJointList", (PyCFunction) &Dtool_OdeUtil_get_connecting_joint_list_637, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_get_connecting_joint_list_637_comment},
  {"are_connected", (PyCFunction) &Dtool_OdeUtil_are_connected_638, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_are_connected_638_comment},
  {"areConnected", (PyCFunction) &Dtool_OdeUtil_are_connected_638, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_are_connected_638_comment},
  {"are_connected_excluding", (PyCFunction) &Dtool_OdeUtil_are_connected_excluding_639, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_are_connected_excluding_639_comment},
  {"areConnectedExcluding", (PyCFunction) &Dtool_OdeUtil_are_connected_excluding_639, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_are_connected_excluding_639_comment},
  {"collide", (PyCFunction) &Dtool_OdeUtil_collide_640, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_collide_640_comment},
  {"collide2", (PyCFunction) &Dtool_OdeUtil_collide2_641, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_OdeUtil_collide2_641_comment},
  {"space_to_geom", &Dtool_OdeUtil_space_to_geom_642, METH_O | METH_STATIC, (const char *)Dtool_OdeUtil_space_to_geom_642_comment},
  {"spaceToGeom", &Dtool_OdeUtil_space_to_geom_642, METH_O | METH_STATIC, (const char *)Dtool_OdeUtil_space_to_geom_642_comment},
  {"get_infinity", &Dtool_OdeUtil_get_infinity_643, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeUtil_get_infinity_643_comment},
  {"getInfinity", &Dtool_OdeUtil_get_infinity_643, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeUtil_get_infinity_643_comment},
  {"rand_get_seed", &Dtool_OdeUtil_rand_get_seed_644, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeUtil_rand_get_seed_644_comment},
  {"randGetSeed", &Dtool_OdeUtil_rand_get_seed_644, METH_NOARGS | METH_STATIC, (const char *)Dtool_OdeUtil_rand_get_seed_644_comment},
  {"rand_set_seed", &Dtool_OdeUtil_rand_set_seed_645, METH_O | METH_STATIC, (const char *)Dtool_OdeUtil_rand_set_seed_645_comment},
  {"randSetSeed", &Dtool_OdeUtil_rand_set_seed_645, METH_O | METH_STATIC, (const char *)Dtool_OdeUtil_rand_set_seed_645_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_OdeUtil = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_OdeUtil = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.ode.OdeUtil",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_OdeUtil,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_OdeUtil,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_OdeUtil,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_OdeUtil,
    PyType_GenericAlloc,
    Dtool_new_OdeUtil,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_OdeUtil,
  Dtool_UpcastInterface_OdeUtil,
  Dtool_DowncastInterface_OdeUtil,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_OdeUtil(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_OdeUtil._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_OdeUtil._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_OdeUtil) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(OdeUtil)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_OdeUtil);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libpandaode_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    OdeWorld::init_type();
    TypeHandle handle = OdeWorld::get_class_type();
    Dtool_OdeWorld._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeWorld);
  }
  {
    OdeJointGroup::init_type();
    TypeHandle handle = OdeJointGroup::get_class_type();
    Dtool_OdeJointGroup._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeJointGroup);
  }
  {
    OdeJoint::init_type();
    TypeHandle handle = OdeJoint::get_class_type();
    Dtool_OdeJoint._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeJoint);
  }
  {
    OdeAMotorJoint::init_type();
    TypeHandle handle = OdeAMotorJoint::get_class_type();
    Dtool_OdeAMotorJoint._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeAMotorJoint);
  }
  {
    OdeBallJoint::init_type();
    TypeHandle handle = OdeBallJoint::get_class_type();
    Dtool_OdeBallJoint._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeBallJoint);
  }
  {
    OdeMass::init_type();
    TypeHandle handle = OdeMass::get_class_type();
    Dtool_OdeMass._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeMass);
  }
  {
    OdeBody::init_type();
    TypeHandle handle = OdeBody::get_class_type();
    Dtool_OdeBody._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeBody);
  }
  {
    OdeSpace::init_type();
    TypeHandle handle = OdeSpace::get_class_type();
    Dtool_OdeSpace._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeSpace);
  }
  {
    OdeGeom::init_type();
    TypeHandle handle = OdeGeom::get_class_type();
    Dtool_OdeGeom._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeGeom);
  }
  {
    OdeBoxGeom::init_type();
    TypeHandle handle = OdeBoxGeom::get_class_type();
    Dtool_OdeBoxGeom._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeBoxGeom);
  }
  {
    OdeCappedCylinderGeom::init_type();
    TypeHandle handle = OdeCappedCylinderGeom::get_class_type();
    Dtool_OdeCappedCylinderGeom._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeCappedCylinderGeom);
  }
  {
    OdeContactGeom::init_type();
    TypeHandle handle = OdeContactGeom::get_class_type();
    Dtool_OdeContactGeom._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeContactGeom);
  }
  {
    OdeCollisionEntry::init_type();
    TypeHandle handle = OdeCollisionEntry::get_class_type();
    Dtool_OdeCollisionEntry._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeCollisionEntry);
  }
  {
    OdeSurfaceParameters::init_type();
    TypeHandle handle = OdeSurfaceParameters::get_class_type();
    Dtool_OdeSurfaceParameters._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeSurfaceParameters);
  }
  {
    OdeContact::init_type();
    TypeHandle handle = OdeContact::get_class_type();
    Dtool_OdeContact._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeContact);
  }
  {
    OdeContactJoint::init_type();
    TypeHandle handle = OdeContactJoint::get_class_type();
    Dtool_OdeContactJoint._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeContactJoint);
  }
  {
    OdeCylinderGeom::init_type();
    TypeHandle handle = OdeCylinderGeom::get_class_type();
    Dtool_OdeCylinderGeom._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeCylinderGeom);
  }
  {
    OdeFixedJoint::init_type();
    TypeHandle handle = OdeFixedJoint::get_class_type();
    Dtool_OdeFixedJoint._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeFixedJoint);
  }
  {
    OdeHashSpace::init_type();
    TypeHandle handle = OdeHashSpace::get_class_type();
    Dtool_OdeHashSpace._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeHashSpace);
  }
  {
    OdeHinge2Joint::init_type();
    TypeHandle handle = OdeHinge2Joint::get_class_type();
    Dtool_OdeHinge2Joint._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeHinge2Joint);
  }
  {
    OdeHingeJoint::init_type();
    TypeHandle handle = OdeHingeJoint::get_class_type();
    Dtool_OdeHingeJoint._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeHingeJoint);
  }
  {
    OdeLMotorJoint::init_type();
    TypeHandle handle = OdeLMotorJoint::get_class_type();
    Dtool_OdeLMotorJoint._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeLMotorJoint);
  }
  {
    OdeNullJoint::init_type();
    TypeHandle handle = OdeNullJoint::get_class_type();
    Dtool_OdeNullJoint._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeNullJoint);
  }
  {
    OdePlane2dJoint::init_type();
    TypeHandle handle = OdePlane2dJoint::get_class_type();
    Dtool_OdePlane2dJoint._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdePlane2dJoint);
  }
  {
    OdePlaneGeom::init_type();
    TypeHandle handle = OdePlaneGeom::get_class_type();
    Dtool_OdePlaneGeom._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdePlaneGeom);
  }
  {
    OdeQuadTreeSpace::init_type();
    TypeHandle handle = OdeQuadTreeSpace::get_class_type();
    Dtool_OdeQuadTreeSpace._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeQuadTreeSpace);
  }
  {
    OdeRayGeom::init_type();
    TypeHandle handle = OdeRayGeom::get_class_type();
    Dtool_OdeRayGeom._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeRayGeom);
  }
  {
    OdeSimpleSpace::init_type();
    TypeHandle handle = OdeSimpleSpace::get_class_type();
    Dtool_OdeSimpleSpace._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeSimpleSpace);
  }
  {
    OdeSliderJoint::init_type();
    TypeHandle handle = OdeSliderJoint::get_class_type();
    Dtool_OdeSliderJoint._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeSliderJoint);
  }
  {
    OdeSphereGeom::init_type();
    TypeHandle handle = OdeSphereGeom::get_class_type();
    Dtool_OdeSphereGeom._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeSphereGeom);
  }
  {
    OdeTriMeshData::init_type();
    TypeHandle handle = OdeTriMeshData::get_class_type();
    Dtool_OdeTriMeshData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeTriMeshData);
  }
  {
    OdeTriMeshGeom::init_type();
    TypeHandle handle = OdeTriMeshGeom::get_class_type();
    Dtool_OdeTriMeshGeom._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeTriMeshGeom);
  }
  {
    OdeUniversalJoint::init_type();
    TypeHandle handle = OdeUniversalJoint::get_class_type();
    Dtool_OdeUniversalJoint._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_OdeUniversalJoint);
  }
}

void Dtool_libpandaode_BuildInstants(PyObject *module) {
  (void) module;
  // dxBody
  Dtool_PyModuleClassInit_dxBody(module);
  PyModule_AddObject(module, "dxBody", (PyObject *)&Dtool_dxBody);
  Py_INCREF(Dtool_Ptr_dxBody);
  PyModule_AddObject(module, "DxBody", (PyObject *)&Dtool_dxBody);
  // dxGeom
  Dtool_PyModuleClassInit_dxGeom(module);
  PyModule_AddObject(module, "dxGeom", (PyObject *)&Dtool_dxGeom);
  Py_INCREF(Dtool_Ptr_dxGeom);
  PyModule_AddObject(module, "DxGeom", (PyObject *)&Dtool_dxGeom);
  // dxJoint
  Dtool_PyModuleClassInit_dxJoint(module);
  PyModule_AddObject(module, "dxJoint", (PyObject *)&Dtool_dxJoint);
  Py_INCREF(Dtool_Ptr_dxJoint);
  PyModule_AddObject(module, "DxJoint", (PyObject *)&Dtool_dxJoint);
  // dxJointGroup
  Dtool_PyModuleClassInit_dxJointGroup(module);
  PyModule_AddObject(module, "dxJointGroup", (PyObject *)&Dtool_dxJointGroup);
  Py_INCREF(Dtool_Ptr_dxJointGroup);
  PyModule_AddObject(module, "DxJointGroup", (PyObject *)&Dtool_dxJointGroup);
  // dxSpace
  Dtool_PyModuleClassInit_dxSpace(module);
  PyModule_AddObject(module, "dxSpace", (PyObject *)&Dtool_dxSpace);
  Py_INCREF(Dtool_Ptr_dxSpace);
  PyModule_AddObject(module, "DxSpace", (PyObject *)&Dtool_dxSpace);
  // dxTriMeshData
  Dtool_PyModuleClassInit_dxTriMeshData(module);
  PyModule_AddObject(module, "dxTriMeshData", (PyObject *)&Dtool_dxTriMeshData);
  Py_INCREF(Dtool_Ptr_dxTriMeshData);
  PyModule_AddObject(module, "DxTriMeshData", (PyObject *)&Dtool_dxTriMeshData);
  // dxWorld
  Dtool_PyModuleClassInit_dxWorld(module);
  PyModule_AddObject(module, "dxWorld", (PyObject *)&Dtool_dxWorld);
  Py_INCREF(Dtool_Ptr_dxWorld);
  PyModule_AddObject(module, "DxWorld", (PyObject *)&Dtool_dxWorld);
  // OdeWorld
  Dtool_PyModuleClassInit_OdeWorld(module);
  PyModule_AddObject(module, "OdeWorld", (PyObject *)&Dtool_OdeWorld);
  // OdeJointGroup
  Dtool_PyModuleClassInit_OdeJointGroup(module);
  PyModule_AddObject(module, "OdeJointGroup", (PyObject *)&Dtool_OdeJointGroup);
  // OdeJointFeedback
  Dtool_PyModuleClassInit_OdeJointFeedback(module);
  PyModule_AddObject(module, "OdeJointFeedback", (PyObject *)&Dtool_OdeJointFeedback);
  // OdeJoint
  Dtool_PyModuleClassInit_OdeJoint(module);
  PyModule_AddObject(module, "OdeJoint", (PyObject *)&Dtool_OdeJoint);
  // OdeAMotorJoint
  Dtool_PyModuleClassInit_OdeAMotorJoint(module);
  PyModule_AddObject(module, "OdeAMotorJoint", (PyObject *)&Dtool_OdeAMotorJoint);
  // OdeBallJoint
  Dtool_PyModuleClassInit_OdeBallJoint(module);
  PyModule_AddObject(module, "OdeBallJoint", (PyObject *)&Dtool_OdeBallJoint);
  // OdeMass
  Dtool_PyModuleClassInit_OdeMass(module);
  PyModule_AddObject(module, "OdeMass", (PyObject *)&Dtool_OdeMass);
  // OdeBody
  Dtool_PyModuleClassInit_OdeBody(module);
  PyModule_AddObject(module, "OdeBody", (PyObject *)&Dtool_OdeBody);
  // OdeSpace
  Dtool_PyModuleClassInit_OdeSpace(module);
  PyModule_AddObject(module, "OdeSpace", (PyObject *)&Dtool_OdeSpace);
  // OdeGeom
  Dtool_PyModuleClassInit_OdeGeom(module);
  PyModule_AddObject(module, "OdeGeom", (PyObject *)&Dtool_OdeGeom);
  // OdeBoxGeom
  Dtool_PyModuleClassInit_OdeBoxGeom(module);
  PyModule_AddObject(module, "OdeBoxGeom", (PyObject *)&Dtool_OdeBoxGeom);
  // OdeCappedCylinderGeom
  Dtool_PyModuleClassInit_OdeCappedCylinderGeom(module);
  PyModule_AddObject(module, "OdeCappedCylinderGeom", (PyObject *)&Dtool_OdeCappedCylinderGeom);
  // OdeContactGeom
  Dtool_PyModuleClassInit_OdeContactGeom(module);
  PyModule_AddObject(module, "OdeContactGeom", (PyObject *)&Dtool_OdeContactGeom);
  // OdeCollisionEntry
  Dtool_PyModuleClassInit_OdeCollisionEntry(module);
  PyModule_AddObject(module, "OdeCollisionEntry", (PyObject *)&Dtool_OdeCollisionEntry);
  // OdeSurfaceParameters
  Dtool_PyModuleClassInit_OdeSurfaceParameters(module);
  PyModule_AddObject(module, "OdeSurfaceParameters", (PyObject *)&Dtool_OdeSurfaceParameters);
  // OdeContact
  Dtool_PyModuleClassInit_OdeContact(module);
  PyModule_AddObject(module, "OdeContact", (PyObject *)&Dtool_OdeContact);
  // OdeContactJoint
  Dtool_PyModuleClassInit_OdeContactJoint(module);
  PyModule_AddObject(module, "OdeContactJoint", (PyObject *)&Dtool_OdeContactJoint);
  // OdeCylinderGeom
  Dtool_PyModuleClassInit_OdeCylinderGeom(module);
  PyModule_AddObject(module, "OdeCylinderGeom", (PyObject *)&Dtool_OdeCylinderGeom);
  // OdeFixedJoint
  Dtool_PyModuleClassInit_OdeFixedJoint(module);
  PyModule_AddObject(module, "OdeFixedJoint", (PyObject *)&Dtool_OdeFixedJoint);
  // OdeHashSpace
  Dtool_PyModuleClassInit_OdeHashSpace(module);
  PyModule_AddObject(module, "OdeHashSpace", (PyObject *)&Dtool_OdeHashSpace);
  // OdeHinge2Joint
  Dtool_PyModuleClassInit_OdeHinge2Joint(module);
  PyModule_AddObject(module, "OdeHinge2Joint", (PyObject *)&Dtool_OdeHinge2Joint);
  // OdeHingeJoint
  Dtool_PyModuleClassInit_OdeHingeJoint(module);
  PyModule_AddObject(module, "OdeHingeJoint", (PyObject *)&Dtool_OdeHingeJoint);
  // OdeJointCollection
  Dtool_PyModuleClassInit_OdeJointCollection(module);
  PyModule_AddObject(module, "OdeJointCollection", (PyObject *)&Dtool_OdeJointCollection);
  // OdeLMotorJoint
  Dtool_PyModuleClassInit_OdeLMotorJoint(module);
  PyModule_AddObject(module, "OdeLMotorJoint", (PyObject *)&Dtool_OdeLMotorJoint);
  // OdeNullJoint
  Dtool_PyModuleClassInit_OdeNullJoint(module);
  PyModule_AddObject(module, "OdeNullJoint", (PyObject *)&Dtool_OdeNullJoint);
  // OdePlane2dJoint
  Dtool_PyModuleClassInit_OdePlane2dJoint(module);
  PyModule_AddObject(module, "OdePlane2dJoint", (PyObject *)&Dtool_OdePlane2dJoint);
  // OdePlaneGeom
  Dtool_PyModuleClassInit_OdePlaneGeom(module);
  PyModule_AddObject(module, "OdePlaneGeom", (PyObject *)&Dtool_OdePlaneGeom);
  // OdeQuadTreeSpace
  Dtool_PyModuleClassInit_OdeQuadTreeSpace(module);
  PyModule_AddObject(module, "OdeQuadTreeSpace", (PyObject *)&Dtool_OdeQuadTreeSpace);
  // OdeRayGeom
  Dtool_PyModuleClassInit_OdeRayGeom(module);
  PyModule_AddObject(module, "OdeRayGeom", (PyObject *)&Dtool_OdeRayGeom);
  // OdeSimpleSpace
  Dtool_PyModuleClassInit_OdeSimpleSpace(module);
  PyModule_AddObject(module, "OdeSimpleSpace", (PyObject *)&Dtool_OdeSimpleSpace);
  // OdeSliderJoint
  Dtool_PyModuleClassInit_OdeSliderJoint(module);
  PyModule_AddObject(module, "OdeSliderJoint", (PyObject *)&Dtool_OdeSliderJoint);
  // OdeSphereGeom
  Dtool_PyModuleClassInit_OdeSphereGeom(module);
  PyModule_AddObject(module, "OdeSphereGeom", (PyObject *)&Dtool_OdeSphereGeom);
  // OdeTriMeshData
  Dtool_PyModuleClassInit_OdeTriMeshData(module);
  PyModule_AddObject(module, "OdeTriMeshData", (PyObject *)&Dtool_OdeTriMeshData);
  // OdeTriMeshGeom
  Dtool_PyModuleClassInit_OdeTriMeshGeom(module);
  PyModule_AddObject(module, "OdeTriMeshGeom", (PyObject *)&Dtool_OdeTriMeshGeom);
  // OdeUniversalJoint
  Dtool_PyModuleClassInit_OdeUniversalJoint(module);
  PyModule_AddObject(module, "OdeUniversalJoint", (PyObject *)&Dtool_OdeUniversalJoint);
  // OdeUtil
  Dtool_PyModuleClassInit_OdeUtil(module);
  PyModule_AddObject(module, "OdeUtil", (PyObject *)&Dtool_OdeUtil);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libpandaode_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libpandaode_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583614291,  /* file_identifier */
  "libpandaode",  /* library_name */
  "sTqO",  /* library_hash_name */
  "panda3d.ode",  /* module_name */
  "libpandaode.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  1478  /* next_index */
};

Configure(_in_configure_libpandaode);
ConfigureFn(_in_configure_libpandaode) {
  interrogate_request_module(&_in_module_def);
}

