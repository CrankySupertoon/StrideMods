/*
 * This file was generated by:
 * built/bin/interrogate -srcdir direct/src/interval -Idirect/src/interval -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3interval_igate.cxx -od built/pandac/input/libp3interval.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Idirect/src/interval -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.direct -library libp3interval cConstrainHprInterval.h cConstrainPosHprInterval.h cConstrainPosInterval.h cConstrainTransformInterval.h cConstraintInterval.h cInterval.h cIntervalManager.h cLerpAnimEffectInterval.h cLerpInterval.h cLerpNodePathInterval.h cMetaInterval.h config_interval.h hideInterval.h lerp_helpers.h lerpblend.h p3interval_composite1.cxx showInterval.h waitInterval.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "animControl.h"
#include "cConstrainHprInterval.h"
#include "cConstrainPosHprInterval.h"
#include "cConstrainPosInterval.h"
#include "cConstrainTransformInterval.h"
#include "cConstraintInterval.h"
#include "cInterval.h"
#include "cIntervalManager.h"
#include "cLerpAnimEffectInterval.h"
#include "cLerpInterval.h"
#include "cLerpNodePathInterval.h"
#include "cMetaInterval.h"
#include "config_interval.h"
#include "directbase.h"
#include "hideInterval.h"
#include "lerp_helpers.h"
#include "lerpblend.h"
#include "lquaternion.h"
#include "lvecBase3.h"
#include <math.h>
#include "nodePath.h"
#include "pdeque.h"
#include "plist.h"
#include "pmap.h"
#include "pmutex.h"
#include "pointerTo.h"
#include "pset.h"
#include "pvector.h"
#include "showInterval.h"
#include "textureStage.h"
#include "typedReferenceCount.h"
#include "vector_int.h"
#include "waitInterval.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class CInterval
 */
typedef CInterval CInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CInterval, CInterval_localtype, CInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CInterval = &Dtool_CInterval;
static void Dtool_PyModuleClassInit_CInterval(PyObject *module);

/**
 * Forward declarations for top-level class CIntervalManager
 */
typedef CIntervalManager CIntervalManager_localtype;
Define_Module_Class(panda3d.direct, CIntervalManager, CIntervalManager_localtype, CIntervalManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CIntervalManager = &Dtool_CIntervalManager;
static void Dtool_PyModuleClassInit_CIntervalManager(PyObject *module);

/**
 * Forward declarations for top-level class CConstraintInterval
 */
typedef CConstraintInterval CConstraintInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CConstraintInterval, CConstraintInterval_localtype, CConstraintInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CConstraintInterval = &Dtool_CConstraintInterval;
static void Dtool_PyModuleClassInit_CConstraintInterval(PyObject *module);

/**
 * Forward declarations for top-level class CConstrainHprInterval
 */
typedef CConstrainHprInterval CConstrainHprInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CConstrainHprInterval, CConstrainHprInterval_localtype, CConstrainHprInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CConstrainHprInterval = &Dtool_CConstrainHprInterval;
static void Dtool_PyModuleClassInit_CConstrainHprInterval(PyObject *module);

/**
 * Forward declarations for top-level class CConstrainPosHprInterval
 */
typedef CConstrainPosHprInterval CConstrainPosHprInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CConstrainPosHprInterval, CConstrainPosHprInterval_localtype, CConstrainPosHprInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CConstrainPosHprInterval = &Dtool_CConstrainPosHprInterval;
static void Dtool_PyModuleClassInit_CConstrainPosHprInterval(PyObject *module);

/**
 * Forward declarations for top-level class CConstrainPosInterval
 */
typedef CConstrainPosInterval CConstrainPosInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CConstrainPosInterval, CConstrainPosInterval_localtype, CConstrainPosInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CConstrainPosInterval = &Dtool_CConstrainPosInterval;
static void Dtool_PyModuleClassInit_CConstrainPosInterval(PyObject *module);

/**
 * Forward declarations for top-level class CConstrainTransformInterval
 */
typedef CConstrainTransformInterval CConstrainTransformInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CConstrainTransformInterval, CConstrainTransformInterval_localtype, CConstrainTransformInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CConstrainTransformInterval = &Dtool_CConstrainTransformInterval;
static void Dtool_PyModuleClassInit_CConstrainTransformInterval(PyObject *module);

/**
 * Forward declarations for top-level class CLerpInterval
 */
typedef CLerpInterval CLerpInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CLerpInterval, CLerpInterval_localtype, CLerpInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CLerpInterval = &Dtool_CLerpInterval;
static void Dtool_PyModuleClassInit_CLerpInterval(PyObject *module);

/**
 * Forward declarations for top-level class CLerpAnimEffectInterval
 */
typedef CLerpAnimEffectInterval CLerpAnimEffectInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CLerpAnimEffectInterval, CLerpAnimEffectInterval_localtype, CLerpAnimEffectInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CLerpAnimEffectInterval = &Dtool_CLerpAnimEffectInterval;
static void Dtool_PyModuleClassInit_CLerpAnimEffectInterval(PyObject *module);

/**
 * Forward declarations for top-level class CLerpNodePathInterval
 */
typedef CLerpNodePathInterval CLerpNodePathInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CLerpNodePathInterval, CLerpNodePathInterval_localtype, CLerpNodePathInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CLerpNodePathInterval = &Dtool_CLerpNodePathInterval;
static void Dtool_PyModuleClassInit_CLerpNodePathInterval(PyObject *module);

/**
 * Forward declarations for top-level class CMetaInterval
 */
typedef CMetaInterval CMetaInterval_localtype;
Define_Module_ClassRef(panda3d.direct, CMetaInterval, CMetaInterval_localtype, CMetaInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CMetaInterval = &Dtool_CMetaInterval;
static void Dtool_PyModuleClassInit_CMetaInterval(PyObject *module);

/**
 * Forward declarations for top-level class HideInterval
 */
typedef HideInterval HideInterval_localtype;
Define_Module_ClassRef(panda3d.direct, HideInterval, HideInterval_localtype, HideInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_HideInterval = &Dtool_HideInterval;
static void Dtool_PyModuleClassInit_HideInterval(PyObject *module);

/**
 * Forward declarations for top-level class LerpBlendType
 */
typedef LerpBlendType LerpBlendType_localtype;
Define_Module_ClassRef(panda3d.direct, LerpBlendType, LerpBlendType_localtype, LerpBlendType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LerpBlendType = &Dtool_LerpBlendType;
static void Dtool_PyModuleClassInit_LerpBlendType(PyObject *module);

/**
 * Forward declarations for top-level class EaseInBlendType
 */
typedef EaseInBlendType EaseInBlendType_localtype;
Define_Module_ClassRef(panda3d.direct, EaseInBlendType, EaseInBlendType_localtype, EaseInBlendType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EaseInBlendType = &Dtool_EaseInBlendType;
static void Dtool_PyModuleClassInit_EaseInBlendType(PyObject *module);

/**
 * Forward declarations for top-level class EaseOutBlendType
 */
typedef EaseOutBlendType EaseOutBlendType_localtype;
Define_Module_ClassRef(panda3d.direct, EaseOutBlendType, EaseOutBlendType_localtype, EaseOutBlendType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EaseOutBlendType = &Dtool_EaseOutBlendType;
static void Dtool_PyModuleClassInit_EaseOutBlendType(PyObject *module);

/**
 * Forward declarations for top-level class EaseInOutBlendType
 */
typedef EaseInOutBlendType EaseInOutBlendType_localtype;
Define_Module_ClassRef(panda3d.direct, EaseInOutBlendType, EaseInOutBlendType_localtype, EaseInOutBlendType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_EaseInOutBlendType = &Dtool_EaseInOutBlendType;
static void Dtool_PyModuleClassInit_EaseInOutBlendType(PyObject *module);

/**
 * Forward declarations for top-level class NoBlendType
 */
typedef NoBlendType NoBlendType_localtype;
Define_Module_ClassRef(panda3d.direct, NoBlendType, NoBlendType_localtype, NoBlendType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NoBlendType = &Dtool_NoBlendType;
static void Dtool_PyModuleClassInit_NoBlendType(PyObject *module);

/**
 * Forward declarations for top-level class ShowInterval
 */
typedef ShowInterval ShowInterval_localtype;
Define_Module_ClassRef(panda3d.direct, ShowInterval, ShowInterval_localtype, ShowInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ShowInterval = &Dtool_ShowInterval;
static void Dtool_PyModuleClassInit_ShowInterval(PyObject *module);

/**
 * Forward declarations for top-level class WaitInterval
 */
typedef WaitInterval WaitInterval_localtype;
Define_Module_ClassRef(panda3d.direct, WaitInterval, WaitInterval_localtype, WaitInterval);
static struct Dtool_PyTypedObject *const Dtool_Ptr_WaitInterval = &Dtool_WaitInterval;
static void Dtool_PyModuleClassInit_WaitInterval(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"CInterval", &Dtool_CInterval},
  {"CIntervalManager", &Dtool_CIntervalManager},
  {"CConstraintInterval", &Dtool_CConstraintInterval},
  {"CConstrainHprInterval", &Dtool_CConstrainHprInterval},
  {"CConstrainPosHprInterval", &Dtool_CConstrainPosHprInterval},
  {"CConstrainPosInterval", &Dtool_CConstrainPosInterval},
  {"CConstrainTransformInterval", &Dtool_CConstrainTransformInterval},
  {"CLerpInterval", &Dtool_CLerpInterval},
  {"CLerpAnimEffectInterval", &Dtool_CLerpAnimEffectInterval},
  {"CLerpNodePathInterval", &Dtool_CLerpNodePathInterval},
  {"CMetaInterval", &Dtool_CMetaInterval},
  {"HideInterval", &Dtool_HideInterval},
  {"LerpBlendType", &Dtool_LerpBlendType},
  {"EaseInBlendType", &Dtool_EaseInBlendType},
  {"EaseOutBlendType", &Dtool_EaseOutBlendType},
  {"EaseInOutBlendType", &Dtool_EaseInOutBlendType},
  {"NoBlendType", &Dtool_NoBlendType},
  {"ShowInterval", &Dtool_ShowInterval},
  {"WaitInterval", &Dtool_WaitInterval},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[1].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[2].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[3].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[4].type)
  {"LVecBase2f", nullptr},
#define Dtool_Ptr_LVecBase2f (imports[5].type)
  {"LVecBase3f", nullptr},
#define Dtool_Ptr_LVecBase3f (imports[6].type)
  {"LVecBase4f", nullptr},
#define Dtool_Ptr_LVecBase4f (imports[7].type)
  {"LQuaternionf", nullptr},
#define Dtool_Ptr_LQuaternionf (imports[8].type)
  {"TextureStage", nullptr},
#define Dtool_Ptr_TextureStage (imports[9].type)
  {"NodePath", nullptr},
#define Dtool_Ptr_NodePath (imports[10].type)
  {"AnimControl", nullptr},
#define Dtool_Ptr_AnimControl (imports[11].type)
  {"EventQueue", nullptr},
#define Dtool_Ptr_EventQueue (imports[12].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// LVecBase2f
#ifndef LINK_ALL_STATIC
inline static LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced) {
  nassertr(Dtool_Ptr_LVecBase2f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2f *(*)(PyObject *, LVecBase2f &))Dtool_Ptr_LVecBase2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2f = &Dtool_LVecBase2f;
extern LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LQuaternionf
#ifndef LINK_ALL_STATIC
inline static LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced) {
  nassertr(Dtool_Ptr_LQuaternionf != nullptr, nullptr);
  nassertr(Dtool_Ptr_LQuaternionf->_Dtool_Coerce != nullptr, nullptr);
  return ((LQuaternionf *(*)(PyObject *, LQuaternionf &))Dtool_Ptr_LQuaternionf->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LQuaternionf;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LQuaternionf = &Dtool_LQuaternionf;
extern LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced);
#endif
// TextureStage
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TextureStage;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TextureStage = &Dtool_TextureStage;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// AnimControl
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_AnimControl;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimControl = &Dtool_AnimControl;
#endif
// EventQueue
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_EventQueue;
static struct Dtool_PyTypedObject *const Dtool_Ptr_EventQueue = &Dtool_EventQueue;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class CInterval
 */
/**
 * Python function wrapper for:
 * inline std::string const &CInterval::get_name(void) const
 */
static PyObject *Dtool_CInterval_get_name_3(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterval)) {
    return nullptr;
  }
  // 1-inline std::string const &CInterval::get_name(void) const
  std::string const &return_value = ((*(const CInterval*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_name_3_comment =
  "C++ Interface:\n"
  "get_name(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the interval's name.\n"
  " */";
#else
static const char *Dtool_CInterval_get_name_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double CInterval::get_duration(void) const
 */
static PyObject *Dtool_CInterval_get_duration_4(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterval)) {
    return nullptr;
  }
  // 1-inline double CInterval::get_duration(void) const
  double return_value = ((*(const CInterval*)local_this).get_duration)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_duration_4_comment =
  "C++ Interface:\n"
  "get_duration(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the duration of the interval in seconds.\n"
  " */";
#else
static const char *Dtool_CInterval_get_duration_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CInterval::get_open_ended(void) const
 */
static PyObject *Dtool_CInterval_get_open_ended_5(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterval)) {
    return nullptr;
  }
  // 1-inline bool CInterval::get_open_ended(void) const
  bool return_value = ((*(const CInterval*)local_this).get_open_ended)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_open_ended_5_comment =
  "C++ Interface:\n"
  "get_open_ended(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the state of the \"open_ended\" flag.  This is primarily intended for\n"
  " * instantaneous intervals like FunctionIntervals; it indicates true if the\n"
  " * interval has some lasting effect that should be applied even if the\n"
  " * interval doesn't get started until after its finish time, or false if the\n"
  " * interval is a transitive thing that doesn't need to be called late.\n"
  " */";
#else
static const char *Dtool_CInterval_get_open_ended_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CInterval::State CInterval::get_state(void) const
 */
static PyObject *Dtool_CInterval_get_state_8(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterval)) {
    return nullptr;
  }
  // 1-inline CInterval::State CInterval::get_state(void) const
  CInterval::State return_value = ((*(const CInterval*)local_this).get_state)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_state_8_comment =
  "C++ Interface:\n"
  "get_state(CInterval self)\n"
  "\n"
  "/**\n"
  " * Indicates the state the interval believes it is in: whether it has been\n"
  " * started, is currently in the middle, or has been finalized.\n"
  " */";
#else
static const char *Dtool_CInterval_get_state_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CInterval::is_stopped(void) const
 */
static PyObject *Dtool_CInterval_is_stopped_9(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterval)) {
    return nullptr;
  }
  // 1-inline bool CInterval::is_stopped(void) const
  bool return_value = ((*(const CInterval*)local_this).is_stopped)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_is_stopped_9_comment =
  "C++ Interface:\n"
  "is_stopped(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns true if the interval is in either its initial or final states (but\n"
  " * not in a running or paused state).\n"
  " */";
#else
static const char *Dtool_CInterval_is_stopped_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CInterval::set_done_event(std::string const &event)
 */
static PyObject *Dtool_CInterval_set_done_event_10(PyObject *self, PyObject *arg) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.set_done_event")) {
    return nullptr;
  }
  // 1-inline void CInterval::set_done_event(std::string const &event)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_done_event)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_done_event(const CInterval self, str event)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_set_done_event_10_comment =
  "C++ Interface:\n"
  "set_done_event(const CInterval self, str event)\n"
  "\n"
  "/**\n"
  " * Sets the event that is generated whenever the interval reaches its final\n"
  " * state, whether it is explicitly finished or whether it gets there on its\n"
  " * own.\n"
  " */";
#else
static const char *Dtool_CInterval_set_done_event_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &CInterval::get_done_event(void) const
 */
static PyObject *Dtool_CInterval_get_done_event_11(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterval)) {
    return nullptr;
  }
  // 1-inline std::string const &CInterval::get_done_event(void) const
  std::string const &return_value = ((*(const CInterval*)local_this).get_done_event)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_done_event_11_comment =
  "C++ Interface:\n"
  "get_done_event(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the event that is generated whenever the interval reaches its final\n"
  " * state, whether it is explicitly finished or whether it gets there on its\n"
  " * own.\n"
  " */";
#else
static const char *Dtool_CInterval_get_done_event_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterval::set_t(double t)
 */
static PyObject *Dtool_CInterval_set_t_12(PyObject *self, PyObject *arg) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.set_t")) {
    return nullptr;
  }
  // 1-void CInterval::set_t(double t)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_t)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_t(const CInterval self, double t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_set_t_12_comment =
  "C++ Interface:\n"
  "set_t(const CInterval self, double t)\n"
  "\n"
  "/**\n"
  " * Explicitly sets the time within the interval.  Normally, you would use\n"
  " * start() .. finish() to let the time play normally, but this may be used to\n"
  " * set the time to some particular value.\n"
  " */";
#else
static const char *Dtool_CInterval_set_t_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double CInterval::get_t(void) const
 */
static PyObject *Dtool_CInterval_get_t_13(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterval)) {
    return nullptr;
  }
  // 1-inline double CInterval::get_t(void) const
  double return_value = ((*(const CInterval*)local_this).get_t)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_t_13_comment =
  "C++ Interface:\n"
  "get_t(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the current time of the interval: the last value of t passed to\n"
  " * priv_initialize(), priv_step(), or priv_finalize().\n"
  " */";
#else
static const char *Dtool_CInterval_get_t_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CInterval::set_auto_pause(bool auto_pause)
 */
static PyObject *Dtool_CInterval_set_auto_pause_14(PyObject *self, PyObject *arg) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.set_auto_pause")) {
    return nullptr;
  }
  // 1-inline void CInterval::set_auto_pause(bool auto_pause)
  ((*local_this).set_auto_pause)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_pause(const CInterval self, bool auto_pause)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_set_auto_pause_14_comment =
  "C++ Interface:\n"
  "set_auto_pause(const CInterval self, bool auto_pause)\n"
  "\n"
  "/**\n"
  " * Changes the state of the 'auto_pause' flag.  If this is true, the interval\n"
  " * may be arbitrarily interrupted when the system needs to reset due to some\n"
  " * external event by calling CIntervalManager::interrupt().  If this is false\n"
  " * (the default), the interval must always be explicitly finished or paused.\n"
  " */";
#else
static const char *Dtool_CInterval_set_auto_pause_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CInterval::get_auto_pause(void) const
 */
static PyObject *Dtool_CInterval_get_auto_pause_15(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterval)) {
    return nullptr;
  }
  // 1-inline bool CInterval::get_auto_pause(void) const
  bool return_value = ((*(const CInterval*)local_this).get_auto_pause)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_auto_pause_15_comment =
  "C++ Interface:\n"
  "get_auto_pause(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the state of the 'auto_pause' flag.  See set_auto_pause().\n"
  " */";
#else
static const char *Dtool_CInterval_get_auto_pause_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CInterval::set_auto_finish(bool auto_finish)
 */
static PyObject *Dtool_CInterval_set_auto_finish_16(PyObject *self, PyObject *arg) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.set_auto_finish")) {
    return nullptr;
  }
  // 1-inline void CInterval::set_auto_finish(bool auto_finish)
  ((*local_this).set_auto_finish)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_finish(const CInterval self, bool auto_finish)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_set_auto_finish_16_comment =
  "C++ Interface:\n"
  "set_auto_finish(const CInterval self, bool auto_finish)\n"
  "\n"
  "/**\n"
  " * Changes the state of the 'auto_finish' flag.  If this is true, the interval\n"
  " * may be arbitrarily finished when the system needs to reset due to some\n"
  " * external event by calling CIntervalManager::interrupt().  If this is false\n"
  " * (the default), the interval must always be explicitly finished or paused.\n"
  " */";
#else
static const char *Dtool_CInterval_set_auto_finish_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CInterval::get_auto_finish(void) const
 */
static PyObject *Dtool_CInterval_get_auto_finish_17(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterval)) {
    return nullptr;
  }
  // 1-inline bool CInterval::get_auto_finish(void) const
  bool return_value = ((*(const CInterval*)local_this).get_auto_finish)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_auto_finish_17_comment =
  "C++ Interface:\n"
  "get_auto_finish(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the state of the 'auto_finish' flag.  See set_auto_finish().\n"
  " */";
#else
static const char *Dtool_CInterval_get_auto_finish_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CInterval::set_wants_t_callback(bool wants_t_callback)
 */
static PyObject *Dtool_CInterval_set_wants_t_callback_18(PyObject *self, PyObject *arg) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.set_wants_t_callback")) {
    return nullptr;
  }
  // 1-inline void CInterval::set_wants_t_callback(bool wants_t_callback)
  ((*local_this).set_wants_t_callback)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wants_t_callback(const CInterval self, bool wants_t_callback)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_set_wants_t_callback_18_comment =
  "C++ Interface:\n"
  "set_wants_t_callback(const CInterval self, bool wants_t_callback)\n"
  "\n"
  "/**\n"
  " * Changes the state of the 'wants_t_callback' flag.  If this is true, the\n"
  " * interval will be returned by CIntervalManager::get_event() each time the\n"
  " * interval's time value has been changed, regardless of whether it has any\n"
  " * external events.\n"
  " */";
#else
static const char *Dtool_CInterval_set_wants_t_callback_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CInterval::get_wants_t_callback(void) const
 */
static PyObject *Dtool_CInterval_get_wants_t_callback_19(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterval)) {
    return nullptr;
  }
  // 1-inline bool CInterval::get_wants_t_callback(void) const
  bool return_value = ((*(const CInterval*)local_this).get_wants_t_callback)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_wants_t_callback_19_comment =
  "C++ Interface:\n"
  "get_wants_t_callback(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the state of the 'wants_t_callback' flag.  See\n"
  " * set_wants_t_callback().\n"
  " */";
#else
static const char *Dtool_CInterval_get_wants_t_callback_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CInterval::set_manager(CIntervalManager *manager)
 */
static PyObject *Dtool_CInterval_set_manager_20(PyObject *self, PyObject *arg) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.set_manager")) {
    return nullptr;
  }
  // 1-inline void CInterval::set_manager(CIntervalManager *manager)
  CIntervalManager *arg_this = (CIntervalManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CIntervalManager, 1, "CInterval.set_manager", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_manager)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_manager(const CInterval self, CIntervalManager manager)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_set_manager_20_comment =
  "C++ Interface:\n"
  "set_manager(const CInterval self, CIntervalManager manager)\n"
  "\n"
  "/**\n"
  " * Indicates the CIntervalManager object which will be responsible for playing\n"
  " * this interval.  This defaults to the global CIntervalManager; you should\n"
  " * need to change this only if you have special requirements for playing this\n"
  " * interval.\n"
  " */";
#else
static const char *Dtool_CInterval_set_manager_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CIntervalManager *CInterval::get_manager(void) const
 */
static PyObject *Dtool_CInterval_get_manager_21(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterval)) {
    return nullptr;
  }
  // 1-inline CIntervalManager *CInterval::get_manager(void) const
  CIntervalManager *return_value = ((*(const CInterval*)local_this).get_manager)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_CIntervalManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_manager_21_comment =
  "C++ Interface:\n"
  "get_manager(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the CIntervalManager object which will be responsible for playing\n"
  " * this interval.  Note that this can only return a C++ object; if the\n"
  " * particular CIntervalManager object has been extended in the scripting\n"
  " * language, this will return the encapsulated C++ object, not the full\n"
  " * extended object.\n"
  " */";
#else
static const char *Dtool_CInterval_get_manager_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterval::start(double start_t = 0.0, double end_t = -1.0, double play_rate = 1.0)
 */
static PyObject *Dtool_CInterval_start_22(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.start")) {
    return nullptr;
  }
  // 1-void CInterval::start(double start_t = 0.0, double end_t = -1.0, double play_rate = 1.0)
  double param1 = 0.0;
  double param2 = -1.0;
  double param3 = 1.0;
  static const char *keyword_list[] = {"start_t", "end_t", "play_rate", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|ddd:start", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).start)((double)param1, (double)param2, (double)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "start(const CInterval self, double start_t, double end_t, double play_rate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_start_22_comment =
  "C++ Interface:\n"
  "start(const CInterval self, double start_t, double end_t, double play_rate)\n"
  "\n"
  "/**\n"
  " * Starts the interval playing by registering it with the current\n"
  " * CIntervalManager.  The interval will play to the end and stop.\n"
  " *\n"
  " * If end_t is less than zero, it indicates the end of the interval.\n"
  " */";
#else
static const char *Dtool_CInterval_start_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterval::loop(double start_t = 0.0, double end_t = -1.0, double play_rate = 1.0)
 */
static PyObject *Dtool_CInterval_loop_23(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.loop")) {
    return nullptr;
  }
  // 1-void CInterval::loop(double start_t = 0.0, double end_t = -1.0, double play_rate = 1.0)
  double param1 = 0.0;
  double param2 = -1.0;
  double param3 = 1.0;
  static const char *keyword_list[] = {"start_t", "end_t", "play_rate", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|ddd:loop", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).loop)((double)param1, (double)param2, (double)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "loop(const CInterval self, double start_t, double end_t, double play_rate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_loop_23_comment =
  "C++ Interface:\n"
  "loop(const CInterval self, double start_t, double end_t, double play_rate)\n"
  "\n"
  "/**\n"
  " * Starts the interval playing by registering it with the current\n"
  " * CIntervalManager.  The interval will play until it is interrupted with\n"
  " * finish() or pause(), looping back to start_t when it reaches end_t.\n"
  " *\n"
  " * If end_t is less than zero, it indicates the end of the interval.\n"
  " */";
#else
static const char *Dtool_CInterval_loop_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double CInterval::pause(void)
 */
static PyObject *Dtool_CInterval_pause_24(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.pause")) {
    return nullptr;
  }
  // 1-double CInterval::pause(void)
  double return_value = ((*local_this).pause)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_pause_24_comment =
  "C++ Interface:\n"
  "pause(const CInterval self)\n"
  "\n"
  "/**\n"
  " * Stops the interval from playing but leaves it in its current state.  It may\n"
  " * later be resumed from this point by calling resume().\n"
  " */";
#else
static const char *Dtool_CInterval_pause_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterval::resume(void)
 * void CInterval::resume(double start_t)
 */
static PyObject *Dtool_CInterval_resume_25(PyObject *self, PyObject *args) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.resume")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-void CInterval::resume(void)
      ((*local_this).resume)();
      return Dtool_Return_None();
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-void CInterval::resume(double start_t)
      if (PyNumber_Check(arg)) {
        ((*local_this).resume)(PyFloat_AsDouble(arg));
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "resume() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "resume(const CInterval self)\n"
      "resume(const CInterval self, double start_t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_resume_25_comment =
  "C++ Interface:\n"
  "resume(const CInterval self)\n"
  "resume(const CInterval self, double start_t)\n"
  "\n"
  "/**\n"
  " * Restarts the interval from its current point after a previous call to\n"
  " * pause().\n"
  " */\n"
  "\n"
  "/**\n"
  " * Restarts the interval from the indicated point after a previous call to\n"
  " * pause().\n"
  " */";
#else
static const char *Dtool_CInterval_resume_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterval::resume_until(double end_t)
 */
static PyObject *Dtool_CInterval_resume_until_26(PyObject *self, PyObject *arg) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.resume_until")) {
    return nullptr;
  }
  // 1-void CInterval::resume_until(double end_t)
  if (PyNumber_Check(arg)) {
    ((*local_this).resume_until)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "resume_until(const CInterval self, double end_t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_resume_until_26_comment =
  "C++ Interface:\n"
  "resume_until(const CInterval self, double end_t)\n"
  "\n"
  "/**\n"
  " * Restarts the interval from the current point after a previous call to\n"
  " * pause() (or a previous play-to-point-and-stop), to play until the indicated\n"
  " * point and then stop.\n"
  " */";
#else
static const char *Dtool_CInterval_resume_until_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterval::finish(void)
 */
static PyObject *Dtool_CInterval_finish_27(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.finish")) {
    return nullptr;
  }
  // 1-void CInterval::finish(void)
  ((*local_this).finish)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterval_finish_27_comment =
  "C++ Interface:\n"
  "finish(const CInterval self)\n"
  "\n"
  "/**\n"
  " * Stops the interval from playing and sets it to its final state.\n"
  " */";
#else
static const char *Dtool_CInterval_finish_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterval::clear_to_initial(void)
 */
static PyObject *Dtool_CInterval_clear_to_initial_28(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.clear_to_initial")) {
    return nullptr;
  }
  // 1-void CInterval::clear_to_initial(void)
  ((*local_this).clear_to_initial)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterval_clear_to_initial_28_comment =
  "C++ Interface:\n"
  "clear_to_initial(const CInterval self)\n"
  "\n"
  "/**\n"
  " * Pauses the interval, if it is playing, and resets its state to its initial\n"
  " * state, abandoning any state changes already in progress in the middle of\n"
  " * the interval.  Calling this is like pausing the interval and discarding it,\n"
  " * creating a new one in its place.\n"
  " */";
#else
static const char *Dtool_CInterval_clear_to_initial_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CInterval::is_playing(void) const
 */
static PyObject *Dtool_CInterval_is_playing_29(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterval)) {
    return nullptr;
  }
  // 1-bool CInterval::is_playing(void) const
  bool return_value = ((*(const CInterval*)local_this).is_playing)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_is_playing_29_comment =
  "C++ Interface:\n"
  "is_playing(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns true if the interval is currently playing, false otherwise.\n"
  " */";
#else
static const char *Dtool_CInterval_is_playing_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double CInterval::get_play_rate(void) const
 */
static PyObject *Dtool_CInterval_get_play_rate_30(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterval)) {
    return nullptr;
  }
  // 1-double CInterval::get_play_rate(void) const
  double return_value = ((*(const CInterval*)local_this).get_play_rate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_play_rate_30_comment =
  "C++ Interface:\n"
  "get_play_rate(CInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the play rate as set by the last call to start(), loop(), or\n"
  " * set_play_rate().\n"
  " */";
#else
static const char *Dtool_CInterval_get_play_rate_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterval::set_play_rate(double play_rate)
 */
static PyObject *Dtool_CInterval_set_play_rate_31(PyObject *self, PyObject *arg) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.set_play_rate")) {
    return nullptr;
  }
  // 1-void CInterval::set_play_rate(double play_rate)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_play_rate)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_play_rate(const CInterval self, double play_rate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_set_play_rate_31_comment =
  "C++ Interface:\n"
  "set_play_rate(const CInterval self, double play_rate)\n"
  "\n"
  "/**\n"
  " * Changes the play rate of the interval.  If the interval is already started,\n"
  " * this changes its speed on-the-fly.  Note that since play_rate is a\n"
  " * parameter to start() and loop(), the next call to start() or loop() will\n"
  " * reset this parameter.\n"
  " */";
#else
static const char *Dtool_CInterval_set_play_rate_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterval::priv_do_event(double t, CInterval::EventType event)
 */
static PyObject *Dtool_CInterval_priv_do_event_32(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_do_event")) {
    return nullptr;
  }
  // 1-void CInterval::priv_do_event(double t, CInterval::EventType event)
  double param1;
  int param2;
  static const char *keyword_list[] = {"t", "event", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "di:priv_do_event", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).priv_do_event)((double)param1, (CInterval::EventType)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "priv_do_event(const CInterval self, double t, int event)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_do_event_32_comment =
  "C++ Interface:\n"
  "priv_do_event(const CInterval self, double t, int event)\n"
  "\n"
  "// These cannot be declared private because they must be accessible to\n"
  "// Python, but the method names are prefixed with priv_ to remind you that\n"
  "// you probably don't want to be using them directly.\n"
  "\n"
  "/**\n"
  " * Calls the appropriate event function indicated by the EventType.\n"
  " */";
#else
static const char *Dtool_CInterval_priv_do_event_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::priv_initialize(double t)
 */
static PyObject *Dtool_CInterval_priv_initialize_33(PyObject *self, PyObject *arg) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_initialize")) {
    return nullptr;
  }
  // 1-virtual void CInterval::priv_initialize(double t)
  if (PyNumber_Check(arg)) {
    ((*local_this).priv_initialize)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "priv_initialize(const CInterval self, double t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_initialize_33_comment =
  "C++ Interface:\n"
  "priv_initialize(const CInterval self, double t)\n"
  "\n"
  "/**\n"
  " * This replaces the first call to priv_step(), and indicates that the\n"
  " * interval has just begun.  This may be overridden by derived classes that\n"
  " * need to do some explicit initialization on the first call.\n"
  " */";
#else
static const char *Dtool_CInterval_priv_initialize_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::priv_instant(void)
 */
static PyObject *Dtool_CInterval_priv_instant_34(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_instant")) {
    return nullptr;
  }
  // 1-virtual void CInterval::priv_instant(void)
  ((*local_this).priv_instant)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_instant_34_comment =
  "C++ Interface:\n"
  "priv_instant(const CInterval self)\n"
  "\n"
  "/**\n"
  " * This is called in lieu of priv_initialize() .. priv_step() ..\n"
  " * priv_finalize(), when everything is to happen within one frame.  The\n"
  " * interval should initialize itself, then leave itself in the final state.\n"
  " */";
#else
static const char *Dtool_CInterval_priv_instant_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::priv_step(double t)
 */
static PyObject *Dtool_CInterval_priv_step_35(PyObject *self, PyObject *arg) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_step")) {
    return nullptr;
  }
  // 1-virtual void CInterval::priv_step(double t)
  if (PyNumber_Check(arg)) {
    ((*local_this).priv_step)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "priv_step(const CInterval self, double t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_step_35_comment =
  "C++ Interface:\n"
  "priv_step(const CInterval self, double t)\n"
  "\n"
  "/**\n"
  " * Advances the time on the interval.  The time may either increase (the\n"
  " * normal case) or decrease (e.g.  if the interval is being played by a\n"
  " * slider).\n"
  " */";
#else
static const char *Dtool_CInterval_priv_step_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::priv_finalize(void)
 */
static PyObject *Dtool_CInterval_priv_finalize_36(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_finalize")) {
    return nullptr;
  }
  // 1-virtual void CInterval::priv_finalize(void)
  ((*local_this).priv_finalize)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_finalize_36_comment =
  "C++ Interface:\n"
  "priv_finalize(const CInterval self)\n"
  "\n"
  "/**\n"
  " * This is called to stop an interval, forcing it to whatever state it would\n"
  " * be after it played all the way through.  It's generally invoked by\n"
  " * set_final_t().\n"
  " */";
#else
static const char *Dtool_CInterval_priv_finalize_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::priv_reverse_initialize(double t)
 */
static PyObject *Dtool_CInterval_priv_reverse_initialize_37(PyObject *self, PyObject *arg) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_reverse_initialize")) {
    return nullptr;
  }
  // 1-virtual void CInterval::priv_reverse_initialize(double t)
  if (PyNumber_Check(arg)) {
    ((*local_this).priv_reverse_initialize)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "priv_reverse_initialize(const CInterval self, double t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_reverse_initialize_37_comment =
  "C++ Interface:\n"
  "priv_reverse_initialize(const CInterval self, double t)\n"
  "\n"
  "/**\n"
  " * Similar to priv_initialize(), but this is called when the interval is being\n"
  " * played backwards; it indicates that the interval should start at the\n"
  " * finishing state and undo any intervening intervals.\n"
  " */";
#else
static const char *Dtool_CInterval_priv_reverse_initialize_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::priv_reverse_instant(void)
 */
static PyObject *Dtool_CInterval_priv_reverse_instant_38(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_reverse_instant")) {
    return nullptr;
  }
  // 1-virtual void CInterval::priv_reverse_instant(void)
  ((*local_this).priv_reverse_instant)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_reverse_instant_38_comment =
  "C++ Interface:\n"
  "priv_reverse_instant(const CInterval self)\n"
  "\n"
  "/**\n"
  " * This is called in lieu of priv_reverse_initialize() .. priv_step() ..\n"
  " * priv_reverse_finalize(), when everything is to happen within one frame.\n"
  " * The interval should initialize itself, then leave itself in the initial\n"
  " * state.\n"
  " */";
#else
static const char *Dtool_CInterval_priv_reverse_instant_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::priv_reverse_finalize(void)
 */
static PyObject *Dtool_CInterval_priv_reverse_finalize_39(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_reverse_finalize")) {
    return nullptr;
  }
  // 1-virtual void CInterval::priv_reverse_finalize(void)
  ((*local_this).priv_reverse_finalize)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_reverse_finalize_39_comment =
  "C++ Interface:\n"
  "priv_reverse_finalize(const CInterval self)\n"
  "\n"
  "/**\n"
  " * Called generally following a priv_reverse_initialize(), this indicates the\n"
  " * interval should set itself to the initial state.\n"
  " */";
#else
static const char *Dtool_CInterval_priv_reverse_finalize_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::priv_interrupt(void)
 */
static PyObject *Dtool_CInterval_priv_interrupt_40(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.priv_interrupt")) {
    return nullptr;
  }
  // 1-virtual void CInterval::priv_interrupt(void)
  ((*local_this).priv_interrupt)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterval_priv_interrupt_40_comment =
  "C++ Interface:\n"
  "priv_interrupt(const CInterval self)\n"
  "\n"
  "/**\n"
  " * This is called while the interval is playing to indicate that it is about\n"
  " * to be interrupted; that is, priv_step() will not be called for a length of\n"
  " * time.  But the interval should remain in its current state in anticipation\n"
  " * of being eventually restarted when the calls to priv_step() eventually\n"
  " * resume.\n"
  " *\n"
  " * The purpose of this function is to allow self-running intervals like sound\n"
  " * intervals to stop the actual sound playback during the pause.\n"
  " */";
#else
static const char *Dtool_CInterval_priv_interrupt_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::output(std::ostream &out) const
 */
static PyObject *Dtool_CInterval_output_41(PyObject *self, PyObject *arg) {
  CInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterval)) {
    return nullptr;
  }
  // 1-virtual void CInterval::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "CInterval.output", false, true);
  if (arg_this != nullptr) {
    ((*(const CInterval*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CInterval self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_output_41_comment =
  "C++ Interface:\n"
  "output(CInterval self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CInterval_output_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void CInterval::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_CInterval_write_42(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CInterval)) {
    return nullptr;
  }
  // 1-virtual void CInterval::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "CInterval.write", false, true);
    if (param1_this != nullptr) {
      ((*(const CInterval*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(CInterval self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_write_42_comment =
  "C++ Interface:\n"
  "write(CInterval self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CInterval_write_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterval::setup_play(double start_time, double end_time, double play_rate, bool do_loop)
 */
static PyObject *Dtool_CInterval_setup_play_43(PyObject *self, PyObject *args, PyObject *kwds) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.setup_play")) {
    return nullptr;
  }
  // 1-void CInterval::setup_play(double start_time, double end_time, double play_rate, bool do_loop)
  double param1;
  double param2;
  double param3;
  PyObject *param4;
  static const char *keyword_list[] = {"start_time", "end_time", "play_rate", "do_loop", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "dddO:setup_play", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
    ((*local_this).setup_play)((double)param1, (double)param2, (double)param3, (PyObject_IsTrue(param4) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_play(const CInterval self, double start_time, double end_time, double play_rate, bool do_loop)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_setup_play_43_comment =
  "C++ Interface:\n"
  "setup_play(const CInterval self, double start_time, double end_time, double play_rate, bool do_loop)\n"
  "\n"
  "/**\n"
  " * Called to prepare the interval for automatic timed playback, e.g.  via a\n"
  " * Python task.  The interval will be played from start_t to end_t, at a time\n"
  " * factor specified by play_rate.  start_t must always be less than end_t\n"
  " * (except for the exception for end_t == -1, below), but if play_rate is\n"
  " * negative the interval will be played backwards.\n"
  " *\n"
  " * Specify end_t of -1 to play the entire interval from start_t.\n"
  " *\n"
  " * Call step_play() repeatedly to execute the interval.\n"
  " */";
#else
static const char *Dtool_CInterval_setup_play_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterval::setup_resume(void)
 */
static PyObject *Dtool_CInterval_setup_resume_44(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.setup_resume")) {
    return nullptr;
  }
  // 1-void CInterval::setup_resume(void)
  ((*local_this).setup_resume)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CInterval_setup_resume_44_comment =
  "C++ Interface:\n"
  "setup_resume(const CInterval self)\n"
  "\n"
  "/**\n"
  " * Called to prepare the interval for restarting at the current point within\n"
  " * the interval after an interruption.\n"
  " */";
#else
static const char *Dtool_CInterval_setup_resume_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CInterval::setup_resume_until(double end_t)
 */
static PyObject *Dtool_CInterval_setup_resume_until_45(PyObject *self, PyObject *arg) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.setup_resume_until")) {
    return nullptr;
  }
  // 1-void CInterval::setup_resume_until(double end_t)
  if (PyNumber_Check(arg)) {
    ((*local_this).setup_resume_until)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "setup_resume_until(const CInterval self, double end_t)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CInterval_setup_resume_until_45_comment =
  "C++ Interface:\n"
  "setup_resume_until(const CInterval self, double end_t)\n"
  "\n"
  "/**\n"
  " * Called to prepare the interval for restarting from the current point after\n"
  " * a previous call to pause() (or a previous play-to-point-and-stop), to play\n"
  " * until the indicated point and then stop.\n"
  " */";
#else
static const char *Dtool_CInterval_setup_resume_until_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CInterval::step_play(void)
 */
static PyObject *Dtool_CInterval_step_play_46(PyObject *self, PyObject *) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.step_play")) {
    return nullptr;
  }
  // 1-bool CInterval::step_play(void)
  bool return_value = ((*local_this).step_play)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_step_play_46_comment =
  "C++ Interface:\n"
  "step_play(const CInterval self)\n"
  "\n"
  "/**\n"
  " * Should be called once per frame to execute the automatic timed playback\n"
  " * begun with setup_play().\n"
  " *\n"
  " * Returns true if the interval should continue, false if it is done and\n"
  " * should stop.\n"
  " */";
#else
static const char *Dtool_CInterval_step_play_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CInterval::get_class_type(void)
 */
static PyObject *Dtool_CInterval_get_class_type_83(PyObject *, PyObject *) {
  // 1-static TypeHandle CInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CInterval::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CInterval_get_class_type_83_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CInterval_get_class_type_83_comment = nullptr;
#endif

static PyObject *Dtool_CInterval_name_Getter(PyObject *self, void *) {
  const CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &CInterval::get_name(void) const
  std::string const &return_value = ((*(const CInterval*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CInterval_duration_Getter(PyObject *self, void *) {
  const CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double CInterval::get_duration(void) const
  double return_value = ((*(const CInterval*)local_this).get_duration)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CInterval_open_ended_Getter(PyObject *self, void *) {
  const CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool CInterval::get_open_ended(void) const
  bool return_value = ((*(const CInterval*)local_this).get_open_ended)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CInterval_state_Getter(PyObject *self, void *) {
  const CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CInterval::State CInterval::get_state(void) const
  CInterval::State return_value = ((*(const CInterval*)local_this).get_state)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CInterval_stopped_Getter(PyObject *self, void *) {
  const CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool CInterval::is_stopped(void) const
  bool return_value = ((*(const CInterval*)local_this).is_stopped)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_CInterval_done_event_Getter(PyObject *self, void *) {
  const CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &CInterval::get_done_event(void) const
  std::string const &return_value = ((*(const CInterval*)local_this).get_done_event)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CInterval_done_event_Setter(PyObject *self, PyObject *arg, void *) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.done_event")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete done_event attribute");
    return -1;
  }
  // 1-inline void CInterval::set_done_event(std::string const &event)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_done_event)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_done_event(const CInterval self, str event)\n");
  }
  return -1;
}

static PyObject *Dtool_CInterval_t_Getter(PyObject *self, void *) {
  const CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double CInterval::get_t(void) const
  double return_value = ((*(const CInterval*)local_this).get_t)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CInterval_t_Setter(PyObject *self, PyObject *arg, void *) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.t")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete t attribute");
    return -1;
  }
  // 1-void CInterval::set_t(double t)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_t)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_t(const CInterval self, double t)\n");
  }
  return -1;
}

static PyObject *Dtool_CInterval_auto_pause_Getter(PyObject *self, void *) {
  const CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool CInterval::get_auto_pause(void) const
  bool return_value = ((*(const CInterval*)local_this).get_auto_pause)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CInterval_auto_pause_Setter(PyObject *self, PyObject *arg, void *) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.auto_pause")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete auto_pause attribute");
    return -1;
  }
  // 1-inline void CInterval::set_auto_pause(bool auto_pause)
  ((*local_this).set_auto_pause)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_auto_pause(const CInterval self, bool auto_pause)\n");
  }
  return -1;
}

static PyObject *Dtool_CInterval_auto_finish_Getter(PyObject *self, void *) {
  const CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool CInterval::get_auto_finish(void) const
  bool return_value = ((*(const CInterval*)local_this).get_auto_finish)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CInterval_auto_finish_Setter(PyObject *self, PyObject *arg, void *) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.auto_finish")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete auto_finish attribute");
    return -1;
  }
  // 1-inline void CInterval::set_auto_finish(bool auto_finish)
  ((*local_this).set_auto_finish)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_auto_finish(const CInterval self, bool auto_finish)\n");
  }
  return -1;
}

static PyObject *Dtool_CInterval_manager_Getter(PyObject *self, void *) {
  const CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline CIntervalManager *CInterval::get_manager(void) const
  CIntervalManager *return_value = ((*(const CInterval*)local_this).get_manager)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_CIntervalManager, false, false);
}

static int Dtool_CInterval_manager_Setter(PyObject *self, PyObject *arg, void *) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.manager")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete manager attribute");
    return -1;
  }
  // 1-inline void CInterval::set_manager(CIntervalManager *manager)
  CIntervalManager *arg_this = (CIntervalManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CIntervalManager, 1, "CInterval.set_manager", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_manager)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_manager(const CInterval self, CIntervalManager manager)\n");
  }
  return -1;
}

static PyObject *Dtool_CInterval_play_rate_Getter(PyObject *self, void *) {
  const CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return nullptr;
  }

  // 1-double CInterval::get_play_rate(void) const
  double return_value = ((*(const CInterval*)local_this).get_play_rate)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_CInterval_play_rate_Setter(PyObject *self, PyObject *arg, void *) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CInterval, (void **)&local_this, "CInterval.play_rate")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete play_rate attribute");
    return -1;
  }
  // 1-void CInterval::set_play_rate(double play_rate)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_play_rate)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_play_rate(const CInterval self, double play_rate)\n");
  }
  return -1;
}

static PyObject *Dtool_CInterval_playing_Getter(PyObject *self, void *) {
  const CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return nullptr;
  }

  // 1-bool CInterval::is_playing(void) const
  bool return_value = ((*(const CInterval*)local_this).is_playing)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline CInterval::CInterval(CInterval const &) = default
 */
static int Dtool_Init_CInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CInterval() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline CInterval::CInterval(CInterval const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    CInterval const *param0_this = (CInterval *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_CInterval, 0, "CInterval.CInterval", true, true);
    if (param0_this != nullptr) {
      CInterval *return_value = new CInterval(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CInterval, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CInterval(const CInterval param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CInterval) {
    printf("CInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CInterval *local_this = (CInterval *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CInterval*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CIntervalManager
 */
/**
 * Python function wrapper for:
 * inline void CIntervalManager::set_event_queue(EventQueue *event_queue)
 */
static PyObject *Dtool_CIntervalManager_set_event_queue_66(PyObject *self, PyObject *arg) {
  CIntervalManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CIntervalManager, (void **)&local_this, "CIntervalManager.set_event_queue")) {
    return nullptr;
  }
  // 1-inline void CIntervalManager::set_event_queue(EventQueue *event_queue)
  EventQueue *arg_this = (EventQueue *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_EventQueue, 1, "CIntervalManager.set_event_queue", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_event_queue)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_event_queue(const CIntervalManager self, EventQueue event_queue)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_set_event_queue_66_comment =
  "C++ Interface:\n"
  "set_event_queue(const CIntervalManager self, EventQueue event_queue)\n"
  "\n"
  "/**\n"
  " * Specifies a custom event queue to be used for throwing done events from\n"
  " * intervals as they finish.  If this is not specified, the global event queue\n"
  " * is used.\n"
  " *\n"
  " * The caller maintains ownership of the EventQueue object; it is the caller's\n"
  " * responsibility to ensure that the supplied EventQueue does not destruct\n"
  " * during the lifetime of the CIntervalManager.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_set_event_queue_66_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline EventQueue *CIntervalManager::get_event_queue(void) const
 */
static PyObject *Dtool_CIntervalManager_get_event_queue_67(PyObject *self, PyObject *) {
  CIntervalManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CIntervalManager)) {
    return nullptr;
  }
  // 1-inline EventQueue *CIntervalManager::get_event_queue(void) const
  EventQueue *return_value = ((*(const CIntervalManager*)local_this).get_event_queue)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_EventQueue, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_get_event_queue_67_comment =
  "C++ Interface:\n"
  "get_event_queue(CIntervalManager self)\n"
  "\n"
  "/**\n"
  " * Returns the custom event queue to be used for throwing done events from\n"
  " * intervals as they finish.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_get_event_queue_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CIntervalManager::add_c_interval(CInterval *interval, bool external)
 */
static PyObject *Dtool_CIntervalManager_add_c_interval_68(PyObject *self, PyObject *args, PyObject *kwds) {
  CIntervalManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CIntervalManager, (void **)&local_this, "CIntervalManager.add_c_interval")) {
    return nullptr;
  }
  // 1-int CIntervalManager::add_c_interval(CInterval *interval, bool external)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"interval", "external", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_c_interval", (char **)keyword_list, &param1, &param2)) {
    CInterval *param1_this = (CInterval *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_CInterval, 1, "CIntervalManager.add_c_interval", false, true);
    if (param1_this != nullptr) {
      int return_value = ((*local_this).add_c_interval)(param1_this, (PyObject_IsTrue(param2) != 0));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_c_interval(const CIntervalManager self, CInterval interval, bool external)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_add_c_interval_68_comment =
  "C++ Interface:\n"
  "add_c_interval(const CIntervalManager self, CInterval interval, bool external)\n"
  "\n"
  "/**\n"
  " * Adds the interval to the manager, and returns a unique index for the\n"
  " * interval.  This index will be unique among all the currently added\n"
  " * intervals, but not unique across all intervals ever added to the manager.\n"
  " * The maximum index value will never exceed the maximum number of intervals\n"
  " * added at any given time.\n"
  " *\n"
  " * If the external flag is true, the interval is understood to also be stored\n"
  " * in the scripting language data structures.  In this case, it will be\n"
  " * available for information returned by get_next_event() and\n"
  " * get_next_removal().  If external is false, the interval's index will never\n"
  " * be returned by these two functions.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_add_c_interval_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CIntervalManager::find_c_interval(std::string const &name) const
 */
static PyObject *Dtool_CIntervalManager_find_c_interval_69(PyObject *self, PyObject *arg) {
  CIntervalManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CIntervalManager)) {
    return nullptr;
  }
  // 1-int CIntervalManager::find_c_interval(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    int return_value = ((*(const CIntervalManager*)local_this).find_c_interval)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_c_interval(CIntervalManager self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_find_c_interval_69_comment =
  "C++ Interface:\n"
  "find_c_interval(CIntervalManager self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the index associated with the named interval, if there is such an\n"
  " * interval, or -1 if there is not.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_find_c_interval_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CInterval *CIntervalManager::get_c_interval(int index) const
 */
static PyObject *Dtool_CIntervalManager_get_c_interval_70(PyObject *self, PyObject *arg) {
  CIntervalManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CIntervalManager)) {
    return nullptr;
  }
  // 1-CInterval *CIntervalManager::get_c_interval(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    CInterval *return_value = ((*(const CIntervalManager*)local_this).get_c_interval)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CInterval, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_c_interval(CIntervalManager self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_get_c_interval_70_comment =
  "C++ Interface:\n"
  "get_c_interval(CIntervalManager self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the interval associated with the given index.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_get_c_interval_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CIntervalManager::remove_c_interval(int index)
 */
static PyObject *Dtool_CIntervalManager_remove_c_interval_71(PyObject *self, PyObject *arg) {
  CIntervalManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CIntervalManager, (void **)&local_this, "CIntervalManager.remove_c_interval")) {
    return nullptr;
  }
  // 1-void CIntervalManager::remove_c_interval(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).remove_c_interval)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_c_interval(const CIntervalManager self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_remove_c_interval_71_comment =
  "C++ Interface:\n"
  "remove_c_interval(const CIntervalManager self, int index)\n"
  "\n"
  "/**\n"
  " * Removes the indicated interval from the queue immediately.  It will not be\n"
  " * returned from get_next_removal(), and none of its pending events, if any,\n"
  " * will be returned by get_next_event().\n"
  " */";
#else
static const char *Dtool_CIntervalManager_remove_c_interval_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CIntervalManager::interrupt(void)
 */
static PyObject *Dtool_CIntervalManager_interrupt_72(PyObject *self, PyObject *) {
  CIntervalManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CIntervalManager, (void **)&local_this, "CIntervalManager.interrupt")) {
    return nullptr;
  }
  // 1-int CIntervalManager::interrupt(void)
  int return_value = ((*local_this).interrupt)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_interrupt_72_comment =
  "C++ Interface:\n"
  "interrupt(const CIntervalManager self)\n"
  "\n"
  "/**\n"
  " * Pauses or finishes (removes from the active queue) all intervals tagged\n"
  " * with auto_pause or auto_finish set to true.  These are intervals that\n"
  " * someone fired up but won't necessarily expect to clean up; they can be\n"
  " * interrupted at will when necessary.\n"
  " *\n"
  " * Returns the number of intervals affected.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_interrupt_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CIntervalManager::get_num_intervals(void) const
 */
static PyObject *Dtool_CIntervalManager_get_num_intervals_73(PyObject *self, PyObject *) {
  CIntervalManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CIntervalManager)) {
    return nullptr;
  }
  // 1-int CIntervalManager::get_num_intervals(void) const
  int return_value = ((*(const CIntervalManager*)local_this).get_num_intervals)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_get_num_intervals_73_comment =
  "C++ Interface:\n"
  "get_num_intervals(CIntervalManager self)\n"
  "\n"
  "/**\n"
  " * Returns the number of currently active intervals.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_get_num_intervals_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CIntervalManager::get_max_index(void) const
 */
static PyObject *Dtool_CIntervalManager_get_max_index_74(PyObject *self, PyObject *) {
  CIntervalManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CIntervalManager)) {
    return nullptr;
  }
  // 1-int CIntervalManager::get_max_index(void) const
  int return_value = ((*(const CIntervalManager*)local_this).get_max_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_get_max_index_74_comment =
  "C++ Interface:\n"
  "get_max_index(CIntervalManager self)\n"
  "\n"
  "/**\n"
  " * Returns one more than the largest interval index number in the manager.  If\n"
  " * you walk through all the values between (0, get_max_index()] and call\n"
  " * get_c_interval() on each number, you will retrieve all of the managed\n"
  " * intervals (and possibly a number of NULL pointers as well).\n"
  " */";
#else
static const char *Dtool_CIntervalManager_get_max_index_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CIntervalManager::step(void)
 */
static PyObject *Dtool_CIntervalManager_step_75(PyObject *self, PyObject *) {
  CIntervalManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CIntervalManager, (void **)&local_this, "CIntervalManager.step")) {
    return nullptr;
  }
  // 1-void CIntervalManager::step(void)
  ((*local_this).step)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_step_75_comment =
  "C++ Interface:\n"
  "step(const CIntervalManager self)\n"
  "\n"
  "/**\n"
  " * This should be called every frame to do the processing for all the active\n"
  " * intervals.  It will call step_play() for each interval that has been added\n"
  " * and that has not yet been removed.\n"
  " *\n"
  " * After each call to step(), the scripting language should call\n"
  " * get_next_event() and get_next_removal() repeatedly to process all the high-\n"
  " * level (e.g.  Python-interval-based) events and to manage the high-level\n"
  " * list of intervals.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_step_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CIntervalManager::get_next_event(void)
 */
static PyObject *Dtool_CIntervalManager_get_next_event_76(PyObject *self, PyObject *) {
  CIntervalManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CIntervalManager, (void **)&local_this, "CIntervalManager.get_next_event")) {
    return nullptr;
  }
  // 1-int CIntervalManager::get_next_event(void)
  int return_value = ((*local_this).get_next_event)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_get_next_event_76_comment =
  "C++ Interface:\n"
  "get_next_event(const CIntervalManager self)\n"
  "\n"
  "/**\n"
  " * This should be called by the scripting language after each call to step().\n"
  " * It returns the index number of the next interval that has events requiring\n"
  " * servicing by the scripting language, or -1 if no more intervals have any\n"
  " * events pending.\n"
  " *\n"
  " * If this function returns something other than -1, it is the scripting\n"
  " * language's responsibility to query the indicated interval for its next\n"
  " * event via get_event_index(), and eventually pop_event().\n"
  " *\n"
  " * Then get_next_event() should be called again until it returns -1.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_get_next_event_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CIntervalManager::get_next_removal(void)
 */
static PyObject *Dtool_CIntervalManager_get_next_removal_77(PyObject *self, PyObject *) {
  CIntervalManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CIntervalManager, (void **)&local_this, "CIntervalManager.get_next_removal")) {
    return nullptr;
  }
  // 1-int CIntervalManager::get_next_removal(void)
  int return_value = ((*local_this).get_next_removal)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_get_next_removal_77_comment =
  "C++ Interface:\n"
  "get_next_removal(const CIntervalManager self)\n"
  "\n"
  "/**\n"
  " * This should be called by the scripting language after each call to step().\n"
  " * It returns the index number of an interval that was recently removed, or -1\n"
  " * if no intervals were removed.\n"
  " *\n"
  " * If this returns something other than -1, the scripting language should\n"
  " * clean up its own data structures accordingly, and then call\n"
  " * get_next_removal() again.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_get_next_removal_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CIntervalManager::output(std::ostream &out) const
 */
static PyObject *Dtool_CIntervalManager_output_78(PyObject *self, PyObject *arg) {
  CIntervalManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CIntervalManager)) {
    return nullptr;
  }
  // 1-void CIntervalManager::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "CIntervalManager.output", false, true);
  if (arg_this != nullptr) {
    ((*(const CIntervalManager*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CIntervalManager self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_output_78_comment =
  "C++ Interface:\n"
  "output(CIntervalManager self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CIntervalManager_output_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CIntervalManager::write(std::ostream &out) const
 */
static PyObject *Dtool_CIntervalManager_write_79(PyObject *self, PyObject *arg) {
  CIntervalManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CIntervalManager)) {
    return nullptr;
  }
  // 1-void CIntervalManager::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "CIntervalManager.write", false, true);
  if (arg_this != nullptr) {
    ((*(const CIntervalManager*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(CIntervalManager self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_write_79_comment =
  "C++ Interface:\n"
  "write(CIntervalManager self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CIntervalManager_write_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static CIntervalManager *CIntervalManager::get_global_ptr(void)
 */
static PyObject *Dtool_CIntervalManager_get_global_ptr_80(PyObject *, PyObject *) {
  // 1-static CIntervalManager *CIntervalManager::get_global_ptr(void)
  CIntervalManager *return_value = (CIntervalManager::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_CIntervalManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CIntervalManager_get_global_ptr_80_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns the pointer to the one global CIntervalManager object.\n"
  " */";
#else
static const char *Dtool_CIntervalManager_get_global_ptr_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CIntervalManager::CIntervalManager(void)
 */
static int Dtool_Init_CIntervalManager(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CIntervalManager() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CIntervalManager() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-CIntervalManager::CIntervalManager(void)
  CIntervalManager *return_value = new CIntervalManager();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CIntervalManager, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CIntervalManager()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CIntervalManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CIntervalManager) {
    printf("CIntervalManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CIntervalManager *local_this = (CIntervalManager *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CIntervalManager) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CIntervalManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CIntervalManager) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CConstraintInterval
 */
/**
 * Python function wrapper for:
 * static TypeHandle CConstraintInterval::get_class_type(void)
 */
static PyObject *Dtool_CConstraintInterval_get_class_type_89(PyObject *, PyObject *) {
  // 1-static TypeHandle CConstraintInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CConstraintInterval::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CConstraintInterval_get_class_type_89_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CConstraintInterval_get_class_type_89_comment = nullptr;
#endif

static PyObject *Dtool_CConstraintInterval_bogus_variable_Getter(PyObject *self, void *) {
  const CConstraintInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CConstraintInterval, (void **)&local_this)) {
    return nullptr;
  }

  // 1-bool CConstraintInterval::get_bogus_variable(void) const
  bool return_value = ((const CConstraintInterval*)local_this)->bogus_variable;
  return Dtool_WrapValue(return_value);
}

static int Dtool_CConstraintInterval_bogus_variable_Setter(PyObject *self, PyObject *arg, void *) {
  CConstraintInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConstraintInterval, (void **)&local_this, "CConstraintInterval.bogus_variable")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete bogus_variable attribute");
    return -1;
  }
  // 1-void CConstraintInterval::set_bogus_variable(bool value)
  (local_this)->bogus_variable = (PyObject_IsTrue(arg) != 0);
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bogus_variable(const CConstraintInterval self, bool value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline CConstraintInterval::CConstraintInterval(CConstraintInterval const &) = default
 */
static int Dtool_Init_CConstraintInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CConstraintInterval() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline CConstraintInterval::CConstraintInterval(CConstraintInterval const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    CConstraintInterval const *param0_this = (CConstraintInterval *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_CConstraintInterval, 0, "CConstraintInterval.CConstraintInterval", true, true);
    if (param0_this != nullptr) {
      CConstraintInterval *return_value = new CConstraintInterval(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstraintInterval, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CConstraintInterval(const CConstraintInterval param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CConstraintInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CConstraintInterval) {
    printf("CConstraintInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CConstraintInterval *local_this = (CConstraintInterval *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CConstraintInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CConstraintInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CConstraintInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CConstraintInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CConstraintInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CConstraintInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CConstraintInterval*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CConstrainHprInterval
 */
/**
 * Python function wrapper for:
 * inline NodePath const &CConstrainHprInterval::get_node(void) const
 */
static PyObject *Dtool_CConstrainHprInterval_get_node_94(PyObject *self, PyObject *) {
  CConstrainHprInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConstrainHprInterval)) {
    return nullptr;
  }
  // 1-inline NodePath const &CConstrainHprInterval::get_node(void) const
  NodePath const *return_value = &(((*(const CConstrainHprInterval*)local_this).get_node)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainHprInterval_get_node_94_comment =
  "C++ Interface:\n"
  "get_node(CConstrainHprInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"source\" node.\n"
  " */";
#else
static const char *Dtool_CConstrainHprInterval_get_node_94_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &CConstrainHprInterval::get_target(void) const
 */
static PyObject *Dtool_CConstrainHprInterval_get_target_95(PyObject *self, PyObject *) {
  CConstrainHprInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConstrainHprInterval)) {
    return nullptr;
  }
  // 1-inline NodePath const &CConstrainHprInterval::get_target(void) const
  NodePath const *return_value = &(((*(const CConstrainHprInterval*)local_this).get_target)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainHprInterval_get_target_95_comment =
  "C++ Interface:\n"
  "get_target(CConstrainHprInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"target\" node.\n"
  " */";
#else
static const char *Dtool_CConstrainHprInterval_get_target_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CConstrainHprInterval::get_class_type(void)
 */
static PyObject *Dtool_CConstrainHprInterval_get_class_type_96(PyObject *, PyObject *) {
  // 1-static TypeHandle CConstrainHprInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CConstrainHprInterval::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainHprInterval_get_class_type_96_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CConstrainHprInterval_get_class_type_96_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CConstrainHprInterval::CConstrainHprInterval(CConstrainHprInterval const &) = default
 * explicit CConstrainHprInterval::CConstrainHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const hprOffset = LVector3::zero())
 */
static int Dtool_Init_CConstrainHprInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CConstrainHprInterval::CConstrainHprInterval(CConstrainHprInterval const &) = default
      CConstrainHprInterval const *arg_this = (CConstrainHprInterval *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CConstrainHprInterval, 0, "CConstrainHprInterval.CConstrainHprInterval", true, true);
      if (arg_this != nullptr) {
        CConstrainHprInterval *return_value = new CConstrainHprInterval(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainHprInterval, true, false);
      }
    }
    break;
  case 5:
  case 6:
    {
      // 1-explicit CConstrainHprInterval::CConstrainHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const hprOffset = LVector3::zero())
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      double param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      PyObject *param5 = nullptr;
      static const char *keyword_list[] = {"name", "duration", "node", "target", "wrt", "hprOffset", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#dOOO|O:CConstrainHprInterval", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5)) {
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "CConstrainHprInterval.CConstrainHprInterval", true, true);
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "CConstrainHprInterval.CConstrainHprInterval", true, true);
        LVecBase3f param5_local;
        LVecBase3 const *param5_this;
        if (param5 != nullptr) {
          param5_this = Dtool_Coerce_LVecBase3f(param5, param5_local);
        } else {
          param5_local = LVector3f::zero();
          param5_this = &param5_local;
        }
        if (param5 != nullptr && !(param5_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param5, 5, "CConstrainHprInterval.CConstrainHprInterval", "LVecBase3f");
          return -1;
        }
        if (param2_this != nullptr && param3_this != nullptr) {
          CConstrainHprInterval *return_value = new CConstrainHprInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainHprInterval, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CConstrainHprInterval() takes 1, 5 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CConstrainHprInterval(const CConstrainHprInterval param0)\n"
      "CConstrainHprInterval(str name, double duration, const NodePath node, const NodePath target, bool wrt, LVecBase3f hprOffset)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CConstrainHprInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CConstrainHprInterval) {
    printf("CConstrainHprInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CConstrainHprInterval *local_this = (CConstrainHprInterval *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CConstrainHprInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CConstraintInterval) {
    return (CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CConstrainHprInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CConstrainHprInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CConstraintInterval) {
    CConstraintInterval* other_this = (CConstraintInterval*)from_this;
    return (CConstrainHprInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CConstrainHprInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CConstrainHprInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CConstrainHprInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CConstrainHprInterval*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CConstrainPosHprInterval
 */
/**
 * Python function wrapper for:
 * inline NodePath const &CConstrainPosHprInterval::get_node(void) const
 */
static PyObject *Dtool_CConstrainPosHprInterval_get_node_100(PyObject *self, PyObject *) {
  CConstrainPosHprInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConstrainPosHprInterval)) {
    return nullptr;
  }
  // 1-inline NodePath const &CConstrainPosHprInterval::get_node(void) const
  NodePath const *return_value = &(((*(const CConstrainPosHprInterval*)local_this).get_node)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainPosHprInterval_get_node_100_comment =
  "C++ Interface:\n"
  "get_node(CConstrainPosHprInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"source\" node.\n"
  " */";
#else
static const char *Dtool_CConstrainPosHprInterval_get_node_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &CConstrainPosHprInterval::get_target(void) const
 */
static PyObject *Dtool_CConstrainPosHprInterval_get_target_101(PyObject *self, PyObject *) {
  CConstrainPosHprInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConstrainPosHprInterval)) {
    return nullptr;
  }
  // 1-inline NodePath const &CConstrainPosHprInterval::get_target(void) const
  NodePath const *return_value = &(((*(const CConstrainPosHprInterval*)local_this).get_target)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainPosHprInterval_get_target_101_comment =
  "C++ Interface:\n"
  "get_target(CConstrainPosHprInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"target\" node.\n"
  " */";
#else
static const char *Dtool_CConstrainPosHprInterval_get_target_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CConstrainPosHprInterval::get_class_type(void)
 */
static PyObject *Dtool_CConstrainPosHprInterval_get_class_type_102(PyObject *, PyObject *) {
  // 1-static TypeHandle CConstrainPosHprInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CConstrainPosHprInterval::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainPosHprInterval_get_class_type_102_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CConstrainPosHprInterval_get_class_type_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CConstrainPosHprInterval::CConstrainPosHprInterval(CConstrainPosHprInterval const &) = default
 * explicit CConstrainPosHprInterval::CConstrainPosHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset = LVector3::zero(), LVecBase3 const hprOffset = LVector3::zero())
 */
static int Dtool_Init_CConstrainPosHprInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CConstrainPosHprInterval::CConstrainPosHprInterval(CConstrainPosHprInterval const &) = default
      CConstrainPosHprInterval const *arg_this = (CConstrainPosHprInterval *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CConstrainPosHprInterval, 0, "CConstrainPosHprInterval.CConstrainPosHprInterval", true, true);
      if (arg_this != nullptr) {
        CConstrainPosHprInterval *return_value = new CConstrainPosHprInterval(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainPosHprInterval, true, false);
      }
    }
    break;
  case 5:
  case 6:
  case 7:
    {
      // 1-explicit CConstrainPosHprInterval::CConstrainPosHprInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset = LVector3::zero(), LVecBase3 const hprOffset = LVector3::zero())
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      double param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      PyObject *param5 = nullptr;
      PyObject *param6 = nullptr;
      static const char *keyword_list[] = {"name", "duration", "node", "target", "wrt", "posOffset", "hprOffset", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#dOOO|OO:CConstrainPosHprInterval", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5, &param6)) {
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "CConstrainPosHprInterval.CConstrainPosHprInterval", true, true);
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "CConstrainPosHprInterval.CConstrainPosHprInterval", true, true);
        LVecBase3f param5_local;
        LVecBase3 const *param5_this;
        if (param5 != nullptr) {
          param5_this = Dtool_Coerce_LVecBase3f(param5, param5_local);
        } else {
          param5_local = LVector3f::zero();
          param5_this = &param5_local;
        }
        if (param5 != nullptr && !(param5_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param5, 5, "CConstrainPosHprInterval.CConstrainPosHprInterval", "LVecBase3f");
          return -1;
        }
        LVecBase3f param6_local;
        LVecBase3 const *param6_this;
        if (param6 != nullptr) {
          param6_this = Dtool_Coerce_LVecBase3f(param6, param6_local);
        } else {
          param6_local = LVector3f::zero();
          param6_this = &param6_local;
        }
        if (param6 != nullptr && !(param6_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param6, 6, "CConstrainPosHprInterval.CConstrainPosHprInterval", "LVecBase3f");
          return -1;
        }
        if (param2_this != nullptr && param3_this != nullptr) {
          CConstrainPosHprInterval *return_value = new CConstrainPosHprInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this, *param6_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainPosHprInterval, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CConstrainPosHprInterval() takes 1, 5, 6 or 7 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CConstrainPosHprInterval(const CConstrainPosHprInterval param0)\n"
      "CConstrainPosHprInterval(str name, double duration, const NodePath node, const NodePath target, bool wrt, LVecBase3f posOffset, LVecBase3f hprOffset)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CConstrainPosHprInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CConstrainPosHprInterval) {
    printf("CConstrainPosHprInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CConstrainPosHprInterval *local_this = (CConstrainPosHprInterval *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CConstrainPosHprInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CConstraintInterval) {
    return (CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CConstrainPosHprInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CConstrainPosHprInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CConstraintInterval) {
    CConstraintInterval* other_this = (CConstraintInterval*)from_this;
    return (CConstrainPosHprInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CConstrainPosHprInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CConstrainPosHprInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CConstrainPosHprInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CConstrainPosHprInterval*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CConstrainPosInterval
 */
/**
 * Python function wrapper for:
 * inline NodePath const &CConstrainPosInterval::get_node(void) const
 */
static PyObject *Dtool_CConstrainPosInterval_get_node_106(PyObject *self, PyObject *) {
  CConstrainPosInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConstrainPosInterval)) {
    return nullptr;
  }
  // 1-inline NodePath const &CConstrainPosInterval::get_node(void) const
  NodePath const *return_value = &(((*(const CConstrainPosInterval*)local_this).get_node)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainPosInterval_get_node_106_comment =
  "C++ Interface:\n"
  "get_node(CConstrainPosInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"source\" node.\n"
  " */";
#else
static const char *Dtool_CConstrainPosInterval_get_node_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &CConstrainPosInterval::get_target(void) const
 */
static PyObject *Dtool_CConstrainPosInterval_get_target_107(PyObject *self, PyObject *) {
  CConstrainPosInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConstrainPosInterval)) {
    return nullptr;
  }
  // 1-inline NodePath const &CConstrainPosInterval::get_target(void) const
  NodePath const *return_value = &(((*(const CConstrainPosInterval*)local_this).get_target)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainPosInterval_get_target_107_comment =
  "C++ Interface:\n"
  "get_target(CConstrainPosInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"target\" node.\n"
  " */";
#else
static const char *Dtool_CConstrainPosInterval_get_target_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CConstrainPosInterval::get_class_type(void)
 */
static PyObject *Dtool_CConstrainPosInterval_get_class_type_108(PyObject *, PyObject *) {
  // 1-static TypeHandle CConstrainPosInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CConstrainPosInterval::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainPosInterval_get_class_type_108_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CConstrainPosInterval_get_class_type_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CConstrainPosInterval::CConstrainPosInterval(CConstrainPosInterval const &) = default
 * explicit CConstrainPosInterval::CConstrainPosInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset = LVector3::zero())
 */
static int Dtool_Init_CConstrainPosInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CConstrainPosInterval::CConstrainPosInterval(CConstrainPosInterval const &) = default
      CConstrainPosInterval const *arg_this = (CConstrainPosInterval *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CConstrainPosInterval, 0, "CConstrainPosInterval.CConstrainPosInterval", true, true);
      if (arg_this != nullptr) {
        CConstrainPosInterval *return_value = new CConstrainPosInterval(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainPosInterval, true, false);
      }
    }
    break;
  case 5:
  case 6:
    {
      // 1-explicit CConstrainPosInterval::CConstrainPosInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3 const posOffset = LVector3::zero())
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      double param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      PyObject *param5 = nullptr;
      static const char *keyword_list[] = {"name", "duration", "node", "target", "wrt", "posOffset", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#dOOO|O:CConstrainPosInterval", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5)) {
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "CConstrainPosInterval.CConstrainPosInterval", true, true);
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "CConstrainPosInterval.CConstrainPosInterval", true, true);
        LVecBase3f param5_local;
        LVecBase3 const *param5_this;
        if (param5 != nullptr) {
          param5_this = Dtool_Coerce_LVecBase3f(param5, param5_local);
        } else {
          param5_local = LVector3f::zero();
          param5_this = &param5_local;
        }
        if (param5 != nullptr && !(param5_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param5, 5, "CConstrainPosInterval.CConstrainPosInterval", "LVecBase3f");
          return -1;
        }
        if (param2_this != nullptr && param3_this != nullptr) {
          CConstrainPosInterval *return_value = new CConstrainPosInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0), *param5_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainPosInterval, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CConstrainPosInterval() takes 1, 5 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CConstrainPosInterval(const CConstrainPosInterval param0)\n"
      "CConstrainPosInterval(str name, double duration, const NodePath node, const NodePath target, bool wrt, LVecBase3f posOffset)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CConstrainPosInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CConstrainPosInterval) {
    printf("CConstrainPosInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CConstrainPosInterval *local_this = (CConstrainPosInterval *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CConstrainPosInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CConstraintInterval) {
    return (CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CConstrainPosInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CConstrainPosInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CConstraintInterval) {
    CConstraintInterval* other_this = (CConstraintInterval*)from_this;
    return (CConstrainPosInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CConstrainPosInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CConstrainPosInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CConstrainPosInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CConstrainPosInterval*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CConstrainTransformInterval
 */
/**
 * Python function wrapper for:
 * inline NodePath const &CConstrainTransformInterval::get_node(void) const
 */
static PyObject *Dtool_CConstrainTransformInterval_get_node_112(PyObject *self, PyObject *) {
  CConstrainTransformInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConstrainTransformInterval)) {
    return nullptr;
  }
  // 1-inline NodePath const &CConstrainTransformInterval::get_node(void) const
  NodePath const *return_value = &(((*(const CConstrainTransformInterval*)local_this).get_node)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainTransformInterval_get_node_112_comment =
  "C++ Interface:\n"
  "get_node(CConstrainTransformInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"source\" node.\n"
  " */";
#else
static const char *Dtool_CConstrainTransformInterval_get_node_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &CConstrainTransformInterval::get_target(void) const
 */
static PyObject *Dtool_CConstrainTransformInterval_get_target_113(PyObject *self, PyObject *) {
  CConstrainTransformInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConstrainTransformInterval)) {
    return nullptr;
  }
  // 1-inline NodePath const &CConstrainTransformInterval::get_target(void) const
  NodePath const *return_value = &(((*(const CConstrainTransformInterval*)local_this).get_target)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainTransformInterval_get_target_113_comment =
  "C++ Interface:\n"
  "get_target(CConstrainTransformInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"target\" node.\n"
  " */";
#else
static const char *Dtool_CConstrainTransformInterval_get_target_113_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CConstrainTransformInterval::get_class_type(void)
 */
static PyObject *Dtool_CConstrainTransformInterval_get_class_type_114(PyObject *, PyObject *) {
  // 1-static TypeHandle CConstrainTransformInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CConstrainTransformInterval::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CConstrainTransformInterval_get_class_type_114_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CConstrainTransformInterval_get_class_type_114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CConstrainTransformInterval::CConstrainTransformInterval(CConstrainTransformInterval const &) = default
 * explicit CConstrainTransformInterval::CConstrainTransformInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt)
 */
static int Dtool_Init_CConstrainTransformInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CConstrainTransformInterval::CConstrainTransformInterval(CConstrainTransformInterval const &) = default
      CConstrainTransformInterval const *arg_this = (CConstrainTransformInterval *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CConstrainTransformInterval, 0, "CConstrainTransformInterval.CConstrainTransformInterval", true, true);
      if (arg_this != nullptr) {
        CConstrainTransformInterval *return_value = new CConstrainTransformInterval(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainTransformInterval, true, false);
      }
    }
    break;
  case 5:
    {
      // 1-explicit CConstrainTransformInterval::CConstrainTransformInterval(std::string const &name, double duration, NodePath const &node, NodePath const &target, bool wrt)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      double param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      static const char *keyword_list[] = {"name", "duration", "node", "target", "wrt", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#dOOO:CConstrainTransformInterval", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4)) {
        NodePath const *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_NodePath, 2, "CConstrainTransformInterval.CConstrainTransformInterval", true, true);
        NodePath const *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_NodePath, 3, "CConstrainTransformInterval.CConstrainTransformInterval", true, true);
        if (param2_this != nullptr && param3_this != nullptr) {
          CConstrainTransformInterval *return_value = new CConstrainTransformInterval(std::string(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConstrainTransformInterval, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CConstrainTransformInterval() takes 1 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CConstrainTransformInterval(const CConstrainTransformInterval param0)\n"
      "CConstrainTransformInterval(str name, double duration, const NodePath node, const NodePath target, bool wrt)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CConstrainTransformInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CConstrainTransformInterval) {
    printf("CConstrainTransformInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CConstrainTransformInterval *local_this = (CConstrainTransformInterval *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CConstrainTransformInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CConstraintInterval) {
    return (CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *)(CConstraintInterval *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CConstrainTransformInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CConstrainTransformInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CConstraintInterval) {
    CConstraintInterval* other_this = (CConstraintInterval*)from_this;
    return (CConstrainTransformInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CConstrainTransformInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CConstrainTransformInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CConstrainTransformInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CConstrainTransformInterval*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CLerpInterval
 */
/**
 * Python function wrapper for:
 * inline CLerpInterval::BlendType CLerpInterval::get_blend_type(void) const
 */
static PyObject *Dtool_CLerpInterval_get_blend_type_118(PyObject *self, PyObject *) {
  CLerpInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CLerpInterval)) {
    return nullptr;
  }
  // 1-inline CLerpInterval::BlendType CLerpInterval::get_blend_type(void) const
  CLerpInterval::BlendType return_value = ((*(const CLerpInterval*)local_this).get_blend_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CLerpInterval_get_blend_type_118_comment =
  "C++ Interface:\n"
  "get_blend_type(CLerpInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the blend type specified for the interval.  This controls how the\n"
  " * linear interpolation behaves near the beginning and end of the lerp period.\n"
  " */";
#else
static const char *Dtool_CLerpInterval_get_blend_type_118_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static CLerpInterval::BlendType CLerpInterval::string_blend_type(std::string const &blend_type)
 */
static PyObject *Dtool_CLerpInterval_string_blend_type_119(PyObject *, PyObject *arg) {
  // 1-static CLerpInterval::BlendType CLerpInterval::string_blend_type(std::string const &blend_type)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    CLerpInterval::BlendType return_value = (CLerpInterval::string_blend_type)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "string_blend_type(str blend_type)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpInterval_string_blend_type_119_comment =
  "C++ Interface:\n"
  "string_blend_type(str blend_type)\n"
  "\n"
  "/**\n"
  " * Returns the BlendType enumerated value corresponding to the indicated\n"
  " * string, or BT_invalid if the string doesn't match anything.\n"
  " */";
#else
static const char *Dtool_CLerpInterval_string_blend_type_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CLerpInterval::get_class_type(void)
 */
static PyObject *Dtool_CLerpInterval_get_class_type_120(PyObject *, PyObject *) {
  // 1-static TypeHandle CLerpInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CLerpInterval::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CLerpInterval_get_class_type_120_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CLerpInterval_get_class_type_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CLerpInterval::CLerpInterval(CLerpInterval const &) = default
 */
static int Dtool_Init_CLerpInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CLerpInterval() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline CLerpInterval::CLerpInterval(CLerpInterval const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    CLerpInterval const *param0_this = (CLerpInterval *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_CLerpInterval, 0, "CLerpInterval.CLerpInterval", true, true);
    if (param0_this != nullptr) {
      CLerpInterval *return_value = new CLerpInterval(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CLerpInterval, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CLerpInterval(const CLerpInterval param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CLerpInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CLerpInterval) {
    printf("CLerpInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CLerpInterval *local_this = (CLerpInterval *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CLerpInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CLerpInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CLerpInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CLerpInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CLerpInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CLerpInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CLerpInterval*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CLerpAnimEffectInterval
 */
/**
 * Python function wrapper for:
 * inline void CLerpAnimEffectInterval::add_control(AnimControl *control, std::string const &name, float begin_effect, float end_effect)
 */
static PyObject *Dtool_CLerpAnimEffectInterval_add_control_125(PyObject *self, PyObject *args, PyObject *kwds) {
  CLerpAnimEffectInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpAnimEffectInterval, (void **)&local_this, "CLerpAnimEffectInterval.add_control")) {
    return nullptr;
  }
  // 1-inline void CLerpAnimEffectInterval::add_control(AnimControl *control, std::string const &name, float begin_effect, float end_effect)
  PyObject *param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  float param3;
  float param4;
  static const char *keyword_list[] = {"control", "name", "begin_effect", "end_effect", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#ff:add_control", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3, &param4)) {
    AnimControl *param1_this = (AnimControl *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_AnimControl, 1, "CLerpAnimEffectInterval.add_control", false, true);
    if (param1_this != nullptr) {
      ((*local_this).add_control)(param1_this, std::string(param2_str, param2_len), (float)param3, (float)param4);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_control(const CLerpAnimEffectInterval self, AnimControl control, str name, float begin_effect, float end_effect)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpAnimEffectInterval_add_control_125_comment =
  "C++ Interface:\n"
  "add_control(const CLerpAnimEffectInterval self, AnimControl control, str name, float begin_effect, float end_effect)\n"
  "\n"
  "/**\n"
  " * Adds another AnimControl to the list of AnimControls affected by the lerp.\n"
  " * This control will be lerped from begin_effect to end_effect over the period\n"
  " * of the lerp.\n"
  " *\n"
  " * The AnimControl name parameter is only used when formatting the interval\n"
  " * for output.\n"
  " */";
#else
static const char *Dtool_CLerpAnimEffectInterval_add_control_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CLerpAnimEffectInterval::get_class_type(void)
 */
static PyObject *Dtool_CLerpAnimEffectInterval_get_class_type_126(PyObject *, PyObject *) {
  // 1-static TypeHandle CLerpAnimEffectInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CLerpAnimEffectInterval::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CLerpAnimEffectInterval_get_class_type_126_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CLerpAnimEffectInterval_get_class_type_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CLerpAnimEffectInterval::CLerpAnimEffectInterval(CLerpAnimEffectInterval const &) = default
 * inline explicit CLerpAnimEffectInterval::CLerpAnimEffectInterval(std::string const &name, double duration, CLerpInterval::BlendType blend_type)
 */
static int Dtool_Init_CLerpAnimEffectInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CLerpAnimEffectInterval::CLerpAnimEffectInterval(CLerpAnimEffectInterval const &) = default
      CLerpAnimEffectInterval const *arg_this = (CLerpAnimEffectInterval *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CLerpAnimEffectInterval, 0, "CLerpAnimEffectInterval.CLerpAnimEffectInterval", true, true);
      if (arg_this != nullptr) {
        CLerpAnimEffectInterval *return_value = new CLerpAnimEffectInterval(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CLerpAnimEffectInterval, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline explicit CLerpAnimEffectInterval::CLerpAnimEffectInterval(std::string const &name, double duration, CLerpInterval::BlendType blend_type)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      double param1;
      int param2;
      static const char *keyword_list[] = {"name", "duration", "blend_type", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#di:CLerpAnimEffectInterval", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2)) {
        CLerpAnimEffectInterval *return_value = new CLerpAnimEffectInterval(std::string(param0_str, param0_len), (double)param1, (CLerpInterval::BlendType)param2);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CLerpAnimEffectInterval, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CLerpAnimEffectInterval() takes 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CLerpAnimEffectInterval(const CLerpAnimEffectInterval param0)\n"
      "CLerpAnimEffectInterval(str name, double duration, int blend_type)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CLerpAnimEffectInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CLerpAnimEffectInterval) {
    printf("CLerpAnimEffectInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CLerpAnimEffectInterval *local_this = (CLerpAnimEffectInterval *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CLerpAnimEffectInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *)(CLerpInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_CLerpInterval) {
    return (CLerpInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *)(CLerpInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *)(CLerpInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *)(CLerpInterval *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CLerpAnimEffectInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CLerpAnimEffectInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CLerpAnimEffectInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_CLerpInterval) {
    CLerpInterval* other_this = (CLerpInterval*)from_this;
    return (CLerpAnimEffectInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CLerpAnimEffectInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CLerpAnimEffectInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CLerpAnimEffectInterval*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CLerpNodePathInterval
 */
/**
 * Python function wrapper for:
 * inline NodePath const &CLerpNodePathInterval::get_node(void) const
 */
static PyObject *Dtool_CLerpNodePathInterval_get_node_130(PyObject *self, PyObject *) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CLerpNodePathInterval)) {
    return nullptr;
  }
  // 1-inline NodePath const &CLerpNodePathInterval::get_node(void) const
  NodePath const *return_value = &(((*(const CLerpNodePathInterval*)local_this).get_node)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_get_node_130_comment =
  "C++ Interface:\n"
  "get_node(CLerpNodePathInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the node being lerped.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_get_node_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath const &CLerpNodePathInterval::get_other(void) const
 */
static PyObject *Dtool_CLerpNodePathInterval_get_other_131(PyObject *self, PyObject *) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CLerpNodePathInterval)) {
    return nullptr;
  }
  // 1-inline NodePath const &CLerpNodePathInterval::get_other(void) const
  NodePath const *return_value = &(((*(const CLerpNodePathInterval*)local_this).get_other)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, false, true);
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_get_other_131_comment =
  "C++ Interface:\n"
  "get_other(CLerpNodePathInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the \"other\" node, which the lerped node is being moved relative to.\n"
  " * If this is an empty node path, the lerped node is being moved in its own\n"
  " * coordinate system.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_get_other_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_pos(LVecBase3 const &pos)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_pos_132(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_pos")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_start_pos(LVecBase3 const &pos)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_start_pos", "LVecBase3f");
  }
  ((*local_this).set_start_pos)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_pos(const CLerpNodePathInterval self, const LVecBase3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_pos_132_comment =
  "C++ Interface:\n"
  "set_start_pos(const CLerpNodePathInterval self, const LVecBase3f pos)\n"
  "\n"
  "/**\n"
  " * Indicates the initial position of the lerped node.  This is meaningful only\n"
  " * if set_end_pos() is also called.  This parameter is optional; if\n"
  " * unspecified, the value will be taken from the node's actual position at the\n"
  " * time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_pos_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_pos(LVecBase3 const &pos)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_pos_133(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_pos")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_end_pos(LVecBase3 const &pos)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_end_pos", "LVecBase3f");
  }
  ((*local_this).set_end_pos)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_pos(const CLerpNodePathInterval self, const LVecBase3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_pos_133_comment =
  "C++ Interface:\n"
  "set_end_pos(const CLerpNodePathInterval self, const LVecBase3f pos)\n"
  "\n"
  "/**\n"
  " * Indicates that the position of the node should be lerped, and specifies the\n"
  " * final position of the node.  This should be called before\n"
  " * priv_initialize().  If this is not called, the node's position will not be\n"
  " * affected by the lerp.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_pos_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_hpr(LVecBase3 const &hpr)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_hpr_134(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_hpr")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_start_hpr(LVecBase3 const &hpr)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_start_hpr", "LVecBase3f");
  }
  ((*local_this).set_start_hpr)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_hpr(const CLerpNodePathInterval self, const LVecBase3f hpr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_hpr_134_comment =
  "C++ Interface:\n"
  "set_start_hpr(const CLerpNodePathInterval self, const LVecBase3f hpr)\n"
  "\n"
  "/**\n"
  " * Indicates the initial rotation of the lerped node.  This is meaningful only\n"
  " * if either set_end_hpr() or set_end_quat() is also called.  This parameter\n"
  " * is optional; if unspecified, the value will be taken from the node's actual\n"
  " * rotation at the time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_hpr_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_hpr(LQuaternion const &quat)
 * inline void CLerpNodePathInterval::set_end_hpr(LVecBase3 const &hpr)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_hpr_135(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_hpr")) {
    return nullptr;
  }
  {
    // -2 inline void CLerpNodePathInterval::set_end_hpr(LQuaternion const &quat)
    LQuaternion const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LQuaternionf);
    if (arg_this != nullptr) {
      ((*local_this).set_end_hpr)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_end_hpr(LVecBase3 const &hpr)
    LVecBase3 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3f);
    if (arg_this != nullptr) {
      ((*local_this).set_end_hpr)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_end_hpr(LQuaternion const &quat)
    LQuaternionf arg_local;
    LQuaternion const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_end_hpr)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_end_hpr(LVecBase3 const &hpr)
    LVecBase3f arg_local;
    LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_end_hpr)(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_hpr(const CLerpNodePathInterval self, const LQuaternionf quat)\n"
      "set_end_hpr(const CLerpNodePathInterval self, const LVecBase3f hpr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_hpr_135_comment =
  "C++ Interface:\n"
  "set_end_hpr(const CLerpNodePathInterval self, const LQuaternionf quat)\n"
  "set_end_hpr(const CLerpNodePathInterval self, const LVecBase3f hpr)\n"
  "\n"
  "/**\n"
  " * Indicates that the rotation of the node should be lerped, and specifies the\n"
  " * final rotation of the node.  This should be called before\n"
  " * priv_initialize().\n"
  " *\n"
  " * This replaces a previous call to set_end_quat().  If neither set_end_hpr()\n"
  " * nor set_end_quat() is called, the node's rotation will not be affected by\n"
  " * the lerp.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Indicates that the rotation of the node should be lerped, and specifies the\n"
  " * final rotation of the node.  This should be called before\n"
  " * priv_initialize().\n"
  " *\n"
  " * This special function is overloaded to accept a quaternion, even though the\n"
  " * function name is set_end_hpr().  The quaternion will be implicitly\n"
  " * converted to a HPR trio, and the lerp will be performed in HPR space,\n"
  " * componentwise.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_hpr_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_quat(LQuaternion const &quat)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_quat_136(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_quat")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_start_quat(LQuaternion const &quat)
  LQuaternionf arg_local;
  LQuaternion const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_start_quat", "LQuaternionf");
  }
  ((*local_this).set_start_quat)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_quat(const CLerpNodePathInterval self, const LQuaternionf quat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_quat_136_comment =
  "C++ Interface:\n"
  "set_start_quat(const CLerpNodePathInterval self, const LQuaternionf quat)\n"
  "\n"
  "/**\n"
  " * Indicates the initial rotation of the lerped node.  This is meaningful only\n"
  " * if either set_end_quat() or set_end_hpr() is also called.  This parameter\n"
  " * is optional; if unspecified, the value will be taken from the node's actual\n"
  " * rotation at the time the lerp is performed.\n"
  " *\n"
  " * The given quaternion needs to be normalized.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_quat_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_quat(LQuaternion const &quat)
 * inline void CLerpNodePathInterval::set_end_quat(LVecBase3 const &hpr)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_quat_137(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_quat")) {
    return nullptr;
  }
  {
    // -2 inline void CLerpNodePathInterval::set_end_quat(LQuaternion const &quat)
    LQuaternion const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LQuaternionf);
    if (arg_this != nullptr) {
      ((*local_this).set_end_quat)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_end_quat(LVecBase3 const &hpr)
    LVecBase3 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3f);
    if (arg_this != nullptr) {
      ((*local_this).set_end_quat)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_end_quat(LQuaternion const &quat)
    LQuaternionf arg_local;
    LQuaternion const *arg_this = Dtool_Coerce_LQuaternionf(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_end_quat)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_end_quat(LVecBase3 const &hpr)
    LVecBase3f arg_local;
    LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_end_quat)(*arg_this);
      return Dtool_Return_None();
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_quat(const CLerpNodePathInterval self, const LQuaternionf quat)\n"
      "set_end_quat(const CLerpNodePathInterval self, const LVecBase3f hpr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_quat_137_comment =
  "C++ Interface:\n"
  "set_end_quat(const CLerpNodePathInterval self, const LQuaternionf quat)\n"
  "set_end_quat(const CLerpNodePathInterval self, const LVecBase3f hpr)\n"
  "\n"
  "/**\n"
  " * Indicates that the rotation of the node should be lerped, and specifies the\n"
  " * final rotation of the node.  This should be called before\n"
  " * priv_initialize().\n"
  " *\n"
  " * This replaces a previous call to set_end_hpr().  If neither set_end_quat()\n"
  " * nor set_end_hpr() is called, the node's rotation will not be affected by\n"
  " * the lerp.\n"
  " *\n"
  " * This special function is overloaded to accept a HPR trio, even though the\n"
  " * function name is set_end_quat().  The HPR will be implicitly converted to a\n"
  " * quaternion, and the lerp will be performed in quaternion space, as a\n"
  " * spherical lerp.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Indicates that the rotation of the node should be lerped, and specifies the\n"
  " * final rotation of the node.  This should be called before\n"
  " * priv_initialize().\n"
  " *\n"
  " * This replaces a previous call to set_end_hpr().  If neither set_end_quat()\n"
  " * nor set_end_hpr() is called, the node's rotation will not be affected by\n"
  " * the lerp.\n"
  " *\n"
  " * The given quaternion needs to be normalized.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_quat_137_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_scale(LVecBase3 const &scale)
 * inline void CLerpNodePathInterval::set_start_scale(PN_stdfloat scale)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_scale_138(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_scale")) {
    return nullptr;
  }
  {
    // -2 inline void CLerpNodePathInterval::set_start_scale(LVecBase3 const &scale)
    LVecBase3 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3f);
    if (arg_this != nullptr) {
      ((*local_this).set_start_scale)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_start_scale(PN_stdfloat scale)
    if (PyNumber_Check(arg)) {
      ((*local_this).set_start_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_start_scale(LVecBase3 const &scale)
    LVecBase3f arg_local;
    LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_start_scale)(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: inline void CLerpNodePathInterval::set_start_scale(PN_stdfloat scale)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_scale(const CLerpNodePathInterval self, const LVecBase3f scale)\n"
      "set_start_scale(const CLerpNodePathInterval self, float scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_scale_138_comment =
  "C++ Interface:\n"
  "set_start_scale(const CLerpNodePathInterval self, const LVecBase3f scale)\n"
  "set_start_scale(const CLerpNodePathInterval self, float scale)\n"
  "\n"
  "/**\n"
  " * Indicates the initial scale of the lerped node.  This is meaningful only if\n"
  " * set_end_scale() is also called.  This parameter is optional; if\n"
  " * unspecified, the value will be taken from the node's actual scale at the\n"
  " * time the lerp is performed.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Indicates the initial scale of the lerped node.  This is meaningful only if\n"
  " * set_end_scale() is also called.  This parameter is optional; if\n"
  " * unspecified, the value will be taken from the node's actual scale at the\n"
  " * time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_scale_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_scale(LVecBase3 const &scale)
 * inline void CLerpNodePathInterval::set_end_scale(PN_stdfloat scale)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_scale_139(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_scale")) {
    return nullptr;
  }
  {
    // -2 inline void CLerpNodePathInterval::set_end_scale(LVecBase3 const &scale)
    LVecBase3 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3f);
    if (arg_this != nullptr) {
      ((*local_this).set_end_scale)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_end_scale(PN_stdfloat scale)
    if (PyNumber_Check(arg)) {
      ((*local_this).set_end_scale)((PN_stdfloat)PyFloat_AsDouble(arg));
      return Dtool_Return_None();
    }
  }

  {
    // -2 inline void CLerpNodePathInterval::set_end_scale(LVecBase3 const &scale)
    LVecBase3f arg_local;
    LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_end_scale)(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: inline void CLerpNodePathInterval::set_end_scale(PN_stdfloat scale)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_scale(const CLerpNodePathInterval self, const LVecBase3f scale)\n"
      "set_end_scale(const CLerpNodePathInterval self, float scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_scale_139_comment =
  "C++ Interface:\n"
  "set_end_scale(const CLerpNodePathInterval self, const LVecBase3f scale)\n"
  "set_end_scale(const CLerpNodePathInterval self, float scale)\n"
  "\n"
  "/**\n"
  " * Indicates that the scale of the node should be lerped, and specifies the\n"
  " * final scale of the node.  This should be called before priv_initialize().\n"
  " * If this is not called, the node's scale will not be affected by the lerp.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Indicates that the scale of the node should be lerped, and specifies the\n"
  " * final scale of the node.  This should be called before priv_initialize().\n"
  " * If this is not called, the node's scale will not be affected by the lerp.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_scale_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_shear(LVecBase3 const &shear)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_shear_140(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_shear")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_start_shear(LVecBase3 const &shear)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_start_shear", "LVecBase3f");
  }
  ((*local_this).set_start_shear)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_shear(const CLerpNodePathInterval self, const LVecBase3f shear)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_shear_140_comment =
  "C++ Interface:\n"
  "set_start_shear(const CLerpNodePathInterval self, const LVecBase3f shear)\n"
  "\n"
  "/**\n"
  " * Indicates the initial shear of the lerped node.  This is meaningful only if\n"
  " * set_end_shear() is also called.  This parameter is optional; if\n"
  " * unspecified, the value will be taken from the node's actual shear at the\n"
  " * time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_shear_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_shear(LVecBase3 const &shear)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_shear_141(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_shear")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_end_shear(LVecBase3 const &shear)
  LVecBase3f arg_local;
  LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_end_shear", "LVecBase3f");
  }
  ((*local_this).set_end_shear)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_shear(const CLerpNodePathInterval self, const LVecBase3f shear)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_shear_141_comment =
  "C++ Interface:\n"
  "set_end_shear(const CLerpNodePathInterval self, const LVecBase3f shear)\n"
  "\n"
  "/**\n"
  " * Indicates that the shear of the node should be lerped, and specifies the\n"
  " * final shear of the node.  This should be called before priv_initialize().\n"
  " * If this is not called, the node's shear will not be affected by the lerp.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_shear_141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_color(LVecBase4 const &color)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_color_142(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_color")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_start_color(LVecBase4 const &color)
  LVecBase4f arg_local;
  LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_start_color", "LVecBase4f");
  }
  ((*local_this).set_start_color)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_color(const CLerpNodePathInterval self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_color_142_comment =
  "C++ Interface:\n"
  "set_start_color(const CLerpNodePathInterval self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Indicates the initial color of the lerped node.  This is meaningful only if\n"
  " * set_end_color() is also called.  This parameter is optional; if\n"
  " * unspecified, the value will be taken from the node's actual color at the\n"
  " * time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_color_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_color(LVecBase4 const &color)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_color_143(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_color")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_end_color(LVecBase4 const &color)
  LVecBase4f arg_local;
  LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_end_color", "LVecBase4f");
  }
  ((*local_this).set_end_color)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_color(const CLerpNodePathInterval self, const LVecBase4f color)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_color_143_comment =
  "C++ Interface:\n"
  "set_end_color(const CLerpNodePathInterval self, const LVecBase4f color)\n"
  "\n"
  "/**\n"
  " * Indicates that the color of the node should be lerped, and specifies the\n"
  " * final color of the node.  This should be called before priv_initialize().\n"
  " * If this is not called, the node's color will not be affected by the lerp.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_color_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_color_scale(LVecBase4 const &color_scale)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_color_scale_144(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_color_scale")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_start_color_scale(LVecBase4 const &color_scale)
  LVecBase4f arg_local;
  LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_start_color_scale", "LVecBase4f");
  }
  ((*local_this).set_start_color_scale)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_color_scale(const CLerpNodePathInterval self, const LVecBase4f color_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_color_scale_144_comment =
  "C++ Interface:\n"
  "set_start_color_scale(const CLerpNodePathInterval self, const LVecBase4f color_scale)\n"
  "\n"
  "/**\n"
  " * Indicates the initial color scale of the lerped node.  This is meaningful\n"
  " * only if set_end_color_scale() is also called.  This parameter is optional;\n"
  " * if unspecified, the value will be taken from the node's actual color scale\n"
  " * at the time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_color_scale_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_color_scale(LVecBase4 const &color_scale)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_color_scale_145(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_color_scale")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_end_color_scale(LVecBase4 const &color_scale)
  LVecBase4f arg_local;
  LVecBase4 const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_end_color_scale", "LVecBase4f");
  }
  ((*local_this).set_end_color_scale)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_color_scale(const CLerpNodePathInterval self, const LVecBase4f color_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_color_scale_145_comment =
  "C++ Interface:\n"
  "set_end_color_scale(const CLerpNodePathInterval self, const LVecBase4f color_scale)\n"
  "\n"
  "/**\n"
  " * Indicates that the color scale of the node should be lerped, and specifies\n"
  " * the final color scale of the node.  This should be called before\n"
  " * priv_initialize().  If this is not called, the node's color scale will not\n"
  " * be affected by the lerp.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_color_scale_145_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_texture_stage(TextureStage *stage)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_texture_stage_146(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_texture_stage")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_texture_stage(TextureStage *stage)
  TextureStage *arg_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TextureStage, 1, "CLerpNodePathInterval.set_texture_stage", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_texture_stage)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture_stage(const CLerpNodePathInterval self, TextureStage stage)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_texture_stage_146_comment =
  "C++ Interface:\n"
  "set_texture_stage(const CLerpNodePathInterval self, TextureStage stage)\n"
  "\n"
  "/**\n"
  " * Indicates the texture stage that is adjusted by tex_offset, tex_rotate,\n"
  " * and/or tex_scale.  If this is not set, the default is the default texture\n"
  " * stage.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_texture_stage_146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_tex_offset(LVecBase2 const &tex_offset)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_tex_offset_147(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_tex_offset")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_start_tex_offset(LVecBase2 const &tex_offset)
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_start_tex_offset", "LVecBase2f");
  }
  ((*local_this).set_start_tex_offset)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_tex_offset(const CLerpNodePathInterval self, const LVecBase2f tex_offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_tex_offset_147_comment =
  "C++ Interface:\n"
  "set_start_tex_offset(const CLerpNodePathInterval self, const LVecBase2f tex_offset)\n"
  "\n"
  "/**\n"
  " * Indicates the initial UV offset of the lerped node.  This is meaningful\n"
  " * only if set_end_tex_offset() is also called.  This parameter is optional;\n"
  " * if unspecified, the value will be taken from the node's actual UV offset at\n"
  " * the time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_tex_offset_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_tex_offset(LVecBase2 const &tex_offset)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_tex_offset_148(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_tex_offset")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_end_tex_offset(LVecBase2 const &tex_offset)
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_end_tex_offset", "LVecBase2f");
  }
  ((*local_this).set_end_tex_offset)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_tex_offset(const CLerpNodePathInterval self, const LVecBase2f tex_offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_tex_offset_148_comment =
  "C++ Interface:\n"
  "set_end_tex_offset(const CLerpNodePathInterval self, const LVecBase2f tex_offset)\n"
  "\n"
  "/**\n"
  " * Indicates that the UV offset of the node should be lerped, and specifies\n"
  " * the final UV offset of the node.  This should be called before\n"
  " * priv_initialize().  If this is not called, the node's UV offset will not be\n"
  " * affected by the lerp.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_tex_offset_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_tex_rotate(PN_stdfloat tex_rotate)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_tex_rotate_149(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_tex_rotate")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_start_tex_rotate(PN_stdfloat tex_rotate)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_start_tex_rotate)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_tex_rotate(const CLerpNodePathInterval self, float tex_rotate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_tex_rotate_149_comment =
  "C++ Interface:\n"
  "set_start_tex_rotate(const CLerpNodePathInterval self, float tex_rotate)\n"
  "\n"
  "/**\n"
  " * Indicates the initial UV rotate of the lerped node.  This is meaningful\n"
  " * only if set_end_tex_rotate() is also called.  This parameter is optional;\n"
  " * if unspecified, the value will be taken from the node's actual UV rotate at\n"
  " * the time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_tex_rotate_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_tex_rotate(PN_stdfloat tex_rotate)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_tex_rotate_150(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_tex_rotate")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_end_tex_rotate(PN_stdfloat tex_rotate)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_end_tex_rotate)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_tex_rotate(const CLerpNodePathInterval self, float tex_rotate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_tex_rotate_150_comment =
  "C++ Interface:\n"
  "set_end_tex_rotate(const CLerpNodePathInterval self, float tex_rotate)\n"
  "\n"
  "/**\n"
  " * Indicates that the UV rotate of the node should be lerped, and specifies\n"
  " * the final UV rotate of the node.  This should be called before\n"
  " * priv_initialize().  If this is not called, the node's UV rotate will not be\n"
  " * affected by the lerp.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_tex_rotate_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_start_tex_scale(LVecBase2 const &tex_scale)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_start_tex_scale_151(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_start_tex_scale")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_start_tex_scale(LVecBase2 const &tex_scale)
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_start_tex_scale", "LVecBase2f");
  }
  ((*local_this).set_start_tex_scale)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_start_tex_scale(const CLerpNodePathInterval self, const LVecBase2f tex_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_start_tex_scale_151_comment =
  "C++ Interface:\n"
  "set_start_tex_scale(const CLerpNodePathInterval self, const LVecBase2f tex_scale)\n"
  "\n"
  "/**\n"
  " * Indicates the initial UV scale of the lerped node.  This is meaningful only\n"
  " * if set_end_tex_scale() is also called.  This parameter is optional; if\n"
  " * unspecified, the value will be taken from the node's actual UV scale at the\n"
  " * time the lerp is performed.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_start_tex_scale_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_end_tex_scale(LVecBase2 const &tex_scale)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_end_tex_scale_152(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_end_tex_scale")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_end_tex_scale(LVecBase2 const &tex_scale)
  LVecBase2f arg_local;
  LVecBase2 const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CLerpNodePathInterval.set_end_tex_scale", "LVecBase2f");
  }
  ((*local_this).set_end_tex_scale)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_end_tex_scale(const CLerpNodePathInterval self, const LVecBase2f tex_scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_end_tex_scale_152_comment =
  "C++ Interface:\n"
  "set_end_tex_scale(const CLerpNodePathInterval self, const LVecBase2f tex_scale)\n"
  "\n"
  "/**\n"
  " * Indicates that the UV scale of the node should be lerped, and specifies the\n"
  " * final UV scale of the node.  This should be called before\n"
  " * priv_initialize().  If this is not called, the node's UV scale will not be\n"
  " * affected by the lerp.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_end_tex_scale_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CLerpNodePathInterval::set_override(int override)
 */
static PyObject *Dtool_CLerpNodePathInterval_set_override_153(PyObject *self, PyObject *arg) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CLerpNodePathInterval, (void **)&local_this, "CLerpNodePathInterval.set_override")) {
    return nullptr;
  }
  // 1-inline void CLerpNodePathInterval::set_override(int override)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_override)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_override(const CLerpNodePathInterval self, int override)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_set_override_153_comment =
  "C++ Interface:\n"
  "set_override(const CLerpNodePathInterval self, int override)\n"
  "\n"
  "/**\n"
  " * Changes the override value that will be associated with any state changes\n"
  " * applied by the lerp.  If this lerp is changing state (for instance, a color\n"
  " * lerp or a tex matrix lerp), then the new attributes created by this lerp\n"
  " * will be assigned the indicated override value when they are applied to the\n"
  " * node.\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_set_override_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int CLerpNodePathInterval::get_override(void) const
 */
static PyObject *Dtool_CLerpNodePathInterval_get_override_154(PyObject *self, PyObject *) {
  CLerpNodePathInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CLerpNodePathInterval)) {
    return nullptr;
  }
  // 1-inline int CLerpNodePathInterval::get_override(void) const
  int return_value = ((*(const CLerpNodePathInterval*)local_this).get_override)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_get_override_154_comment =
  "C++ Interface:\n"
  "get_override(CLerpNodePathInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the override value that will be associated with any state changes\n"
  " * applied by the lerp.  See set_override().\n"
  " */";
#else
static const char *Dtool_CLerpNodePathInterval_get_override_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CLerpNodePathInterval::get_class_type(void)
 */
static PyObject *Dtool_CLerpNodePathInterval_get_class_type_155(PyObject *, PyObject *) {
  // 1-static TypeHandle CLerpNodePathInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CLerpNodePathInterval::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CLerpNodePathInterval_get_class_type_155_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CLerpNodePathInterval_get_class_type_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CLerpNodePathInterval::CLerpNodePathInterval(CLerpNodePathInterval const &) = default
 * explicit CLerpNodePathInterval::CLerpNodePathInterval(std::string const &name, double duration, CLerpInterval::BlendType blend_type, bool bake_in_start, bool fluid, NodePath const &node, NodePath const &other)
 */
static int Dtool_Init_CLerpNodePathInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CLerpNodePathInterval::CLerpNodePathInterval(CLerpNodePathInterval const &) = default
      CLerpNodePathInterval const *arg_this = (CLerpNodePathInterval *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CLerpNodePathInterval, 0, "CLerpNodePathInterval.CLerpNodePathInterval", true, true);
      if (arg_this != nullptr) {
        CLerpNodePathInterval *return_value = new CLerpNodePathInterval(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CLerpNodePathInterval, true, false);
      }
    }
    break;
  case 7:
    {
      // 1-explicit CLerpNodePathInterval::CLerpNodePathInterval(std::string const &name, double duration, CLerpInterval::BlendType blend_type, bool bake_in_start, bool fluid, NodePath const &node, NodePath const &other)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      double param1;
      int param2;
      PyObject *param3;
      PyObject *param4;
      PyObject *param5;
      PyObject *param6;
      static const char *keyword_list[] = {"name", "duration", "blend_type", "bake_in_start", "fluid", "node", "other", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#diOOOO:CLerpNodePathInterval", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5, &param6)) {
        NodePath const *param5_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param5, Dtool_Ptr_NodePath, 5, "CLerpNodePathInterval.CLerpNodePathInterval", true, true);
        NodePath const *param6_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param6, Dtool_Ptr_NodePath, 6, "CLerpNodePathInterval.CLerpNodePathInterval", true, true);
        if (param5_this != nullptr && param6_this != nullptr) {
          CLerpNodePathInterval *return_value = new CLerpNodePathInterval(std::string(param0_str, param0_len), (double)param1, (CLerpInterval::BlendType)param2, (PyObject_IsTrue(param3) != 0), (PyObject_IsTrue(param4) != 0), *param5_this, *param6_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CLerpNodePathInterval, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CLerpNodePathInterval() takes 1 or 7 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CLerpNodePathInterval(const CLerpNodePathInterval param0)\n"
      "CLerpNodePathInterval(str name, double duration, int blend_type, bool bake_in_start, bool fluid, const NodePath node, const NodePath other)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CLerpNodePathInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CLerpNodePathInterval) {
    printf("CLerpNodePathInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CLerpNodePathInterval *local_this = (CLerpNodePathInterval *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CLerpNodePathInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *)(CLerpInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_CLerpInterval) {
    return (CLerpInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *)(CLerpInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *)(CLerpInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *)(CLerpInterval *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CLerpNodePathInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CLerpNodePathInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CLerpNodePathInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_CLerpInterval) {
    CLerpInterval* other_this = (CLerpInterval*)from_this;
    return (CLerpNodePathInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CLerpNodePathInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CLerpNodePathInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CLerpNodePathInterval*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CMetaInterval
 */
/**
 * Python function wrapper for:
 * inline void CMetaInterval::set_precision(double precision)
 */
static PyObject *Dtool_CMetaInterval_set_precision_160(PyObject *self, PyObject *arg) {
  CMetaInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.set_precision")) {
    return nullptr;
  }
  // 1-inline void CMetaInterval::set_precision(double precision)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_precision)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_precision(const CMetaInterval self, double precision)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_set_precision_160_comment =
  "C++ Interface:\n"
  "set_precision(const CMetaInterval self, double precision)\n"
  "\n"
  "/**\n"
  " * Indicates the precision with which time measurements are compared.  For\n"
  " * numerical accuracy, all floating-point time values are converted to integer\n"
  " * values internally by scaling by the precision factor.  The larger the\n"
  " * number given here, the smaller the delta of time that can be\n"
  " * differentiated; the limit is the maximum integer that can be represented in\n"
  " * the system.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_set_precision_160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double CMetaInterval::get_precision(void) const
 */
static PyObject *Dtool_CMetaInterval_get_precision_161(PyObject *self, PyObject *) {
  CMetaInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CMetaInterval)) {
    return nullptr;
  }
  // 1-inline double CMetaInterval::get_precision(void) const
  double return_value = ((*(const CMetaInterval*)local_this).get_precision)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_precision_161_comment =
  "C++ Interface:\n"
  "get_precision(CMetaInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the precision with which time measurements are compared.  See\n"
  " * set_precision().\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_precision_161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CMetaInterval::clear_intervals(void)
 */
static PyObject *Dtool_CMetaInterval_clear_intervals_162(PyObject *self, PyObject *) {
  CMetaInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.clear_intervals")) {
    return nullptr;
  }
  // 1-void CMetaInterval::clear_intervals(void)
  ((*local_this).clear_intervals)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_clear_intervals_162_comment =
  "C++ Interface:\n"
  "clear_intervals(const CMetaInterval self)\n"
  "\n"
  "/**\n"
  " * Resets the list of intervals and prepares for receiving a new list.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_clear_intervals_162_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CMetaInterval::push_level(std::string const &name, double rel_time, CMetaInterval::RelativeStart rel_to)
 */
static PyObject *Dtool_CMetaInterval_push_level_163(PyObject *self, PyObject *args, PyObject *kwds) {
  CMetaInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.push_level")) {
    return nullptr;
  }
  // 1-int CMetaInterval::push_level(std::string const &name, double rel_time, CMetaInterval::RelativeStart rel_to)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  double param2;
  int param3;
  static const char *keyword_list[] = {"name", "rel_time", "rel_to", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#di:push_level", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
    int return_value = ((*local_this).push_level)(std::string(param1_str, param1_len), (double)param2, (CMetaInterval::RelativeStart)param3);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_level(const CMetaInterval self, str name, double rel_time, int rel_to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_push_level_163_comment =
  "C++ Interface:\n"
  "push_level(const CMetaInterval self, str name, double rel_time, int rel_to)\n"
  "\n"
  "/**\n"
  " * Marks the beginning of a nested level of child intervals.  Within the\n"
  " * nested level, a RelativeStart time of RS_level_begin refers to the start of\n"
  " * the level, and the first interval added within the level is always relative\n"
  " * to the start of the level.\n"
  " *\n"
  " * The return value is the index of the def entry created by this push.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_push_level_163_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CMetaInterval::add_c_interval(CInterval *c_interval, double rel_time = 0.0, CMetaInterval::RelativeStart rel_to = ::CMetaInterval::RS_previous_end)
 */
static PyObject *Dtool_CMetaInterval_add_c_interval_164(PyObject *self, PyObject *args, PyObject *kwds) {
  CMetaInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.add_c_interval")) {
    return nullptr;
  }
  // 1-int CMetaInterval::add_c_interval(CInterval *c_interval, double rel_time = 0.0, CMetaInterval::RelativeStart rel_to = ::CMetaInterval::RS_previous_end)
  PyObject *param1;
  double param2 = 0.0;
  int param3 = CMetaInterval::RS_previous_end;
  static const char *keyword_list[] = {"c_interval", "rel_time", "rel_to", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|di:add_c_interval", (char **)keyword_list, &param1, &param2, &param3)) {
    CInterval *param1_this = (CInterval *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_CInterval, 1, "CMetaInterval.add_c_interval", false, true);
    if (param1_this != nullptr) {
      int return_value = ((*local_this).add_c_interval)(param1_this, (double)param2, (CMetaInterval::RelativeStart)param3);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_c_interval(const CMetaInterval self, CInterval c_interval, double rel_time, int rel_to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_add_c_interval_164_comment =
  "C++ Interface:\n"
  "add_c_interval(const CMetaInterval self, CInterval c_interval, double rel_time, int rel_to)\n"
  "\n"
  "/**\n"
  " * Adds a new CInterval to the list.  The interval will be played when the\n"
  " * indicated time (relative to the given point) has been reached.\n"
  " *\n"
  " * The return value is the index of the def entry representing the new\n"
  " * interval.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_add_c_interval_164_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CMetaInterval::add_ext_index(int ext_index, std::string const &name, double duration, bool open_ended, double rel_time, CMetaInterval::RelativeStart rel_to)
 */
static PyObject *Dtool_CMetaInterval_add_ext_index_165(PyObject *self, PyObject *args, PyObject *kwds) {
  CMetaInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.add_ext_index")) {
    return nullptr;
  }
  // 1-int CMetaInterval::add_ext_index(int ext_index, std::string const &name, double duration, bool open_ended, double rel_time, CMetaInterval::RelativeStart rel_to)
  int param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  double param3;
  PyObject *param4;
  double param5;
  int param6;
  static const char *keyword_list[] = {"ext_index", "name", "duration", "open_ended", "rel_time", "rel_to", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "is#dOdi:add_ext_index", (char **)keyword_list, &param1, &param2_str, &param2_len, &param3, &param4, &param5, &param6)) {
    int return_value = ((*local_this).add_ext_index)((int)param1, std::string(param2_str, param2_len), (double)param3, (PyObject_IsTrue(param4) != 0), (double)param5, (CMetaInterval::RelativeStart)param6);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_ext_index(const CMetaInterval self, int ext_index, str name, double duration, bool open_ended, double rel_time, int rel_to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_add_ext_index_165_comment =
  "C++ Interface:\n"
  "add_ext_index(const CMetaInterval self, int ext_index, str name, double duration, bool open_ended, double rel_time, int rel_to)\n"
  "\n"
  "/**\n"
  " * Adds a new external interval to the list.  This represents some object in\n"
  " * the external scripting language that has properties similar to a CInterval\n"
  " * (for instance, a Python Interval object).\n"
  " *\n"
  " * The CMetaInterval object cannot play this external interval directly, but\n"
  " * it records a placeholder for it and will ask the scripting language to play\n"
  " * it when it is time, via is_event_ready() and related methods.\n"
  " *\n"
  " * The ext_index number itself is simply a handle that the scripting language\n"
  " * makes up and associates with its interval object somehow.  The\n"
  " * CMetaInterval object does not attempt to interpret this value.\n"
  " *\n"
  " * The return value is the index of the def entry representing the new\n"
  " * interval.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_add_ext_index_165_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int CMetaInterval::pop_level(double duration = -1.0)
 */
static PyObject *Dtool_CMetaInterval_pop_level_166(PyObject *self, PyObject *args, PyObject *kwds) {
  CMetaInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.pop_level")) {
    return nullptr;
  }
  // 1-int CMetaInterval::pop_level(double duration = -1.0)
  double param1 = -1.0;
  static const char *keyword_list[] = {"duration", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|d:pop_level", (char **)keyword_list, &param1)) {
    int return_value = ((*local_this).pop_level)((double)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pop_level(const CMetaInterval self, double duration)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_pop_level_166_comment =
  "C++ Interface:\n"
  "pop_level(const CMetaInterval self, double duration)\n"
  "\n"
  "/**\n"
  " * Finishes a level marked by a previous call to push_level(), and returns to\n"
  " * the previous level.\n"
  " *\n"
  " * If the duration is not negative, it represents a phony duration to assign\n"
  " * to the level, for the purposes of sequencing later intervals.  Otherwise,\n"
  " * the level's duration is computed based on the intervals within the level.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_pop_level_166_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CMetaInterval::set_interval_start_time(std::string const &name, double rel_time, CMetaInterval::RelativeStart rel_to = ::CMetaInterval::RS_level_begin)
 */
static PyObject *Dtool_CMetaInterval_set_interval_start_time_167(PyObject *self, PyObject *args, PyObject *kwds) {
  CMetaInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.set_interval_start_time")) {
    return nullptr;
  }
  // 1-bool CMetaInterval::set_interval_start_time(std::string const &name, double rel_time, CMetaInterval::RelativeStart rel_to = ::CMetaInterval::RS_level_begin)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  double param2;
  int param3 = CMetaInterval::RS_level_begin;
  static const char *keyword_list[] = {"name", "rel_time", "rel_to", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#d|i:set_interval_start_time", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
    bool return_value = ((*local_this).set_interval_start_time)(std::string(param1_str, param1_len), (double)param2, (CMetaInterval::RelativeStart)param3);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_interval_start_time(const CMetaInterval self, str name, double rel_time, int rel_to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_set_interval_start_time_167_comment =
  "C++ Interface:\n"
  "set_interval_start_time(const CMetaInterval self, str name, double rel_time, int rel_to)\n"
  "\n"
  "/**\n"
  " * Adjusts the start time of the child interval with the given name, if found.\n"
  " * This may be either a C++ interval added via add_c_interval(), or an\n"
  " * external interval added via add_ext_index(); the name must match exactly.\n"
  " *\n"
  " * If the interval is found, its start time is adjusted, and all subsequent\n"
  " * intervals are adjusting accordingly, and true is returned.  If a matching\n"
  " * interval is not found, nothing is changed and false is returned.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_set_interval_start_time_167_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double CMetaInterval::get_interval_start_time(std::string const &name) const
 */
static PyObject *Dtool_CMetaInterval_get_interval_start_time_168(PyObject *self, PyObject *arg) {
  CMetaInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CMetaInterval)) {
    return nullptr;
  }
  // 1-double CMetaInterval::get_interval_start_time(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    double return_value = ((*(const CMetaInterval*)local_this).get_interval_start_time)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_interval_start_time(CMetaInterval self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_interval_start_time_168_comment =
  "C++ Interface:\n"
  "get_interval_start_time(CMetaInterval self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the actual start time, relative to the beginning of the interval,\n"
  " * of the child interval with the given name, if found, or -1 if the interval\n"
  " * is not found.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_interval_start_time_168_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double CMetaInterval::get_interval_end_time(std::string const &name) const
 */
static PyObject *Dtool_CMetaInterval_get_interval_end_time_169(PyObject *self, PyObject *arg) {
  CMetaInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CMetaInterval)) {
    return nullptr;
  }
  // 1-double CMetaInterval::get_interval_end_time(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    double return_value = ((*(const CMetaInterval*)local_this).get_interval_end_time)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_interval_end_time(CMetaInterval self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_interval_end_time_169_comment =
  "C++ Interface:\n"
  "get_interval_end_time(CMetaInterval self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the actual end time, relative to the beginning of the interval, of\n"
  " * the child interval with the given name, if found, or -1 if the interval is\n"
  " * not found.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_interval_end_time_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int CMetaInterval::get_num_defs(void) const
 */
static PyObject *Dtool_CMetaInterval_get_num_defs_171(PyObject *self, PyObject *) {
  CMetaInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CMetaInterval)) {
    return nullptr;
  }
  // 1-inline int CMetaInterval::get_num_defs(void) const
  int return_value = ((*(const CMetaInterval*)local_this).get_num_defs)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_num_defs_171_comment =
  "C++ Interface:\n"
  "get_num_defs(CMetaInterval self)\n"
  "\n"
  "/**\n"
  " * Returns the number of interval and push/pop definitions that have been\n"
  " * added to the meta interval.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_num_defs_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CMetaInterval::DefType CMetaInterval::get_def_type(int n) const
 */
static PyObject *Dtool_CMetaInterval_get_def_type_172(PyObject *self, PyObject *arg) {
  CMetaInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CMetaInterval)) {
    return nullptr;
  }
  // 1-inline CMetaInterval::DefType CMetaInterval::get_def_type(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    CMetaInterval::DefType return_value = ((*(const CMetaInterval*)local_this).get_def_type)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_def_type(CMetaInterval self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_def_type_172_comment =
  "C++ Interface:\n"
  "get_def_type(CMetaInterval self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the type of the nth interval definition that has been added.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_def_type_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CInterval *CMetaInterval::get_c_interval(int n) const
 */
static PyObject *Dtool_CMetaInterval_get_c_interval_173(PyObject *self, PyObject *arg) {
  CMetaInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CMetaInterval)) {
    return nullptr;
  }
  // 1-inline CInterval *CMetaInterval::get_c_interval(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    CInterval *return_value = ((*(const CMetaInterval*)local_this).get_c_interval)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CInterval, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_c_interval(CMetaInterval self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_c_interval_173_comment =
  "C++ Interface:\n"
  "get_c_interval(CMetaInterval self, int n)\n"
  "\n"
  "/**\n"
  " * Return the CInterval pointer associated with the nth interval definition.\n"
  " * It is only valid to call this if get_def_type(n) returns DT_c_interval.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_c_interval_173_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int CMetaInterval::get_ext_index(int n) const
 */
static PyObject *Dtool_CMetaInterval_get_ext_index_174(PyObject *self, PyObject *arg) {
  CMetaInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CMetaInterval)) {
    return nullptr;
  }
  // 1-inline int CMetaInterval::get_ext_index(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const CMetaInterval*)local_this).get_ext_index)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ext_index(CMetaInterval self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_ext_index_174_comment =
  "C++ Interface:\n"
  "get_ext_index(CMetaInterval self, int n)\n"
  "\n"
  "/**\n"
  " * Return the external interval index number associated with the nth interval\n"
  " * definition.  It is only valid to call this if get_def_type(n) returns\n"
  " * DT_ext_index.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_ext_index_174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CMetaInterval::is_event_ready(void)
 */
static PyObject *Dtool_CMetaInterval_is_event_ready_175(PyObject *self, PyObject *) {
  CMetaInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.is_event_ready")) {
    return nullptr;
  }
  // 1-inline bool CMetaInterval::is_event_ready(void)
  bool return_value = ((*local_this).is_event_ready)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_is_event_ready_175_comment =
  "C++ Interface:\n"
  "is_event_ready(const CMetaInterval self)\n"
  "\n"
  "/**\n"
  " * Returns true if a recent call to priv_initialize(), priv_step(), or\n"
  " * priv_finalize() has left some external intervals ready to play.  If this\n"
  " * returns true, call get_event_index(), get_event_t(), and pop_event() to\n"
  " * retrieve the relevant information.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_is_event_ready_175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int CMetaInterval::get_event_index(void) const
 */
static PyObject *Dtool_CMetaInterval_get_event_index_176(PyObject *self, PyObject *) {
  CMetaInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CMetaInterval)) {
    return nullptr;
  }
  // 1-inline int CMetaInterval::get_event_index(void) const
  int return_value = ((*(const CMetaInterval*)local_this).get_event_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_event_index_176_comment =
  "C++ Interface:\n"
  "get_event_index(CMetaInterval self)\n"
  "\n"
  "/**\n"
  " * If a previous call to is_event_ready() returned true, this returns the\n"
  " * index number (added via add_event_index()) of the external interval that\n"
  " * needs to be played.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_event_index_176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double CMetaInterval::get_event_t(void) const
 */
static PyObject *Dtool_CMetaInterval_get_event_t_177(PyObject *self, PyObject *) {
  CMetaInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CMetaInterval)) {
    return nullptr;
  }
  // 1-inline double CMetaInterval::get_event_t(void) const
  double return_value = ((*(const CMetaInterval*)local_this).get_event_t)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_event_t_177_comment =
  "C++ Interface:\n"
  "get_event_t(CMetaInterval self)\n"
  "\n"
  "/**\n"
  " * If a previous call to is_event_ready() returned true, this returns the t\n"
  " * value that should be fed to the given interval.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_event_t_177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CInterval::EventType CMetaInterval::get_event_type(void) const
 */
static PyObject *Dtool_CMetaInterval_get_event_type_178(PyObject *self, PyObject *) {
  CMetaInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CMetaInterval)) {
    return nullptr;
  }
  // 1-inline CInterval::EventType CMetaInterval::get_event_type(void) const
  CInterval::EventType return_value = ((*(const CMetaInterval*)local_this).get_event_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_event_type_178_comment =
  "C++ Interface:\n"
  "get_event_type(CMetaInterval self)\n"
  "\n"
  "/**\n"
  " * If a previous call to is_event_ready() returned true, this returns the type\n"
  " * of the event (initialize, step, finalize, etc.) for the given interval.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_get_event_type_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CMetaInterval::pop_event(void)
 */
static PyObject *Dtool_CMetaInterval_pop_event_179(PyObject *self, PyObject *) {
  CMetaInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CMetaInterval, (void **)&local_this, "CMetaInterval.pop_event")) {
    return nullptr;
  }
  // 1-void CMetaInterval::pop_event(void)
  ((*local_this).pop_event)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_pop_event_179_comment =
  "C++ Interface:\n"
  "pop_event(const CMetaInterval self)\n"
  "\n"
  "/**\n"
  " * Acknowledges that the external interval on the top of the queue has been\n"
  " * extracted, and is about to be serviced by the scripting language.  This\n"
  " * prepares the interval so the next call to is_event_ready() will return\n"
  " * information about the next external interval on the queue, if any.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_pop_event_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CMetaInterval::timeline(std::ostream &out) const
 */
static PyObject *Dtool_CMetaInterval_timeline_180(PyObject *self, PyObject *arg) {
  CMetaInterval *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CMetaInterval)) {
    return nullptr;
  }
  // 1-void CMetaInterval::timeline(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "CMetaInterval.timeline", false, true);
  if (arg_this != nullptr) {
    ((*(const CMetaInterval*)local_this).timeline)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "timeline(CMetaInterval self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_timeline_180_comment =
  "C++ Interface:\n"
  "timeline(CMetaInterval self, ostream out)\n"
  "\n"
  "/**\n"
  " * Outputs a list of all events in the order in which they occur.\n"
  " */";
#else
static const char *Dtool_CMetaInterval_timeline_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CMetaInterval::get_class_type(void)
 */
static PyObject *Dtool_CMetaInterval_get_class_type_181(PyObject *, PyObject *) {
  // 1-static TypeHandle CMetaInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CMetaInterval::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CMetaInterval_get_class_type_181_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CMetaInterval_get_class_type_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CMetaInterval::CMetaInterval(CMetaInterval const &) = default
 * explicit CMetaInterval::CMetaInterval(std::string const &name)
 */
static int Dtool_Init_CMetaInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "CMetaInterval() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline CMetaInterval::CMetaInterval(CMetaInterval const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CMetaInterval const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_CMetaInterval);
      if (param0_this != nullptr) {
        CMetaInterval *return_value = new CMetaInterval(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CMetaInterval, true, false);
      }
    }
  }

  {
    // -2 explicit CMetaInterval::CMetaInterval(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
    static const char *keyword_list[] = {"name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:CMetaInterval", (char **)keyword_list, &param0_str, &param0_len)) {
      CMetaInterval *return_value = new CMetaInterval(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CMetaInterval, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline CMetaInterval::CMetaInterval(CMetaInterval const &) = default
  // No coercion possible: explicit CMetaInterval::CMetaInterval(std::string const &name)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CMetaInterval(const CMetaInterval param0)\n"
      "CMetaInterval(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CMetaInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CMetaInterval) {
    printf("CMetaInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CMetaInterval *local_this = (CMetaInterval *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CMetaInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CMetaInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CMetaInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (CMetaInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CMetaInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CMetaInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CMetaInterval*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class HideInterval
 */
/**
 * Python function wrapper for:
 * static TypeHandle HideInterval::get_class_type(void)
 */
static PyObject *Dtool_HideInterval_get_class_type_184(PyObject *, PyObject *) {
  // 1-static TypeHandle HideInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((HideInterval::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_HideInterval_get_class_type_184_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_HideInterval_get_class_type_184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline HideInterval::HideInterval(HideInterval const &) = default
 * explicit HideInterval::HideInterval(NodePath const &node, std::string const &name = string())
 */
static int Dtool_Init_HideInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 explicit HideInterval::HideInterval(NodePath const &node, std::string const &name = string())
    PyObject *param0;
    const char *param1_str = "";
    Py_ssize_t param1_len = 0;
    static const char *keyword_list[] = {"node", "name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:HideInterval", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
      NodePath const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_NodePath);
      if (param0_this != nullptr) {
        HideInterval *return_value = new HideInterval(*param0_this, std::string(param1_str, param1_len));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HideInterval, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline HideInterval::HideInterval(HideInterval const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      HideInterval const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_HideInterval);
      if (param0_this != nullptr) {
        HideInterval *return_value = new HideInterval(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_HideInterval, true, false);
      }
    }
  }

  // No coercion possible: explicit HideInterval::HideInterval(NodePath const &node, std::string const &name = string())
  // No coercion possible: inline HideInterval::HideInterval(HideInterval const &) = default
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "HideInterval(const NodePath node, str name)\n"
      "HideInterval(const HideInterval param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_HideInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_HideInterval) {
    printf("HideInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  HideInterval *local_this = (HideInterval *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_HideInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_HideInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_HideInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (HideInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (HideInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (HideInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (HideInterval*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LerpBlendType
 */
/**
 * Python function wrapper for:
 * static TypeHandle LerpBlendType::get_class_type(void)
 */
static PyObject *Dtool_LerpBlendType_get_class_type_188(PyObject *, PyObject *) {
  // 1-static TypeHandle LerpBlendType::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LerpBlendType::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LerpBlendType_get_class_type_188_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "// now for typehandle stuff";
#else
static const char *Dtool_LerpBlendType_get_class_type_188_comment = nullptr;
#endif

static int Dtool_Init_LerpBlendType(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LerpBlendType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LerpBlendType) {
    printf("LerpBlendType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LerpBlendType *local_this = (LerpBlendType *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LerpBlendType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LerpBlendType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LerpBlendType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LerpBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LerpBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LerpBlendType*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EaseInBlendType
 */
/**
 * Python function wrapper for:
 * static TypeHandle EaseInBlendType::get_class_type(void)
 */
static PyObject *Dtool_EaseInBlendType_get_class_type_191(PyObject *, PyObject *) {
  // 1-static TypeHandle EaseInBlendType::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EaseInBlendType::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EaseInBlendType_get_class_type_191_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "// now for typehandle stuff";
#else
static const char *Dtool_EaseInBlendType_get_class_type_191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EaseInBlendType::EaseInBlendType(void)
 */
static int Dtool_Init_EaseInBlendType(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("EaseInBlendType() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EaseInBlendType() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-EaseInBlendType::EaseInBlendType(void)
  EaseInBlendType *return_value = new EaseInBlendType();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EaseInBlendType, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EaseInBlendType()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EaseInBlendType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EaseInBlendType) {
    printf("EaseInBlendType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EaseInBlendType *local_this = (EaseInBlendType *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EaseInBlendType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LerpBlendType) {
    return (LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EaseInBlendType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EaseInBlendType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LerpBlendType) {
    LerpBlendType* other_this = (LerpBlendType*)from_this;
    return (EaseInBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EaseInBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EaseInBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EaseInBlendType*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EaseOutBlendType
 */
/**
 * Python function wrapper for:
 * static TypeHandle EaseOutBlendType::get_class_type(void)
 */
static PyObject *Dtool_EaseOutBlendType_get_class_type_194(PyObject *, PyObject *) {
  // 1-static TypeHandle EaseOutBlendType::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EaseOutBlendType::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EaseOutBlendType_get_class_type_194_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "// now for typehandle stuff";
#else
static const char *Dtool_EaseOutBlendType_get_class_type_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EaseOutBlendType::EaseOutBlendType(void)
 */
static int Dtool_Init_EaseOutBlendType(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("EaseOutBlendType() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EaseOutBlendType() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-EaseOutBlendType::EaseOutBlendType(void)
  EaseOutBlendType *return_value = new EaseOutBlendType();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EaseOutBlendType, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EaseOutBlendType()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EaseOutBlendType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EaseOutBlendType) {
    printf("EaseOutBlendType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EaseOutBlendType *local_this = (EaseOutBlendType *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EaseOutBlendType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LerpBlendType) {
    return (LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EaseOutBlendType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EaseOutBlendType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LerpBlendType) {
    LerpBlendType* other_this = (LerpBlendType*)from_this;
    return (EaseOutBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EaseOutBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EaseOutBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EaseOutBlendType*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class EaseInOutBlendType
 */
/**
 * Python function wrapper for:
 * static TypeHandle EaseInOutBlendType::get_class_type(void)
 */
static PyObject *Dtool_EaseInOutBlendType_get_class_type_197(PyObject *, PyObject *) {
  // 1-static TypeHandle EaseInOutBlendType::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((EaseInOutBlendType::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_EaseInOutBlendType_get_class_type_197_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "// now for typehandle stuff";
#else
static const char *Dtool_EaseInOutBlendType_get_class_type_197_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * EaseInOutBlendType::EaseInOutBlendType(void)
 */
static int Dtool_Init_EaseInOutBlendType(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("EaseInOutBlendType() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "EaseInOutBlendType() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-EaseInOutBlendType::EaseInOutBlendType(void)
  EaseInOutBlendType *return_value = new EaseInOutBlendType();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_EaseInOutBlendType, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "EaseInOutBlendType()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_EaseInOutBlendType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_EaseInOutBlendType) {
    printf("EaseInOutBlendType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  EaseInOutBlendType *local_this = (EaseInOutBlendType *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_EaseInOutBlendType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LerpBlendType) {
    return (LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_EaseInOutBlendType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_EaseInOutBlendType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LerpBlendType) {
    LerpBlendType* other_this = (LerpBlendType*)from_this;
    return (EaseInOutBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (EaseInOutBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (EaseInOutBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (EaseInOutBlendType*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NoBlendType
 */
/**
 * Python function wrapper for:
 * static TypeHandle NoBlendType::get_class_type(void)
 */
static PyObject *Dtool_NoBlendType_get_class_type_200(PyObject *, PyObject *) {
  // 1-static TypeHandle NoBlendType::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((NoBlendType::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NoBlendType_get_class_type_200_comment =
  "C++ Interface:\n"
  "get_class_type()\n"
  "\n"
  "// now for typehandle stuff";
#else
static const char *Dtool_NoBlendType_get_class_type_200_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NoBlendType::NoBlendType(void)
 */
static int Dtool_Init_NoBlendType(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("NoBlendType() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "NoBlendType() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-NoBlendType::NoBlendType(void)
  NoBlendType *return_value = new NoBlendType();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NoBlendType, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NoBlendType()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_NoBlendType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NoBlendType) {
    printf("NoBlendType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NoBlendType *local_this = (NoBlendType *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NoBlendType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LerpBlendType) {
    return (LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(LerpBlendType *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NoBlendType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NoBlendType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LerpBlendType) {
    LerpBlendType* other_this = (LerpBlendType*)from_this;
    return (NoBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NoBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (NoBlendType*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (NoBlendType*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ShowInterval
 */
/**
 * Python function wrapper for:
 * static TypeHandle ShowInterval::get_class_type(void)
 */
static PyObject *Dtool_ShowInterval_get_class_type_203(PyObject *, PyObject *) {
  // 1-static TypeHandle ShowInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ShowInterval::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ShowInterval_get_class_type_203_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ShowInterval_get_class_type_203_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit ShowInterval::ShowInterval(NodePath const &node, std::string const &name = string())
 * inline ShowInterval::ShowInterval(ShowInterval const &) = default
 */
static int Dtool_Init_ShowInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  {
    // -2 explicit ShowInterval::ShowInterval(NodePath const &node, std::string const &name = string())
    PyObject *param0;
    const char *param1_str = "";
    Py_ssize_t param1_len = 0;
    static const char *keyword_list[] = {"node", "name", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|s#:ShowInterval", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
      NodePath const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_NodePath);
      if (param0_this != nullptr) {
        ShowInterval *return_value = new ShowInterval(*param0_this, std::string(param1_str, param1_len));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShowInterval, true, false);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 inline ShowInterval::ShowInterval(ShowInterval const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      ShowInterval const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_ShowInterval);
      if (param0_this != nullptr) {
        ShowInterval *return_value = new ShowInterval(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ShowInterval, true, false);
      }
    }
  }

  // No coercion possible: explicit ShowInterval::ShowInterval(NodePath const &node, std::string const &name = string())
  // No coercion possible: inline ShowInterval::ShowInterval(ShowInterval const &) = default
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ShowInterval(const NodePath node, str name)\n"
      "ShowInterval(const ShowInterval param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ShowInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ShowInterval) {
    printf("ShowInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ShowInterval *local_this = (ShowInterval *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ShowInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ShowInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ShowInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (ShowInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ShowInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ShowInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ShowInterval*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class WaitInterval
 */
/**
 * Python function wrapper for:
 * static TypeHandle WaitInterval::get_class_type(void)
 */
static PyObject *Dtool_WaitInterval_get_class_type_207(PyObject *, PyObject *) {
  // 1-static TypeHandle WaitInterval::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((WaitInterval::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_WaitInterval_get_class_type_207_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_WaitInterval_get_class_type_207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline WaitInterval::WaitInterval(WaitInterval const &) = default
 * inline explicit WaitInterval::WaitInterval(double duration)
 */
static int Dtool_Init_WaitInterval(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "WaitInterval() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline WaitInterval::WaitInterval(WaitInterval const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      WaitInterval const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_WaitInterval);
      if (param0_this != nullptr) {
        WaitInterval *return_value = new WaitInterval(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WaitInterval, true, false);
      }
    }
  }

  {
    // -2 inline explicit WaitInterval::WaitInterval(double duration)
    double param0;
    static const char *keyword_list[] = {"duration", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "d:WaitInterval", (char **)keyword_list, &param0)) {
      WaitInterval *return_value = new WaitInterval((double)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_WaitInterval, true, false);
    }
    PyErr_Clear();
  }

  // No coercion possible: inline WaitInterval::WaitInterval(WaitInterval const &) = default
  // No coercion possible: inline explicit WaitInterval::WaitInterval(double duration)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "WaitInterval(const WaitInterval param0)\n"
      "WaitInterval(double duration)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_WaitInterval(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_WaitInterval) {
    printf("WaitInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  WaitInterval *local_this = (WaitInterval *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_WaitInterval) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CInterval) {
    return (CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CInterval *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CInterval *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_WaitInterval(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_WaitInterval) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CInterval) {
    CInterval* other_this = (CInterval*)from_this;
    return (WaitInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (WaitInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (WaitInterval*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (WaitInterval*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for CInterval (CInterval)
 */
static PyMethodDef Dtool_Methods_CInterval[] = {
  {"get_name", &Dtool_CInterval_get_name_3, METH_NOARGS, (const char *)Dtool_CInterval_get_name_3_comment},
  {"getName", &Dtool_CInterval_get_name_3, METH_NOARGS, (const char *)Dtool_CInterval_get_name_3_comment},
  {"get_duration", &Dtool_CInterval_get_duration_4, METH_NOARGS, (const char *)Dtool_CInterval_get_duration_4_comment},
  {"getDuration", &Dtool_CInterval_get_duration_4, METH_NOARGS, (const char *)Dtool_CInterval_get_duration_4_comment},
  {"get_open_ended", &Dtool_CInterval_get_open_ended_5, METH_NOARGS, (const char *)Dtool_CInterval_get_open_ended_5_comment},
  {"getOpenEnded", &Dtool_CInterval_get_open_ended_5, METH_NOARGS, (const char *)Dtool_CInterval_get_open_ended_5_comment},
  {"get_state", &Dtool_CInterval_get_state_8, METH_NOARGS, (const char *)Dtool_CInterval_get_state_8_comment},
  {"getState", &Dtool_CInterval_get_state_8, METH_NOARGS, (const char *)Dtool_CInterval_get_state_8_comment},
  {"is_stopped", &Dtool_CInterval_is_stopped_9, METH_NOARGS, (const char *)Dtool_CInterval_is_stopped_9_comment},
  {"isStopped", &Dtool_CInterval_is_stopped_9, METH_NOARGS, (const char *)Dtool_CInterval_is_stopped_9_comment},
  {"set_done_event", &Dtool_CInterval_set_done_event_10, METH_O, (const char *)Dtool_CInterval_set_done_event_10_comment},
  {"setDoneEvent", &Dtool_CInterval_set_done_event_10, METH_O, (const char *)Dtool_CInterval_set_done_event_10_comment},
  {"get_done_event", &Dtool_CInterval_get_done_event_11, METH_NOARGS, (const char *)Dtool_CInterval_get_done_event_11_comment},
  {"getDoneEvent", &Dtool_CInterval_get_done_event_11, METH_NOARGS, (const char *)Dtool_CInterval_get_done_event_11_comment},
  {"set_t", &Dtool_CInterval_set_t_12, METH_O, (const char *)Dtool_CInterval_set_t_12_comment},
  {"setT", &Dtool_CInterval_set_t_12, METH_O, (const char *)Dtool_CInterval_set_t_12_comment},
  {"get_t", &Dtool_CInterval_get_t_13, METH_NOARGS, (const char *)Dtool_CInterval_get_t_13_comment},
  {"getT", &Dtool_CInterval_get_t_13, METH_NOARGS, (const char *)Dtool_CInterval_get_t_13_comment},
  {"set_auto_pause", &Dtool_CInterval_set_auto_pause_14, METH_O, (const char *)Dtool_CInterval_set_auto_pause_14_comment},
  {"setAutoPause", &Dtool_CInterval_set_auto_pause_14, METH_O, (const char *)Dtool_CInterval_set_auto_pause_14_comment},
  {"get_auto_pause", &Dtool_CInterval_get_auto_pause_15, METH_NOARGS, (const char *)Dtool_CInterval_get_auto_pause_15_comment},
  {"getAutoPause", &Dtool_CInterval_get_auto_pause_15, METH_NOARGS, (const char *)Dtool_CInterval_get_auto_pause_15_comment},
  {"set_auto_finish", &Dtool_CInterval_set_auto_finish_16, METH_O, (const char *)Dtool_CInterval_set_auto_finish_16_comment},
  {"setAutoFinish", &Dtool_CInterval_set_auto_finish_16, METH_O, (const char *)Dtool_CInterval_set_auto_finish_16_comment},
  {"get_auto_finish", &Dtool_CInterval_get_auto_finish_17, METH_NOARGS, (const char *)Dtool_CInterval_get_auto_finish_17_comment},
  {"getAutoFinish", &Dtool_CInterval_get_auto_finish_17, METH_NOARGS, (const char *)Dtool_CInterval_get_auto_finish_17_comment},
  {"set_wants_t_callback", &Dtool_CInterval_set_wants_t_callback_18, METH_O, (const char *)Dtool_CInterval_set_wants_t_callback_18_comment},
  {"setWantsTCallback", &Dtool_CInterval_set_wants_t_callback_18, METH_O, (const char *)Dtool_CInterval_set_wants_t_callback_18_comment},
  {"get_wants_t_callback", &Dtool_CInterval_get_wants_t_callback_19, METH_NOARGS, (const char *)Dtool_CInterval_get_wants_t_callback_19_comment},
  {"getWantsTCallback", &Dtool_CInterval_get_wants_t_callback_19, METH_NOARGS, (const char *)Dtool_CInterval_get_wants_t_callback_19_comment},
  {"set_manager", &Dtool_CInterval_set_manager_20, METH_O, (const char *)Dtool_CInterval_set_manager_20_comment},
  {"setManager", &Dtool_CInterval_set_manager_20, METH_O, (const char *)Dtool_CInterval_set_manager_20_comment},
  {"get_manager", &Dtool_CInterval_get_manager_21, METH_NOARGS, (const char *)Dtool_CInterval_get_manager_21_comment},
  {"getManager", &Dtool_CInterval_get_manager_21, METH_NOARGS, (const char *)Dtool_CInterval_get_manager_21_comment},
  {"start", (PyCFunction) &Dtool_CInterval_start_22, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterval_start_22_comment},
  {"loop", (PyCFunction) &Dtool_CInterval_loop_23, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterval_loop_23_comment},
  {"pause", &Dtool_CInterval_pause_24, METH_NOARGS, (const char *)Dtool_CInterval_pause_24_comment},
  {"resume", &Dtool_CInterval_resume_25, METH_VARARGS, (const char *)Dtool_CInterval_resume_25_comment},
  {"resume_until", &Dtool_CInterval_resume_until_26, METH_O, (const char *)Dtool_CInterval_resume_until_26_comment},
  {"resumeUntil", &Dtool_CInterval_resume_until_26, METH_O, (const char *)Dtool_CInterval_resume_until_26_comment},
  {"finish", &Dtool_CInterval_finish_27, METH_NOARGS, (const char *)Dtool_CInterval_finish_27_comment},
  {"clear_to_initial", &Dtool_CInterval_clear_to_initial_28, METH_NOARGS, (const char *)Dtool_CInterval_clear_to_initial_28_comment},
  {"clearToInitial", &Dtool_CInterval_clear_to_initial_28, METH_NOARGS, (const char *)Dtool_CInterval_clear_to_initial_28_comment},
  {"is_playing", &Dtool_CInterval_is_playing_29, METH_NOARGS, (const char *)Dtool_CInterval_is_playing_29_comment},
  {"isPlaying", &Dtool_CInterval_is_playing_29, METH_NOARGS, (const char *)Dtool_CInterval_is_playing_29_comment},
  {"get_play_rate", &Dtool_CInterval_get_play_rate_30, METH_NOARGS, (const char *)Dtool_CInterval_get_play_rate_30_comment},
  {"getPlayRate", &Dtool_CInterval_get_play_rate_30, METH_NOARGS, (const char *)Dtool_CInterval_get_play_rate_30_comment},
  {"set_play_rate", &Dtool_CInterval_set_play_rate_31, METH_O, (const char *)Dtool_CInterval_set_play_rate_31_comment},
  {"setPlayRate", &Dtool_CInterval_set_play_rate_31, METH_O, (const char *)Dtool_CInterval_set_play_rate_31_comment},
  {"priv_do_event", (PyCFunction) &Dtool_CInterval_priv_do_event_32, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterval_priv_do_event_32_comment},
  {"privDoEvent", (PyCFunction) &Dtool_CInterval_priv_do_event_32, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterval_priv_do_event_32_comment},
  {"priv_initialize", &Dtool_CInterval_priv_initialize_33, METH_O, (const char *)Dtool_CInterval_priv_initialize_33_comment},
  {"privInitialize", &Dtool_CInterval_priv_initialize_33, METH_O, (const char *)Dtool_CInterval_priv_initialize_33_comment},
  {"priv_instant", &Dtool_CInterval_priv_instant_34, METH_NOARGS, (const char *)Dtool_CInterval_priv_instant_34_comment},
  {"privInstant", &Dtool_CInterval_priv_instant_34, METH_NOARGS, (const char *)Dtool_CInterval_priv_instant_34_comment},
  {"priv_step", &Dtool_CInterval_priv_step_35, METH_O, (const char *)Dtool_CInterval_priv_step_35_comment},
  {"privStep", &Dtool_CInterval_priv_step_35, METH_O, (const char *)Dtool_CInterval_priv_step_35_comment},
  {"priv_finalize", &Dtool_CInterval_priv_finalize_36, METH_NOARGS, (const char *)Dtool_CInterval_priv_finalize_36_comment},
  {"privFinalize", &Dtool_CInterval_priv_finalize_36, METH_NOARGS, (const char *)Dtool_CInterval_priv_finalize_36_comment},
  {"priv_reverse_initialize", &Dtool_CInterval_priv_reverse_initialize_37, METH_O, (const char *)Dtool_CInterval_priv_reverse_initialize_37_comment},
  {"privReverseInitialize", &Dtool_CInterval_priv_reverse_initialize_37, METH_O, (const char *)Dtool_CInterval_priv_reverse_initialize_37_comment},
  {"priv_reverse_instant", &Dtool_CInterval_priv_reverse_instant_38, METH_NOARGS, (const char *)Dtool_CInterval_priv_reverse_instant_38_comment},
  {"privReverseInstant", &Dtool_CInterval_priv_reverse_instant_38, METH_NOARGS, (const char *)Dtool_CInterval_priv_reverse_instant_38_comment},
  {"priv_reverse_finalize", &Dtool_CInterval_priv_reverse_finalize_39, METH_NOARGS, (const char *)Dtool_CInterval_priv_reverse_finalize_39_comment},
  {"privReverseFinalize", &Dtool_CInterval_priv_reverse_finalize_39, METH_NOARGS, (const char *)Dtool_CInterval_priv_reverse_finalize_39_comment},
  {"priv_interrupt", &Dtool_CInterval_priv_interrupt_40, METH_NOARGS, (const char *)Dtool_CInterval_priv_interrupt_40_comment},
  {"privInterrupt", &Dtool_CInterval_priv_interrupt_40, METH_NOARGS, (const char *)Dtool_CInterval_priv_interrupt_40_comment},
  {"output", &Dtool_CInterval_output_41, METH_O, (const char *)Dtool_CInterval_output_41_comment},
  {"write", (PyCFunction) &Dtool_CInterval_write_42, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterval_write_42_comment},
  {"setup_play", (PyCFunction) &Dtool_CInterval_setup_play_43, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterval_setup_play_43_comment},
  {"setupPlay", (PyCFunction) &Dtool_CInterval_setup_play_43, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CInterval_setup_play_43_comment},
  {"setup_resume", &Dtool_CInterval_setup_resume_44, METH_NOARGS, (const char *)Dtool_CInterval_setup_resume_44_comment},
  {"setupResume", &Dtool_CInterval_setup_resume_44, METH_NOARGS, (const char *)Dtool_CInterval_setup_resume_44_comment},
  {"setup_resume_until", &Dtool_CInterval_setup_resume_until_45, METH_O, (const char *)Dtool_CInterval_setup_resume_until_45_comment},
  {"setupResumeUntil", &Dtool_CInterval_setup_resume_until_45, METH_O, (const char *)Dtool_CInterval_setup_resume_until_45_comment},
  {"step_play", &Dtool_CInterval_step_play_46, METH_NOARGS, (const char *)Dtool_CInterval_step_play_46_comment},
  {"stepPlay", &Dtool_CInterval_step_play_46, METH_NOARGS, (const char *)Dtool_CInterval_step_play_46_comment},
  {"get_class_type", &Dtool_CInterval_get_class_type_83, METH_NOARGS | METH_STATIC, (const char *)Dtool_CInterval_get_class_type_83_comment},
  {"getClassType", &Dtool_CInterval_get_class_type_83, METH_NOARGS | METH_STATIC, (const char *)Dtool_CInterval_get_class_type_83_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     CInterval
//////////////////
static PyObject *Dtool_Repr_CInterval(PyObject *self) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     CInterval
//////////////////
static PyObject *Dtool_Str_CInterval(PyObject *self) {
  CInterval *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CInterval, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_CInterval[] = {
  {(char *)"name", &Dtool_CInterval_name_Getter, nullptr, nullptr, nullptr},
  {(char *)"duration", &Dtool_CInterval_duration_Getter, nullptr, nullptr, nullptr},
  {(char *)"open_ended", &Dtool_CInterval_open_ended_Getter, nullptr, nullptr, nullptr},
  {(char *)"state", &Dtool_CInterval_state_Getter, nullptr, nullptr, nullptr},
  {(char *)"stopped", &Dtool_CInterval_stopped_Getter, nullptr, nullptr, nullptr},
  {(char *)"done_event", &Dtool_CInterval_done_event_Getter, &Dtool_CInterval_done_event_Setter, nullptr, nullptr},
  {(char *)"t", &Dtool_CInterval_t_Getter, &Dtool_CInterval_t_Setter, nullptr, nullptr},
  {(char *)"auto_pause", &Dtool_CInterval_auto_pause_Getter, &Dtool_CInterval_auto_pause_Setter, nullptr, nullptr},
  {(char *)"auto_finish", &Dtool_CInterval_auto_finish_Getter, &Dtool_CInterval_auto_finish_Setter, nullptr, nullptr},
  {(char *)"manager", &Dtool_CInterval_manager_Getter, &Dtool_CInterval_manager_Setter, nullptr, nullptr},
  {(char *)"play_rate", &Dtool_CInterval_play_rate_Getter, &Dtool_CInterval_play_rate_Setter, nullptr, nullptr},
  {(char *)"playing", &Dtool_CInterval_playing_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CInterval = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CInterval = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CInterval = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CInterval = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CInterval = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CInterval = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.CInterval",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CInterval,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CInterval,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_CInterval,
    &Dtool_NumberMethods_CInterval,
    &Dtool_SequenceMethods_CInterval,
    &Dtool_MappingMethods_CInterval,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_CInterval,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The base class for timeline components.  A CInterval represents a single\n"
    " * action, event, or collection of nested intervals that will be performed at\n"
    " * some specific time or over a period of time.\n"
    " *\n"
    " * This is essentially similar to the Python \"Interval\" class, but it is\n"
    " * implemented in C++ (hence the name). Intervals that may be implemented in\n"
    " * C++ will inherit from this class; Intervals that must be implemented in\n"
    " * Python will inherit from the similar Python class.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CInterval,
    nullptr, // tp_members
    Dtool_Properties_CInterval,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CInterval,
    PyType_GenericAlloc,
    Dtool_new_CInterval,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CInterval,
  Dtool_UpcastInterface_CInterval,
  Dtool_DowncastInterface_CInterval,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_CInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_CInterval._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(25);
    Dtool_CInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum CInterval::EventType;
    PyDict_SetItemString(dict, "ET_initialize", Dtool_WrapValue(CInterval::ET_initialize));
    PyDict_SetItemString(dict, "ETInitialize", Dtool_WrapValue(CInterval::ET_initialize));
    PyDict_SetItemString(dict, "ET_instant", Dtool_WrapValue(CInterval::ET_instant));
    PyDict_SetItemString(dict, "ETInstant", Dtool_WrapValue(CInterval::ET_instant));
    PyDict_SetItemString(dict, "ET_step", Dtool_WrapValue(CInterval::ET_step));
    PyDict_SetItemString(dict, "ETStep", Dtool_WrapValue(CInterval::ET_step));
    PyDict_SetItemString(dict, "ET_finalize", Dtool_WrapValue(CInterval::ET_finalize));
    PyDict_SetItemString(dict, "ETFinalize", Dtool_WrapValue(CInterval::ET_finalize));
    PyDict_SetItemString(dict, "ET_reverse_initialize", Dtool_WrapValue(CInterval::ET_reverse_initialize));
    PyDict_SetItemString(dict, "ETReverseInitialize", Dtool_WrapValue(CInterval::ET_reverse_initialize));
    PyDict_SetItemString(dict, "ET_reverse_instant", Dtool_WrapValue(CInterval::ET_reverse_instant));
    PyDict_SetItemString(dict, "ETReverseInstant", Dtool_WrapValue(CInterval::ET_reverse_instant));
    PyDict_SetItemString(dict, "ET_reverse_finalize", Dtool_WrapValue(CInterval::ET_reverse_finalize));
    PyDict_SetItemString(dict, "ETReverseFinalize", Dtool_WrapValue(CInterval::ET_reverse_finalize));
    PyDict_SetItemString(dict, "ET_interrupt", Dtool_WrapValue(CInterval::ET_interrupt));
    PyDict_SetItemString(dict, "ETInterrupt", Dtool_WrapValue(CInterval::ET_interrupt));
    // enum CInterval::State;
    PyDict_SetItemString(dict, "S_initial", Dtool_WrapValue(CInterval::S_initial));
    PyDict_SetItemString(dict, "SInitial", Dtool_WrapValue(CInterval::S_initial));
    PyDict_SetItemString(dict, "S_started", Dtool_WrapValue(CInterval::S_started));
    PyDict_SetItemString(dict, "SStarted", Dtool_WrapValue(CInterval::S_started));
    PyDict_SetItemString(dict, "S_paused", Dtool_WrapValue(CInterval::S_paused));
    PyDict_SetItemString(dict, "SPaused", Dtool_WrapValue(CInterval::S_paused));
    PyDict_SetItemString(dict, "S_final", Dtool_WrapValue(CInterval::S_final));
    PyDict_SetItemString(dict, "SFinal", Dtool_WrapValue(CInterval::S_final));
    if (PyType_Ready((PyTypeObject *)&Dtool_CInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CInterval);
  }
}

/**
 * Python method tables for CIntervalManager (CIntervalManager)
 */
static PyMethodDef Dtool_Methods_CIntervalManager[] = {
  {"set_event_queue", &Dtool_CIntervalManager_set_event_queue_66, METH_O, (const char *)Dtool_CIntervalManager_set_event_queue_66_comment},
  {"setEventQueue", &Dtool_CIntervalManager_set_event_queue_66, METH_O, (const char *)Dtool_CIntervalManager_set_event_queue_66_comment},
  {"get_event_queue", &Dtool_CIntervalManager_get_event_queue_67, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_event_queue_67_comment},
  {"getEventQueue", &Dtool_CIntervalManager_get_event_queue_67, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_event_queue_67_comment},
  {"add_c_interval", (PyCFunction) &Dtool_CIntervalManager_add_c_interval_68, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CIntervalManager_add_c_interval_68_comment},
  {"addCInterval", (PyCFunction) &Dtool_CIntervalManager_add_c_interval_68, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CIntervalManager_add_c_interval_68_comment},
  {"find_c_interval", &Dtool_CIntervalManager_find_c_interval_69, METH_O, (const char *)Dtool_CIntervalManager_find_c_interval_69_comment},
  {"findCInterval", &Dtool_CIntervalManager_find_c_interval_69, METH_O, (const char *)Dtool_CIntervalManager_find_c_interval_69_comment},
  {"get_c_interval", &Dtool_CIntervalManager_get_c_interval_70, METH_O, (const char *)Dtool_CIntervalManager_get_c_interval_70_comment},
  {"getCInterval", &Dtool_CIntervalManager_get_c_interval_70, METH_O, (const char *)Dtool_CIntervalManager_get_c_interval_70_comment},
  {"remove_c_interval", &Dtool_CIntervalManager_remove_c_interval_71, METH_O, (const char *)Dtool_CIntervalManager_remove_c_interval_71_comment},
  {"removeCInterval", &Dtool_CIntervalManager_remove_c_interval_71, METH_O, (const char *)Dtool_CIntervalManager_remove_c_interval_71_comment},
  {"interrupt", &Dtool_CIntervalManager_interrupt_72, METH_NOARGS, (const char *)Dtool_CIntervalManager_interrupt_72_comment},
  {"get_num_intervals", &Dtool_CIntervalManager_get_num_intervals_73, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_num_intervals_73_comment},
  {"getNumIntervals", &Dtool_CIntervalManager_get_num_intervals_73, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_num_intervals_73_comment},
  {"get_max_index", &Dtool_CIntervalManager_get_max_index_74, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_max_index_74_comment},
  {"getMaxIndex", &Dtool_CIntervalManager_get_max_index_74, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_max_index_74_comment},
  {"step", &Dtool_CIntervalManager_step_75, METH_NOARGS, (const char *)Dtool_CIntervalManager_step_75_comment},
  {"get_next_event", &Dtool_CIntervalManager_get_next_event_76, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_next_event_76_comment},
  {"getNextEvent", &Dtool_CIntervalManager_get_next_event_76, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_next_event_76_comment},
  {"get_next_removal", &Dtool_CIntervalManager_get_next_removal_77, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_next_removal_77_comment},
  {"getNextRemoval", &Dtool_CIntervalManager_get_next_removal_77, METH_NOARGS, (const char *)Dtool_CIntervalManager_get_next_removal_77_comment},
  {"output", &Dtool_CIntervalManager_output_78, METH_O, (const char *)Dtool_CIntervalManager_output_78_comment},
  {"write", &Dtool_CIntervalManager_write_79, METH_O, (const char *)Dtool_CIntervalManager_write_79_comment},
  {"get_global_ptr", &Dtool_CIntervalManager_get_global_ptr_80, METH_NOARGS | METH_STATIC, (const char *)Dtool_CIntervalManager_get_global_ptr_80_comment},
  {"getGlobalPtr", &Dtool_CIntervalManager_get_global_ptr_80, METH_NOARGS | METH_STATIC, (const char *)Dtool_CIntervalManager_get_global_ptr_80_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     CIntervalManager
//////////////////
static PyObject *Dtool_Repr_CIntervalManager(PyObject *self) {
  CIntervalManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CIntervalManager, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     CIntervalManager
//////////////////
static PyObject *Dtool_Str_CIntervalManager(PyObject *self) {
  CIntervalManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CIntervalManager, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_CIntervalManager = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_CIntervalManager = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.CIntervalManager",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CIntervalManager,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_CIntervalManager,
    &Dtool_NumberMethods_CIntervalManager,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_CIntervalManager,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This object holds a number of currently-playing intervals and is\n"
    " * responsible for advancing them each frame as needed.\n"
    " *\n"
    " * There is normally only one IntervalManager object in the world, and it is\n"
    " * the responsibility of the scripting language to call step() on this object\n"
    " * once each frame, and to then process the events indicated by\n"
    " * get_next_event().\n"
    " *\n"
    " * It is also possible to create multiple IntervalManager objects for special\n"
    " * needs.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CIntervalManager,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CIntervalManager,
    PyType_GenericAlloc,
    Dtool_new_CIntervalManager,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CIntervalManager,
  Dtool_UpcastInterface_CIntervalManager,
  Dtool_DowncastInterface_CIntervalManager,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CIntervalManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_CIntervalManager._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CIntervalManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CIntervalManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CIntervalManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CIntervalManager);
  }
}

/**
 * Python method tables for CConstraintInterval (CConstraintInterval)
 */
static PyMethodDef Dtool_Methods_CConstraintInterval[] = {
  {"get_class_type", &Dtool_CConstraintInterval_get_class_type_89, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstraintInterval_get_class_type_89_comment},
  {"getClassType", &Dtool_CConstraintInterval_get_class_type_89, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstraintInterval_get_class_type_89_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CConstraintInterval[] = {
  {(char *)"bogus_variable", &Dtool_CConstraintInterval_bogus_variable_Getter, &Dtool_CConstraintInterval_bogus_variable_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CConstraintInterval = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CConstraintInterval = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CConstraintInterval = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CConstraintInterval = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CConstraintInterval = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CConstraintInterval = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.CConstraintInterval",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CConstraintInterval,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CConstraintInterval,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CConstraintInterval,
    &Dtool_SequenceMethods_CConstraintInterval,
    &Dtool_MappingMethods_CConstraintInterval,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CConstraintInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The base class for a family of intervals that constrain some property to a\n"
    " * value over time.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CConstraintInterval,
    nullptr, // tp_members
    Dtool_Properties_CConstraintInterval,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CConstraintInterval,
    PyType_GenericAlloc,
    Dtool_new_CConstraintInterval,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CConstraintInterval,
  Dtool_UpcastInterface_CConstraintInterval,
  Dtool_DowncastInterface_CConstraintInterval,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CConstraintInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CInterval(nullptr);
    Dtool_CConstraintInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CInterval);
    Dtool_CConstraintInterval._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CConstraintInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CConstraintInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CConstraintInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CConstraintInterval);
  }
}

/**
 * Python method tables for CConstrainHprInterval (CConstrainHprInterval)
 */
static PyMethodDef Dtool_Methods_CConstrainHprInterval[] = {
  {"get_node", &Dtool_CConstrainHprInterval_get_node_94, METH_NOARGS, (const char *)Dtool_CConstrainHprInterval_get_node_94_comment},
  {"getNode", &Dtool_CConstrainHprInterval_get_node_94, METH_NOARGS, (const char *)Dtool_CConstrainHprInterval_get_node_94_comment},
  {"get_target", &Dtool_CConstrainHprInterval_get_target_95, METH_NOARGS, (const char *)Dtool_CConstrainHprInterval_get_target_95_comment},
  {"getTarget", &Dtool_CConstrainHprInterval_get_target_95, METH_NOARGS, (const char *)Dtool_CConstrainHprInterval_get_target_95_comment},
  {"get_class_type", &Dtool_CConstrainHprInterval_get_class_type_96, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstrainHprInterval_get_class_type_96_comment},
  {"getClassType", &Dtool_CConstrainHprInterval_get_class_type_96, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstrainHprInterval_get_class_type_96_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CConstrainHprInterval = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CConstrainHprInterval = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CConstrainHprInterval = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CConstrainHprInterval = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CConstrainHprInterval = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CConstrainHprInterval = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.CConstrainHprInterval",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CConstrainHprInterval,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CConstrainHprInterval,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CConstrainHprInterval,
    &Dtool_SequenceMethods_CConstrainHprInterval,
    &Dtool_MappingMethods_CConstrainHprInterval,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CConstrainHprInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A constraint interval that will constrain the orientation of one node to\n"
    " * the orientation of another.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CConstrainHprInterval,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CConstrainHprInterval,
    PyType_GenericAlloc,
    Dtool_new_CConstrainHprInterval,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CConstrainHprInterval,
  Dtool_UpcastInterface_CConstrainHprInterval,
  Dtool_DowncastInterface_CConstrainHprInterval,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CConstrainHprInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CConstraintInterval(nullptr);
    Dtool_CConstrainHprInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CConstraintInterval);
    Dtool_CConstrainHprInterval._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CConstrainHprInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CConstrainHprInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CConstrainHprInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CConstrainHprInterval);
  }
}

/**
 * Python method tables for CConstrainPosHprInterval (CConstrainPosHprInterval)
 */
static PyMethodDef Dtool_Methods_CConstrainPosHprInterval[] = {
  {"get_node", &Dtool_CConstrainPosHprInterval_get_node_100, METH_NOARGS, (const char *)Dtool_CConstrainPosHprInterval_get_node_100_comment},
  {"getNode", &Dtool_CConstrainPosHprInterval_get_node_100, METH_NOARGS, (const char *)Dtool_CConstrainPosHprInterval_get_node_100_comment},
  {"get_target", &Dtool_CConstrainPosHprInterval_get_target_101, METH_NOARGS, (const char *)Dtool_CConstrainPosHprInterval_get_target_101_comment},
  {"getTarget", &Dtool_CConstrainPosHprInterval_get_target_101, METH_NOARGS, (const char *)Dtool_CConstrainPosHprInterval_get_target_101_comment},
  {"get_class_type", &Dtool_CConstrainPosHprInterval_get_class_type_102, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstrainPosHprInterval_get_class_type_102_comment},
  {"getClassType", &Dtool_CConstrainPosHprInterval_get_class_type_102, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstrainPosHprInterval_get_class_type_102_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CConstrainPosHprInterval = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CConstrainPosHprInterval = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CConstrainPosHprInterval = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CConstrainPosHprInterval = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CConstrainPosHprInterval = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CConstrainPosHprInterval = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.CConstrainPosHprInterval",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CConstrainPosHprInterval,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CConstrainPosHprInterval,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CConstrainPosHprInterval,
    &Dtool_SequenceMethods_CConstrainPosHprInterval,
    &Dtool_MappingMethods_CConstrainPosHprInterval,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CConstrainPosHprInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A constraint interval that will constrain the position and orientation of\n"
    " * one node to the position and orientation of another.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CConstrainPosHprInterval,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CConstrainPosHprInterval,
    PyType_GenericAlloc,
    Dtool_new_CConstrainPosHprInterval,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CConstrainPosHprInterval,
  Dtool_UpcastInterface_CConstrainPosHprInterval,
  Dtool_DowncastInterface_CConstrainPosHprInterval,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CConstrainPosHprInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CConstraintInterval(nullptr);
    Dtool_CConstrainPosHprInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CConstraintInterval);
    Dtool_CConstrainPosHprInterval._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CConstrainPosHprInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CConstrainPosHprInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CConstrainPosHprInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CConstrainPosHprInterval);
  }
}

/**
 * Python method tables for CConstrainPosInterval (CConstrainPosInterval)
 */
static PyMethodDef Dtool_Methods_CConstrainPosInterval[] = {
  {"get_node", &Dtool_CConstrainPosInterval_get_node_106, METH_NOARGS, (const char *)Dtool_CConstrainPosInterval_get_node_106_comment},
  {"getNode", &Dtool_CConstrainPosInterval_get_node_106, METH_NOARGS, (const char *)Dtool_CConstrainPosInterval_get_node_106_comment},
  {"get_target", &Dtool_CConstrainPosInterval_get_target_107, METH_NOARGS, (const char *)Dtool_CConstrainPosInterval_get_target_107_comment},
  {"getTarget", &Dtool_CConstrainPosInterval_get_target_107, METH_NOARGS, (const char *)Dtool_CConstrainPosInterval_get_target_107_comment},
  {"get_class_type", &Dtool_CConstrainPosInterval_get_class_type_108, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstrainPosInterval_get_class_type_108_comment},
  {"getClassType", &Dtool_CConstrainPosInterval_get_class_type_108, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstrainPosInterval_get_class_type_108_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CConstrainPosInterval = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CConstrainPosInterval = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CConstrainPosInterval = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CConstrainPosInterval = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CConstrainPosInterval = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CConstrainPosInterval = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.CConstrainPosInterval",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CConstrainPosInterval,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CConstrainPosInterval,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CConstrainPosInterval,
    &Dtool_SequenceMethods_CConstrainPosInterval,
    &Dtool_MappingMethods_CConstrainPosInterval,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CConstrainPosInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A constraint interval that will constrain the position of one node to the\n"
    " * position of another.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CConstrainPosInterval,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CConstrainPosInterval,
    PyType_GenericAlloc,
    Dtool_new_CConstrainPosInterval,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CConstrainPosInterval,
  Dtool_UpcastInterface_CConstrainPosInterval,
  Dtool_DowncastInterface_CConstrainPosInterval,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CConstrainPosInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CConstraintInterval(nullptr);
    Dtool_CConstrainPosInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CConstraintInterval);
    Dtool_CConstrainPosInterval._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CConstrainPosInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CConstrainPosInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CConstrainPosInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CConstrainPosInterval);
  }
}

/**
 * Python method tables for CConstrainTransformInterval (CConstrainTransformInterval)
 */
static PyMethodDef Dtool_Methods_CConstrainTransformInterval[] = {
  {"get_node", &Dtool_CConstrainTransformInterval_get_node_112, METH_NOARGS, (const char *)Dtool_CConstrainTransformInterval_get_node_112_comment},
  {"getNode", &Dtool_CConstrainTransformInterval_get_node_112, METH_NOARGS, (const char *)Dtool_CConstrainTransformInterval_get_node_112_comment},
  {"get_target", &Dtool_CConstrainTransformInterval_get_target_113, METH_NOARGS, (const char *)Dtool_CConstrainTransformInterval_get_target_113_comment},
  {"getTarget", &Dtool_CConstrainTransformInterval_get_target_113, METH_NOARGS, (const char *)Dtool_CConstrainTransformInterval_get_target_113_comment},
  {"get_class_type", &Dtool_CConstrainTransformInterval_get_class_type_114, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstrainTransformInterval_get_class_type_114_comment},
  {"getClassType", &Dtool_CConstrainTransformInterval_get_class_type_114, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConstrainTransformInterval_get_class_type_114_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CConstrainTransformInterval = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CConstrainTransformInterval = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CConstrainTransformInterval = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CConstrainTransformInterval = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CConstrainTransformInterval = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CConstrainTransformInterval = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.CConstrainTransformInterval",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CConstrainTransformInterval,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CConstrainTransformInterval,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CConstrainTransformInterval,
    &Dtool_SequenceMethods_CConstrainTransformInterval,
    &Dtool_MappingMethods_CConstrainTransformInterval,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CConstrainTransformInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A constraint interval that will constrain the transform of one node to the\n"
    " * transform of another.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CConstrainTransformInterval,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CConstrainTransformInterval,
    PyType_GenericAlloc,
    Dtool_new_CConstrainTransformInterval,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CConstrainTransformInterval,
  Dtool_UpcastInterface_CConstrainTransformInterval,
  Dtool_DowncastInterface_CConstrainTransformInterval,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CConstrainTransformInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CConstraintInterval(nullptr);
    Dtool_CConstrainTransformInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CConstraintInterval);
    Dtool_CConstrainTransformInterval._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CConstrainTransformInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CConstrainTransformInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CConstrainTransformInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CConstrainTransformInterval);
  }
}

/**
 * Python method tables for CLerpInterval (CLerpInterval)
 */
static PyMethodDef Dtool_Methods_CLerpInterval[] = {
  {"get_blend_type", &Dtool_CLerpInterval_get_blend_type_118, METH_NOARGS, (const char *)Dtool_CLerpInterval_get_blend_type_118_comment},
  {"getBlendType", &Dtool_CLerpInterval_get_blend_type_118, METH_NOARGS, (const char *)Dtool_CLerpInterval_get_blend_type_118_comment},
  {"string_blend_type", &Dtool_CLerpInterval_string_blend_type_119, METH_O | METH_STATIC, (const char *)Dtool_CLerpInterval_string_blend_type_119_comment},
  {"stringBlendType", &Dtool_CLerpInterval_string_blend_type_119, METH_O | METH_STATIC, (const char *)Dtool_CLerpInterval_string_blend_type_119_comment},
  {"get_class_type", &Dtool_CLerpInterval_get_class_type_120, METH_NOARGS | METH_STATIC, (const char *)Dtool_CLerpInterval_get_class_type_120_comment},
  {"getClassType", &Dtool_CLerpInterval_get_class_type_120, METH_NOARGS | METH_STATIC, (const char *)Dtool_CLerpInterval_get_class_type_120_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CLerpInterval = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CLerpInterval = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CLerpInterval = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CLerpInterval = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CLerpInterval = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CLerpInterval = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.CLerpInterval",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CLerpInterval,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CLerpInterval,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CLerpInterval,
    &Dtool_SequenceMethods_CLerpInterval,
    &Dtool_MappingMethods_CLerpInterval,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CLerpInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The base class for a family of intervals that linearly interpolate one or\n"
    " * more numeric values over time.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CLerpInterval,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CLerpInterval,
    PyType_GenericAlloc,
    Dtool_new_CLerpInterval,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CLerpInterval,
  Dtool_UpcastInterface_CLerpInterval,
  Dtool_DowncastInterface_CLerpInterval,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CLerpInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CInterval(nullptr);
    Dtool_CLerpInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CInterval);
    Dtool_CLerpInterval._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(11);
    Dtool_CLerpInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum CLerpInterval::BlendType;
    PyDict_SetItemString(dict, "BT_no_blend", Dtool_WrapValue(CLerpInterval::BT_no_blend));
    PyDict_SetItemString(dict, "BTNoBlend", Dtool_WrapValue(CLerpInterval::BT_no_blend));
    PyDict_SetItemString(dict, "BT_ease_in", Dtool_WrapValue(CLerpInterval::BT_ease_in));
    PyDict_SetItemString(dict, "BTEaseIn", Dtool_WrapValue(CLerpInterval::BT_ease_in));
    PyDict_SetItemString(dict, "BT_ease_out", Dtool_WrapValue(CLerpInterval::BT_ease_out));
    PyDict_SetItemString(dict, "BTEaseOut", Dtool_WrapValue(CLerpInterval::BT_ease_out));
    PyDict_SetItemString(dict, "BT_ease_in_out", Dtool_WrapValue(CLerpInterval::BT_ease_in_out));
    PyDict_SetItemString(dict, "BTEaseInOut", Dtool_WrapValue(CLerpInterval::BT_ease_in_out));
    PyDict_SetItemString(dict, "BT_invalid", Dtool_WrapValue(CLerpInterval::BT_invalid));
    PyDict_SetItemString(dict, "BTInvalid", Dtool_WrapValue(CLerpInterval::BT_invalid));
    if (PyType_Ready((PyTypeObject *)&Dtool_CLerpInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CLerpInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CLerpInterval);
  }
}

/**
 * Python method tables for CLerpAnimEffectInterval (CLerpAnimEffectInterval)
 */
static PyMethodDef Dtool_Methods_CLerpAnimEffectInterval[] = {
  {"add_control", (PyCFunction) &Dtool_CLerpAnimEffectInterval_add_control_125, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CLerpAnimEffectInterval_add_control_125_comment},
  {"addControl", (PyCFunction) &Dtool_CLerpAnimEffectInterval_add_control_125, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CLerpAnimEffectInterval_add_control_125_comment},
  {"get_class_type", &Dtool_CLerpAnimEffectInterval_get_class_type_126, METH_NOARGS | METH_STATIC, (const char *)Dtool_CLerpAnimEffectInterval_get_class_type_126_comment},
  {"getClassType", &Dtool_CLerpAnimEffectInterval_get_class_type_126, METH_NOARGS | METH_STATIC, (const char *)Dtool_CLerpAnimEffectInterval_get_class_type_126_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CLerpAnimEffectInterval = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CLerpAnimEffectInterval = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CLerpAnimEffectInterval = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CLerpAnimEffectInterval = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CLerpAnimEffectInterval = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CLerpAnimEffectInterval = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.CLerpAnimEffectInterval",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CLerpAnimEffectInterval,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CLerpAnimEffectInterval,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CLerpAnimEffectInterval,
    &Dtool_SequenceMethods_CLerpAnimEffectInterval,
    &Dtool_MappingMethods_CLerpAnimEffectInterval,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CLerpAnimEffectInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This interval lerps between different amounts of control effects for\n"
    " * various AnimControls that might be playing on an actor.  It's used to\n"
    " * change the blending amount between multiple animations.\n"
    " *\n"
    " * The idea is to start all the animations playing first, then use a\n"
    " * CLerpAnimEffectInterval to adjust the degree to which each animation\n"
    " * affects the actor.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CLerpAnimEffectInterval,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CLerpAnimEffectInterval,
    PyType_GenericAlloc,
    Dtool_new_CLerpAnimEffectInterval,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CLerpAnimEffectInterval,
  Dtool_UpcastInterface_CLerpAnimEffectInterval,
  Dtool_DowncastInterface_CLerpAnimEffectInterval,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CLerpAnimEffectInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CLerpInterval(nullptr);
    Dtool_CLerpAnimEffectInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CLerpInterval);
    Dtool_CLerpAnimEffectInterval._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CLerpAnimEffectInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CLerpAnimEffectInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CLerpAnimEffectInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CLerpAnimEffectInterval);
  }
}

/**
 * Python method tables for CLerpNodePathInterval (CLerpNodePathInterval)
 */
static PyMethodDef Dtool_Methods_CLerpNodePathInterval[] = {
  {"get_node", &Dtool_CLerpNodePathInterval_get_node_130, METH_NOARGS, (const char *)Dtool_CLerpNodePathInterval_get_node_130_comment},
  {"getNode", &Dtool_CLerpNodePathInterval_get_node_130, METH_NOARGS, (const char *)Dtool_CLerpNodePathInterval_get_node_130_comment},
  {"get_other", &Dtool_CLerpNodePathInterval_get_other_131, METH_NOARGS, (const char *)Dtool_CLerpNodePathInterval_get_other_131_comment},
  {"getOther", &Dtool_CLerpNodePathInterval_get_other_131, METH_NOARGS, (const char *)Dtool_CLerpNodePathInterval_get_other_131_comment},
  {"set_start_pos", &Dtool_CLerpNodePathInterval_set_start_pos_132, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_pos_132_comment},
  {"setStartPos", &Dtool_CLerpNodePathInterval_set_start_pos_132, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_pos_132_comment},
  {"set_end_pos", &Dtool_CLerpNodePathInterval_set_end_pos_133, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_pos_133_comment},
  {"setEndPos", &Dtool_CLerpNodePathInterval_set_end_pos_133, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_pos_133_comment},
  {"set_start_hpr", &Dtool_CLerpNodePathInterval_set_start_hpr_134, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_hpr_134_comment},
  {"setStartHpr", &Dtool_CLerpNodePathInterval_set_start_hpr_134, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_hpr_134_comment},
  {"set_end_hpr", &Dtool_CLerpNodePathInterval_set_end_hpr_135, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_hpr_135_comment},
  {"setEndHpr", &Dtool_CLerpNodePathInterval_set_end_hpr_135, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_hpr_135_comment},
  {"set_start_quat", &Dtool_CLerpNodePathInterval_set_start_quat_136, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_quat_136_comment},
  {"setStartQuat", &Dtool_CLerpNodePathInterval_set_start_quat_136, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_quat_136_comment},
  {"set_end_quat", &Dtool_CLerpNodePathInterval_set_end_quat_137, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_quat_137_comment},
  {"setEndQuat", &Dtool_CLerpNodePathInterval_set_end_quat_137, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_quat_137_comment},
  {"set_start_scale", &Dtool_CLerpNodePathInterval_set_start_scale_138, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_scale_138_comment},
  {"setStartScale", &Dtool_CLerpNodePathInterval_set_start_scale_138, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_scale_138_comment},
  {"set_end_scale", &Dtool_CLerpNodePathInterval_set_end_scale_139, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_scale_139_comment},
  {"setEndScale", &Dtool_CLerpNodePathInterval_set_end_scale_139, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_scale_139_comment},
  {"set_start_shear", &Dtool_CLerpNodePathInterval_set_start_shear_140, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_shear_140_comment},
  {"setStartShear", &Dtool_CLerpNodePathInterval_set_start_shear_140, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_shear_140_comment},
  {"set_end_shear", &Dtool_CLerpNodePathInterval_set_end_shear_141, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_shear_141_comment},
  {"setEndShear", &Dtool_CLerpNodePathInterval_set_end_shear_141, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_shear_141_comment},
  {"set_start_color", &Dtool_CLerpNodePathInterval_set_start_color_142, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_color_142_comment},
  {"setStartColor", &Dtool_CLerpNodePathInterval_set_start_color_142, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_color_142_comment},
  {"set_end_color", &Dtool_CLerpNodePathInterval_set_end_color_143, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_color_143_comment},
  {"setEndColor", &Dtool_CLerpNodePathInterval_set_end_color_143, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_color_143_comment},
  {"set_start_color_scale", &Dtool_CLerpNodePathInterval_set_start_color_scale_144, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_color_scale_144_comment},
  {"setStartColorScale", &Dtool_CLerpNodePathInterval_set_start_color_scale_144, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_color_scale_144_comment},
  {"set_end_color_scale", &Dtool_CLerpNodePathInterval_set_end_color_scale_145, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_color_scale_145_comment},
  {"setEndColorScale", &Dtool_CLerpNodePathInterval_set_end_color_scale_145, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_color_scale_145_comment},
  {"set_texture_stage", &Dtool_CLerpNodePathInterval_set_texture_stage_146, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_texture_stage_146_comment},
  {"setTextureStage", &Dtool_CLerpNodePathInterval_set_texture_stage_146, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_texture_stage_146_comment},
  {"set_start_tex_offset", &Dtool_CLerpNodePathInterval_set_start_tex_offset_147, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_tex_offset_147_comment},
  {"setStartTexOffset", &Dtool_CLerpNodePathInterval_set_start_tex_offset_147, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_tex_offset_147_comment},
  {"set_end_tex_offset", &Dtool_CLerpNodePathInterval_set_end_tex_offset_148, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_tex_offset_148_comment},
  {"setEndTexOffset", &Dtool_CLerpNodePathInterval_set_end_tex_offset_148, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_tex_offset_148_comment},
  {"set_start_tex_rotate", &Dtool_CLerpNodePathInterval_set_start_tex_rotate_149, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_tex_rotate_149_comment},
  {"setStartTexRotate", &Dtool_CLerpNodePathInterval_set_start_tex_rotate_149, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_tex_rotate_149_comment},
  {"set_end_tex_rotate", &Dtool_CLerpNodePathInterval_set_end_tex_rotate_150, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_tex_rotate_150_comment},
  {"setEndTexRotate", &Dtool_CLerpNodePathInterval_set_end_tex_rotate_150, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_tex_rotate_150_comment},
  {"set_start_tex_scale", &Dtool_CLerpNodePathInterval_set_start_tex_scale_151, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_tex_scale_151_comment},
  {"setStartTexScale", &Dtool_CLerpNodePathInterval_set_start_tex_scale_151, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_start_tex_scale_151_comment},
  {"set_end_tex_scale", &Dtool_CLerpNodePathInterval_set_end_tex_scale_152, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_tex_scale_152_comment},
  {"setEndTexScale", &Dtool_CLerpNodePathInterval_set_end_tex_scale_152, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_end_tex_scale_152_comment},
  {"set_override", &Dtool_CLerpNodePathInterval_set_override_153, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_override_153_comment},
  {"setOverride", &Dtool_CLerpNodePathInterval_set_override_153, METH_O, (const char *)Dtool_CLerpNodePathInterval_set_override_153_comment},
  {"get_override", &Dtool_CLerpNodePathInterval_get_override_154, METH_NOARGS, (const char *)Dtool_CLerpNodePathInterval_get_override_154_comment},
  {"getOverride", &Dtool_CLerpNodePathInterval_get_override_154, METH_NOARGS, (const char *)Dtool_CLerpNodePathInterval_get_override_154_comment},
  {"get_class_type", &Dtool_CLerpNodePathInterval_get_class_type_155, METH_NOARGS | METH_STATIC, (const char *)Dtool_CLerpNodePathInterval_get_class_type_155_comment},
  {"getClassType", &Dtool_CLerpNodePathInterval_get_class_type_155, METH_NOARGS | METH_STATIC, (const char *)Dtool_CLerpNodePathInterval_get_class_type_155_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CLerpNodePathInterval = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CLerpNodePathInterval = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CLerpNodePathInterval = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CLerpNodePathInterval = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CLerpNodePathInterval = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CLerpNodePathInterval = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.CLerpNodePathInterval",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CLerpNodePathInterval,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CLerpNodePathInterval,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CLerpNodePathInterval,
    &Dtool_SequenceMethods_CLerpNodePathInterval,
    &Dtool_MappingMethods_CLerpNodePathInterval,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CLerpNodePathInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An interval that lerps one or more properties (like pos, hpr, etc.) on a\n"
    " * NodePath over time.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CLerpNodePathInterval,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CLerpNodePathInterval,
    PyType_GenericAlloc,
    Dtool_new_CLerpNodePathInterval,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CLerpNodePathInterval,
  Dtool_UpcastInterface_CLerpNodePathInterval,
  Dtool_DowncastInterface_CLerpNodePathInterval,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CLerpNodePathInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CLerpInterval(nullptr);
    Dtool_CLerpNodePathInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CLerpInterval);
    Dtool_CLerpNodePathInterval._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CLerpNodePathInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CLerpNodePathInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CLerpNodePathInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CLerpNodePathInterval);
  }
}

/**
 * Python method tables for CMetaInterval (CMetaInterval)
 */
static PyMethodDef Dtool_Methods_CMetaInterval[] = {
  {"set_precision", &Dtool_CMetaInterval_set_precision_160, METH_O, (const char *)Dtool_CMetaInterval_set_precision_160_comment},
  {"setPrecision", &Dtool_CMetaInterval_set_precision_160, METH_O, (const char *)Dtool_CMetaInterval_set_precision_160_comment},
  {"get_precision", &Dtool_CMetaInterval_get_precision_161, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_precision_161_comment},
  {"getPrecision", &Dtool_CMetaInterval_get_precision_161, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_precision_161_comment},
  {"clear_intervals", &Dtool_CMetaInterval_clear_intervals_162, METH_NOARGS, (const char *)Dtool_CMetaInterval_clear_intervals_162_comment},
  {"clearIntervals", &Dtool_CMetaInterval_clear_intervals_162, METH_NOARGS, (const char *)Dtool_CMetaInterval_clear_intervals_162_comment},
  {"push_level", (PyCFunction) &Dtool_CMetaInterval_push_level_163, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_push_level_163_comment},
  {"pushLevel", (PyCFunction) &Dtool_CMetaInterval_push_level_163, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_push_level_163_comment},
  {"add_c_interval", (PyCFunction) &Dtool_CMetaInterval_add_c_interval_164, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_add_c_interval_164_comment},
  {"addCInterval", (PyCFunction) &Dtool_CMetaInterval_add_c_interval_164, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_add_c_interval_164_comment},
  {"add_ext_index", (PyCFunction) &Dtool_CMetaInterval_add_ext_index_165, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_add_ext_index_165_comment},
  {"addExtIndex", (PyCFunction) &Dtool_CMetaInterval_add_ext_index_165, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_add_ext_index_165_comment},
  {"pop_level", (PyCFunction) &Dtool_CMetaInterval_pop_level_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_pop_level_166_comment},
  {"popLevel", (PyCFunction) &Dtool_CMetaInterval_pop_level_166, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_pop_level_166_comment},
  {"set_interval_start_time", (PyCFunction) &Dtool_CMetaInterval_set_interval_start_time_167, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_set_interval_start_time_167_comment},
  {"setIntervalStartTime", (PyCFunction) &Dtool_CMetaInterval_set_interval_start_time_167, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CMetaInterval_set_interval_start_time_167_comment},
  {"get_interval_start_time", &Dtool_CMetaInterval_get_interval_start_time_168, METH_O, (const char *)Dtool_CMetaInterval_get_interval_start_time_168_comment},
  {"getIntervalStartTime", &Dtool_CMetaInterval_get_interval_start_time_168, METH_O, (const char *)Dtool_CMetaInterval_get_interval_start_time_168_comment},
  {"get_interval_end_time", &Dtool_CMetaInterval_get_interval_end_time_169, METH_O, (const char *)Dtool_CMetaInterval_get_interval_end_time_169_comment},
  {"getIntervalEndTime", &Dtool_CMetaInterval_get_interval_end_time_169, METH_O, (const char *)Dtool_CMetaInterval_get_interval_end_time_169_comment},
  {"get_num_defs", &Dtool_CMetaInterval_get_num_defs_171, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_num_defs_171_comment},
  {"getNumDefs", &Dtool_CMetaInterval_get_num_defs_171, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_num_defs_171_comment},
  {"get_def_type", &Dtool_CMetaInterval_get_def_type_172, METH_O, (const char *)Dtool_CMetaInterval_get_def_type_172_comment},
  {"getDefType", &Dtool_CMetaInterval_get_def_type_172, METH_O, (const char *)Dtool_CMetaInterval_get_def_type_172_comment},
  {"get_c_interval", &Dtool_CMetaInterval_get_c_interval_173, METH_O, (const char *)Dtool_CMetaInterval_get_c_interval_173_comment},
  {"getCInterval", &Dtool_CMetaInterval_get_c_interval_173, METH_O, (const char *)Dtool_CMetaInterval_get_c_interval_173_comment},
  {"get_ext_index", &Dtool_CMetaInterval_get_ext_index_174, METH_O, (const char *)Dtool_CMetaInterval_get_ext_index_174_comment},
  {"getExtIndex", &Dtool_CMetaInterval_get_ext_index_174, METH_O, (const char *)Dtool_CMetaInterval_get_ext_index_174_comment},
  {"is_event_ready", &Dtool_CMetaInterval_is_event_ready_175, METH_NOARGS, (const char *)Dtool_CMetaInterval_is_event_ready_175_comment},
  {"isEventReady", &Dtool_CMetaInterval_is_event_ready_175, METH_NOARGS, (const char *)Dtool_CMetaInterval_is_event_ready_175_comment},
  {"get_event_index", &Dtool_CMetaInterval_get_event_index_176, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_event_index_176_comment},
  {"getEventIndex", &Dtool_CMetaInterval_get_event_index_176, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_event_index_176_comment},
  {"get_event_t", &Dtool_CMetaInterval_get_event_t_177, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_event_t_177_comment},
  {"getEventT", &Dtool_CMetaInterval_get_event_t_177, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_event_t_177_comment},
  {"get_event_type", &Dtool_CMetaInterval_get_event_type_178, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_event_type_178_comment},
  {"getEventType", &Dtool_CMetaInterval_get_event_type_178, METH_NOARGS, (const char *)Dtool_CMetaInterval_get_event_type_178_comment},
  {"pop_event", &Dtool_CMetaInterval_pop_event_179, METH_NOARGS, (const char *)Dtool_CMetaInterval_pop_event_179_comment},
  {"popEvent", &Dtool_CMetaInterval_pop_event_179, METH_NOARGS, (const char *)Dtool_CMetaInterval_pop_event_179_comment},
  {"timeline", &Dtool_CMetaInterval_timeline_180, METH_O, (const char *)Dtool_CMetaInterval_timeline_180_comment},
  {"get_class_type", &Dtool_CMetaInterval_get_class_type_181, METH_NOARGS | METH_STATIC, (const char *)Dtool_CMetaInterval_get_class_type_181_comment},
  {"getClassType", &Dtool_CMetaInterval_get_class_type_181, METH_NOARGS | METH_STATIC, (const char *)Dtool_CMetaInterval_get_class_type_181_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CMetaInterval = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CMetaInterval = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CMetaInterval = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CMetaInterval = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CMetaInterval = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CMetaInterval = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.CMetaInterval",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CMetaInterval,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CMetaInterval,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CMetaInterval,
    &Dtool_SequenceMethods_CMetaInterval,
    &Dtool_MappingMethods_CMetaInterval,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CMetaInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This interval contains a list of nested intervals, each of which has its\n"
    " * own begin and end times.  Some of them may overlap and some of them may\n"
    " * not.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CMetaInterval,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CMetaInterval,
    PyType_GenericAlloc,
    Dtool_new_CMetaInterval,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CMetaInterval,
  Dtool_UpcastInterface_CMetaInterval,
  Dtool_DowncastInterface_CMetaInterval,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CMetaInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CInterval(nullptr);
    Dtool_CMetaInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CInterval);
    Dtool_CMetaInterval._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(15);
    Dtool_CMetaInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum CMetaInterval::RelativeStart;
    PyDict_SetItemString(dict, "RS_previous_end", Dtool_WrapValue(CMetaInterval::RS_previous_end));
    PyDict_SetItemString(dict, "RSPreviousEnd", Dtool_WrapValue(CMetaInterval::RS_previous_end));
    PyDict_SetItemString(dict, "RS_previous_begin", Dtool_WrapValue(CMetaInterval::RS_previous_begin));
    PyDict_SetItemString(dict, "RSPreviousBegin", Dtool_WrapValue(CMetaInterval::RS_previous_begin));
    PyDict_SetItemString(dict, "RS_level_begin", Dtool_WrapValue(CMetaInterval::RS_level_begin));
    PyDict_SetItemString(dict, "RSLevelBegin", Dtool_WrapValue(CMetaInterval::RS_level_begin));
    // enum CMetaInterval::DefType;
    PyDict_SetItemString(dict, "DT_c_interval", Dtool_WrapValue(CMetaInterval::DT_c_interval));
    PyDict_SetItemString(dict, "DTCInterval", Dtool_WrapValue(CMetaInterval::DT_c_interval));
    PyDict_SetItemString(dict, "DT_ext_index", Dtool_WrapValue(CMetaInterval::DT_ext_index));
    PyDict_SetItemString(dict, "DTExtIndex", Dtool_WrapValue(CMetaInterval::DT_ext_index));
    PyDict_SetItemString(dict, "DT_push_level", Dtool_WrapValue(CMetaInterval::DT_push_level));
    PyDict_SetItemString(dict, "DTPushLevel", Dtool_WrapValue(CMetaInterval::DT_push_level));
    PyDict_SetItemString(dict, "DT_pop_level", Dtool_WrapValue(CMetaInterval::DT_pop_level));
    PyDict_SetItemString(dict, "DTPopLevel", Dtool_WrapValue(CMetaInterval::DT_pop_level));
    if (PyType_Ready((PyTypeObject *)&Dtool_CMetaInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CMetaInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CMetaInterval);
  }
}

/**
 * Python method tables for HideInterval (HideInterval)
 */
static PyMethodDef Dtool_Methods_HideInterval[] = {
  {"get_class_type", &Dtool_HideInterval_get_class_type_184, METH_NOARGS | METH_STATIC, (const char *)Dtool_HideInterval_get_class_type_184_comment},
  {"getClassType", &Dtool_HideInterval_get_class_type_184, METH_NOARGS | METH_STATIC, (const char *)Dtool_HideInterval_get_class_type_184_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_HideInterval = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_HideInterval = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_HideInterval = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_HideInterval = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_HideInterval = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_HideInterval = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.HideInterval",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_HideInterval,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_HideInterval,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_HideInterval,
    &Dtool_SequenceMethods_HideInterval,
    &Dtool_MappingMethods_HideInterval,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_HideInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An interval that calls NodePath::hide().\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_HideInterval,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_HideInterval,
    PyType_GenericAlloc,
    Dtool_new_HideInterval,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_HideInterval,
  Dtool_UpcastInterface_HideInterval,
  Dtool_DowncastInterface_HideInterval,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_HideInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CInterval(nullptr);
    Dtool_HideInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CInterval);
    Dtool_HideInterval._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_HideInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_HideInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(HideInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_HideInterval);
  }
}

/**
 * Python method tables for LerpBlendType (LerpBlendType)
 */
static PyMethodDef Dtool_Methods_LerpBlendType[] = {
  {"get_class_type", &Dtool_LerpBlendType_get_class_type_188, METH_NOARGS | METH_STATIC, (const char *)Dtool_LerpBlendType_get_class_type_188_comment},
  {"getClassType", &Dtool_LerpBlendType_get_class_type_188, METH_NOARGS | METH_STATIC, (const char *)Dtool_LerpBlendType_get_class_type_188_comment},
  {nullptr, nullptr, 0, nullptr}
};

/**
 * Python function wrapper for:
 * virtual PN_stdfloat LerpBlendType::operator ()(PN_stdfloat ) = 0
 */
static PyObject *Dtool_LerpBlendType_operator_187(PyObject *self, PyObject *args, PyObject *kwds)
 {
  LerpBlendType *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LerpBlendType, (void **)&local_this, "LerpBlendType.__call__")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("function takes exactly 1 argument");
#else
    return PyErr_Format(PyExc_TypeError,
                        "__call__() takes exactly 1 argument (%d given)",
                        parameter_count);
#endif
  }
  // 1-virtual PN_stdfloat LerpBlendType::operator ()(PN_stdfloat ) = 0
  float param1;
  if ((kwds == nullptr || PyDict_Size(kwds) == 0) && PyArg_ParseTuple(args, "f:__call__", &param1)) {
    PN_stdfloat return_value = ((*local_this).operator ())((PN_stdfloat)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__call__(const LerpBlendType self, float param0)\n");
  }
  return nullptr;
}

static PyNumberMethods Dtool_NumberMethods_LerpBlendType = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LerpBlendType = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LerpBlendType = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LerpBlendType = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LerpBlendType = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LerpBlendType = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.LerpBlendType",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LerpBlendType,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LerpBlendType,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LerpBlendType,
    &Dtool_SequenceMethods_LerpBlendType,
    &Dtool_MappingMethods_LerpBlendType,
    nullptr, // tp_hash
    &Dtool_LerpBlendType_operator_187,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LerpBlendType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LerpBlendType,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LerpBlendType,
    PyType_GenericAlloc,
    Dtool_new_LerpBlendType,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LerpBlendType,
  Dtool_UpcastInterface_LerpBlendType,
  Dtool_DowncastInterface_LerpBlendType,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LerpBlendType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_LerpBlendType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_LerpBlendType._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LerpBlendType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LerpBlendType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LerpBlendType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LerpBlendType);
  }
}

/**
 * Python method tables for EaseInBlendType (EaseInBlendType)
 */
static PyMethodDef Dtool_Methods_EaseInBlendType[] = {
  {"get_class_type", &Dtool_EaseInBlendType_get_class_type_191, METH_NOARGS | METH_STATIC, (const char *)Dtool_EaseInBlendType_get_class_type_191_comment},
  {"getClassType", &Dtool_EaseInBlendType_get_class_type_191, METH_NOARGS | METH_STATIC, (const char *)Dtool_EaseInBlendType_get_class_type_191_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EaseInBlendType = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EaseInBlendType = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EaseInBlendType = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EaseInBlendType = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EaseInBlendType = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EaseInBlendType = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.EaseInBlendType",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EaseInBlendType,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EaseInBlendType,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EaseInBlendType,
    &Dtool_SequenceMethods_EaseInBlendType,
    &Dtool_MappingMethods_EaseInBlendType,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EaseInBlendType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EaseInBlendType,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EaseInBlendType,
    PyType_GenericAlloc,
    Dtool_new_EaseInBlendType,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EaseInBlendType,
  Dtool_UpcastInterface_EaseInBlendType,
  Dtool_DowncastInterface_EaseInBlendType,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EaseInBlendType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LerpBlendType(nullptr);
    Dtool_EaseInBlendType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LerpBlendType);
    Dtool_EaseInBlendType._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EaseInBlendType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EaseInBlendType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EaseInBlendType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EaseInBlendType);
  }
}

/**
 * Python method tables for EaseOutBlendType (EaseOutBlendType)
 */
static PyMethodDef Dtool_Methods_EaseOutBlendType[] = {
  {"get_class_type", &Dtool_EaseOutBlendType_get_class_type_194, METH_NOARGS | METH_STATIC, (const char *)Dtool_EaseOutBlendType_get_class_type_194_comment},
  {"getClassType", &Dtool_EaseOutBlendType_get_class_type_194, METH_NOARGS | METH_STATIC, (const char *)Dtool_EaseOutBlendType_get_class_type_194_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EaseOutBlendType = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EaseOutBlendType = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EaseOutBlendType = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EaseOutBlendType = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EaseOutBlendType = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EaseOutBlendType = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.EaseOutBlendType",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EaseOutBlendType,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EaseOutBlendType,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EaseOutBlendType,
    &Dtool_SequenceMethods_EaseOutBlendType,
    &Dtool_MappingMethods_EaseOutBlendType,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EaseOutBlendType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EaseOutBlendType,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EaseOutBlendType,
    PyType_GenericAlloc,
    Dtool_new_EaseOutBlendType,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EaseOutBlendType,
  Dtool_UpcastInterface_EaseOutBlendType,
  Dtool_DowncastInterface_EaseOutBlendType,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EaseOutBlendType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LerpBlendType(nullptr);
    Dtool_EaseOutBlendType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LerpBlendType);
    Dtool_EaseOutBlendType._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EaseOutBlendType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EaseOutBlendType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EaseOutBlendType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EaseOutBlendType);
  }
}

/**
 * Python method tables for EaseInOutBlendType (EaseInOutBlendType)
 */
static PyMethodDef Dtool_Methods_EaseInOutBlendType[] = {
  {"get_class_type", &Dtool_EaseInOutBlendType_get_class_type_197, METH_NOARGS | METH_STATIC, (const char *)Dtool_EaseInOutBlendType_get_class_type_197_comment},
  {"getClassType", &Dtool_EaseInOutBlendType_get_class_type_197, METH_NOARGS | METH_STATIC, (const char *)Dtool_EaseInOutBlendType_get_class_type_197_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_EaseInOutBlendType = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_EaseInOutBlendType = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_EaseInOutBlendType = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_EaseInOutBlendType = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_EaseInOutBlendType = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_EaseInOutBlendType = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.EaseInOutBlendType",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_EaseInOutBlendType,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_EaseInOutBlendType,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_EaseInOutBlendType,
    &Dtool_SequenceMethods_EaseInOutBlendType,
    &Dtool_MappingMethods_EaseInOutBlendType,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_EaseInOutBlendType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_EaseInOutBlendType,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_EaseInOutBlendType,
    PyType_GenericAlloc,
    Dtool_new_EaseInOutBlendType,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_EaseInOutBlendType,
  Dtool_UpcastInterface_EaseInOutBlendType,
  Dtool_DowncastInterface_EaseInOutBlendType,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_EaseInOutBlendType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LerpBlendType(nullptr);
    Dtool_EaseInOutBlendType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LerpBlendType);
    Dtool_EaseInOutBlendType._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_EaseInOutBlendType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_EaseInOutBlendType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(EaseInOutBlendType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_EaseInOutBlendType);
  }
}

/**
 * Python method tables for NoBlendType (NoBlendType)
 */
static PyMethodDef Dtool_Methods_NoBlendType[] = {
  {"get_class_type", &Dtool_NoBlendType_get_class_type_200, METH_NOARGS | METH_STATIC, (const char *)Dtool_NoBlendType_get_class_type_200_comment},
  {"getClassType", &Dtool_NoBlendType_get_class_type_200, METH_NOARGS | METH_STATIC, (const char *)Dtool_NoBlendType_get_class_type_200_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_NoBlendType = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NoBlendType = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_NoBlendType = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_NoBlendType = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_NoBlendType = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_NoBlendType = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.NoBlendType",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NoBlendType,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_NoBlendType,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_NoBlendType,
    &Dtool_SequenceMethods_NoBlendType,
    &Dtool_MappingMethods_NoBlendType,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_NoBlendType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NoBlendType,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NoBlendType,
    PyType_GenericAlloc,
    Dtool_new_NoBlendType,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NoBlendType,
  Dtool_UpcastInterface_NoBlendType,
  Dtool_DowncastInterface_NoBlendType,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_NoBlendType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LerpBlendType(nullptr);
    Dtool_NoBlendType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LerpBlendType);
    Dtool_NoBlendType._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NoBlendType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NoBlendType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NoBlendType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NoBlendType);
  }
}

/**
 * Python method tables for ShowInterval (ShowInterval)
 */
static PyMethodDef Dtool_Methods_ShowInterval[] = {
  {"get_class_type", &Dtool_ShowInterval_get_class_type_203, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShowInterval_get_class_type_203_comment},
  {"getClassType", &Dtool_ShowInterval_get_class_type_203, METH_NOARGS | METH_STATIC, (const char *)Dtool_ShowInterval_get_class_type_203_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ShowInterval = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ShowInterval = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ShowInterval = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ShowInterval = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ShowInterval = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ShowInterval = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.ShowInterval",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ShowInterval,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ShowInterval,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ShowInterval,
    &Dtool_SequenceMethods_ShowInterval,
    &Dtool_MappingMethods_ShowInterval,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ShowInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An interval that calls NodePath::show().\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ShowInterval,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ShowInterval,
    PyType_GenericAlloc,
    Dtool_new_ShowInterval,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ShowInterval,
  Dtool_UpcastInterface_ShowInterval,
  Dtool_DowncastInterface_ShowInterval,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ShowInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CInterval(nullptr);
    Dtool_ShowInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CInterval);
    Dtool_ShowInterval._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ShowInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ShowInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ShowInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ShowInterval);
  }
}

/**
 * Python method tables for WaitInterval (WaitInterval)
 */
static PyMethodDef Dtool_Methods_WaitInterval[] = {
  {"get_class_type", &Dtool_WaitInterval_get_class_type_207, METH_NOARGS | METH_STATIC, (const char *)Dtool_WaitInterval_get_class_type_207_comment},
  {"getClassType", &Dtool_WaitInterval_get_class_type_207, METH_NOARGS | METH_STATIC, (const char *)Dtool_WaitInterval_get_class_type_207_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_WaitInterval = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_WaitInterval = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_WaitInterval = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_WaitInterval = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_WaitInterval = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_WaitInterval = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.WaitInterval",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_WaitInterval,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_WaitInterval,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_WaitInterval,
    &Dtool_SequenceMethods_WaitInterval,
    &Dtool_MappingMethods_WaitInterval,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_WaitInterval,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This interval does absolutely nothing, and is mainly useful for marking\n"
    " * time between other intervals within a sequence.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_WaitInterval,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_WaitInterval,
    PyType_GenericAlloc,
    Dtool_new_WaitInterval,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_WaitInterval,
  Dtool_UpcastInterface_WaitInterval,
  Dtool_DowncastInterface_WaitInterval,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_WaitInterval(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CInterval(nullptr);
    Dtool_WaitInterval._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CInterval);
    Dtool_WaitInterval._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_WaitInterval._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_WaitInterval) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(WaitInterval)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_WaitInterval);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3interval_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    CInterval::init_type();
    TypeHandle handle = CInterval::get_class_type();
    Dtool_CInterval._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CInterval);
  }
  {
    CConstraintInterval::init_type();
    TypeHandle handle = CConstraintInterval::get_class_type();
    Dtool_CConstraintInterval._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CConstraintInterval);
  }
  {
    CConstrainHprInterval::init_type();
    TypeHandle handle = CConstrainHprInterval::get_class_type();
    Dtool_CConstrainHprInterval._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CConstrainHprInterval);
  }
  {
    CConstrainPosHprInterval::init_type();
    TypeHandle handle = CConstrainPosHprInterval::get_class_type();
    Dtool_CConstrainPosHprInterval._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CConstrainPosHprInterval);
  }
  {
    CConstrainPosInterval::init_type();
    TypeHandle handle = CConstrainPosInterval::get_class_type();
    Dtool_CConstrainPosInterval._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CConstrainPosInterval);
  }
  {
    CConstrainTransformInterval::init_type();
    TypeHandle handle = CConstrainTransformInterval::get_class_type();
    Dtool_CConstrainTransformInterval._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CConstrainTransformInterval);
  }
  {
    CLerpInterval::init_type();
    TypeHandle handle = CLerpInterval::get_class_type();
    Dtool_CLerpInterval._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CLerpInterval);
  }
  {
    CLerpAnimEffectInterval::init_type();
    TypeHandle handle = CLerpAnimEffectInterval::get_class_type();
    Dtool_CLerpAnimEffectInterval._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CLerpAnimEffectInterval);
  }
  {
    CLerpNodePathInterval::init_type();
    TypeHandle handle = CLerpNodePathInterval::get_class_type();
    Dtool_CLerpNodePathInterval._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CLerpNodePathInterval);
  }
  {
    CMetaInterval::init_type();
    TypeHandle handle = CMetaInterval::get_class_type();
    Dtool_CMetaInterval._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CMetaInterval);
  }
  {
    HideInterval::init_type();
    TypeHandle handle = HideInterval::get_class_type();
    Dtool_HideInterval._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_HideInterval);
  }
  {
    LerpBlendType::init_type();
    TypeHandle handle = LerpBlendType::get_class_type();
    Dtool_LerpBlendType._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LerpBlendType);
  }
  {
    EaseInBlendType::init_type();
    TypeHandle handle = EaseInBlendType::get_class_type();
    Dtool_EaseInBlendType._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EaseInBlendType);
  }
  {
    EaseOutBlendType::init_type();
    TypeHandle handle = EaseOutBlendType::get_class_type();
    Dtool_EaseOutBlendType._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EaseOutBlendType);
  }
  {
    EaseInOutBlendType::init_type();
    TypeHandle handle = EaseInOutBlendType::get_class_type();
    Dtool_EaseInOutBlendType._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_EaseInOutBlendType);
  }
  {
    NoBlendType::init_type();
    TypeHandle handle = NoBlendType::get_class_type();
    Dtool_NoBlendType._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_NoBlendType);
  }
  {
    ShowInterval::init_type();
    TypeHandle handle = ShowInterval::get_class_type();
    Dtool_ShowInterval._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ShowInterval);
  }
  {
    WaitInterval::init_type();
    TypeHandle handle = WaitInterval::get_class_type();
    Dtool_WaitInterval._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_WaitInterval);
  }
}

void Dtool_libp3interval_BuildInstants(PyObject *module) {
  (void) module;
  // CInterval
  Dtool_PyModuleClassInit_CInterval(module);
  PyModule_AddObject(module, "CInterval", (PyObject *)&Dtool_CInterval);
  // CIntervalManager
  Dtool_PyModuleClassInit_CIntervalManager(module);
  PyModule_AddObject(module, "CIntervalManager", (PyObject *)&Dtool_CIntervalManager);
  // CConstraintInterval
  Dtool_PyModuleClassInit_CConstraintInterval(module);
  PyModule_AddObject(module, "CConstraintInterval", (PyObject *)&Dtool_CConstraintInterval);
  // CConstrainHprInterval
  Dtool_PyModuleClassInit_CConstrainHprInterval(module);
  PyModule_AddObject(module, "CConstrainHprInterval", (PyObject *)&Dtool_CConstrainHprInterval);
  // CConstrainPosHprInterval
  Dtool_PyModuleClassInit_CConstrainPosHprInterval(module);
  PyModule_AddObject(module, "CConstrainPosHprInterval", (PyObject *)&Dtool_CConstrainPosHprInterval);
  // CConstrainPosInterval
  Dtool_PyModuleClassInit_CConstrainPosInterval(module);
  PyModule_AddObject(module, "CConstrainPosInterval", (PyObject *)&Dtool_CConstrainPosInterval);
  // CConstrainTransformInterval
  Dtool_PyModuleClassInit_CConstrainTransformInterval(module);
  PyModule_AddObject(module, "CConstrainTransformInterval", (PyObject *)&Dtool_CConstrainTransformInterval);
  // CLerpInterval
  Dtool_PyModuleClassInit_CLerpInterval(module);
  PyModule_AddObject(module, "CLerpInterval", (PyObject *)&Dtool_CLerpInterval);
  // CLerpAnimEffectInterval
  Dtool_PyModuleClassInit_CLerpAnimEffectInterval(module);
  PyModule_AddObject(module, "CLerpAnimEffectInterval", (PyObject *)&Dtool_CLerpAnimEffectInterval);
  // CLerpNodePathInterval
  Dtool_PyModuleClassInit_CLerpNodePathInterval(module);
  PyModule_AddObject(module, "CLerpNodePathInterval", (PyObject *)&Dtool_CLerpNodePathInterval);
  // CMetaInterval
  Dtool_PyModuleClassInit_CMetaInterval(module);
  PyModule_AddObject(module, "CMetaInterval", (PyObject *)&Dtool_CMetaInterval);
  // HideInterval
  Dtool_PyModuleClassInit_HideInterval(module);
  PyModule_AddObject(module, "HideInterval", (PyObject *)&Dtool_HideInterval);
  // LerpBlendType
  Dtool_PyModuleClassInit_LerpBlendType(module);
  PyModule_AddObject(module, "LerpBlendType", (PyObject *)&Dtool_LerpBlendType);
  // EaseInBlendType
  Dtool_PyModuleClassInit_EaseInBlendType(module);
  PyModule_AddObject(module, "EaseInBlendType", (PyObject *)&Dtool_EaseInBlendType);
  // EaseOutBlendType
  Dtool_PyModuleClassInit_EaseOutBlendType(module);
  PyModule_AddObject(module, "EaseOutBlendType", (PyObject *)&Dtool_EaseOutBlendType);
  // EaseInOutBlendType
  Dtool_PyModuleClassInit_EaseInOutBlendType(module);
  PyModule_AddObject(module, "EaseInOutBlendType", (PyObject *)&Dtool_EaseInOutBlendType);
  // NoBlendType
  Dtool_PyModuleClassInit_NoBlendType(module);
  PyModule_AddObject(module, "NoBlendType", (PyObject *)&Dtool_NoBlendType);
  // ShowInterval
  Dtool_PyModuleClassInit_ShowInterval(module);
  PyModule_AddObject(module, "ShowInterval", (PyObject *)&Dtool_ShowInterval);
  // WaitInterval
  Dtool_PyModuleClassInit_WaitInterval(module);
  PyModule_AddObject(module, "WaitInterval", (PyObject *)&Dtool_WaitInterval);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3interval_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3interval_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583614822,  /* file_identifier */
  "libp3interval",  /* library_name */
  "ceEZ",  /* library_hash_name */
  "panda3d.direct",  /* module_name */
  "libp3interval.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  454  /* next_index */
};

Configure(_in_configure_libp3interval);
ConfigureFn(_in_configure_libp3interval) {
  interrogate_request_module(&_in_module_def);
}

