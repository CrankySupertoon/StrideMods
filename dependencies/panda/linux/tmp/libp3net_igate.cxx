/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/net -Ipanda/src/net -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3net_igate.cxx -od built/pandac/input/libp3net.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/net -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3net config_net.h connection.h connectionListener.h connectionManager.h connectionReader.h connectionWriter.h datagramGeneratorNet.h datagramQueue.h datagramSinkNet.h datagramTCPHeader.h datagramUDPHeader.h netAddress.h netDatagram.h p3net_composite1.cxx p3net_composite2.cxx queuedConnectionListener.h queuedConnectionManager.h queuedConnectionReader.h queuedReturn.h recentConnectionReader.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "conditionVar.h"
#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "configVariableEnum.h"
#include "configVariableInt.h"
#include "config_net.h"
#include "connection.h"
#include "connectionListener.h"
#include "connectionManager.h"
#include "connectionReader.h"
#include "connectionWriter.h"
#include "datagramGenerator.h"
#include "datagramGeneratorNet.h"
#include "datagramIterator.h"
#include "datagramQueue.h"
#include "datagramSink.h"
#include "datagramSinkNet.h"
#include "datagramTCPHeader.h"
#include "datagramUDPHeader.h"
#include "lightMutex.h"
#include "lightReMutex.h"
#include "netAddress.h"
#include "netDatagram.h"
#include "notifyCategoryProxy.h"
#include "numeric_types.h"
#include "pandabase.h"
#include "pmutex.h"
#include "pointerTo.h"
#include "pset.h"
#include "pvector.h"
#include "queuedConnectionListener.h"
#include "queuedConnectionManager.h"
#include "queuedConnectionReader.h"
#include "queuedReturn.h"
#include "recentConnectionReader.h"
#include "referenceCount.h"
#include "thread.h"
#include "threadPriority.h"
#include "vector_uchar.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class PointerTo_Connection
 */
typedef PointerTo< Connection > PointerTo_Connection_localtype;
Define_Module_Class(panda3d.core, PointerTo_Connection, PointerTo_Connection_localtype, PointerTo_Connection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerTo_Connection = &Dtool_PointerTo_Connection;
static void Dtool_PyModuleClassInit_PointerTo_Connection(PyObject *module);
PointerTo< Connection > *Dtool_Coerce_PointerTo_Connection(PyObject *args, PointerTo< Connection > &coerced);

/**
 * Forward declarations for top-level class PointerToBase_Connection
 */
typedef PointerToBase< Connection > PointerToBase_Connection_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_Connection, PointerToBase_Connection_localtype, PointerToBase_Connection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_Connection = &Dtool_PointerToBase_Connection;
static void Dtool_PyModuleClassInit_PointerToBase_Connection(PyObject *module);

/**
 * Forward declarations for top-level class NetAddress
 */
typedef NetAddress NetAddress_localtype;
Define_Module_Class(panda3d.core, NetAddress, NetAddress_localtype, NetAddress);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NetAddress = &Dtool_NetAddress;
static void Dtool_PyModuleClassInit_NetAddress(PyObject *module);
NetAddress *Dtool_Coerce_NetAddress(PyObject *args, NetAddress &coerced);

/**
 * Forward declarations for top-level class Connection
 */
typedef Connection Connection_localtype;
Define_Module_ClassRef(panda3d.core, Connection, Connection_localtype, Connection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Connection = &Dtool_Connection;
static void Dtool_PyModuleClassInit_Connection(PyObject *module);

/**
 * Forward declarations for top-level class ConnectionReader
 */
typedef ConnectionReader ConnectionReader_localtype;
Define_Module_Class(panda3d.core, ConnectionReader, ConnectionReader_localtype, ConnectionReader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConnectionReader = &Dtool_ConnectionReader;
static void Dtool_PyModuleClassInit_ConnectionReader(PyObject *module);

/**
 * Forward declarations for top-level class ConnectionListener
 */
typedef ConnectionListener ConnectionListener_localtype;
Define_Module_Class(panda3d.core, ConnectionListener, ConnectionListener_localtype, ConnectionListener);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConnectionListener = &Dtool_ConnectionListener;
static void Dtool_PyModuleClassInit_ConnectionListener(PyObject *module);

/**
 * Forward declarations for top-level class NetDatagram
 */
typedef NetDatagram NetDatagram_localtype;
Define_Module_Class(panda3d.core, NetDatagram, NetDatagram_localtype, NetDatagram);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NetDatagram = &Dtool_NetDatagram;
static void Dtool_PyModuleClassInit_NetDatagram(PyObject *module);
NetDatagram *Dtool_Coerce_NetDatagram(PyObject *args, NetDatagram &coerced);

/**
 * Forward declarations for top-level class ConnectionManager
 */
typedef ConnectionManager ConnectionManager_localtype;
Define_Module_Class(panda3d.core, ConnectionManager, ConnectionManager_localtype, ConnectionManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConnectionManager = &Dtool_ConnectionManager;
static void Dtool_PyModuleClassInit_ConnectionManager(PyObject *module);

/**
 * Forward declarations for top-level class ConnectionManager_Interface
 */
typedef ConnectionManager::Interface ConnectionManager_Interface_localtype;
Define_Module_Class(panda3d.core, ConnectionManager_Interface, ConnectionManager_Interface_localtype, Interface);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConnectionManager_Interface = &Dtool_ConnectionManager_Interface;
static void Dtool_PyModuleClassInit_ConnectionManager_Interface(PyObject *module);

/**
 * Forward declarations for top-level class ConnectionWriter
 */
typedef ConnectionWriter ConnectionWriter_localtype;
Define_Module_Class(panda3d.core, ConnectionWriter, ConnectionWriter_localtype, ConnectionWriter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConnectionWriter = &Dtool_ConnectionWriter;
static void Dtool_PyModuleClassInit_ConnectionWriter(PyObject *module);

/**
 * Forward declarations for top-level class DatagramGeneratorNet
 */
typedef DatagramGeneratorNet DatagramGeneratorNet_localtype;
Define_Module_Class(panda3d.core, DatagramGeneratorNet, DatagramGeneratorNet_localtype, DatagramGeneratorNet);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramGeneratorNet = &Dtool_DatagramGeneratorNet;
static void Dtool_PyModuleClassInit_DatagramGeneratorNet(PyObject *module);

/**
 * Forward declarations for top-level class QueuedReturn_Datagram
 */
typedef QueuedReturn< Datagram > QueuedReturn_Datagram_localtype;
Define_Module_Class_Private(panda3d.core, QueuedReturn_Datagram, QueuedReturn_Datagram_localtype, QueuedReturn_Datagram);
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedReturn_Datagram = &Dtool_QueuedReturn_Datagram;
static void Dtool_PyModuleClassInit_QueuedReturn_Datagram(PyObject *module);

/**
 * Forward declarations for top-level class DatagramSinkNet
 */
typedef DatagramSinkNet DatagramSinkNet_localtype;
Define_Module_Class(panda3d.core, DatagramSinkNet, DatagramSinkNet_localtype, DatagramSinkNet);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramSinkNet = &Dtool_DatagramSinkNet;
static void Dtool_PyModuleClassInit_DatagramSinkNet(PyObject *module);

/**
 * Forward declarations for top-level class QueuedConnectionListener
 */
typedef QueuedConnectionListener QueuedConnectionListener_localtype;
Define_Module_Class(panda3d.core, QueuedConnectionListener, QueuedConnectionListener_localtype, QueuedConnectionListener);
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedConnectionListener = &Dtool_QueuedConnectionListener;
static void Dtool_PyModuleClassInit_QueuedConnectionListener(PyObject *module);

/**
 * Forward declarations for top-level class QueuedReturn_ConnectionListenerData
 */
typedef QueuedReturn< ConnectionListenerData > QueuedReturn_ConnectionListenerData_localtype;
Define_Module_Class_Private(panda3d.core, QueuedReturn_ConnectionListenerData, QueuedReturn_ConnectionListenerData_localtype, QueuedReturn_ConnectionListenerData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedReturn_ConnectionListenerData = &Dtool_QueuedReturn_ConnectionListenerData;
static void Dtool_PyModuleClassInit_QueuedReturn_ConnectionListenerData(PyObject *module);

/**
 * Forward declarations for top-level class QueuedConnectionManager
 */
typedef QueuedConnectionManager QueuedConnectionManager_localtype;
Define_Module_Class(panda3d.core, QueuedConnectionManager, QueuedConnectionManager_localtype, QueuedConnectionManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedConnectionManager = &Dtool_QueuedConnectionManager;
static void Dtool_PyModuleClassInit_QueuedConnectionManager(PyObject *module);

/**
 * Forward declarations for top-level class QueuedReturn_PointerTo_Connection
 */
typedef QueuedReturn< PointerTo< Connection > > QueuedReturn_PointerTo_Connection_localtype;
Define_Module_Class_Private(panda3d.core, QueuedReturn_PointerTo_Connection, QueuedReturn_PointerTo_Connection_localtype, QueuedReturn_PointerTo_Connection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedReturn_PointerTo_Connection = &Dtool_QueuedReturn_PointerTo_Connection;
static void Dtool_PyModuleClassInit_QueuedReturn_PointerTo_Connection(PyObject *module);

/**
 * Forward declarations for top-level class QueuedConnectionReader
 */
typedef QueuedConnectionReader QueuedConnectionReader_localtype;
Define_Module_Class(panda3d.core, QueuedConnectionReader, QueuedConnectionReader_localtype, QueuedConnectionReader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedConnectionReader = &Dtool_QueuedConnectionReader;
static void Dtool_PyModuleClassInit_QueuedConnectionReader(PyObject *module);

/**
 * Forward declarations for top-level class QueuedReturn_NetDatagram
 */
typedef QueuedReturn< NetDatagram > QueuedReturn_NetDatagram_localtype;
Define_Module_Class_Private(panda3d.core, QueuedReturn_NetDatagram, QueuedReturn_NetDatagram_localtype, QueuedReturn_NetDatagram);
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedReturn_NetDatagram = &Dtool_QueuedReturn_NetDatagram;
static void Dtool_PyModuleClassInit_QueuedReturn_NetDatagram(PyObject *module);

/**
 * Forward declarations for top-level class RecentConnectionReader
 */
typedef RecentConnectionReader RecentConnectionReader_localtype;
Define_Module_Class(panda3d.core, RecentConnectionReader, RecentConnectionReader_localtype, RecentConnectionReader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_RecentConnectionReader = &Dtool_RecentConnectionReader;
static void Dtool_PyModuleClassInit_RecentConnectionReader(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"PointerTo< Connection >", &Dtool_PointerTo_Connection},
  {"PointerToBase< Connection >", &Dtool_PointerToBase_Connection},
  {"NetAddress", &Dtool_NetAddress},
  {"Connection", &Dtool_Connection},
  {"ConnectionReader", &Dtool_ConnectionReader},
  {"ConnectionListener", &Dtool_ConnectionListener},
  {"NetDatagram", &Dtool_NetDatagram},
  {"ConnectionManager", &Dtool_ConnectionManager},
  {"ConnectionManager::Interface", &Dtool_ConnectionManager_Interface},
  {"ConnectionWriter", &Dtool_ConnectionWriter},
  {"DatagramGeneratorNet", &Dtool_DatagramGeneratorNet},
  {"QueuedReturn< Datagram >", &Dtool_QueuedReturn_Datagram},
  {"DatagramSinkNet", &Dtool_DatagramSinkNet},
  {"QueuedConnectionListener", &Dtool_QueuedConnectionListener},
  {"QueuedReturn< ConnectionListenerData >", &Dtool_QueuedReturn_ConnectionListenerData},
  {"QueuedConnectionManager", &Dtool_QueuedConnectionManager},
  {"QueuedReturn< PointerTo< Connection > >", &Dtool_QueuedReturn_PointerTo_Connection},
  {"QueuedConnectionReader", &Dtool_QueuedConnectionReader},
  {"QueuedReturn< NetDatagram >", &Dtool_QueuedReturn_NetDatagram},
  {"RecentConnectionReader", &Dtool_RecentConnectionReader},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[1].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[2].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[3].type)
  {"Socket_Address", nullptr},
#define Dtool_Ptr_Socket_Address (imports[4].type)
  {"PointerToVoid", nullptr},
#define Dtool_Ptr_PointerToVoid (imports[5].type)
  {"Socket_IP", nullptr},
#define Dtool_Ptr_Socket_IP (imports[6].type)
  {"Datagram", nullptr},
#define Dtool_Ptr_Datagram (imports[7].type)
  {"DatagramGenerator", nullptr},
#define Dtool_Ptr_DatagramGenerator (imports[8].type)
  {"DatagramSink", nullptr},
#define Dtool_Ptr_DatagramSink (imports[9].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// Socket_Address
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Socket_Address;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_Address = &Dtool_Socket_Address;
#endif
// PointerToVoid
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PointerToVoid;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToVoid = &Dtool_PointerToVoid;
#endif
// Socket_IP
#ifndef LINK_ALL_STATIC
inline static Socket_IP *Dtool_Coerce_Socket_IP(PyObject *args, Socket_IP &coerced) {
  nassertr(Dtool_Ptr_Socket_IP != nullptr, nullptr);
  nassertr(Dtool_Ptr_Socket_IP->_Dtool_Coerce != nullptr, nullptr);
  return ((Socket_IP *(*)(PyObject *, Socket_IP &))Dtool_Ptr_Socket_IP->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Socket_IP;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Socket_IP = &Dtool_Socket_IP;
extern Socket_IP *Dtool_Coerce_Socket_IP(PyObject *args, Socket_IP &coerced);
#endif
// Datagram
#ifndef LINK_ALL_STATIC
inline static Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced) {
  nassertr(Dtool_Ptr_Datagram != nullptr, nullptr);
  nassertr(Dtool_Ptr_Datagram->_Dtool_Coerce != nullptr, nullptr);
  return ((Datagram *(*)(PyObject *, Datagram &))Dtool_Ptr_Datagram->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Datagram;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
extern Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced);
#endif
// DatagramGenerator
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DatagramGenerator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramGenerator = &Dtool_DatagramGenerator;
#endif
// DatagramSink
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DatagramSink;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramSink = &Dtool_DatagramSink;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class PointerTo< Connection >
 */
/**
 * Python function wrapper for:
 * constexpr Connection *PointerTo< Connection >::p(void) const noexcept
 */
static PyObject *Dtool_PointerTo_Connection_p_7(PyObject *self, PyObject *) {
  PointerTo< Connection > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerTo_Connection)) {
    return nullptr;
  }
  // 1-constexpr Connection *PointerTo< Connection >::p(void) const noexcept
  Connection *return_value = ((*(const PointerTo< Connection >*)local_this).p)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Connection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PointerTo_Connection_p_7_comment =
  "C++ Interface:\n"
  "p(PointerTo self)\n"
  "\n"
  "// If your base class is a derivative of TypedObject, you might want to use\n"
  "// the DCAST macro defined in typedObject.h instead, e.g.  DCAST(MyType,\n"
  "// ptr).  This provides a clean downcast that doesn't require .p() or any\n"
  "// double-casting, and it can be run-time checked for correctness.";
#else
static const char *Dtool_PointerTo_Connection_p_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerTo< Connection >::operator =(Connection *ptr)
 * inline void PointerTo< Connection >::operator =(PointerTo< Connection > const &copy)
 */
static PyObject *Dtool_PointerTo_Connection_operator_8(PyObject *self, PyObject *arg) {
  PointerTo< Connection > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerTo_Connection, (void **)&local_this, "PointerTo_Connection.assign")) {
    return nullptr;
  }
  {
    // -2 inline void PointerTo< Connection >::operator =(PointerTo< Connection > const &copy)
    Connection *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Connection);
    if (arg_this != nullptr) {
      ((*local_this).operator =)(arg_this);
      PointerTo< Connection > *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerTo_Connection, false, false);
    }
  }

  {
    // -2 inline void PointerTo< Connection >::operator =(Connection *ptr)
    Connection *arg_this = (Connection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Connection, 1, "PointerTo.assign", false, false);
    if (arg_this != nullptr) {
      ((*local_this).operator =)(arg_this);
      PointerTo< Connection > *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerTo_Connection, false, false);
    }
  }

  // No coercion possible: inline void PointerTo< Connection >::operator =(PointerTo< Connection > const &copy)
  // No coercion possible: inline void PointerTo< Connection >::operator =(Connection *ptr)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PointerTo self, const Connection copy)\n"
      "assign(const PointerTo self, Connection ptr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerTo_Connection_operator_8_comment =
  "C++ Interface:\n"
  "assign(const PointerTo self, const Connection copy)\n"
  "assign(const PointerTo self, Connection ptr)\n";
#else
static const char *Dtool_PointerTo_Connection_operator_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PointerTo< Connection >::is_null(void) const
 */
static PyObject *Dtool_PointerTo_Connection_is_null_9(PyObject *self, PyObject *) {
  PointerTo< Connection > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerTo_Connection)) {
    return nullptr;
  }
  // 1-inline bool PointerTo< Connection >::is_null(void) const
  bool return_value = ((*(const PointerTo< Connection >*)local_this).is_null)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerTo_Connection_is_null_9_comment =
  "C++ Interface:\n"
  "is_null(PointerTo self)\n";
#else
static const char *Dtool_PointerTo_Connection_is_null_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerTo< Connection >::clear(void)
 */
static PyObject *Dtool_PointerTo_Connection_clear_10(PyObject *self, PyObject *) {
  PointerTo< Connection > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerTo_Connection, (void **)&local_this, "PointerTo_Connection.clear")) {
    return nullptr;
  }
  // 1-inline void PointerTo< Connection >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerTo_Connection_clear_10_comment =
  "C++ Interface:\n"
  "clear(const PointerTo self)\n";
#else
static const char *Dtool_PointerTo_Connection_clear_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline constexpr PointerTo< Connection >::PointerTo(void) noexcept = default
 * inline PointerTo< Connection >::PointerTo(Connection *ptr) noexcept
 * inline PointerTo< Connection >::PointerTo(PointerTo< Connection > const &copy)
 * inline explicit constexpr PointerTo< Connection >::PointerTo(decltype(nullptr) ) noexcept
 */
static int Dtool_Init_PointerTo_Connection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline constexpr PointerTo< Connection >::PointerTo(void) noexcept = default
      PointerTo< Connection > *return_value = new PointerTo< Connection >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerTo_Connection, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerTo< Connection >::PointerTo(PointerTo< Connection > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          Connection *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Connection);
          if (param0_this != nullptr) {
            PointerTo< Connection > *return_value = new PointerTo< Connection >(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerTo_Connection, true, false);
          }
        }
      }

      {
        // -2 inline PointerTo< Connection >::PointerTo(Connection *ptr) noexcept
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "ptr")) {
          Connection *param0_this = (Connection *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_Connection, 0, "PointerTo.PointerTo", false, false);
          if (param0_this != nullptr) {
            PointerTo< Connection > *return_value = new PointerTo< Connection >(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerTo_Connection, true, false);
          }
        }
      }

      {
        // -2 inline explicit constexpr PointerTo< Connection >::PointerTo(decltype(nullptr) ) noexcept
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          if (param0 == Py_None) {
            PointerTo< Connection > *return_value = new PointerTo< Connection >(nullptr);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerTo_Connection, true, false);
          }
        }
      }

      // No coercion possible: inline PointerTo< Connection >::PointerTo(PointerTo< Connection > const &copy)
      // No coercion possible: inline PointerTo< Connection >::PointerTo(Connection *ptr) noexcept
      // No coercion possible: inline explicit constexpr PointerTo< Connection >::PointerTo(decltype(nullptr) ) noexcept
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerTo() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerTo()\n"
      "PointerTo(const Connection copy)\n"
      "PointerTo(Connection ptr)\n"
      "PointerTo(NoneType param0)\n");
  }
  return -1;
}

PointerTo< Connection > *Dtool_Coerce_PointerTo_Connection(PyObject *args, PointerTo< Connection > &coerced) {
  PointerTo< Connection > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerTo_Connection)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerTo< Connection > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline PointerTo< Connection >::PointerTo(Connection *ptr) noexcept
    Connection *arg_this = (Connection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Connection, 0, "PointerTo.PointerTo", false, false);
    if (arg_this != nullptr) {
      coerced = PointerTo< Connection >(arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerTo_Connection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerTo_Connection) {
    printf("PointerTo_Connection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerTo< Connection > *local_this = (PointerTo< Connection > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerTo_Connection) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_Connection) {
    return (PointerToBase< Connection > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< Connection > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerTo_Connection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerTo_Connection) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_Connection) {
    PointerToBase< Connection >* other_this = (PointerToBase< Connection >*)from_this;
    return (PointerTo< Connection >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerTo< Connection >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< Connection >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< Connection >::clear(void)
 */
static PyObject *Dtool_PointerToBase_Connection_clear_4(PyObject *self, PyObject *) {
  PointerToBase< Connection > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_Connection, (void **)&local_this, "PointerToBase_Connection.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< Connection >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_Connection_clear_4_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_Connection_clear_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< Connection >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_Connection_output_5(PyObject *self, PyObject *arg) {
  PointerToBase< Connection > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_Connection)) {
    return nullptr;
  }
  // 1-void PointerToBase< Connection >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< Connection >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_Connection_output_5_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_Connection_output_5_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_Connection(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_Connection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_Connection) {
    printf("PointerToBase_Connection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< Connection > *local_this = (PointerToBase< Connection > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_Connection) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_Connection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_Connection) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< Connection >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NetAddress
 */
/**
 * Python function wrapper for:
 * bool NetAddress::set_any(int port)
 */
static PyObject *Dtool_NetAddress_set_any_14(PyObject *self, PyObject *arg) {
  NetAddress *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetAddress, (void **)&local_this, "NetAddress.set_any")) {
    return nullptr;
  }
  // 1-bool NetAddress::set_any(int port)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).set_any)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_any(const NetAddress self, int port)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_set_any_14_comment =
  "C++ Interface:\n"
  "set_any(const NetAddress self, int port)\n"
  "\n"
  "/**\n"
  " * Sets the address up to refer to a particular port, but not to any\n"
  " * particular IP.  Returns true if successful, false otherwise (currently,\n"
  " * this only returns true).\n"
  " */";
#else
static const char *Dtool_NetAddress_set_any_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NetAddress::set_localhost(int port)
 */
static PyObject *Dtool_NetAddress_set_localhost_15(PyObject *self, PyObject *arg) {
  NetAddress *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetAddress, (void **)&local_this, "NetAddress.set_localhost")) {
    return nullptr;
  }
  // 1-bool NetAddress::set_localhost(int port)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).set_localhost)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_localhost(const NetAddress self, int port)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_set_localhost_15_comment =
  "C++ Interface:\n"
  "set_localhost(const NetAddress self, int port)\n"
  "\n"
  "/**\n"
  " * Sets the address up to refer to a particular port, on this host.\n"
  " */";
#else
static const char *Dtool_NetAddress_set_localhost_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NetAddress::set_broadcast(int port)
 */
static PyObject *Dtool_NetAddress_set_broadcast_16(PyObject *self, PyObject *arg) {
  NetAddress *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetAddress, (void **)&local_this, "NetAddress.set_broadcast")) {
    return nullptr;
  }
  // 1-bool NetAddress::set_broadcast(int port)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*local_this).set_broadcast)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_broadcast(const NetAddress self, int port)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_set_broadcast_16_comment =
  "C++ Interface:\n"
  "set_broadcast(const NetAddress self, int port)\n"
  "\n"
  "/**\n"
  " * Sets the address to the broadcast address.\n"
  " */";
#else
static const char *Dtool_NetAddress_set_broadcast_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NetAddress::set_host(std::string const &hostname, int port)
 */
static PyObject *Dtool_NetAddress_set_host_17(PyObject *self, PyObject *args, PyObject *kwds) {
  NetAddress *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetAddress, (void **)&local_this, "NetAddress.set_host")) {
    return nullptr;
  }
  // 1-bool NetAddress::set_host(std::string const &hostname, int port)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  int param2;
  static const char *keyword_list[] = {"hostname", "port", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#i:set_host", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    bool return_value = ((*local_this).set_host)(std::string(param1_str, param1_len), (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_host(const NetAddress self, str hostname, int port)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_set_host_17_comment =
  "C++ Interface:\n"
  "set_host(const NetAddress self, str hostname, int port)\n"
  "\n"
  "/**\n"
  " * Sets the address up to refer to a particular port on a particular host.\n"
  " * Returns true if the hostname is known, false otherwise.\n"
  " */";
#else
static const char *Dtool_NetAddress_set_host_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NetAddress::clear(void)
 */
static PyObject *Dtool_NetAddress_clear_18(PyObject *self, PyObject *) {
  NetAddress *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetAddress, (void **)&local_this, "NetAddress.clear")) {
    return nullptr;
  }
  // 1-void NetAddress::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_clear_18_comment =
  "C++ Interface:\n"
  "clear(const NetAddress self)\n"
  "\n"
  "/**\n"
  " * Resets the NetAddress to its initial state.\n"
  " */";
#else
static const char *Dtool_NetAddress_clear_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int NetAddress::get_port(void) const
 */
static PyObject *Dtool_NetAddress_get_port_19(PyObject *self, PyObject *) {
  NetAddress *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NetAddress)) {
    return nullptr;
  }
  // 1-int NetAddress::get_port(void) const
  int return_value = ((*(const NetAddress*)local_this).get_port)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_get_port_19_comment =
  "C++ Interface:\n"
  "get_port(NetAddress self)\n"
  "\n"
  "/**\n"
  " * Returns the port number to which this address refers.\n"
  " */";
#else
static const char *Dtool_NetAddress_get_port_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NetAddress::set_port(int port)
 */
static PyObject *Dtool_NetAddress_set_port_20(PyObject *self, PyObject *arg) {
  NetAddress *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetAddress, (void **)&local_this, "NetAddress.set_port")) {
    return nullptr;
  }
  // 1-void NetAddress::set_port(int port)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_port)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_port(const NetAddress self, int port)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_set_port_20_comment =
  "C++ Interface:\n"
  "set_port(const NetAddress self, int port)\n"
  "\n"
  "/**\n"
  " * Resets the port number without otherwise changing the address.\n"
  " */";
#else
static const char *Dtool_NetAddress_set_port_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string NetAddress::get_ip_string(void) const
 */
static PyObject *Dtool_NetAddress_get_ip_string_21(PyObject *self, PyObject *) {
  NetAddress *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NetAddress)) {
    return nullptr;
  }
  // 1-std::string NetAddress::get_ip_string(void) const
  std::string return_value = ((*(const NetAddress*)local_this).get_ip_string)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_get_ip_string_21_comment =
  "C++ Interface:\n"
  "get_ip_string(NetAddress self)\n"
  "\n"
  "/**\n"
  " * Returns the IP address to which this address refers, formatted as a string.\n"
  " */";
#else
static const char *Dtool_NetAddress_get_ip_string_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool NetAddress::is_any(void) const
 */
static PyObject *Dtool_NetAddress_is_any_22(PyObject *self, PyObject *) {
  NetAddress *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NetAddress)) {
    return nullptr;
  }
  // 1-bool NetAddress::is_any(void) const
  bool return_value = ((*(const NetAddress*)local_this).is_any)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_is_any_22_comment =
  "C++ Interface:\n"
  "is_any(NetAddress self)\n"
  "\n"
  "/**\n"
  " * Returns true if the IP address has only zeroes.\n"
  " */";
#else
static const char *Dtool_NetAddress_is_any_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * uint32_t NetAddress::get_ip(void) const
 */
static PyObject *Dtool_NetAddress_get_ip_23(PyObject *self, PyObject *) {
  NetAddress *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NetAddress)) {
    return nullptr;
  }
  // 1-uint32_t NetAddress::get_ip(void) const
  uint32_t return_value = ((*(const NetAddress*)local_this).get_ip)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_get_ip_23_comment =
  "C++ Interface:\n"
  "get_ip(NetAddress self)\n"
  "\n"
  "/**\n"
  " * Returns the IP address to which this address refers, as a 32-bit integer,\n"
  " * in host byte order.\n"
  " * @deprecated  Does not work with IPv6 addresses.\n"
  " */";
#else
static const char *Dtool_NetAddress_get_ip_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * uint8_t NetAddress::get_ip_component(int n) const
 */
static PyObject *Dtool_NetAddress_get_ip_component_24(PyObject *self, PyObject *arg) {
  NetAddress *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NetAddress)) {
    return nullptr;
  }
  // 1-uint8_t NetAddress::get_ip_component(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    uint8_t return_value = ((*(const NetAddress*)local_this).get_ip_component)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_ip_component(NetAddress self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_get_ip_component_24_comment =
  "C++ Interface:\n"
  "get_ip_component(NetAddress self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth 8-bit component of the IP address.  An IP address has four\n"
  " * components; component 0 is the first (leftmost), and component 3 is the\n"
  " * last (rightmost) in the dotted number convention.\n"
  " */";
#else
static const char *Dtool_NetAddress_get_ip_component_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Socket_Address const &NetAddress::get_addr(void) const
 */
static PyObject *Dtool_NetAddress_get_addr_25(PyObject *self, PyObject *) {
  NetAddress *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NetAddress)) {
    return nullptr;
  }
  // 1-Socket_Address const &NetAddress::get_addr(void) const
  Socket_Address const *return_value = &(((*(const NetAddress*)local_this).get_addr)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Socket_Address, false, true);
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_get_addr_25_comment =
  "C++ Interface:\n"
  "get_addr(NetAddress self)\n"
  "\n"
  "/**\n"
  " * Returns the Socket_Address for this address.\n"
  " */";
#else
static const char *Dtool_NetAddress_get_addr_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NetAddress::output(std::ostream &out) const
 */
static PyObject *Dtool_NetAddress_output_26(PyObject *self, PyObject *arg) {
  NetAddress *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NetAddress)) {
    return nullptr;
  }
  // 1-void NetAddress::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "NetAddress.output", false, true);
  if (arg_this != nullptr) {
    ((*(const NetAddress*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(NetAddress self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_output_26_comment =
  "C++ Interface:\n"
  "output(NetAddress self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NetAddress_output_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t NetAddress::get_hash(void) const
 */
static PyObject *Dtool_NetAddress_get_hash_27(PyObject *self, PyObject *) {
  NetAddress *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NetAddress)) {
    return nullptr;
  }
  // 1-std::size_t NetAddress::get_hash(void) const
  std::size_t return_value = ((*(const NetAddress*)local_this).get_hash)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NetAddress_get_hash_27_comment =
  "C++ Interface:\n"
  "get_hash(NetAddress self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_NetAddress_get_hash_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NetAddress::NetAddress(void)
 * inline NetAddress::NetAddress(NetAddress const &) = default
 * NetAddress::NetAddress(Socket_Address const &addr)
 */
static int Dtool_Init_NetAddress(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-NetAddress::NetAddress(void)
      NetAddress *return_value = new NetAddress();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetAddress, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline NetAddress::NetAddress(NetAddress const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          NetAddress const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_NetAddress);
          if (param0_this != nullptr) {
            NetAddress *return_value = new NetAddress(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetAddress, true, false);
          }
        }
      }

      {
        // -2 NetAddress::NetAddress(Socket_Address const &addr)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "addr")) {
          Socket_Address const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Socket_Address);
          if (param0_this != nullptr) {
            NetAddress *return_value = new NetAddress(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetAddress, true, false);
          }
        }
      }

      {
        // -2 inline NetAddress::NetAddress(NetAddress const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          NetAddress param0_local;
          NetAddress const *param0_this = Dtool_Coerce_NetAddress(param0, param0_local);
          if ((param0_this != nullptr)) {
            NetAddress *return_value = new NetAddress(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetAddress, true, false);
          }
        }
      }

      // No coercion possible: NetAddress::NetAddress(Socket_Address const &addr)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "NetAddress() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NetAddress()\n"
      "NetAddress(const NetAddress param0)\n"
      "NetAddress(const Socket_Address addr)\n");
  }
  return -1;
}

NetAddress *Dtool_Coerce_NetAddress(PyObject *args, NetAddress &coerced) {
  NetAddress *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_NetAddress)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const NetAddress *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-NetAddress::NetAddress(Socket_Address const &addr)
    Socket_Address const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Socket_Address);
    if (arg_this != nullptr) {
      coerced = NetAddress(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_NetAddress(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NetAddress) {
    printf("NetAddress ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NetAddress *local_this = (NetAddress *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NetAddress) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NetAddress(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NetAddress) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Connection
 */
/**
 * Python function wrapper for:
 * NetAddress Connection::get_address(void) const
 */
static PyObject *Dtool_Connection_get_address_34(PyObject *self, PyObject *) {
  Connection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Connection)) {
    return nullptr;
  }
  // 1-NetAddress Connection::get_address(void) const
  NetAddress *return_value = new NetAddress(((*(const Connection*)local_this).get_address)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NetAddress, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Connection_get_address_34_comment =
  "C++ Interface:\n"
  "get_address(Connection self)\n"
  "\n"
  "/**\n"
  " * Returns the address bound to this connection, if it is a TCP connection.\n"
  " */";
#else
static const char *Dtool_Connection_get_address_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConnectionManager *Connection::get_manager(void) const
 */
static PyObject *Dtool_Connection_get_manager_35(PyObject *self, PyObject *) {
  Connection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Connection)) {
    return nullptr;
  }
  // 1-ConnectionManager *Connection::get_manager(void) const
  ConnectionManager *return_value = ((*(const Connection*)local_this).get_manager)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Connection_get_manager_35_comment =
  "C++ Interface:\n"
  "get_manager(Connection self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the ConnectionManager object that serves this\n"
  " * connection.\n"
  " */";
#else
static const char *Dtool_Connection_get_manager_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Socket_IP *Connection::get_socket(void) const
 */
static PyObject *Dtool_Connection_get_socket_36(PyObject *self, PyObject *) {
  Connection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Connection)) {
    return nullptr;
  }
  // 1-Socket_IP *Connection::get_socket(void) const
  Socket_IP *return_value = ((*(const Connection*)local_this).get_socket)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Socket_IP, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Connection_get_socket_36_comment =
  "C++ Interface:\n"
  "get_socket(Connection self)\n"
  "\n"
  "/**\n"
  " * Returns the internal Socket_IP that defines the connection.\n"
  " */";
#else
static const char *Dtool_Connection_get_socket_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_collect_tcp(bool collect_tcp)
 */
static PyObject *Dtool_Connection_set_collect_tcp_37(PyObject *self, PyObject *arg) {
  Connection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_collect_tcp")) {
    return nullptr;
  }
  // 1-void Connection::set_collect_tcp(bool collect_tcp)
  ((*local_this).set_collect_tcp)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collect_tcp(const Connection self, bool collect_tcp)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_collect_tcp_37_comment =
  "C++ Interface:\n"
  "set_collect_tcp(const Connection self, bool collect_tcp)\n"
  "\n"
  "/**\n"
  " * Enables or disables \"collect-tcp\" mode.  In this mode, individual TCP\n"
  " * packets are not sent immediately, but rather they are collected together\n"
  " * and accumulated to be sent periodically as one larger TCP packet.  This\n"
  " * cuts down on overhead from the TCP/IP protocol, especially if many small\n"
  " * packets need to be sent on the same connection, but it introduces\n"
  " * additional latency (since packets must be held before they can be sent).\n"
  " *\n"
  " * See set_collect_tcp_interval() to specify the interval of time for which to\n"
  " * hold packets before sending them.\n"
  " *\n"
  " * If you enable this mode, you may also need to periodically call\n"
  " * consider_flush() to flush the queue if no packets have been sent recently.\n"
  " */";
#else
static const char *Dtool_Connection_set_collect_tcp_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Connection::get_collect_tcp(void) const
 */
static PyObject *Dtool_Connection_get_collect_tcp_38(PyObject *self, PyObject *) {
  Connection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Connection)) {
    return nullptr;
  }
  // 1-bool Connection::get_collect_tcp(void) const
  bool return_value = ((*(const Connection*)local_this).get_collect_tcp)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Connection_get_collect_tcp_38_comment =
  "C++ Interface:\n"
  "get_collect_tcp(Connection self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of \"collect-tcp\" mode.  See set_collect_tcp().\n"
  " */";
#else
static const char *Dtool_Connection_get_collect_tcp_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_collect_tcp_interval(double interval)
 */
static PyObject *Dtool_Connection_set_collect_tcp_interval_39(PyObject *self, PyObject *arg) {
  Connection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_collect_tcp_interval")) {
    return nullptr;
  }
  // 1-void Connection::set_collect_tcp_interval(double interval)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_collect_tcp_interval)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_collect_tcp_interval(const Connection self, double interval)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_collect_tcp_interval_39_comment =
  "C++ Interface:\n"
  "set_collect_tcp_interval(const Connection self, double interval)\n"
  "\n"
  "/**\n"
  " * Specifies the interval in time, in seconds, for which to hold TCP packets\n"
  " * before sending all of the recently received packets at once.  This only has\n"
  " * meaning if \"collect-tcp\" mode is enabled; see set_collect_tcp().\n"
  " */";
#else
static const char *Dtool_Connection_set_collect_tcp_interval_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double Connection::get_collect_tcp_interval(void) const
 */
static PyObject *Dtool_Connection_get_collect_tcp_interval_40(PyObject *self, PyObject *) {
  Connection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Connection)) {
    return nullptr;
  }
  // 1-double Connection::get_collect_tcp_interval(void) const
  double return_value = ((*(const Connection*)local_this).get_collect_tcp_interval)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Connection_get_collect_tcp_interval_40_comment =
  "C++ Interface:\n"
  "get_collect_tcp_interval(Connection self)\n"
  "\n"
  "/**\n"
  " * Returns the interval in time, in seconds, for which to hold TCP packets\n"
  " * before sending all of the recently received packets at once.  This only has\n"
  " * meaning if \"collect-tcp\" mode is enabled; see set_collect_tcp().\n"
  " */";
#else
static const char *Dtool_Connection_get_collect_tcp_interval_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Connection::consider_flush(void)
 */
static PyObject *Dtool_Connection_consider_flush_41(PyObject *self, PyObject *) {
  Connection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.consider_flush")) {
    return nullptr;
  }
  // 1-bool Connection::consider_flush(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).consider_flush)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Connection_consider_flush_41_comment =
  "C++ Interface:\n"
  "consider_flush(const Connection self)\n"
  "\n"
  "/**\n"
  " * Sends the most recently queued TCP datagram(s) if enough time has elapsed.\n"
  " * This only has meaning if set_collect_tcp() has been set to true.\n"
  " */";
#else
static const char *Dtool_Connection_consider_flush_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool Connection::flush(void)
 */
static PyObject *Dtool_Connection_flush_42(PyObject *self, PyObject *) {
  Connection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.flush")) {
    return nullptr;
  }
  // 1-bool Connection::flush(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).flush)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Connection_flush_42_comment =
  "C++ Interface:\n"
  "flush(const Connection self)\n"
  "\n"
  "/**\n"
  " * Sends the most recently queued TCP datagram(s) now.  This only has meaning\n"
  " * if set_collect_tcp() has been set to true.\n"
  " */";
#else
static const char *Dtool_Connection_flush_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_linger(bool flag, double time)
 */
static PyObject *Dtool_Connection_set_linger_43(PyObject *self, PyObject *args, PyObject *kwds) {
  Connection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_linger")) {
    return nullptr;
  }
  // 1-void Connection::set_linger(bool flag, double time)
  PyObject *param1;
  double param2;
  static const char *keyword_list[] = {"flag", "time", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Od:set_linger", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_linger)((PyObject_IsTrue(param1) != 0), (double)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_linger(const Connection self, bool flag, double time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_linger_43_comment =
  "C++ Interface:\n"
  "set_linger(const Connection self, bool flag, double time)\n"
  "\n"
  "// Socket options.  void set_nonblock(bool flag);\n"
  "\n"
  "/**\n"
  " * Sets the time to linger on close if data is present.  If flag is false,\n"
  " * when you close a socket with data available the system attempts to deliver\n"
  " * the data to the peer (the default behavior).  If flag is false but time is\n"
  " * zero, the system discards any undelivered data when you close the socket.\n"
  " * If flag is false but time is nonzero, the system waits up to time seconds\n"
  " * to deliver the data.\n"
  " */";
#else
static const char *Dtool_Connection_set_linger_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_reuse_addr(bool flag)
 */
static PyObject *Dtool_Connection_set_reuse_addr_44(PyObject *self, PyObject *arg) {
  Connection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_reuse_addr")) {
    return nullptr;
  }
  // 1-void Connection::set_reuse_addr(bool flag)
  ((*local_this).set_reuse_addr)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_reuse_addr(const Connection self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_reuse_addr_44_comment =
  "C++ Interface:\n"
  "set_reuse_addr(const Connection self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets whether local address reuse is allowed.\n"
  " */";
#else
static const char *Dtool_Connection_set_reuse_addr_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_keep_alive(bool flag)
 */
static PyObject *Dtool_Connection_set_keep_alive_45(PyObject *self, PyObject *arg) {
  Connection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_keep_alive")) {
    return nullptr;
  }
  // 1-void Connection::set_keep_alive(bool flag)
  ((*local_this).set_keep_alive)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_keep_alive(const Connection self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_keep_alive_45_comment =
  "C++ Interface:\n"
  "set_keep_alive(const Connection self, bool flag)\n"
  "\n"
  "/**\n"
  " * Sets whether the connection is periodically tested to see if it is still\n"
  " * alive.\n"
  " */";
#else
static const char *Dtool_Connection_set_keep_alive_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_recv_buffer_size(int size)
 */
static PyObject *Dtool_Connection_set_recv_buffer_size_46(PyObject *self, PyObject *arg) {
  Connection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_recv_buffer_size")) {
    return nullptr;
  }
  // 1-void Connection::set_recv_buffer_size(int size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_recv_buffer_size)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_recv_buffer_size(const Connection self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_recv_buffer_size_46_comment =
  "C++ Interface:\n"
  "set_recv_buffer_size(const Connection self, int size)\n"
  "\n"
  "/**\n"
  " * Sets the size of the receive buffer, in bytes.\n"
  " */";
#else
static const char *Dtool_Connection_set_recv_buffer_size_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_send_buffer_size(int size)
 */
static PyObject *Dtool_Connection_set_send_buffer_size_47(PyObject *self, PyObject *arg) {
  Connection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_send_buffer_size")) {
    return nullptr;
  }
  // 1-void Connection::set_send_buffer_size(int size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_send_buffer_size)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_send_buffer_size(const Connection self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_send_buffer_size_47_comment =
  "C++ Interface:\n"
  "set_send_buffer_size(const Connection self, int size)\n"
  "\n"
  "/**\n"
  " * Sets the size of the send buffer, in bytes.\n"
  " */";
#else
static const char *Dtool_Connection_set_send_buffer_size_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_ip_time_to_live(int ttl)
 */
static PyObject *Dtool_Connection_set_ip_time_to_live_48(PyObject *self, PyObject *arg) {
  Connection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_ip_time_to_live")) {
    return nullptr;
  }
  // 1-void Connection::set_ip_time_to_live(int ttl)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_ip_time_to_live)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ip_time_to_live(const Connection self, int ttl)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_ip_time_to_live_48_comment =
  "C++ Interface:\n"
  "set_ip_time_to_live(const Connection self, int ttl)\n"
  "\n"
  "/**\n"
  " * Sets IP time-to-live.\n"
  " */";
#else
static const char *Dtool_Connection_set_ip_time_to_live_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_ip_type_of_service(int tos)
 */
static PyObject *Dtool_Connection_set_ip_type_of_service_49(PyObject *self, PyObject *arg) {
  Connection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_ip_type_of_service")) {
    return nullptr;
  }
  // 1-void Connection::set_ip_type_of_service(int tos)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_ip_type_of_service)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_ip_type_of_service(const Connection self, int tos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_ip_type_of_service_49_comment =
  "C++ Interface:\n"
  "set_ip_type_of_service(const Connection self, int tos)\n"
  "\n"
  "/**\n"
  " * Sets IP type-of-service and precedence.\n"
  " */";
#else
static const char *Dtool_Connection_set_ip_type_of_service_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_no_delay(bool flag)
 */
static PyObject *Dtool_Connection_set_no_delay_50(PyObject *self, PyObject *arg) {
  Connection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_no_delay")) {
    return nullptr;
  }
  // 1-void Connection::set_no_delay(bool flag)
  ((*local_this).set_no_delay)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_no_delay(const Connection self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_no_delay_50_comment =
  "C++ Interface:\n"
  "set_no_delay(const Connection self, bool flag)\n"
  "\n"
  "/**\n"
  " * If flag is true, this disables the Nagle algorithm, and prevents delaying\n"
  " * of send to coalesce packets.\n"
  " */";
#else
static const char *Dtool_Connection_set_no_delay_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void Connection::set_max_segment(int size)
 */
static PyObject *Dtool_Connection_set_max_segment_51(PyObject *self, PyObject *arg) {
  Connection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Connection, (void **)&local_this, "Connection.set_max_segment")) {
    return nullptr;
  }
  // 1-void Connection::set_max_segment(int size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_max_segment)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_segment(const Connection self, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Connection_set_max_segment_51_comment =
  "C++ Interface:\n"
  "set_max_segment(const Connection self, int size)\n"
  "\n"
  "/**\n"
  " * Sets the maximum segment size.\n"
  " */";
#else
static const char *Dtool_Connection_set_max_segment_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit Connection::Connection(ConnectionManager *manager, Socket_IP *socket)
 */
static int Dtool_Init_Connection(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit Connection::Connection(ConnectionManager *manager, Socket_IP *socket)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"manager", "socket", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:Connection", (char **)keyword_list, &param0, &param1)) {
    ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "Connection.Connection", false, true);
    Socket_IP param1_local;
    Socket_IP *param1_this = Dtool_Coerce_Socket_IP(param1, param1_local);
    if (!(param1_this != nullptr)) {
      Dtool_Raise_ArgTypeError(param1, 1, "Connection.Connection", "Socket_IP");
      return -1;
    }
    if (param0_this != nullptr) {
      Connection *return_value = new Connection(param0_this, param1_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Connection, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Connection(ConnectionManager manager, Socket_IP socket)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_Connection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Connection) {
    printf("Connection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Connection *local_this = (Connection *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Connection) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Connection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Connection) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Connection*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConnectionReader
 */
/**
 * Python function wrapper for:
 * bool ConnectionReader::add_connection(Connection *connection)
 */
static PyObject *Dtool_ConnectionReader_add_connection_54(PyObject *self, PyObject *arg) {
  ConnectionReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionReader, (void **)&local_this, "ConnectionReader.add_connection")) {
    return nullptr;
  }
  // 1-bool ConnectionReader::add_connection(Connection *connection)
  Connection *arg_this = (Connection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Connection, 1, "ConnectionReader.add_connection", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).add_connection)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_connection(const ConnectionReader self, Connection connection)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_add_connection_54_comment =
  "C++ Interface:\n"
  "add_connection(const ConnectionReader self, Connection connection)\n"
  "\n"
  "/**\n"
  " * Adds a new socket to the list of sockets the ConnectionReader will monitor.\n"
  " * A datagram that comes in on any of the monitored sockets will be reported.\n"
  " * In the case of a ConnectionListener, this adds a new rendezvous socket; any\n"
  " * activity on any of the monitored sockets will cause a connection to be\n"
  " * accepted.\n"
  " *\n"
  " * The return value is true if the connection was added, false if it was\n"
  " * already there.\n"
  " *\n"
  " * add_connection() is thread-safe, and may be called at will by any thread.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_add_connection_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionReader::remove_connection(Connection *connection)
 */
static PyObject *Dtool_ConnectionReader_remove_connection_55(PyObject *self, PyObject *arg) {
  ConnectionReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionReader, (void **)&local_this, "ConnectionReader.remove_connection")) {
    return nullptr;
  }
  // 1-bool ConnectionReader::remove_connection(Connection *connection)
  Connection *arg_this = (Connection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Connection, 1, "ConnectionReader.remove_connection", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).remove_connection)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_connection(const ConnectionReader self, Connection connection)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_remove_connection_55_comment =
  "C++ Interface:\n"
  "remove_connection(const ConnectionReader self, Connection connection)\n"
  "\n"
  "/**\n"
  " * Removes a socket from the list of sockets being monitored.  Returns true if\n"
  " * the socket was correctly removed, false if it was not on the list in the\n"
  " * first place.\n"
  " *\n"
  " * remove_connection() is thread-safe, and may be called at will by any\n"
  " * thread.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_remove_connection_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionReader::is_connection_ok(Connection *connection)
 */
static PyObject *Dtool_ConnectionReader_is_connection_ok_56(PyObject *self, PyObject *arg) {
  ConnectionReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionReader, (void **)&local_this, "ConnectionReader.is_connection_ok")) {
    return nullptr;
  }
  // 1-bool ConnectionReader::is_connection_ok(Connection *connection)
  Connection *arg_this = (Connection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Connection, 1, "ConnectionReader.is_connection_ok", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).is_connection_ok)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_connection_ok(const ConnectionReader self, Connection connection)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_is_connection_ok_56_comment =
  "C++ Interface:\n"
  "is_connection_ok(const ConnectionReader self, Connection connection)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated connection has been added to the\n"
  " * ConnectionReader and is being monitored properly, false if it is not known,\n"
  " * or if there was some error condition detected on the connection.  (If there\n"
  " * was an error condition, normally the ConnectionManager would have been\n"
  " * informed and closed the connection.)\n"
  " */";
#else
static const char *Dtool_ConnectionReader_is_connection_ok_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConnectionReader::poll(void)
 */
static PyObject *Dtool_ConnectionReader_poll_57(PyObject *self, PyObject *) {
  ConnectionReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionReader, (void **)&local_this, "ConnectionReader.poll")) {
    return nullptr;
  }
  // 1-void ConnectionReader::poll(void)
  ((*local_this).poll)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_poll_57_comment =
  "C++ Interface:\n"
  "poll(const ConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Explicitly polls the available sockets to see if any of them have any\n"
  " * noise.  This function does nothing unless this is a polling-type\n"
  " * ConnectionReader, i.e.  it was created with zero threads (and is_polling()\n"
  " * will return true).\n"
  " *\n"
  " * It is not necessary to call this explicitly for a QueuedConnectionReader.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_poll_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConnectionManager *ConnectionReader::get_manager(void) const
 */
static PyObject *Dtool_ConnectionReader_get_manager_58(PyObject *self, PyObject *) {
  ConnectionReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionReader)) {
    return nullptr;
  }
  // 1-ConnectionManager *ConnectionReader::get_manager(void) const
  ConnectionManager *return_value = ((*(const ConnectionReader*)local_this).get_manager)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_get_manager_58_comment =
  "C++ Interface:\n"
  "get_manager(ConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the ConnectionManager object that serves this\n"
  " * ConnectionReader.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_get_manager_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ConnectionReader::is_polling(void) const
 */
static PyObject *Dtool_ConnectionReader_is_polling_59(PyObject *self, PyObject *) {
  ConnectionReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionReader)) {
    return nullptr;
  }
  // 1-inline bool ConnectionReader::is_polling(void) const
  bool return_value = ((*(const ConnectionReader*)local_this).is_polling)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_is_polling_59_comment =
  "C++ Interface:\n"
  "is_polling(ConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Returns true if the reader is a polling reader, i.e.  it has no threads.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_is_polling_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int ConnectionReader::get_num_threads(void) const
 */
static PyObject *Dtool_ConnectionReader_get_num_threads_60(PyObject *self, PyObject *) {
  ConnectionReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionReader)) {
    return nullptr;
  }
  // 1-int ConnectionReader::get_num_threads(void) const
  int return_value = ((*(const ConnectionReader*)local_this).get_num_threads)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_get_num_threads_60_comment =
  "C++ Interface:\n"
  "get_num_threads(ConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Returns the number of threads the ConnectionReader has been created with.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_get_num_threads_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConnectionReader::set_raw_mode(bool mode)
 */
static PyObject *Dtool_ConnectionReader_set_raw_mode_61(PyObject *self, PyObject *arg) {
  ConnectionReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionReader, (void **)&local_this, "ConnectionReader.set_raw_mode")) {
    return nullptr;
  }
  // 1-void ConnectionReader::set_raw_mode(bool mode)
  ((*local_this).set_raw_mode)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_raw_mode(const ConnectionReader self, bool mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_set_raw_mode_61_comment =
  "C++ Interface:\n"
  "set_raw_mode(const ConnectionReader self, bool mode)\n"
  "\n"
  "/**\n"
  " * Sets the ConnectionReader into raw mode (or turns off raw mode).  In raw\n"
  " * mode, datagram headers are not expected; instead, all the data available on\n"
  " * the pipe is treated as a single datagram.\n"
  " *\n"
  " * This is similar to set_tcp_header_size(0), except that it also turns off\n"
  " * headers for UDP packets.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_set_raw_mode_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionReader::get_raw_mode(void) const
 */
static PyObject *Dtool_ConnectionReader_get_raw_mode_62(PyObject *self, PyObject *) {
  ConnectionReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionReader)) {
    return nullptr;
  }
  // 1-bool ConnectionReader::get_raw_mode(void) const
  bool return_value = ((*(const ConnectionReader*)local_this).get_raw_mode)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_get_raw_mode_62_comment =
  "C++ Interface:\n"
  "get_raw_mode(ConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the raw mode flag.  See set_raw_mode().\n"
  " */";
#else
static const char *Dtool_ConnectionReader_get_raw_mode_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConnectionReader::set_tcp_header_size(int tcp_header_size)
 */
static PyObject *Dtool_ConnectionReader_set_tcp_header_size_63(PyObject *self, PyObject *arg) {
  ConnectionReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionReader, (void **)&local_this, "ConnectionReader.set_tcp_header_size")) {
    return nullptr;
  }
  // 1-void ConnectionReader::set_tcp_header_size(int tcp_header_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_tcp_header_size)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tcp_header_size(const ConnectionReader self, int tcp_header_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_set_tcp_header_size_63_comment =
  "C++ Interface:\n"
  "set_tcp_header_size(const ConnectionReader self, int tcp_header_size)\n"
  "\n"
  "/**\n"
  " * Sets the header size of TCP packets.  At the present, legal values for this\n"
  " * are 0, 2, or 4; this specifies the number of bytes to use encode the\n"
  " * datagram length at the start of each TCP datagram.  Sender and receiver\n"
  " * must independently agree on this.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_set_tcp_header_size_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int ConnectionReader::get_tcp_header_size(void) const
 */
static PyObject *Dtool_ConnectionReader_get_tcp_header_size_64(PyObject *self, PyObject *) {
  ConnectionReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionReader)) {
    return nullptr;
  }
  // 1-int ConnectionReader::get_tcp_header_size(void) const
  int return_value = ((*(const ConnectionReader*)local_this).get_tcp_header_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_get_tcp_header_size_64_comment =
  "C++ Interface:\n"
  "get_tcp_header_size(ConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of TCP header size.  See set_tcp_header_size().\n"
  " */";
#else
static const char *Dtool_ConnectionReader_get_tcp_header_size_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConnectionReader::shutdown(void)
 */
static PyObject *Dtool_ConnectionReader_shutdown_65(PyObject *self, PyObject *) {
  ConnectionReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionReader, (void **)&local_this, "ConnectionReader.shutdown")) {
    return nullptr;
  }
  // 1-void ConnectionReader::shutdown(void)
  ((*local_this).shutdown)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConnectionReader_shutdown_65_comment =
  "C++ Interface:\n"
  "shutdown(const ConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Terminates all threads cleanly.  Normally this is only called by the\n"
  " * destructor, but it may be called explicitly before destruction.\n"
  " */";
#else
static const char *Dtool_ConnectionReader_shutdown_65_comment = nullptr;
#endif

static int Dtool_Init_ConnectionReader(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ConnectionReader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConnectionReader) {
    printf("ConnectionReader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConnectionReader *local_this = (ConnectionReader *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConnectionReader) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConnectionReader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConnectionReader) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConnectionListener
 */
static int Dtool_Init_ConnectionListener(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ConnectionListener(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConnectionListener) {
    printf("ConnectionListener ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConnectionListener *local_this = (ConnectionListener *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConnectionListener) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConnectionReader) {
    return (ConnectionReader *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConnectionListener(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConnectionListener) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConnectionReader) {
    ConnectionReader* other_this = (ConnectionReader*)from_this;
    return (ConnectionListener*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NetDatagram
 */
/**
 * Python function wrapper for:
 * void NetDatagram::operator =(Datagram const &copy)
 * void NetDatagram::operator =(NetDatagram const &copy)
 */
static PyObject *Dtool_NetDatagram_operator_71(PyObject *self, PyObject *arg) {
  NetDatagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetDatagram, (void **)&local_this, "NetDatagram.assign")) {
    return nullptr;
  }
  {
    // -2 void NetDatagram::operator =(NetDatagram const &copy)
    NetDatagram const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NetDatagram);
    if (arg_this != nullptr) {
      ((*local_this).operator =)(*arg_this);
      NetDatagram *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_NetDatagram, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 void NetDatagram::operator =(Datagram const &copy)
    Datagram const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Datagram);
    if (arg_this != nullptr) {
      ((*local_this).operator =)(*arg_this);
      NetDatagram *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_NetDatagram, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 void NetDatagram::operator =(NetDatagram const &copy)
    NetDatagram arg_local;
    NetDatagram const *arg_this = Dtool_Coerce_NetDatagram(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).operator =)(*arg_this);
      NetDatagram *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_NetDatagram, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  {
    // -2 void NetDatagram::operator =(Datagram const &copy)
    Datagram arg_local;
    Datagram const *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).operator =)(*arg_this);
      NetDatagram *return_value = local_this;
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_NetDatagram, false, false, return_value->as_typed_object()->get_type_index());
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const NetDatagram self, const NetDatagram copy)\n"
      "assign(const NetDatagram self, const Datagram copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetDatagram_operator_71_comment =
  "C++ Interface:\n"
  "assign(const NetDatagram self, const NetDatagram copy)\n"
  "assign(const NetDatagram self, const Datagram copy)\n";
#else
static const char *Dtool_NetDatagram_operator_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NetDatagram::set_connection(PointerTo< Connection > const &connection)
 */
static PyObject *Dtool_NetDatagram_set_connection_72(PyObject *self, PyObject *arg) {
  NetDatagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetDatagram, (void **)&local_this, "NetDatagram.set_connection")) {
    return nullptr;
  }
  // 1-void NetDatagram::set_connection(PointerTo< Connection > const &connection)
  Connection *arg_this = (Connection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Connection, 1, "NetDatagram.set_connection", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_connection)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_connection(const NetDatagram self, const Connection connection)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetDatagram_set_connection_72_comment =
  "C++ Interface:\n"
  "set_connection(const NetDatagram self, const Connection connection)\n"
  "\n"
  "/**\n"
  " * Specifies the socket to which the datagram should be written.\n"
  " */";
#else
static const char *Dtool_NetDatagram_set_connection_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< Connection > NetDatagram::get_connection(void) const
 */
static PyObject *Dtool_NetDatagram_get_connection_73(PyObject *self, PyObject *) {
  NetDatagram *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NetDatagram)) {
    return nullptr;
  }
  // 1-PointerTo< Connection > NetDatagram::get_connection(void) const
  PointerTo< Connection > return_value = ((*(const NetDatagram*)local_this).get_connection)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  Connection *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NetDatagram_get_connection_73_comment =
  "C++ Interface:\n"
  "get_connection(NetDatagram self)\n"
  "\n"
  "/**\n"
  " * Retrieves the socket from which the datagram was read, or to which it is\n"
  " * scheduled to be written.\n"
  " */";
#else
static const char *Dtool_NetDatagram_get_connection_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void NetDatagram::set_address(NetAddress const &address)
 */
static PyObject *Dtool_NetDatagram_set_address_74(PyObject *self, PyObject *arg) {
  NetDatagram *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_NetDatagram, (void **)&local_this, "NetDatagram.set_address")) {
    return nullptr;
  }
  // 1-void NetDatagram::set_address(NetAddress const &address)
  NetAddress arg_local;
  NetAddress const *arg_this = Dtool_Coerce_NetAddress(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "NetDatagram.set_address", "NetAddress");
  }
  ((*local_this).set_address)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_address(const NetDatagram self, const NetAddress address)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_NetDatagram_set_address_74_comment =
  "C++ Interface:\n"
  "set_address(const NetDatagram self, const NetAddress address)\n"
  "\n"
  "/**\n"
  " * Specifies the host to which the datagram should be sent.\n"
  " */";
#else
static const char *Dtool_NetDatagram_set_address_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NetAddress const &NetDatagram::get_address(void) const
 */
static PyObject *Dtool_NetDatagram_get_address_75(PyObject *self, PyObject *) {
  NetDatagram *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NetDatagram)) {
    return nullptr;
  }
  // 1-NetAddress const &NetDatagram::get_address(void) const
  NetAddress const *return_value = &(((*(const NetDatagram*)local_this).get_address)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NetAddress, false, true);
}

#ifndef NDEBUG
static const char *Dtool_NetDatagram_get_address_75_comment =
  "C++ Interface:\n"
  "get_address(NetDatagram self)\n"
  "\n"
  "/**\n"
  " * Retrieves the host from which the datagram was read, or to which it is\n"
  " * scheduled to be sent.\n"
  " */";
#else
static const char *Dtool_NetDatagram_get_address_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle NetDatagram::get_class_type(void)
 */
static PyObject *Dtool_NetDatagram_get_class_type_76(PyObject *, PyObject *) {
  // 1-static TypeHandle NetDatagram::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((NetDatagram::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NetDatagram_get_class_type_76_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_NetDatagram_get_class_type_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NetDatagram::NetDatagram(void)
 * NetDatagram::NetDatagram(Datagram const &copy)
 * NetDatagram::NetDatagram(NetDatagram const &copy)
 */
static int Dtool_Init_NetDatagram(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-NetDatagram::NetDatagram(void)
      NetDatagram *return_value = new NetDatagram();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetDatagram, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        {
          // -2 NetDatagram::NetDatagram(NetDatagram const &copy)
          NetDatagram const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_NetDatagram);
          if (arg_this != nullptr) {
            NetDatagram *return_value = new NetDatagram(*arg_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetDatagram, true, false);
          }
        }

        {
          // -2 NetDatagram::NetDatagram(Datagram const &copy)
          Datagram const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Datagram);
          if (arg_this != nullptr) {
            NetDatagram *return_value = new NetDatagram(*arg_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetDatagram, true, false);
          }
        }

        {
          // -2 NetDatagram::NetDatagram(NetDatagram const &copy)
          NetDatagram arg_local;
          NetDatagram const *arg_this = Dtool_Coerce_NetDatagram(arg, arg_local);
          if ((arg_this != nullptr)) {
            NetDatagram *return_value = new NetDatagram(*arg_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetDatagram, true, false);
          }
        }

        {
          // -2 NetDatagram::NetDatagram(Datagram const &copy)
          Datagram arg_local;
          Datagram const *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
          if ((arg_this != nullptr)) {
            NetDatagram *return_value = new NetDatagram(*arg_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_NetDatagram, true, false);
          }
        }

      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "NetDatagram() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "NetDatagram()\n"
      "NetDatagram(const NetDatagram copy)\n"
      "NetDatagram(const Datagram copy)\n");
  }
  return -1;
}

NetDatagram *Dtool_Coerce_NetDatagram(PyObject *args, NetDatagram &coerced) {
  NetDatagram *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_NetDatagram)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const NetDatagram *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-NetDatagram::NetDatagram(Datagram const &copy)
    Datagram const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Datagram);
    if (arg_this != nullptr) {
      coerced = NetDatagram(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_NetDatagram(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NetDatagram) {
    printf("NetDatagram ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NetDatagram *local_this = (NetDatagram *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NetDatagram) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Datagram) {
    return (Datagram *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(Datagram *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NetDatagram(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NetDatagram) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Datagram) {
    Datagram* other_this = (Datagram*)from_this;
    return (NetDatagram*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (NetDatagram*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConnectionManager
 */
/**
 * Python function wrapper for:
 * PointerTo< Connection > ConnectionManager::open_UDP_connection(std::string const &hostname, uint16_t port, bool for_broadcast = false)
 * PointerTo< Connection > ConnectionManager::open_UDP_connection(uint16_t port = 0)
 */
static PyObject *Dtool_ConnectionManager_open_UDP_connection_81(PyObject *self, PyObject *args, PyObject *kwds) {
  ConnectionManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.open_UDP_connection")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PointerTo< Connection > ConnectionManager::open_UDP_connection(uint16_t port)
      PointerTo< Connection > return_value = ((*local_this).open_UDP_connection)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      Connection *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "port")) {
        // 1-PointerTo< Connection > ConnectionManager::open_UDP_connection(uint16_t port)
        if (PyLongOrInt_Check(arg)) {
          long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
          if (param1 < 0 || param1 > USHRT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for unsigned short integer",
                                param1);
          }
#endif
          PointerTo< Connection > return_value = ((*local_this).open_UDP_connection)((uint16_t)param1);
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          Connection *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
        }
      }
    }
    break;
  case 2:
  case 3:
    {
      // 1-PointerTo< Connection > ConnectionManager::open_UDP_connection(std::string const &hostname, uint16_t port, bool for_broadcast = false)
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      long param2;
      PyObject *param3 = Py_False;
      static const char *keyword_list[] = {"hostname", "port", "for_broadcast", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#l|O:open_UDP_connection", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param2);
        }
#endif
        PointerTo< Connection > return_value = ((*local_this).open_UDP_connection)(std::string(param1_str, param1_len), (uint16_t)param2, (PyObject_IsTrue(param3) != 0));
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        Connection *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "open_UDP_connection() takes 1, 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_UDP_connection(const ConnectionManager self)\n"
      "open_UDP_connection(const ConnectionManager self, int port)\n"
      "open_UDP_connection(const ConnectionManager self, str hostname, int port, bool for_broadcast)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_open_UDP_connection_81_comment =
  "C++ Interface:\n"
  "open_UDP_connection(const ConnectionManager self)\n"
  "open_UDP_connection(const ConnectionManager self, int port)\n"
  "open_UDP_connection(const ConnectionManager self, str hostname, int port, bool for_broadcast)\n"
  "\n"
  "/**\n"
  " * Opens a socket for sending and/or receiving UDP packets.  If the port\n"
  " * number is greater than zero, the UDP connection will be opened for\n"
  " * listening on the indicated port; otherwise, it will be useful only for\n"
  " * sending.\n"
  " *\n"
  " * Use a ConnectionReader and ConnectionWriter to handle the actual\n"
  " * communication.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Opens a socket for sending and/or receiving UDP packets.  If the port\n"
  " * number is greater than zero, the UDP connection will be opened for\n"
  " * listening on the indicated port; otherwise, it will be useful only for\n"
  " * sending.\n"
  " *\n"
  " * This variant accepts both a hostname and port to listen on a particular\n"
  " * interface; if the hostname is empty, all interfaces will be available,\n"
  " * both IPv4 and IPv6.\n"
  " *\n"
  " * If for_broadcast is true, this UDP connection will be configured to send\n"
  " * and/or receive messages on the broadcast address (255.255.255.255);\n"
  " * otherwise, these messages may be automatically filtered by the OS.\n"
  " *\n"
  " * Use a ConnectionReader and ConnectionWriter to handle the actual\n"
  " * communication.\n"
  " */";
#else
static const char *Dtool_ConnectionManager_open_UDP_connection_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(NetAddress const &address, int backlog)
 * PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(std::string const &hostname, uint16_t port, int backlog)
 * PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(uint16_t port, int backlog)
 */
static PyObject *Dtool_ConnectionManager_open_TCP_server_rendezvous_82(PyObject *self, PyObject *args, PyObject *kwds) {
  ConnectionManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.open_TCP_server_rendezvous")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      {
        // -2 PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(NetAddress const &address, int backlog)
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"address", "backlog", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:open_TCP_server_rendezvous", (char **)keyword_list, &param1, &param2)) {
          NetAddress const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_NetAddress);
          if (param1_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            PointerTo< Connection > return_value = ((*local_this).open_TCP_server_rendezvous)(*param1_this, (int)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            Connection *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(uint16_t port, int backlog)
        long param1;
        int param2;
        static const char *keyword_list[] = {"port", "backlog", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "li:open_TCP_server_rendezvous", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
          if (param1 < 0 || param1 > USHRT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for unsigned short integer",
                                param1);
          }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          PointerTo< Connection > return_value = ((*local_this).open_TCP_server_rendezvous)((uint16_t)param1, (int)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          Connection *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(NetAddress const &address, int backlog)
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"address", "backlog", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:open_TCP_server_rendezvous", (char **)keyword_list, &param1, &param2)) {
          NetAddress param1_local;
          NetAddress const *param1_this = Dtool_Coerce_NetAddress(param1, param1_local);
          if ((param1_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            PointerTo< Connection > return_value = ((*local_this).open_TCP_server_rendezvous)(*param1_this, (int)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            if (Dtool_CheckErrorOccurred()) {
              return nullptr;
            }
            // Transfer ownership of return_value.
            Connection *return_ptr = return_value.p();
            return_value.cheat() = nullptr;
            return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(uint16_t port, int backlog)
    }
    break;
  case 3:
    {
      // 1-PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(std::string const &hostname, uint16_t port, int backlog)
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      long param2;
      int param3;
      static const char *keyword_list[] = {"hostname", "port", "backlog", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#li:open_TCP_server_rendezvous", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param2);
        }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        PointerTo< Connection > return_value = ((*local_this).open_TCP_server_rendezvous)(std::string(param1_str, param1_len), (uint16_t)param2, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        Connection *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "open_TCP_server_rendezvous() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_TCP_server_rendezvous(const ConnectionManager self, const NetAddress address, int backlog)\n"
      "open_TCP_server_rendezvous(const ConnectionManager self, int port, int backlog)\n"
      "open_TCP_server_rendezvous(const ConnectionManager self, str hostname, int port, int backlog)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_open_TCP_server_rendezvous_82_comment =
  "C++ Interface:\n"
  "open_TCP_server_rendezvous(const ConnectionManager self, const NetAddress address, int backlog)\n"
  "open_TCP_server_rendezvous(const ConnectionManager self, int port, int backlog)\n"
  "open_TCP_server_rendezvous(const ConnectionManager self, str hostname, int port, int backlog)\n"
  "\n"
  "/**\n"
  " * Creates a socket to be used as a rendezvous socket for a server to listen\n"
  " * for TCP connections.  The socket returned by this call should only be added\n"
  " * to a ConnectionListener (not to a generic ConnectionReader).\n"
  " *\n"
  " * This variant of this method accepts a single port, and will listen to that\n"
  " * port on all available interfaces, both IPv4 and IPv6.\n"
  " *\n"
  " * backlog is the maximum length of the queue of pending connections.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Creates a socket to be used as a rendezvous socket for a server to listen\n"
  " * for TCP connections.  The socket returned by this call should only be added\n"
  " * to a ConnectionListener (not to a generic ConnectionReader).\n"
  " *\n"
  " * This variant of this method accepts a \"hostname\", which is usually just an\n"
  " * IP address in dotted notation, and a port number.  It will listen on the\n"
  " * interface indicated by the IP address.  If the IP address is empty string,\n"
  " * it will listen on all interfaces.\n"
  " *\n"
  " * backlog is the maximum length of the queue of pending connections.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Creates a socket to be used as a rendezvous socket for a server to listen\n"
  " * for TCP connections.  The socket returned by this call should only be added\n"
  " * to a ConnectionListener (not to a generic ConnectionReader).\n"
  " *\n"
  " * This variant of this method accepts a NetAddress, which allows you to\n"
  " * specify a specific interface to listen to.\n"
  " *\n"
  " * backlog is the maximum length of the queue of pending connections.\n"
  " */";
#else
static const char *Dtool_ConnectionManager_open_TCP_server_rendezvous_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< Connection > ConnectionManager::open_TCP_client_connection(NetAddress const &address, int timeout_ms)
 * PointerTo< Connection > ConnectionManager::open_TCP_client_connection(std::string const &hostname, uint16_t port, int timeout_ms)
 */
static PyObject *Dtool_ConnectionManager_open_TCP_client_connection_83(PyObject *self, PyObject *args, PyObject *kwds) {
  ConnectionManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.open_TCP_client_connection")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-PointerTo< Connection > ConnectionManager::open_TCP_client_connection(NetAddress const &address, int timeout_ms)
      PyObject *param1;
      int param2;
      static const char *keyword_list[] = {"address", "timeout_ms", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:open_TCP_client_connection", (char **)keyword_list, &param1, &param2)) {
        NetAddress param1_local;
        NetAddress const *param1_this = Dtool_Coerce_NetAddress(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "ConnectionManager.open_TCP_client_connection", "NetAddress");
        }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        PointerTo< Connection > return_value = ((*local_this).open_TCP_client_connection)(*param1_this, (int)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        Connection *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-PointerTo< Connection > ConnectionManager::open_TCP_client_connection(std::string const &hostname, uint16_t port, int timeout_ms)
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      long param2;
      int param3;
      static const char *keyword_list[] = {"hostname", "port", "timeout_ms", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#li:open_TCP_client_connection", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          return PyErr_Format(PyExc_OverflowError,
                              "value %ld out of range for unsigned short integer",
                              param2);
        }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        PointerTo< Connection > return_value = ((*local_this).open_TCP_client_connection)(std::string(param1_str, param1_len), (uint16_t)param2, (int)param3);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
        Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        // Transfer ownership of return_value.
        Connection *return_ptr = return_value.p();
        return_value.cheat() = nullptr;
        return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_Connection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "open_TCP_client_connection() takes 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open_TCP_client_connection(const ConnectionManager self, const NetAddress address, int timeout_ms)\n"
      "open_TCP_client_connection(const ConnectionManager self, str hostname, int port, int timeout_ms)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_open_TCP_client_connection_83_comment =
  "C++ Interface:\n"
  "open_TCP_client_connection(const ConnectionManager self, const NetAddress address, int timeout_ms)\n"
  "open_TCP_client_connection(const ConnectionManager self, str hostname, int port, int timeout_ms)\n"
  "\n"
  "/**\n"
  " * Attempts to establish a TCP client connection to a server at the indicated\n"
  " * address.  If the connection is not established within timeout_ms\n"
  " * milliseconds, a null connection is returned.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This is a shorthand version of the function to directly establish\n"
  " * communications to a named host and port.\n"
  " */";
#else
static const char *Dtool_ConnectionManager_open_TCP_client_connection_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionManager::close_connection(PointerTo< Connection > const &connection)
 */
static PyObject *Dtool_ConnectionManager_close_connection_84(PyObject *self, PyObject *arg) {
  ConnectionManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.close_connection")) {
    return nullptr;
  }
  // 1-bool ConnectionManager::close_connection(PointerTo< Connection > const &connection)
  Connection *arg_this = (Connection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Connection, 1, "ConnectionManager.close_connection", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).close_connection)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "close_connection(const ConnectionManager self, const Connection connection)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_close_connection_84_comment =
  "C++ Interface:\n"
  "close_connection(const ConnectionManager self, const Connection connection)\n"
  "\n"
  "/**\n"
  " * Terminates a UDP or TCP socket previously opened.  This also removes it\n"
  " * from any associated ConnectionReader or ConnectionListeners.\n"
  " *\n"
  " * The socket itself may not be immediately closed--it will not be closed\n"
  " * until all outstanding pointers to it are cleared, including any pointers\n"
  " * remaining in NetDatagrams recently received from the socket.\n"
  " *\n"
  " * The return value is true if the connection was marked to be closed, or\n"
  " * false if close_connection() had already been called (or the connection did\n"
  " * not belong to this ConnectionManager).  In neither case can you infer\n"
  " * anything about whether the connection has *actually* been closed yet based\n"
  " * on the return value.\n"
  " */";
#else
static const char *Dtool_ConnectionManager_close_connection_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionManager::wait_for_readers(double timeout)
 */
static PyObject *Dtool_ConnectionManager_wait_for_readers_85(PyObject *self, PyObject *arg) {
  ConnectionManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.wait_for_readers")) {
    return nullptr;
  }
  // 1-bool ConnectionManager::wait_for_readers(double timeout)
  if (PyNumber_Check(arg)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    bool return_value = ((*local_this).wait_for_readers)(PyFloat_AsDouble(arg));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "wait_for_readers(const ConnectionManager self, double timeout)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_wait_for_readers_85_comment =
  "C++ Interface:\n"
  "wait_for_readers(const ConnectionManager self, double timeout)\n"
  "\n"
  "/**\n"
  " * Blocks the process for timeout number of seconds, or until any data is\n"
  " * available on any of the non-threaded ConnectionReaders or\n"
  " * ConnectionListeners, whichever comes first.  The return value is true if\n"
  " * there is data available (but you have to iterate through all readers to\n"
  " * find it), or false if the timeout occurred without any data.\n"
  " *\n"
  " * If the timeout value is negative, this will block forever or until data is\n"
  " * available.\n"
  " *\n"
  " * This only works if all ConnectionReaders and ConnectionListeners are non-\n"
  " * threaded.  If any threaded ConnectionReaders are part of the\n"
  " * ConnectionManager, the timeout value is implicitly treated as 0.\n"
  " */";
#else
static const char *Dtool_ConnectionManager_wait_for_readers_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static std::string ConnectionManager::get_host_name(void)
 */
static PyObject *Dtool_ConnectionManager_get_host_name_86(PyObject *, PyObject *) {
  // 1-static std::string ConnectionManager::get_host_name(void)
  std::string return_value = (ConnectionManager::get_host_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_get_host_name_86_comment =
  "C++ Interface:\n"
  "get_host_name()\n"
  "\n"
  "/**\n"
  " * Returns the name of this particular machine on the network, if available,\n"
  " * or the empty string if the hostname cannot be determined.\n"
  " */";
#else
static const char *Dtool_ConnectionManager_get_host_name_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConnectionManager::scan_interfaces(void)
 */
static PyObject *Dtool_ConnectionManager_scan_interfaces_101(PyObject *self, PyObject *) {
  ConnectionManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.scan_interfaces")) {
    return nullptr;
  }
  // 1-void ConnectionManager::scan_interfaces(void)
  ((*local_this).scan_interfaces)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_scan_interfaces_101_comment =
  "C++ Interface:\n"
  "scan_interfaces(const ConnectionManager self)\n"
  "\n"
  "/**\n"
  " * Repopulates the list reported by get_num_interface()/get_interface().  It\n"
  " * is not necessary to call this explicitly, unless you want to re-determine\n"
  " * the connected interfaces (for instance, if you suspect the hardware has\n"
  " * recently changed).\n"
  " */";
#else
static const char *Dtool_ConnectionManager_scan_interfaces_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::size_t ConnectionManager::get_num_interfaces(void)
 */
static PyObject *Dtool_ConnectionManager_get_num_interfaces_102(PyObject *self, PyObject *) {
  ConnectionManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.get_num_interfaces")) {
    return nullptr;
  }
  // 1-std::size_t ConnectionManager::get_num_interfaces(void)
  std::size_t return_value = ((*local_this).get_num_interfaces)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_get_num_interfaces_102_comment =
  "C++ Interface:\n"
  "get_num_interfaces(const ConnectionManager self)\n"
  "\n"
  "/**\n"
  " * This returns the number of usable network interfaces detected on this\n"
  " * machine.  See scan_interfaces() to repopulate this list.\n"
  " */";
#else
static const char *Dtool_ConnectionManager_get_num_interfaces_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConnectionManager::Interface const &ConnectionManager::get_interface(std::size_t n)
 */
static PyObject *Dtool_ConnectionManager_get_interface_103(PyObject *self, PyObject *arg) {
  ConnectionManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionManager, (void **)&local_this, "ConnectionManager.get_interface")) {
    return nullptr;
  }
  // 1-ConnectionManager::Interface const &ConnectionManager::get_interface(std::size_t n)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ConnectionManager::Interface const *return_value = &(((*local_this).get_interface)(arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionManager_Interface, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_interface(const ConnectionManager self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_get_interface_103_comment =
  "C++ Interface:\n"
  "get_interface(const ConnectionManager self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth usable network interface detected on this machine.\n"
  " * See scan_interfaces() to repopulate this list.\n"
  " */";
#else
static const char *Dtool_ConnectionManager_get_interface_103_comment = nullptr;
#endif

static PyObject *Dtool_ConnectionManager_host_name_Getter(PyObject *self, void *) {
  // 1-static std::string ConnectionManager::get_host_name(void)
  std::string return_value = (ConnectionManager::get_host_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * sequence length function for property ConnectionManager::interfaces
 */
static Py_ssize_t Dtool_ConnectionManager_interfaces_Len(PyObject *self) {
  ConnectionManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_interfaces)();
}

/**
 * sequence getter for property ConnectionManager::interfaces
 */
static PyObject *Dtool_ConnectionManager_interfaces_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  ConnectionManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_interfaces)()) {
    PyErr_SetString(PyExc_IndexError, "ConnectionManager.interfaces[] index out of range");
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // 1-ConnectionManager::Interface const &ConnectionManager::get_interface(std::size_t n)
    ConnectionManager::Interface const *return_value = &(((*local_this).get_interface)(index));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionManager_Interface, false, true);
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call ConnectionManager.get_interface() on a const object.");
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_interface(const ConnectionManager self, index)\n");
  }
}

static PyObject *Dtool_ConnectionManager_interfaces_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "ConnectionManager.interfaces");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_ConnectionManager_interfaces_Len;
    wrap->_getitem_func = &Dtool_ConnectionManager_interfaces_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * ConnectionManager::ConnectionManager(void)
 */
static int Dtool_Init_ConnectionManager(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("ConnectionManager() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConnectionManager() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-ConnectionManager::ConnectionManager(void)
  ConnectionManager *return_value = new ConnectionManager();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConnectionManager, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConnectionManager()\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ConnectionManager_get_interfaces(PyObject *self, PyObject *) {
  ConnectionManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_interfaces)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ConnectionManager_get_interface_103(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ConnectionManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConnectionManager) {
    printf("ConnectionManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConnectionManager *local_this = (ConnectionManager *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConnectionManager) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConnectionManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConnectionManager) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConnectionManager::Interface
 */
/**
 * Python function wrapper for:
 * std::string const &ConnectionManager::Interface::get_name(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_get_name_88(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionManager_Interface)) {
    return nullptr;
  }
  // 1-std::string const &ConnectionManager::Interface::get_name(void) const
  std::string const &return_value = ((*(const ConnectionManager::Interface*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_get_name_88_comment =
  "C++ Interface:\n"
  "get_name(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_get_name_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string const &ConnectionManager::Interface::get_mac_address(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_get_mac_address_89(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionManager_Interface)) {
    return nullptr;
  }
  // 1-std::string const &ConnectionManager::Interface::get_mac_address(void) const
  std::string const &return_value = ((*(const ConnectionManager::Interface*)local_this).get_mac_address)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_get_mac_address_89_comment =
  "C++ Interface:\n"
  "get_mac_address(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_get_mac_address_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionManager::Interface::has_ip(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_has_ip_90(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionManager_Interface)) {
    return nullptr;
  }
  // 1-bool ConnectionManager::Interface::has_ip(void) const
  bool return_value = ((*(const ConnectionManager::Interface*)local_this).has_ip)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_has_ip_90_comment =
  "C++ Interface:\n"
  "has_ip(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_has_ip_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NetAddress const &ConnectionManager::Interface::get_ip(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_get_ip_91(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionManager_Interface)) {
    return nullptr;
  }
  // 1-NetAddress const &ConnectionManager::Interface::get_ip(void) const
  NetAddress const *return_value = &(((*(const ConnectionManager::Interface*)local_this).get_ip)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NetAddress, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_get_ip_91_comment =
  "C++ Interface:\n"
  "get_ip(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_get_ip_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionManager::Interface::has_netmask(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_has_netmask_92(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionManager_Interface)) {
    return nullptr;
  }
  // 1-bool ConnectionManager::Interface::has_netmask(void) const
  bool return_value = ((*(const ConnectionManager::Interface*)local_this).has_netmask)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_has_netmask_92_comment =
  "C++ Interface:\n"
  "has_netmask(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_has_netmask_92_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NetAddress const &ConnectionManager::Interface::get_netmask(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_get_netmask_93(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionManager_Interface)) {
    return nullptr;
  }
  // 1-NetAddress const &ConnectionManager::Interface::get_netmask(void) const
  NetAddress const *return_value = &(((*(const ConnectionManager::Interface*)local_this).get_netmask)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NetAddress, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_get_netmask_93_comment =
  "C++ Interface:\n"
  "get_netmask(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_get_netmask_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionManager::Interface::has_broadcast(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_has_broadcast_94(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionManager_Interface)) {
    return nullptr;
  }
  // 1-bool ConnectionManager::Interface::has_broadcast(void) const
  bool return_value = ((*(const ConnectionManager::Interface*)local_this).has_broadcast)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_has_broadcast_94_comment =
  "C++ Interface:\n"
  "has_broadcast(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_has_broadcast_94_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NetAddress const &ConnectionManager::Interface::get_broadcast(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_get_broadcast_95(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionManager_Interface)) {
    return nullptr;
  }
  // 1-NetAddress const &ConnectionManager::Interface::get_broadcast(void) const
  NetAddress const *return_value = &(((*(const ConnectionManager::Interface*)local_this).get_broadcast)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NetAddress, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_get_broadcast_95_comment =
  "C++ Interface:\n"
  "get_broadcast(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_get_broadcast_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionManager::Interface::has_p2p(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_has_p2p_96(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionManager_Interface)) {
    return nullptr;
  }
  // 1-bool ConnectionManager::Interface::has_p2p(void) const
  bool return_value = ((*(const ConnectionManager::Interface*)local_this).has_p2p)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_has_p2p_96_comment =
  "C++ Interface:\n"
  "has_p2p(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_has_p2p_96_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * NetAddress const &ConnectionManager::Interface::get_p2p(void) const
 */
static PyObject *Dtool_ConnectionManager_Interface_get_p2p_97(PyObject *self, PyObject *) {
  ConnectionManager::Interface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionManager_Interface)) {
    return nullptr;
  }
  // 1-NetAddress const &ConnectionManager::Interface::get_p2p(void) const
  NetAddress const *return_value = &(((*(const ConnectionManager::Interface*)local_this).get_p2p)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NetAddress, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_get_p2p_97_comment =
  "C++ Interface:\n"
  "get_p2p(Interface self)\n";
#else
static const char *Dtool_ConnectionManager_Interface_get_p2p_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConnectionManager::Interface::output(std::ostream &out) const
 */
static PyObject *Dtool_ConnectionManager_Interface_output_98(PyObject *self, PyObject *arg) {
  ConnectionManager::Interface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionManager_Interface)) {
    return nullptr;
  }
  // 1-void ConnectionManager::Interface::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "Interface.output", false, true);
  if (arg_this != nullptr) {
    ((*(const ConnectionManager::Interface*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Interface self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionManager_Interface_output_98_comment =
  "C++ Interface:\n"
  "output(Interface self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ConnectionManager_Interface_output_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConnectionManager::Interface::Interface(ConnectionManager::Interface const &) = default
 */
static int Dtool_Init_ConnectionManager_Interface(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("Interface() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline ConnectionManager::Interface::Interface(ConnectionManager::Interface const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    ConnectionManager::Interface const *param0_this = (ConnectionManager::Interface *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager_Interface, 0, "Interface.Interface", true, true);
    if (param0_this != nullptr) {
      ConnectionManager::Interface *return_value = new ConnectionManager::Interface(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConnectionManager_Interface, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Interface(const Interface param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ConnectionManager_Interface(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConnectionManager_Interface) {
    printf("ConnectionManager_Interface ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConnectionManager::Interface *local_this = (ConnectionManager::Interface *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConnectionManager_Interface) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConnectionManager_Interface(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConnectionManager_Interface) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ConnectionWriter
 */
/**
 * Python function wrapper for:
 * void ConnectionWriter::set_max_queue_size(int max_size)
 */
static PyObject *Dtool_ConnectionWriter_set_max_queue_size_113(PyObject *self, PyObject *arg) {
  ConnectionWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionWriter, (void **)&local_this, "ConnectionWriter.set_max_queue_size")) {
    return nullptr;
  }
  // 1-void ConnectionWriter::set_max_queue_size(int max_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_max_queue_size)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_queue_size(const ConnectionWriter self, int max_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_set_max_queue_size_113_comment =
  "C++ Interface:\n"
  "set_max_queue_size(const ConnectionWriter self, int max_size)\n"
  "\n"
  "/**\n"
  " * Limits the number of packets that may be pending on the outbound queue.\n"
  " * This only has an effect when using threads; if num_threads is 0, then all\n"
  " * packets are sent immediately.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_set_max_queue_size_113_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int ConnectionWriter::get_max_queue_size(void) const
 */
static PyObject *Dtool_ConnectionWriter_get_max_queue_size_114(PyObject *self, PyObject *) {
  ConnectionWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionWriter)) {
    return nullptr;
  }
  // 1-int ConnectionWriter::get_max_queue_size(void) const
  int return_value = ((*(const ConnectionWriter*)local_this).get_max_queue_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_get_max_queue_size_114_comment =
  "C++ Interface:\n"
  "get_max_queue_size(ConnectionWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum size the queue is allowed to grow to.  See\n"
  " * set_max_queue_size().\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_get_max_queue_size_114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int ConnectionWriter::get_current_queue_size(void) const
 */
static PyObject *Dtool_ConnectionWriter_get_current_queue_size_115(PyObject *self, PyObject *) {
  ConnectionWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionWriter)) {
    return nullptr;
  }
  // 1-int ConnectionWriter::get_current_queue_size(void) const
  int return_value = ((*(const ConnectionWriter*)local_this).get_current_queue_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_get_current_queue_size_115_comment =
  "C++ Interface:\n"
  "get_current_queue_size(ConnectionWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the current number of things in the queue.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_get_current_queue_size_115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, NetAddress const &address, bool block = false)
 * bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, bool block = false)
 */
static PyObject *Dtool_ConnectionWriter_send_116(PyObject *self, PyObject *args, PyObject *kwds) {
  ConnectionWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionWriter, (void **)&local_this, "ConnectionWriter.send")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, bool block)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"datagram", "connection", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:send", (char **)keyword_list, &param1, &param2)) {
        Datagram param1_local;
        Datagram const *param1_this = Dtool_Coerce_Datagram(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "ConnectionWriter.send", "Datagram");
        }
        Connection *param2_this = (Connection *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Connection, 2, "ConnectionWriter.send", true, true);
        if (param2_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          bool return_value = ((*local_this).send)(*param1_this, param2_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
          Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
  case 3:
  case 4:
    {
      {
        // -2 bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, NetAddress const &address, bool block = false)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4 = Py_False;
        static const char *keyword_list[] = {"datagram", "connection", "address", "block", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|O:send", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          Datagram const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_Datagram);
          Connection *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_Connection);
          NetAddress const *param3_this = nullptr;
          DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_NetAddress);
          if (param1_this != nullptr && param2_this != nullptr && param3_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).send)(*param1_this, param2_this, *param3_this, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, bool block = false)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"datagram", "connection", "block", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:send", (char **)keyword_list, &param1, &param2, &param3)) {
          Datagram const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_Datagram);
          Connection *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_Connection);
          if (param1_this != nullptr && param2_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).send)(*param1_this, param2_this, (PyObject_IsTrue(param3) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, NetAddress const &address, bool block = false)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4 = Py_False;
        static const char *keyword_list[] = {"datagram", "connection", "address", "block", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO|O:send", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
          Datagram param1_local;
          Datagram const *param1_this = Dtool_Coerce_Datagram(param1, param1_local);
          Connection *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_Connection);
          NetAddress param3_local;
          NetAddress const *param3_this = Dtool_Coerce_NetAddress(param3, param3_local);
          if ((param1_this != nullptr) && param2_this != nullptr && (param3_this != nullptr)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).send)(*param1_this, param2_this, *param3_this, (PyObject_IsTrue(param4) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, bool block = false)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static const char *keyword_list[] = {"datagram", "connection", "block", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:send", (char **)keyword_list, &param1, &param2, &param3)) {
          Datagram param1_local;
          Datagram const *param1_this = Dtool_Coerce_Datagram(param1, param1_local);
          Connection *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_Connection);
          if ((param1_this != nullptr) && param2_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            bool return_value = ((*local_this).send)(*param1_this, param2_this, (PyObject_IsTrue(param3) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
            Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "send() takes 3, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "send(const ConnectionWriter self, const Datagram datagram, const Connection connection)\n"
      "send(const ConnectionWriter self, const Datagram datagram, const Connection connection, const NetAddress address, bool block)\n"
      "send(const ConnectionWriter self, const Datagram datagram, const Connection connection, bool block)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_send_116_comment =
  "C++ Interface:\n"
  "send(const ConnectionWriter self, const Datagram datagram, const Connection connection)\n"
  "send(const ConnectionWriter self, const Datagram datagram, const Connection connection, const NetAddress address, bool block)\n"
  "send(const ConnectionWriter self, const Datagram datagram, const Connection connection, bool block)\n"
  "\n"
  "/**\n"
  " * Enqueues a datagram for transmittal on the indicated socket.  Since the\n"
  " * host address is not specified with this form, this function should only be\n"
  " * used for sending TCP packets.  Use the other send() method for sending UDP\n"
  " * packets.\n"
  " *\n"
  " * Returns true if successful, false if there was an error.  In the normal,\n"
  " * threaded case, this function only returns false if the send queue is\n"
  " * filled; it's impossible to detect a transmission error at this point.\n"
  " *\n"
  " * If block is true, this will not return false if the send queue is filled;\n"
  " * instead, it will wait until there is space available.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Enqueues a datagram for transmittal on the indicated socket.  This form of\n"
  " * the function allows the specification of a destination host address, and so\n"
  " * is appropriate for UDP packets.  Use the other send() method for sending\n"
  " * TCP packets.\n"
  " *\n"
  " * Returns true if successful, false if there was an error.  In the normal,\n"
  " * threaded case, this function only returns false if the send queue is\n"
  " * filled; it's impossible to detect a transmission error at this point.\n"
  " *\n"
  " * If block is true, this will not return false if the send queue is filled;\n"
  " * instead, it will wait until there is space available.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_send_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionWriter::is_valid_for_udp(Datagram const &datagram) const
 */
static PyObject *Dtool_ConnectionWriter_is_valid_for_udp_117(PyObject *self, PyObject *arg) {
  ConnectionWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionWriter)) {
    return nullptr;
  }
  // 1-bool ConnectionWriter::is_valid_for_udp(Datagram const &datagram) const
  Datagram arg_local;
  Datagram const *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ConnectionWriter.is_valid_for_udp", "Datagram");
  }
  bool return_value = ((*(const ConnectionWriter*)local_this).is_valid_for_udp)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_valid_for_udp(ConnectionWriter self, const Datagram datagram)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_is_valid_for_udp_117_comment =
  "C++ Interface:\n"
  "is_valid_for_udp(ConnectionWriter self, const Datagram datagram)\n"
  "\n"
  "/**\n"
  " * Returns true if the datagram is small enough to be sent over a UDP packet,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_is_valid_for_udp_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConnectionManager *ConnectionWriter::get_manager(void) const
 */
static PyObject *Dtool_ConnectionWriter_get_manager_118(PyObject *self, PyObject *) {
  ConnectionWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionWriter)) {
    return nullptr;
  }
  // 1-ConnectionManager *ConnectionWriter::get_manager(void) const
  ConnectionManager *return_value = ((*(const ConnectionWriter*)local_this).get_manager)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_get_manager_118_comment =
  "C++ Interface:\n"
  "get_manager(ConnectionWriter self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the ConnectionManager object that serves this\n"
  " * ConnectionWriter.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_get_manager_118_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionWriter::is_immediate(void) const
 */
static PyObject *Dtool_ConnectionWriter_is_immediate_119(PyObject *self, PyObject *) {
  ConnectionWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionWriter)) {
    return nullptr;
  }
  // 1-bool ConnectionWriter::is_immediate(void) const
  bool return_value = ((*(const ConnectionWriter*)local_this).is_immediate)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_is_immediate_119_comment =
  "C++ Interface:\n"
  "is_immediate(ConnectionWriter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the writer is an immediate writer, i.e.  it has no threads.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_is_immediate_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int ConnectionWriter::get_num_threads(void) const
 */
static PyObject *Dtool_ConnectionWriter_get_num_threads_120(PyObject *self, PyObject *) {
  ConnectionWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionWriter)) {
    return nullptr;
  }
  // 1-int ConnectionWriter::get_num_threads(void) const
  int return_value = ((*(const ConnectionWriter*)local_this).get_num_threads)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_get_num_threads_120_comment =
  "C++ Interface:\n"
  "get_num_threads(ConnectionWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the number of threads the ConnectionWriter has been created with.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_get_num_threads_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConnectionWriter::set_raw_mode(bool mode)
 */
static PyObject *Dtool_ConnectionWriter_set_raw_mode_121(PyObject *self, PyObject *arg) {
  ConnectionWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionWriter, (void **)&local_this, "ConnectionWriter.set_raw_mode")) {
    return nullptr;
  }
  // 1-void ConnectionWriter::set_raw_mode(bool mode)
  ((*local_this).set_raw_mode)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_raw_mode(const ConnectionWriter self, bool mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_set_raw_mode_121_comment =
  "C++ Interface:\n"
  "set_raw_mode(const ConnectionWriter self, bool mode)\n"
  "\n"
  "/**\n"
  " * Sets the ConnectionWriter into raw mode (or turns off raw mode).  In raw\n"
  " * mode, datagrams are not sent along with their headers; the bytes in the\n"
  " * datagram are simply sent down the pipe.\n"
  " *\n"
  " * Setting the ConnectionWriter to raw mode must be done with care.  This can\n"
  " * only be done when the matching ConnectionReader is also set to raw mode, or\n"
  " * when the ConnectionWriter is communicating to a process that does not\n"
  " * expect datagrams.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_set_raw_mode_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ConnectionWriter::get_raw_mode(void) const
 */
static PyObject *Dtool_ConnectionWriter_get_raw_mode_122(PyObject *self, PyObject *) {
  ConnectionWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionWriter)) {
    return nullptr;
  }
  // 1-bool ConnectionWriter::get_raw_mode(void) const
  bool return_value = ((*(const ConnectionWriter*)local_this).get_raw_mode)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_get_raw_mode_122_comment =
  "C++ Interface:\n"
  "get_raw_mode(ConnectionWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the raw mode flag.  See set_raw_mode().\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_get_raw_mode_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConnectionWriter::set_tcp_header_size(int tcp_header_size)
 */
static PyObject *Dtool_ConnectionWriter_set_tcp_header_size_123(PyObject *self, PyObject *arg) {
  ConnectionWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionWriter, (void **)&local_this, "ConnectionWriter.set_tcp_header_size")) {
    return nullptr;
  }
  // 1-void ConnectionWriter::set_tcp_header_size(int tcp_header_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_tcp_header_size)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tcp_header_size(const ConnectionWriter self, int tcp_header_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_set_tcp_header_size_123_comment =
  "C++ Interface:\n"
  "set_tcp_header_size(const ConnectionWriter self, int tcp_header_size)\n"
  "\n"
  "/**\n"
  " * Sets the header size of TCP packets.  At the present, legal values for this\n"
  " * are 0, 2, or 4; this specifies the number of bytes to use encode the\n"
  " * datagram length at the start of each TCP datagram.  Sender and receiver\n"
  " * must independently agree on this.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_set_tcp_header_size_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int ConnectionWriter::get_tcp_header_size(void) const
 */
static PyObject *Dtool_ConnectionWriter_get_tcp_header_size_124(PyObject *self, PyObject *) {
  ConnectionWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConnectionWriter)) {
    return nullptr;
  }
  // 1-int ConnectionWriter::get_tcp_header_size(void) const
  int return_value = ((*(const ConnectionWriter*)local_this).get_tcp_header_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_get_tcp_header_size_124_comment =
  "C++ Interface:\n"
  "get_tcp_header_size(ConnectionWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of TCP header size.  See set_tcp_header_size().\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_get_tcp_header_size_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ConnectionWriter::shutdown(void)
 */
static PyObject *Dtool_ConnectionWriter_shutdown_125(PyObject *self, PyObject *) {
  ConnectionWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConnectionWriter, (void **)&local_this, "ConnectionWriter.shutdown")) {
    return nullptr;
  }
  // 1-void ConnectionWriter::shutdown(void)
  ((*local_this).shutdown)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConnectionWriter_shutdown_125_comment =
  "C++ Interface:\n"
  "shutdown(const ConnectionWriter self)\n"
  "\n"
  "/**\n"
  " * Stops all the threads and cleans them up.  This is called automatically by\n"
  " * the destructor, but it may be called explicitly before destruction.\n"
  " */";
#else
static const char *Dtool_ConnectionWriter_shutdown_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit ConnectionWriter::ConnectionWriter(ConnectionManager *manager, int num_threads, std::string const &thread_name = string())
 */
static int Dtool_Init_ConnectionWriter(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit ConnectionWriter::ConnectionWriter(ConnectionManager *manager, int num_threads, std::string const &thread_name = string())
  PyObject *param0;
  int param1;
  const char *param2_str = "";
  Py_ssize_t param2_len = 0;
  static const char *keyword_list[] = {"manager", "num_threads", "thread_name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi|s#:ConnectionWriter", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len)) {
    ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "ConnectionWriter.ConnectionWriter", false, true);
    if (param0_this != nullptr) {
      ConnectionWriter *return_value = new ConnectionWriter(param0_this, (int)param1, std::string(param2_str, param2_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConnectionWriter, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConnectionWriter(ConnectionManager manager, int num_threads, str thread_name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ConnectionWriter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConnectionWriter) {
    printf("ConnectionWriter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConnectionWriter *local_this = (ConnectionWriter *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConnectionWriter) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConnectionWriter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConnectionWriter) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DatagramGeneratorNet
 */
/**
 * Python function wrapper for:
 * virtual bool DatagramGeneratorNet::get_datagram(Datagram &data)
 */
static PyObject *Dtool_DatagramGeneratorNet_get_datagram_142(PyObject *self, PyObject *arg) {
  DatagramGeneratorNet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGeneratorNet, (void **)&local_this, "DatagramGeneratorNet.get_datagram")) {
    return nullptr;
  }
  // 1-virtual bool DatagramGeneratorNet::get_datagram(Datagram &data)
  Datagram arg_local;
  Datagram *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DatagramGeneratorNet.get_datagram", "Datagram");
  }
  bool return_value = ((*local_this).get_datagram)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_datagram(const DatagramGeneratorNet self, Datagram data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DatagramGeneratorNet_get_datagram_142_comment =
  "C++ Interface:\n"
  "get_datagram(const DatagramGeneratorNet self, Datagram data)\n"
  "\n"
  "// Inherited from DatagramGenerator\n"
  "\n"
  "/**\n"
  " * Reads the next datagram from the stream.  Blocks until a datagram is\n"
  " * available.  Returns true on success, false on stream closed or error.\n"
  " */";
#else
static const char *Dtool_DatagramGeneratorNet_get_datagram_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramGeneratorNet::is_eof(void)
 */
static PyObject *Dtool_DatagramGeneratorNet_is_eof_143(PyObject *self, PyObject *) {
  DatagramGeneratorNet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGeneratorNet, (void **)&local_this, "DatagramGeneratorNet.is_eof")) {
    return nullptr;
  }
  // 1-virtual bool DatagramGeneratorNet::is_eof(void)
  bool return_value = ((*local_this).is_eof)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGeneratorNet_is_eof_143_comment =
  "C++ Interface:\n"
  "is_eof(const DatagramGeneratorNet self)\n"
  "\n"
  "/**\n"
  " * Returns true if the stream has been closed normally.  This test may only be\n"
  " * made after a call to get_datagram() has failed.\n"
  " */";
#else
static const char *Dtool_DatagramGeneratorNet_is_eof_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramGeneratorNet::is_error(void)
 */
static PyObject *Dtool_DatagramGeneratorNet_is_error_144(PyObject *self, PyObject *) {
  DatagramGeneratorNet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGeneratorNet, (void **)&local_this, "DatagramGeneratorNet.is_error")) {
    return nullptr;
  }
  // 1-virtual bool DatagramGeneratorNet::is_error(void)
  bool return_value = ((*local_this).is_error)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGeneratorNet_is_error_144_comment =
  "C++ Interface:\n"
  "is_error(const DatagramGeneratorNet self)\n"
  "\n"
  "/**\n"
  " * Returns true if the stream has an error condition.\n"
  " */";
#else
static const char *Dtool_DatagramGeneratorNet_is_error_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DatagramGenerator *DatagramGeneratorNet::upcast_to_DatagramGenerator(void)
 */
static PyObject *Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_128(PyObject *self, PyObject *) {
  DatagramGeneratorNet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGeneratorNet, (void **)&local_this, "DatagramGeneratorNet.upcast_to_DatagramGenerator")) {
    return nullptr;
  }
  // 1-DatagramGenerator *DatagramGeneratorNet::upcast_to_DatagramGenerator(void)
  DatagramGenerator *return_value = (DatagramGenerator *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramGenerator, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_128_comment =
  "C++ Interface:\n"
  "upcast_to_DatagramGenerator(const DatagramGeneratorNet self)\n"
  "\n"
  "upcast from DatagramGeneratorNet to DatagramGenerator";
#else
static const char *Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConnectionReader *DatagramGeneratorNet::upcast_to_ConnectionReader(void)
 */
static PyObject *Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_130(PyObject *self, PyObject *) {
  DatagramGeneratorNet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGeneratorNet, (void **)&local_this, "DatagramGeneratorNet.upcast_to_ConnectionReader")) {
    return nullptr;
  }
  // 1-ConnectionReader *DatagramGeneratorNet::upcast_to_ConnectionReader(void)
  ConnectionReader *return_value = (ConnectionReader *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionReader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_130_comment =
  "C++ Interface:\n"
  "upcast_to_ConnectionReader(const DatagramGeneratorNet self)\n"
  "\n"
  "upcast from DatagramGeneratorNet to ConnectionReader";
#else
static const char *Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * QueuedReturn< Datagram > *DatagramGeneratorNet::upcast_to_QueuedReturn_Datagram(void)
 */
static PyObject *Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_138(PyObject *self, PyObject *) {
  DatagramGeneratorNet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramGeneratorNet, (void **)&local_this, "DatagramGeneratorNet.upcast_to_QueuedReturn_Datagram")) {
    return nullptr;
  }
  // 1-QueuedReturn< Datagram > *DatagramGeneratorNet::upcast_to_QueuedReturn_Datagram(void)
  QueuedReturn< Datagram > *return_value = (QueuedReturn< Datagram > *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedReturn_Datagram, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_138_comment =
  "C++ Interface:\n"
  "upcast_to_QueuedReturn_Datagram(const DatagramGeneratorNet self)\n"
  "\n"
  "upcast from DatagramGeneratorNet to QueuedReturn< Datagram >";
#else
static const char *Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit DatagramGeneratorNet::DatagramGeneratorNet(ConnectionManager *manager, int num_threads)
 */
static int Dtool_Init_DatagramGeneratorNet(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit DatagramGeneratorNet::DatagramGeneratorNet(ConnectionManager *manager, int num_threads)
  PyObject *param0;
  int param1;
  static const char *keyword_list[] = {"manager", "num_threads", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:DatagramGeneratorNet", (char **)keyword_list, &param0, &param1)) {
    ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "DatagramGeneratorNet.DatagramGeneratorNet", false, true);
    if (param0_this != nullptr) {
      DatagramGeneratorNet *return_value = new DatagramGeneratorNet(param0_this, (int)param1);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramGeneratorNet, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DatagramGeneratorNet(ConnectionManager manager, int num_threads)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DatagramGeneratorNet(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DatagramGeneratorNet) {
    printf("DatagramGeneratorNet ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DatagramGeneratorNet *local_this = (DatagramGeneratorNet *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DatagramGeneratorNet) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConnectionReader) {
    return (ConnectionReader *) local_this;
  }
  if (requested_type == Dtool_Ptr_DatagramGenerator) {
    return (DatagramGenerator *) local_this;
  }
  if (requested_type == Dtool_Ptr_QueuedReturn_Datagram) {
    return (QueuedReturn< Datagram > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DatagramGeneratorNet(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DatagramGeneratorNet) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConnectionReader) {
    ConnectionReader* other_this = (ConnectionReader*)from_this;
    return (DatagramGeneratorNet*)other_this;
  }
  if (from_type == Dtool_Ptr_DatagramGenerator) {
    DatagramGenerator* other_this = (DatagramGenerator*)from_this;
    return (DatagramGeneratorNet*)other_this;
  }
  if (from_type == Dtool_Ptr_QueuedReturn_Datagram) {
    QueuedReturn< Datagram >* other_this = (QueuedReturn< Datagram >*)from_this;
    return (DatagramGeneratorNet*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class QueuedReturn< Datagram >
 */
/**
 * Python function wrapper for:
 * void QueuedReturn< Datagram >::set_max_queue_size(int max_size)
 */
static PyObject *Dtool_QueuedReturn_Datagram_set_max_queue_size_133(PyObject *self, PyObject *arg) {
  QueuedReturn< Datagram > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_Datagram, (void **)&local_this, "QueuedReturn_Datagram.set_max_queue_size")) {
    return nullptr;
  }
  // 1-void QueuedReturn< Datagram >::set_max_queue_size(int max_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_max_queue_size)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_queue_size(const QueuedReturn self, int max_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_Datagram_set_max_queue_size_133_comment =
  "C++ Interface:\n"
  "set_max_queue_size(const QueuedReturn self, int max_size)\n";
#else
static const char *Dtool_QueuedReturn_Datagram_set_max_queue_size_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int QueuedReturn< Datagram >::get_max_queue_size(void) const
 */
static PyObject *Dtool_QueuedReturn_Datagram_get_max_queue_size_134(PyObject *self, PyObject *) {
  QueuedReturn< Datagram > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_QueuedReturn_Datagram)) {
    return nullptr;
  }
  // 1-int QueuedReturn< Datagram >::get_max_queue_size(void) const
  int return_value = ((*(const QueuedReturn< Datagram >*)local_this).get_max_queue_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_Datagram_get_max_queue_size_134_comment =
  "C++ Interface:\n"
  "get_max_queue_size(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_Datagram_get_max_queue_size_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int QueuedReturn< Datagram >::get_current_queue_size(void) const
 */
static PyObject *Dtool_QueuedReturn_Datagram_get_current_queue_size_135(PyObject *self, PyObject *) {
  QueuedReturn< Datagram > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_QueuedReturn_Datagram)) {
    return nullptr;
  }
  // 1-int QueuedReturn< Datagram >::get_current_queue_size(void) const
  int return_value = ((*(const QueuedReturn< Datagram >*)local_this).get_current_queue_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_Datagram_get_current_queue_size_135_comment =
  "C++ Interface:\n"
  "get_current_queue_size(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_Datagram_get_current_queue_size_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool QueuedReturn< Datagram >::get_overflow_flag(void) const
 */
static PyObject *Dtool_QueuedReturn_Datagram_get_overflow_flag_136(PyObject *self, PyObject *) {
  QueuedReturn< Datagram > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_QueuedReturn_Datagram)) {
    return nullptr;
  }
  // 1-bool QueuedReturn< Datagram >::get_overflow_flag(void) const
  bool return_value = ((*(const QueuedReturn< Datagram >*)local_this).get_overflow_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_Datagram_get_overflow_flag_136_comment =
  "C++ Interface:\n"
  "get_overflow_flag(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_Datagram_get_overflow_flag_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void QueuedReturn< Datagram >::reset_overflow_flag(void)
 */
static PyObject *Dtool_QueuedReturn_Datagram_reset_overflow_flag_137(PyObject *self, PyObject *) {
  QueuedReturn< Datagram > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_Datagram, (void **)&local_this, "QueuedReturn_Datagram.reset_overflow_flag")) {
    return nullptr;
  }
  // 1-void QueuedReturn< Datagram >::reset_overflow_flag(void)
  ((*local_this).reset_overflow_flag)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_Datagram_reset_overflow_flag_137_comment =
  "C++ Interface:\n"
  "reset_overflow_flag(const QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_Datagram_reset_overflow_flag_137_comment = nullptr;
#endif

static int Dtool_Init_QueuedReturn_Datagram(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_QueuedReturn_Datagram(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_QueuedReturn_Datagram) {
    printf("QueuedReturn_Datagram ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  QueuedReturn< Datagram > *local_this = (QueuedReturn< Datagram > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_QueuedReturn_Datagram) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_QueuedReturn_Datagram(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_QueuedReturn_Datagram) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DatagramSinkNet
 */
/**
 * Python function wrapper for:
 * inline void DatagramSinkNet::set_target(Connection *connection)
 */
static PyObject *Dtool_DatagramSinkNet_set_target_152(PyObject *self, PyObject *arg) {
  DatagramSinkNet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSinkNet, (void **)&local_this, "DatagramSinkNet.set_target")) {
    return nullptr;
  }
  // 1-inline void DatagramSinkNet::set_target(Connection *connection)
  Connection *arg_this = (Connection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Connection, 1, "DatagramSinkNet.set_target", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_target)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_target(const DatagramSinkNet self, Connection connection)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DatagramSinkNet_set_target_152_comment =
  "C++ Interface:\n"
  "set_target(const DatagramSinkNet self, Connection connection)\n"
  "\n"
  "/**\n"
  " * Specifies the Connection that will receive all future Datagrams sent.\n"
  " */";
#else
static const char *Dtool_DatagramSinkNet_set_target_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Connection *DatagramSinkNet::get_target(void) const
 */
static PyObject *Dtool_DatagramSinkNet_get_target_153(PyObject *self, PyObject *) {
  DatagramSinkNet *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DatagramSinkNet)) {
    return nullptr;
  }
  // 1-inline Connection *DatagramSinkNet::get_target(void) const
  Connection *return_value = ((*(const DatagramSinkNet*)local_this).get_target)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Connection, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramSinkNet_get_target_153_comment =
  "C++ Interface:\n"
  "get_target(DatagramSinkNet self)\n"
  "\n"
  "/**\n"
  " * Returns the current target Connection, or NULL if the target has not yet\n"
  " * been set.  See set_target().\n"
  " */";
#else
static const char *Dtool_DatagramSinkNet_get_target_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramSinkNet::put_datagram(Datagram const &data)
 */
static PyObject *Dtool_DatagramSinkNet_put_datagram_154(PyObject *self, PyObject *arg) {
  DatagramSinkNet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSinkNet, (void **)&local_this, "DatagramSinkNet.put_datagram")) {
    return nullptr;
  }
  // 1-virtual bool DatagramSinkNet::put_datagram(Datagram const &data)
  Datagram arg_local;
  Datagram const *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "DatagramSinkNet.put_datagram", "Datagram");
  }
  bool return_value = ((*local_this).put_datagram)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "put_datagram(const DatagramSinkNet self, const Datagram data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DatagramSinkNet_put_datagram_154_comment =
  "C++ Interface:\n"
  "put_datagram(const DatagramSinkNet self, const Datagram data)\n"
  "\n"
  "// Inherited from DatagramSink\n"
  "\n"
  "/**\n"
  " * Sends the given datagram to the target.  Returns true on success, false if\n"
  " * there is an error.  Blocks if necessary until the target is ready.\n"
  " */";
#else
static const char *Dtool_DatagramSinkNet_put_datagram_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool DatagramSinkNet::is_error(void)
 */
static PyObject *Dtool_DatagramSinkNet_is_error_155(PyObject *self, PyObject *) {
  DatagramSinkNet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSinkNet, (void **)&local_this, "DatagramSinkNet.is_error")) {
    return nullptr;
  }
  // 1-virtual bool DatagramSinkNet::is_error(void)
  bool return_value = ((*local_this).is_error)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DatagramSinkNet_is_error_155_comment =
  "C++ Interface:\n"
  "is_error(const DatagramSinkNet self)\n"
  "\n"
  "/**\n"
  " * Returns true if there is an error on the target connection, or if the\n"
  " * target has never been set.\n"
  " */";
#else
static const char *Dtool_DatagramSinkNet_is_error_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void DatagramSinkNet::flush(void)
 */
static PyObject *Dtool_DatagramSinkNet_flush_156(PyObject *self, PyObject *) {
  DatagramSinkNet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSinkNet, (void **)&local_this, "DatagramSinkNet.flush")) {
    return nullptr;
  }
  // 1-virtual void DatagramSinkNet::flush(void)
  ((*local_this).flush)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DatagramSinkNet_flush_156_comment =
  "C++ Interface:\n"
  "flush(const DatagramSinkNet self)\n"
  "\n"
  "/**\n"
  " * Ensures that all datagrams previously written will be visible on the\n"
  " * stream.\n"
  " */";
#else
static const char *Dtool_DatagramSinkNet_flush_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DatagramSink *DatagramSinkNet::upcast_to_DatagramSink(void)
 */
static PyObject *Dtool_DatagramSinkNet_upcast_to_DatagramSink_147(PyObject *self, PyObject *) {
  DatagramSinkNet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSinkNet, (void **)&local_this, "DatagramSinkNet.upcast_to_DatagramSink")) {
    return nullptr;
  }
  // 1-DatagramSink *DatagramSinkNet::upcast_to_DatagramSink(void)
  DatagramSink *return_value = (DatagramSink *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramSink, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramSinkNet_upcast_to_DatagramSink_147_comment =
  "C++ Interface:\n"
  "upcast_to_DatagramSink(const DatagramSinkNet self)\n"
  "\n"
  "upcast from DatagramSinkNet to DatagramSink";
#else
static const char *Dtool_DatagramSinkNet_upcast_to_DatagramSink_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConnectionWriter *DatagramSinkNet::upcast_to_ConnectionWriter(void)
 */
static PyObject *Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_149(PyObject *self, PyObject *) {
  DatagramSinkNet *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramSinkNet, (void **)&local_this, "DatagramSinkNet.upcast_to_ConnectionWriter")) {
    return nullptr;
  }
  // 1-ConnectionWriter *DatagramSinkNet::upcast_to_ConnectionWriter(void)
  ConnectionWriter *return_value = (ConnectionWriter *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionWriter, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_149_comment =
  "C++ Interface:\n"
  "upcast_to_ConnectionWriter(const DatagramSinkNet self)\n"
  "\n"
  "upcast from DatagramSinkNet to ConnectionWriter";
#else
static const char *Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit DatagramSinkNet::DatagramSinkNet(ConnectionManager *manager, int num_threads)
 */
static int Dtool_Init_DatagramSinkNet(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit DatagramSinkNet::DatagramSinkNet(ConnectionManager *manager, int num_threads)
  PyObject *param0;
  int param1;
  static const char *keyword_list[] = {"manager", "num_threads", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:DatagramSinkNet", (char **)keyword_list, &param0, &param1)) {
    ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "DatagramSinkNet.DatagramSinkNet", false, true);
    if (param0_this != nullptr) {
      DatagramSinkNet *return_value = new DatagramSinkNet(param0_this, (int)param1);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramSinkNet, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DatagramSinkNet(ConnectionManager manager, int num_threads)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DatagramSinkNet(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DatagramSinkNet) {
    printf("DatagramSinkNet ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DatagramSinkNet *local_this = (DatagramSinkNet *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DatagramSinkNet) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConnectionWriter) {
    return (ConnectionWriter *) local_this;
  }
  if (requested_type == Dtool_Ptr_DatagramSink) {
    return (DatagramSink *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DatagramSinkNet(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DatagramSinkNet) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConnectionWriter) {
    ConnectionWriter* other_this = (ConnectionWriter*)from_this;
    return (DatagramSinkNet*)other_this;
  }
  if (from_type == Dtool_Ptr_DatagramSink) {
    DatagramSink* other_this = (DatagramSink*)from_this;
    return (DatagramSinkNet*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class QueuedConnectionListener
 */
/**
 * Python function wrapper for:
 * bool QueuedConnectionListener::new_connection_available(void)
 */
static PyObject *Dtool_QueuedConnectionListener_new_connection_available_171(PyObject *self, PyObject *) {
  QueuedConnectionListener *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionListener, (void **)&local_this, "QueuedConnectionListener.new_connection_available")) {
    return nullptr;
  }
  // 1-bool QueuedConnectionListener::new_connection_available(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).new_connection_available)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionListener_new_connection_available_171_comment =
  "C++ Interface:\n"
  "new_connection_available(const QueuedConnectionListener self)\n"
  "\n"
  "/**\n"
  " * Returns true if a new connection was recently established; the connection\n"
  " * information may then be retrieved via get_new_connection().\n"
  " */";
#else
static const char *Dtool_QueuedConnectionListener_new_connection_available_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool QueuedConnectionListener::get_new_connection(PointerTo< Connection > &new_connection)
 * bool QueuedConnectionListener::get_new_connection(PointerTo< Connection > &rendezvous, NetAddress &address, PointerTo< Connection > &new_connection)
 */
static PyObject *Dtool_QueuedConnectionListener_get_new_connection_172(PyObject *self, PyObject *args, PyObject *kwds) {
  QueuedConnectionListener *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionListener, (void **)&local_this, "QueuedConnectionListener.get_new_connection")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "new_connection")) {
        // 1-bool QueuedConnectionListener::get_new_connection(PointerTo< Connection > &new_connection)
        PointerTo< Connection > arg_local;
        PointerTo< Connection > *arg_this = Dtool_Coerce_PointerTo_Connection(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "QueuedConnectionListener.get_new_connection", "PointerTo");
        }
        bool return_value = ((*local_this).get_new_connection)(*arg_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 3:
    {
      // 1-bool QueuedConnectionListener::get_new_connection(PointerTo< Connection > &rendezvous, NetAddress &address, PointerTo< Connection > &new_connection)
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      static const char *keyword_list[] = {"rendezvous", "address", "new_connection", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:get_new_connection", (char **)keyword_list, &param1, &param2, &param3)) {
        PointerTo< Connection > param1_local;
        PointerTo< Connection > *param1_this = Dtool_Coerce_PointerTo_Connection(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "QueuedConnectionListener.get_new_connection", "PointerTo");
        }
        NetAddress param2_local;
        NetAddress *param2_this = Dtool_Coerce_NetAddress(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "QueuedConnectionListener.get_new_connection", "NetAddress");
        }
        PointerTo< Connection > param3_local;
        PointerTo< Connection > *param3_this = Dtool_Coerce_PointerTo_Connection(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "QueuedConnectionListener.get_new_connection", "PointerTo");
        }
        bool return_value = ((*local_this).get_new_connection)(*param1_this, *param2_this, *param3_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_new_connection() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_new_connection(const QueuedConnectionListener self, PointerTo new_connection)\n"
      "get_new_connection(const QueuedConnectionListener self, PointerTo rendezvous, NetAddress address, PointerTo new_connection)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionListener_get_new_connection_172_comment =
  "C++ Interface:\n"
  "get_new_connection(const QueuedConnectionListener self, PointerTo new_connection)\n"
  "get_new_connection(const QueuedConnectionListener self, PointerTo rendezvous, NetAddress address, PointerTo new_connection)\n"
  "\n"
  "/**\n"
  " * If a previous call to new_connection_available() returned true, this\n"
  " * function will return information about the newly established connection.\n"
  " *\n"
  " * The rendezvous parameter is the particular rendezvous socket this new\n"
  " * connection originally communicated with; it is provided in case the\n"
  " * ConnectionListener was monitorind more than one and you care which one it\n"
  " * was.  The address parameter is the net address of the new client, and\n"
  " * new_connection is the socket of the newly established connection.\n"
  " *\n"
  " * The return value is true if a connection was successfully returned, or\n"
  " * false if there was, in fact, no new connection.  (This may happen if there\n"
  " * are multiple threads accessing the QueuedConnectionListener).\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of get_new_connection() simply returns a new connection,\n"
  " * assuming the user doesn't care about the rendezvous socket that originated\n"
  " * it or the address it came from.\n"
  " */";
#else
static const char *Dtool_QueuedConnectionListener_get_new_connection_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConnectionListener *QueuedConnectionListener::upcast_to_ConnectionListener(void)
 */
static PyObject *Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_159(PyObject *self, PyObject *) {
  QueuedConnectionListener *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionListener, (void **)&local_this, "QueuedConnectionListener.upcast_to_ConnectionListener")) {
    return nullptr;
  }
  // 1-ConnectionListener *QueuedConnectionListener::upcast_to_ConnectionListener(void)
  ConnectionListener *return_value = (ConnectionListener *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionListener, false, false);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_159_comment =
  "C++ Interface:\n"
  "upcast_to_ConnectionListener(const QueuedConnectionListener self)\n"
  "\n"
  "upcast from QueuedConnectionListener to ConnectionListener";
#else
static const char *Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_159_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * QueuedReturn< ConnectionListenerData > *QueuedConnectionListener::upcast_to_QueuedReturn_ConnectionListenerData(void)
 */
static PyObject *Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_167(PyObject *self, PyObject *) {
  QueuedConnectionListener *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionListener, (void **)&local_this, "QueuedConnectionListener.upcast_to_QueuedReturn_ConnectionListenerData")) {
    return nullptr;
  }
  // 1-QueuedReturn< ConnectionListenerData > *QueuedConnectionListener::upcast_to_QueuedReturn_ConnectionListenerData(void)
  QueuedReturn< ConnectionListenerData > *return_value = (QueuedReturn< ConnectionListenerData > *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedReturn_ConnectionListenerData, false, false);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_167_comment =
  "C++ Interface:\n"
  "upcast_to_QueuedReturn_ConnectionListenerData(const QueuedConnectionListener self)\n"
  "\n"
  "upcast from QueuedConnectionListener to QueuedReturn< ConnectionListenerData >";
#else
static const char *Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_167_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit QueuedConnectionListener::QueuedConnectionListener(ConnectionManager *manager, int num_threads)
 */
static int Dtool_Init_QueuedConnectionListener(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit QueuedConnectionListener::QueuedConnectionListener(ConnectionManager *manager, int num_threads)
  PyObject *param0;
  int param1;
  static const char *keyword_list[] = {"manager", "num_threads", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:QueuedConnectionListener", (char **)keyword_list, &param0, &param1)) {
    ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "QueuedConnectionListener.QueuedConnectionListener", false, true);
    if (param0_this != nullptr) {
      QueuedConnectionListener *return_value = new QueuedConnectionListener(param0_this, (int)param1);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_QueuedConnectionListener, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "QueuedConnectionListener(ConnectionManager manager, int num_threads)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_QueuedConnectionListener(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_QueuedConnectionListener) {
    printf("QueuedConnectionListener ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  QueuedConnectionListener *local_this = (QueuedConnectionListener *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_QueuedConnectionListener) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConnectionListener) {
    return (ConnectionListener *) local_this;
  }
  if (requested_type == Dtool_Ptr_ConnectionReader) {
    return (ConnectionReader *)(ConnectionListener *) local_this;
  }
  if (requested_type == Dtool_Ptr_QueuedReturn_ConnectionListenerData) {
    return (QueuedReturn< ConnectionListenerData > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_QueuedConnectionListener(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_QueuedConnectionListener) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConnectionListener) {
    ConnectionListener* other_this = (ConnectionListener*)from_this;
    return (QueuedConnectionListener*)other_this;
  }
  if (from_type == Dtool_Ptr_ConnectionReader) {
    ConnectionReader* other_this = (ConnectionReader*)from_this;
    return (QueuedConnectionListener*)other_this;
  }
  if (from_type == Dtool_Ptr_QueuedReturn_ConnectionListenerData) {
    QueuedReturn< ConnectionListenerData >* other_this = (QueuedReturn< ConnectionListenerData >*)from_this;
    return (QueuedConnectionListener*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class QueuedReturn< ConnectionListenerData >
 */
/**
 * Python function wrapper for:
 * void QueuedReturn< ConnectionListenerData >::set_max_queue_size(int max_size)
 */
static PyObject *Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_162(PyObject *self, PyObject *arg) {
  QueuedReturn< ConnectionListenerData > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_ConnectionListenerData, (void **)&local_this, "QueuedReturn_ConnectionListenerData.set_max_queue_size")) {
    return nullptr;
  }
  // 1-void QueuedReturn< ConnectionListenerData >::set_max_queue_size(int max_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_max_queue_size)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_queue_size(const QueuedReturn self, int max_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_162_comment =
  "C++ Interface:\n"
  "set_max_queue_size(const QueuedReturn self, int max_size)\n";
#else
static const char *Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_162_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int QueuedReturn< ConnectionListenerData >::get_max_queue_size(void) const
 */
static PyObject *Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_163(PyObject *self, PyObject *) {
  QueuedReturn< ConnectionListenerData > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_QueuedReturn_ConnectionListenerData)) {
    return nullptr;
  }
  // 1-int QueuedReturn< ConnectionListenerData >::get_max_queue_size(void) const
  int return_value = ((*(const QueuedReturn< ConnectionListenerData >*)local_this).get_max_queue_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_163_comment =
  "C++ Interface:\n"
  "get_max_queue_size(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_163_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int QueuedReturn< ConnectionListenerData >::get_current_queue_size(void) const
 */
static PyObject *Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_164(PyObject *self, PyObject *) {
  QueuedReturn< ConnectionListenerData > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_QueuedReturn_ConnectionListenerData)) {
    return nullptr;
  }
  // 1-int QueuedReturn< ConnectionListenerData >::get_current_queue_size(void) const
  int return_value = ((*(const QueuedReturn< ConnectionListenerData >*)local_this).get_current_queue_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_164_comment =
  "C++ Interface:\n"
  "get_current_queue_size(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_164_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool QueuedReturn< ConnectionListenerData >::get_overflow_flag(void) const
 */
static PyObject *Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_165(PyObject *self, PyObject *) {
  QueuedReturn< ConnectionListenerData > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_QueuedReturn_ConnectionListenerData)) {
    return nullptr;
  }
  // 1-bool QueuedReturn< ConnectionListenerData >::get_overflow_flag(void) const
  bool return_value = ((*(const QueuedReturn< ConnectionListenerData >*)local_this).get_overflow_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_165_comment =
  "C++ Interface:\n"
  "get_overflow_flag(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_165_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void QueuedReturn< ConnectionListenerData >::reset_overflow_flag(void)
 */
static PyObject *Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_166(PyObject *self, PyObject *) {
  QueuedReturn< ConnectionListenerData > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_ConnectionListenerData, (void **)&local_this, "QueuedReturn_ConnectionListenerData.reset_overflow_flag")) {
    return nullptr;
  }
  // 1-void QueuedReturn< ConnectionListenerData >::reset_overflow_flag(void)
  ((*local_this).reset_overflow_flag)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_166_comment =
  "C++ Interface:\n"
  "reset_overflow_flag(const QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_166_comment = nullptr;
#endif

static int Dtool_Init_QueuedReturn_ConnectionListenerData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_QueuedReturn_ConnectionListenerData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_QueuedReturn_ConnectionListenerData) {
    printf("QueuedReturn_ConnectionListenerData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  QueuedReturn< ConnectionListenerData > *local_this = (QueuedReturn< ConnectionListenerData > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_QueuedReturn_ConnectionListenerData) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_QueuedReturn_ConnectionListenerData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_QueuedReturn_ConnectionListenerData) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class QueuedConnectionManager
 */
/**
 * Python function wrapper for:
 * bool QueuedConnectionManager::reset_connection_available(void) const
 */
static PyObject *Dtool_QueuedConnectionManager_reset_connection_available_186(PyObject *self, PyObject *) {
  QueuedConnectionManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_QueuedConnectionManager)) {
    return nullptr;
  }
  // 1-bool QueuedConnectionManager::reset_connection_available(void) const
  bool return_value = ((*(const QueuedConnectionManager*)local_this).reset_connection_available)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionManager_reset_connection_available_186_comment =
  "C++ Interface:\n"
  "reset_connection_available(QueuedConnectionManager self)\n"
  "\n"
  "/**\n"
  " * Returns true if one of the readers/writers/listeners reported a connection\n"
  " * reset recently.  If so, the particular connection that has been reset can\n"
  " * be extracted via get_reset_connection().\n"
  " *\n"
  " * Only connections which were externally reset are certain to appear in this\n"
  " * list.  Those which were explicitly closed via a call to close_connection()\n"
  " * may or may not be reported.  Furthermore, it is the responsibility of the\n"
  " * caller to subsequently call close_connection() with any connection reported\n"
  " * reset by this call.  (There is no harm in calling close_connection() more\n"
  " * than once on a given socket.)\n"
  " */";
#else
static const char *Dtool_QueuedConnectionManager_reset_connection_available_186_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool QueuedConnectionManager::get_reset_connection(PointerTo< Connection > &connection)
 */
static PyObject *Dtool_QueuedConnectionManager_get_reset_connection_187(PyObject *self, PyObject *arg) {
  QueuedConnectionManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionManager, (void **)&local_this, "QueuedConnectionManager.get_reset_connection")) {
    return nullptr;
  }
  // 1-bool QueuedConnectionManager::get_reset_connection(PointerTo< Connection > &connection)
  PointerTo< Connection > arg_local;
  PointerTo< Connection > *arg_this = Dtool_Coerce_PointerTo_Connection(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "QueuedConnectionManager.get_reset_connection", "PointerTo");
  }
  bool return_value = ((*local_this).get_reset_connection)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_reset_connection(const QueuedConnectionManager self, PointerTo connection)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionManager_get_reset_connection_187_comment =
  "C++ Interface:\n"
  "get_reset_connection(const QueuedConnectionManager self, PointerTo connection)\n"
  "\n"
  "/**\n"
  " * If a previous call to reset_connection_available() returned true, this\n"
  " * function will return information about the newly reset connection.\n"
  " *\n"
  " * Only connections which were externally reset are certain to appear in this\n"
  " * list.  Those which were explicitly closed via a call to close_connection()\n"
  " * may or may not be reported.  Furthermore, it is the responsibility of the\n"
  " * caller to subsequently call close_connection() with any connection reported\n"
  " * reset by this call.  (There is no harm in calling close_connection() more\n"
  " * than once on a given socket.)\n"
  " *\n"
  " * The return value is true if a connection was successfully returned, or\n"
  " * false if there was, in fact, no reset connection.  (This may happen if\n"
  " * there are multiple threads accessing the QueuedConnectionManager).\n"
  " */";
#else
static const char *Dtool_QueuedConnectionManager_get_reset_connection_187_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConnectionManager *QueuedConnectionManager::upcast_to_ConnectionManager(void)
 */
static PyObject *Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_174(PyObject *self, PyObject *) {
  QueuedConnectionManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionManager, (void **)&local_this, "QueuedConnectionManager.upcast_to_ConnectionManager")) {
    return nullptr;
  }
  // 1-ConnectionManager *QueuedConnectionManager::upcast_to_ConnectionManager(void)
  ConnectionManager *return_value = (ConnectionManager *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_174_comment =
  "C++ Interface:\n"
  "upcast_to_ConnectionManager(const QueuedConnectionManager self)\n"
  "\n"
  "upcast from QueuedConnectionManager to ConnectionManager";
#else
static const char *Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * QueuedReturn< PointerTo< Connection > > *QueuedConnectionManager::upcast_to_QueuedReturn_PointerTo_Connection(void)
 */
static PyObject *Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_182(PyObject *self, PyObject *) {
  QueuedConnectionManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionManager, (void **)&local_this, "QueuedConnectionManager.upcast_to_QueuedReturn_PointerTo_Connection")) {
    return nullptr;
  }
  // 1-QueuedReturn< PointerTo< Connection > > *QueuedConnectionManager::upcast_to_QueuedReturn_PointerTo_Connection(void)
  QueuedReturn< PointerTo< Connection > > *return_value = (QueuedReturn< PointerTo< Connection > > *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedReturn_PointerTo_Connection, false, false);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_182_comment =
  "C++ Interface:\n"
  "upcast_to_QueuedReturn_PointerTo_Connection(const QueuedConnectionManager self)\n"
  "\n"
  "upcast from QueuedConnectionManager to QueuedReturn< PointerTo< Connection > >";
#else
static const char *Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * QueuedConnectionManager::QueuedConnectionManager(void)
 */
static int Dtool_Init_QueuedConnectionManager(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("QueuedConnectionManager() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "QueuedConnectionManager() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-QueuedConnectionManager::QueuedConnectionManager(void)
  QueuedConnectionManager *return_value = new QueuedConnectionManager();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_QueuedConnectionManager, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "QueuedConnectionManager()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_QueuedConnectionManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_QueuedConnectionManager) {
    printf("QueuedConnectionManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  QueuedConnectionManager *local_this = (QueuedConnectionManager *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_QueuedConnectionManager) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConnectionManager) {
    return (ConnectionManager *) local_this;
  }
  if (requested_type == Dtool_Ptr_QueuedReturn_PointerTo_Connection) {
    return (QueuedReturn< PointerTo< Connection > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_QueuedConnectionManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_QueuedConnectionManager) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConnectionManager) {
    ConnectionManager* other_this = (ConnectionManager*)from_this;
    return (QueuedConnectionManager*)other_this;
  }
  if (from_type == Dtool_Ptr_QueuedReturn_PointerTo_Connection) {
    QueuedReturn< PointerTo< Connection > >* other_this = (QueuedReturn< PointerTo< Connection > >*)from_this;
    return (QueuedConnectionManager*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class QueuedReturn< PointerTo< Connection > >
 */
/**
 * Python function wrapper for:
 * void QueuedReturn< PointerTo< Connection > >::set_max_queue_size(int max_size)
 */
static PyObject *Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_177(PyObject *self, PyObject *arg) {
  QueuedReturn< PointerTo< Connection > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_PointerTo_Connection, (void **)&local_this, "QueuedReturn_PointerTo_Connection.set_max_queue_size")) {
    return nullptr;
  }
  // 1-void QueuedReturn< PointerTo< Connection > >::set_max_queue_size(int max_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_max_queue_size)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_queue_size(const QueuedReturn self, int max_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_177_comment =
  "C++ Interface:\n"
  "set_max_queue_size(const QueuedReturn self, int max_size)\n";
#else
static const char *Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int QueuedReturn< PointerTo< Connection > >::get_max_queue_size(void) const
 */
static PyObject *Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_178(PyObject *self, PyObject *) {
  QueuedReturn< PointerTo< Connection > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_QueuedReturn_PointerTo_Connection)) {
    return nullptr;
  }
  // 1-int QueuedReturn< PointerTo< Connection > >::get_max_queue_size(void) const
  int return_value = ((*(const QueuedReturn< PointerTo< Connection > >*)local_this).get_max_queue_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_178_comment =
  "C++ Interface:\n"
  "get_max_queue_size(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int QueuedReturn< PointerTo< Connection > >::get_current_queue_size(void) const
 */
static PyObject *Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_179(PyObject *self, PyObject *) {
  QueuedReturn< PointerTo< Connection > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_QueuedReturn_PointerTo_Connection)) {
    return nullptr;
  }
  // 1-int QueuedReturn< PointerTo< Connection > >::get_current_queue_size(void) const
  int return_value = ((*(const QueuedReturn< PointerTo< Connection > >*)local_this).get_current_queue_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_179_comment =
  "C++ Interface:\n"
  "get_current_queue_size(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool QueuedReturn< PointerTo< Connection > >::get_overflow_flag(void) const
 */
static PyObject *Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_180(PyObject *self, PyObject *) {
  QueuedReturn< PointerTo< Connection > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_QueuedReturn_PointerTo_Connection)) {
    return nullptr;
  }
  // 1-bool QueuedReturn< PointerTo< Connection > >::get_overflow_flag(void) const
  bool return_value = ((*(const QueuedReturn< PointerTo< Connection > >*)local_this).get_overflow_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_180_comment =
  "C++ Interface:\n"
  "get_overflow_flag(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void QueuedReturn< PointerTo< Connection > >::reset_overflow_flag(void)
 */
static PyObject *Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_181(PyObject *self, PyObject *) {
  QueuedReturn< PointerTo< Connection > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_PointerTo_Connection, (void **)&local_this, "QueuedReturn_PointerTo_Connection.reset_overflow_flag")) {
    return nullptr;
  }
  // 1-void QueuedReturn< PointerTo< Connection > >::reset_overflow_flag(void)
  ((*local_this).reset_overflow_flag)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_181_comment =
  "C++ Interface:\n"
  "reset_overflow_flag(const QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_181_comment = nullptr;
#endif

static int Dtool_Init_QueuedReturn_PointerTo_Connection(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_QueuedReturn_PointerTo_Connection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_QueuedReturn_PointerTo_Connection) {
    printf("QueuedReturn_PointerTo_Connection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  QueuedReturn< PointerTo< Connection > > *local_this = (QueuedReturn< PointerTo< Connection > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_QueuedReturn_PointerTo_Connection) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_QueuedReturn_PointerTo_Connection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_QueuedReturn_PointerTo_Connection) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class QueuedConnectionReader
 */
/**
 * Python function wrapper for:
 * bool QueuedConnectionReader::data_available(void)
 */
static PyObject *Dtool_QueuedConnectionReader_data_available_201(PyObject *self, PyObject *) {
  QueuedConnectionReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionReader, (void **)&local_this, "QueuedConnectionReader.data_available")) {
    return nullptr;
  }
  // 1-bool QueuedConnectionReader::data_available(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).data_available)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionReader_data_available_201_comment =
  "C++ Interface:\n"
  "data_available(const QueuedConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Returns true if a datagram is available on the queue; call get_data() to\n"
  " * extract the datagram.\n"
  " */";
#else
static const char *Dtool_QueuedConnectionReader_data_available_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool QueuedConnectionReader::get_data(Datagram &result)
 * bool QueuedConnectionReader::get_data(NetDatagram &result)
 */
static PyObject *Dtool_QueuedConnectionReader_get_data_202(PyObject *self, PyObject *arg) {
  QueuedConnectionReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionReader, (void **)&local_this, "QueuedConnectionReader.get_data")) {
    return nullptr;
  }
  {
    // -2 bool QueuedConnectionReader::get_data(NetDatagram &result)
    NetDatagram *arg_this = (NetDatagram *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NetDatagram, 1, "QueuedConnectionReader.get_data", false, false);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).get_data)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool QueuedConnectionReader::get_data(Datagram &result)
    Datagram *arg_this = (Datagram *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Datagram, 1, "QueuedConnectionReader.get_data", false, false);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).get_data)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool QueuedConnectionReader::get_data(NetDatagram &result)
    NetDatagram arg_local;
    NetDatagram *arg_this = Dtool_Coerce_NetDatagram(arg, arg_local);
    if ((arg_this != nullptr)) {
      bool return_value = ((*local_this).get_data)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool QueuedConnectionReader::get_data(Datagram &result)
    Datagram arg_local;
    Datagram *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
    if ((arg_this != nullptr)) {
      bool return_value = ((*local_this).get_data)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_data(const QueuedConnectionReader self, NetDatagram result)\n"
      "get_data(const QueuedConnectionReader self, Datagram result)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionReader_get_data_202_comment =
  "C++ Interface:\n"
  "get_data(const QueuedConnectionReader self, NetDatagram result)\n"
  "get_data(const QueuedConnectionReader self, Datagram result)\n"
  "\n"
  "/**\n"
  " * If a previous call to data_available() returned true, this function will\n"
  " * return the datagram that has become available.\n"
  " *\n"
  " * The return value is true if a datagram was successfully returned, or false\n"
  " * if there was, in fact, no datagram available.  (This may happen if there\n"
  " * are multiple threads accessing the QueuedConnectionReader).\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of QueuedConnectionReader::get_data(), works like the other,\n"
  " * except that it only fills a Datagram object, not a NetDatagram object.\n"
  " * This means that the Datagram cannot be queried for its source Connection\n"
  " * and/or NetAddress, but it is useful in all other respects.\n"
  " */";
#else
static const char *Dtool_QueuedConnectionReader_get_data_202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConnectionReader *QueuedConnectionReader::upcast_to_ConnectionReader(void)
 */
static PyObject *Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_189(PyObject *self, PyObject *) {
  QueuedConnectionReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionReader, (void **)&local_this, "QueuedConnectionReader.upcast_to_ConnectionReader")) {
    return nullptr;
  }
  // 1-ConnectionReader *QueuedConnectionReader::upcast_to_ConnectionReader(void)
  ConnectionReader *return_value = (ConnectionReader *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionReader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_189_comment =
  "C++ Interface:\n"
  "upcast_to_ConnectionReader(const QueuedConnectionReader self)\n"
  "\n"
  "upcast from QueuedConnectionReader to ConnectionReader";
#else
static const char *Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * QueuedReturn< NetDatagram > *QueuedConnectionReader::upcast_to_QueuedReturn_NetDatagram(void)
 */
static PyObject *Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_197(PyObject *self, PyObject *) {
  QueuedConnectionReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedConnectionReader, (void **)&local_this, "QueuedConnectionReader.upcast_to_QueuedReturn_NetDatagram")) {
    return nullptr;
  }
  // 1-QueuedReturn< NetDatagram > *QueuedConnectionReader::upcast_to_QueuedReturn_NetDatagram(void)
  QueuedReturn< NetDatagram > *return_value = (QueuedReturn< NetDatagram > *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedReturn_NetDatagram, false, false);
}

#ifndef NDEBUG
static const char *Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_197_comment =
  "C++ Interface:\n"
  "upcast_to_QueuedReturn_NetDatagram(const QueuedConnectionReader self)\n"
  "\n"
  "upcast from QueuedConnectionReader to QueuedReturn< NetDatagram >";
#else
static const char *Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_197_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit QueuedConnectionReader::QueuedConnectionReader(ConnectionManager *manager, int num_threads)
 */
static int Dtool_Init_QueuedConnectionReader(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit QueuedConnectionReader::QueuedConnectionReader(ConnectionManager *manager, int num_threads)
  PyObject *param0;
  int param1;
  static const char *keyword_list[] = {"manager", "num_threads", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:QueuedConnectionReader", (char **)keyword_list, &param0, &param1)) {
    ConnectionManager *param0_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ConnectionManager, 0, "QueuedConnectionReader.QueuedConnectionReader", false, true);
    if (param0_this != nullptr) {
      QueuedConnectionReader *return_value = new QueuedConnectionReader(param0_this, (int)param1);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_QueuedConnectionReader, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "QueuedConnectionReader(ConnectionManager manager, int num_threads)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_QueuedConnectionReader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_QueuedConnectionReader) {
    printf("QueuedConnectionReader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  QueuedConnectionReader *local_this = (QueuedConnectionReader *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_QueuedConnectionReader) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConnectionReader) {
    return (ConnectionReader *) local_this;
  }
  if (requested_type == Dtool_Ptr_QueuedReturn_NetDatagram) {
    return (QueuedReturn< NetDatagram > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_QueuedConnectionReader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_QueuedConnectionReader) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConnectionReader) {
    ConnectionReader* other_this = (ConnectionReader*)from_this;
    return (QueuedConnectionReader*)other_this;
  }
  if (from_type == Dtool_Ptr_QueuedReturn_NetDatagram) {
    QueuedReturn< NetDatagram >* other_this = (QueuedReturn< NetDatagram >*)from_this;
    return (QueuedConnectionReader*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class QueuedReturn< NetDatagram >
 */
/**
 * Python function wrapper for:
 * void QueuedReturn< NetDatagram >::set_max_queue_size(int max_size)
 */
static PyObject *Dtool_QueuedReturn_NetDatagram_set_max_queue_size_192(PyObject *self, PyObject *arg) {
  QueuedReturn< NetDatagram > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_NetDatagram, (void **)&local_this, "QueuedReturn_NetDatagram.set_max_queue_size")) {
    return nullptr;
  }
  // 1-void QueuedReturn< NetDatagram >::set_max_queue_size(int max_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_max_queue_size)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_queue_size(const QueuedReturn self, int max_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_NetDatagram_set_max_queue_size_192_comment =
  "C++ Interface:\n"
  "set_max_queue_size(const QueuedReturn self, int max_size)\n";
#else
static const char *Dtool_QueuedReturn_NetDatagram_set_max_queue_size_192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int QueuedReturn< NetDatagram >::get_max_queue_size(void) const
 */
static PyObject *Dtool_QueuedReturn_NetDatagram_get_max_queue_size_193(PyObject *self, PyObject *) {
  QueuedReturn< NetDatagram > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_QueuedReturn_NetDatagram)) {
    return nullptr;
  }
  // 1-int QueuedReturn< NetDatagram >::get_max_queue_size(void) const
  int return_value = ((*(const QueuedReturn< NetDatagram >*)local_this).get_max_queue_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_NetDatagram_get_max_queue_size_193_comment =
  "C++ Interface:\n"
  "get_max_queue_size(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_NetDatagram_get_max_queue_size_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int QueuedReturn< NetDatagram >::get_current_queue_size(void) const
 */
static PyObject *Dtool_QueuedReturn_NetDatagram_get_current_queue_size_194(PyObject *self, PyObject *) {
  QueuedReturn< NetDatagram > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_QueuedReturn_NetDatagram)) {
    return nullptr;
  }
  // 1-int QueuedReturn< NetDatagram >::get_current_queue_size(void) const
  int return_value = ((*(const QueuedReturn< NetDatagram >*)local_this).get_current_queue_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_NetDatagram_get_current_queue_size_194_comment =
  "C++ Interface:\n"
  "get_current_queue_size(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_NetDatagram_get_current_queue_size_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool QueuedReturn< NetDatagram >::get_overflow_flag(void) const
 */
static PyObject *Dtool_QueuedReturn_NetDatagram_get_overflow_flag_195(PyObject *self, PyObject *) {
  QueuedReturn< NetDatagram > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_QueuedReturn_NetDatagram)) {
    return nullptr;
  }
  // 1-bool QueuedReturn< NetDatagram >::get_overflow_flag(void) const
  bool return_value = ((*(const QueuedReturn< NetDatagram >*)local_this).get_overflow_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_NetDatagram_get_overflow_flag_195_comment =
  "C++ Interface:\n"
  "get_overflow_flag(QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_NetDatagram_get_overflow_flag_195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void QueuedReturn< NetDatagram >::reset_overflow_flag(void)
 */
static PyObject *Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_196(PyObject *self, PyObject *) {
  QueuedReturn< NetDatagram > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_QueuedReturn_NetDatagram, (void **)&local_this, "QueuedReturn_NetDatagram.reset_overflow_flag")) {
    return nullptr;
  }
  // 1-void QueuedReturn< NetDatagram >::reset_overflow_flag(void)
  ((*local_this).reset_overflow_flag)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_196_comment =
  "C++ Interface:\n"
  "reset_overflow_flag(const QueuedReturn self)\n";
#else
static const char *Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_196_comment = nullptr;
#endif

static int Dtool_Init_QueuedReturn_NetDatagram(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_QueuedReturn_NetDatagram(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_QueuedReturn_NetDatagram) {
    printf("QueuedReturn_NetDatagram ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  QueuedReturn< NetDatagram > *local_this = (QueuedReturn< NetDatagram > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_QueuedReturn_NetDatagram) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_QueuedReturn_NetDatagram(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_QueuedReturn_NetDatagram) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class RecentConnectionReader
 */
/**
 * Python function wrapper for:
 * bool RecentConnectionReader::data_available(void)
 */
static PyObject *Dtool_RecentConnectionReader_data_available_205(PyObject *self, PyObject *) {
  RecentConnectionReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecentConnectionReader, (void **)&local_this, "RecentConnectionReader.data_available")) {
    return nullptr;
  }
  // 1-bool RecentConnectionReader::data_available(void)
  bool return_value = ((*local_this).data_available)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_RecentConnectionReader_data_available_205_comment =
  "C++ Interface:\n"
  "data_available(const RecentConnectionReader self)\n"
  "\n"
  "/**\n"
  " * Returns true if a datagram is available on the queue; call get_data() to\n"
  " * extract the datagram.\n"
  " */";
#else
static const char *Dtool_RecentConnectionReader_data_available_205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool RecentConnectionReader::get_data(Datagram &result)
 * bool RecentConnectionReader::get_data(NetDatagram &result)
 */
static PyObject *Dtool_RecentConnectionReader_get_data_206(PyObject *self, PyObject *arg) {
  RecentConnectionReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_RecentConnectionReader, (void **)&local_this, "RecentConnectionReader.get_data")) {
    return nullptr;
  }
  {
    // -2 bool RecentConnectionReader::get_data(NetDatagram &result)
    NetDatagram *arg_this = (NetDatagram *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_NetDatagram, 1, "RecentConnectionReader.get_data", false, false);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).get_data)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool RecentConnectionReader::get_data(Datagram &result)
    Datagram *arg_this = (Datagram *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Datagram, 1, "RecentConnectionReader.get_data", false, false);
    if (arg_this != nullptr) {
      bool return_value = ((*local_this).get_data)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool RecentConnectionReader::get_data(NetDatagram &result)
    NetDatagram arg_local;
    NetDatagram *arg_this = Dtool_Coerce_NetDatagram(arg, arg_local);
    if ((arg_this != nullptr)) {
      bool return_value = ((*local_this).get_data)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool RecentConnectionReader::get_data(Datagram &result)
    Datagram arg_local;
    Datagram *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
    if ((arg_this != nullptr)) {
      bool return_value = ((*local_this).get_data)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_data(const RecentConnectionReader self, NetDatagram result)\n"
      "get_data(const RecentConnectionReader self, Datagram result)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_RecentConnectionReader_get_data_206_comment =
  "C++ Interface:\n"
  "get_data(const RecentConnectionReader self, NetDatagram result)\n"
  "get_data(const RecentConnectionReader self, Datagram result)\n"
  "\n"
  "/**\n"
  " * If a previous call to data_available() returned true, this function will\n"
  " * return the datagram that has become available.\n"
  " *\n"
  " * The return value is true if a datagram was successfully returned, or false\n"
  " * if there was, in fact, no datagram available.  (This may happen if there\n"
  " * are multiple threads accessing the RecentConnectionReader).\n"
  " */\n"
  "\n"
  "/**\n"
  " * This flavor of RecentConnectionReader::get_data(), works like the other,\n"
  " * except that it only fills a Datagram object, not a NetDatagram object.\n"
  " * This means that the Datagram cannot be queried for its source Connection\n"
  " * and/or NetAddress, but it is useful in all other respects.\n"
  " */";
#else
static const char *Dtool_RecentConnectionReader_get_data_206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit RecentConnectionReader::RecentConnectionReader(ConnectionManager *manager)
 */
static int Dtool_Init_RecentConnectionReader(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "RecentConnectionReader() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "manager")) {
    // 1-explicit RecentConnectionReader::RecentConnectionReader(ConnectionManager *manager)
    ConnectionManager *arg_this = (ConnectionManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ConnectionManager, 0, "RecentConnectionReader.RecentConnectionReader", false, true);
    if (arg_this != nullptr) {
      RecentConnectionReader *return_value = new RecentConnectionReader(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_RecentConnectionReader, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "RecentConnectionReader(ConnectionManager manager)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_RecentConnectionReader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_RecentConnectionReader) {
    printf("RecentConnectionReader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  RecentConnectionReader *local_this = (RecentConnectionReader *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_RecentConnectionReader) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ConnectionReader) {
    return (ConnectionReader *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_RecentConnectionReader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_RecentConnectionReader) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ConnectionReader) {
    ConnectionReader* other_this = (ConnectionReader*)from_this;
    return (RecentConnectionReader*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for PointerTo_Connection (PointerTo_Connection)
 */
static PyMethodDef Dtool_Methods_PointerTo_Connection[] = {
  {"p", &Dtool_PointerTo_Connection_p_7, METH_NOARGS, (const char *)Dtool_PointerTo_Connection_p_7_comment},
  {"assign", &Dtool_PointerTo_Connection_operator_8, METH_O, (const char *)Dtool_PointerTo_Connection_operator_8_comment},
  {"is_null", &Dtool_PointerTo_Connection_is_null_9, METH_NOARGS, (const char *)Dtool_PointerTo_Connection_is_null_9_comment},
  {"isNull", &Dtool_PointerTo_Connection_is_null_9, METH_NOARGS, (const char *)Dtool_PointerTo_Connection_is_null_9_comment},
  {"clear", &Dtool_PointerTo_Connection_clear_10, METH_NOARGS, (const char *)Dtool_PointerTo_Connection_clear_10_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerTo_Connection = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerTo_Connection = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerTo_Connection = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerTo_Connection = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerTo_Connection = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerTo_Connection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerTo_Connection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerTo_Connection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerTo_Connection,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerTo_Connection,
    &Dtool_SequenceMethods_PointerTo_Connection,
    &Dtool_MappingMethods_PointerTo_Connection,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerTo_Connection,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerTo_Connection,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerTo_Connection,
    PyType_GenericAlloc,
    Dtool_new_PointerTo_Connection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerTo_Connection,
  Dtool_UpcastInterface_PointerTo_Connection,
  Dtool_DowncastInterface_PointerTo_Connection,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerTo_Connection,
};

static void Dtool_PyModuleClassInit_PointerTo_Connection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_Connection(nullptr);
    Dtool_PointerTo_Connection._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_Connection);
    Dtool_PointerTo_Connection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerTo_Connection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerTo_Connection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerTo_Connection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerTo_Connection);
  }
}

/**
 * Python method tables for PointerToBase_Connection (PointerToBase_Connection)
 */
static PyMethodDef Dtool_Methods_PointerToBase_Connection[] = {
  {"clear", &Dtool_PointerToBase_Connection_clear_4, METH_NOARGS, (const char *)Dtool_PointerToBase_Connection_clear_4_comment},
  {"output", &Dtool_PointerToBase_Connection_output_5, METH_O, (const char *)Dtool_PointerToBase_Connection_output_5_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_Connection
//////////////////
static PyObject *Dtool_Repr_PointerToBase_Connection(PyObject *self) {
  PointerToBase< Connection > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_Connection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_Connection = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_Connection = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_Connection = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_Connection = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_Connection = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_Connection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_Connection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_Connection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_Connection,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_Connection,
    &Dtool_NumberMethods_PointerToBase_Connection,
    &Dtool_SequenceMethods_PointerToBase_Connection,
    &Dtool_MappingMethods_PointerToBase_Connection,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_Connection,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_Connection,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_Connection,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_Connection,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_Connection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_Connection,
  Dtool_UpcastInterface_PointerToBase_Connection,
  Dtool_DowncastInterface_PointerToBase_Connection,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_Connection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != nullptr);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(nullptr);
    Dtool_PointerToBase_Connection._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    Dtool_PointerToBase_Connection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_Connection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_Connection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_Connection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_Connection);
  }
}

/**
 * Python method tables for NetAddress (NetAddress)
 */
static PyMethodDef Dtool_Methods_NetAddress[] = {
  {"set_any", &Dtool_NetAddress_set_any_14, METH_O, (const char *)Dtool_NetAddress_set_any_14_comment},
  {"setAny", &Dtool_NetAddress_set_any_14, METH_O, (const char *)Dtool_NetAddress_set_any_14_comment},
  {"set_localhost", &Dtool_NetAddress_set_localhost_15, METH_O, (const char *)Dtool_NetAddress_set_localhost_15_comment},
  {"setLocalhost", &Dtool_NetAddress_set_localhost_15, METH_O, (const char *)Dtool_NetAddress_set_localhost_15_comment},
  {"set_broadcast", &Dtool_NetAddress_set_broadcast_16, METH_O, (const char *)Dtool_NetAddress_set_broadcast_16_comment},
  {"setBroadcast", &Dtool_NetAddress_set_broadcast_16, METH_O, (const char *)Dtool_NetAddress_set_broadcast_16_comment},
  {"set_host", (PyCFunction) &Dtool_NetAddress_set_host_17, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NetAddress_set_host_17_comment},
  {"setHost", (PyCFunction) &Dtool_NetAddress_set_host_17, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_NetAddress_set_host_17_comment},
  {"clear", &Dtool_NetAddress_clear_18, METH_NOARGS, (const char *)Dtool_NetAddress_clear_18_comment},
  {"get_port", &Dtool_NetAddress_get_port_19, METH_NOARGS, (const char *)Dtool_NetAddress_get_port_19_comment},
  {"getPort", &Dtool_NetAddress_get_port_19, METH_NOARGS, (const char *)Dtool_NetAddress_get_port_19_comment},
  {"set_port", &Dtool_NetAddress_set_port_20, METH_O, (const char *)Dtool_NetAddress_set_port_20_comment},
  {"setPort", &Dtool_NetAddress_set_port_20, METH_O, (const char *)Dtool_NetAddress_set_port_20_comment},
  {"get_ip_string", &Dtool_NetAddress_get_ip_string_21, METH_NOARGS, (const char *)Dtool_NetAddress_get_ip_string_21_comment},
  {"getIpString", &Dtool_NetAddress_get_ip_string_21, METH_NOARGS, (const char *)Dtool_NetAddress_get_ip_string_21_comment},
  {"is_any", &Dtool_NetAddress_is_any_22, METH_NOARGS, (const char *)Dtool_NetAddress_is_any_22_comment},
  {"isAny", &Dtool_NetAddress_is_any_22, METH_NOARGS, (const char *)Dtool_NetAddress_is_any_22_comment},
  {"get_ip", &Dtool_NetAddress_get_ip_23, METH_NOARGS, (const char *)Dtool_NetAddress_get_ip_23_comment},
  {"getIp", &Dtool_NetAddress_get_ip_23, METH_NOARGS, (const char *)Dtool_NetAddress_get_ip_23_comment},
  {"get_ip_component", &Dtool_NetAddress_get_ip_component_24, METH_O, (const char *)Dtool_NetAddress_get_ip_component_24_comment},
  {"getIpComponent", &Dtool_NetAddress_get_ip_component_24, METH_O, (const char *)Dtool_NetAddress_get_ip_component_24_comment},
  {"get_addr", &Dtool_NetAddress_get_addr_25, METH_NOARGS, (const char *)Dtool_NetAddress_get_addr_25_comment},
  {"getAddr", &Dtool_NetAddress_get_addr_25, METH_NOARGS, (const char *)Dtool_NetAddress_get_addr_25_comment},
  {"output", &Dtool_NetAddress_output_26, METH_O, (const char *)Dtool_NetAddress_output_26_comment},
  {"get_hash", &Dtool_NetAddress_get_hash_27, METH_NOARGS, (const char *)Dtool_NetAddress_get_hash_27_comment},
  {"getHash", &Dtool_NetAddress_get_hash_27, METH_NOARGS, (const char *)Dtool_NetAddress_get_hash_27_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// NetAddress slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_NetAddress_get_hash_27_tp_hash(PyObject *self) {
  NetAddress *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetAddress, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) ((*local_this).get_hash)();
}

//////////////////
//  A __repr__ function
//     NetAddress
//////////////////
static PyObject *Dtool_Repr_NetAddress(PyObject *self) {
  NetAddress *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetAddress, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     NetAddress
//////////////////
static PyObject *Dtool_RichCompare_NetAddress(PyObject *self, PyObject *arg, int op) {
  NetAddress *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_NetAddress, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-bool NetAddress::operator ==(NetAddress const &other) const
      NetAddress arg_local;
      NetAddress const *arg_this = Dtool_Coerce_NetAddress(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const NetAddress*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-bool NetAddress::operator !=(NetAddress const &other) const
      NetAddress arg_local;
      NetAddress const *arg_this = Dtool_Coerce_NetAddress(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const NetAddress*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_NetAddress = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_NetAddress = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.NetAddress",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NetAddress,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    &Dtool_Repr_NetAddress,
    &Dtool_NumberMethods_NetAddress,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &Dtool_NetAddress_get_hash_27_tp_hash,
    nullptr,
    &Dtool_Repr_NetAddress,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Represents a network address to which UDP packets may be sent or to which a\n"
    " * TCP socket may be bound.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_NetAddress,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NetAddress,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NetAddress,
    PyType_GenericAlloc,
    Dtool_new_NetAddress,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NetAddress,
  Dtool_UpcastInterface_NetAddress,
  Dtool_DowncastInterface_NetAddress,
  nullptr,
  (CoerceFunction)Dtool_Coerce_NetAddress,
};

static void Dtool_PyModuleClassInit_NetAddress(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_NetAddress._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NetAddress._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NetAddress) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NetAddress)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NetAddress);
  }
}

/**
 * Python method tables for Connection (Connection)
 */
static PyMethodDef Dtool_Methods_Connection[] = {
  {"get_address", &Dtool_Connection_get_address_34, METH_NOARGS, (const char *)Dtool_Connection_get_address_34_comment},
  {"getAddress", &Dtool_Connection_get_address_34, METH_NOARGS, (const char *)Dtool_Connection_get_address_34_comment},
  {"get_manager", &Dtool_Connection_get_manager_35, METH_NOARGS, (const char *)Dtool_Connection_get_manager_35_comment},
  {"getManager", &Dtool_Connection_get_manager_35, METH_NOARGS, (const char *)Dtool_Connection_get_manager_35_comment},
  {"get_socket", &Dtool_Connection_get_socket_36, METH_NOARGS, (const char *)Dtool_Connection_get_socket_36_comment},
  {"getSocket", &Dtool_Connection_get_socket_36, METH_NOARGS, (const char *)Dtool_Connection_get_socket_36_comment},
  {"set_collect_tcp", &Dtool_Connection_set_collect_tcp_37, METH_O, (const char *)Dtool_Connection_set_collect_tcp_37_comment},
  {"setCollectTcp", &Dtool_Connection_set_collect_tcp_37, METH_O, (const char *)Dtool_Connection_set_collect_tcp_37_comment},
  {"get_collect_tcp", &Dtool_Connection_get_collect_tcp_38, METH_NOARGS, (const char *)Dtool_Connection_get_collect_tcp_38_comment},
  {"getCollectTcp", &Dtool_Connection_get_collect_tcp_38, METH_NOARGS, (const char *)Dtool_Connection_get_collect_tcp_38_comment},
  {"set_collect_tcp_interval", &Dtool_Connection_set_collect_tcp_interval_39, METH_O, (const char *)Dtool_Connection_set_collect_tcp_interval_39_comment},
  {"setCollectTcpInterval", &Dtool_Connection_set_collect_tcp_interval_39, METH_O, (const char *)Dtool_Connection_set_collect_tcp_interval_39_comment},
  {"get_collect_tcp_interval", &Dtool_Connection_get_collect_tcp_interval_40, METH_NOARGS, (const char *)Dtool_Connection_get_collect_tcp_interval_40_comment},
  {"getCollectTcpInterval", &Dtool_Connection_get_collect_tcp_interval_40, METH_NOARGS, (const char *)Dtool_Connection_get_collect_tcp_interval_40_comment},
  {"consider_flush", &Dtool_Connection_consider_flush_41, METH_NOARGS, (const char *)Dtool_Connection_consider_flush_41_comment},
  {"considerFlush", &Dtool_Connection_consider_flush_41, METH_NOARGS, (const char *)Dtool_Connection_consider_flush_41_comment},
  {"flush", &Dtool_Connection_flush_42, METH_NOARGS, (const char *)Dtool_Connection_flush_42_comment},
  {"set_linger", (PyCFunction) &Dtool_Connection_set_linger_43, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Connection_set_linger_43_comment},
  {"setLinger", (PyCFunction) &Dtool_Connection_set_linger_43, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Connection_set_linger_43_comment},
  {"set_reuse_addr", &Dtool_Connection_set_reuse_addr_44, METH_O, (const char *)Dtool_Connection_set_reuse_addr_44_comment},
  {"setReuseAddr", &Dtool_Connection_set_reuse_addr_44, METH_O, (const char *)Dtool_Connection_set_reuse_addr_44_comment},
  {"set_keep_alive", &Dtool_Connection_set_keep_alive_45, METH_O, (const char *)Dtool_Connection_set_keep_alive_45_comment},
  {"setKeepAlive", &Dtool_Connection_set_keep_alive_45, METH_O, (const char *)Dtool_Connection_set_keep_alive_45_comment},
  {"set_recv_buffer_size", &Dtool_Connection_set_recv_buffer_size_46, METH_O, (const char *)Dtool_Connection_set_recv_buffer_size_46_comment},
  {"setRecvBufferSize", &Dtool_Connection_set_recv_buffer_size_46, METH_O, (const char *)Dtool_Connection_set_recv_buffer_size_46_comment},
  {"set_send_buffer_size", &Dtool_Connection_set_send_buffer_size_47, METH_O, (const char *)Dtool_Connection_set_send_buffer_size_47_comment},
  {"setSendBufferSize", &Dtool_Connection_set_send_buffer_size_47, METH_O, (const char *)Dtool_Connection_set_send_buffer_size_47_comment},
  {"set_ip_time_to_live", &Dtool_Connection_set_ip_time_to_live_48, METH_O, (const char *)Dtool_Connection_set_ip_time_to_live_48_comment},
  {"setIpTimeToLive", &Dtool_Connection_set_ip_time_to_live_48, METH_O, (const char *)Dtool_Connection_set_ip_time_to_live_48_comment},
  {"set_ip_type_of_service", &Dtool_Connection_set_ip_type_of_service_49, METH_O, (const char *)Dtool_Connection_set_ip_type_of_service_49_comment},
  {"setIpTypeOfService", &Dtool_Connection_set_ip_type_of_service_49, METH_O, (const char *)Dtool_Connection_set_ip_type_of_service_49_comment},
  {"set_no_delay", &Dtool_Connection_set_no_delay_50, METH_O, (const char *)Dtool_Connection_set_no_delay_50_comment},
  {"setNoDelay", &Dtool_Connection_set_no_delay_50, METH_O, (const char *)Dtool_Connection_set_no_delay_50_comment},
  {"set_max_segment", &Dtool_Connection_set_max_segment_51, METH_O, (const char *)Dtool_Connection_set_max_segment_51_comment},
  {"setMaxSegment", &Dtool_Connection_set_max_segment_51, METH_O, (const char *)Dtool_Connection_set_max_segment_51_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_Connection = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Connection = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Connection = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Connection = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Connection = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Connection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Connection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Connection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Connection,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_Connection,
    &Dtool_SequenceMethods_Connection,
    &Dtool_MappingMethods_Connection,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Connection,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Represents a single TCP or UDP socket for input or output.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Connection,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Connection,
    PyType_GenericAlloc,
    Dtool_new_Connection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Connection,
  Dtool_UpcastInterface_Connection,
  Dtool_DowncastInterface_Connection,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Connection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_Connection._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_Connection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Connection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Connection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Connection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Connection);
  }
}

/**
 * Python method tables for ConnectionReader (ConnectionReader)
 */
static PyMethodDef Dtool_Methods_ConnectionReader[] = {
  {"add_connection", &Dtool_ConnectionReader_add_connection_54, METH_O, (const char *)Dtool_ConnectionReader_add_connection_54_comment},
  {"addConnection", &Dtool_ConnectionReader_add_connection_54, METH_O, (const char *)Dtool_ConnectionReader_add_connection_54_comment},
  {"remove_connection", &Dtool_ConnectionReader_remove_connection_55, METH_O, (const char *)Dtool_ConnectionReader_remove_connection_55_comment},
  {"removeConnection", &Dtool_ConnectionReader_remove_connection_55, METH_O, (const char *)Dtool_ConnectionReader_remove_connection_55_comment},
  {"is_connection_ok", &Dtool_ConnectionReader_is_connection_ok_56, METH_O, (const char *)Dtool_ConnectionReader_is_connection_ok_56_comment},
  {"isConnectionOk", &Dtool_ConnectionReader_is_connection_ok_56, METH_O, (const char *)Dtool_ConnectionReader_is_connection_ok_56_comment},
  {"poll", &Dtool_ConnectionReader_poll_57, METH_NOARGS, (const char *)Dtool_ConnectionReader_poll_57_comment},
  {"get_manager", &Dtool_ConnectionReader_get_manager_58, METH_NOARGS, (const char *)Dtool_ConnectionReader_get_manager_58_comment},
  {"getManager", &Dtool_ConnectionReader_get_manager_58, METH_NOARGS, (const char *)Dtool_ConnectionReader_get_manager_58_comment},
  {"is_polling", &Dtool_ConnectionReader_is_polling_59, METH_NOARGS, (const char *)Dtool_ConnectionReader_is_polling_59_comment},
  {"isPolling", &Dtool_ConnectionReader_is_polling_59, METH_NOARGS, (const char *)Dtool_ConnectionReader_is_polling_59_comment},
  {"get_num_threads", &Dtool_ConnectionReader_get_num_threads_60, METH_NOARGS, (const char *)Dtool_ConnectionReader_get_num_threads_60_comment},
  {"getNumThreads", &Dtool_ConnectionReader_get_num_threads_60, METH_NOARGS, (const char *)Dtool_ConnectionReader_get_num_threads_60_comment},
  {"set_raw_mode", &Dtool_ConnectionReader_set_raw_mode_61, METH_O, (const char *)Dtool_ConnectionReader_set_raw_mode_61_comment},
  {"setRawMode", &Dtool_ConnectionReader_set_raw_mode_61, METH_O, (const char *)Dtool_ConnectionReader_set_raw_mode_61_comment},
  {"get_raw_mode", &Dtool_ConnectionReader_get_raw_mode_62, METH_NOARGS, (const char *)Dtool_ConnectionReader_get_raw_mode_62_comment},
  {"getRawMode", &Dtool_ConnectionReader_get_raw_mode_62, METH_NOARGS, (const char *)Dtool_ConnectionReader_get_raw_mode_62_comment},
  {"set_tcp_header_size", &Dtool_ConnectionReader_set_tcp_header_size_63, METH_O, (const char *)Dtool_ConnectionReader_set_tcp_header_size_63_comment},
  {"setTcpHeaderSize", &Dtool_ConnectionReader_set_tcp_header_size_63, METH_O, (const char *)Dtool_ConnectionReader_set_tcp_header_size_63_comment},
  {"get_tcp_header_size", &Dtool_ConnectionReader_get_tcp_header_size_64, METH_NOARGS, (const char *)Dtool_ConnectionReader_get_tcp_header_size_64_comment},
  {"getTcpHeaderSize", &Dtool_ConnectionReader_get_tcp_header_size_64, METH_NOARGS, (const char *)Dtool_ConnectionReader_get_tcp_header_size_64_comment},
  {"shutdown", &Dtool_ConnectionReader_shutdown_65, METH_NOARGS, (const char *)Dtool_ConnectionReader_shutdown_65_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ConnectionReader = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ConnectionReader = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConnectionReader",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConnectionReader,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConnectionReader,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is an abstract base class for a family of classes that listen for\n"
    " * activity on a socket and respond to it, for instance by reading a datagram\n"
    " * and serving it (or queueing it up for later service).\n"
    " *\n"
    " * A ConnectionReader may define an arbitrary number of threads (at least one)\n"
    " * to process datagrams coming in from an arbitrary number of sockets that it\n"
    " * is monitoring.  The number of threads is specified at construction time and\n"
    " * cannot be changed, but the set of sockets that is to be monitored may be\n"
    " * constantly modified at will.\n"
    " *\n"
    " * This is an abstract class because it doesn't define how to process each\n"
    " * received datagram.  See QueuedConnectionReader.  Also note that\n"
    " * ConnectionListener derives from this class, extending it to accept\n"
    " * connections on a rendezvous socket rather than read datagrams.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConnectionReader,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConnectionReader,
    PyType_GenericAlloc,
    Dtool_new_ConnectionReader,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConnectionReader,
  Dtool_UpcastInterface_ConnectionReader,
  Dtool_DowncastInterface_ConnectionReader,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConnectionReader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ConnectionReader._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConnectionReader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConnectionReader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConnectionReader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConnectionReader);
  }
}

/**
 * Python method tables for ConnectionListener (ConnectionListener)
 */
static PyMethodDef Dtool_Methods_ConnectionListener[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ConnectionListener = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConnectionListener = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConnectionListener = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConnectionListener = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConnectionListener = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConnectionListener = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConnectionListener",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConnectionListener,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConnectionListener,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConnectionListener,
    &Dtool_SequenceMethods_ConnectionListener,
    &Dtool_MappingMethods_ConnectionListener,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConnectionListener,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special kind of ConnectionReader that waits for activity on a\n"
    " * rendezvous port and accepts a TCP connection (instead of attempting to read\n"
    " * a datagram from the rendezvous port).\n"
    " *\n"
    " * It is itself an abstract class, as it doesn't define what to do with the\n"
    " * established connection.  See QueuedConnectionListener.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConnectionListener,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConnectionListener,
    PyType_GenericAlloc,
    Dtool_new_ConnectionListener,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConnectionListener,
  Dtool_UpcastInterface_ConnectionListener,
  Dtool_DowncastInterface_ConnectionListener,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConnectionListener(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConnectionReader(nullptr);
    Dtool_ConnectionListener._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConnectionReader);
    Dtool_ConnectionListener._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConnectionListener._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConnectionListener) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConnectionListener)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConnectionListener);
  }
}

/**
 * Python method tables for NetDatagram (NetDatagram)
 */
static PyMethodDef Dtool_Methods_NetDatagram[] = {
  {"assign", &Dtool_NetDatagram_operator_71, METH_O, (const char *)Dtool_NetDatagram_operator_71_comment},
  {"set_connection", &Dtool_NetDatagram_set_connection_72, METH_O, (const char *)Dtool_NetDatagram_set_connection_72_comment},
  {"setConnection", &Dtool_NetDatagram_set_connection_72, METH_O, (const char *)Dtool_NetDatagram_set_connection_72_comment},
  {"get_connection", &Dtool_NetDatagram_get_connection_73, METH_NOARGS, (const char *)Dtool_NetDatagram_get_connection_73_comment},
  {"getConnection", &Dtool_NetDatagram_get_connection_73, METH_NOARGS, (const char *)Dtool_NetDatagram_get_connection_73_comment},
  {"set_address", &Dtool_NetDatagram_set_address_74, METH_O, (const char *)Dtool_NetDatagram_set_address_74_comment},
  {"setAddress", &Dtool_NetDatagram_set_address_74, METH_O, (const char *)Dtool_NetDatagram_set_address_74_comment},
  {"get_address", &Dtool_NetDatagram_get_address_75, METH_NOARGS, (const char *)Dtool_NetDatagram_get_address_75_comment},
  {"getAddress", &Dtool_NetDatagram_get_address_75, METH_NOARGS, (const char *)Dtool_NetDatagram_get_address_75_comment},
  {"get_class_type", &Dtool_NetDatagram_get_class_type_76, METH_NOARGS | METH_STATIC, (const char *)Dtool_NetDatagram_get_class_type_76_comment},
  {"getClassType", &Dtool_NetDatagram_get_class_type_76, METH_NOARGS | METH_STATIC, (const char *)Dtool_NetDatagram_get_class_type_76_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_NetDatagram = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NetDatagram = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_NetDatagram = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_NetDatagram = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_NetDatagram = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_NetDatagram = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.NetDatagram",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NetDatagram,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_NetDatagram,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_NetDatagram,
    &Dtool_SequenceMethods_NetDatagram,
    &Dtool_MappingMethods_NetDatagram,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_NetDatagram,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specific kind of Datagram, especially for sending across or receiving\n"
    " * from a network.  It's different only in that it knows which Connection\n"
    " * and/or NetAddress it is to be sent to or was received from.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NetDatagram,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NetDatagram,
    PyType_GenericAlloc,
    Dtool_new_NetDatagram,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NetDatagram,
  Dtool_UpcastInterface_NetDatagram,
  Dtool_DowncastInterface_NetDatagram,
  nullptr,
  (CoerceFunction)Dtool_Coerce_NetDatagram,
};

static void Dtool_PyModuleClassInit_NetDatagram(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_Datagram != nullptr);
    assert(Dtool_Ptr_Datagram->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Datagram->_Dtool_ModuleClassInit(nullptr);
    Dtool_NetDatagram._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_Datagram);
    Dtool_NetDatagram._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NetDatagram._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_NetDatagram) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NetDatagram)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NetDatagram);
  }
}

/**
 * Python method tables for ConnectionManager_Interface (Interface)
 */
static PyMethodDef Dtool_Methods_ConnectionManager_Interface[] = {
  {"get_name", &Dtool_ConnectionManager_Interface_get_name_88, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_name_88_comment},
  {"getName", &Dtool_ConnectionManager_Interface_get_name_88, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_name_88_comment},
  {"get_mac_address", &Dtool_ConnectionManager_Interface_get_mac_address_89, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_mac_address_89_comment},
  {"getMacAddress", &Dtool_ConnectionManager_Interface_get_mac_address_89, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_mac_address_89_comment},
  {"has_ip", &Dtool_ConnectionManager_Interface_has_ip_90, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_has_ip_90_comment},
  {"hasIp", &Dtool_ConnectionManager_Interface_has_ip_90, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_has_ip_90_comment},
  {"get_ip", &Dtool_ConnectionManager_Interface_get_ip_91, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_ip_91_comment},
  {"getIp", &Dtool_ConnectionManager_Interface_get_ip_91, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_ip_91_comment},
  {"has_netmask", &Dtool_ConnectionManager_Interface_has_netmask_92, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_has_netmask_92_comment},
  {"hasNetmask", &Dtool_ConnectionManager_Interface_has_netmask_92, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_has_netmask_92_comment},
  {"get_netmask", &Dtool_ConnectionManager_Interface_get_netmask_93, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_netmask_93_comment},
  {"getNetmask", &Dtool_ConnectionManager_Interface_get_netmask_93, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_netmask_93_comment},
  {"has_broadcast", &Dtool_ConnectionManager_Interface_has_broadcast_94, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_has_broadcast_94_comment},
  {"hasBroadcast", &Dtool_ConnectionManager_Interface_has_broadcast_94, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_has_broadcast_94_comment},
  {"get_broadcast", &Dtool_ConnectionManager_Interface_get_broadcast_95, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_broadcast_95_comment},
  {"getBroadcast", &Dtool_ConnectionManager_Interface_get_broadcast_95, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_broadcast_95_comment},
  {"has_p2p", &Dtool_ConnectionManager_Interface_has_p2p_96, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_has_p2p_96_comment},
  {"hasP2p", &Dtool_ConnectionManager_Interface_has_p2p_96, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_has_p2p_96_comment},
  {"get_p2p", &Dtool_ConnectionManager_Interface_get_p2p_97, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_p2p_97_comment},
  {"getP2p", &Dtool_ConnectionManager_Interface_get_p2p_97, METH_NOARGS, (const char *)Dtool_ConnectionManager_Interface_get_p2p_97_comment},
  {"output", &Dtool_ConnectionManager_Interface_output_98, METH_O, (const char *)Dtool_ConnectionManager_Interface_output_98_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     ConnectionManager_Interface
//////////////////
static PyObject *Dtool_Repr_ConnectionManager_Interface(PyObject *self) {
  ConnectionManager::Interface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConnectionManager_Interface, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ConnectionManager_Interface = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ConnectionManager_Interface = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.Interface",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConnectionManager_Interface,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_ConnectionManager_Interface,
    &Dtool_NumberMethods_ConnectionManager_Interface,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_ConnectionManager_Interface,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConnectionManager_Interface,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConnectionManager_Interface,
    PyType_GenericAlloc,
    Dtool_new_ConnectionManager_Interface,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConnectionManager_Interface,
  Dtool_UpcastInterface_ConnectionManager_Interface,
  Dtool_DowncastInterface_ConnectionManager_Interface,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConnectionManager_Interface(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ConnectionManager_Interface._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConnectionManager_Interface._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConnectionManager_Interface) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConnectionManager_Interface)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConnectionManager_Interface);
  }
}

/**
 * Python method tables for ConnectionManager (ConnectionManager)
 */
static PyMethodDef Dtool_Methods_ConnectionManager[] = {
  {"open_UDP_connection", (PyCFunction) &Dtool_ConnectionManager_open_UDP_connection_81, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConnectionManager_open_UDP_connection_81_comment},
  {"openUDPConnection", (PyCFunction) &Dtool_ConnectionManager_open_UDP_connection_81, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConnectionManager_open_UDP_connection_81_comment},
  {"open_TCP_server_rendezvous", (PyCFunction) &Dtool_ConnectionManager_open_TCP_server_rendezvous_82, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConnectionManager_open_TCP_server_rendezvous_82_comment},
  {"openTCPServerRendezvous", (PyCFunction) &Dtool_ConnectionManager_open_TCP_server_rendezvous_82, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConnectionManager_open_TCP_server_rendezvous_82_comment},
  {"open_TCP_client_connection", (PyCFunction) &Dtool_ConnectionManager_open_TCP_client_connection_83, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConnectionManager_open_TCP_client_connection_83_comment},
  {"openTCPClientConnection", (PyCFunction) &Dtool_ConnectionManager_open_TCP_client_connection_83, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConnectionManager_open_TCP_client_connection_83_comment},
  {"close_connection", &Dtool_ConnectionManager_close_connection_84, METH_O, (const char *)Dtool_ConnectionManager_close_connection_84_comment},
  {"closeConnection", &Dtool_ConnectionManager_close_connection_84, METH_O, (const char *)Dtool_ConnectionManager_close_connection_84_comment},
  {"wait_for_readers", &Dtool_ConnectionManager_wait_for_readers_85, METH_O, (const char *)Dtool_ConnectionManager_wait_for_readers_85_comment},
  {"waitForReaders", &Dtool_ConnectionManager_wait_for_readers_85, METH_O, (const char *)Dtool_ConnectionManager_wait_for_readers_85_comment},
  {"get_host_name", &Dtool_ConnectionManager_get_host_name_86, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConnectionManager_get_host_name_86_comment},
  {"getHostName", &Dtool_ConnectionManager_get_host_name_86, METH_NOARGS | METH_STATIC, (const char *)Dtool_ConnectionManager_get_host_name_86_comment},
  {"scan_interfaces", &Dtool_ConnectionManager_scan_interfaces_101, METH_NOARGS, (const char *)Dtool_ConnectionManager_scan_interfaces_101_comment},
  {"scanInterfaces", &Dtool_ConnectionManager_scan_interfaces_101, METH_NOARGS, (const char *)Dtool_ConnectionManager_scan_interfaces_101_comment},
  {"get_num_interfaces", &Dtool_ConnectionManager_get_num_interfaces_102, METH_NOARGS, (const char *)Dtool_ConnectionManager_get_num_interfaces_102_comment},
  {"getNumInterfaces", &Dtool_ConnectionManager_get_num_interfaces_102, METH_NOARGS, (const char *)Dtool_ConnectionManager_get_num_interfaces_102_comment},
  {"get_interface", &Dtool_ConnectionManager_get_interface_103, METH_O, (const char *)Dtool_ConnectionManager_get_interface_103_comment},
  {"getInterface", &Dtool_ConnectionManager_get_interface_103, METH_O, (const char *)Dtool_ConnectionManager_get_interface_103_comment},
  {"get_interfaces", (PyCFunction) &MakeSeq_ConnectionManager_get_interfaces, METH_NOARGS, nullptr},
  { "getInterfaces", (PyCFunction) &MakeSeq_ConnectionManager_get_interfaces, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ConnectionManager[] = {
  {(char *)"interfaces", &Dtool_ConnectionManager_interfaces_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ConnectionManager = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ConnectionManager = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConnectionManager",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConnectionManager,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConnectionManager,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The primary interface to the low-level networking layer in this package.  A\n"
    " * ConnectionManager is used to establish and destroy TCP and UDP connections.\n"
    " * Communication on these connections, once established, is handled via\n"
    " * ConnectionReader, ConnectionWriter, and ConnectionListener.\n"
    " *\n"
    " * You may use this class directly if you don't care about tracking which\n"
    " * connections have been unexpectedly closed; otherwise, you should use\n"
    " * QueuedConnectionManager to get reports about these events (or derive your\n"
    " * own class to handle these events properly).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConnectionManager,
    nullptr, // tp_members
    Dtool_Properties_ConnectionManager,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConnectionManager,
    PyType_GenericAlloc,
    Dtool_new_ConnectionManager,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConnectionManager,
  Dtool_UpcastInterface_ConnectionManager,
  Dtool_DowncastInterface_ConnectionManager,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConnectionManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ConnectionManager._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConnectionManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // Nested Object   ConnectionManager_Interface;
    Dtool_PyModuleClassInit_ConnectionManager_Interface(nullptr);
    PyDict_SetItemString(dict, "Interface", (PyObject *)&Dtool_ConnectionManager_Interface);
    static const PyGetSetDef def_host_name = {(char *)"host_name", &Dtool_ConnectionManager_host_name_Getter, nullptr, nullptr, nullptr};
    PyDict_SetItemString(dict, "host_name", Dtool_NewStaticProperty(&Dtool_ConnectionManager._PyType, &def_host_name));
    if (PyType_Ready((PyTypeObject *)&Dtool_ConnectionManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConnectionManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConnectionManager);
  }
}

/**
 * Python method tables for ConnectionWriter (ConnectionWriter)
 */
static PyMethodDef Dtool_Methods_ConnectionWriter[] = {
  {"set_max_queue_size", &Dtool_ConnectionWriter_set_max_queue_size_113, METH_O, (const char *)Dtool_ConnectionWriter_set_max_queue_size_113_comment},
  {"setMaxQueueSize", &Dtool_ConnectionWriter_set_max_queue_size_113, METH_O, (const char *)Dtool_ConnectionWriter_set_max_queue_size_113_comment},
  {"get_max_queue_size", &Dtool_ConnectionWriter_get_max_queue_size_114, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_max_queue_size_114_comment},
  {"getMaxQueueSize", &Dtool_ConnectionWriter_get_max_queue_size_114, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_max_queue_size_114_comment},
  {"get_current_queue_size", &Dtool_ConnectionWriter_get_current_queue_size_115, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_current_queue_size_115_comment},
  {"getCurrentQueueSize", &Dtool_ConnectionWriter_get_current_queue_size_115, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_current_queue_size_115_comment},
  {"send", (PyCFunction) &Dtool_ConnectionWriter_send_116, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConnectionWriter_send_116_comment},
  {"is_valid_for_udp", &Dtool_ConnectionWriter_is_valid_for_udp_117, METH_O, (const char *)Dtool_ConnectionWriter_is_valid_for_udp_117_comment},
  {"isValidForUdp", &Dtool_ConnectionWriter_is_valid_for_udp_117, METH_O, (const char *)Dtool_ConnectionWriter_is_valid_for_udp_117_comment},
  {"get_manager", &Dtool_ConnectionWriter_get_manager_118, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_manager_118_comment},
  {"getManager", &Dtool_ConnectionWriter_get_manager_118, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_manager_118_comment},
  {"is_immediate", &Dtool_ConnectionWriter_is_immediate_119, METH_NOARGS, (const char *)Dtool_ConnectionWriter_is_immediate_119_comment},
  {"isImmediate", &Dtool_ConnectionWriter_is_immediate_119, METH_NOARGS, (const char *)Dtool_ConnectionWriter_is_immediate_119_comment},
  {"get_num_threads", &Dtool_ConnectionWriter_get_num_threads_120, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_num_threads_120_comment},
  {"getNumThreads", &Dtool_ConnectionWriter_get_num_threads_120, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_num_threads_120_comment},
  {"set_raw_mode", &Dtool_ConnectionWriter_set_raw_mode_121, METH_O, (const char *)Dtool_ConnectionWriter_set_raw_mode_121_comment},
  {"setRawMode", &Dtool_ConnectionWriter_set_raw_mode_121, METH_O, (const char *)Dtool_ConnectionWriter_set_raw_mode_121_comment},
  {"get_raw_mode", &Dtool_ConnectionWriter_get_raw_mode_122, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_raw_mode_122_comment},
  {"getRawMode", &Dtool_ConnectionWriter_get_raw_mode_122, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_raw_mode_122_comment},
  {"set_tcp_header_size", &Dtool_ConnectionWriter_set_tcp_header_size_123, METH_O, (const char *)Dtool_ConnectionWriter_set_tcp_header_size_123_comment},
  {"setTcpHeaderSize", &Dtool_ConnectionWriter_set_tcp_header_size_123, METH_O, (const char *)Dtool_ConnectionWriter_set_tcp_header_size_123_comment},
  {"get_tcp_header_size", &Dtool_ConnectionWriter_get_tcp_header_size_124, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_tcp_header_size_124_comment},
  {"getTcpHeaderSize", &Dtool_ConnectionWriter_get_tcp_header_size_124, METH_NOARGS, (const char *)Dtool_ConnectionWriter_get_tcp_header_size_124_comment},
  {"shutdown", &Dtool_ConnectionWriter_shutdown_125, METH_NOARGS, (const char *)Dtool_ConnectionWriter_shutdown_125_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ConnectionWriter = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ConnectionWriter = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConnectionWriter",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConnectionWriter,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConnectionWriter,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class handles threaded delivery of datagrams to various TCP or UDP\n"
    " * sockets.\n"
    " *\n"
    " * A ConnectionWriter may define an arbitrary number of threads (0 or more) to\n"
    " * write its datagrams to sockets.  The number of threads is specified at\n"
    " * construction time and cannot be changed.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConnectionWriter,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConnectionWriter,
    PyType_GenericAlloc,
    Dtool_new_ConnectionWriter,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConnectionWriter,
  Dtool_UpcastInterface_ConnectionWriter,
  Dtool_DowncastInterface_ConnectionWriter,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ConnectionWriter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ConnectionWriter._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConnectionWriter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConnectionWriter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConnectionWriter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConnectionWriter);
  }
}

/**
 * Python method tables for DatagramGeneratorNet (DatagramGeneratorNet)
 */
static PyMethodDef Dtool_Methods_DatagramGeneratorNet[] = {
  {"get_datagram", &Dtool_DatagramGeneratorNet_get_datagram_142, METH_O, (const char *)Dtool_DatagramGeneratorNet_get_datagram_142_comment},
  {"getDatagram", &Dtool_DatagramGeneratorNet_get_datagram_142, METH_O, (const char *)Dtool_DatagramGeneratorNet_get_datagram_142_comment},
  {"is_eof", &Dtool_DatagramGeneratorNet_is_eof_143, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_is_eof_143_comment},
  {"isEof", &Dtool_DatagramGeneratorNet_is_eof_143, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_is_eof_143_comment},
  {"is_error", &Dtool_DatagramGeneratorNet_is_error_144, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_is_error_144_comment},
  {"isError", &Dtool_DatagramGeneratorNet_is_error_144, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_is_error_144_comment},
  {"upcast_to_DatagramGenerator", &Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_128, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_128_comment},
  {"upcastToDatagramGenerator", &Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_128, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_upcast_to_DatagramGenerator_128_comment},
  {"upcast_to_ConnectionReader", &Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_130, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_130_comment},
  {"upcastToConnectionReader", &Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_130, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_upcast_to_ConnectionReader_130_comment},
  {"upcast_to_QueuedReturn_Datagram", &Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_138, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_138_comment},
  {"upcastToQueuedReturnDatagram", &Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_138, METH_NOARGS, (const char *)Dtool_DatagramGeneratorNet_upcast_to_QueuedReturn_Datagram_138_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DatagramGeneratorNet = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DatagramGeneratorNet = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DatagramGeneratorNet = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DatagramGeneratorNet = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DatagramGeneratorNet = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DatagramGeneratorNet = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DatagramGeneratorNet",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DatagramGeneratorNet,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DatagramGeneratorNet,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DatagramGeneratorNet,
    &Dtool_SequenceMethods_DatagramGeneratorNet,
    &Dtool_MappingMethods_DatagramGeneratorNet,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DatagramGeneratorNet,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class provides datagrams one-at-a-time as read directly from the net,\n"
    " * via a TCP connection.  If a datagram is not available, get_datagram() will\n"
    " * block until one is.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DatagramGeneratorNet,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DatagramGeneratorNet,
    PyType_GenericAlloc,
    Dtool_new_DatagramGeneratorNet,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DatagramGeneratorNet,
  Dtool_UpcastInterface_DatagramGeneratorNet,
  Dtool_DowncastInterface_DatagramGeneratorNet,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DatagramGeneratorNet(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DatagramGenerator != nullptr);
    assert(Dtool_Ptr_DatagramGenerator->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_DatagramGenerator->_Dtool_ModuleClassInit(nullptr);
    Dtool_PyModuleClassInit_ConnectionReader(nullptr);
    Dtool_PyModuleClassInit_QueuedReturn_Datagram(nullptr);
    Dtool_DatagramGeneratorNet._PyType.tp_bases = PyTuple_Pack(3, (PyTypeObject *)Dtool_Ptr_DatagramGenerator, (PyTypeObject *)&Dtool_ConnectionReader, (PyTypeObject *)&Dtool_QueuedReturn_Datagram);
    Dtool_DatagramGeneratorNet._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DatagramGeneratorNet._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DatagramGeneratorNet) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DatagramGeneratorNet)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DatagramGeneratorNet);
  }
}

/**
 * Python method tables for QueuedReturn_Datagram (QueuedReturn_Datagram)
 */
static PyMethodDef Dtool_Methods_QueuedReturn_Datagram[] = {
  {"set_max_queue_size", &Dtool_QueuedReturn_Datagram_set_max_queue_size_133, METH_O, (const char *)Dtool_QueuedReturn_Datagram_set_max_queue_size_133_comment},
  {"setMaxQueueSize", &Dtool_QueuedReturn_Datagram_set_max_queue_size_133, METH_O, (const char *)Dtool_QueuedReturn_Datagram_set_max_queue_size_133_comment},
  {"get_max_queue_size", &Dtool_QueuedReturn_Datagram_get_max_queue_size_134, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_get_max_queue_size_134_comment},
  {"getMaxQueueSize", &Dtool_QueuedReturn_Datagram_get_max_queue_size_134, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_get_max_queue_size_134_comment},
  {"get_current_queue_size", &Dtool_QueuedReturn_Datagram_get_current_queue_size_135, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_get_current_queue_size_135_comment},
  {"getCurrentQueueSize", &Dtool_QueuedReturn_Datagram_get_current_queue_size_135, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_get_current_queue_size_135_comment},
  {"get_overflow_flag", &Dtool_QueuedReturn_Datagram_get_overflow_flag_136, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_get_overflow_flag_136_comment},
  {"getOverflowFlag", &Dtool_QueuedReturn_Datagram_get_overflow_flag_136, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_get_overflow_flag_136_comment},
  {"reset_overflow_flag", &Dtool_QueuedReturn_Datagram_reset_overflow_flag_137, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_reset_overflow_flag_137_comment},
  {"resetOverflowFlag", &Dtool_QueuedReturn_Datagram_reset_overflow_flag_137, METH_NOARGS, (const char *)Dtool_QueuedReturn_Datagram_reset_overflow_flag_137_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_QueuedReturn_Datagram = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_QueuedReturn_Datagram = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.QueuedReturn_Datagram",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_QueuedReturn_Datagram,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_QueuedReturn_Datagram,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_QueuedReturn_Datagram,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_QueuedReturn_Datagram,
    PyType_GenericAlloc,
    Dtool_new_QueuedReturn_Datagram,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_QueuedReturn_Datagram,
  Dtool_UpcastInterface_QueuedReturn_Datagram,
  Dtool_DowncastInterface_QueuedReturn_Datagram,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_QueuedReturn_Datagram(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_QueuedReturn_Datagram._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_QueuedReturn_Datagram._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_QueuedReturn_Datagram) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(QueuedReturn_Datagram)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_QueuedReturn_Datagram);
  }
}

/**
 * Python method tables for DatagramSinkNet (DatagramSinkNet)
 */
static PyMethodDef Dtool_Methods_DatagramSinkNet[] = {
  {"set_target", &Dtool_DatagramSinkNet_set_target_152, METH_O, (const char *)Dtool_DatagramSinkNet_set_target_152_comment},
  {"setTarget", &Dtool_DatagramSinkNet_set_target_152, METH_O, (const char *)Dtool_DatagramSinkNet_set_target_152_comment},
  {"get_target", &Dtool_DatagramSinkNet_get_target_153, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_get_target_153_comment},
  {"getTarget", &Dtool_DatagramSinkNet_get_target_153, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_get_target_153_comment},
  {"put_datagram", &Dtool_DatagramSinkNet_put_datagram_154, METH_O, (const char *)Dtool_DatagramSinkNet_put_datagram_154_comment},
  {"putDatagram", &Dtool_DatagramSinkNet_put_datagram_154, METH_O, (const char *)Dtool_DatagramSinkNet_put_datagram_154_comment},
  {"is_error", &Dtool_DatagramSinkNet_is_error_155, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_is_error_155_comment},
  {"isError", &Dtool_DatagramSinkNet_is_error_155, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_is_error_155_comment},
  {"flush", &Dtool_DatagramSinkNet_flush_156, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_flush_156_comment},
  {"upcast_to_DatagramSink", &Dtool_DatagramSinkNet_upcast_to_DatagramSink_147, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_upcast_to_DatagramSink_147_comment},
  {"upcastToDatagramSink", &Dtool_DatagramSinkNet_upcast_to_DatagramSink_147, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_upcast_to_DatagramSink_147_comment},
  {"upcast_to_ConnectionWriter", &Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_149, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_149_comment},
  {"upcastToConnectionWriter", &Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_149, METH_NOARGS, (const char *)Dtool_DatagramSinkNet_upcast_to_ConnectionWriter_149_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DatagramSinkNet = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DatagramSinkNet = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DatagramSinkNet = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DatagramSinkNet = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DatagramSinkNet = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DatagramSinkNet = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DatagramSinkNet",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DatagramSinkNet,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DatagramSinkNet,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DatagramSinkNet,
    &Dtool_SequenceMethods_DatagramSinkNet,
    &Dtool_MappingMethods_DatagramSinkNet,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DatagramSinkNet,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class accepts datagrams one-at-a-time and sends them over the net, via\n"
    " * a TCP connection.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DatagramSinkNet,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DatagramSinkNet,
    PyType_GenericAlloc,
    Dtool_new_DatagramSinkNet,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DatagramSinkNet,
  Dtool_UpcastInterface_DatagramSinkNet,
  Dtool_DowncastInterface_DatagramSinkNet,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DatagramSinkNet(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DatagramSink != nullptr);
    assert(Dtool_Ptr_DatagramSink->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_DatagramSink->_Dtool_ModuleClassInit(nullptr);
    Dtool_PyModuleClassInit_ConnectionWriter(nullptr);
    Dtool_DatagramSinkNet._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_DatagramSink, (PyTypeObject *)&Dtool_ConnectionWriter);
    Dtool_DatagramSinkNet._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DatagramSinkNet._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DatagramSinkNet) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DatagramSinkNet)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DatagramSinkNet);
  }
}

/**
 * Python method tables for QueuedConnectionListener (QueuedConnectionListener)
 */
static PyMethodDef Dtool_Methods_QueuedConnectionListener[] = {
  {"new_connection_available", &Dtool_QueuedConnectionListener_new_connection_available_171, METH_NOARGS, (const char *)Dtool_QueuedConnectionListener_new_connection_available_171_comment},
  {"newConnectionAvailable", &Dtool_QueuedConnectionListener_new_connection_available_171, METH_NOARGS, (const char *)Dtool_QueuedConnectionListener_new_connection_available_171_comment},
  {"get_new_connection", (PyCFunction) &Dtool_QueuedConnectionListener_get_new_connection_172, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_QueuedConnectionListener_get_new_connection_172_comment},
  {"getNewConnection", (PyCFunction) &Dtool_QueuedConnectionListener_get_new_connection_172, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_QueuedConnectionListener_get_new_connection_172_comment},
  {"upcast_to_ConnectionListener", &Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_159, METH_NOARGS, (const char *)Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_159_comment},
  {"upcastToConnectionListener", &Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_159, METH_NOARGS, (const char *)Dtool_QueuedConnectionListener_upcast_to_ConnectionListener_159_comment},
  {"upcast_to_QueuedReturn_ConnectionListenerData", &Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_167, METH_NOARGS, (const char *)Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_167_comment},
  {"upcastToQueuedReturnConnectionListenerData", &Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_167, METH_NOARGS, (const char *)Dtool_QueuedConnectionListener_upcast_to_QueuedReturn_ConnectionListenerData_167_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_QueuedConnectionListener = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_QueuedConnectionListener = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_QueuedConnectionListener = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_QueuedConnectionListener = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_QueuedConnectionListener = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_QueuedConnectionListener = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.QueuedConnectionListener",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_QueuedConnectionListener,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_QueuedConnectionListener,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_QueuedConnectionListener,
    &Dtool_SequenceMethods_QueuedConnectionListener,
    &Dtool_MappingMethods_QueuedConnectionListener,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_QueuedConnectionListener,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This flavor of ConnectionListener will queue up all of the TCP connections\n"
    " * it established for later detection by the client code.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_QueuedConnectionListener,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_QueuedConnectionListener,
    PyType_GenericAlloc,
    Dtool_new_QueuedConnectionListener,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_QueuedConnectionListener,
  Dtool_UpcastInterface_QueuedConnectionListener,
  Dtool_DowncastInterface_QueuedConnectionListener,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_QueuedConnectionListener(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConnectionListener(nullptr);
    Dtool_PyModuleClassInit_QueuedReturn_ConnectionListenerData(nullptr);
    Dtool_QueuedConnectionListener._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_ConnectionListener, (PyTypeObject *)&Dtool_QueuedReturn_ConnectionListenerData);
    Dtool_QueuedConnectionListener._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_QueuedConnectionListener._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_QueuedConnectionListener) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(QueuedConnectionListener)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_QueuedConnectionListener);
  }
}

/**
 * Python method tables for QueuedReturn_ConnectionListenerData (QueuedReturn_ConnectionListenerData)
 */
static PyMethodDef Dtool_Methods_QueuedReturn_ConnectionListenerData[] = {
  {"set_max_queue_size", &Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_162, METH_O, (const char *)Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_162_comment},
  {"setMaxQueueSize", &Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_162, METH_O, (const char *)Dtool_QueuedReturn_ConnectionListenerData_set_max_queue_size_162_comment},
  {"get_max_queue_size", &Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_163, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_163_comment},
  {"getMaxQueueSize", &Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_163, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_get_max_queue_size_163_comment},
  {"get_current_queue_size", &Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_164, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_164_comment},
  {"getCurrentQueueSize", &Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_164, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_get_current_queue_size_164_comment},
  {"get_overflow_flag", &Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_165, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_165_comment},
  {"getOverflowFlag", &Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_165, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_get_overflow_flag_165_comment},
  {"reset_overflow_flag", &Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_166, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_166_comment},
  {"resetOverflowFlag", &Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_166, METH_NOARGS, (const char *)Dtool_QueuedReturn_ConnectionListenerData_reset_overflow_flag_166_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_QueuedReturn_ConnectionListenerData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_QueuedReturn_ConnectionListenerData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.QueuedReturn_ConnectionListenerData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_QueuedReturn_ConnectionListenerData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_QueuedReturn_ConnectionListenerData,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_QueuedReturn_ConnectionListenerData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_QueuedReturn_ConnectionListenerData,
    PyType_GenericAlloc,
    Dtool_new_QueuedReturn_ConnectionListenerData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_QueuedReturn_ConnectionListenerData,
  Dtool_UpcastInterface_QueuedReturn_ConnectionListenerData,
  Dtool_DowncastInterface_QueuedReturn_ConnectionListenerData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_QueuedReturn_ConnectionListenerData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_QueuedReturn_ConnectionListenerData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_QueuedReturn_ConnectionListenerData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_QueuedReturn_ConnectionListenerData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(QueuedReturn_ConnectionListenerData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_QueuedReturn_ConnectionListenerData);
  }
}

/**
 * Python method tables for QueuedConnectionManager (QueuedConnectionManager)
 */
static PyMethodDef Dtool_Methods_QueuedConnectionManager[] = {
  {"reset_connection_available", &Dtool_QueuedConnectionManager_reset_connection_available_186, METH_NOARGS, (const char *)Dtool_QueuedConnectionManager_reset_connection_available_186_comment},
  {"resetConnectionAvailable", &Dtool_QueuedConnectionManager_reset_connection_available_186, METH_NOARGS, (const char *)Dtool_QueuedConnectionManager_reset_connection_available_186_comment},
  {"get_reset_connection", &Dtool_QueuedConnectionManager_get_reset_connection_187, METH_O, (const char *)Dtool_QueuedConnectionManager_get_reset_connection_187_comment},
  {"getResetConnection", &Dtool_QueuedConnectionManager_get_reset_connection_187, METH_O, (const char *)Dtool_QueuedConnectionManager_get_reset_connection_187_comment},
  {"upcast_to_ConnectionManager", &Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_174, METH_NOARGS, (const char *)Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_174_comment},
  {"upcastToConnectionManager", &Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_174, METH_NOARGS, (const char *)Dtool_QueuedConnectionManager_upcast_to_ConnectionManager_174_comment},
  {"upcast_to_QueuedReturn_PointerTo_Connection", &Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_182, METH_NOARGS, (const char *)Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_182_comment},
  {"upcastToQueuedReturnPointerToConnection", &Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_182, METH_NOARGS, (const char *)Dtool_QueuedConnectionManager_upcast_to_QueuedReturn_PointerTo_Connection_182_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_QueuedConnectionManager = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_QueuedConnectionManager = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_QueuedConnectionManager = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_QueuedConnectionManager = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_QueuedConnectionManager = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_QueuedConnectionManager = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.QueuedConnectionManager",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_QueuedConnectionManager,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_QueuedConnectionManager,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_QueuedConnectionManager,
    &Dtool_SequenceMethods_QueuedConnectionManager,
    &Dtool_MappingMethods_QueuedConnectionManager,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_QueuedConnectionManager,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This flavor of ConnectionManager will queue up all of the reset-connection\n"
    " * messages from the ConnectionReaders and ConnectionWriters and report them\n"
    " * to the client on demand.\n"
    " *\n"
    " * When a reset connection has been discovered via\n"
    " * reset_connection_available()/get_reset_connection(), it is still the\n"
    " * responsibility of the client to call close_connection() on that connection\n"
    " * to free up its resources.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_QueuedConnectionManager,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_QueuedConnectionManager,
    PyType_GenericAlloc,
    Dtool_new_QueuedConnectionManager,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_QueuedConnectionManager,
  Dtool_UpcastInterface_QueuedConnectionManager,
  Dtool_DowncastInterface_QueuedConnectionManager,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_QueuedConnectionManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConnectionManager(nullptr);
    Dtool_PyModuleClassInit_QueuedReturn_PointerTo_Connection(nullptr);
    Dtool_QueuedConnectionManager._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_ConnectionManager, (PyTypeObject *)&Dtool_QueuedReturn_PointerTo_Connection);
    Dtool_QueuedConnectionManager._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_QueuedConnectionManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_QueuedConnectionManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(QueuedConnectionManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_QueuedConnectionManager);
  }
}

/**
 * Python method tables for QueuedReturn_PointerTo_Connection (QueuedReturn_PointerTo_Connection)
 */
static PyMethodDef Dtool_Methods_QueuedReturn_PointerTo_Connection[] = {
  {"set_max_queue_size", &Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_177, METH_O, (const char *)Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_177_comment},
  {"setMaxQueueSize", &Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_177, METH_O, (const char *)Dtool_QueuedReturn_PointerTo_Connection_set_max_queue_size_177_comment},
  {"get_max_queue_size", &Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_178, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_178_comment},
  {"getMaxQueueSize", &Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_178, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_get_max_queue_size_178_comment},
  {"get_current_queue_size", &Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_179, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_179_comment},
  {"getCurrentQueueSize", &Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_179, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_get_current_queue_size_179_comment},
  {"get_overflow_flag", &Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_180, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_180_comment},
  {"getOverflowFlag", &Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_180, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_get_overflow_flag_180_comment},
  {"reset_overflow_flag", &Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_181, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_181_comment},
  {"resetOverflowFlag", &Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_181, METH_NOARGS, (const char *)Dtool_QueuedReturn_PointerTo_Connection_reset_overflow_flag_181_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_QueuedReturn_PointerTo_Connection = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_QueuedReturn_PointerTo_Connection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.QueuedReturn_PointerTo_Connection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_QueuedReturn_PointerTo_Connection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_QueuedReturn_PointerTo_Connection,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_QueuedReturn_PointerTo_Connection,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_QueuedReturn_PointerTo_Connection,
    PyType_GenericAlloc,
    Dtool_new_QueuedReturn_PointerTo_Connection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_QueuedReturn_PointerTo_Connection,
  Dtool_UpcastInterface_QueuedReturn_PointerTo_Connection,
  Dtool_DowncastInterface_QueuedReturn_PointerTo_Connection,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_QueuedReturn_PointerTo_Connection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_QueuedReturn_PointerTo_Connection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_QueuedReturn_PointerTo_Connection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_QueuedReturn_PointerTo_Connection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(QueuedReturn_PointerTo_Connection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_QueuedReturn_PointerTo_Connection);
  }
}

/**
 * Python method tables for QueuedConnectionReader (QueuedConnectionReader)
 */
static PyMethodDef Dtool_Methods_QueuedConnectionReader[] = {
  {"data_available", &Dtool_QueuedConnectionReader_data_available_201, METH_NOARGS, (const char *)Dtool_QueuedConnectionReader_data_available_201_comment},
  {"dataAvailable", &Dtool_QueuedConnectionReader_data_available_201, METH_NOARGS, (const char *)Dtool_QueuedConnectionReader_data_available_201_comment},
  {"get_data", &Dtool_QueuedConnectionReader_get_data_202, METH_O, (const char *)Dtool_QueuedConnectionReader_get_data_202_comment},
  {"getData", &Dtool_QueuedConnectionReader_get_data_202, METH_O, (const char *)Dtool_QueuedConnectionReader_get_data_202_comment},
  {"upcast_to_ConnectionReader", &Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_189, METH_NOARGS, (const char *)Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_189_comment},
  {"upcastToConnectionReader", &Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_189, METH_NOARGS, (const char *)Dtool_QueuedConnectionReader_upcast_to_ConnectionReader_189_comment},
  {"upcast_to_QueuedReturn_NetDatagram", &Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_197, METH_NOARGS, (const char *)Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_197_comment},
  {"upcastToQueuedReturnNetDatagram", &Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_197, METH_NOARGS, (const char *)Dtool_QueuedConnectionReader_upcast_to_QueuedReturn_NetDatagram_197_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_QueuedConnectionReader = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_QueuedConnectionReader = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_QueuedConnectionReader = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_QueuedConnectionReader = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_QueuedConnectionReader = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_QueuedConnectionReader = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.QueuedConnectionReader",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_QueuedConnectionReader,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_QueuedConnectionReader,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_QueuedConnectionReader,
    &Dtool_SequenceMethods_QueuedConnectionReader,
    &Dtool_MappingMethods_QueuedConnectionReader,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_QueuedConnectionReader,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This flavor of ConnectionReader will read from its sockets and queue up all\n"
    " * of the datagrams read for later receipt by the client code.  This class is\n"
    " * useful for client code that doesn't want to deal with threading and is\n"
    " * willing to poll for datagrams at its convenience.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_QueuedConnectionReader,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_QueuedConnectionReader,
    PyType_GenericAlloc,
    Dtool_new_QueuedConnectionReader,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_QueuedConnectionReader,
  Dtool_UpcastInterface_QueuedConnectionReader,
  Dtool_DowncastInterface_QueuedConnectionReader,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_QueuedConnectionReader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConnectionReader(nullptr);
    Dtool_PyModuleClassInit_QueuedReturn_NetDatagram(nullptr);
    Dtool_QueuedConnectionReader._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_ConnectionReader, (PyTypeObject *)&Dtool_QueuedReturn_NetDatagram);
    Dtool_QueuedConnectionReader._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_QueuedConnectionReader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_QueuedConnectionReader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(QueuedConnectionReader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_QueuedConnectionReader);
  }
}

/**
 * Python method tables for QueuedReturn_NetDatagram (QueuedReturn_NetDatagram)
 */
static PyMethodDef Dtool_Methods_QueuedReturn_NetDatagram[] = {
  {"set_max_queue_size", &Dtool_QueuedReturn_NetDatagram_set_max_queue_size_192, METH_O, (const char *)Dtool_QueuedReturn_NetDatagram_set_max_queue_size_192_comment},
  {"setMaxQueueSize", &Dtool_QueuedReturn_NetDatagram_set_max_queue_size_192, METH_O, (const char *)Dtool_QueuedReturn_NetDatagram_set_max_queue_size_192_comment},
  {"get_max_queue_size", &Dtool_QueuedReturn_NetDatagram_get_max_queue_size_193, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_get_max_queue_size_193_comment},
  {"getMaxQueueSize", &Dtool_QueuedReturn_NetDatagram_get_max_queue_size_193, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_get_max_queue_size_193_comment},
  {"get_current_queue_size", &Dtool_QueuedReturn_NetDatagram_get_current_queue_size_194, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_get_current_queue_size_194_comment},
  {"getCurrentQueueSize", &Dtool_QueuedReturn_NetDatagram_get_current_queue_size_194, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_get_current_queue_size_194_comment},
  {"get_overflow_flag", &Dtool_QueuedReturn_NetDatagram_get_overflow_flag_195, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_get_overflow_flag_195_comment},
  {"getOverflowFlag", &Dtool_QueuedReturn_NetDatagram_get_overflow_flag_195, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_get_overflow_flag_195_comment},
  {"reset_overflow_flag", &Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_196, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_196_comment},
  {"resetOverflowFlag", &Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_196, METH_NOARGS, (const char *)Dtool_QueuedReturn_NetDatagram_reset_overflow_flag_196_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_QueuedReturn_NetDatagram = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_QueuedReturn_NetDatagram = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.QueuedReturn_NetDatagram",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_QueuedReturn_NetDatagram,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_QueuedReturn_NetDatagram,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_QueuedReturn_NetDatagram,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_QueuedReturn_NetDatagram,
    PyType_GenericAlloc,
    Dtool_new_QueuedReturn_NetDatagram,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_QueuedReturn_NetDatagram,
  Dtool_UpcastInterface_QueuedReturn_NetDatagram,
  Dtool_DowncastInterface_QueuedReturn_NetDatagram,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_QueuedReturn_NetDatagram(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_QueuedReturn_NetDatagram._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_QueuedReturn_NetDatagram._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_QueuedReturn_NetDatagram) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(QueuedReturn_NetDatagram)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_QueuedReturn_NetDatagram);
  }
}

/**
 * Python method tables for RecentConnectionReader (RecentConnectionReader)
 */
static PyMethodDef Dtool_Methods_RecentConnectionReader[] = {
  {"data_available", &Dtool_RecentConnectionReader_data_available_205, METH_NOARGS, (const char *)Dtool_RecentConnectionReader_data_available_205_comment},
  {"dataAvailable", &Dtool_RecentConnectionReader_data_available_205, METH_NOARGS, (const char *)Dtool_RecentConnectionReader_data_available_205_comment},
  {"get_data", &Dtool_RecentConnectionReader_get_data_206, METH_O, (const char *)Dtool_RecentConnectionReader_get_data_206_comment},
  {"getData", &Dtool_RecentConnectionReader_get_data_206, METH_O, (const char *)Dtool_RecentConnectionReader_get_data_206_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_RecentConnectionReader = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_RecentConnectionReader = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_RecentConnectionReader = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_RecentConnectionReader = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_RecentConnectionReader = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_RecentConnectionReader = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.RecentConnectionReader",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_RecentConnectionReader,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_RecentConnectionReader,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_RecentConnectionReader,
    &Dtool_SequenceMethods_RecentConnectionReader,
    &Dtool_MappingMethods_RecentConnectionReader,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_RecentConnectionReader,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This flavor of ConnectionReader will read from its sockets and retain only\n"
    " * the single most recent datagram for inspection by client code.  It's useful\n"
    " * particularly for reading telemetry-type data from UDP sockets where you\n"
    " * don't care about getting every last socket, and in fact if the sockets are\n"
    " * coming too fast you'd prefer to skip some of them.\n"
    " *\n"
    " * This class will always create one thread for itself.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_RecentConnectionReader,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_RecentConnectionReader,
    PyType_GenericAlloc,
    Dtool_new_RecentConnectionReader,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_RecentConnectionReader,
  Dtool_UpcastInterface_RecentConnectionReader,
  Dtool_DowncastInterface_RecentConnectionReader,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_RecentConnectionReader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ConnectionReader(nullptr);
    Dtool_RecentConnectionReader._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ConnectionReader);
    Dtool_RecentConnectionReader._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_RecentConnectionReader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_RecentConnectionReader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(RecentConnectionReader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_RecentConnectionReader);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3net_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    NetDatagram::init_type();
    TypeHandle handle = NetDatagram::get_class_type();
    Dtool_NetDatagram._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_NetDatagram);
  }
}

void Dtool_libp3net_BuildInstants(PyObject *module) {
  (void) module;
  // PointerTo< Connection >
  Dtool_PyModuleClassInit_PointerTo_Connection(module);
  PyModule_AddObject(module, "PointerTo_Connection", (PyObject *)&Dtool_PointerTo_Connection);
  Py_INCREF(Dtool_Ptr_PointerTo_Connection);
  PyModule_AddObject(module, "PointerToConnection", (PyObject *)&Dtool_PointerTo_Connection);
  // PointerToBase< Connection >
  Dtool_PyModuleClassInit_PointerToBase_Connection(module);
  PyModule_AddObject(module, "PointerToBase_Connection", (PyObject *)&Dtool_PointerToBase_Connection);
  Py_INCREF(Dtool_Ptr_PointerToBase_Connection);
  PyModule_AddObject(module, "PointerToBaseConnection", (PyObject *)&Dtool_PointerToBase_Connection);
  // NetAddress
  Dtool_PyModuleClassInit_NetAddress(module);
  PyModule_AddObject(module, "NetAddress", (PyObject *)&Dtool_NetAddress);
  // Connection
  Dtool_PyModuleClassInit_Connection(module);
  PyModule_AddObject(module, "Connection", (PyObject *)&Dtool_Connection);
  // ConnectionReader
  Dtool_PyModuleClassInit_ConnectionReader(module);
  PyModule_AddObject(module, "ConnectionReader", (PyObject *)&Dtool_ConnectionReader);
  // ConnectionListener
  Dtool_PyModuleClassInit_ConnectionListener(module);
  PyModule_AddObject(module, "ConnectionListener", (PyObject *)&Dtool_ConnectionListener);
  // NetDatagram
  Dtool_PyModuleClassInit_NetDatagram(module);
  PyModule_AddObject(module, "NetDatagram", (PyObject *)&Dtool_NetDatagram);
  // ConnectionManager
  Dtool_PyModuleClassInit_ConnectionManager(module);
  PyModule_AddObject(module, "ConnectionManager", (PyObject *)&Dtool_ConnectionManager);
  // ConnectionWriter
  Dtool_PyModuleClassInit_ConnectionWriter(module);
  PyModule_AddObject(module, "ConnectionWriter", (PyObject *)&Dtool_ConnectionWriter);
  // DatagramGeneratorNet
  Dtool_PyModuleClassInit_DatagramGeneratorNet(module);
  PyModule_AddObject(module, "DatagramGeneratorNet", (PyObject *)&Dtool_DatagramGeneratorNet);
  // QueuedReturn< Datagram >
  Dtool_PyModuleClassInit_QueuedReturn_Datagram(module);
  PyModule_AddObject(module, "QueuedReturn_Datagram", (PyObject *)&Dtool_QueuedReturn_Datagram);
  Py_INCREF(Dtool_Ptr_QueuedReturn_Datagram);
  PyModule_AddObject(module, "QueuedReturnDatagram", (PyObject *)&Dtool_QueuedReturn_Datagram);
  // DatagramSinkNet
  Dtool_PyModuleClassInit_DatagramSinkNet(module);
  PyModule_AddObject(module, "DatagramSinkNet", (PyObject *)&Dtool_DatagramSinkNet);
  // QueuedConnectionListener
  Dtool_PyModuleClassInit_QueuedConnectionListener(module);
  PyModule_AddObject(module, "QueuedConnectionListener", (PyObject *)&Dtool_QueuedConnectionListener);
  // QueuedReturn< ConnectionListenerData >
  Dtool_PyModuleClassInit_QueuedReturn_ConnectionListenerData(module);
  PyModule_AddObject(module, "QueuedReturn_ConnectionListenerData", (PyObject *)&Dtool_QueuedReturn_ConnectionListenerData);
  Py_INCREF(Dtool_Ptr_QueuedReturn_ConnectionListenerData);
  PyModule_AddObject(module, "QueuedReturnConnectionListenerData", (PyObject *)&Dtool_QueuedReturn_ConnectionListenerData);
  // QueuedConnectionManager
  Dtool_PyModuleClassInit_QueuedConnectionManager(module);
  PyModule_AddObject(module, "QueuedConnectionManager", (PyObject *)&Dtool_QueuedConnectionManager);
  // QueuedReturn< PointerTo< Connection > >
  Dtool_PyModuleClassInit_QueuedReturn_PointerTo_Connection(module);
  PyModule_AddObject(module, "QueuedReturn_PointerTo_Connection", (PyObject *)&Dtool_QueuedReturn_PointerTo_Connection);
  Py_INCREF(Dtool_Ptr_QueuedReturn_PointerTo_Connection);
  PyModule_AddObject(module, "QueuedReturnPointerToConnection", (PyObject *)&Dtool_QueuedReturn_PointerTo_Connection);
  // QueuedConnectionReader
  Dtool_PyModuleClassInit_QueuedConnectionReader(module);
  PyModule_AddObject(module, "QueuedConnectionReader", (PyObject *)&Dtool_QueuedConnectionReader);
  // QueuedReturn< NetDatagram >
  Dtool_PyModuleClassInit_QueuedReturn_NetDatagram(module);
  PyModule_AddObject(module, "QueuedReturn_NetDatagram", (PyObject *)&Dtool_QueuedReturn_NetDatagram);
  Py_INCREF(Dtool_Ptr_QueuedReturn_NetDatagram);
  PyModule_AddObject(module, "QueuedReturnNetDatagram", (PyObject *)&Dtool_QueuedReturn_NetDatagram);
  // RecentConnectionReader
  Dtool_PyModuleClassInit_RecentConnectionReader(module);
  PyModule_AddObject(module, "RecentConnectionReader", (PyObject *)&Dtool_RecentConnectionReader);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3net_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3net_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613114,  /* file_identifier */
  "libp3net",  /* library_name */
  "7xrj",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3net.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  450  /* next_index */
};

Configure(_in_configure_libp3net);
ConfigureFn(_in_configure_libp3net) {
  interrogate_request_module(&_in_module_def);
}

