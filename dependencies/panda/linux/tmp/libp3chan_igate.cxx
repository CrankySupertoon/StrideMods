/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/chan -Ipanda/src/chan -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3chan_igate.cxx -od built/pandac/input/libp3chan.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/chan -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3chan animBundle.h animBundleNode.h animChannel.h animChannelBase.h animChannelMatrixDynamic.h animChannelMatrixFixed.h animChannelMatrixXfmTable.h animChannelScalarDynamic.h animChannelScalarTable.h animControl.h animControlCollection.h animGroup.h animPreloadTable.h auto_bind.h bindAnimRequest.h config_chan.h movingPartBase.h movingPartMatrix.h movingPartScalar.h p3chan_composite1.cxx p3chan_composite2.cxx partBundle.h partBundleHandle.h partBundleNode.h partGroup.h partSubset.h vector_PartGroupStar.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "animBundle.h"
#include "animBundleNode.h"
#include "animChannel.h"
#include "animChannelBase.h"
#include "animChannelFixed.h"
#include "animChannelMatrixDynamic.h"
#include "animChannelMatrixFixed.h"
#include "animChannelMatrixXfmTable.h"
#include "animChannelScalarDynamic.h"
#include "animChannelScalarTable.h"
#include "animControl.h"
#include "animControlCollection.h"
#include "animGroup.h"
#include "animPreloadTable.h"
#include "auto_bind.h"
#include "bindAnimRequest.h"
#include "cmath.h"
#include "compose_matrix.h"
#include "configVariableBool.h"
#include "configVariableInt.h"
#include "config_chan.h"
#include "copyOnWriteObject.h"
#include "dcast.h"
#include "event.h"
#include "luse.h"
#include "modelLoadRequest.h"
#include "movingPart.h"
#include "movingPartBase.h"
#include "movingPartMatrix.h"
#include "movingPartScalar.h"
#include "notifyCategoryProxy.h"
#include "ordered_vector.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "partBundle.h"
#include "partBundleHandle.h"
#include "partBundleNode.h"
#include "partGroup.h"
#include "partSubset.h"
#include "pmap.h"
#include "pointerTo.h"
#include "pointerToArray.h"
#include "pt_Event.h"
#include "pta_stdfloat.h"
#include "transformState.h"
#include "typedWritableReferenceCount.h"
#include "vector_PartGroupStar.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class AnimGroup
 */
typedef AnimGroup AnimGroup_localtype;
Define_Module_ClassRef(panda3d.core, AnimGroup, AnimGroup_localtype, AnimGroup);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimGroup = &Dtool_AnimGroup;
static void Dtool_PyModuleClassInit_AnimGroup(PyObject *module);

/**
 * Forward declarations for top-level class AnimBundle
 */
typedef AnimBundle AnimBundle_localtype;
Define_Module_ClassRef(panda3d.core, AnimBundle, AnimBundle_localtype, AnimBundle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimBundle = &Dtool_AnimBundle;
static void Dtool_PyModuleClassInit_AnimBundle(PyObject *module);

/**
 * Forward declarations for top-level class AnimBundleNode
 */
typedef AnimBundleNode AnimBundleNode_localtype;
Define_Module_ClassRef(panda3d.core, AnimBundleNode, AnimBundleNode_localtype, AnimBundleNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimBundleNode = &Dtool_AnimBundleNode;
static void Dtool_PyModuleClassInit_AnimBundleNode(PyObject *module);

/**
 * Forward declarations for top-level class PartGroup
 */
typedef PartGroup PartGroup_localtype;
Define_Module_ClassRef(panda3d.core, PartGroup, PartGroup_localtype, PartGroup);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartGroup = &Dtool_PartGroup;
static void Dtool_PyModuleClassInit_PartGroup(PyObject *module);

/**
 * Forward declarations for top-level class AnimControl
 */
typedef AnimControl AnimControl_localtype;
Define_Module_ClassRef(panda3d.core, AnimControl, AnimControl_localtype, AnimControl);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimControl = &Dtool_AnimControl;
static void Dtool_PyModuleClassInit_AnimControl(PyObject *module);

/**
 * Forward declarations for top-level class AnimChannelBase
 */
typedef AnimChannelBase AnimChannelBase_localtype;
Define_Module_ClassRef(panda3d.core, AnimChannelBase, AnimChannelBase_localtype, AnimChannelBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimChannelBase = &Dtool_AnimChannelBase;
static void Dtool_PyModuleClassInit_AnimChannelBase(PyObject *module);

/**
 * Forward declarations for top-level class AnimChannel_ACMatrixSwitchType
 */
typedef AnimChannel< ACMatrixSwitchType > AnimChannel_ACMatrixSwitchType_localtype;
Define_Module_ClassRef(panda3d.core, AnimChannel_ACMatrixSwitchType, AnimChannel_ACMatrixSwitchType_localtype, AnimChannel_ACMatrixSwitchType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimChannel_ACMatrixSwitchType = &Dtool_AnimChannel_ACMatrixSwitchType;
static void Dtool_PyModuleClassInit_AnimChannel_ACMatrixSwitchType(PyObject *module);

/**
 * Forward declarations for top-level class AnimChannel_ACScalarSwitchType
 */
typedef AnimChannel< ACScalarSwitchType > AnimChannel_ACScalarSwitchType_localtype;
Define_Module_ClassRef(panda3d.core, AnimChannel_ACScalarSwitchType, AnimChannel_ACScalarSwitchType_localtype, AnimChannel_ACScalarSwitchType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimChannel_ACScalarSwitchType = &Dtool_AnimChannel_ACScalarSwitchType;
static void Dtool_PyModuleClassInit_AnimChannel_ACScalarSwitchType(PyObject *module);

/**
 * Forward declarations for top-level class AnimChannelMatrixDynamic
 */
typedef AnimChannelMatrixDynamic AnimChannelMatrixDynamic_localtype;
Define_Module_ClassRef(panda3d.core, AnimChannelMatrixDynamic, AnimChannelMatrixDynamic_localtype, AnimChannelMatrixDynamic);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimChannelMatrixDynamic = &Dtool_AnimChannelMatrixDynamic;
static void Dtool_PyModuleClassInit_AnimChannelMatrixDynamic(PyObject *module);

/**
 * Forward declarations for top-level class AnimChannelMatrixXfmTable
 */
typedef AnimChannelMatrixXfmTable AnimChannelMatrixXfmTable_localtype;
Define_Module_ClassRef(panda3d.core, AnimChannelMatrixXfmTable, AnimChannelMatrixXfmTable_localtype, AnimChannelMatrixXfmTable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimChannelMatrixXfmTable = &Dtool_AnimChannelMatrixXfmTable;
static void Dtool_PyModuleClassInit_AnimChannelMatrixXfmTable(PyObject *module);

/**
 * Forward declarations for top-level class AnimChannelScalarDynamic
 */
typedef AnimChannelScalarDynamic AnimChannelScalarDynamic_localtype;
Define_Module_ClassRef(panda3d.core, AnimChannelScalarDynamic, AnimChannelScalarDynamic_localtype, AnimChannelScalarDynamic);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimChannelScalarDynamic = &Dtool_AnimChannelScalarDynamic;
static void Dtool_PyModuleClassInit_AnimChannelScalarDynamic(PyObject *module);

/**
 * Forward declarations for top-level class AnimChannelScalarTable
 */
typedef AnimChannelScalarTable AnimChannelScalarTable_localtype;
Define_Module_ClassRef(panda3d.core, AnimChannelScalarTable, AnimChannelScalarTable_localtype, AnimChannelScalarTable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimChannelScalarTable = &Dtool_AnimChannelScalarTable;
static void Dtool_PyModuleClassInit_AnimChannelScalarTable(PyObject *module);
bool Dtool_ConstCoerce_AnimChannelScalarTable(PyObject *args, CPT(AnimChannelScalarTable) &coerced);
bool Dtool_Coerce_AnimChannelScalarTable(PyObject *args, PT(AnimChannelScalarTable) &coerced);

/**
 * Forward declarations for top-level class AnimControlCollection
 */
typedef AnimControlCollection AnimControlCollection_localtype;
Define_Module_Class(panda3d.core, AnimControlCollection, AnimControlCollection_localtype, AnimControlCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimControlCollection = &Dtool_AnimControlCollection;
static void Dtool_PyModuleClassInit_AnimControlCollection(PyObject *module);

/**
 * Forward declarations for top-level class AnimPreloadTable
 */
typedef AnimPreloadTable AnimPreloadTable_localtype;
Define_Module_ClassRef(panda3d.core, AnimPreloadTable, AnimPreloadTable_localtype, AnimPreloadTable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimPreloadTable = &Dtool_AnimPreloadTable;
static void Dtool_PyModuleClassInit_AnimPreloadTable(PyObject *module);

/**
 * Forward declarations for top-level class PartSubset
 */
typedef PartSubset PartSubset_localtype;
Define_Module_Class(panda3d.core, PartSubset, PartSubset_localtype, PartSubset);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartSubset = &Dtool_PartSubset;
static void Dtool_PyModuleClassInit_PartSubset(PyObject *module);

/**
 * Forward declarations for top-level class BindAnimRequest
 */
typedef BindAnimRequest BindAnimRequest_localtype;
Define_Module_ClassRef(panda3d.core, BindAnimRequest, BindAnimRequest_localtype, BindAnimRequest);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BindAnimRequest = &Dtool_BindAnimRequest;
static void Dtool_PyModuleClassInit_BindAnimRequest(PyObject *module);

/**
 * Forward declarations for top-level class PartBundle
 */
typedef PartBundle PartBundle_localtype;
Define_Module_ClassRef(panda3d.core, PartBundle, PartBundle_localtype, PartBundle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartBundle = &Dtool_PartBundle;
static void Dtool_PyModuleClassInit_PartBundle(PyObject *module);

/**
 * Forward declarations for top-level class PartBundleNode
 */
typedef PartBundleNode PartBundleNode_localtype;
Define_Module_ClassRef(panda3d.core, PartBundleNode, PartBundleNode_localtype, PartBundleNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartBundleNode = &Dtool_PartBundleNode;
static void Dtool_PyModuleClassInit_PartBundleNode(PyObject *module);

/**
 * Forward declarations for top-level class PartBundleHandle
 */
typedef PartBundleHandle PartBundleHandle_localtype;
Define_Module_ClassRef(panda3d.core, PartBundleHandle, PartBundleHandle_localtype, PartBundleHandle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PartBundleHandle = &Dtool_PartBundleHandle;
static void Dtool_PyModuleClassInit_PartBundleHandle(PyObject *module);
bool Dtool_ConstCoerce_PartBundleHandle(PyObject *args, CPT(PartBundleHandle) &coerced);
bool Dtool_Coerce_PartBundleHandle(PyObject *args, PT(PartBundleHandle) &coerced);

/**
 * Forward declarations for top-level class MovingPartBase
 */
typedef MovingPartBase MovingPartBase_localtype;
Define_Module_ClassRef(panda3d.core, MovingPartBase, MovingPartBase_localtype, MovingPartBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPartBase = &Dtool_MovingPartBase;
static void Dtool_PyModuleClassInit_MovingPartBase(PyObject *module);

/**
 * Forward declarations for top-level class MovingPartMatrix
 */
typedef MovingPartMatrix MovingPartMatrix_localtype;
Define_Module_ClassRef(panda3d.core, MovingPartMatrix, MovingPartMatrix_localtype, MovingPartMatrix);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPartMatrix = &Dtool_MovingPartMatrix;
static void Dtool_PyModuleClassInit_MovingPartMatrix(PyObject *module);

/**
 * Forward declarations for top-level class MovingPart_ACMatrixSwitchType
 */
typedef MovingPart< ACMatrixSwitchType > MovingPart_ACMatrixSwitchType_localtype;
Define_Module_ClassRef(panda3d.core, MovingPart_ACMatrixSwitchType, MovingPart_ACMatrixSwitchType_localtype, MovingPart_ACMatrixSwitchType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPart_ACMatrixSwitchType = &Dtool_MovingPart_ACMatrixSwitchType;
static void Dtool_PyModuleClassInit_MovingPart_ACMatrixSwitchType(PyObject *module);

/**
 * Forward declarations for top-level class MovingPartScalar
 */
typedef MovingPartScalar MovingPartScalar_localtype;
Define_Module_ClassRef(panda3d.core, MovingPartScalar, MovingPartScalar_localtype, MovingPartScalar);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPartScalar = &Dtool_MovingPartScalar;
static void Dtool_PyModuleClassInit_MovingPartScalar(PyObject *module);

/**
 * Forward declarations for top-level class MovingPart_ACScalarSwitchType
 */
typedef MovingPart< ACScalarSwitchType > MovingPart_ACScalarSwitchType_localtype;
Define_Module_ClassRef(panda3d.core, MovingPart_ACScalarSwitchType, MovingPart_ACScalarSwitchType_localtype, MovingPart_ACScalarSwitchType);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MovingPart_ACScalarSwitchType = &Dtool_MovingPart_ACScalarSwitchType;
static void Dtool_PyModuleClassInit_MovingPart_ACScalarSwitchType(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"AnimGroup", &Dtool_AnimGroup},
  {"AnimBundle", &Dtool_AnimBundle},
  {"AnimBundleNode", &Dtool_AnimBundleNode},
  {"PartGroup", &Dtool_PartGroup},
  {"AnimControl", &Dtool_AnimControl},
  {"AnimChannelBase", &Dtool_AnimChannelBase},
  {"AnimChannel< ACMatrixSwitchType >", &Dtool_AnimChannel_ACMatrixSwitchType},
  {"AnimChannel< ACScalarSwitchType >", &Dtool_AnimChannel_ACScalarSwitchType},
  {"AnimChannelMatrixDynamic", &Dtool_AnimChannelMatrixDynamic},
  {"AnimChannelMatrixXfmTable", &Dtool_AnimChannelMatrixXfmTable},
  {"AnimChannelScalarDynamic", &Dtool_AnimChannelScalarDynamic},
  {"AnimChannelScalarTable", &Dtool_AnimChannelScalarTable},
  {"AnimControlCollection", &Dtool_AnimControlCollection},
  {"AnimPreloadTable", &Dtool_AnimPreloadTable},
  {"PartSubset", &Dtool_PartSubset},
  {"BindAnimRequest", &Dtool_BindAnimRequest},
  {"PartBundle", &Dtool_PartBundle},
  {"PartBundleNode", &Dtool_PartBundleNode},
  {"PartBundleHandle", &Dtool_PartBundleHandle},
  {"MovingPartBase", &Dtool_MovingPartBase},
  {"MovingPartMatrix", &Dtool_MovingPartMatrix},
  {"MovingPart< ACMatrixSwitchType >", &Dtool_MovingPart_ACMatrixSwitchType},
  {"MovingPartScalar", &Dtool_MovingPartScalar},
  {"MovingPart< ACScalarSwitchType >", &Dtool_MovingPart_ACScalarSwitchType},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[1].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[2].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[3].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[4].type)
  {"GlobPattern", nullptr},
#define Dtool_Ptr_GlobPattern (imports[5].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[6].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[7].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[8].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[9].type)
  {"LVecBase3f", nullptr},
#define Dtool_Ptr_LVecBase3f (imports[10].type)
  {"LMatrix4f", nullptr},
#define Dtool_Ptr_LMatrix4f (imports[11].type)
  {"LQuaternionf", nullptr},
#define Dtool_Ptr_LQuaternionf (imports[12].type)
  {"BitArray", nullptr},
#define Dtool_Ptr_BitArray (imports[13].type)
  {"CachedTypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_CachedTypedWritableReferenceCount (imports[14].type)
  {"CopyOnWriteObject", nullptr},
#define Dtool_Ptr_CopyOnWriteObject (imports[15].type)
  {"LoaderOptions", nullptr},
#define Dtool_Ptr_LoaderOptions (imports[16].type)
  {"TransformState", nullptr},
#define Dtool_Ptr_TransformState (imports[17].type)
  {"PandaNode", nullptr},
#define Dtool_Ptr_PandaNode (imports[18].type)
  {"AnimInterface", nullptr},
#define Dtool_Ptr_AnimInterface (imports[19].type)
  {"ConstPointerToArray< float >", nullptr},
#define Dtool_Ptr_ConstPointerToArray_float (imports[20].type)
  {"AsyncFuture", nullptr},
#define Dtool_Ptr_AsyncFuture (imports[21].type)
  {"AsyncTask", nullptr},
#define Dtool_Ptr_AsyncTask (imports[22].type)
  {"Loader", nullptr},
#define Dtool_Ptr_Loader (imports[23].type)
  {"ModelLoadRequest", nullptr},
#define Dtool_Ptr_ModelLoadRequest (imports[24].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// GlobPattern
#ifndef LINK_ALL_STATIC
inline static GlobPattern *Dtool_Coerce_GlobPattern(PyObject *args, GlobPattern &coerced) {
  nassertr(Dtool_Ptr_GlobPattern != nullptr, nullptr);
  nassertr(Dtool_Ptr_GlobPattern->_Dtool_Coerce != nullptr, nullptr);
  return ((GlobPattern *(*)(PyObject *, GlobPattern &))Dtool_Ptr_GlobPattern->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_GlobPattern;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GlobPattern = &Dtool_GlobPattern;
extern GlobPattern *Dtool_Coerce_GlobPattern(PyObject *args, GlobPattern &coerced);
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// LQuaternionf
#ifndef LINK_ALL_STATIC
inline static LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced) {
  nassertr(Dtool_Ptr_LQuaternionf != nullptr, nullptr);
  nassertr(Dtool_Ptr_LQuaternionf->_Dtool_Coerce != nullptr, nullptr);
  return ((LQuaternionf *(*)(PyObject *, LQuaternionf &))Dtool_Ptr_LQuaternionf->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LQuaternionf;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LQuaternionf = &Dtool_LQuaternionf;
extern LQuaternionf *Dtool_Coerce_LQuaternionf(PyObject *args, LQuaternionf &coerced);
#endif
// BitArray
#ifndef LINK_ALL_STATIC
inline static BitArray *Dtool_Coerce_BitArray(PyObject *args, BitArray &coerced) {
  nassertr(Dtool_Ptr_BitArray != nullptr, nullptr);
  nassertr(Dtool_Ptr_BitArray->_Dtool_Coerce != nullptr, nullptr);
  return ((BitArray *(*)(PyObject *, BitArray &))Dtool_Ptr_BitArray->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_BitArray;
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitArray = &Dtool_BitArray;
extern BitArray *Dtool_Coerce_BitArray(PyObject *args, BitArray &coerced);
#endif
// CachedTypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CachedTypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CachedTypedWritableReferenceCount = &Dtool_CachedTypedWritableReferenceCount;
#endif
// CopyOnWriteObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CopyOnWriteObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CopyOnWriteObject = &Dtool_CopyOnWriteObject;
#endif
// LoaderOptions
#ifndef LINK_ALL_STATIC
inline static LoaderOptions *Dtool_Coerce_LoaderOptions(PyObject *args, LoaderOptions &coerced) {
  nassertr(Dtool_Ptr_LoaderOptions != nullptr, nullptr);
  nassertr(Dtool_Ptr_LoaderOptions->_Dtool_Coerce != nullptr, nullptr);
  return ((LoaderOptions *(*)(PyObject *, LoaderOptions &))Dtool_Ptr_LoaderOptions->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LoaderOptions;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LoaderOptions = &Dtool_LoaderOptions;
extern LoaderOptions *Dtool_Coerce_LoaderOptions(PyObject *args, LoaderOptions &coerced);
#endif
// TransformState
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TransformState;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TransformState = &Dtool_TransformState;
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// AnimInterface
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_AnimInterface;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimInterface = &Dtool_AnimInterface;
#endif
// ConstPointerToArray< float >
#ifndef LINK_ALL_STATIC
inline static ConstPointerToArray< float > *Dtool_Coerce_ConstPointerToArray_float(PyObject *args, ConstPointerToArray< float > &coerced) {
  nassertr(Dtool_Ptr_ConstPointerToArray_float != nullptr, nullptr);
  nassertr(Dtool_Ptr_ConstPointerToArray_float->_Dtool_Coerce != nullptr, nullptr);
  return ((ConstPointerToArray< float > *(*)(PyObject *, ConstPointerToArray< float > &))Dtool_Ptr_ConstPointerToArray_float->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_ConstPointerToArray_float;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_float = &Dtool_ConstPointerToArray_float;
extern ConstPointerToArray< float > *Dtool_Coerce_ConstPointerToArray_float(PyObject *args, ConstPointerToArray< float > &coerced);
#endif
// AsyncFuture
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_AsyncFuture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncFuture = &Dtool_AsyncFuture;
#endif
// AsyncTask
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_AsyncTask;
static struct Dtool_PyTypedObject *const Dtool_Ptr_AsyncTask = &Dtool_AsyncTask;
#endif
// Loader
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Loader;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Loader = &Dtool_Loader;
#endif
// ModelLoadRequest
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ModelLoadRequest;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ModelLoadRequest = &Dtool_ModelLoadRequest;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python function wrapper for:
 * void auto_bind(PandaNode *root_node, AnimControlCollection &controls, int hierarchy_match_flags = 0)
 */
static PyObject *Dtool_auto_bind_203(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-void auto_bind(PandaNode *root_node, AnimControlCollection &controls, int hierarchy_match_flags = 0)
  PyObject *param0;
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"root_node", "controls", "hierarchy_match_flags", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO|i:auto_bind", (char **)keyword_list, &param0, &param1, &param2)) {
    PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PandaNode, 0, "auto_bind", false, true);
    AnimControlCollection *param1_this = (AnimControlCollection *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_AnimControlCollection, 1, "auto_bind", false, true);
    if (param0_this != nullptr && param1_this != nullptr) {
      (::auto_bind)(param0_this, *param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "auto_bind(PandaNode root_node, AnimControlCollection controls, int hierarchy_match_flags)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_auto_bind_203_comment =
  "C++ Interface:\n"
  "auto_bind(PandaNode root_node, AnimControlCollection controls, int hierarchy_match_flags)\n";
#else
static const char *Dtool_auto_bind_203_comment = nullptr;
#endif

/**
 * Python wrappers for functions of class AnimGroup
 */
/**
 * Python function wrapper for:
 * int AnimGroup::get_num_children(void) const
 */
static PyObject *Dtool_AnimGroup_get_num_children_10(PyObject *self, PyObject *) {
  AnimGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimGroup)) {
    return nullptr;
  }
  // 1-int AnimGroup::get_num_children(void) const
  int return_value = ((*(const AnimGroup*)local_this).get_num_children)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_get_num_children_10_comment =
  "C++ Interface:\n"
  "get_num_children(AnimGroup self)\n"
  "\n"
  "/**\n"
  " * Returns the number of child nodes of the group.\n"
  " */";
#else
static const char *Dtool_AnimGroup_get_num_children_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AnimGroup *AnimGroup::get_child(int n) const
 */
static PyObject *Dtool_AnimGroup_get_child_11(PyObject *self, PyObject *arg) {
  AnimGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimGroup)) {
    return nullptr;
  }
  // 1-AnimGroup *AnimGroup::get_child(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    AnimGroup *return_value = ((*(const AnimGroup*)local_this).get_child)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimGroup, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child(AnimGroup self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_get_child_11_comment =
  "C++ Interface:\n"
  "get_child(AnimGroup self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth child of the group.\n"
  " */";
#else
static const char *Dtool_AnimGroup_get_child_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AnimGroup *AnimGroup::get_child_named(std::string const &name) const
 */
static PyObject *Dtool_AnimGroup_get_child_named_13(PyObject *self, PyObject *arg) {
  AnimGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimGroup)) {
    return nullptr;
  }
  // 1-AnimGroup *AnimGroup::get_child_named(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    AnimGroup *return_value = ((*(const AnimGroup*)local_this).get_child_named)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimGroup, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child_named(AnimGroup self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_get_child_named_13_comment =
  "C++ Interface:\n"
  "get_child_named(AnimGroup self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the first child found with the indicated name, or NULL if no such\n"
  " * child exists.  This method searches only the children of this particular\n"
  " * AnimGroup; it does not recursively search the entire graph.  See also\n"
  " * find_child().\n"
  " */";
#else
static const char *Dtool_AnimGroup_get_child_named_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AnimGroup *AnimGroup::find_child(std::string const &name) const
 */
static PyObject *Dtool_AnimGroup_find_child_14(PyObject *self, PyObject *arg) {
  AnimGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimGroup)) {
    return nullptr;
  }
  // 1-AnimGroup *AnimGroup::find_child(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    AnimGroup *return_value = ((*(const AnimGroup*)local_this).find_child)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimGroup, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_child(AnimGroup self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_find_child_14_comment =
  "C++ Interface:\n"
  "find_child(AnimGroup self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the first descendant found with the indicated name, or NULL if no\n"
  " * such descendant exists.  This method searches the entire graph beginning at\n"
  " * this AnimGroup; see also get_child_named().\n"
  " */";
#else
static const char *Dtool_AnimGroup_find_child_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AnimGroup::sort_descendants(void)
 */
static PyObject *Dtool_AnimGroup_sort_descendants_15(PyObject *self, PyObject *) {
  AnimGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimGroup, (void **)&local_this, "AnimGroup.sort_descendants")) {
    return nullptr;
  }
  // 1-void AnimGroup::sort_descendants(void)
  ((*local_this).sort_descendants)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_sort_descendants_15_comment =
  "C++ Interface:\n"
  "sort_descendants(const AnimGroup self)\n"
  "\n"
  "/**\n"
  " * Sorts the children nodes at each level of the hierarchy into alphabetical\n"
  " * order.  This should be done after creating the hierarchy, to guarantee that\n"
  " * the correct names will match up together when the AnimBundle is later bound\n"
  " * to a PlayerRoot.\n"
  " */";
#else
static const char *Dtool_AnimGroup_sort_descendants_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimGroup::output(std::ostream &out) const
 */
static PyObject *Dtool_AnimGroup_output_18(PyObject *self, PyObject *arg) {
  AnimGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimGroup)) {
    return nullptr;
  }
  // 1-virtual void AnimGroup::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AnimGroup.output", false, true);
  if (arg_this != nullptr) {
    ((*(const AnimGroup*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AnimGroup self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_output_18_comment =
  "C++ Interface:\n"
  "output(AnimGroup self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a one-line description of the group.\n"
  " */";
#else
static const char *Dtool_AnimGroup_output_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimGroup::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_AnimGroup_write_19(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimGroup)) {
    return nullptr;
  }
  // 1-virtual void AnimGroup::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "AnimGroup.write", false, true);
    if (param1_this != nullptr) {
      ((*(const AnimGroup*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AnimGroup self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_write_19_comment =
  "C++ Interface:\n"
  "write(AnimGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a brief description of the group and all of its descendants.\n"
  " */";
#else
static const char *Dtool_AnimGroup_write_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimGroup::get_class_type(void)
 */
static PyObject *Dtool_AnimGroup_get_class_type_20(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimGroup::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AnimGroup::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_get_class_type_20_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimGroup_get_class_type_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedWritableReferenceCount *AnimGroup::upcast_to_TypedWritableReferenceCount(void)
 */
static PyObject *Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3(PyObject *self, PyObject *) {
  AnimGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimGroup, (void **)&local_this, "AnimGroup.upcast_to_TypedWritableReferenceCount")) {
    return nullptr;
  }
  // 1-TypedWritableReferenceCount *AnimGroup::upcast_to_TypedWritableReferenceCount(void)
  TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritableReferenceCount(const AnimGroup self)\n"
  "\n"
  "upcast from AnimGroup to TypedWritableReferenceCount";
#else
static const char *Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *AnimGroup::upcast_to_Namable(void)
 */
static PyObject *Dtool_AnimGroup_upcast_to_Namable_6(PyObject *self, PyObject *) {
  AnimGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimGroup, (void **)&local_this, "AnimGroup.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *AnimGroup::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimGroup_upcast_to_Namable_6_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const AnimGroup self)\n"
  "\n"
  "upcast from AnimGroup to Namable";
#else
static const char *Dtool_AnimGroup_upcast_to_Namable_6_comment = nullptr;
#endif

/**
 * sequence length function for property AnimGroup::children
 */
static Py_ssize_t Dtool_AnimGroup_children_Len(PyObject *self) {
  AnimGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimGroup, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_children)();
}

/**
 * sequence getter for property AnimGroup::children
 */
static PyObject *Dtool_AnimGroup_children_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  AnimGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimGroup, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_children)()) {
    PyErr_SetString(PyExc_IndexError, "AnimGroup.children[] index out of range");
    return nullptr;
  }
  // 1-AnimGroup *AnimGroup::get_child(int n) const
  AnimGroup *return_value = ((*(const AnimGroup*)local_this).get_child)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimGroup, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child(AnimGroup self, index)\n");
  }
}

static PyObject *Dtool_AnimGroup_children_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "AnimGroup.children");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_AnimGroup_children_Len;
    wrap->_getitem_func = &Dtool_AnimGroup_children_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * explicit AnimGroup::AnimGroup(AnimGroup *parent, std::string const &name)
 * inline AnimGroup::AnimGroup(AnimGroup const &) = default
 */
static int Dtool_Init_AnimGroup(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline AnimGroup::AnimGroup(AnimGroup const &) = default
      AnimGroup const *arg_this = (AnimGroup *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AnimGroup, 0, "AnimGroup.AnimGroup", true, true);
      if (arg_this != nullptr) {
        AnimGroup *return_value = new AnimGroup(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimGroup, true, false);
      }
    }
    break;
  case 2:
    {
      // 1-explicit AnimGroup::AnimGroup(AnimGroup *parent, std::string const &name)
      PyObject *param0;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      static const char *keyword_list[] = {"parent", "name", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:AnimGroup", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
        AnimGroup *param0_this = (AnimGroup *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AnimGroup, 0, "AnimGroup.AnimGroup", false, true);
        if (param0_this != nullptr) {
          AnimGroup *return_value = new AnimGroup(param0_this, std::string(param1_str, param1_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimGroup, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AnimGroup() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AnimGroup(const AnimGroup param0)\n"
      "AnimGroup(AnimGroup parent, str name)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_AnimGroup_get_children(PyObject *self, PyObject *) {
  AnimGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimGroup, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_children)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_AnimGroup_get_child_11(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_AnimGroup(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AnimGroup) {
    printf("AnimGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AnimGroup *local_this = (AnimGroup *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AnimGroup) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AnimGroup(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimGroup*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AnimBundle
 */
/**
 * Python function wrapper for:
 * PointerTo< AnimBundle > AnimBundle::copy_bundle(void) const
 */
static PyObject *Dtool_AnimBundle_copy_bundle_23(PyObject *self, PyObject *) {
  AnimBundle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimBundle)) {
    return nullptr;
  }
  // 1-PointerTo< AnimBundle > AnimBundle::copy_bundle(void) const
  PointerTo< AnimBundle > return_value = ((*(const AnimBundle*)local_this).copy_bundle)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  AnimBundle *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AnimBundle, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AnimBundle_copy_bundle_23_comment =
  "C++ Interface:\n"
  "copy_bundle(AnimBundle self)\n"
  "\n"
  "/**\n"
  " * Returns a full copy of the bundle and its entire tree of nested AnimGroups.\n"
  " * However, the actual data stored in the leaves--that is, animation tables,\n"
  " * such as those stored in an AnimChannelMatrixXfmTable--will be shared.\n"
  " */";
#else
static const char *Dtool_AnimBundle_copy_bundle_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double AnimBundle::get_base_frame_rate(void) const
 */
static PyObject *Dtool_AnimBundle_get_base_frame_rate_24(PyObject *self, PyObject *) {
  AnimBundle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimBundle)) {
    return nullptr;
  }
  // 1-inline double AnimBundle::get_base_frame_rate(void) const
  double return_value = ((*(const AnimBundle*)local_this).get_base_frame_rate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimBundle_get_base_frame_rate_24_comment =
  "C++ Interface:\n"
  "get_base_frame_rate(AnimBundle self)\n"
  "\n"
  "/**\n"
  " * Returns the ideal number of frames per second of the animation, when it is\n"
  " * running at normal speed.  This may not be the same as the actual playing\n"
  " * frame rate, as it might have been adjusted through set_play_rate() on the\n"
  " * AnimControl object.  See AnimControl::get_effective_frame_rate().\n"
  " */";
#else
static const char *Dtool_AnimBundle_get_base_frame_rate_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int AnimBundle::get_num_frames(void) const
 */
static PyObject *Dtool_AnimBundle_get_num_frames_25(PyObject *self, PyObject *) {
  AnimBundle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimBundle)) {
    return nullptr;
  }
  // 1-inline int AnimBundle::get_num_frames(void) const
  int return_value = ((*(const AnimBundle*)local_this).get_num_frames)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimBundle_get_num_frames_25_comment =
  "C++ Interface:\n"
  "get_num_frames(AnimBundle self)\n"
  "\n"
  "/**\n"
  " * Returns the number of frames of animation, or 0 if the animation has no\n"
  " * fixed number of frames.\n"
  " */";
#else
static const char *Dtool_AnimBundle_get_num_frames_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimBundle::get_class_type(void)
 */
static PyObject *Dtool_AnimBundle_get_class_type_30(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimBundle::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AnimBundle::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimBundle_get_class_type_30_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimBundle_get_class_type_30_comment = nullptr;
#endif

static PyObject *Dtool_AnimBundle_base_frame_rate_Getter(PyObject *self, void *) {
  const AnimBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimBundle, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double AnimBundle::get_base_frame_rate(void) const
  double return_value = ((*(const AnimBundle*)local_this).get_base_frame_rate)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AnimBundle_num_frames_Getter(PyObject *self, void *) {
  const AnimBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimBundle, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int AnimBundle::get_num_frames(void) const
  int return_value = ((*(const AnimBundle*)local_this).get_num_frames)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline AnimBundle::AnimBundle(AnimBundle const &) = default
 * inline explicit AnimBundle::AnimBundle(std::string const &name, PN_stdfloat fps, int num_frames)
 */
static int Dtool_Init_AnimBundle(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline AnimBundle::AnimBundle(AnimBundle const &) = default
      AnimBundle const *arg_this = (AnimBundle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AnimBundle, 0, "AnimBundle.AnimBundle", true, true);
      if (arg_this != nullptr) {
        AnimBundle *return_value = new AnimBundle(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimBundle, true, false);
      }
    }
    break;
  case 3:
    {
      // 1-inline explicit AnimBundle::AnimBundle(std::string const &name, PN_stdfloat fps, int num_frames)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      float param1;
      int param2;
      static const char *keyword_list[] = {"name", "fps", "num_frames", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#fi:AnimBundle", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2)) {
        AnimBundle *return_value = new AnimBundle(std::string(param0_str, param0_len), (PN_stdfloat)param1, (int)param2);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimBundle, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AnimBundle() takes 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AnimBundle(const AnimBundle param0)\n"
      "AnimBundle(str name, float fps, int num_frames)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AnimBundle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AnimBundle) {
    printf("AnimBundle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AnimBundle *local_this = (AnimBundle *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AnimBundle) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimGroup) {
    return (AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(AnimGroup *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AnimBundle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AnimBundle) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    AnimGroup* other_this = (AnimGroup*)from_this;
    return (AnimBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimBundle*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AnimBundleNode
 */
/**
 * Python function wrapper for:
 * inline AnimBundle *AnimBundleNode::get_bundle(void) const
 */
static PyObject *Dtool_AnimBundleNode_get_bundle_35(PyObject *self, PyObject *) {
  AnimBundleNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimBundleNode)) {
    return nullptr;
  }
  // 1-inline AnimBundle *AnimBundleNode::get_bundle(void) const
  AnimBundle *return_value = ((*(const AnimBundleNode*)local_this).get_bundle)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimBundle, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AnimBundleNode_get_bundle_35_comment =
  "C++ Interface:\n"
  "get_bundle(AnimBundleNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AnimBundleNode_get_bundle_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static AnimBundle *AnimBundleNode::find_anim_bundle(PandaNode *root)
 */
static PyObject *Dtool_AnimBundleNode_find_anim_bundle_38(PyObject *, PyObject *arg) {
  // 1-static AnimBundle *AnimBundleNode::find_anim_bundle(PandaNode *root)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 0, "AnimBundleNode.find_anim_bundle", false, true);
  if (arg_this != nullptr) {
    AnimBundle *return_value = (AnimBundleNode::find_anim_bundle)(arg_this);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimBundle, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_anim_bundle(PandaNode root)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimBundleNode_find_anim_bundle_38_comment =
  "C++ Interface:\n"
  "find_anim_bundle(PandaNode root)\n"
  "\n"
  "/**\n"
  " * Recursively walks the scene graph beginning at the indicated node (which\n"
  " * need not be an AnimBundleNode), and returns the first AnimBundle found.\n"
  " * Returns NULL if no AnimBundle can be found.\n"
  " */";
#else
static const char *Dtool_AnimBundleNode_find_anim_bundle_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimBundleNode::get_class_type(void)
 */
static PyObject *Dtool_AnimBundleNode_get_class_type_39(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimBundleNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AnimBundleNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimBundleNode_get_class_type_39_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimBundleNode_get_class_type_39_comment = nullptr;
#endif

static PyObject *Dtool_AnimBundleNode_bundle_Getter(PyObject *self, void *) {
  const AnimBundleNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimBundleNode, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline AnimBundle *AnimBundleNode::get_bundle(void) const
  AnimBundle *return_value = ((*(const AnimBundleNode*)local_this).get_bundle)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimBundle, true, false, return_value->as_typed_object()->get_type_index());
  }
}

/**
 * Python function wrapper for:
 * inline explicit AnimBundleNode::AnimBundleNode(std::string const &name, AnimBundle *bundle)
 */
static int Dtool_Init_AnimBundleNode(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-inline explicit AnimBundleNode::AnimBundleNode(std::string const &name, AnimBundle *bundle)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  PyObject *param1;
  static const char *keyword_list[] = {"name", "bundle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:AnimBundleNode", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    AnimBundle *param1_this = (AnimBundle *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_AnimBundle, 1, "AnimBundleNode.AnimBundleNode", false, true);
    if (param1_this != nullptr) {
      AnimBundleNode *return_value = new AnimBundleNode(std::string(param0_str, param0_len), param1_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimBundleNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AnimBundleNode(str name, AnimBundle bundle)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AnimBundleNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AnimBundleNode) {
    printf("AnimBundleNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AnimBundleNode *local_this = (AnimBundleNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AnimBundleNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AnimBundleNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AnimBundleNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (AnimBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimBundleNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PartGroup
 */
/**
 * Python function wrapper for:
 * virtual bool PartGroup::is_character_joint(void) const
 */
static PyObject *Dtool_PartGroup_is_character_joint_49(PyObject *self, PyObject *) {
  PartGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartGroup)) {
    return nullptr;
  }
  // 1-virtual bool PartGroup::is_character_joint(void) const
  bool return_value = ((*(const PartGroup*)local_this).is_character_joint)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_is_character_joint_49_comment =
  "C++ Interface:\n"
  "is_character_joint(PartGroup self)\n"
  "\n"
  "/**\n"
  " * Returns true if this part is a CharacterJoint, false otherwise.  This is a\n"
  " * tiny optimization over is_of_type(CharacterType::get_class_type()).\n"
  " */";
#else
static const char *Dtool_PartGroup_is_character_joint_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PartGroup *PartGroup::make_copy(void) const
 */
static PyObject *Dtool_PartGroup_make_copy_50(PyObject *self, PyObject *) {
  PartGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartGroup)) {
    return nullptr;
  }
  // 1-virtual PartGroup *PartGroup::make_copy(void) const
  PartGroup *return_value = ((*(const PartGroup*)local_this).make_copy)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartGroup, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_make_copy_50_comment =
  "C++ Interface:\n"
  "make_copy(PartGroup self)\n"
  "\n"
  "/**\n"
  " * Allocates and returns a new copy of the node.  Children are not copied, but\n"
  " * see copy_subgraph().\n"
  " */";
#else
static const char *Dtool_PartGroup_make_copy_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PartGroup *PartGroup::copy_subgraph(void) const
 */
static PyObject *Dtool_PartGroup_copy_subgraph_51(PyObject *self, PyObject *) {
  PartGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartGroup)) {
    return nullptr;
  }
  // 1-PartGroup *PartGroup::copy_subgraph(void) const
  PartGroup *return_value = ((*(const PartGroup*)local_this).copy_subgraph)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartGroup, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_copy_subgraph_51_comment =
  "C++ Interface:\n"
  "copy_subgraph(PartGroup self)\n"
  "\n"
  "/**\n"
  " * Allocates and returns a new copy of this node and of all of its children.\n"
  " */";
#else
static const char *Dtool_PartGroup_copy_subgraph_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PartGroup::get_num_children(void) const
 */
static PyObject *Dtool_PartGroup_get_num_children_52(PyObject *self, PyObject *) {
  PartGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartGroup)) {
    return nullptr;
  }
  // 1-int PartGroup::get_num_children(void) const
  int return_value = ((*(const PartGroup*)local_this).get_num_children)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_get_num_children_52_comment =
  "C++ Interface:\n"
  "get_num_children(PartGroup self)\n"
  "\n"
  "/**\n"
  " * Returns the number of child nodes of the group.\n"
  " */";
#else
static const char *Dtool_PartGroup_get_num_children_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PartGroup *PartGroup::get_child(int n) const
 */
static PyObject *Dtool_PartGroup_get_child_53(PyObject *self, PyObject *arg) {
  PartGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartGroup)) {
    return nullptr;
  }
  // 1-PartGroup *PartGroup::get_child(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PartGroup *return_value = ((*(const PartGroup*)local_this).get_child)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartGroup, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child(PartGroup self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_get_child_53_comment =
  "C++ Interface:\n"
  "get_child(PartGroup self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth child of the group.\n"
  " */";
#else
static const char *Dtool_PartGroup_get_child_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PartGroup *PartGroup::get_child_named(std::string const &name) const
 */
static PyObject *Dtool_PartGroup_get_child_named_55(PyObject *self, PyObject *arg) {
  PartGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartGroup)) {
    return nullptr;
  }
  // 1-PartGroup *PartGroup::get_child_named(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    PartGroup *return_value = ((*(const PartGroup*)local_this).get_child_named)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartGroup, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child_named(PartGroup self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_get_child_named_55_comment =
  "C++ Interface:\n"
  "get_child_named(PartGroup self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the first child found with the indicated name, or NULL if no such\n"
  " * child exists.  This method searches only the children of this particular\n"
  " * PartGroup; it does not recursively search the entire graph.  See also\n"
  " * find_child().\n"
  " */";
#else
static const char *Dtool_PartGroup_get_child_named_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PartGroup *PartGroup::find_child(std::string const &name) const
 */
static PyObject *Dtool_PartGroup_find_child_56(PyObject *self, PyObject *arg) {
  PartGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartGroup)) {
    return nullptr;
  }
  // 1-PartGroup *PartGroup::find_child(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    PartGroup *return_value = ((*(const PartGroup*)local_this).find_child)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartGroup, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_child(PartGroup self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_find_child_56_comment =
  "C++ Interface:\n"
  "find_child(PartGroup self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the first descendant found with the indicated name, or NULL if no\n"
  " * such descendant exists.  This method searches the entire graph beginning at\n"
  " * this PartGroup; see also get_child_named().\n"
  " */";
#else
static const char *Dtool_PartGroup_find_child_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PartGroup::sort_descendants(void)
 */
static PyObject *Dtool_PartGroup_sort_descendants_57(PyObject *self, PyObject *) {
  PartGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartGroup, (void **)&local_this, "PartGroup.sort_descendants")) {
    return nullptr;
  }
  // 1-void PartGroup::sort_descendants(void)
  ((*local_this).sort_descendants)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_sort_descendants_57_comment =
  "C++ Interface:\n"
  "sort_descendants(const PartGroup self)\n"
  "\n"
  "/**\n"
  " * Sorts the children nodes at each level of the hierarchy into alphabetical\n"
  " * order.  This should be done after creating the hierarchy, to guarantee that\n"
  " * the correct names will match up together when the AnimBundle is later bound\n"
  " * to a PlayerRoot.\n"
  " */";
#else
static const char *Dtool_PartGroup_sort_descendants_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PartGroup::apply_freeze(TransformState const *transform)
 */
static PyObject *Dtool_PartGroup_apply_freeze_60(PyObject *self, PyObject *arg) {
  PartGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartGroup, (void **)&local_this, "PartGroup.apply_freeze")) {
    return nullptr;
  }
  // 1-bool PartGroup::apply_freeze(TransformState const *transform)
  TransformState const *arg_this = (TransformState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformState, 1, "PartGroup.apply_freeze", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).apply_freeze)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_freeze(const PartGroup self, const TransformState transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_apply_freeze_60_comment =
  "C++ Interface:\n"
  "apply_freeze(const PartGroup self, const TransformState transform)\n"
  "\n"
  "/**\n"
  " * Freezes this particular joint so that it will always hold the specified\n"
  " * transform.  Returns true if this is a joint that can be so frozen, false\n"
  " * otherwise.\n"
  " *\n"
  " * This is normally only called internally by PartBundle::freeze_joint(), but\n"
  " * you may also call it directly.\n"
  " */";
#else
static const char *Dtool_PartGroup_apply_freeze_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool PartGroup::apply_freeze_matrix(LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale)
 */
static PyObject *Dtool_PartGroup_apply_freeze_matrix_61(PyObject *self, PyObject *args, PyObject *kwds) {
  PartGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartGroup, (void **)&local_this, "PartGroup.apply_freeze_matrix")) {
    return nullptr;
  }
  // 1-virtual bool PartGroup::apply_freeze_matrix(LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"pos", "hpr", "scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:apply_freeze_matrix", (char **)keyword_list, &param1, &param2, &param3)) {
    LVecBase3f param1_local;
    LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PartGroup.apply_freeze_matrix", "LVecBase3f");
    }
    LVecBase3f param2_local;
    LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PartGroup.apply_freeze_matrix", "LVecBase3f");
    }
    LVecBase3f param3_local;
    LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
    if (!(param3_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param3, 3, "PartGroup.apply_freeze_matrix", "LVecBase3f");
    }
    bool return_value = ((*local_this).apply_freeze_matrix)(*param1_this, *param2_this, *param3_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_freeze_matrix(const PartGroup self, const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_apply_freeze_matrix_61_comment =
  "C++ Interface:\n"
  "apply_freeze_matrix(const PartGroup self, const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale)\n"
  "\n"
  "/**\n"
  " * Freezes this particular joint so that it will always hold the specified\n"
  " * transform.  Returns true if this is a joint that can be so frozen, false\n"
  " * otherwise.\n"
  " *\n"
  " * This is normally only called internally by PartBundle::freeze_joint(), but\n"
  " * you may also call it directly.\n"
  " */";
#else
static const char *Dtool_PartGroup_apply_freeze_matrix_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool PartGroup::apply_freeze_scalar(PN_stdfloat value)
 */
static PyObject *Dtool_PartGroup_apply_freeze_scalar_62(PyObject *self, PyObject *arg) {
  PartGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartGroup, (void **)&local_this, "PartGroup.apply_freeze_scalar")) {
    return nullptr;
  }
  // 1-virtual bool PartGroup::apply_freeze_scalar(PN_stdfloat value)
  if (PyNumber_Check(arg)) {
    bool return_value = ((*local_this).apply_freeze_scalar)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_freeze_scalar(const PartGroup self, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_apply_freeze_scalar_62_comment =
  "C++ Interface:\n"
  "apply_freeze_scalar(const PartGroup self, float value)\n"
  "\n"
  "/**\n"
  " * Freezes this particular joint so that it will always hold the specified\n"
  " * transform.  Returns true if this is a joint that can be so frozen, false\n"
  " * otherwise.\n"
  " *\n"
  " * This is normally only called internally by PartBundle::freeze_joint(), but\n"
  " * you may also call it directly.\n"
  " */";
#else
static const char *Dtool_PartGroup_apply_freeze_scalar_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool PartGroup::apply_control(PandaNode *node)
 */
static PyObject *Dtool_PartGroup_apply_control_63(PyObject *self, PyObject *arg) {
  PartGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartGroup, (void **)&local_this, "PartGroup.apply_control")) {
    return nullptr;
  }
  // 1-virtual bool PartGroup::apply_control(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "PartGroup.apply_control", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).apply_control)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_control(const PartGroup self, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_apply_control_63_comment =
  "C++ Interface:\n"
  "apply_control(const PartGroup self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Specifies a node to influence this particular joint so that it will always\n"
  " * hold the node's transform.  Returns true if this is a joint that can be so\n"
  " * controlled, false otherwise.\n"
  " *\n"
  " * This is normally only called internally by PartBundle::control_joint(), but\n"
  " * you may also call it directly.\n"
  " */";
#else
static const char *Dtool_PartGroup_apply_control_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool PartGroup::clear_forced_channel(void)
 */
static PyObject *Dtool_PartGroup_clear_forced_channel_64(PyObject *self, PyObject *) {
  PartGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartGroup, (void **)&local_this, "PartGroup.clear_forced_channel")) {
    return nullptr;
  }
  // 1-virtual bool PartGroup::clear_forced_channel(void)
  bool return_value = ((*local_this).clear_forced_channel)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_clear_forced_channel_64_comment =
  "C++ Interface:\n"
  "clear_forced_channel(const PartGroup self)\n"
  "\n"
  "/**\n"
  " * Undoes the effect of a previous call to apply_freeze() or apply_control().\n"
  " * Returns true if the joint was modified, false otherwise.\n"
  " *\n"
  " * This is normally only called internally by PartBundle::release_joint(), but\n"
  " * you may also call it directly.\n"
  " */";
#else
static const char *Dtool_PartGroup_clear_forced_channel_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual AnimChannelBase *PartGroup::get_forced_channel(void) const
 */
static PyObject *Dtool_PartGroup_get_forced_channel_65(PyObject *self, PyObject *) {
  PartGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartGroup)) {
    return nullptr;
  }
  // 1-virtual AnimChannelBase *PartGroup::get_forced_channel(void) const
  AnimChannelBase *return_value = ((*(const PartGroup*)local_this).get_forced_channel)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimChannelBase, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_get_forced_channel_65_comment =
  "C++ Interface:\n"
  "get_forced_channel(PartGroup self)\n"
  "\n"
  "/**\n"
  " * Returns the AnimChannelBase that has been forced to this joint by a\n"
  " * previous call to apply_freeze() or apply_control(), or NULL if no such\n"
  " * channel has been applied.\n"
  " */";
#else
static const char *Dtool_PartGroup_get_forced_channel_65_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PartGroup::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_PartGroup_write_66(PyObject *self, PyObject *args, PyObject *kwds) {
  PartGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartGroup)) {
    return nullptr;
  }
  // 1-virtual void PartGroup::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "PartGroup.write", false, true);
    if (param1_this != nullptr) {
      ((*(const PartGroup*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(PartGroup self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_write_66_comment =
  "C++ Interface:\n"
  "write(PartGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a brief description of the group and all of its descendants.\n"
  " */";
#else
static const char *Dtool_PartGroup_write_66_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PartGroup::write_with_value(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_PartGroup_write_with_value_67(PyObject *self, PyObject *args, PyObject *kwds) {
  PartGroup *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartGroup)) {
    return nullptr;
  }
  // 1-virtual void PartGroup::write_with_value(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write_with_value", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "PartGroup.write_with_value", false, true);
    if (param1_this != nullptr) {
      ((*(const PartGroup*)local_this).write_with_value)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_with_value(PartGroup self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_write_with_value_67_comment =
  "C++ Interface:\n"
  "write_with_value(PartGroup self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a brief description of the group, showing its current value, and\n"
  " * that of all of its descendants.\n"
  " */";
#else
static const char *Dtool_PartGroup_write_with_value_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PartGroup::get_class_type(void)
 */
static PyObject *Dtool_PartGroup_get_class_type_68(PyObject *, PyObject *) {
  // 1-static TypeHandle PartGroup::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PartGroup::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_get_class_type_68_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PartGroup_get_class_type_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedWritableReferenceCount *PartGroup::upcast_to_TypedWritableReferenceCount(void)
 */
static PyObject *Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_42(PyObject *self, PyObject *) {
  PartGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartGroup, (void **)&local_this, "PartGroup.upcast_to_TypedWritableReferenceCount")) {
    return nullptr;
  }
  // 1-TypedWritableReferenceCount *PartGroup::upcast_to_TypedWritableReferenceCount(void)
  TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_42_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritableReferenceCount(const PartGroup self)\n"
  "\n"
  "upcast from PartGroup to TypedWritableReferenceCount";
#else
static const char *Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *PartGroup::upcast_to_Namable(void)
 */
static PyObject *Dtool_PartGroup_upcast_to_Namable_44(PyObject *self, PyObject *) {
  PartGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartGroup, (void **)&local_this, "PartGroup.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *PartGroup::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_PartGroup_upcast_to_Namable_44_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const PartGroup self)\n"
  "\n"
  "upcast from PartGroup to Namable";
#else
static const char *Dtool_PartGroup_upcast_to_Namable_44_comment = nullptr;
#endif

/**
 * sequence length function for property PartGroup::children
 */
static Py_ssize_t Dtool_PartGroup_children_Len(PyObject *self) {
  PartGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_children)();
}

/**
 * sequence getter for property PartGroup::children
 */
static PyObject *Dtool_PartGroup_children_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  PartGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_children)()) {
    PyErr_SetString(PyExc_IndexError, "PartGroup.children[] index out of range");
    return nullptr;
  }
  // 1-PartGroup *PartGroup::get_child(int n) const
  PartGroup *return_value = ((*(const PartGroup*)local_this).get_child)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartGroup, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child(PartGroup self, index)\n");
  }
}

static PyObject *Dtool_PartGroup_children_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "PartGroup.children");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_PartGroup_children_Len;
    wrap->_getitem_func = &Dtool_PartGroup_children_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * explicit PartGroup::PartGroup(PartGroup *parent, std::string const &name)
 */
static int Dtool_Init_PartGroup(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit PartGroup::PartGroup(PartGroup *parent, std::string const &name)
  PyObject *param0;
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"parent", "name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:PartGroup", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
    PartGroup *param0_this = (PartGroup *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PartGroup, 0, "PartGroup.PartGroup", false, true);
    if (param0_this != nullptr) {
      PartGroup *return_value = new PartGroup(param0_this, std::string(param1_str, param1_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PartGroup, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PartGroup(PartGroup parent, str name)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PartGroup_get_children(PyObject *self, PyObject *) {
  PartGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_children)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PartGroup_get_child_53(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PartGroup(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PartGroup) {
    printf("PartGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PartGroup *local_this = (PartGroup *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PartGroup) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PartGroup(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PartGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PartGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PartGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PartGroup*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PartGroup*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AnimControl
 */
/**
 * Python function wrapper for:
 * inline bool AnimControl::is_pending(void) const
 */
static PyObject *Dtool_AnimControl_is_pending_79(PyObject *self, PyObject *) {
  AnimControl *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControl)) {
    return nullptr;
  }
  // 1-inline bool AnimControl::is_pending(void) const
  bool return_value = ((*(const AnimControl*)local_this).is_pending)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_is_pending_79_comment =
  "C++ Interface:\n"
  "is_pending(AnimControl self)\n"
  "\n"
  "/**\n"
  " * Returns true if the AnimControl is being bound asynchronously, and has not\n"
  " * yet finished.  If this is true, the AnimControl's interface is still\n"
  " * available and will be perfectly useful (though get_anim() might return\n"
  " * NULL), but nothing visible will happen immediately.\n"
  " */";
#else
static const char *Dtool_AnimControl_is_pending_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AnimControl::wait_pending(void)
 */
static PyObject *Dtool_AnimControl_wait_pending_80(PyObject *self, PyObject *) {
  AnimControl *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControl, (void **)&local_this, "AnimControl.wait_pending")) {
    return nullptr;
  }
  // 1-void AnimControl::wait_pending(void)
  ((*local_this).wait_pending)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_wait_pending_80_comment =
  "C++ Interface:\n"
  "wait_pending(const AnimControl self)\n"
  "\n"
  "/**\n"
  " * Blocks the current thread until the AnimControl has finished loading and is\n"
  " * fully bound.\n"
  " */";
#else
static const char *Dtool_AnimControl_wait_pending_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimControl::has_anim(void) const
 */
static PyObject *Dtool_AnimControl_has_anim_81(PyObject *self, PyObject *) {
  AnimControl *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControl)) {
    return nullptr;
  }
  // 1-inline bool AnimControl::has_anim(void) const
  bool return_value = ((*(const AnimControl*)local_this).has_anim)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_has_anim_81_comment =
  "C++ Interface:\n"
  "has_anim(AnimControl self)\n"
  "\n"
  "/**\n"
  " * Returns true if the AnimControl was successfully loaded, or false if there\n"
  " * was a problem.  This may return false while is_pending() is true.\n"
  " */";
#else
static const char *Dtool_AnimControl_has_anim_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AnimControl::set_pending_done_event(std::string const &done_event)
 */
static PyObject *Dtool_AnimControl_set_pending_done_event_82(PyObject *self, PyObject *arg) {
  AnimControl *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControl, (void **)&local_this, "AnimControl.set_pending_done_event")) {
    return nullptr;
  }
  // 1-void AnimControl::set_pending_done_event(std::string const &done_event)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_pending_done_event)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pending_done_event(const AnimControl self, str done_event)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_set_pending_done_event_82_comment =
  "C++ Interface:\n"
  "set_pending_done_event(const AnimControl self, str done_event)\n"
  "\n"
  "/**\n"
  " * Specifies an event name that will be thrown when the AnimControl is\n"
  " * finished binding asynchronously.  If the AnimControl has already finished\n"
  " * binding, the event will be thrown immediately.\n"
  " */";
#else
static const char *Dtool_AnimControl_set_pending_done_event_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string AnimControl::get_pending_done_event(void) const
 */
static PyObject *Dtool_AnimControl_get_pending_done_event_83(PyObject *self, PyObject *) {
  AnimControl *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControl)) {
    return nullptr;
  }
  // 1-std::string AnimControl::get_pending_done_event(void) const
  std::string return_value = ((*(const AnimControl*)local_this).get_pending_done_event)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_get_pending_done_event_83_comment =
  "C++ Interface:\n"
  "get_pending_done_event(AnimControl self)\n"
  "\n"
  "/**\n"
  " * Returns the event name that will be thrown when the AnimControl is finished\n"
  " * binding asynchronously.\n"
  " */";
#else
static const char *Dtool_AnimControl_get_pending_done_event_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PartBundle *AnimControl::get_part(void) const
 */
static PyObject *Dtool_AnimControl_get_part_84(PyObject *self, PyObject *) {
  AnimControl *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControl)) {
    return nullptr;
  }
  // 1-PartBundle *AnimControl::get_part(void) const
  PartBundle *return_value = ((*(const AnimControl*)local_this).get_part)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartBundle, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_get_part_84_comment =
  "C++ Interface:\n"
  "get_part(AnimControl self)\n"
  "\n"
  "/**\n"
  " * Returns the PartBundle bound in with this AnimControl.\n"
  " */";
#else
static const char *Dtool_AnimControl_get_part_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AnimBundle *AnimControl::get_anim(void) const
 */
static PyObject *Dtool_AnimControl_get_anim_85(PyObject *self, PyObject *) {
  AnimControl *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControl)) {
    return nullptr;
  }
  // 1-inline AnimBundle *AnimControl::get_anim(void) const
  AnimBundle *return_value = ((*(const AnimControl*)local_this).get_anim)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimBundle, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_get_anim_85_comment =
  "C++ Interface:\n"
  "get_anim(AnimControl self)\n"
  "\n"
  "/**\n"
  " * Returns the AnimBundle bound in with this AnimControl.\n"
  " */";
#else
static const char *Dtool_AnimControl_get_anim_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int AnimControl::get_channel_index(void) const
 */
static PyObject *Dtool_AnimControl_get_channel_index_86(PyObject *self, PyObject *) {
  AnimControl *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControl)) {
    return nullptr;
  }
  // 1-inline int AnimControl::get_channel_index(void) const
  int return_value = ((*(const AnimControl*)local_this).get_channel_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_get_channel_index_86_comment =
  "C++ Interface:\n"
  "get_channel_index(AnimControl self)\n"
  "\n"
  "/**\n"
  " * Returns the particular channel index associated with this AnimControl.\n"
  " * This channel index is the slot on which each AnimGroup is bound to its\n"
  " * associated PartGroup, for each joint in the animation.\n"
  " *\n"
  " * It will be true that\n"
  " * get_part()->find_child(\"n\")->get_bound(get_channel_index()) ==\n"
  " * get_anim()->find_child(\"n\"), for each joint \"n\".\n"
  " */";
#else
static const char *Dtool_AnimControl_get_channel_index_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitArray const &AnimControl::get_bound_joints(void) const
 */
static PyObject *Dtool_AnimControl_get_bound_joints_87(PyObject *self, PyObject *) {
  AnimControl *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControl)) {
    return nullptr;
  }
  // 1-inline BitArray const &AnimControl::get_bound_joints(void) const
  BitArray const *return_value = &(((*(const AnimControl*)local_this).get_bound_joints)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, false, true);
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_get_bound_joints_87_comment =
  "C++ Interface:\n"
  "get_bound_joints(AnimControl self)\n"
  "\n"
  "/**\n"
  " * Returns the subset of joints controlled by this AnimControl.  Most of the\n"
  " * time, this will be BitArray::all_on(), for a normal full-body animation.\n"
  " * For a subset animation, however, this will be just a subset of those bits,\n"
  " * corresponding to the set of joints and sliders actually bound (as\n"
  " * enumerated by bind_hierarchy() in depth-first LIFO order).\n"
  " */";
#else
static const char *Dtool_AnimControl_get_bound_joints_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AnimControl::set_anim_model(PandaNode *model)
 */
static PyObject *Dtool_AnimControl_set_anim_model_88(PyObject *self, PyObject *arg) {
  AnimControl *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControl, (void **)&local_this, "AnimControl.set_anim_model")) {
    return nullptr;
  }
  // 1-inline void AnimControl::set_anim_model(PandaNode *model)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "AnimControl.set_anim_model", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_anim_model)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anim_model(const AnimControl self, PandaNode model)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_set_anim_model_88_comment =
  "C++ Interface:\n"
  "set_anim_model(const AnimControl self, PandaNode model)\n"
  "\n"
  "/**\n"
  " * Associates the indicated PandaNode with the AnimControl.  By convention,\n"
  " * this node represents the root node of the model file that corresponds to\n"
  " * this AnimControl's animation file, though nothing in this code makes this\n"
  " * assumption or indeed does anything with this node.\n"
  " *\n"
  " * The purpose of this is simply to allow the AnimControl to keep a reference\n"
  " * count on the ModelRoot node that generated it, so that the model will not\n"
  " * disappear from the model pool until it is no longer referenced.\n"
  " */";
#else
static const char *Dtool_AnimControl_set_anim_model_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *AnimControl::get_anim_model(void) const
 */
static PyObject *Dtool_AnimControl_get_anim_model_89(PyObject *self, PyObject *) {
  AnimControl *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControl)) {
    return nullptr;
  }
  // 1-inline PandaNode *AnimControl::get_anim_model(void) const
  PandaNode *return_value = ((*(const AnimControl*)local_this).get_anim_model)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_get_anim_model_89_comment =
  "C++ Interface:\n"
  "get_anim_model(AnimControl self)\n"
  "\n"
  "/**\n"
  " * Retrieves the pointer set via set_anim_model().  See set_anim_model().\n"
  " */";
#else
static const char *Dtool_AnimControl_get_anim_model_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimControl::output(std::ostream &out) const
 */
static PyObject *Dtool_AnimControl_output_90(PyObject *self, PyObject *arg) {
  AnimControl *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControl)) {
    return nullptr;
  }
  // 1-virtual void AnimControl::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AnimControl.output", false, true);
  if (arg_this != nullptr) {
    ((*(const AnimControl*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AnimControl self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_output_90_comment =
  "C++ Interface:\n"
  "output(AnimControl self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AnimControl_output_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimControl::get_class_type(void)
 */
static PyObject *Dtool_AnimControl_get_class_type_91(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimControl::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AnimControl::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_get_class_type_91_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimControl_get_class_type_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedReferenceCount *AnimControl::upcast_to_TypedReferenceCount(void)
 */
static PyObject *Dtool_AnimControl_upcast_to_TypedReferenceCount_71(PyObject *self, PyObject *) {
  AnimControl *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControl, (void **)&local_this, "AnimControl.upcast_to_TypedReferenceCount")) {
    return nullptr;
  }
  // 1-TypedReferenceCount *AnimControl::upcast_to_TypedReferenceCount(void)
  TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_upcast_to_TypedReferenceCount_71_comment =
  "C++ Interface:\n"
  "upcast_to_TypedReferenceCount(const AnimControl self)\n"
  "\n"
  "upcast from AnimControl to TypedReferenceCount";
#else
static const char *Dtool_AnimControl_upcast_to_TypedReferenceCount_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AnimInterface *AnimControl::upcast_to_AnimInterface(void)
 */
static PyObject *Dtool_AnimControl_upcast_to_AnimInterface_74(PyObject *self, PyObject *) {
  AnimControl *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControl, (void **)&local_this, "AnimControl.upcast_to_AnimInterface")) {
    return nullptr;
  }
  // 1-AnimInterface *AnimControl::upcast_to_AnimInterface(void)
  AnimInterface *return_value = (AnimInterface *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_AnimInterface, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_upcast_to_AnimInterface_74_comment =
  "C++ Interface:\n"
  "upcast_to_AnimInterface(const AnimControl self)\n"
  "\n"
  "upcast from AnimControl to AnimInterface";
#else
static const char *Dtool_AnimControl_upcast_to_AnimInterface_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Namable *AnimControl::upcast_to_Namable(void)
 */
static PyObject *Dtool_AnimControl_upcast_to_Namable_76(PyObject *self, PyObject *) {
  AnimControl *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControl, (void **)&local_this, "AnimControl.upcast_to_Namable")) {
    return nullptr;
  }
  // 1-Namable *AnimControl::upcast_to_Namable(void)
  Namable *return_value = (Namable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Namable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimControl_upcast_to_Namable_76_comment =
  "C++ Interface:\n"
  "upcast_to_Namable(const AnimControl self)\n"
  "\n"
  "upcast from AnimControl to Namable";
#else
static const char *Dtool_AnimControl_upcast_to_Namable_76_comment = nullptr;
#endif

static int Dtool_Init_AnimControl(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AnimControl(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AnimControl) {
    printf("AnimControl ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AnimControl *local_this = (AnimControl *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AnimControl) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimInterface) {
    return (AnimInterface *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AnimControl(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AnimControl) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimInterface) {
    AnimInterface* other_this = (AnimInterface*)from_this;
    return (AnimControl*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimControl*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimControl*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimControl*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AnimControl*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AnimChannelBase
 */
/**
 * Python function wrapper for:
 * virtual TypeHandle AnimChannelBase::get_type(void) const
 */
static PyObject *Dtool_AnimChannelBase_get_type_93(PyObject *self, PyObject *) {
  AnimChannelBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimChannelBase)) {
    return nullptr;
  }
  // 1-virtual TypeHandle AnimChannelBase::get_type(void) const
  TypeHandle *return_value = new TypeHandle(((*(const AnimChannelBase*)local_this).get_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelBase_get_type_93_comment =
  "C++ Interface:\n"
  "get_type(AnimChannelBase self)\n";
#else
static const char *Dtool_AnimChannelBase_get_type_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimChannelBase::get_class_type(void)
 */
static PyObject *Dtool_AnimChannelBase_get_class_type_94(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimChannelBase::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AnimChannelBase::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelBase_get_class_type_94_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimChannelBase_get_class_type_94_comment = nullptr;
#endif

static int Dtool_Init_AnimChannelBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AnimChannelBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AnimChannelBase) {
    printf("AnimChannelBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AnimChannelBase *local_this = (AnimChannelBase *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AnimChannelBase) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimGroup) {
    return (AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(AnimGroup *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AnimChannelBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AnimChannelBase) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    AnimGroup* other_this = (AnimGroup*)from_this;
    return (AnimChannelBase*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimChannelBase*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimChannelBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimChannelBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimChannelBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimChannelBase*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AnimChannel< ACMatrixSwitchType >
 */
/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACMatrixSwitchType >::get_value(int frame, LMatrix4 &value) = 0
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_value_99(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACMatrixSwitchType > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACMatrixSwitchType, (void **)&local_this, "AnimChannel_ACMatrixSwitchType.get_value")) {
    return nullptr;
  }
  // 1-virtual void AnimChannel< ACMatrixSwitchType >::get_value(int frame, LMatrix4 &value) = 0
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_value", (char **)keyword_list, &param1, &param2)) {
    LMatrix4f param2_local;
    LMatrix4 *param2_this = Dtool_Coerce_LMatrix4f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_value", "LMatrix4f");
    }
    ((*local_this).get_value)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_value(const AnimChannel self, int frame, LMatrix4f value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_value_99_comment =
  "C++ Interface:\n"
  "get_value(const AnimChannel self, int frame, LMatrix4f value)\n";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_value_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACMatrixSwitchType >::get_value_no_scale_shear(int frame, LMatrix4 &value)
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_100(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACMatrixSwitchType > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACMatrixSwitchType, (void **)&local_this, "AnimChannel_ACMatrixSwitchType.get_value_no_scale_shear")) {
    return nullptr;
  }
  // 1-virtual void AnimChannel< ACMatrixSwitchType >::get_value_no_scale_shear(int frame, LMatrix4 &value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_value_no_scale_shear", (char **)keyword_list, &param1, &param2)) {
    LMatrix4f param2_local;
    LMatrix4 *param2_this = Dtool_Coerce_LMatrix4f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_value_no_scale_shear", "LMatrix4f");
    }
    ((*local_this).get_value_no_scale_shear)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_value_no_scale_shear(const AnimChannel self, int frame, LMatrix4f value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_100_comment =
  "C++ Interface:\n"
  "get_value_no_scale_shear(const AnimChannel self, int frame, LMatrix4f value)\n"
  "\n"
  "// These transform-component methods only have meaning for matrix types.";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACMatrixSwitchType >::get_scale(int frame, LVecBase3 &scale)
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_scale_101(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACMatrixSwitchType > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACMatrixSwitchType, (void **)&local_this, "AnimChannel_ACMatrixSwitchType.get_scale")) {
    return nullptr;
  }
  // 1-virtual void AnimChannel< ACMatrixSwitchType >::get_scale(int frame, LVecBase3 &scale)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_scale", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_scale", "LVecBase3f");
    }
    ((*local_this).get_scale)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_scale(const AnimChannel self, int frame, LVecBase3f scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_scale_101_comment =
  "C++ Interface:\n"
  "get_scale(const AnimChannel self, int frame, LVecBase3f scale)\n";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_scale_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACMatrixSwitchType >::get_hpr(int frame, LVecBase3 &hpr)
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_102(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACMatrixSwitchType > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACMatrixSwitchType, (void **)&local_this, "AnimChannel_ACMatrixSwitchType.get_hpr")) {
    return nullptr;
  }
  // 1-virtual void AnimChannel< ACMatrixSwitchType >::get_hpr(int frame, LVecBase3 &hpr)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "hpr", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_hpr", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_hpr", "LVecBase3f");
    }
    ((*local_this).get_hpr)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hpr(const AnimChannel self, int frame, LVecBase3f hpr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_102_comment =
  "C++ Interface:\n"
  "get_hpr(const AnimChannel self, int frame, LVecBase3f hpr)\n";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACMatrixSwitchType >::get_quat(int frame, LQuaternion &quat)
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_quat_103(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACMatrixSwitchType > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACMatrixSwitchType, (void **)&local_this, "AnimChannel_ACMatrixSwitchType.get_quat")) {
    return nullptr;
  }
  // 1-virtual void AnimChannel< ACMatrixSwitchType >::get_quat(int frame, LQuaternion &quat)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "quat", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_quat", (char **)keyword_list, &param1, &param2)) {
    LQuaternionf param2_local;
    LQuaternion *param2_this = Dtool_Coerce_LQuaternionf(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_quat", "LQuaternionf");
    }
    ((*local_this).get_quat)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_quat(const AnimChannel self, int frame, LQuaternionf quat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_quat_103_comment =
  "C++ Interface:\n"
  "get_quat(const AnimChannel self, int frame, LQuaternionf quat)\n";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_quat_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACMatrixSwitchType >::get_pos(int frame, LVecBase3 &pos)
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_pos_104(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACMatrixSwitchType > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACMatrixSwitchType, (void **)&local_this, "AnimChannel_ACMatrixSwitchType.get_pos")) {
    return nullptr;
  }
  // 1-virtual void AnimChannel< ACMatrixSwitchType >::get_pos(int frame, LVecBase3 &pos)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "pos", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_pos", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_pos", "LVecBase3f");
    }
    ((*local_this).get_pos)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pos(const AnimChannel self, int frame, LVecBase3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_pos_104_comment =
  "C++ Interface:\n"
  "get_pos(const AnimChannel self, int frame, LVecBase3f pos)\n";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_pos_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACMatrixSwitchType >::get_shear(int frame, LVecBase3 &shear)
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_shear_105(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACMatrixSwitchType > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACMatrixSwitchType, (void **)&local_this, "AnimChannel_ACMatrixSwitchType.get_shear")) {
    return nullptr;
  }
  // 1-virtual void AnimChannel< ACMatrixSwitchType >::get_shear(int frame, LVecBase3 &shear)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "shear", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_shear", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_shear", "LVecBase3f");
    }
    ((*local_this).get_shear)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_shear(const AnimChannel self, int frame, LVecBase3f shear)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_shear_105_comment =
  "C++ Interface:\n"
  "get_shear(const AnimChannel self, int frame, LVecBase3f shear)\n";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_shear_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual TypeHandle AnimChannel< ACMatrixSwitchType >::get_value_type(void) const
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_106(PyObject *self, PyObject *) {
  AnimChannel< ACMatrixSwitchType > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimChannel_ACMatrixSwitchType)) {
    return nullptr;
  }
  // 1-virtual TypeHandle AnimChannel< ACMatrixSwitchType >::get_value_type(void) const
  TypeHandle *return_value = new TypeHandle(((*(const AnimChannel< ACMatrixSwitchType >*)local_this).get_value_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_106_comment =
  "C++ Interface:\n"
  "get_value_type(AnimChannel self)\n";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimChannel< ACMatrixSwitchType >::get_class_type(void)
 */
static PyObject *Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_107(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimChannel< ACMatrixSwitchType >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AnimChannel< ACMatrixSwitchType >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_107_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_107_comment = nullptr;
#endif

static int Dtool_Init_AnimChannel_ACMatrixSwitchType(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AnimChannel_ACMatrixSwitchType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AnimChannel_ACMatrixSwitchType) {
    printf("AnimChannel_ACMatrixSwitchType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AnimChannel< ACMatrixSwitchType > *local_this = (AnimChannel< ACMatrixSwitchType > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AnimChannel_ACMatrixSwitchType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannelBase) {
    return (AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimGroup) {
    return (AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AnimChannel_ACMatrixSwitchType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AnimChannel_ACMatrixSwitchType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimChannelBase) {
    AnimChannelBase* other_this = (AnimChannelBase*)from_this;
    return (AnimChannel< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    AnimGroup* other_this = (AnimGroup*)from_this;
    return (AnimChannel< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimChannel< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimChannel< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimChannel< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimChannel< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimChannel< ACMatrixSwitchType >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AnimChannel< ACScalarSwitchType >
 */
/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACScalarSwitchType >::get_scale(int frame, LVecBase3 &scale)
 */
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_scale_112(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACScalarSwitchType > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACScalarSwitchType, (void **)&local_this, "AnimChannel_ACScalarSwitchType.get_scale")) {
    return nullptr;
  }
  // 1-virtual void AnimChannel< ACScalarSwitchType >::get_scale(int frame, LVecBase3 &scale)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "scale", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_scale", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_scale", "LVecBase3f");
    }
    ((*local_this).get_scale)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_scale(const AnimChannel self, int frame, LVecBase3f scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_scale_112_comment =
  "C++ Interface:\n"
  "get_scale(const AnimChannel self, int frame, LVecBase3f scale)\n";
#else
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_scale_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACScalarSwitchType >::get_hpr(int frame, LVecBase3 &hpr)
 */
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_hpr_113(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACScalarSwitchType > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACScalarSwitchType, (void **)&local_this, "AnimChannel_ACScalarSwitchType.get_hpr")) {
    return nullptr;
  }
  // 1-virtual void AnimChannel< ACScalarSwitchType >::get_hpr(int frame, LVecBase3 &hpr)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "hpr", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_hpr", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_hpr", "LVecBase3f");
    }
    ((*local_this).get_hpr)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_hpr(const AnimChannel self, int frame, LVecBase3f hpr)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_hpr_113_comment =
  "C++ Interface:\n"
  "get_hpr(const AnimChannel self, int frame, LVecBase3f hpr)\n";
#else
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_hpr_113_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACScalarSwitchType >::get_quat(int frame, LQuaternion &quat)
 */
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_quat_114(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACScalarSwitchType > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACScalarSwitchType, (void **)&local_this, "AnimChannel_ACScalarSwitchType.get_quat")) {
    return nullptr;
  }
  // 1-virtual void AnimChannel< ACScalarSwitchType >::get_quat(int frame, LQuaternion &quat)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "quat", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_quat", (char **)keyword_list, &param1, &param2)) {
    LQuaternionf param2_local;
    LQuaternion *param2_this = Dtool_Coerce_LQuaternionf(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_quat", "LQuaternionf");
    }
    ((*local_this).get_quat)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_quat(const AnimChannel self, int frame, LQuaternionf quat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_quat_114_comment =
  "C++ Interface:\n"
  "get_quat(const AnimChannel self, int frame, LQuaternionf quat)\n";
#else
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_quat_114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACScalarSwitchType >::get_pos(int frame, LVecBase3 &pos)
 */
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_pos_115(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACScalarSwitchType > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACScalarSwitchType, (void **)&local_this, "AnimChannel_ACScalarSwitchType.get_pos")) {
    return nullptr;
  }
  // 1-virtual void AnimChannel< ACScalarSwitchType >::get_pos(int frame, LVecBase3 &pos)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "pos", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_pos", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_pos", "LVecBase3f");
    }
    ((*local_this).get_pos)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_pos(const AnimChannel self, int frame, LVecBase3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_pos_115_comment =
  "C++ Interface:\n"
  "get_pos(const AnimChannel self, int frame, LVecBase3f pos)\n";
#else
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_pos_115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimChannel< ACScalarSwitchType >::get_shear(int frame, LVecBase3 &shear)
 */
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_shear_116(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannel< ACScalarSwitchType > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannel_ACScalarSwitchType, (void **)&local_this, "AnimChannel_ACScalarSwitchType.get_shear")) {
    return nullptr;
  }
  // 1-virtual void AnimChannel< ACScalarSwitchType >::get_shear(int frame, LVecBase3 &shear)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"frame", "shear", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:get_shear", (char **)keyword_list, &param1, &param2)) {
    LVecBase3f param2_local;
    LVecBase3 *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannel.get_shear", "LVecBase3f");
    }
    ((*local_this).get_shear)((int)param1, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_shear(const AnimChannel self, int frame, LVecBase3f shear)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_shear_116_comment =
  "C++ Interface:\n"
  "get_shear(const AnimChannel self, int frame, LVecBase3f shear)\n";
#else
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_shear_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual TypeHandle AnimChannel< ACScalarSwitchType >::get_value_type(void) const
 */
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_value_type_117(PyObject *self, PyObject *) {
  AnimChannel< ACScalarSwitchType > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimChannel_ACScalarSwitchType)) {
    return nullptr;
  }
  // 1-virtual TypeHandle AnimChannel< ACScalarSwitchType >::get_value_type(void) const
  TypeHandle *return_value = new TypeHandle(((*(const AnimChannel< ACScalarSwitchType >*)local_this).get_value_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_value_type_117_comment =
  "C++ Interface:\n"
  "get_value_type(AnimChannel self)\n";
#else
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_value_type_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimChannel< ACScalarSwitchType >::get_class_type(void)
 */
static PyObject *Dtool_AnimChannel_ACScalarSwitchType_get_class_type_118(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimChannel< ACScalarSwitchType >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AnimChannel< ACScalarSwitchType >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_class_type_118_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimChannel_ACScalarSwitchType_get_class_type_118_comment = nullptr;
#endif

static int Dtool_Init_AnimChannel_ACScalarSwitchType(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AnimChannel_ACScalarSwitchType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AnimChannel_ACScalarSwitchType) {
    printf("AnimChannel_ACScalarSwitchType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AnimChannel< ACScalarSwitchType > *local_this = (AnimChannel< ACScalarSwitchType > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AnimChannel_ACScalarSwitchType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannelBase) {
    return (AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimGroup) {
    return (AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AnimChannel_ACScalarSwitchType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AnimChannel_ACScalarSwitchType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimChannelBase) {
    AnimChannelBase* other_this = (AnimChannelBase*)from_this;
    return (AnimChannel< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    AnimGroup* other_this = (AnimGroup*)from_this;
    return (AnimChannel< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimChannel< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimChannel< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimChannel< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimChannel< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimChannel< ACScalarSwitchType >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AnimChannelMatrixDynamic
 */
/**
 * Python function wrapper for:
 * void AnimChannelMatrixDynamic::set_value(LMatrix4 const &value)
 * void AnimChannelMatrixDynamic::set_value(TransformState const *value)
 */
static PyObject *Dtool_AnimChannelMatrixDynamic_set_value_121(PyObject *self, PyObject *arg) {
  AnimChannelMatrixDynamic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelMatrixDynamic, (void **)&local_this, "AnimChannelMatrixDynamic.set_value")) {
    return nullptr;
  }
  {
    // -2 void AnimChannelMatrixDynamic::set_value(LMatrix4 const &value)
    LMatrix4 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LMatrix4f);
    if (arg_this != nullptr) {
      ((*local_this).set_value)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void AnimChannelMatrixDynamic::set_value(TransformState const *value)
    TransformState const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TransformState);
    if (arg_this != nullptr) {
      ((*local_this).set_value)(arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void AnimChannelMatrixDynamic::set_value(LMatrix4 const &value)
    LMatrix4f arg_local;
    LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_value)(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void AnimChannelMatrixDynamic::set_value(TransformState const *value)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const AnimChannelMatrixDynamic self, const LMatrix4f value)\n"
      "set_value(const AnimChannelMatrixDynamic self, const TransformState value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixDynamic_set_value_121_comment =
  "C++ Interface:\n"
  "set_value(const AnimChannelMatrixDynamic self, const LMatrix4f value)\n"
  "set_value(const AnimChannelMatrixDynamic self, const TransformState value)\n"
  "\n"
  "/**\n"
  " * Explicitly sets the matrix value.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Explicitly sets the matrix value, using the indicated TransformState object\n"
  " * as a convenience.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixDynamic_set_value_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AnimChannelMatrixDynamic::set_value_node(PandaNode *node)
 */
static PyObject *Dtool_AnimChannelMatrixDynamic_set_value_node_122(PyObject *self, PyObject *arg) {
  AnimChannelMatrixDynamic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelMatrixDynamic, (void **)&local_this, "AnimChannelMatrixDynamic.set_value_node")) {
    return nullptr;
  }
  // 1-void AnimChannelMatrixDynamic::set_value_node(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "AnimChannelMatrixDynamic.set_value_node", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_value_node)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value_node(const AnimChannelMatrixDynamic self, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixDynamic_set_value_node_122_comment =
  "C++ Interface:\n"
  "set_value_node(const AnimChannelMatrixDynamic self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Specifies a node whose transform will be queried each frame to implicitly\n"
  " * specify the transform of this joint.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixDynamic_set_value_node_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TransformState const *AnimChannelMatrixDynamic::get_value_transform(void) const
 */
static PyObject *Dtool_AnimChannelMatrixDynamic_get_value_transform_123(PyObject *self, PyObject *) {
  AnimChannelMatrixDynamic *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimChannelMatrixDynamic)) {
    return nullptr;
  }
  // 1-inline TransformState const *AnimChannelMatrixDynamic::get_value_transform(void) const
  TransformState const *return_value = ((*(const AnimChannelMatrixDynamic*)local_this).get_value_transform)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TransformState, true, true);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixDynamic_get_value_transform_123_comment =
  "C++ Interface:\n"
  "get_value_transform(AnimChannelMatrixDynamic self)\n"
  "\n"
  "/**\n"
  " * Returns the explicit TransformState value that was set via set_value(), if\n"
  " * any.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixDynamic_get_value_transform_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PandaNode *AnimChannelMatrixDynamic::get_value_node(void) const
 */
static PyObject *Dtool_AnimChannelMatrixDynamic_get_value_node_124(PyObject *self, PyObject *) {
  AnimChannelMatrixDynamic *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimChannelMatrixDynamic)) {
    return nullptr;
  }
  // 1-inline PandaNode *AnimChannelMatrixDynamic::get_value_node(void) const
  PandaNode *return_value = ((*(const AnimChannelMatrixDynamic*)local_this).get_value_node)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixDynamic_get_value_node_124_comment =
  "C++ Interface:\n"
  "get_value_node(AnimChannelMatrixDynamic self)\n"
  "\n"
  "/**\n"
  " * Returns the node that was set via set_value_node(), if any.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixDynamic_get_value_node_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimChannelMatrixDynamic::get_class_type(void)
 */
static PyObject *Dtool_AnimChannelMatrixDynamic_get_class_type_127(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimChannelMatrixDynamic::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AnimChannelMatrixDynamic::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixDynamic_get_class_type_127_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimChannelMatrixDynamic_get_class_type_127_comment = nullptr;
#endif

static PyObject *Dtool_AnimChannelMatrixDynamic_value_node_Getter(PyObject *self, void *) {
  const AnimChannelMatrixDynamic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimChannelMatrixDynamic, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PandaNode *AnimChannelMatrixDynamic::get_value_node(void) const
  PandaNode *return_value = ((*(const AnimChannelMatrixDynamic*)local_this).get_value_node)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_AnimChannelMatrixDynamic_value_node_Setter(PyObject *self, PyObject *arg, void *) {
  AnimChannelMatrixDynamic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelMatrixDynamic, (void **)&local_this, "AnimChannelMatrixDynamic.value_node")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value_node attribute");
    return -1;
  }
  // 1-void AnimChannelMatrixDynamic::set_value_node(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "AnimChannelMatrixDynamic.set_value_node", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_value_node)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value_node(const AnimChannelMatrixDynamic self, PandaNode node)\n");
  }
  return -1;
}

static int Dtool_Init_AnimChannelMatrixDynamic(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AnimChannelMatrixDynamic(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AnimChannelMatrixDynamic) {
    printf("AnimChannelMatrixDynamic ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AnimChannelMatrixDynamic *local_this = (AnimChannelMatrixDynamic *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AnimChannelMatrixDynamic) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannel_ACMatrixSwitchType) {
    return (AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannelBase) {
    return (AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimGroup) {
    return (AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AnimChannelMatrixDynamic(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AnimChannelMatrixDynamic) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimChannel_ACMatrixSwitchType) {
    AnimChannel< ACMatrixSwitchType >* other_this = (AnimChannel< ACMatrixSwitchType >*)from_this;
    return (AnimChannelMatrixDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimChannelBase) {
    AnimChannelBase* other_this = (AnimChannelBase*)from_this;
    return (AnimChannelMatrixDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    AnimGroup* other_this = (AnimGroup*)from_this;
    return (AnimChannelMatrixDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimChannelMatrixDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimChannelMatrixDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimChannelMatrixDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimChannelMatrixDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimChannelMatrixDynamic*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AnimChannelMatrixXfmTable
 */
/**
 * Python function wrapper for:
 * static inline bool AnimChannelMatrixXfmTable::is_valid_id(char table_id)
 */
static PyObject *Dtool_AnimChannelMatrixXfmTable_is_valid_id_131(PyObject *, PyObject *arg) {
  // 1-static inline bool AnimChannelMatrixXfmTable::is_valid_id(char table_id)
  char *param0_str;
  Py_ssize_t param0_len;
  if (PyArg_Parse(arg, "s#:is_valid_id", &param0_str, &param0_len)) {
    if (param0_len == 1) {
      bool return_value = (AnimChannelMatrixXfmTable::is_valid_id)(param0_str[0]);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_valid_id(char table_id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixXfmTable_is_valid_id_131_comment =
  "C++ Interface:\n"
  "is_valid_id(char table_id)\n"
  "\n"
  "/**\n"
  " * Returns true if the given letter is one of the nine valid table id's.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixXfmTable_is_valid_id_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AnimChannelMatrixXfmTable::set_table(char table_id, CPTA_stdfloat const &table)
 */
static PyObject *Dtool_AnimChannelMatrixXfmTable_set_table_132(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimChannelMatrixXfmTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelMatrixXfmTable, (void **)&local_this, "AnimChannelMatrixXfmTable.set_table")) {
    return nullptr;
  }
  // 1-void AnimChannelMatrixXfmTable::set_table(char table_id, CPTA_stdfloat const &table)
  char *param1_str;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"table_id", "table", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_table", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    ConstPointerToArray< float > param2_local;
    CPTA_stdfloat const *param2_this = Dtool_Coerce_ConstPointerToArray_float(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "AnimChannelMatrixXfmTable.set_table", "ConstPointerToArray");
    }
    if (param1_len == 1) {
      ((*local_this).set_table)(param1_str[0], *param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_table(const AnimChannelMatrixXfmTable self, char table_id, const ConstPointerToArray table)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixXfmTable_set_table_132_comment =
  "C++ Interface:\n"
  "set_table(const AnimChannelMatrixXfmTable self, char table_id, const ConstPointerToArray table)\n"
  "\n"
  "/**\n"
  " * Assigns the indicated table.  table_id is one of 'i', 'j', 'k', for scale,\n"
  " * 'a', 'b', 'c' for shear, 'h', 'p', 'r', for rotation, and 'x', 'y', 'z',\n"
  " * for translation.  The new table must have either zero, one, or\n"
  " * get_num_frames() frames.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixXfmTable_set_table_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CPTA_stdfloat AnimChannelMatrixXfmTable::get_table(char table_id) const
 */
static PyObject *Dtool_AnimChannelMatrixXfmTable_get_table_133(PyObject *self, PyObject *arg) {
  AnimChannelMatrixXfmTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimChannelMatrixXfmTable)) {
    return nullptr;
  }
  // 1-inline CPTA_stdfloat AnimChannelMatrixXfmTable::get_table(char table_id) const
  char *param1_str;
  Py_ssize_t param1_len;
  if (PyArg_Parse(arg, "s#:get_table", &param1_str, &param1_len)) {
    if (param1_len == 1) {
      CPTA_stdfloat *return_value = new CPTA_stdfloat(((*(const AnimChannelMatrixXfmTable*)local_this).get_table)(param1_str[0]));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConstPointerToArray_float, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_table(AnimChannelMatrixXfmTable self, char table_id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixXfmTable_get_table_133_comment =
  "C++ Interface:\n"
  "get_table(AnimChannelMatrixXfmTable self, char table_id)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the indicated subtable's data, if it exists, or NULL\n"
  " * if it does not.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixXfmTable_get_table_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AnimChannelMatrixXfmTable::clear_all_tables(void)
 */
static PyObject *Dtool_AnimChannelMatrixXfmTable_clear_all_tables_134(PyObject *self, PyObject *) {
  AnimChannelMatrixXfmTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelMatrixXfmTable, (void **)&local_this, "AnimChannelMatrixXfmTable.clear_all_tables")) {
    return nullptr;
  }
  // 1-void AnimChannelMatrixXfmTable::clear_all_tables(void)
  ((*local_this).clear_all_tables)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixXfmTable_clear_all_tables_134_comment =
  "C++ Interface:\n"
  "clear_all_tables(const AnimChannelMatrixXfmTable self)\n"
  "\n"
  "/**\n"
  " * Removes all the tables from the channel, and resets it to its initial\n"
  " * state.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixXfmTable_clear_all_tables_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimChannelMatrixXfmTable::has_table(char table_id) const
 */
static PyObject *Dtool_AnimChannelMatrixXfmTable_has_table_135(PyObject *self, PyObject *arg) {
  AnimChannelMatrixXfmTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimChannelMatrixXfmTable)) {
    return nullptr;
  }
  // 1-inline bool AnimChannelMatrixXfmTable::has_table(char table_id) const
  char *param1_str;
  Py_ssize_t param1_len;
  if (PyArg_Parse(arg, "s#:has_table", &param1_str, &param1_len)) {
    if (param1_len == 1) {
      bool return_value = ((*(const AnimChannelMatrixXfmTable*)local_this).has_table)(param1_str[0]);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_table(AnimChannelMatrixXfmTable self, char table_id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixXfmTable_has_table_135_comment =
  "C++ Interface:\n"
  "has_table(AnimChannelMatrixXfmTable self, char table_id)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated subtable has been assigned.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixXfmTable_has_table_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AnimChannelMatrixXfmTable::clear_table(char table_id)
 */
static PyObject *Dtool_AnimChannelMatrixXfmTable_clear_table_136(PyObject *self, PyObject *arg) {
  AnimChannelMatrixXfmTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelMatrixXfmTable, (void **)&local_this, "AnimChannelMatrixXfmTable.clear_table")) {
    return nullptr;
  }
  // 1-inline void AnimChannelMatrixXfmTable::clear_table(char table_id)
  char *param1_str;
  Py_ssize_t param1_len;
  if (PyArg_Parse(arg, "s#:clear_table", &param1_str, &param1_len)) {
    if (param1_len == 1) {
      ((*local_this).clear_table)(param1_str[0]);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_table(const AnimChannelMatrixXfmTable self, char table_id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixXfmTable_clear_table_136_comment =
  "C++ Interface:\n"
  "clear_table(const AnimChannelMatrixXfmTable self, char table_id)\n"
  "\n"
  "/**\n"
  " * Removes the indicated table from the definition.\n"
  " */";
#else
static const char *Dtool_AnimChannelMatrixXfmTable_clear_table_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimChannelMatrixXfmTable::get_class_type(void)
 */
static PyObject *Dtool_AnimChannelMatrixXfmTable_get_class_type_141(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimChannelMatrixXfmTable::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AnimChannelMatrixXfmTable::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelMatrixXfmTable_get_class_type_141_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimChannelMatrixXfmTable_get_class_type_141_comment = nullptr;
#endif

/**
 * mapping getitem for property AnimChannelMatrixXfmTable::tables
 */
static PyObject *Dtool_AnimChannelMatrixXfmTable_tables_Mapping_Getitem(PyObject *self, PyObject *arg) {
  AnimChannelMatrixXfmTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimChannelMatrixXfmTable, (void **)&local_this)) {
    return nullptr;
  }
  {
    // 1-inline bool AnimChannelMatrixXfmTable::has_table(char table_id) const
    char *param1_str;
    Py_ssize_t param1_len;
    if (PyArg_Parse(arg, "s#:has_table", &param1_str, &param1_len)) {
      if (param1_len == 1) {
        bool return_value = ((*(const AnimChannelMatrixXfmTable*)local_this).has_table)(param1_str[0]);
        if (!return_value) {
          PyErr_SetObject(PyExc_KeyError, arg);
          return nullptr;
        }
      }
    }
  }
  // 1-inline CPTA_stdfloat AnimChannelMatrixXfmTable::get_table(char table_id) const
  char *param1_str;
  Py_ssize_t param1_len;
  if (PyArg_Parse(arg, "s#:get_table", &param1_str, &param1_len)) {
    if (param1_len == 1) {
      CPTA_stdfloat *return_value = new CPTA_stdfloat(((*(const AnimChannelMatrixXfmTable*)local_this).get_table)(param1_str[0]));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        delete return_value;
        return Dtool_Raise_AssertionError();
      }
#endif
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConstPointerToArray_float, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_table(AnimChannelMatrixXfmTable self, char table_id)\n");
  }
  return nullptr;
}

/**
 * mapping setitem for property AnimChannelMatrixXfmTable::tables
 */
static int Dtool_AnimChannelMatrixXfmTable_tables_Mapping_Setitem(PyObject *self, PyObject *key, PyObject *value) {
  AnimChannelMatrixXfmTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelMatrixXfmTable, (void **)&local_this, "AnimChannelMatrixXfmTable.tables")) {
    return -1;
  }

  if (value == nullptr) {
    PyObject *arg = key;
    {
      // 1-inline bool AnimChannelMatrixXfmTable::has_table(char table_id) const
      char *param1_str;
      Py_ssize_t param1_len;
      if (PyArg_Parse(arg, "s#:has_table", &param1_str, &param1_len)) {
        if (param1_len == 1) {
          bool return_value = ((*(const AnimChannelMatrixXfmTable*)local_this).has_table)(param1_str[0]);
          if (!return_value) {
            PyErr_SetObject(PyExc_KeyError, arg);
            return -1;
          }
        }
      }
    }
    // 1-inline void AnimChannelMatrixXfmTable::clear_table(char table_id)
    char *param1_str;
    Py_ssize_t param1_len;
    if (PyArg_Parse(arg, "s#:clear_table", &param1_str, &param1_len)) {
      if (param1_len == 1) {
        ((*local_this).clear_table)(param1_str[0]);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    }
    return -1;
  }
  PyObject *args = PyTuple_New(2);
  PyTuple_SET_ITEM(args, 0, key);
  PyTuple_SET_ITEM(args, 1, value);
  Py_INCREF(key);
  Py_INCREF(value);
  // 1-void AnimChannelMatrixXfmTable::set_table(char table_id, CPTA_stdfloat const &table)
  char *param1_str;
  Py_ssize_t param1_len;
  PyObject *param2;
  if (PyArg_ParseTuple(args, "s#O:set_table", &param1_str, &param1_len, &param2)) {
    ConstPointerToArray< float > param2_local;
    CPTA_stdfloat const *param2_this = Dtool_Coerce_ConstPointerToArray_float(param2, param2_local);
    if (!(param2_this != nullptr)) {
      Dtool_Raise_ArgTypeError(param2, 2, "AnimChannelMatrixXfmTable.set_table", "ConstPointerToArray");
      Py_DECREF(args);
      return -1;
    }
    if (param1_len == 1) {
      ((*local_this).set_table)(param1_str[0], *param2_this);
      Py_DECREF(args);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_table(const AnimChannelMatrixXfmTable self, char table_id, const ConstPointerToArray table)\n");
  }
  Py_DECREF(args);
  return -1;
}

static PyObject *Dtool_AnimChannelMatrixXfmTable_tables_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MappingWrapper *wrap = Dtool_NewMutableMappingWrapper(self, "AnimChannelMatrixXfmTable.tables");
  if (wrap != nullptr) {
    wrap->_getitem_func = &Dtool_AnimChannelMatrixXfmTable_tables_Mapping_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_AnimChannelMatrixXfmTable_tables_Mapping_Setitem;
    }
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * explicit AnimChannelMatrixXfmTable::AnimChannelMatrixXfmTable(AnimGroup *parent, std::string const &name)
 */
static int Dtool_Init_AnimChannelMatrixXfmTable(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit AnimChannelMatrixXfmTable::AnimChannelMatrixXfmTable(AnimGroup *parent, std::string const &name)
  PyObject *param0;
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"parent", "name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:AnimChannelMatrixXfmTable", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
    AnimGroup *param0_this = (AnimGroup *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AnimGroup, 0, "AnimChannelMatrixXfmTable.AnimChannelMatrixXfmTable", false, true);
    if (param0_this != nullptr) {
      AnimChannelMatrixXfmTable *return_value = new AnimChannelMatrixXfmTable(param0_this, std::string(param1_str, param1_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimChannelMatrixXfmTable, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AnimChannelMatrixXfmTable(AnimGroup parent, str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AnimChannelMatrixXfmTable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AnimChannelMatrixXfmTable) {
    printf("AnimChannelMatrixXfmTable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AnimChannelMatrixXfmTable *local_this = (AnimChannelMatrixXfmTable *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AnimChannelMatrixXfmTable) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannel_ACMatrixSwitchType) {
    return (AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannelBase) {
    return (AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimGroup) {
    return (AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACMatrixSwitchType > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AnimChannelMatrixXfmTable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AnimChannelMatrixXfmTable) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimChannel_ACMatrixSwitchType) {
    AnimChannel< ACMatrixSwitchType >* other_this = (AnimChannel< ACMatrixSwitchType >*)from_this;
    return (AnimChannelMatrixXfmTable*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimChannelBase) {
    AnimChannelBase* other_this = (AnimChannelBase*)from_this;
    return (AnimChannelMatrixXfmTable*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    AnimGroup* other_this = (AnimGroup*)from_this;
    return (AnimChannelMatrixXfmTable*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimChannelMatrixXfmTable*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimChannelMatrixXfmTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimChannelMatrixXfmTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimChannelMatrixXfmTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimChannelMatrixXfmTable*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AnimChannelScalarDynamic
 */
/**
 * Python function wrapper for:
 * void AnimChannelScalarDynamic::set_value(PN_stdfloat value)
 */
static PyObject *Dtool_AnimChannelScalarDynamic_set_value_143(PyObject *self, PyObject *arg) {
  AnimChannelScalarDynamic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelScalarDynamic, (void **)&local_this, "AnimChannelScalarDynamic.set_value")) {
    return nullptr;
  }
  // 1-void AnimChannelScalarDynamic::set_value(PN_stdfloat value)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_value)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const AnimChannelScalarDynamic self, float value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelScalarDynamic_set_value_143_comment =
  "C++ Interface:\n"
  "set_value(const AnimChannelScalarDynamic self, float value)\n"
  "\n"
  "/**\n"
  " * Explicitly sets the value.  This will remove any node assigned via\n"
  " * set_value_node().\n"
  " */";
#else
static const char *Dtool_AnimChannelScalarDynamic_set_value_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AnimChannelScalarDynamic::set_value_node(PandaNode *node)
 */
static PyObject *Dtool_AnimChannelScalarDynamic_set_value_node_144(PyObject *self, PyObject *arg) {
  AnimChannelScalarDynamic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelScalarDynamic, (void **)&local_this, "AnimChannelScalarDynamic.set_value_node")) {
    return nullptr;
  }
  // 1-void AnimChannelScalarDynamic::set_value_node(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "AnimChannelScalarDynamic.set_value_node", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_value_node)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value_node(const AnimChannelScalarDynamic self, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelScalarDynamic_set_value_node_144_comment =
  "C++ Interface:\n"
  "set_value_node(const AnimChannelScalarDynamic self, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Specifies a node whose transform will be queried each frame to implicitly\n"
  " * specify the transform of this joint.  This will override the values set by\n"
  " * set_value().\n"
  " */";
#else
static const char *Dtool_AnimChannelScalarDynamic_set_value_node_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimChannelScalarDynamic::get_class_type(void)
 */
static PyObject *Dtool_AnimChannelScalarDynamic_get_class_type_151(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimChannelScalarDynamic::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AnimChannelScalarDynamic::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelScalarDynamic_get_class_type_151_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimChannelScalarDynamic_get_class_type_151_comment = nullptr;
#endif

static PyObject *Dtool_AnimChannelScalarDynamic_value_Getter(PyObject *self, void *) {
  const AnimChannelScalarDynamic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimChannelScalarDynamic, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PN_stdfloat AnimChannelScalarDynamic::get_value(void) const
  PN_stdfloat return_value = ((*(const AnimChannelScalarDynamic*)local_this).get_value)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_AnimChannelScalarDynamic_value_Setter(PyObject *self, PyObject *arg, void *) {
  AnimChannelScalarDynamic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelScalarDynamic, (void **)&local_this, "AnimChannelScalarDynamic.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-void AnimChannelScalarDynamic::set_value(PN_stdfloat value)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_value)((PN_stdfloat)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const AnimChannelScalarDynamic self, float value)\n");
  }
  return -1;
}

static PyObject *Dtool_AnimChannelScalarDynamic_value_node_Getter(PyObject *self, void *) {
  const AnimChannelScalarDynamic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimChannelScalarDynamic, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PandaNode *AnimChannelScalarDynamic::get_value_node(void) const
  PandaNode *return_value = ((*(const AnimChannelScalarDynamic*)local_this).get_value_node)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PandaNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_AnimChannelScalarDynamic_value_node_Setter(PyObject *self, PyObject *arg, void *) {
  AnimChannelScalarDynamic *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelScalarDynamic, (void **)&local_this, "AnimChannelScalarDynamic.value_node")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value_node attribute");
    return -1;
  }
  // 1-void AnimChannelScalarDynamic::set_value_node(PandaNode *node)
  PandaNode *arg_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PandaNode, 1, "AnimChannelScalarDynamic.set_value_node", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_value_node)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value_node(const AnimChannelScalarDynamic self, PandaNode node)\n");
  }
  return -1;
}

static int Dtool_Init_AnimChannelScalarDynamic(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AnimChannelScalarDynamic(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AnimChannelScalarDynamic) {
    printf("AnimChannelScalarDynamic ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AnimChannelScalarDynamic *local_this = (AnimChannelScalarDynamic *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AnimChannelScalarDynamic) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannel_ACScalarSwitchType) {
    return (AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannelBase) {
    return (AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimGroup) {
    return (AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AnimChannelScalarDynamic(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AnimChannelScalarDynamic) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimChannel_ACScalarSwitchType) {
    AnimChannel< ACScalarSwitchType >* other_this = (AnimChannel< ACScalarSwitchType >*)from_this;
    return (AnimChannelScalarDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimChannelBase) {
    AnimChannelBase* other_this = (AnimChannelBase*)from_this;
    return (AnimChannelScalarDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    AnimGroup* other_this = (AnimGroup*)from_this;
    return (AnimChannelScalarDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimChannelScalarDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimChannelScalarDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimChannelScalarDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimChannelScalarDynamic*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimChannelScalarDynamic*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AnimChannelScalarTable
 */
/**
 * Python function wrapper for:
 * void AnimChannelScalarTable::set_table(CPTA_stdfloat const &table)
 */
static PyObject *Dtool_AnimChannelScalarTable_set_table_155(PyObject *self, PyObject *arg) {
  AnimChannelScalarTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelScalarTable, (void **)&local_this, "AnimChannelScalarTable.set_table")) {
    return nullptr;
  }
  // 1-void AnimChannelScalarTable::set_table(CPTA_stdfloat const &table)
  ConstPointerToArray< float > arg_local;
  CPTA_stdfloat const *arg_this = Dtool_Coerce_ConstPointerToArray_float(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "AnimChannelScalarTable.set_table", "ConstPointerToArray");
  }
  ((*local_this).set_table)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_table(const AnimChannelScalarTable self, const ConstPointerToArray table)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelScalarTable_set_table_155_comment =
  "C++ Interface:\n"
  "set_table(const AnimChannelScalarTable self, const ConstPointerToArray table)\n"
  "\n"
  "/**\n"
  " * Assigns the data table.\n"
  " */";
#else
static const char *Dtool_AnimChannelScalarTable_set_table_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CPTA_stdfloat AnimChannelScalarTable::get_table(void) const
 */
static PyObject *Dtool_AnimChannelScalarTable_get_table_156(PyObject *self, PyObject *) {
  AnimChannelScalarTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimChannelScalarTable)) {
    return nullptr;
  }
  // 1-inline CPTA_stdfloat AnimChannelScalarTable::get_table(void) const
  CPTA_stdfloat *return_value = new CPTA_stdfloat(((*(const AnimChannelScalarTable*)local_this).get_table)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConstPointerToArray_float, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelScalarTable_get_table_156_comment =
  "C++ Interface:\n"
  "get_table(AnimChannelScalarTable self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the table's data, if it exists, or NULL if it does\n"
  " * not.\n"
  " */";
#else
static const char *Dtool_AnimChannelScalarTable_get_table_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimChannelScalarTable::has_table(void) const
 */
static PyObject *Dtool_AnimChannelScalarTable_has_table_157(PyObject *self, PyObject *) {
  AnimChannelScalarTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimChannelScalarTable)) {
    return nullptr;
  }
  // 1-inline bool AnimChannelScalarTable::has_table(void) const
  bool return_value = ((*(const AnimChannelScalarTable*)local_this).has_table)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelScalarTable_has_table_157_comment =
  "C++ Interface:\n"
  "has_table(AnimChannelScalarTable self)\n"
  "\n"
  "/**\n"
  " * Returns true if the data table has been assigned.\n"
  " */";
#else
static const char *Dtool_AnimChannelScalarTable_has_table_157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AnimChannelScalarTable::clear_table(void)
 */
static PyObject *Dtool_AnimChannelScalarTable_clear_table_158(PyObject *self, PyObject *) {
  AnimChannelScalarTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelScalarTable, (void **)&local_this, "AnimChannelScalarTable.clear_table")) {
    return nullptr;
  }
  // 1-inline void AnimChannelScalarTable::clear_table(void)
  ((*local_this).clear_table)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelScalarTable_clear_table_158_comment =
  "C++ Interface:\n"
  "clear_table(const AnimChannelScalarTable self)\n"
  "\n"
  "/**\n"
  " * Empties the data table.\n"
  " */";
#else
static const char *Dtool_AnimChannelScalarTable_clear_table_158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimChannelScalarTable::get_class_type(void)
 */
static PyObject *Dtool_AnimChannelScalarTable_get_class_type_160(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimChannelScalarTable::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AnimChannelScalarTable::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimChannelScalarTable_get_class_type_160_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimChannelScalarTable_get_class_type_160_comment = nullptr;
#endif

static PyObject *Dtool_AnimChannelScalarTable_table_Getter(PyObject *self, void *) {
  const AnimChannelScalarTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimChannelScalarTable, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_table()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline CPTA_stdfloat AnimChannelScalarTable::get_table(void) const
  CPTA_stdfloat *return_value = new CPTA_stdfloat(((*(const AnimChannelScalarTable*)local_this).get_table)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConstPointerToArray_float, true, false);
}

static int Dtool_AnimChannelScalarTable_table_Setter(PyObject *self, PyObject *arg, void *) {
  AnimChannelScalarTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimChannelScalarTable, (void **)&local_this, "AnimChannelScalarTable.table")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete table attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_table();
    return 0;
  }
  // 1-void AnimChannelScalarTable::set_table(CPTA_stdfloat const &table)
  ConstPointerToArray< float > arg_local;
  CPTA_stdfloat const *arg_this = Dtool_Coerce_ConstPointerToArray_float(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "AnimChannelScalarTable.set_table", "ConstPointerToArray");
    return -1;
  }
  ((*local_this).set_table)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_table(const AnimChannelScalarTable self, const ConstPointerToArray table)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * AnimChannelScalarTable::AnimChannelScalarTable(AnimGroup *parent, std::string const &name)
 */
static int Dtool_Init_AnimChannelScalarTable(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-AnimChannelScalarTable::AnimChannelScalarTable(AnimGroup *parent, std::string const &name)
  PyObject *param0;
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"parent", "name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:AnimChannelScalarTable", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
    AnimGroup *param0_this = (AnimGroup *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AnimGroup, 0, "AnimChannelScalarTable.AnimChannelScalarTable", false, true);
    if (param0_this != nullptr) {
      AnimChannelScalarTable *return_value = new AnimChannelScalarTable(param0_this, std::string(param1_str, param1_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimChannelScalarTable, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AnimChannelScalarTable(AnimGroup parent, str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_AnimChannelScalarTable(PyObject *args, CPT(AnimChannelScalarTable) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_AnimChannelScalarTable)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-AnimChannelScalarTable::AnimChannelScalarTable(AnimGroup *parent, std::string const &name)
      PyObject *param0;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:AnimChannelScalarTable", &param0, &param1_str, &param1_len)) {
        AnimGroup *param0_this = (AnimGroup *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AnimGroup, 0, "AnimChannelScalarTable.AnimChannelScalarTable", false, false);
        if (param0_this != nullptr) {
          AnimChannelScalarTable *return_value = new AnimChannelScalarTable(param0_this, std::string(param1_str, param1_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_AnimChannelScalarTable(PyObject *args, PT(AnimChannelScalarTable) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_AnimChannelScalarTable)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-AnimChannelScalarTable::AnimChannelScalarTable(AnimGroup *parent, std::string const &name)
      PyObject *param0;
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      if (PyArg_ParseTuple(args, "Os#:AnimChannelScalarTable", &param0, &param1_str, &param1_len)) {
        AnimGroup *param0_this = (AnimGroup *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_AnimGroup, 0, "AnimChannelScalarTable.AnimChannelScalarTable", false, false);
        if (param0_this != nullptr) {
          AnimChannelScalarTable *return_value = new AnimChannelScalarTable(param0_this, std::string(param1_str, param1_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_AnimChannelScalarTable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AnimChannelScalarTable) {
    printf("AnimChannelScalarTable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AnimChannelScalarTable *local_this = (AnimChannelScalarTable *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AnimChannelScalarTable) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannel_ACScalarSwitchType) {
    return (AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimChannelBase) {
    return (AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_AnimGroup) {
    return (AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(AnimGroup *)(AnimChannelBase *)(AnimChannel< ACScalarSwitchType > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AnimChannelScalarTable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AnimChannelScalarTable) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AnimChannel_ACScalarSwitchType) {
    AnimChannel< ACScalarSwitchType >* other_this = (AnimChannel< ACScalarSwitchType >*)from_this;
    return (AnimChannelScalarTable*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimChannelBase) {
    AnimChannelBase* other_this = (AnimChannelBase*)from_this;
    return (AnimChannelScalarTable*)other_this;
  }
  if (from_type == Dtool_Ptr_AnimGroup) {
    AnimGroup* other_this = (AnimGroup*)from_this;
    return (AnimChannelScalarTable*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (AnimChannelScalarTable*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimChannelScalarTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimChannelScalarTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimChannelScalarTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimChannelScalarTable*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AnimControlCollection
 */
/**
 * Python function wrapper for:
 * void AnimControlCollection::store_anim(AnimControl *control, std::string const &name)
 */
static PyObject *Dtool_AnimControlCollection_store_anim_165(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimControlCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.store_anim")) {
    return nullptr;
  }
  // 1-void AnimControlCollection::store_anim(AnimControl *control, std::string const &name)
  PyObject *param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"control", "name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:store_anim", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    AnimControl *param1_this = (AnimControl *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_AnimControl, 1, "AnimControlCollection.store_anim", false, true);
    if (param1_this != nullptr) {
      ((*local_this).store_anim)(param1_this, std::string(param2_str, param2_len));
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store_anim(const AnimControlCollection self, AnimControl control, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_store_anim_165_comment =
  "C++ Interface:\n"
  "store_anim(const AnimControlCollection self, AnimControl control, str name)\n"
  "\n"
  "/**\n"
  " * Associates the given AnimControl with this collection under the given name.\n"
  " * The AnimControl will remain associated until a new AnimControl is\n"
  " * associated with the same name later, or until unbind_anim() is called with\n"
  " * this name.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_store_anim_165_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AnimControl *AnimControlCollection::find_anim(std::string const &name) const
 */
static PyObject *Dtool_AnimControlCollection_find_anim_166(PyObject *self, PyObject *arg) {
  AnimControlCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControlCollection)) {
    return nullptr;
  }
  // 1-AnimControl *AnimControlCollection::find_anim(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    AnimControl *return_value = ((*(const AnimControlCollection*)local_this).find_anim)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimControl, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_anim(AnimControlCollection self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_find_anim_166_comment =
  "C++ Interface:\n"
  "find_anim(AnimControlCollection self, str name)\n"
  "\n"
  "/**\n"
  " * Returns the AnimControl associated with the given name, or NULL if no such\n"
  " * control has been associated.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_find_anim_166_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool AnimControlCollection::unbind_anim(std::string const &name)
 */
static PyObject *Dtool_AnimControlCollection_unbind_anim_167(PyObject *self, PyObject *arg) {
  AnimControlCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.unbind_anim")) {
    return nullptr;
  }
  // 1-bool AnimControlCollection::unbind_anim(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*local_this).unbind_anim)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unbind_anim(const AnimControlCollection self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_unbind_anim_167_comment =
  "C++ Interface:\n"
  "unbind_anim(const AnimControlCollection self, str name)\n"
  "\n"
  "/**\n"
  " * Removes the AnimControl associated with the given name, if any.  Returns\n"
  " * true if an AnimControl was removed, false if there was no AnimControl with\n"
  " * the indicated name.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_unbind_anim_167_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int AnimControlCollection::get_num_anims(void) const
 */
static PyObject *Dtool_AnimControlCollection_get_num_anims_168(PyObject *self, PyObject *) {
  AnimControlCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControlCollection)) {
    return nullptr;
  }
  // 1-int AnimControlCollection::get_num_anims(void) const
  int return_value = ((*(const AnimControlCollection*)local_this).get_num_anims)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_get_num_anims_168_comment =
  "C++ Interface:\n"
  "get_num_anims(AnimControlCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of AnimControls associated with this collection.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_get_num_anims_168_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AnimControl *AnimControlCollection::get_anim(int n) const
 */
static PyObject *Dtool_AnimControlCollection_get_anim_169(PyObject *self, PyObject *arg) {
  AnimControlCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControlCollection)) {
    return nullptr;
  }
  // 1-AnimControl *AnimControlCollection::get_anim(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    AnimControl *return_value = ((*(const AnimControlCollection*)local_this).get_anim)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimControl, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_anim(AnimControlCollection self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_get_anim_169_comment =
  "C++ Interface:\n"
  "get_anim(AnimControlCollection self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth AnimControl associated with this collection.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_get_anim_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string AnimControlCollection::get_anim_name(int n) const
 */
static PyObject *Dtool_AnimControlCollection_get_anim_name_170(PyObject *self, PyObject *arg) {
  AnimControlCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControlCollection)) {
    return nullptr;
  }
  // 1-std::string AnimControlCollection::get_anim_name(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const AnimControlCollection*)local_this).get_anim_name)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_anim_name(AnimControlCollection self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_get_anim_name_170_comment =
  "C++ Interface:\n"
  "get_anim_name(AnimControlCollection self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the name of the nth AnimControl associated with this collection.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_get_anim_name_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AnimControlCollection::clear_anims(void)
 */
static PyObject *Dtool_AnimControlCollection_clear_anims_173(PyObject *self, PyObject *) {
  AnimControlCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.clear_anims")) {
    return nullptr;
  }
  // 1-void AnimControlCollection::clear_anims(void)
  ((*local_this).clear_anims)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_clear_anims_173_comment =
  "C++ Interface:\n"
  "clear_anims(const AnimControlCollection self)\n"
  "\n"
  "/**\n"
  " * Disassociates all anims from this collection.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_clear_anims_173_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimControlCollection::play(std::string const &anim_name)
 * inline bool AnimControlCollection::play(std::string const &anim_name, double from, double to)
 */
static PyObject *Dtool_AnimControlCollection_play_174(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimControlCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.play")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "anim_name")) {
        // 1-inline bool AnimControlCollection::play(std::string const &anim_name)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          bool return_value = ((*local_this).play)(std::string(param1_str, param1_len));
          return Dtool_Return_Bool(return_value);
        }
      }
    }
    break;
  case 3:
    {
      // 1-inline bool AnimControlCollection::play(std::string const &anim_name, double from, double to)
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      double param2;
      double param3;
      static const char *keyword_list[] = {"anim_name", "from", "to", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#dd:play", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
        bool return_value = ((*local_this).play)(std::string(param1_str, param1_len), (double)param2, (double)param3);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "play() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "play(const AnimControlCollection self, str anim_name)\n"
      "play(const AnimControlCollection self, str anim_name, double from, double to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_play_174_comment =
  "C++ Interface:\n"
  "play(const AnimControlCollection self, str anim_name)\n"
  "play(const AnimControlCollection self, str anim_name, double from, double to)\n"
  "\n"
  "/**\n"
  " * Starts the named animation playing.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Starts the named animation playing.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_play_174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimControlCollection::loop(std::string const &anim_name, bool restart)
 * inline bool AnimControlCollection::loop(std::string const &anim_name, bool restart, double from, double to)
 */
static PyObject *Dtool_AnimControlCollection_loop_175(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimControlCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.loop")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline bool AnimControlCollection::loop(std::string const &anim_name, bool restart)
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      PyObject *param2;
      static const char *keyword_list[] = {"anim_name", "restart", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:loop", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
        bool return_value = ((*local_this).loop)(std::string(param1_str, param1_len), (PyObject_IsTrue(param2) != 0));
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
  case 4:
    {
      // 1-inline bool AnimControlCollection::loop(std::string const &anim_name, bool restart, double from, double to)
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      PyObject *param2;
      double param3;
      double param4;
      static const char *keyword_list[] = {"anim_name", "restart", "from", "to", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#Odd:loop", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3, &param4)) {
        bool return_value = ((*local_this).loop)(std::string(param1_str, param1_len), (PyObject_IsTrue(param2) != 0), (double)param3, (double)param4);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "loop() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "loop(const AnimControlCollection self, str anim_name, bool restart)\n"
      "loop(const AnimControlCollection self, str anim_name, bool restart, double from, double to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_loop_175_comment =
  "C++ Interface:\n"
  "loop(const AnimControlCollection self, str anim_name, bool restart)\n"
  "loop(const AnimControlCollection self, str anim_name, bool restart, double from, double to)\n"
  "\n"
  "/**\n"
  " * Starts the named animation looping.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Starts the named animation looping.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_loop_175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimControlCollection::stop(std::string const &anim_name)
 */
static PyObject *Dtool_AnimControlCollection_stop_176(PyObject *self, PyObject *arg) {
  AnimControlCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.stop")) {
    return nullptr;
  }
  // 1-inline bool AnimControlCollection::stop(std::string const &anim_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*local_this).stop)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "stop(const AnimControlCollection self, str anim_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_stop_176_comment =
  "C++ Interface:\n"
  "stop(const AnimControlCollection self, str anim_name)\n"
  "\n"
  "/**\n"
  " * Stops the named animation.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_stop_176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimControlCollection::pose(std::string const &anim_name, double frame)
 */
static PyObject *Dtool_AnimControlCollection_pose_177(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimControlCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.pose")) {
    return nullptr;
  }
  // 1-inline bool AnimControlCollection::pose(std::string const &anim_name, double frame)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  double param2;
  static const char *keyword_list[] = {"anim_name", "frame", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#d:pose", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    bool return_value = ((*local_this).pose)(std::string(param1_str, param1_len), (double)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pose(const AnimControlCollection self, str anim_name, double frame)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_pose_177_comment =
  "C++ Interface:\n"
  "pose(const AnimControlCollection self, str anim_name, double frame)\n"
  "\n"
  "/**\n"
  " * Sets to a particular frame in the named animation.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_pose_177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AnimControlCollection::play_all(void)
 * void AnimControlCollection::play_all(double from, double to)
 */
static PyObject *Dtool_AnimControlCollection_play_all_178(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimControlCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.play_all")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-void AnimControlCollection::play_all(void)
      ((*local_this).play_all)();
      return Dtool_Return_None();
    }
    break;
  case 2:
    {
      // 1-void AnimControlCollection::play_all(double from, double to)
      double param1;
      double param2;
      static const char *keyword_list[] = {"from", "to", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:play_all", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).play_all)((double)param1, (double)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "play_all() takes 1 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "play_all(const AnimControlCollection self)\n"
      "play_all(const AnimControlCollection self, double from, double to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_play_all_178_comment =
  "C++ Interface:\n"
  "play_all(const AnimControlCollection self)\n"
  "play_all(const AnimControlCollection self, double from, double to)\n"
  "\n"
  "// These functions operate on all anims at once.\n"
  "\n"
  "/**\n"
  " * Starts all animations playing.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Starts all animations playing.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_play_all_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AnimControlCollection::loop_all(bool restart)
 * void AnimControlCollection::loop_all(bool restart, double from, double to)
 */
static PyObject *Dtool_AnimControlCollection_loop_all_179(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimControlCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.loop_all")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "restart")) {
        // 1-void AnimControlCollection::loop_all(bool restart)
        ((*local_this).loop_all)((PyObject_IsTrue(arg) != 0));
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-void AnimControlCollection::loop_all(bool restart, double from, double to)
      PyObject *param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"restart", "from", "to", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Odd:loop_all", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).loop_all)((PyObject_IsTrue(param1) != 0), (double)param2, (double)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "loop_all() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "loop_all(const AnimControlCollection self, bool restart)\n"
      "loop_all(const AnimControlCollection self, bool restart, double from, double to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_loop_all_179_comment =
  "C++ Interface:\n"
  "loop_all(const AnimControlCollection self, bool restart)\n"
  "loop_all(const AnimControlCollection self, bool restart, double from, double to)\n"
  "\n"
  "/**\n"
  " * Starts all animations looping.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Starts all animations looping.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_loop_all_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool AnimControlCollection::stop_all(void)
 */
static PyObject *Dtool_AnimControlCollection_stop_all_180(PyObject *self, PyObject *) {
  AnimControlCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.stop_all")) {
    return nullptr;
  }
  // 1-bool AnimControlCollection::stop_all(void)
  bool return_value = ((*local_this).stop_all)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_stop_all_180_comment =
  "C++ Interface:\n"
  "stop_all(const AnimControlCollection self)\n"
  "\n"
  "/**\n"
  " * Stops all currently playing animations.  Returns true if any animations\n"
  " * were stopped, false if none were playing.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_stop_all_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AnimControlCollection::pose_all(double frame)
 */
static PyObject *Dtool_AnimControlCollection_pose_all_181(PyObject *self, PyObject *arg) {
  AnimControlCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimControlCollection, (void **)&local_this, "AnimControlCollection.pose_all")) {
    return nullptr;
  }
  // 1-void AnimControlCollection::pose_all(double frame)
  if (PyNumber_Check(arg)) {
    ((*local_this).pose_all)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pose_all(const AnimControlCollection self, double frame)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_pose_all_181_comment =
  "C++ Interface:\n"
  "pose_all(const AnimControlCollection self, double frame)\n"
  "\n"
  "/**\n"
  " * Sets all animations to the indicated frame.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_pose_all_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int AnimControlCollection::get_frame(void) const
 * inline int AnimControlCollection::get_frame(std::string const &anim_name) const
 */
static PyObject *Dtool_AnimControlCollection_get_frame_182(PyObject *self, PyObject *args) {
  AnimControlCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControlCollection)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline int AnimControlCollection::get_frame(void) const
      int return_value = ((*(const AnimControlCollection*)local_this).get_frame)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline int AnimControlCollection::get_frame(std::string const &anim_name) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        int return_value = ((*(const AnimControlCollection*)local_this).get_frame)(std::string(param1_str, param1_len));
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_frame() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_frame(AnimControlCollection self)\n"
      "get_frame(AnimControlCollection self, str anim_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_get_frame_182_comment =
  "C++ Interface:\n"
  "get_frame(AnimControlCollection self)\n"
  "get_frame(AnimControlCollection self, str anim_name)\n"
  "\n"
  "/**\n"
  " * Returns the current frame in the named animation, or 0 if the animation is\n"
  " * not found.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the current frame in the last-started animation.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_get_frame_182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int AnimControlCollection::get_num_frames(void) const
 * inline int AnimControlCollection::get_num_frames(std::string const &anim_name) const
 */
static PyObject *Dtool_AnimControlCollection_get_num_frames_183(PyObject *self, PyObject *args) {
  AnimControlCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControlCollection)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline int AnimControlCollection::get_num_frames(void) const
      int return_value = ((*(const AnimControlCollection*)local_this).get_num_frames)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline int AnimControlCollection::get_num_frames(std::string const &anim_name) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        int return_value = ((*(const AnimControlCollection*)local_this).get_num_frames)(std::string(param1_str, param1_len));
        if (Dtool_CheckErrorOccurred()) {
          return nullptr;
        }
        return Dtool_WrapValue(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "get_num_frames() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_frames(AnimControlCollection self)\n"
      "get_num_frames(AnimControlCollection self, str anim_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_get_num_frames_183_comment =
  "C++ Interface:\n"
  "get_num_frames(AnimControlCollection self)\n"
  "get_num_frames(AnimControlCollection self, str anim_name)\n"
  "\n"
  "/**\n"
  " * Returns the total number of frames in the named animation, or 0 if the\n"
  " * animation is not found.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the total number of frames in the last-started animation.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_get_num_frames_183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimControlCollection::is_playing(void) const
 * inline bool AnimControlCollection::is_playing(std::string const &anim_name) const
 */
static PyObject *Dtool_AnimControlCollection_is_playing_184(PyObject *self, PyObject *args) {
  AnimControlCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControlCollection)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline bool AnimControlCollection::is_playing(void) const
      bool return_value = ((*(const AnimControlCollection*)local_this).is_playing)();
      return Dtool_Return_Bool(return_value);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline bool AnimControlCollection::is_playing(std::string const &anim_name) const
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
      param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
        param1_str = nullptr;
      }
#endif
      if (param1_str != nullptr) {
        bool return_value = ((*(const AnimControlCollection*)local_this).is_playing)(std::string(param1_str, param1_len));
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "is_playing() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_playing(AnimControlCollection self)\n"
      "is_playing(AnimControlCollection self, str anim_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_is_playing_184_comment =
  "C++ Interface:\n"
  "is_playing(AnimControlCollection self)\n"
  "is_playing(AnimControlCollection self, str anim_name)\n"
  "\n"
  "/**\n"
  " * Returns true if the named animation is currently playing, false otherwise.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the last-started animation is currently playing, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_is_playing_184_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string AnimControlCollection::which_anim_playing(void) const
 */
static PyObject *Dtool_AnimControlCollection_which_anim_playing_185(PyObject *self, PyObject *) {
  AnimControlCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControlCollection)) {
    return nullptr;
  }
  // 1-std::string AnimControlCollection::which_anim_playing(void) const
  std::string return_value = ((*(const AnimControlCollection*)local_this).which_anim_playing)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_which_anim_playing_185_comment =
  "C++ Interface:\n"
  "which_anim_playing(AnimControlCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the bound AnimControl currently playing, if any.  If\n"
  " * more than one AnimControl is currently playing, returns all of the names\n"
  " * separated by spaces.\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_which_anim_playing_185_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AnimControlCollection::output(std::ostream &out) const
 */
static PyObject *Dtool_AnimControlCollection_output_186(PyObject *self, PyObject *arg) {
  AnimControlCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControlCollection)) {
    return nullptr;
  }
  // 1-void AnimControlCollection::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AnimControlCollection.output", false, true);
  if (arg_this != nullptr) {
    ((*(const AnimControlCollection*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AnimControlCollection self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_output_186_comment =
  "C++ Interface:\n"
  "output(AnimControlCollection self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_output_186_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AnimControlCollection::write(std::ostream &out) const
 */
static PyObject *Dtool_AnimControlCollection_write_187(PyObject *self, PyObject *arg) {
  AnimControlCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimControlCollection)) {
    return nullptr;
  }
  // 1-void AnimControlCollection::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AnimControlCollection.write", false, true);
  if (arg_this != nullptr) {
    ((*(const AnimControlCollection*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AnimControlCollection self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimControlCollection_write_187_comment =
  "C++ Interface:\n"
  "write(AnimControlCollection self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AnimControlCollection_write_187_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AnimControlCollection::AnimControlCollection(void)
 * inline AnimControlCollection::AnimControlCollection(AnimControlCollection const &) = default
 */
static int Dtool_Init_AnimControlCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("AnimControlCollection() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-AnimControlCollection::AnimControlCollection(void)
      AnimControlCollection *return_value = new AnimControlCollection();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimControlCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline AnimControlCollection::AnimControlCollection(AnimControlCollection const &) = default
      AnimControlCollection const *arg_this = (AnimControlCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AnimControlCollection, 0, "AnimControlCollection.AnimControlCollection", true, true);
      if (arg_this != nullptr) {
        AnimControlCollection *return_value = new AnimControlCollection(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimControlCollection, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AnimControlCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AnimControlCollection()\n"
      "AnimControlCollection(const AnimControlCollection param0)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_AnimControlCollection_get_anims(PyObject *self, PyObject *) {
  AnimControlCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_anims)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_AnimControlCollection_get_anim_169(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_AnimControlCollection_get_anim_names(PyObject *self, PyObject *) {
  AnimControlCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_anims)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_AnimControlCollection_get_anim_name_170(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_AnimControlCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AnimControlCollection) {
    printf("AnimControlCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AnimControlCollection *local_this = (AnimControlCollection *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AnimControlCollection) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AnimControlCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AnimControlCollection) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AnimPreloadTable
 */
/**
 * Python function wrapper for:
 * int AnimPreloadTable::get_num_anims(void) const
 */
static PyObject *Dtool_AnimPreloadTable_get_num_anims_191(PyObject *self, PyObject *) {
  AnimPreloadTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimPreloadTable)) {
    return nullptr;
  }
  // 1-int AnimPreloadTable::get_num_anims(void) const
  int return_value = ((*(const AnimPreloadTable*)local_this).get_num_anims)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_get_num_anims_191_comment =
  "C++ Interface:\n"
  "get_num_anims(AnimPreloadTable self)\n"
  "\n"
  "/**\n"
  " * Returns the number of animation records in the table.\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_get_num_anims_191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int AnimPreloadTable::find_anim(std::string const &basename) const
 */
static PyObject *Dtool_AnimPreloadTable_find_anim_192(PyObject *self, PyObject *arg) {
  AnimPreloadTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimPreloadTable)) {
    return nullptr;
  }
  // 1-int AnimPreloadTable::find_anim(std::string const &basename) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    int return_value = ((*(const AnimPreloadTable*)local_this).find_anim)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_anim(AnimPreloadTable self, str basename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_find_anim_192_comment =
  "C++ Interface:\n"
  "find_anim(AnimPreloadTable self, str basename)\n"
  "\n"
  "/**\n"
  " * Returns the index number in the table of the animation record with the\n"
  " * indicated name, or -1 if the name is not present.  By convention, the\n"
  " * basename is the filename of the egg or bam file, without the directory part\n"
  " * and without the extension.  That is, it is\n"
  " * Filename::get_basename_wo_extension().\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_find_anim_192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string AnimPreloadTable::get_basename(int n) const
 */
static PyObject *Dtool_AnimPreloadTable_get_basename_193(PyObject *self, PyObject *arg) {
  AnimPreloadTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimPreloadTable)) {
    return nullptr;
  }
  // 1-inline std::string AnimPreloadTable::get_basename(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = ((*(const AnimPreloadTable*)local_this).get_basename)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_basename(AnimPreloadTable self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_get_basename_193_comment =
  "C++ Interface:\n"
  "get_basename(AnimPreloadTable self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the basename stored for the nth animation record.  See find_anim().\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_get_basename_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat AnimPreloadTable::get_base_frame_rate(int n) const
 */
static PyObject *Dtool_AnimPreloadTable_get_base_frame_rate_194(PyObject *self, PyObject *arg) {
  AnimPreloadTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimPreloadTable)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat AnimPreloadTable::get_base_frame_rate(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PN_stdfloat return_value = ((*(const AnimPreloadTable*)local_this).get_base_frame_rate)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_base_frame_rate(AnimPreloadTable self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_get_base_frame_rate_194_comment =
  "C++ Interface:\n"
  "get_base_frame_rate(AnimPreloadTable self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the frame rate stored for the nth animation record.\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_get_base_frame_rate_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int AnimPreloadTable::get_num_frames(int n) const
 */
static PyObject *Dtool_AnimPreloadTable_get_num_frames_195(PyObject *self, PyObject *arg) {
  AnimPreloadTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimPreloadTable)) {
    return nullptr;
  }
  // 1-inline int AnimPreloadTable::get_num_frames(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const AnimPreloadTable*)local_this).get_num_frames)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_num_frames(AnimPreloadTable self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_get_num_frames_195_comment =
  "C++ Interface:\n"
  "get_num_frames(AnimPreloadTable self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the number of frames stored for the nth animation record.\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_get_num_frames_195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AnimPreloadTable::clear_anims(void)
 */
static PyObject *Dtool_AnimPreloadTable_clear_anims_196(PyObject *self, PyObject *) {
  AnimPreloadTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimPreloadTable, (void **)&local_this, "AnimPreloadTable.clear_anims")) {
    return nullptr;
  }
  // 1-void AnimPreloadTable::clear_anims(void)
  ((*local_this).clear_anims)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_clear_anims_196_comment =
  "C++ Interface:\n"
  "clear_anims(const AnimPreloadTable self)\n"
  "\n"
  "/**\n"
  " * Removes all animation records from the table.\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_clear_anims_196_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AnimPreloadTable::remove_anim(int n)
 */
static PyObject *Dtool_AnimPreloadTable_remove_anim_197(PyObject *self, PyObject *arg) {
  AnimPreloadTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimPreloadTable, (void **)&local_this, "AnimPreloadTable.remove_anim")) {
    return nullptr;
  }
  // 1-void AnimPreloadTable::remove_anim(int n)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).remove_anim)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_anim(const AnimPreloadTable self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_remove_anim_197_comment =
  "C++ Interface:\n"
  "remove_anim(const AnimPreloadTable self, int n)\n"
  "\n"
  "/**\n"
  " * Removes the nth animation records from the table.  This renumbers indexes\n"
  " * for following animations.\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_remove_anim_197_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AnimPreloadTable::add_anim(std::string const &basename, PN_stdfloat base_frame_rate, int num_frames)
 */
static PyObject *Dtool_AnimPreloadTable_add_anim_198(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimPreloadTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimPreloadTable, (void **)&local_this, "AnimPreloadTable.add_anim")) {
    return nullptr;
  }
  // 1-void AnimPreloadTable::add_anim(std::string const &basename, PN_stdfloat base_frame_rate, int num_frames)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  float param2;
  int param3;
  static const char *keyword_list[] = {"basename", "base_frame_rate", "num_frames", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#fi:add_anim", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
    ((*local_this).add_anim)(std::string(param1_str, param1_len), (PN_stdfloat)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_anim(const AnimPreloadTable self, str basename, float base_frame_rate, int num_frames)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_add_anim_198_comment =
  "C++ Interface:\n"
  "add_anim(const AnimPreloadTable self, str basename, float base_frame_rate, int num_frames)\n"
  "\n"
  "/**\n"
  " * Adds a new animation record to the table.  If there is already a record of\n"
  " * this name, no operation is performed (the original record is unchanged).\n"
  " * See find_anim().  This will invalidate existing index numbers.\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_add_anim_198_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void AnimPreloadTable::add_anims_from(AnimPreloadTable const *other)
 */
static PyObject *Dtool_AnimPreloadTable_add_anims_from_199(PyObject *self, PyObject *arg) {
  AnimPreloadTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimPreloadTable, (void **)&local_this, "AnimPreloadTable.add_anims_from")) {
    return nullptr;
  }
  // 1-void AnimPreloadTable::add_anims_from(AnimPreloadTable const *other)
  AnimPreloadTable const *arg_this = (AnimPreloadTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AnimPreloadTable, 1, "AnimPreloadTable.add_anims_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_anims_from)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_anims_from(const AnimPreloadTable self, const AnimPreloadTable other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_add_anims_from_199_comment =
  "C++ Interface:\n"
  "add_anims_from(const AnimPreloadTable self, const AnimPreloadTable other)\n"
  "\n"
  "/**\n"
  " * Copies the animation records from the other table into this one.  If a\n"
  " * given record name exists in both tables, the record in this one supercedes.\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_add_anims_from_199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimPreloadTable::output(std::ostream &out) const
 */
static PyObject *Dtool_AnimPreloadTable_output_200(PyObject *self, PyObject *arg) {
  AnimPreloadTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimPreloadTable)) {
    return nullptr;
  }
  // 1-virtual void AnimPreloadTable::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AnimPreloadTable.output", false, true);
  if (arg_this != nullptr) {
    ((*(const AnimPreloadTable*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AnimPreloadTable self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_output_200_comment =
  "C++ Interface:\n"
  "output(AnimPreloadTable self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_output_200_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimPreloadTable::write(std::ostream &out, int indent_level) const
 */
static PyObject *Dtool_AnimPreloadTable_write_201(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimPreloadTable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimPreloadTable)) {
    return nullptr;
  }
  // 1-virtual void AnimPreloadTable::write(std::ostream &out, int indent_level) const
  PyObject *param1;
  int param2;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "AnimPreloadTable.write", false, true);
    if (param1_this != nullptr) {
      ((*(const AnimPreloadTable*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(AnimPreloadTable self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_write_201_comment =
  "C++ Interface:\n"
  "write(AnimPreloadTable self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AnimPreloadTable_write_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimPreloadTable::get_class_type(void)
 */
static PyObject *Dtool_AnimPreloadTable_get_class_type_202(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimPreloadTable::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AnimPreloadTable::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimPreloadTable_get_class_type_202_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimPreloadTable_get_class_type_202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AnimPreloadTable::AnimPreloadTable(void)
 */
static int Dtool_Init_AnimPreloadTable(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("AnimPreloadTable() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "AnimPreloadTable() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-AnimPreloadTable::AnimPreloadTable(void)
  AnimPreloadTable *return_value = new AnimPreloadTable();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AnimPreloadTable, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AnimPreloadTable()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AnimPreloadTable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AnimPreloadTable) {
    printf("AnimPreloadTable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AnimPreloadTable *local_this = (AnimPreloadTable *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AnimPreloadTable) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_CopyOnWriteObject) {
    return (CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *)(CopyOnWriteObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AnimPreloadTable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AnimPreloadTable) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (AnimPreloadTable*)other_this;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    CopyOnWriteObject* other_this = (CopyOnWriteObject*)from_this;
    return (AnimPreloadTable*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AnimPreloadTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AnimPreloadTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (AnimPreloadTable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (AnimPreloadTable*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PartSubset
 */
/**
 * Python function wrapper for:
 * void PartSubset::operator =(PartSubset const &copy)
 */
static PyObject *Dtool_PartSubset_operator_206(PyObject *self, PyObject *arg) {
  PartSubset *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartSubset, (void **)&local_this, "PartSubset.assign")) {
    return nullptr;
  }
  // 1-void PartSubset::operator =(PartSubset const &copy)
  PartSubset const *arg_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PartSubset, 1, "PartSubset.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    PartSubset *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PartSubset, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PartSubset self, const PartSubset copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartSubset_operator_206_comment =
  "C++ Interface:\n"
  "assign(const PartSubset self, const PartSubset copy)\n";
#else
static const char *Dtool_PartSubset_operator_206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PartSubset::add_include_joint(GlobPattern const &name)
 */
static PyObject *Dtool_PartSubset_add_include_joint_207(PyObject *self, PyObject *arg) {
  PartSubset *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartSubset, (void **)&local_this, "PartSubset.add_include_joint")) {
    return nullptr;
  }
  // 1-void PartSubset::add_include_joint(GlobPattern const &name)
  GlobPattern arg_local;
  GlobPattern const *arg_this = Dtool_Coerce_GlobPattern(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PartSubset.add_include_joint", "GlobPattern");
  }
  ((*local_this).add_include_joint)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_include_joint(const PartSubset self, const GlobPattern name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartSubset_add_include_joint_207_comment =
  "C++ Interface:\n"
  "add_include_joint(const PartSubset self, const GlobPattern name)\n"
  "\n"
  "/**\n"
  " * Adds the named joint to the list of joints that will be explicitly included\n"
  " * in the subset.  Any joint at or below a named node will be included in the\n"
  " * subset (unless a lower node is also listed in the exclude list).\n"
  " *\n"
  " * Since the name is a GlobPattern, it may of course include filename globbing\n"
  " * characters like * and ?.\n"
  " */";
#else
static const char *Dtool_PartSubset_add_include_joint_207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PartSubset::add_exclude_joint(GlobPattern const &name)
 */
static PyObject *Dtool_PartSubset_add_exclude_joint_208(PyObject *self, PyObject *arg) {
  PartSubset *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartSubset, (void **)&local_this, "PartSubset.add_exclude_joint")) {
    return nullptr;
  }
  // 1-void PartSubset::add_exclude_joint(GlobPattern const &name)
  GlobPattern arg_local;
  GlobPattern const *arg_this = Dtool_Coerce_GlobPattern(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PartSubset.add_exclude_joint", "GlobPattern");
  }
  ((*local_this).add_exclude_joint)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_exclude_joint(const PartSubset self, const GlobPattern name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartSubset_add_exclude_joint_208_comment =
  "C++ Interface:\n"
  "add_exclude_joint(const PartSubset self, const GlobPattern name)\n"
  "\n"
  "/**\n"
  " * Adds the named joint to the list of joints that will be explicitly\n"
  " * exlcluded from the subset.  Any joint at or below a named node will not be\n"
  " * included in the subset (unless a lower node is also listed in the include\n"
  " * list).\n"
  " *\n"
  " * Since the name is a GlobPattern, it may of course include filename globbing\n"
  " * characters like * and ?.\n"
  " */";
#else
static const char *Dtool_PartSubset_add_exclude_joint_208_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PartSubset::append(PartSubset const &other)
 */
static PyObject *Dtool_PartSubset_append_209(PyObject *self, PyObject *arg) {
  PartSubset *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartSubset, (void **)&local_this, "PartSubset.append")) {
    return nullptr;
  }
  // 1-void PartSubset::append(PartSubset const &other)
  PartSubset const *arg_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PartSubset, 1, "PartSubset.append", true, true);
  if (arg_this != nullptr) {
    ((*local_this).append)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "append(const PartSubset self, const PartSubset other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartSubset_append_209_comment =
  "C++ Interface:\n"
  "append(const PartSubset self, const PartSubset other)\n"
  "\n"
  "/**\n"
  " * Appends the include and exclude list from the other object onto this\n"
  " * object's lists.\n"
  " */";
#else
static const char *Dtool_PartSubset_append_209_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PartSubset::output(std::ostream &out) const
 */
static PyObject *Dtool_PartSubset_output_210(PyObject *self, PyObject *arg) {
  PartSubset *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartSubset)) {
    return nullptr;
  }
  // 1-void PartSubset::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PartSubset.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PartSubset*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PartSubset self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartSubset_output_210_comment =
  "C++ Interface:\n"
  "output(PartSubset self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PartSubset_output_210_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PartSubset::is_include_empty(void) const
 */
static PyObject *Dtool_PartSubset_is_include_empty_211(PyObject *self, PyObject *) {
  PartSubset *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartSubset)) {
    return nullptr;
  }
  // 1-bool PartSubset::is_include_empty(void) const
  bool return_value = ((*(const PartSubset*)local_this).is_include_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartSubset_is_include_empty_211_comment =
  "C++ Interface:\n"
  "is_include_empty(PartSubset self)\n"
  "\n"
  "/**\n"
  " * Returns true if the include list is completely empty, false otherwise.  If\n"
  " * it is empty, it is the same thing as including all joints.\n"
  " */";
#else
static const char *Dtool_PartSubset_is_include_empty_211_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PartSubset::matches_include(std::string const &joint_name) const
 */
static PyObject *Dtool_PartSubset_matches_include_212(PyObject *self, PyObject *arg) {
  PartSubset *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartSubset)) {
    return nullptr;
  }
  // 1-bool PartSubset::matches_include(std::string const &joint_name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const PartSubset*)local_this).matches_include)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "matches_include(PartSubset self, str joint_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartSubset_matches_include_212_comment =
  "C++ Interface:\n"
  "matches_include(PartSubset self, str joint_name)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated name matches a name on the include list,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_PartSubset_matches_include_212_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PartSubset::matches_exclude(std::string const &joint_name) const
 */
static PyObject *Dtool_PartSubset_matches_exclude_213(PyObject *self, PyObject *arg) {
  PartSubset *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartSubset)) {
    return nullptr;
  }
  // 1-bool PartSubset::matches_exclude(std::string const &joint_name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const PartSubset*)local_this).matches_exclude)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "matches_exclude(PartSubset self, str joint_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartSubset_matches_exclude_213_comment =
  "C++ Interface:\n"
  "matches_exclude(PartSubset self, str joint_name)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated name matches a name on the exclude list,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_PartSubset_matches_exclude_213_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PartSubset::PartSubset(void)
 * PartSubset::PartSubset(PartSubset const &copy)
 */
static int Dtool_Init_PartSubset(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PartSubset::PartSubset(void)
      PartSubset *return_value = new PartSubset();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PartSubset, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-PartSubset::PartSubset(PartSubset const &copy)
        PartSubset const *arg_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PartSubset, 0, "PartSubset.PartSubset", true, true);
        if (arg_this != nullptr) {
          PartSubset *return_value = new PartSubset(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PartSubset, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PartSubset() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PartSubset()\n"
      "PartSubset(const PartSubset copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PartSubset(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PartSubset) {
    printf("PartSubset ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PartSubset *local_this = (PartSubset *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PartSubset) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PartSubset(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PartSubset) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BindAnimRequest
 */
/**
 * Python function wrapper for:
 * static TypeHandle BindAnimRequest::get_class_type(void)
 */
static PyObject *Dtool_BindAnimRequest_get_class_type_218(PyObject *, PyObject *) {
  // 1-static TypeHandle BindAnimRequest::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BindAnimRequest::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BindAnimRequest_get_class_type_218_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BindAnimRequest_get_class_type_218_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BindAnimRequest::BindAnimRequest(BindAnimRequest const &) = default
 * explicit BindAnimRequest::BindAnimRequest(std::string const &name, Filename const &filename, LoaderOptions const &options, Loader *loader, AnimControl *control, int hierarchy_match_flags, PartSubset const &subset)
 */
static int Dtool_Init_BindAnimRequest(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline BindAnimRequest::BindAnimRequest(BindAnimRequest const &) = default
      BindAnimRequest const *arg_this = (BindAnimRequest *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BindAnimRequest, 0, "BindAnimRequest.BindAnimRequest", true, true);
      if (arg_this != nullptr) {
        BindAnimRequest *return_value = new BindAnimRequest(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BindAnimRequest, true, false);
      }
    }
    break;
  case 7:
    {
      // 1-explicit BindAnimRequest::BindAnimRequest(std::string const &name, Filename const &filename, LoaderOptions const &options, Loader *loader, AnimControl *control, int hierarchy_match_flags, PartSubset const &subset)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      int param5;
      PyObject *param6;
      static const char *keyword_list[] = {"name", "filename", "options", "loader", "control", "hierarchy_match_flags", "subset", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#OOOOiO:BindAnimRequest", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5, &param6)) {
        Filename param1_local;
        Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
        if (!(param1_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param1, 1, "BindAnimRequest.BindAnimRequest", "Filename");
          return -1;
        }
        LoaderOptions param2_local;
        LoaderOptions const *param2_this = Dtool_Coerce_LoaderOptions(param2, param2_local);
        if (!(param2_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param2, 2, "BindAnimRequest.BindAnimRequest", "LoaderOptions");
          return -1;
        }
        Loader *param3_this = (Loader *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_Loader, 3, "BindAnimRequest.BindAnimRequest", false, true);
        AnimControl *param4_this = (AnimControl *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_AnimControl, 4, "BindAnimRequest.BindAnimRequest", false, true);
        PartSubset const *param6_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(param6, Dtool_Ptr_PartSubset, 6, "BindAnimRequest.BindAnimRequest", true, true);
        if (param3_this != nullptr && param4_this != nullptr && param6_this != nullptr) {
          BindAnimRequest *return_value = new BindAnimRequest(std::string(param0_str, param0_len), *param1_this, *param2_this, param3_this, param4_this, (int)param5, *param6_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BindAnimRequest, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BindAnimRequest() takes 1 or 7 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BindAnimRequest(const BindAnimRequest param0)\n"
      "BindAnimRequest(str name, const Filename filename, const LoaderOptions options, Loader loader, AnimControl control, int hierarchy_match_flags, const PartSubset subset)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BindAnimRequest(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BindAnimRequest) {
    printf("BindAnimRequest ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BindAnimRequest *local_this = (BindAnimRequest *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BindAnimRequest) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncFuture) {
    return (AsyncFuture *)(AsyncTask *)(ModelLoadRequest *) local_this;
  }
  if (requested_type == Dtool_Ptr_AsyncTask) {
    return (AsyncTask *)(ModelLoadRequest *) local_this;
  }
  if (requested_type == Dtool_Ptr_ModelLoadRequest) {
    return (ModelLoadRequest *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(AsyncTask *)(ModelLoadRequest *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *)(ModelLoadRequest *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(AsyncFuture *)(AsyncTask *)(ModelLoadRequest *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(AsyncFuture *)(AsyncTask *)(ModelLoadRequest *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BindAnimRequest(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BindAnimRequest) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AsyncFuture) {
    AsyncFuture* other_this = (AsyncFuture*)from_this;
    return (BindAnimRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_AsyncTask) {
    AsyncTask* other_this = (AsyncTask*)from_this;
    return (BindAnimRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_ModelLoadRequest) {
    ModelLoadRequest* other_this = (ModelLoadRequest*)from_this;
    return (BindAnimRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (BindAnimRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BindAnimRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BindAnimRequest*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BindAnimRequest*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PartBundle
 */
/**
 * Python function wrapper for:
 * inline ConstPointerTo< AnimPreloadTable > PartBundle::get_anim_preload(void) const
 */
static PyObject *Dtool_PartBundle_get_anim_preload_222(PyObject *self, PyObject *) {
  PartBundle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartBundle)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< AnimPreloadTable > PartBundle::get_anim_preload(void) const
  ConstPointerTo< AnimPreloadTable > return_value = ((*(const PartBundle*)local_this).get_anim_preload)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  AnimPreloadTable const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AnimPreloadTable, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_anim_preload_222_comment =
  "C++ Interface:\n"
  "get_anim_preload(PartBundle self)\n"
  "\n"
  "/**\n"
  " * Returns the AnimPreloadTable associated with the PartBundle.  This table,\n"
  " * if present, can be used for the benefit of load_bind_anim() to allow\n"
  " * asynchronous binding.\n"
  " */";
#else
static const char *Dtool_PartBundle_get_anim_preload_222_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< AnimPreloadTable > PartBundle::modify_anim_preload(void)
 */
static PyObject *Dtool_PartBundle_modify_anim_preload_223(PyObject *self, PyObject *) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.modify_anim_preload")) {
    return nullptr;
  }
  // 1-inline PointerTo< AnimPreloadTable > PartBundle::modify_anim_preload(void)
  PointerTo< AnimPreloadTable > return_value = ((*local_this).modify_anim_preload)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  AnimPreloadTable *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AnimPreloadTable, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_modify_anim_preload_223_comment =
  "C++ Interface:\n"
  "modify_anim_preload(const PartBundle self)\n"
  "\n"
  "/**\n"
  " * Returns a modifiable pointer to the AnimPreloadTable associated with the\n"
  " * PartBundle, if any.\n"
  " */";
#else
static const char *Dtool_PartBundle_modify_anim_preload_223_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PartBundle::set_anim_preload(AnimPreloadTable *table)
 */
static PyObject *Dtool_PartBundle_set_anim_preload_224(PyObject *self, PyObject *arg) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.set_anim_preload")) {
    return nullptr;
  }
  // 1-inline void PartBundle::set_anim_preload(AnimPreloadTable *table)
  AnimPreloadTable *arg_this = (AnimPreloadTable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AnimPreloadTable, 1, "PartBundle.set_anim_preload", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_anim_preload)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anim_preload(const PartBundle self, AnimPreloadTable table)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_set_anim_preload_224_comment =
  "C++ Interface:\n"
  "set_anim_preload(const PartBundle self, AnimPreloadTable table)\n"
  "\n"
  "/**\n"
  " * Replaces the AnimPreloadTable associated with the PartBundle.\n"
  " */";
#else
static const char *Dtool_PartBundle_set_anim_preload_224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PartBundle::clear_anim_preload(void)
 */
static PyObject *Dtool_PartBundle_clear_anim_preload_225(PyObject *self, PyObject *) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.clear_anim_preload")) {
    return nullptr;
  }
  // 1-inline void PartBundle::clear_anim_preload(void)
  ((*local_this).clear_anim_preload)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_clear_anim_preload_225_comment =
  "C++ Interface:\n"
  "clear_anim_preload(const PartBundle self)\n"
  "\n"
  "/**\n"
  " * Removes any AnimPreloadTable associated with the PartBundle.\n"
  " */";
#else
static const char *Dtool_PartBundle_clear_anim_preload_225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PartBundle::merge_anim_preloads(PartBundle const *other)
 */
static PyObject *Dtool_PartBundle_merge_anim_preloads_226(PyObject *self, PyObject *arg) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.merge_anim_preloads")) {
    return nullptr;
  }
  // 1-void PartBundle::merge_anim_preloads(PartBundle const *other)
  PartBundle const *arg_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PartBundle, 1, "PartBundle.merge_anim_preloads", true, true);
  if (arg_this != nullptr) {
    ((*local_this).merge_anim_preloads)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "merge_anim_preloads(const PartBundle self, const PartBundle other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_merge_anim_preloads_226_comment =
  "C++ Interface:\n"
  "merge_anim_preloads(const PartBundle self, const PartBundle other)\n"
  "\n"
  "/**\n"
  " * Copies the contents of the other PartBundle's preload table into this one.\n"
  " */";
#else
static const char *Dtool_PartBundle_merge_anim_preloads_226_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PartBundle::set_blend_type(PartBundle::BlendType bt)
 */
static PyObject *Dtool_PartBundle_set_blend_type_228(PyObject *self, PyObject *arg) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.set_blend_type")) {
    return nullptr;
  }
  // 1-inline void PartBundle::set_blend_type(PartBundle::BlendType bt)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_blend_type)((PartBundle::BlendType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blend_type(const PartBundle self, int bt)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_set_blend_type_228_comment =
  "C++ Interface:\n"
  "set_blend_type(const PartBundle self, int bt)\n"
  "\n"
  "/**\n"
  " * Defines the algorithm that is used when blending multiple frames or\n"
  " * multiple animations together, when either anim_blend_flag or\n"
  " * frame_blend_flag is set to true.\n"
  " *\n"
  " * See partBundle.h for a description of the meaning of each of the BlendType\n"
  " * values.\n"
  " */";
#else
static const char *Dtool_PartBundle_set_blend_type_228_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PartBundle::BlendType PartBundle::get_blend_type(void) const
 */
static PyObject *Dtool_PartBundle_get_blend_type_229(PyObject *self, PyObject *) {
  PartBundle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartBundle)) {
    return nullptr;
  }
  // 1-inline PartBundle::BlendType PartBundle::get_blend_type(void) const
  PartBundle::BlendType return_value = ((*(const PartBundle*)local_this).get_blend_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_blend_type_229_comment =
  "C++ Interface:\n"
  "get_blend_type(PartBundle self)\n"
  "\n"
  "/**\n"
  " * Returns the algorithm that is used when blending multiple frames or\n"
  " * multiple animations together, when either anim_blend_flag or\n"
  " * frame_blend_flag is set to true.\n"
  " */";
#else
static const char *Dtool_PartBundle_get_blend_type_229_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PartBundle::set_anim_blend_flag(bool anim_blend_flag)
 */
static PyObject *Dtool_PartBundle_set_anim_blend_flag_230(PyObject *self, PyObject *arg) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.set_anim_blend_flag")) {
    return nullptr;
  }
  // 1-void PartBundle::set_anim_blend_flag(bool anim_blend_flag)
  ((*local_this).set_anim_blend_flag)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_anim_blend_flag(const PartBundle self, bool anim_blend_flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_set_anim_blend_flag_230_comment =
  "C++ Interface:\n"
  "set_anim_blend_flag(const PartBundle self, bool anim_blend_flag)\n"
  "\n"
  "/**\n"
  " * Defines the way the character responds to multiple calls to\n"
  " * set_control_effect()).  By default, this flag is set false, which disallows\n"
  " * multiple animations.  When this flag is false, it is not necessary to\n"
  " * explicitly set the control_effect when starting an animation; starting the\n"
  " * animation will implicitly remove the control_effect from the previous\n"
  " * animation and set it on the current one.\n"
  " *\n"
  " * However, if this flag is set true, the control_effect must be explicitly\n"
  " * set via set_control_effect() whenever an animation is to affect the\n"
  " * character.\n"
  " */";
#else
static const char *Dtool_PartBundle_set_anim_blend_flag_230_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PartBundle::get_anim_blend_flag(void) const
 */
static PyObject *Dtool_PartBundle_get_anim_blend_flag_231(PyObject *self, PyObject *) {
  PartBundle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartBundle)) {
    return nullptr;
  }
  // 1-inline bool PartBundle::get_anim_blend_flag(void) const
  bool return_value = ((*(const PartBundle*)local_this).get_anim_blend_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_anim_blend_flag_231_comment =
  "C++ Interface:\n"
  "get_anim_blend_flag(PartBundle self)\n"
  "\n"
  "/**\n"
  " * Returns whether the character allows multiple different animations to be\n"
  " * bound simultaneously.  See set_anim_blend_flag().\n"
  " */";
#else
static const char *Dtool_PartBundle_get_anim_blend_flag_231_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PartBundle::set_frame_blend_flag(bool frame_blend_flag)
 */
static PyObject *Dtool_PartBundle_set_frame_blend_flag_232(PyObject *self, PyObject *arg) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.set_frame_blend_flag")) {
    return nullptr;
  }
  // 1-inline void PartBundle::set_frame_blend_flag(bool frame_blend_flag)
  ((*local_this).set_frame_blend_flag)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_blend_flag(const PartBundle self, bool frame_blend_flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_set_frame_blend_flag_232_comment =
  "C++ Interface:\n"
  "set_frame_blend_flag(const PartBundle self, bool frame_blend_flag)\n"
  "\n"
  "/**\n"
  " * Specifies whether the character interpolates (blends) between two\n"
  " * sequential frames of an active animation, showing a smooth intra-frame\n"
  " * motion, or whether it holds each frame until the next frame is ready,\n"
  " * showing precisely the specified animation.\n"
  " *\n"
  " * When this value is false, the character holds each frame until the next is\n"
  " * ready.  When this is true, the character will interpolate between two\n"
  " * consecutive frames of animation for each frame the animation is onscreen,\n"
  " * according to the amount of time elapsed between the frames.\n"
  " *\n"
  " * The default value of this flag is determined by the interpolate-frames\n"
  " * Config.prc variable.\n"
  " *\n"
  " * Use set_blend_type() to change the algorithm that the character uses to\n"
  " * interpolate matrix positions.\n"
  " */";
#else
static const char *Dtool_PartBundle_set_frame_blend_flag_232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PartBundle::get_frame_blend_flag(void) const
 */
static PyObject *Dtool_PartBundle_get_frame_blend_flag_233(PyObject *self, PyObject *) {
  PartBundle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartBundle)) {
    return nullptr;
  }
  // 1-inline bool PartBundle::get_frame_blend_flag(void) const
  bool return_value = ((*(const PartBundle*)local_this).get_frame_blend_flag)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_frame_blend_flag_233_comment =
  "C++ Interface:\n"
  "get_frame_blend_flag(PartBundle self)\n"
  "\n"
  "/**\n"
  " * Returns whether the character interpolates (blends) between two sequential\n"
  " * animation frames, or whether it holds the current frame until the next one\n"
  " * is ready.  See set_frame_blend_flag().\n"
  " */";
#else
static const char *Dtool_PartBundle_get_frame_blend_flag_233_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PartBundle::set_root_xform(LMatrix4 const &root_xform)
 */
static PyObject *Dtool_PartBundle_set_root_xform_234(PyObject *self, PyObject *arg) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.set_root_xform")) {
    return nullptr;
  }
  // 1-inline void PartBundle::set_root_xform(LMatrix4 const &root_xform)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PartBundle.set_root_xform", "LMatrix4f");
  }
  ((*local_this).set_root_xform)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_root_xform(const PartBundle self, const LMatrix4f root_xform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_set_root_xform_234_comment =
  "C++ Interface:\n"
  "set_root_xform(const PartBundle self, const LMatrix4f root_xform)\n"
  "\n"
  "/**\n"
  " * Specifies the transform matrix which is implicitly applied at the root of\n"
  " * the animated hierarchy.\n"
  " */";
#else
static const char *Dtool_PartBundle_set_root_xform_234_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PartBundle::xform(LMatrix4 const &mat)
 */
static PyObject *Dtool_PartBundle_xform_235(PyObject *self, PyObject *arg) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.xform")) {
    return nullptr;
  }
  // 1-inline void PartBundle::xform(LMatrix4 const &mat)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PartBundle.xform", "LMatrix4f");
  }
  ((*local_this).xform)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "xform(const PartBundle self, const LMatrix4f mat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_xform_235_comment =
  "C++ Interface:\n"
  "xform(const PartBundle self, const LMatrix4f mat)\n"
  "\n"
  "/**\n"
  " * Applies the indicated transform to the root of the animated hierarchy.\n"
  " */";
#else
static const char *Dtool_PartBundle_xform_235_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 const &PartBundle::get_root_xform(void) const
 */
static PyObject *Dtool_PartBundle_get_root_xform_236(PyObject *self, PyObject *) {
  PartBundle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartBundle)) {
    return nullptr;
  }
  // 1-inline LMatrix4 const &PartBundle::get_root_xform(void) const
  LMatrix4 const *return_value = &(((*(const PartBundle*)local_this).get_root_xform)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_root_xform_236_comment =
  "C++ Interface:\n"
  "get_root_xform(PartBundle self)\n"
  "\n"
  "/**\n"
  " * Returns the transform matrix which is implicitly applied at the root of the\n"
  " * animated hierarchy.\n"
  " */";
#else
static const char *Dtool_PartBundle_get_root_xform_236_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PartBundle > PartBundle::apply_transform(TransformState const *transform)
 */
static PyObject *Dtool_PartBundle_apply_transform_237(PyObject *self, PyObject *arg) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.apply_transform")) {
    return nullptr;
  }
  // 1-PointerTo< PartBundle > PartBundle::apply_transform(TransformState const *transform)
  TransformState const *arg_this = (TransformState *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TransformState, 1, "PartBundle.apply_transform", true, true);
  if (arg_this != nullptr) {
    PointerTo< PartBundle > return_value = ((*local_this).apply_transform)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    PartBundle *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PartBundle, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "apply_transform(const PartBundle self, const TransformState transform)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_apply_transform_237_comment =
  "C++ Interface:\n"
  "apply_transform(const PartBundle self, const TransformState transform)\n"
  "\n"
  "/**\n"
  " * Returns a PartBundle that is a duplicate of this one, but with the\n"
  " * indicated transform applied.  If this is called multiple times with the\n"
  " * same TransformState pointer, it returns the same PartBundle each time.\n"
  " */";
#else
static const char *Dtool_PartBundle_apply_transform_237_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PartBundle::get_num_nodes(void) const
 */
static PyObject *Dtool_PartBundle_get_num_nodes_238(PyObject *self, PyObject *) {
  PartBundle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartBundle)) {
    return nullptr;
  }
  // 1-inline int PartBundle::get_num_nodes(void) const
  int return_value = ((*(const PartBundle*)local_this).get_num_nodes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_num_nodes_238_comment =
  "C++ Interface:\n"
  "get_num_nodes(PartBundle self)\n"
  "\n"
  "/**\n"
  " * Returns the number of PartBundleNodes that contain a pointer to this\n"
  " * PartBundle.\n"
  " */";
#else
static const char *Dtool_PartBundle_get_num_nodes_238_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PartBundleNode *PartBundle::get_node(int n) const
 */
static PyObject *Dtool_PartBundle_get_node_239(PyObject *self, PyObject *arg) {
  PartBundle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartBundle)) {
    return nullptr;
  }
  // 1-inline PartBundleNode *PartBundle::get_node(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PartBundleNode *return_value = ((*(const PartBundle*)local_this).get_node)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartBundleNode, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_node(PartBundle self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_node_239_comment =
  "C++ Interface:\n"
  "get_node(PartBundle self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth PartBundleNode associated with this PartBundle.\n"
  " */";
#else
static const char *Dtool_PartBundle_get_node_239_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PartBundle::clear_control_effects(void)
 */
static PyObject *Dtool_PartBundle_clear_control_effects_267(PyObject *self, PyObject *) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.clear_control_effects")) {
    return nullptr;
  }
  // 1-void PartBundle::clear_control_effects(void)
  ((*local_this).clear_control_effects)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_clear_control_effects_267_comment =
  "C++ Interface:\n"
  "clear_control_effects(const PartBundle self)\n"
  "\n"
  "/**\n"
  " * Sets the control effect of all AnimControls to zero (but does not \"stop\"\n"
  " * the AnimControls).  The character will no longer be affected by any\n"
  " * animation, and will return to its default pose (unless restore-initial-pose\n"
  " * is false).\n"
  " *\n"
  " * The AnimControls which are no longer associated will not be using any CPU\n"
  " * cycles, but they may still be in the \"playing\" state; if they are later\n"
  " * reassociated with the PartBundle they will resume at their current frame as\n"
  " * if they'd been running all along.\n"
  " */";
#else
static const char *Dtool_PartBundle_clear_control_effects_267_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PartBundle::set_control_effect(AnimControl *control, PN_stdfloat effect)
 */
static PyObject *Dtool_PartBundle_set_control_effect_268(PyObject *self, PyObject *args, PyObject *kwds) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.set_control_effect")) {
    return nullptr;
  }
  // 1-inline void PartBundle::set_control_effect(AnimControl *control, PN_stdfloat effect)
  PyObject *param1;
  float param2;
  static const char *keyword_list[] = {"control", "effect", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:set_control_effect", (char **)keyword_list, &param1, &param2)) {
    AnimControl *param1_this = (AnimControl *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_AnimControl, 1, "PartBundle.set_control_effect", false, true);
    if (param1_this != nullptr) {
      ((*local_this).set_control_effect)(param1_this, (PN_stdfloat)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_control_effect(const PartBundle self, AnimControl control, float effect)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_set_control_effect_268_comment =
  "C++ Interface:\n"
  "set_control_effect(const PartBundle self, AnimControl control, float effect)\n"
  "\n"
  "/**\n"
  " * Sets the amount by which the character is affected by the indicated\n"
  " * AnimControl (and its associated animation).  Normally, this will only be\n"
  " * zero or one.  Zero indicates the animation does not affect the character,\n"
  " * and one means it does.\n"
  " *\n"
  " * If the _anim_blend_flag is not false (see set_anim_blend_flag()), it is\n"
  " * possible to have multiple AnimControls in effect simultaneously.  In this\n"
  " * case, the effect is a weight that indicates the relative importance of each\n"
  " * AnimControl to the final animation.\n"
  " */";
#else
static const char *Dtool_PartBundle_set_control_effect_268_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PartBundle::get_control_effect(AnimControl *control) const
 */
static PyObject *Dtool_PartBundle_get_control_effect_269(PyObject *self, PyObject *arg) {
  PartBundle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartBundle)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PartBundle::get_control_effect(AnimControl *control) const
  AnimControl *arg_this = (AnimControl *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AnimControl, 1, "PartBundle.get_control_effect", false, true);
  if (arg_this != nullptr) {
    PN_stdfloat return_value = ((*(const PartBundle*)local_this).get_control_effect)(arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_control_effect(PartBundle self, AnimControl control)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_control_effect_269_comment =
  "C++ Interface:\n"
  "get_control_effect(PartBundle self, AnimControl control)\n"
  "\n"
  "/**\n"
  " * Returns the amount by which the character is affected by the indicated\n"
  " * AnimControl and its associated animation.  See set_control_effect().\n"
  " */";
#else
static const char *Dtool_PartBundle_get_control_effect_269_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PartBundle::output(std::ostream &out) const
 */
static PyObject *Dtool_PartBundle_output_270(PyObject *self, PyObject *arg) {
  PartBundle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartBundle)) {
    return nullptr;
  }
  // 1-virtual void PartBundle::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PartBundle.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PartBundle*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PartBundle self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_output_270_comment =
  "C++ Interface:\n"
  "output(PartBundle self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a one-line description of the bundle.\n"
  " */";
#else
static const char *Dtool_PartBundle_output_270_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< AnimControl > PartBundle::bind_anim(AnimBundle *anim, int hierarchy_match_flags = 0, PartSubset const &subset = PartSubset())
 */
static PyObject *Dtool_PartBundle_bind_anim_271(PyObject *self, PyObject *args, PyObject *kwds) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.bind_anim")) {
    return nullptr;
  }
  // 1-PointerTo< AnimControl > PartBundle::bind_anim(AnimBundle *anim, int hierarchy_match_flags = 0, PartSubset const &subset = PartSubset())
  PyObject *param1;
  int param2 = 0;
  PyObject *param3 = nullptr;
  static const char *keyword_list[] = {"anim", "hierarchy_match_flags", "subset", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|iO:bind_anim", (char **)keyword_list, &param1, &param2, &param3)) {
    AnimBundle *param1_this = (AnimBundle *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_AnimBundle, 1, "PartBundle.bind_anim", false, true);
    PartSubset const *param3_this;
    const PartSubset &param3_ref = PartSubset();
    if (param3 == nullptr) {
      param3_this = &param3_ref;
    } else {
      param3_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(param3, Dtool_Ptr_PartSubset, 3, "PartBundle.bind_anim", true, true);
    }
    if (param1_this != nullptr && (param3 == nullptr || param3_this != nullptr)) {
      PointerTo< AnimControl > return_value = ((*local_this).bind_anim)(param1_this, (int)param2, *param3_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      AnimControl *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AnimControl, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bind_anim(const PartBundle self, AnimBundle anim, int hierarchy_match_flags, const PartSubset subset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_bind_anim_271_comment =
  "C++ Interface:\n"
  "bind_anim(const PartBundle self, AnimBundle anim, int hierarchy_match_flags, const PartSubset subset)\n"
  "\n"
  "/**\n"
  " * Binds the animation to the bundle, if possible, and returns a new\n"
  " * AnimControl that can be used to start and stop the animation.  If the anim\n"
  " * hierarchy does not match the part hierarchy, returns NULL.\n"
  " *\n"
  " * If hierarchy_match_flags is 0, only an exact match is accepted; otherwise,\n"
  " * it may contain a union of PartGroup::HierarchyMatchFlags values indicating\n"
  " * conditions that will be tolerated (but warnings will still be issued).\n"
  " *\n"
  " * If subset is specified, it restricts the binding only to the named subtree\n"
  " * of joints.\n"
  " *\n"
  " * The AnimControl is not stored within the PartBundle; it is the user's\n"
  " * responsibility to maintain the pointer.  The animation will automatically\n"
  " * unbind itself when the AnimControl destructs (i.e.  its reference count\n"
  " * goes to zero).\n"
  " */";
#else
static const char *Dtool_PartBundle_bind_anim_271_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< AnimControl > PartBundle::load_bind_anim(Loader *loader, Filename const &filename, int hierarchy_match_flags, PartSubset const &subset, bool allow_async)
 */
static PyObject *Dtool_PartBundle_load_bind_anim_272(PyObject *self, PyObject *args, PyObject *kwds) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.load_bind_anim")) {
    return nullptr;
  }
  // 1-PointerTo< AnimControl > PartBundle::load_bind_anim(Loader *loader, Filename const &filename, int hierarchy_match_flags, PartSubset const &subset, bool allow_async)
  PyObject *param1;
  PyObject *param2;
  int param3;
  PyObject *param4;
  PyObject *param5;
  static const char *keyword_list[] = {"loader", "filename", "hierarchy_match_flags", "subset", "allow_async", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOiOO:load_bind_anim", (char **)keyword_list, &param1, &param2, &param3, &param4, &param5)) {
    Loader *param1_this = (Loader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Loader, 1, "PartBundle.load_bind_anim", false, true);
    Filename param2_local;
    Filename const *param2_this = Dtool_Coerce_Filename(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PartBundle.load_bind_anim", "Filename");
    }
    PartSubset const *param4_this = (PartSubset *)DTOOL_Call_GetPointerThisClass(param4, Dtool_Ptr_PartSubset, 4, "PartBundle.load_bind_anim", true, true);
    if (param1_this != nullptr && param4_this != nullptr) {
      PointerTo< AnimControl > return_value = ((*local_this).load_bind_anim)(param1_this, *param2_this, (int)param3, *param4_this, (PyObject_IsTrue(param5) != 0));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      AnimControl *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AnimControl, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_bind_anim(const PartBundle self, Loader loader, const Filename filename, int hierarchy_match_flags, const PartSubset subset, bool allow_async)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_load_bind_anim_272_comment =
  "C++ Interface:\n"
  "load_bind_anim(const PartBundle self, Loader loader, const Filename filename, int hierarchy_match_flags, const PartSubset subset, bool allow_async)\n"
  "\n"
  "/**\n"
  " * Binds an animation to the bundle.  The animation is loaded from the disk\n"
  " * via the indicated Loader object.  In other respects, this behaves similarly\n"
  " * to bind_anim(), with the addition of asynchronous support.\n"
  " *\n"
  " * If allow_aysnc is true, the load will be asynchronous if possible.  This\n"
  " * requires that the animation basename can be found in the PartBundle's\n"
  " * preload table (see get_anim_preload()).\n"
  " *\n"
  " * In an asynchronous load, the animation file will be loaded and bound in a\n"
  " * sub-thread.  This means that the animation will not necessarily be\n"
  " * available at the time this method returns.  You may still use the returned\n"
  " * AnimControl immediately, though, but no visible effect will occur until the\n"
  " * animation eventually becomes available.\n"
  " *\n"
  " * You can test AnimControl::is_pending() to see if the animation has been\n"
  " * loaded yet, or wait for it to finish with AnimControl::wait_pending() or\n"
  " * even PartBundle::wait_pending().  You can also set an event to be triggered\n"
  " * when the animation finishes loading with\n"
  " * AnimControl::set_pending_done_event().\n"
  " */";
#else
static const char *Dtool_PartBundle_load_bind_anim_272_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PartBundle::wait_pending(void)
 */
static PyObject *Dtool_PartBundle_wait_pending_273(PyObject *self, PyObject *) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.wait_pending")) {
    return nullptr;
  }
  // 1-void PartBundle::wait_pending(void)
  ((*local_this).wait_pending)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_wait_pending_273_comment =
  "C++ Interface:\n"
  "wait_pending(const PartBundle self)\n"
  "\n"
  "/**\n"
  " * Blocks the current thread until all currently-pending AnimControls, with a\n"
  " * nonzero control effect, have been loaded and are properly bound.\n"
  " */";
#else
static const char *Dtool_PartBundle_wait_pending_273_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PartBundle::freeze_joint(std::string const &joint_name, LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale)
 * bool PartBundle::freeze_joint(std::string const &joint_name, PN_stdfloat value)
 * bool PartBundle::freeze_joint(std::string const &joint_name, TransformState const *transform)
 */
static PyObject *Dtool_PartBundle_freeze_joint_274(PyObject *self, PyObject *args, PyObject *kwds) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.freeze_joint")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      {
        // -2 bool PartBundle::freeze_joint(std::string const &joint_name, TransformState const *transform)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        PyObject *param2;
        static const char *keyword_list[] = {"joint_name", "transform", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:freeze_joint", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
          TransformState const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_TransformState);
          if (param2_this != nullptr) {
            bool return_value = ((*local_this).freeze_joint)(std::string(param1_str, param1_len), param2_this);
            return Dtool_Return_Bool(return_value);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 bool PartBundle::freeze_joint(std::string const &joint_name, PN_stdfloat value)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        float param2;
        static const char *keyword_list[] = {"joint_name", "value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#f:freeze_joint", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
          bool return_value = ((*local_this).freeze_joint)(std::string(param1_str, param1_len), (PN_stdfloat)param2);
          return Dtool_Return_Bool(return_value);
        }
        PyErr_Clear();
      }

      // No coercion possible: bool PartBundle::freeze_joint(std::string const &joint_name, TransformState const *transform)
      // No coercion possible: bool PartBundle::freeze_joint(std::string const &joint_name, PN_stdfloat value)
    }
    break;
  case 4:
    {
      // 1-bool PartBundle::freeze_joint(std::string const &joint_name, LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale)
      const char *param1_str = nullptr;
      Py_ssize_t param1_len;
      PyObject *param2;
      PyObject *param3;
      PyObject *param4;
      static const char *keyword_list[] = {"joint_name", "pos", "hpr", "scale", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#OOO:freeze_joint", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3, &param4)) {
        LVecBase3f param2_local;
        LVecBase3 const *param2_this = Dtool_Coerce_LVecBase3f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "PartBundle.freeze_joint", "LVecBase3f");
        }
        LVecBase3f param3_local;
        LVecBase3 const *param3_this = Dtool_Coerce_LVecBase3f(param3, param3_local);
        if (!(param3_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param3, 3, "PartBundle.freeze_joint", "LVecBase3f");
        }
        LVecBase3f param4_local;
        LVecBase3 const *param4_this = Dtool_Coerce_LVecBase3f(param4, param4_local);
        if (!(param4_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param4, 4, "PartBundle.freeze_joint", "LVecBase3f");
        }
        bool return_value = ((*local_this).freeze_joint)(std::string(param1_str, param1_len), *param2_this, *param3_this, *param4_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "freeze_joint() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "freeze_joint(const PartBundle self, str joint_name, const TransformState transform)\n"
      "freeze_joint(const PartBundle self, str joint_name, float value)\n"
      "freeze_joint(const PartBundle self, str joint_name, const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_freeze_joint_274_comment =
  "C++ Interface:\n"
  "freeze_joint(const PartBundle self, str joint_name, const TransformState transform)\n"
  "freeze_joint(const PartBundle self, str joint_name, float value)\n"
  "freeze_joint(const PartBundle self, str joint_name, const LVecBase3f pos, const LVecBase3f hpr, const LVecBase3f scale)\n"
  "\n"
  "/**\n"
  " * Specifies that the joint with the indicated name should be frozen with the\n"
  " * specified transform.  It will henceforth always hold this fixed transform,\n"
  " * regardless of any animations that may subsequently be bound to the joint.\n"
  " *\n"
  " * Returns true if the joint is successfully frozen, or false if the named\n"
  " * child is not a joint (or slider) or does not exist.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies that the joint with the indicated name should be frozen with the\n"
  " * specified transform.  It will henceforth always hold this fixed transform,\n"
  " * regardless of any animations that may subsequently be bound to the joint.\n"
  " *\n"
  " * Returns true if the joint is successfully frozen, or false if the named\n"
  " * child is not a joint (or slider) or does not exist.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Specifies that the joint with the indicated name should be frozen with the\n"
  " * specified transform.  It will henceforth always hold this fixed transform,\n"
  " * regardless of any animations that may subsequently be bound to the joint.\n"
  " *\n"
  " * Returns true if the joint is successfully frozen, or false if the named\n"
  " * child is not a joint (or slider) or does not exist.\n"
  " */";
#else
static const char *Dtool_PartBundle_freeze_joint_274_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PartBundle::control_joint(std::string const &joint_name, PandaNode *node)
 */
static PyObject *Dtool_PartBundle_control_joint_275(PyObject *self, PyObject *args, PyObject *kwds) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.control_joint")) {
    return nullptr;
  }
  // 1-bool PartBundle::control_joint(std::string const &joint_name, PandaNode *node)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"joint_name", "node", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:control_joint", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    PandaNode *param2_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_PandaNode, 2, "PartBundle.control_joint", false, true);
    if (param2_this != nullptr) {
      bool return_value = ((*local_this).control_joint)(std::string(param1_str, param1_len), param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "control_joint(const PartBundle self, str joint_name, PandaNode node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_control_joint_275_comment =
  "C++ Interface:\n"
  "control_joint(const PartBundle self, str joint_name, PandaNode node)\n"
  "\n"
  "/**\n"
  " * Specifies that the joint with the indicated name should be animated with\n"
  " * the transform on the indicated node.  It will henceforth always follow the\n"
  " * node's transform, regardless of any animations that may subsequently be\n"
  " * bound to the joint.\n"
  " *\n"
  " * Returns true if the joint is successfully controlled, or false if the named\n"
  " * child is not a joint (or slider) or does not exist.\n"
  " */";
#else
static const char *Dtool_PartBundle_control_joint_275_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PartBundle::release_joint(std::string const &joint_name)
 */
static PyObject *Dtool_PartBundle_release_joint_276(PyObject *self, PyObject *arg) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.release_joint")) {
    return nullptr;
  }
  // 1-bool PartBundle::release_joint(std::string const &joint_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*local_this).release_joint)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "release_joint(const PartBundle self, str joint_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_release_joint_276_comment =
  "C++ Interface:\n"
  "release_joint(const PartBundle self, str joint_name)\n"
  "\n"
  "/**\n"
  " * Releases the named joint from the effects of a previous call to\n"
  " * freeze_joint() or control_joint(). It will henceforth once again follow\n"
  " * whatever transforms are dictated by the animation.\n"
  " *\n"
  " * Returns true if the joint is released, or false if the named child was not\n"
  " * previously controlled or frozen, or it does not exist.\n"
  " */";
#else
static const char *Dtool_PartBundle_release_joint_276_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PartBundle::update(void)
 */
static PyObject *Dtool_PartBundle_update_277(PyObject *self, PyObject *) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.update")) {
    return nullptr;
  }
  // 1-bool PartBundle::update(void)
  bool return_value = ((*local_this).update)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_update_277_comment =
  "C++ Interface:\n"
  "update(const PartBundle self)\n"
  "\n"
  "/**\n"
  " * Updates all the parts in the bundle to reflect the data for the current\n"
  " * frame (as set in each of the AnimControls).\n"
  " *\n"
  " * Returns true if any part has changed as a result of this, or false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_PartBundle_update_277_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PartBundle::force_update(void)
 */
static PyObject *Dtool_PartBundle_force_update_278(PyObject *self, PyObject *) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.force_update")) {
    return nullptr;
  }
  // 1-bool PartBundle::force_update(void)
  bool return_value = ((*local_this).force_update)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_force_update_278_comment =
  "C++ Interface:\n"
  "force_update(const PartBundle self)\n"
  "\n"
  "/**\n"
  " * Updates all the parts in the bundle to reflect the data for the current\n"
  " * frame, whether we believe it needs it or not.\n"
  " */";
#else
static const char *Dtool_PartBundle_force_update_278_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PartBundle::get_class_type(void)
 */
static PyObject *Dtool_PartBundle_get_class_type_279(PyObject *, PyObject *) {
  // 1-static TypeHandle PartBundle::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PartBundle::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PartBundle_get_class_type_279_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PartBundle_get_class_type_279_comment = nullptr;
#endif

static PyObject *Dtool_PartBundle_blend_type_Getter(PyObject *self, void *) {
  const PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PartBundle::BlendType PartBundle::get_blend_type(void) const
  PartBundle::BlendType return_value = ((*(const PartBundle*)local_this).get_blend_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PartBundle_blend_type_Setter(PyObject *self, PyObject *arg, void *) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.blend_type")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete blend_type attribute");
    return -1;
  }
  // 1-inline void PartBundle::set_blend_type(PartBundle::BlendType bt)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_blend_type)((PartBundle::BlendType)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_blend_type(const PartBundle self, int bt)\n");
  }
  return -1;
}

static PyObject *Dtool_PartBundle_anim_blend_flag_Getter(PyObject *self, void *) {
  const PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool PartBundle::get_anim_blend_flag(void) const
  bool return_value = ((*(const PartBundle*)local_this).get_anim_blend_flag)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PartBundle_anim_blend_flag_Setter(PyObject *self, PyObject *arg, void *) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.anim_blend_flag")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete anim_blend_flag attribute");
    return -1;
  }
  // 1-void PartBundle::set_anim_blend_flag(bool anim_blend_flag)
  ((*local_this).set_anim_blend_flag)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_anim_blend_flag(const PartBundle self, bool anim_blend_flag)\n");
  }
  return -1;
}

static PyObject *Dtool_PartBundle_frame_blend_flag_Getter(PyObject *self, void *) {
  const PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool PartBundle::get_frame_blend_flag(void) const
  bool return_value = ((*(const PartBundle*)local_this).get_frame_blend_flag)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PartBundle_frame_blend_flag_Setter(PyObject *self, PyObject *arg, void *) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.frame_blend_flag")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete frame_blend_flag attribute");
    return -1;
  }
  // 1-inline void PartBundle::set_frame_blend_flag(bool frame_blend_flag)
  ((*local_this).set_frame_blend_flag)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_frame_blend_flag(const PartBundle self, bool frame_blend_flag)\n");
  }
  return -1;
}

static PyObject *Dtool_PartBundle_root_xform_Getter(PyObject *self, void *) {
  const PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LMatrix4 const &PartBundle::get_root_xform(void) const
  LMatrix4 const *return_value = &(((*(const PartBundle*)local_this).get_root_xform)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

static int Dtool_PartBundle_root_xform_Setter(PyObject *self, PyObject *arg, void *) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundle, (void **)&local_this, "PartBundle.root_xform")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete root_xform attribute");
    return -1;
  }
  // 1-inline void PartBundle::set_root_xform(LMatrix4 const &root_xform)
  LMatrix4f arg_local;
  LMatrix4 const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "PartBundle.set_root_xform", "LMatrix4f");
    return -1;
  }
  ((*local_this).set_root_xform)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_root_xform(const PartBundle self, const LMatrix4f root_xform)\n");
  }
  return -1;
}

/**
 * sequence length function for property PartBundle::nodes
 */
static Py_ssize_t Dtool_PartBundle_nodes_Len(PyObject *self) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_nodes)();
}

/**
 * sequence getter for property PartBundle::nodes
 */
static PyObject *Dtool_PartBundle_nodes_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_nodes)()) {
    PyErr_SetString(PyExc_IndexError, "PartBundle.nodes[] index out of range");
    return nullptr;
  }
  // 1-inline PartBundleNode *PartBundle::get_node(int n) const
  PartBundleNode *return_value = ((*(const PartBundle*)local_this).get_node)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartBundleNode, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_node(PartBundle self, index)\n");
  }
}

static PyObject *Dtool_PartBundle_nodes_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "PartBundle.nodes");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_PartBundle_nodes_Len;
    wrap->_getitem_func = &Dtool_PartBundle_nodes_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * explicit PartBundle::PartBundle(std::string const &name = "")
 */
static int Dtool_Init_PartBundle(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit PartBundle::PartBundle(std::string const &name = "")
  const char *param0_str = "";
  Py_ssize_t param0_len = 0;
  static const char *keyword_list[] = {"name", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|s#:PartBundle", (char **)keyword_list, &param0_str, &param0_len)) {
    PartBundle *return_value = new PartBundle(std::string(param0_str, param0_len));
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PartBundle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PartBundle(str name)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PartBundle_get_nodes(PyObject *self, PyObject *) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_nodes)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PartBundle_get_node_239(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PartBundle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PartBundle) {
    printf("PartBundle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PartBundle *local_this = (PartBundle *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PartBundle) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PartBundle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PartBundle) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PartBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (PartBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PartBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PartBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PartBundle*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PartBundle*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PartBundleNode
 */
/**
 * Python function wrapper for:
 * inline int PartBundleNode::get_num_bundles(void) const
 */
static PyObject *Dtool_PartBundleNode_get_num_bundles_251(PyObject *self, PyObject *) {
  PartBundleNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartBundleNode)) {
    return nullptr;
  }
  // 1-inline int PartBundleNode::get_num_bundles(void) const
  int return_value = ((*(const PartBundleNode*)local_this).get_num_bundles)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PartBundleNode_get_num_bundles_251_comment =
  "C++ Interface:\n"
  "get_num_bundles(PartBundleNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PartBundleNode_get_num_bundles_251_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PartBundle *PartBundleNode::get_bundle(int n) const
 */
static PyObject *Dtool_PartBundleNode_get_bundle_252(PyObject *self, PyObject *arg) {
  PartBundleNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartBundleNode)) {
    return nullptr;
  }
  // 1-inline PartBundle *PartBundleNode::get_bundle(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PartBundle *return_value = ((*(const PartBundleNode*)local_this).get_bundle)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartBundle, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bundle(PartBundleNode self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundleNode_get_bundle_252_comment =
  "C++ Interface:\n"
  "get_bundle(PartBundleNode self, int n)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PartBundleNode_get_bundle_252_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PartBundleHandle *PartBundleNode::get_bundle_handle(int n) const
 */
static PyObject *Dtool_PartBundleNode_get_bundle_handle_254(PyObject *self, PyObject *arg) {
  PartBundleNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PartBundleNode)) {
    return nullptr;
  }
  // 1-inline PartBundleHandle *PartBundleNode::get_bundle_handle(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PartBundleHandle *return_value = ((*(const PartBundleNode*)local_this).get_bundle_handle)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PartBundleHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bundle_handle(PartBundleNode self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundleNode_get_bundle_handle_254_comment =
  "C++ Interface:\n"
  "get_bundle_handle(PartBundleNode self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the PartBundleHandle that wraps around the actual nth PartBundle.\n"
  " * While the PartBundle pointer might later change due to a future flatten\n"
  " * operation, the PartBundleHandle will not.\n"
  " */";
#else
static const char *Dtool_PartBundleNode_get_bundle_handle_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PartBundleNode::get_class_type(void)
 */
static PyObject *Dtool_PartBundleNode_get_class_type_266(PyObject *, PyObject *) {
  // 1-static TypeHandle PartBundleNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PartBundleNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PartBundleNode_get_class_type_266_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PartBundleNode_get_class_type_266_comment = nullptr;
#endif

/**
 * sequence length function for property PartBundleNode::bundles
 */
static Py_ssize_t Dtool_PartBundleNode_bundles_Len(PyObject *self) {
  PartBundleNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundleNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_bundles)();
}

/**
 * sequence getter for property PartBundleNode::bundles
 */
static PyObject *Dtool_PartBundleNode_bundles_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  PartBundleNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundleNode, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_bundles)()) {
    PyErr_SetString(PyExc_IndexError, "PartBundleNode.bundles[] index out of range");
    return nullptr;
  }
  // 1-inline PartBundle *PartBundleNode::get_bundle(int n) const
  PartBundle *return_value = ((*(const PartBundleNode*)local_this).get_bundle)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartBundle, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bundle(PartBundleNode self, index)\n");
  }
}

static PyObject *Dtool_PartBundleNode_bundles_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "PartBundleNode.bundles");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_PartBundleNode_bundles_Len;
    wrap->_getitem_func = &Dtool_PartBundleNode_bundles_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * sequence length function for property PartBundleNode::bundle_handles
 */
static Py_ssize_t Dtool_PartBundleNode_bundle_handles_Len(PyObject *self) {
  PartBundleNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundleNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_bundles)();
}

/**
 * sequence getter for property PartBundleNode::bundle_handles
 */
static PyObject *Dtool_PartBundleNode_bundle_handles_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  PartBundleNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundleNode, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_bundles)()) {
    PyErr_SetString(PyExc_IndexError, "PartBundleNode.bundle_handles[] index out of range");
    return nullptr;
  }
  // 1-inline PartBundleHandle *PartBundleNode::get_bundle_handle(int n) const
  PartBundleHandle *return_value = ((*(const PartBundleNode*)local_this).get_bundle_handle)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PartBundleHandle, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bundle_handle(PartBundleNode self, index)\n");
  }
}

static PyObject *Dtool_PartBundleNode_bundle_handles_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "PartBundleNode.bundle_handles");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_PartBundleNode_bundle_handles_Len;
    wrap->_getitem_func = &Dtool_PartBundleNode_bundle_handles_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * inline explicit PartBundleNode::PartBundleNode(std::string const &name, PartBundle *bundle)
 */
static int Dtool_Init_PartBundleNode(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-inline explicit PartBundleNode::PartBundleNode(std::string const &name, PartBundle *bundle)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  PyObject *param1;
  static const char *keyword_list[] = {"name", "bundle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:PartBundleNode", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    PartBundle *param1_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_PartBundle, 1, "PartBundleNode.PartBundleNode", false, true);
    if (param1_this != nullptr) {
      PartBundleNode *return_value = new PartBundleNode(std::string(param0_str, param0_len), param1_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PartBundleNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PartBundleNode(str name, PartBundle bundle)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PartBundleNode_get_bundles(PyObject *self, PyObject *) {
  PartBundleNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundleNode, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_bundles)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PartBundleNode_get_bundle_252(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PartBundleNode_get_bundle_handles(PyObject *self, PyObject *) {
  PartBundleNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundleNode, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_bundles)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PartBundleNode_get_bundle_handle_254(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PartBundleNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PartBundleNode) {
    printf("PartBundleNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PartBundleNode *local_this = (PartBundleNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PartBundleNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PartBundleNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PartBundleNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PartBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PartBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PartBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PartBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PartBundleNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PartBundleNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PartBundleHandle
 */
/**
 * Python function wrapper for:
 * inline PartBundle *PartBundleHandle::get_bundle(void)
 */
static PyObject *Dtool_PartBundleHandle_get_bundle_263(PyObject *self, PyObject *) {
  PartBundleHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundleHandle, (void **)&local_this, "PartBundleHandle.get_bundle")) {
    return nullptr;
  }
  // 1-inline PartBundle *PartBundleHandle::get_bundle(void)
  PartBundle *return_value = ((*local_this).get_bundle)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartBundle, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PartBundleHandle_get_bundle_263_comment =
  "C++ Interface:\n"
  "get_bundle(const PartBundleHandle self)\n"
  "\n"
  "/**\n"
  " * Returns the actual PartBundle embedded within the handle.\n"
  " */";
#else
static const char *Dtool_PartBundleHandle_get_bundle_263_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PartBundleHandle::set_bundle(PartBundle *bundle)
 */
static PyObject *Dtool_PartBundleHandle_set_bundle_264(PyObject *self, PyObject *arg) {
  PartBundleHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundleHandle, (void **)&local_this, "PartBundleHandle.set_bundle")) {
    return nullptr;
  }
  // 1-inline void PartBundleHandle::set_bundle(PartBundle *bundle)
  PartBundle *arg_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PartBundle, 1, "PartBundleHandle.set_bundle", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_bundle)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bundle(const PartBundleHandle self, PartBundle bundle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PartBundleHandle_set_bundle_264_comment =
  "C++ Interface:\n"
  "set_bundle(const PartBundleHandle self, PartBundle bundle)\n"
  "\n"
  "/**\n"
  " * Changes the actual PartBundle embedded within the handle.\n"
  " */";
#else
static const char *Dtool_PartBundleHandle_set_bundle_264_comment = nullptr;
#endif

static PyObject *Dtool_PartBundleHandle_bundle_Getter(PyObject *self, void *) {
  PartBundleHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundleHandle, (void **)&local_this, "PartBundleHandle.bundle")) {
    return nullptr;
  }

  // 1-inline PartBundle *PartBundleHandle::get_bundle(void)
  PartBundle *return_value = ((*local_this).get_bundle)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PartBundle, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_PartBundleHandle_bundle_Setter(PyObject *self, PyObject *arg, void *) {
  PartBundleHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PartBundleHandle, (void **)&local_this, "PartBundleHandle.bundle")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete bundle attribute");
    return -1;
  }
  // 1-inline void PartBundleHandle::set_bundle(PartBundle *bundle)
  PartBundle *arg_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PartBundle, 1, "PartBundleHandle.set_bundle", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_bundle)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bundle(const PartBundleHandle self, PartBundle bundle)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline PartBundleHandle::PartBundleHandle(PartBundle *bundle)
 * inline PartBundleHandle::PartBundleHandle(PartBundleHandle const &) = default
 */
static int Dtool_Init_PartBundleHandle(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PartBundleHandle() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline PartBundleHandle::PartBundleHandle(PartBundle *bundle)
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds, "bundle")) {
      PartBundle *param0_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_PartBundle, 0, "PartBundleHandle.PartBundleHandle", false, false);
      if (param0_this != nullptr) {
        PartBundleHandle *return_value = new PartBundleHandle(param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PartBundleHandle, true, false);
      }
    }
  }

  // No coercion possible: inline PartBundleHandle::PartBundleHandle(PartBundle *bundle)
  {
    // -2 inline PartBundleHandle::PartBundleHandle(PartBundleHandle const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(PartBundleHandle) param0_this;
      if (Dtool_ConstCoerce_PartBundleHandle(param0, param0_this)) {
        PartBundleHandle *return_value = new PartBundleHandle(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PartBundleHandle, true, false);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PartBundleHandle(PartBundle bundle)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PartBundleHandle(PyObject *args, CPT(PartBundleHandle) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PartBundleHandle)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline PartBundleHandle::PartBundleHandle(PartBundle *bundle)
    PartBundle *arg_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PartBundle, 0, "PartBundleHandle.PartBundleHandle", false, false);
    if (arg_this != nullptr) {
      PartBundleHandle *return_value = new PartBundleHandle(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_PartBundleHandle(PyObject *args, PT(PartBundleHandle) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PartBundleHandle)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline PartBundleHandle::PartBundleHandle(PartBundle *bundle)
    PartBundle *arg_this = (PartBundle *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PartBundle, 0, "PartBundleHandle.PartBundleHandle", false, false);
    if (arg_this != nullptr) {
      PartBundleHandle *return_value = new PartBundleHandle(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_PartBundleHandle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PartBundleHandle) {
    printf("PartBundleHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PartBundleHandle *local_this = (PartBundleHandle *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PartBundleHandle) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PartBundleHandle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PartBundleHandle) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PartBundleHandle*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MovingPartBase
 */
/**
 * Python function wrapper for:
 * inline int MovingPartBase::get_max_bound(void) const
 */
static PyObject *Dtool_MovingPartBase_get_max_bound_282(PyObject *self, PyObject *) {
  MovingPartBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovingPartBase)) {
    return nullptr;
  }
  // 1-inline int MovingPartBase::get_max_bound(void) const
  int return_value = ((*(const MovingPartBase*)local_this).get_max_bound)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovingPartBase_get_max_bound_282_comment =
  "C++ Interface:\n"
  "get_max_bound(MovingPartBase self)\n"
  "\n"
  "/**\n"
  " * Returns the number of channels that might be bound to this PartGroup.  This\n"
  " * might not be the actual number of channels, since there might be holes in\n"
  " * the list; it is one more than the index number of the highest bound\n"
  " * channel.  Thus, it is called get_max_bound() instead of get_num_bound().\n"
  " */";
#else
static const char *Dtool_MovingPartBase_get_max_bound_282_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AnimChannelBase *MovingPartBase::get_bound(int n) const
 */
static PyObject *Dtool_MovingPartBase_get_bound_283(PyObject *self, PyObject *arg) {
  MovingPartBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovingPartBase)) {
    return nullptr;
  }
  // 1-inline AnimChannelBase *MovingPartBase::get_bound(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    AnimChannelBase *return_value = ((*(const MovingPartBase*)local_this).get_bound)((int)arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AnimChannelBase, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bound(MovingPartBase self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MovingPartBase_get_bound_283_comment =
  "C++ Interface:\n"
  "get_bound(MovingPartBase self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth bound channel on this PartGroup.  n can be determined by\n"
  " * iterating from 0 to one less than get_max_bound(); or n might be\n"
  " * AnimControl::get_channel_index().\n"
  " *\n"
  " * This will return NULL if there is no channel bound on the indicated index.\n"
  " * It is an error to call this if n is less than zero or greater than or equal\n"
  " * to get_max_bound().\n"
  " */";
#else
static const char *Dtool_MovingPartBase_get_bound_283_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void MovingPartBase::output_value(std::ostream &out) const = 0
 */
static PyObject *Dtool_MovingPartBase_output_value_284(PyObject *self, PyObject *arg) {
  MovingPartBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovingPartBase)) {
    return nullptr;
  }
  // 1-virtual void MovingPartBase::output_value(std::ostream &out) const = 0
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "MovingPartBase.output_value", false, true);
  if (arg_this != nullptr) {
    ((*(const MovingPartBase*)local_this).output_value)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_value(MovingPartBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MovingPartBase_output_value_284_comment =
  "C++ Interface:\n"
  "output_value(MovingPartBase self, ostream out)\n";
#else
static const char *Dtool_MovingPartBase_output_value_284_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle MovingPartBase::get_class_type(void)
 */
static PyObject *Dtool_MovingPartBase_get_class_type_285(PyObject *, PyObject *) {
  // 1-static TypeHandle MovingPartBase::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((MovingPartBase::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovingPartBase_get_class_type_285_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MovingPartBase_get_class_type_285_comment = nullptr;
#endif

static int Dtool_Init_MovingPartBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MovingPartBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MovingPartBase) {
    printf("MovingPartBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MovingPartBase *local_this = (MovingPartBase *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MovingPartBase) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MovingPartBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MovingPartBase) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MovingPartBase*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (MovingPartBase*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MovingPartBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MovingPartBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MovingPartBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MovingPartBase*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MovingPartMatrix
 */
/**
 * Python function wrapper for:
 * static TypeHandle MovingPartMatrix::get_class_type(void)
 */
static PyObject *Dtool_MovingPartMatrix_get_class_type_293(PyObject *, PyObject *) {
  // 1-static TypeHandle MovingPartMatrix::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((MovingPartMatrix::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovingPartMatrix_get_class_type_293_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MovingPartMatrix_get_class_type_293_comment = nullptr;
#endif

static int Dtool_Init_MovingPartMatrix(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MovingPartMatrix(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MovingPartMatrix) {
    printf("MovingPartMatrix ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MovingPartMatrix *local_this = (MovingPartMatrix *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MovingPartMatrix) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPart_ACMatrixSwitchType) {
    return (MovingPart< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPartBase) {
    return (MovingPartBase *)(MovingPart< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACMatrixSwitchType > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MovingPartMatrix(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MovingPartMatrix) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovingPart_ACMatrixSwitchType) {
    MovingPart< ACMatrixSwitchType >* other_this = (MovingPart< ACMatrixSwitchType >*)from_this;
    return (MovingPartMatrix*)other_this;
  }
  if (from_type == Dtool_Ptr_MovingPartBase) {
    MovingPartBase* other_this = (MovingPartBase*)from_this;
    return (MovingPartMatrix*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MovingPartMatrix*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (MovingPartMatrix*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MovingPartMatrix*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MovingPartMatrix*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MovingPartMatrix*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MovingPartMatrix*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MovingPart< ACMatrixSwitchType >
 */
/**
 * Python function wrapper for:
 * static TypeHandle MovingPart< ACMatrixSwitchType >::get_class_type(void)
 */
static PyObject *Dtool_MovingPart_ACMatrixSwitchType_get_class_type_289(PyObject *, PyObject *) {
  // 1-static TypeHandle MovingPart< ACMatrixSwitchType >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((MovingPart< ACMatrixSwitchType >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovingPart_ACMatrixSwitchType_get_class_type_289_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MovingPart_ACMatrixSwitchType_get_class_type_289_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 MovingPart< ACMatrixSwitchType >::get_value(void) const
 */
static PyObject *Dtool_MovingPart_ACMatrixSwitchType_get_value_290(PyObject *self, PyObject *) {
  MovingPart< ACMatrixSwitchType > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovingPart_ACMatrixSwitchType)) {
    return nullptr;
  }
  // 1-inline LMatrix4 MovingPart< ACMatrixSwitchType >::get_value(void) const
  LMatrix4 *return_value = new LMatrix4(((*(const MovingPart< ACMatrixSwitchType >*)local_this).get_value)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovingPart_ACMatrixSwitchType_get_value_290_comment =
  "C++ Interface:\n"
  "get_value(MovingPart self)\n";
#else
static const char *Dtool_MovingPart_ACMatrixSwitchType_get_value_290_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4 MovingPart< ACMatrixSwitchType >::get_default_value(void) const
 */
static PyObject *Dtool_MovingPart_ACMatrixSwitchType_get_default_value_291(PyObject *self, PyObject *) {
  MovingPart< ACMatrixSwitchType > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovingPart_ACMatrixSwitchType)) {
    return nullptr;
  }
  // 1-inline LMatrix4 MovingPart< ACMatrixSwitchType >::get_default_value(void) const
  LMatrix4 *return_value = new LMatrix4(((*(const MovingPart< ACMatrixSwitchType >*)local_this).get_default_value)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovingPart_ACMatrixSwitchType_get_default_value_291_comment =
  "C++ Interface:\n"
  "get_default_value(MovingPart self)\n";
#else
static const char *Dtool_MovingPart_ACMatrixSwitchType_get_default_value_291_comment = nullptr;
#endif

static int Dtool_Init_MovingPart_ACMatrixSwitchType(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MovingPart_ACMatrixSwitchType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MovingPart_ACMatrixSwitchType) {
    printf("MovingPart_ACMatrixSwitchType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MovingPart< ACMatrixSwitchType > *local_this = (MovingPart< ACMatrixSwitchType > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MovingPart_ACMatrixSwitchType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPartBase) {
    return (MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MovingPart_ACMatrixSwitchType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MovingPart_ACMatrixSwitchType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovingPartBase) {
    MovingPartBase* other_this = (MovingPartBase*)from_this;
    return (MovingPart< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MovingPart< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (MovingPart< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MovingPart< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MovingPart< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MovingPart< ACMatrixSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MovingPart< ACMatrixSwitchType >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MovingPartScalar
 */
/**
 * Python function wrapper for:
 * static TypeHandle MovingPartScalar::get_class_type(void)
 */
static PyObject *Dtool_MovingPartScalar_get_class_type_300(PyObject *, PyObject *) {
  // 1-static TypeHandle MovingPartScalar::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((MovingPartScalar::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovingPartScalar_get_class_type_300_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MovingPartScalar_get_class_type_300_comment = nullptr;
#endif

static int Dtool_Init_MovingPartScalar(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MovingPartScalar(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MovingPartScalar) {
    printf("MovingPartScalar ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MovingPartScalar *local_this = (MovingPartScalar *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MovingPartScalar) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPart_ACScalarSwitchType) {
    return (MovingPart< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPartBase) {
    return (MovingPartBase *)(MovingPart< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *)(MovingPart< ACScalarSwitchType > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MovingPartScalar(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MovingPartScalar) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovingPart_ACScalarSwitchType) {
    MovingPart< ACScalarSwitchType >* other_this = (MovingPart< ACScalarSwitchType >*)from_this;
    return (MovingPartScalar*)other_this;
  }
  if (from_type == Dtool_Ptr_MovingPartBase) {
    MovingPartBase* other_this = (MovingPartBase*)from_this;
    return (MovingPartScalar*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MovingPartScalar*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (MovingPartScalar*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MovingPartScalar*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MovingPartScalar*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MovingPartScalar*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MovingPartScalar*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MovingPart< ACScalarSwitchType >
 */
/**
 * Python function wrapper for:
 * static TypeHandle MovingPart< ACScalarSwitchType >::get_class_type(void)
 */
static PyObject *Dtool_MovingPart_ACScalarSwitchType_get_class_type_296(PyObject *, PyObject *) {
  // 1-static TypeHandle MovingPart< ACScalarSwitchType >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((MovingPart< ACScalarSwitchType >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MovingPart_ACScalarSwitchType_get_class_type_296_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_MovingPart_ACScalarSwitchType_get_class_type_296_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat MovingPart< ACScalarSwitchType >::get_value(void) const
 */
static PyObject *Dtool_MovingPart_ACScalarSwitchType_get_value_297(PyObject *self, PyObject *) {
  MovingPart< ACScalarSwitchType > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovingPart_ACScalarSwitchType)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat MovingPart< ACScalarSwitchType >::get_value(void) const
  PN_stdfloat return_value = ((*(const MovingPart< ACScalarSwitchType >*)local_this).get_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovingPart_ACScalarSwitchType_get_value_297_comment =
  "C++ Interface:\n"
  "get_value(MovingPart self)\n";
#else
static const char *Dtool_MovingPart_ACScalarSwitchType_get_value_297_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat MovingPart< ACScalarSwitchType >::get_default_value(void) const
 */
static PyObject *Dtool_MovingPart_ACScalarSwitchType_get_default_value_298(PyObject *self, PyObject *) {
  MovingPart< ACScalarSwitchType > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_MovingPart_ACScalarSwitchType)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat MovingPart< ACScalarSwitchType >::get_default_value(void) const
  PN_stdfloat return_value = ((*(const MovingPart< ACScalarSwitchType >*)local_this).get_default_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_MovingPart_ACScalarSwitchType_get_default_value_298_comment =
  "C++ Interface:\n"
  "get_default_value(MovingPart self)\n";
#else
static const char *Dtool_MovingPart_ACScalarSwitchType_get_default_value_298_comment = nullptr;
#endif

static int Dtool_Init_MovingPart_ACScalarSwitchType(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_MovingPart_ACScalarSwitchType(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MovingPart_ACScalarSwitchType) {
    printf("MovingPart_ACScalarSwitchType ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MovingPart< ACScalarSwitchType > *local_this = (MovingPart< ACScalarSwitchType > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MovingPart_ACScalarSwitchType) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_MovingPartBase) {
    return (MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_PartGroup) {
    return (PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PartGroup *)(MovingPartBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MovingPart_ACScalarSwitchType(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MovingPart_ACScalarSwitchType) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_MovingPartBase) {
    MovingPartBase* other_this = (MovingPartBase*)from_this;
    return (MovingPart< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (MovingPart< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_PartGroup) {
    PartGroup* other_this = (PartGroup*)from_this;
    return (MovingPart< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (MovingPart< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (MovingPart< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (MovingPart< ACScalarSwitchType >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (MovingPart< ACScalarSwitchType >*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for AnimGroup (AnimGroup)
 */
static PyMethodDef Dtool_Methods_AnimGroup[] = {
  {"get_num_children", &Dtool_AnimGroup_get_num_children_10, METH_NOARGS, (const char *)Dtool_AnimGroup_get_num_children_10_comment},
  {"getNumChildren", &Dtool_AnimGroup_get_num_children_10, METH_NOARGS, (const char *)Dtool_AnimGroup_get_num_children_10_comment},
  {"get_child", &Dtool_AnimGroup_get_child_11, METH_O, (const char *)Dtool_AnimGroup_get_child_11_comment},
  {"getChild", &Dtool_AnimGroup_get_child_11, METH_O, (const char *)Dtool_AnimGroup_get_child_11_comment},
  {"get_child_named", &Dtool_AnimGroup_get_child_named_13, METH_O, (const char *)Dtool_AnimGroup_get_child_named_13_comment},
  {"getChildNamed", &Dtool_AnimGroup_get_child_named_13, METH_O, (const char *)Dtool_AnimGroup_get_child_named_13_comment},
  {"find_child", &Dtool_AnimGroup_find_child_14, METH_O, (const char *)Dtool_AnimGroup_find_child_14_comment},
  {"findChild", &Dtool_AnimGroup_find_child_14, METH_O, (const char *)Dtool_AnimGroup_find_child_14_comment},
  {"sort_descendants", &Dtool_AnimGroup_sort_descendants_15, METH_NOARGS, (const char *)Dtool_AnimGroup_sort_descendants_15_comment},
  {"sortDescendants", &Dtool_AnimGroup_sort_descendants_15, METH_NOARGS, (const char *)Dtool_AnimGroup_sort_descendants_15_comment},
  {"output", &Dtool_AnimGroup_output_18, METH_O, (const char *)Dtool_AnimGroup_output_18_comment},
  {"write", (PyCFunction) &Dtool_AnimGroup_write_19, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimGroup_write_19_comment},
  {"get_class_type", &Dtool_AnimGroup_get_class_type_20, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimGroup_get_class_type_20_comment},
  {"getClassType", &Dtool_AnimGroup_get_class_type_20, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimGroup_get_class_type_20_comment},
  {"upcast_to_TypedWritableReferenceCount", &Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3, METH_NOARGS, (const char *)Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3_comment},
  {"upcastToTypedWritableReferenceCount", &Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3, METH_NOARGS, (const char *)Dtool_AnimGroup_upcast_to_TypedWritableReferenceCount_3_comment},
  {"upcast_to_Namable", &Dtool_AnimGroup_upcast_to_Namable_6, METH_NOARGS, (const char *)Dtool_AnimGroup_upcast_to_Namable_6_comment},
  {"upcastToNamable", &Dtool_AnimGroup_upcast_to_Namable_6, METH_NOARGS, (const char *)Dtool_AnimGroup_upcast_to_Namable_6_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_children", (PyCFunction) &MakeSeq_AnimGroup_get_children, METH_NOARGS, nullptr},
  { "getChildren", (PyCFunction) &MakeSeq_AnimGroup_get_children, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     AnimGroup
//////////////////
static PyObject *Dtool_Repr_AnimGroup(PyObject *self) {
  AnimGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimGroup, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AnimGroup
//////////////////
static PyObject *Dtool_Str_AnimGroup(PyObject *self) {
  AnimGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimGroup, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_AnimGroup[] = {
  {(char *)"children", &Dtool_AnimGroup_children_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_AnimGroup = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimGroup = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AnimGroup = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AnimGroup = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AnimGroup = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AnimGroup = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AnimGroup",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimGroup,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AnimGroup,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_AnimGroup,
    &Dtool_NumberMethods_AnimGroup,
    &Dtool_SequenceMethods_AnimGroup,
    &Dtool_MappingMethods_AnimGroup,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_AnimGroup,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AnimGroup,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for AnimChannel and AnimBundle.  It implements a\n"
    " * hierarchy of AnimChannels.  The root of the hierarchy must be an\n"
    " * AnimBundle.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AnimGroup,
    nullptr, // tp_members
    Dtool_Properties_AnimGroup,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AnimGroup,
    PyType_GenericAlloc,
    Dtool_new_AnimGroup,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimGroup,
  Dtool_UpcastInterface_AnimGroup,
  Dtool_DowncastInterface_AnimGroup,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AnimGroup(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_AnimGroup._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_AnimGroup._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AnimGroup._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimGroup) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimGroup)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimGroup);
  }
}

/**
 * Python method tables for AnimBundle (AnimBundle)
 */
static PyMethodDef Dtool_Methods_AnimBundle[] = {
  {"copy_bundle", &Dtool_AnimBundle_copy_bundle_23, METH_NOARGS, (const char *)Dtool_AnimBundle_copy_bundle_23_comment},
  {"copyBundle", &Dtool_AnimBundle_copy_bundle_23, METH_NOARGS, (const char *)Dtool_AnimBundle_copy_bundle_23_comment},
  {"get_base_frame_rate", &Dtool_AnimBundle_get_base_frame_rate_24, METH_NOARGS, (const char *)Dtool_AnimBundle_get_base_frame_rate_24_comment},
  {"getBaseFrameRate", &Dtool_AnimBundle_get_base_frame_rate_24, METH_NOARGS, (const char *)Dtool_AnimBundle_get_base_frame_rate_24_comment},
  {"get_num_frames", &Dtool_AnimBundle_get_num_frames_25, METH_NOARGS, (const char *)Dtool_AnimBundle_get_num_frames_25_comment},
  {"getNumFrames", &Dtool_AnimBundle_get_num_frames_25, METH_NOARGS, (const char *)Dtool_AnimBundle_get_num_frames_25_comment},
  {"get_class_type", &Dtool_AnimBundle_get_class_type_30, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimBundle_get_class_type_30_comment},
  {"getClassType", &Dtool_AnimBundle_get_class_type_30, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimBundle_get_class_type_30_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_AnimBundle[] = {
  {(char *)"base_frame_rate", &Dtool_AnimBundle_base_frame_rate_Getter, nullptr, nullptr, nullptr},
  {(char *)"num_frames", &Dtool_AnimBundle_num_frames_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_AnimBundle = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimBundle = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AnimBundle = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AnimBundle = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AnimBundle = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AnimBundle = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AnimBundle",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimBundle,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AnimBundle,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AnimBundle,
    &Dtool_SequenceMethods_AnimBundle,
    &Dtool_MappingMethods_AnimBundle,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AnimBundle,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the root of an AnimChannel hierarchy.  It knows the frame rate and\n"
    " * number of frames of all the channels in the hierarchy (which must all\n"
    " * match).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AnimBundle,
    nullptr, // tp_members
    Dtool_Properties_AnimBundle,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AnimBundle,
    PyType_GenericAlloc,
    Dtool_new_AnimBundle,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimBundle,
  Dtool_UpcastInterface_AnimBundle,
  Dtool_DowncastInterface_AnimBundle,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AnimBundle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AnimGroup(nullptr);
    Dtool_AnimBundle._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AnimGroup);
    Dtool_AnimBundle._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AnimBundle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimBundle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimBundle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimBundle);
  }
}

/**
 * Python method tables for AnimBundleNode (AnimBundleNode)
 */
static PyMethodDef Dtool_Methods_AnimBundleNode[] = {
  {"get_bundle", &Dtool_AnimBundleNode_get_bundle_35, METH_NOARGS, (const char *)Dtool_AnimBundleNode_get_bundle_35_comment},
  {"getBundle", &Dtool_AnimBundleNode_get_bundle_35, METH_NOARGS, (const char *)Dtool_AnimBundleNode_get_bundle_35_comment},
  {"find_anim_bundle", &Dtool_AnimBundleNode_find_anim_bundle_38, METH_O | METH_STATIC, (const char *)Dtool_AnimBundleNode_find_anim_bundle_38_comment},
  {"findAnimBundle", &Dtool_AnimBundleNode_find_anim_bundle_38, METH_O | METH_STATIC, (const char *)Dtool_AnimBundleNode_find_anim_bundle_38_comment},
  {"get_class_type", &Dtool_AnimBundleNode_get_class_type_39, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimBundleNode_get_class_type_39_comment},
  {"getClassType", &Dtool_AnimBundleNode_get_class_type_39, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimBundleNode_get_class_type_39_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_AnimBundleNode[] = {
  {(char *)"bundle", &Dtool_AnimBundleNode_bundle_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_AnimBundleNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimBundleNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AnimBundleNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AnimBundleNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AnimBundleNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AnimBundleNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AnimBundleNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimBundleNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AnimBundleNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AnimBundleNode,
    &Dtool_SequenceMethods_AnimBundleNode,
    &Dtool_MappingMethods_AnimBundleNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AnimBundleNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a node that contains a pointer to an AnimBundle.  Like\n"
    " * PartBundleNode, it exists solely to make it easy to store AnimBundles in\n"
    " * the scene graph.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AnimBundleNode,
    nullptr, // tp_members
    Dtool_Properties_AnimBundleNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AnimBundleNode,
    PyType_GenericAlloc,
    Dtool_new_AnimBundleNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimBundleNode,
  Dtool_UpcastInterface_AnimBundleNode,
  Dtool_DowncastInterface_AnimBundleNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AnimBundleNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_AnimBundleNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    Dtool_AnimBundleNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AnimBundleNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimBundleNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimBundleNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimBundleNode);
  }
}

/**
 * Python method tables for PartGroup (PartGroup)
 */
static PyMethodDef Dtool_Methods_PartGroup[] = {
  {"is_character_joint", &Dtool_PartGroup_is_character_joint_49, METH_NOARGS, (const char *)Dtool_PartGroup_is_character_joint_49_comment},
  {"isCharacterJoint", &Dtool_PartGroup_is_character_joint_49, METH_NOARGS, (const char *)Dtool_PartGroup_is_character_joint_49_comment},
  {"make_copy", &Dtool_PartGroup_make_copy_50, METH_NOARGS, (const char *)Dtool_PartGroup_make_copy_50_comment},
  {"makeCopy", &Dtool_PartGroup_make_copy_50, METH_NOARGS, (const char *)Dtool_PartGroup_make_copy_50_comment},
  {"copy_subgraph", &Dtool_PartGroup_copy_subgraph_51, METH_NOARGS, (const char *)Dtool_PartGroup_copy_subgraph_51_comment},
  {"copySubgraph", &Dtool_PartGroup_copy_subgraph_51, METH_NOARGS, (const char *)Dtool_PartGroup_copy_subgraph_51_comment},
  {"get_num_children", &Dtool_PartGroup_get_num_children_52, METH_NOARGS, (const char *)Dtool_PartGroup_get_num_children_52_comment},
  {"getNumChildren", &Dtool_PartGroup_get_num_children_52, METH_NOARGS, (const char *)Dtool_PartGroup_get_num_children_52_comment},
  {"get_child", &Dtool_PartGroup_get_child_53, METH_O, (const char *)Dtool_PartGroup_get_child_53_comment},
  {"getChild", &Dtool_PartGroup_get_child_53, METH_O, (const char *)Dtool_PartGroup_get_child_53_comment},
  {"get_child_named", &Dtool_PartGroup_get_child_named_55, METH_O, (const char *)Dtool_PartGroup_get_child_named_55_comment},
  {"getChildNamed", &Dtool_PartGroup_get_child_named_55, METH_O, (const char *)Dtool_PartGroup_get_child_named_55_comment},
  {"find_child", &Dtool_PartGroup_find_child_56, METH_O, (const char *)Dtool_PartGroup_find_child_56_comment},
  {"findChild", &Dtool_PartGroup_find_child_56, METH_O, (const char *)Dtool_PartGroup_find_child_56_comment},
  {"sort_descendants", &Dtool_PartGroup_sort_descendants_57, METH_NOARGS, (const char *)Dtool_PartGroup_sort_descendants_57_comment},
  {"sortDescendants", &Dtool_PartGroup_sort_descendants_57, METH_NOARGS, (const char *)Dtool_PartGroup_sort_descendants_57_comment},
  {"apply_freeze", &Dtool_PartGroup_apply_freeze_60, METH_O, (const char *)Dtool_PartGroup_apply_freeze_60_comment},
  {"applyFreeze", &Dtool_PartGroup_apply_freeze_60, METH_O, (const char *)Dtool_PartGroup_apply_freeze_60_comment},
  {"apply_freeze_matrix", (PyCFunction) &Dtool_PartGroup_apply_freeze_matrix_61, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartGroup_apply_freeze_matrix_61_comment},
  {"applyFreezeMatrix", (PyCFunction) &Dtool_PartGroup_apply_freeze_matrix_61, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartGroup_apply_freeze_matrix_61_comment},
  {"apply_freeze_scalar", &Dtool_PartGroup_apply_freeze_scalar_62, METH_O, (const char *)Dtool_PartGroup_apply_freeze_scalar_62_comment},
  {"applyFreezeScalar", &Dtool_PartGroup_apply_freeze_scalar_62, METH_O, (const char *)Dtool_PartGroup_apply_freeze_scalar_62_comment},
  {"apply_control", &Dtool_PartGroup_apply_control_63, METH_O, (const char *)Dtool_PartGroup_apply_control_63_comment},
  {"applyControl", &Dtool_PartGroup_apply_control_63, METH_O, (const char *)Dtool_PartGroup_apply_control_63_comment},
  {"clear_forced_channel", &Dtool_PartGroup_clear_forced_channel_64, METH_NOARGS, (const char *)Dtool_PartGroup_clear_forced_channel_64_comment},
  {"clearForcedChannel", &Dtool_PartGroup_clear_forced_channel_64, METH_NOARGS, (const char *)Dtool_PartGroup_clear_forced_channel_64_comment},
  {"get_forced_channel", &Dtool_PartGroup_get_forced_channel_65, METH_NOARGS, (const char *)Dtool_PartGroup_get_forced_channel_65_comment},
  {"getForcedChannel", &Dtool_PartGroup_get_forced_channel_65, METH_NOARGS, (const char *)Dtool_PartGroup_get_forced_channel_65_comment},
  {"write", (PyCFunction) &Dtool_PartGroup_write_66, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartGroup_write_66_comment},
  {"write_with_value", (PyCFunction) &Dtool_PartGroup_write_with_value_67, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartGroup_write_with_value_67_comment},
  {"writeWithValue", (PyCFunction) &Dtool_PartGroup_write_with_value_67, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartGroup_write_with_value_67_comment},
  {"get_class_type", &Dtool_PartGroup_get_class_type_68, METH_NOARGS | METH_STATIC, (const char *)Dtool_PartGroup_get_class_type_68_comment},
  {"getClassType", &Dtool_PartGroup_get_class_type_68, METH_NOARGS | METH_STATIC, (const char *)Dtool_PartGroup_get_class_type_68_comment},
  {"upcast_to_TypedWritableReferenceCount", &Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_42, METH_NOARGS, (const char *)Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_42_comment},
  {"upcastToTypedWritableReferenceCount", &Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_42, METH_NOARGS, (const char *)Dtool_PartGroup_upcast_to_TypedWritableReferenceCount_42_comment},
  {"upcast_to_Namable", &Dtool_PartGroup_upcast_to_Namable_44, METH_NOARGS, (const char *)Dtool_PartGroup_upcast_to_Namable_44_comment},
  {"upcastToNamable", &Dtool_PartGroup_upcast_to_Namable_44, METH_NOARGS, (const char *)Dtool_PartGroup_upcast_to_Namable_44_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_children", (PyCFunction) &MakeSeq_PartGroup_get_children, METH_NOARGS, nullptr},
  { "getChildren", (PyCFunction) &MakeSeq_PartGroup_get_children, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     PartGroup
//////////////////
static PyObject *Dtool_Str_PartGroup(PyObject *self) {
  PartGroup *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartGroup, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_PartGroup[] = {
  {(char *)"children", &Dtool_PartGroup_children_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PartGroup = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PartGroup = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PartGroup = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PartGroup = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PartGroup = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PartGroup = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PartGroup",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PartGroup,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PartGroup,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PartGroup,
    &Dtool_SequenceMethods_PartGroup,
    &Dtool_MappingMethods_PartGroup,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_PartGroup,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PartGroup,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for PartRoot and MovingPart.  It defines a hierarchy\n"
    " * of MovingParts.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PartGroup,
    nullptr, // tp_members
    Dtool_Properties_PartGroup,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PartGroup,
    PyType_GenericAlloc,
    Dtool_new_PartGroup,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PartGroup,
  Dtool_UpcastInterface_PartGroup,
  Dtool_DowncastInterface_PartGroup,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PartGroup(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedWritableReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedWritableReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_PartGroup._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedWritableReferenceCount, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_PartGroup._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_PartGroup._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PartGroup::HierarchyMatchFlags;
    PyDict_SetItemString(dict, "HMF_ok_part_extra", Dtool_WrapValue(PartGroup::HMF_ok_part_extra));
    PyDict_SetItemString(dict, "HMFOkPartExtra", Dtool_WrapValue(PartGroup::HMF_ok_part_extra));
    PyDict_SetItemString(dict, "HMF_ok_anim_extra", Dtool_WrapValue(PartGroup::HMF_ok_anim_extra));
    PyDict_SetItemString(dict, "HMFOkAnimExtra", Dtool_WrapValue(PartGroup::HMF_ok_anim_extra));
    PyDict_SetItemString(dict, "HMF_ok_wrong_root_name", Dtool_WrapValue(PartGroup::HMF_ok_wrong_root_name));
    PyDict_SetItemString(dict, "HMFOkWrongRootName", Dtool_WrapValue(PartGroup::HMF_ok_wrong_root_name));
    if (PyType_Ready((PyTypeObject *)&Dtool_PartGroup) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PartGroup)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PartGroup);
  }
}

/**
 * Python method tables for AnimControl (AnimControl)
 */
static PyMethodDef Dtool_Methods_AnimControl[] = {
  {"is_pending", &Dtool_AnimControl_is_pending_79, METH_NOARGS, (const char *)Dtool_AnimControl_is_pending_79_comment},
  {"isPending", &Dtool_AnimControl_is_pending_79, METH_NOARGS, (const char *)Dtool_AnimControl_is_pending_79_comment},
  {"wait_pending", &Dtool_AnimControl_wait_pending_80, METH_NOARGS, (const char *)Dtool_AnimControl_wait_pending_80_comment},
  {"waitPending", &Dtool_AnimControl_wait_pending_80, METH_NOARGS, (const char *)Dtool_AnimControl_wait_pending_80_comment},
  {"has_anim", &Dtool_AnimControl_has_anim_81, METH_NOARGS, (const char *)Dtool_AnimControl_has_anim_81_comment},
  {"hasAnim", &Dtool_AnimControl_has_anim_81, METH_NOARGS, (const char *)Dtool_AnimControl_has_anim_81_comment},
  {"set_pending_done_event", &Dtool_AnimControl_set_pending_done_event_82, METH_O, (const char *)Dtool_AnimControl_set_pending_done_event_82_comment},
  {"setPendingDoneEvent", &Dtool_AnimControl_set_pending_done_event_82, METH_O, (const char *)Dtool_AnimControl_set_pending_done_event_82_comment},
  {"get_pending_done_event", &Dtool_AnimControl_get_pending_done_event_83, METH_NOARGS, (const char *)Dtool_AnimControl_get_pending_done_event_83_comment},
  {"getPendingDoneEvent", &Dtool_AnimControl_get_pending_done_event_83, METH_NOARGS, (const char *)Dtool_AnimControl_get_pending_done_event_83_comment},
  {"get_part", &Dtool_AnimControl_get_part_84, METH_NOARGS, (const char *)Dtool_AnimControl_get_part_84_comment},
  {"getPart", &Dtool_AnimControl_get_part_84, METH_NOARGS, (const char *)Dtool_AnimControl_get_part_84_comment},
  {"get_anim", &Dtool_AnimControl_get_anim_85, METH_NOARGS, (const char *)Dtool_AnimControl_get_anim_85_comment},
  {"getAnim", &Dtool_AnimControl_get_anim_85, METH_NOARGS, (const char *)Dtool_AnimControl_get_anim_85_comment},
  {"get_channel_index", &Dtool_AnimControl_get_channel_index_86, METH_NOARGS, (const char *)Dtool_AnimControl_get_channel_index_86_comment},
  {"getChannelIndex", &Dtool_AnimControl_get_channel_index_86, METH_NOARGS, (const char *)Dtool_AnimControl_get_channel_index_86_comment},
  {"get_bound_joints", &Dtool_AnimControl_get_bound_joints_87, METH_NOARGS, (const char *)Dtool_AnimControl_get_bound_joints_87_comment},
  {"getBoundJoints", &Dtool_AnimControl_get_bound_joints_87, METH_NOARGS, (const char *)Dtool_AnimControl_get_bound_joints_87_comment},
  {"set_anim_model", &Dtool_AnimControl_set_anim_model_88, METH_O, (const char *)Dtool_AnimControl_set_anim_model_88_comment},
  {"setAnimModel", &Dtool_AnimControl_set_anim_model_88, METH_O, (const char *)Dtool_AnimControl_set_anim_model_88_comment},
  {"get_anim_model", &Dtool_AnimControl_get_anim_model_89, METH_NOARGS, (const char *)Dtool_AnimControl_get_anim_model_89_comment},
  {"getAnimModel", &Dtool_AnimControl_get_anim_model_89, METH_NOARGS, (const char *)Dtool_AnimControl_get_anim_model_89_comment},
  {"output", &Dtool_AnimControl_output_90, METH_O, (const char *)Dtool_AnimControl_output_90_comment},
  {"get_class_type", &Dtool_AnimControl_get_class_type_91, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimControl_get_class_type_91_comment},
  {"getClassType", &Dtool_AnimControl_get_class_type_91, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimControl_get_class_type_91_comment},
  {"upcast_to_TypedReferenceCount", &Dtool_AnimControl_upcast_to_TypedReferenceCount_71, METH_NOARGS, (const char *)Dtool_AnimControl_upcast_to_TypedReferenceCount_71_comment},
  {"upcastToTypedReferenceCount", &Dtool_AnimControl_upcast_to_TypedReferenceCount_71, METH_NOARGS, (const char *)Dtool_AnimControl_upcast_to_TypedReferenceCount_71_comment},
  {"upcast_to_AnimInterface", &Dtool_AnimControl_upcast_to_AnimInterface_74, METH_NOARGS, (const char *)Dtool_AnimControl_upcast_to_AnimInterface_74_comment},
  {"upcastToAnimInterface", &Dtool_AnimControl_upcast_to_AnimInterface_74, METH_NOARGS, (const char *)Dtool_AnimControl_upcast_to_AnimInterface_74_comment},
  {"upcast_to_Namable", &Dtool_AnimControl_upcast_to_Namable_76, METH_NOARGS, (const char *)Dtool_AnimControl_upcast_to_Namable_76_comment},
  {"upcastToNamable", &Dtool_AnimControl_upcast_to_Namable_76, METH_NOARGS, (const char *)Dtool_AnimControl_upcast_to_Namable_76_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     AnimControl
//////////////////
static PyObject *Dtool_Repr_AnimControl(PyObject *self) {
  AnimControl *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControl, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AnimControl = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimControl = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AnimControl = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AnimControl = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AnimControl = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AnimControl = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AnimControl",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimControl,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AnimControl,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_AnimControl,
    &Dtool_NumberMethods_AnimControl,
    &Dtool_SequenceMethods_AnimControl,
    &Dtool_MappingMethods_AnimControl,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_AnimControl,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AnimControl,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Controls the timing of a character animation.  An AnimControl object is\n"
    " * created for each character/bundle binding and manages the state of the\n"
    " * animation: whether started, stopped, or looping, and the current frame\n"
    " * number and play rate.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AnimControl,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AnimControl,
    PyType_GenericAlloc,
    Dtool_new_AnimControl,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimControl,
  Dtool_UpcastInterface_AnimControl,
  Dtool_DowncastInterface_AnimControl,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AnimControl(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_AnimInterface != nullptr);
    assert(Dtool_Ptr_AnimInterface->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_AnimInterface->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_Namable != nullptr);
    assert(Dtool_Ptr_Namable->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_Namable->_Dtool_ModuleClassInit(nullptr);
    Dtool_AnimControl._PyType.tp_bases = PyTuple_Pack(3, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount, (PyTypeObject *)Dtool_Ptr_AnimInterface, (PyTypeObject *)Dtool_Ptr_Namable);
    Dtool_AnimControl._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AnimControl._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimControl) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimControl)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimControl);
  }
}

/**
 * Python method tables for AnimChannelBase (AnimChannelBase)
 */
static PyMethodDef Dtool_Methods_AnimChannelBase[] = {
  {"get_type", &Dtool_AnimChannelBase_get_type_93, METH_NOARGS, (const char *)Dtool_AnimChannelBase_get_type_93_comment},
  {"getType", &Dtool_AnimChannelBase_get_type_93, METH_NOARGS, (const char *)Dtool_AnimChannelBase_get_type_93_comment},
  {"get_class_type", &Dtool_AnimChannelBase_get_class_type_94, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelBase_get_class_type_94_comment},
  {"getClassType", &Dtool_AnimChannelBase_get_class_type_94, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelBase_get_class_type_94_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AnimChannelBase = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimChannelBase = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AnimChannelBase = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AnimChannelBase = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AnimChannelBase = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AnimChannelBase = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AnimChannelBase",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimChannelBase,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AnimChannelBase,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AnimChannelBase,
    &Dtool_SequenceMethods_AnimChannelBase,
    &Dtool_MappingMethods_AnimChannelBase,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AnimChannelBase,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Parent class for all animation channels.  An AnimChannel is an arbitrary\n"
    " * function that changes over time (actually, over frames), usually defined by\n"
    " * a table read from an egg file (but possibly computed or generated in any\n"
    " * other way).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AnimChannelBase,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AnimChannelBase,
    PyType_GenericAlloc,
    Dtool_new_AnimChannelBase,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimChannelBase,
  Dtool_UpcastInterface_AnimChannelBase,
  Dtool_DowncastInterface_AnimChannelBase,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AnimChannelBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AnimGroup(nullptr);
    Dtool_AnimChannelBase._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AnimGroup);
    Dtool_AnimChannelBase._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AnimChannelBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimChannelBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimChannelBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimChannelBase);
  }
}

/**
 * Python method tables for AnimChannel_ACMatrixSwitchType (AnimChannel_ACMatrixSwitchType)
 */
static PyMethodDef Dtool_Methods_AnimChannel_ACMatrixSwitchType[] = {
  {"get_value", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_value_99, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_value_99_comment},
  {"getValue", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_value_99, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_value_99_comment},
  {"get_value_no_scale_shear", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_100, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_100_comment},
  {"getValueNoScaleShear", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_100, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_value_no_scale_shear_100_comment},
  {"get_scale", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_scale_101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_scale_101_comment},
  {"getScale", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_scale_101, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_scale_101_comment},
  {"get_hpr", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_102, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_102_comment},
  {"getHpr", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_102, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_hpr_102_comment},
  {"get_quat", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_quat_103, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_quat_103_comment},
  {"getQuat", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_quat_103, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_quat_103_comment},
  {"get_pos", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_pos_104, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_pos_104_comment},
  {"getPos", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_pos_104, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_pos_104_comment},
  {"get_shear", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_shear_105, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_shear_105_comment},
  {"getShear", (PyCFunction) &Dtool_AnimChannel_ACMatrixSwitchType_get_shear_105, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_shear_105_comment},
  {"get_value_type", &Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_106, METH_NOARGS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_106_comment},
  {"getValueType", &Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_106, METH_NOARGS, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_value_type_106_comment},
  {"get_class_type", &Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_107, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_107_comment},
  {"getClassType", &Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_107, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannel_ACMatrixSwitchType_get_class_type_107_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AnimChannel_ACMatrixSwitchType = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimChannel_ACMatrixSwitchType = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AnimChannel_ACMatrixSwitchType = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AnimChannel_ACMatrixSwitchType = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AnimChannel_ACMatrixSwitchType = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AnimChannel_ACMatrixSwitchType = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AnimChannel_ACMatrixSwitchType",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimChannel_ACMatrixSwitchType,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AnimChannel_ACMatrixSwitchType,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AnimChannel_ACMatrixSwitchType,
    &Dtool_SequenceMethods_AnimChannel_ACMatrixSwitchType,
    &Dtool_MappingMethods_AnimChannel_ACMatrixSwitchType,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AnimChannel_ACMatrixSwitchType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AnimChannel_ACMatrixSwitchType,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AnimChannel_ACMatrixSwitchType,
    PyType_GenericAlloc,
    Dtool_new_AnimChannel_ACMatrixSwitchType,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimChannel_ACMatrixSwitchType,
  Dtool_UpcastInterface_AnimChannel_ACMatrixSwitchType,
  Dtool_DowncastInterface_AnimChannel_ACMatrixSwitchType,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AnimChannel_ACMatrixSwitchType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AnimChannelBase(nullptr);
    Dtool_AnimChannel_ACMatrixSwitchType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AnimChannelBase);
    Dtool_AnimChannel_ACMatrixSwitchType._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AnimChannel_ACMatrixSwitchType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimChannel_ACMatrixSwitchType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimChannel_ACMatrixSwitchType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimChannel_ACMatrixSwitchType);
  }
}

/**
 * Python method tables for AnimChannel_ACScalarSwitchType (AnimChannel_ACScalarSwitchType)
 */
static PyMethodDef Dtool_Methods_AnimChannel_ACScalarSwitchType[] = {
  {"get_scale", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_scale_112, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_scale_112_comment},
  {"getScale", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_scale_112, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_scale_112_comment},
  {"get_hpr", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_hpr_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_hpr_113_comment},
  {"getHpr", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_hpr_113, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_hpr_113_comment},
  {"get_quat", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_quat_114, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_quat_114_comment},
  {"getQuat", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_quat_114, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_quat_114_comment},
  {"get_pos", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_pos_115, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_pos_115_comment},
  {"getPos", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_pos_115, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_pos_115_comment},
  {"get_shear", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_shear_116, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_shear_116_comment},
  {"getShear", (PyCFunction) &Dtool_AnimChannel_ACScalarSwitchType_get_shear_116, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_shear_116_comment},
  {"get_value_type", &Dtool_AnimChannel_ACScalarSwitchType_get_value_type_117, METH_NOARGS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_value_type_117_comment},
  {"getValueType", &Dtool_AnimChannel_ACScalarSwitchType_get_value_type_117, METH_NOARGS, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_value_type_117_comment},
  {"get_class_type", &Dtool_AnimChannel_ACScalarSwitchType_get_class_type_118, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_class_type_118_comment},
  {"getClassType", &Dtool_AnimChannel_ACScalarSwitchType_get_class_type_118, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannel_ACScalarSwitchType_get_class_type_118_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AnimChannel_ACScalarSwitchType = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimChannel_ACScalarSwitchType = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AnimChannel_ACScalarSwitchType = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AnimChannel_ACScalarSwitchType = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AnimChannel_ACScalarSwitchType = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AnimChannel_ACScalarSwitchType = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AnimChannel_ACScalarSwitchType",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimChannel_ACScalarSwitchType,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AnimChannel_ACScalarSwitchType,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AnimChannel_ACScalarSwitchType,
    &Dtool_SequenceMethods_AnimChannel_ACScalarSwitchType,
    &Dtool_MappingMethods_AnimChannel_ACScalarSwitchType,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AnimChannel_ACScalarSwitchType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AnimChannel_ACScalarSwitchType,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AnimChannel_ACScalarSwitchType,
    PyType_GenericAlloc,
    Dtool_new_AnimChannel_ACScalarSwitchType,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimChannel_ACScalarSwitchType,
  Dtool_UpcastInterface_AnimChannel_ACScalarSwitchType,
  Dtool_DowncastInterface_AnimChannel_ACScalarSwitchType,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AnimChannel_ACScalarSwitchType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AnimChannelBase(nullptr);
    Dtool_AnimChannel_ACScalarSwitchType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AnimChannelBase);
    Dtool_AnimChannel_ACScalarSwitchType._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AnimChannel_ACScalarSwitchType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimChannel_ACScalarSwitchType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimChannel_ACScalarSwitchType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimChannel_ACScalarSwitchType);
  }
}

/**
 * Python method tables for AnimChannelMatrixDynamic (AnimChannelMatrixDynamic)
 */
static PyMethodDef Dtool_Methods_AnimChannelMatrixDynamic[] = {
  {"set_value", &Dtool_AnimChannelMatrixDynamic_set_value_121, METH_O, (const char *)Dtool_AnimChannelMatrixDynamic_set_value_121_comment},
  {"setValue", &Dtool_AnimChannelMatrixDynamic_set_value_121, METH_O, (const char *)Dtool_AnimChannelMatrixDynamic_set_value_121_comment},
  {"set_value_node", &Dtool_AnimChannelMatrixDynamic_set_value_node_122, METH_O, (const char *)Dtool_AnimChannelMatrixDynamic_set_value_node_122_comment},
  {"setValueNode", &Dtool_AnimChannelMatrixDynamic_set_value_node_122, METH_O, (const char *)Dtool_AnimChannelMatrixDynamic_set_value_node_122_comment},
  {"get_value_transform", &Dtool_AnimChannelMatrixDynamic_get_value_transform_123, METH_NOARGS, (const char *)Dtool_AnimChannelMatrixDynamic_get_value_transform_123_comment},
  {"getValueTransform", &Dtool_AnimChannelMatrixDynamic_get_value_transform_123, METH_NOARGS, (const char *)Dtool_AnimChannelMatrixDynamic_get_value_transform_123_comment},
  {"get_value_node", &Dtool_AnimChannelMatrixDynamic_get_value_node_124, METH_NOARGS, (const char *)Dtool_AnimChannelMatrixDynamic_get_value_node_124_comment},
  {"getValueNode", &Dtool_AnimChannelMatrixDynamic_get_value_node_124, METH_NOARGS, (const char *)Dtool_AnimChannelMatrixDynamic_get_value_node_124_comment},
  {"get_class_type", &Dtool_AnimChannelMatrixDynamic_get_class_type_127, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelMatrixDynamic_get_class_type_127_comment},
  {"getClassType", &Dtool_AnimChannelMatrixDynamic_get_class_type_127, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelMatrixDynamic_get_class_type_127_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_AnimChannelMatrixDynamic[] = {
  {(char *)"value_node", &Dtool_AnimChannelMatrixDynamic_value_node_Getter, &Dtool_AnimChannelMatrixDynamic_value_node_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_AnimChannelMatrixDynamic = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimChannelMatrixDynamic = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AnimChannelMatrixDynamic = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AnimChannelMatrixDynamic = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AnimChannelMatrixDynamic = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AnimChannelMatrixDynamic = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AnimChannelMatrixDynamic",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimChannelMatrixDynamic,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AnimChannelMatrixDynamic,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AnimChannelMatrixDynamic,
    &Dtool_SequenceMethods_AnimChannelMatrixDynamic,
    &Dtool_MappingMethods_AnimChannelMatrixDynamic,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AnimChannelMatrixDynamic,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An animation channel that accepts a matrix each frame from some dynamic\n"
    " * input provided by code.\n"
    " *\n"
    " * This object operates in two modes: in explicit mode, the programmer should\n"
    " * call set_value() each frame to indicate the new value; in implicit mode,\n"
    " * the programmer should call set_value_node() to indicate the node whose\n"
    " * transform will be copied to the joint each frame.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AnimChannelMatrixDynamic,
    nullptr, // tp_members
    Dtool_Properties_AnimChannelMatrixDynamic,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AnimChannelMatrixDynamic,
    PyType_GenericAlloc,
    Dtool_new_AnimChannelMatrixDynamic,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimChannelMatrixDynamic,
  Dtool_UpcastInterface_AnimChannelMatrixDynamic,
  Dtool_DowncastInterface_AnimChannelMatrixDynamic,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AnimChannelMatrixDynamic(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AnimChannel_ACMatrixSwitchType(nullptr);
    Dtool_AnimChannelMatrixDynamic._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AnimChannel_ACMatrixSwitchType);
    Dtool_AnimChannelMatrixDynamic._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AnimChannelMatrixDynamic._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimChannelMatrixDynamic) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimChannelMatrixDynamic)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimChannelMatrixDynamic);
  }
}

/**
 * Python method tables for AnimChannelMatrixXfmTable (AnimChannelMatrixXfmTable)
 */
static PyMethodDef Dtool_Methods_AnimChannelMatrixXfmTable[] = {
  {"is_valid_id", &Dtool_AnimChannelMatrixXfmTable_is_valid_id_131, METH_O | METH_STATIC, (const char *)Dtool_AnimChannelMatrixXfmTable_is_valid_id_131_comment},
  {"isValidId", &Dtool_AnimChannelMatrixXfmTable_is_valid_id_131, METH_O | METH_STATIC, (const char *)Dtool_AnimChannelMatrixXfmTable_is_valid_id_131_comment},
  {"set_table", (PyCFunction) &Dtool_AnimChannelMatrixXfmTable_set_table_132, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannelMatrixXfmTable_set_table_132_comment},
  {"setTable", (PyCFunction) &Dtool_AnimChannelMatrixXfmTable_set_table_132, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimChannelMatrixXfmTable_set_table_132_comment},
  {"get_table", &Dtool_AnimChannelMatrixXfmTable_get_table_133, METH_O, (const char *)Dtool_AnimChannelMatrixXfmTable_get_table_133_comment},
  {"getTable", &Dtool_AnimChannelMatrixXfmTable_get_table_133, METH_O, (const char *)Dtool_AnimChannelMatrixXfmTable_get_table_133_comment},
  {"clear_all_tables", &Dtool_AnimChannelMatrixXfmTable_clear_all_tables_134, METH_NOARGS, (const char *)Dtool_AnimChannelMatrixXfmTable_clear_all_tables_134_comment},
  {"clearAllTables", &Dtool_AnimChannelMatrixXfmTable_clear_all_tables_134, METH_NOARGS, (const char *)Dtool_AnimChannelMatrixXfmTable_clear_all_tables_134_comment},
  {"has_table", &Dtool_AnimChannelMatrixXfmTable_has_table_135, METH_O, (const char *)Dtool_AnimChannelMatrixXfmTable_has_table_135_comment},
  {"hasTable", &Dtool_AnimChannelMatrixXfmTable_has_table_135, METH_O, (const char *)Dtool_AnimChannelMatrixXfmTable_has_table_135_comment},
  {"clear_table", &Dtool_AnimChannelMatrixXfmTable_clear_table_136, METH_O, (const char *)Dtool_AnimChannelMatrixXfmTable_clear_table_136_comment},
  {"clearTable", &Dtool_AnimChannelMatrixXfmTable_clear_table_136, METH_O, (const char *)Dtool_AnimChannelMatrixXfmTable_clear_table_136_comment},
  {"get_class_type", &Dtool_AnimChannelMatrixXfmTable_get_class_type_141, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelMatrixXfmTable_get_class_type_141_comment},
  {"getClassType", &Dtool_AnimChannelMatrixXfmTable_get_class_type_141, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelMatrixXfmTable_get_class_type_141_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_AnimChannelMatrixXfmTable[] = {
  {(char *)"tables", &Dtool_AnimChannelMatrixXfmTable_tables_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_AnimChannelMatrixXfmTable = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimChannelMatrixXfmTable = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AnimChannelMatrixXfmTable = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AnimChannelMatrixXfmTable = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AnimChannelMatrixXfmTable = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AnimChannelMatrixXfmTable = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AnimChannelMatrixXfmTable",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimChannelMatrixXfmTable,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AnimChannelMatrixXfmTable,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AnimChannelMatrixXfmTable,
    &Dtool_SequenceMethods_AnimChannelMatrixXfmTable,
    &Dtool_MappingMethods_AnimChannelMatrixXfmTable,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AnimChannelMatrixXfmTable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An animation channel that issues a matrix each frame, read from a table\n"
    " * such as might have been read from an egg file.  The table actually consists\n"
    " * of nine sub-tables, each representing one component of the transform:\n"
    " * scale, rotate, translate.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AnimChannelMatrixXfmTable,
    nullptr, // tp_members
    Dtool_Properties_AnimChannelMatrixXfmTable,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AnimChannelMatrixXfmTable,
    PyType_GenericAlloc,
    Dtool_new_AnimChannelMatrixXfmTable,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimChannelMatrixXfmTable,
  Dtool_UpcastInterface_AnimChannelMatrixXfmTable,
  Dtool_DowncastInterface_AnimChannelMatrixXfmTable,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AnimChannelMatrixXfmTable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AnimChannel_ACMatrixSwitchType(nullptr);
    Dtool_AnimChannelMatrixXfmTable._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AnimChannel_ACMatrixSwitchType);
    Dtool_AnimChannelMatrixXfmTable._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AnimChannelMatrixXfmTable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimChannelMatrixXfmTable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimChannelMatrixXfmTable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimChannelMatrixXfmTable);
  }
}

/**
 * Python method tables for AnimChannelScalarDynamic (AnimChannelScalarDynamic)
 */
static PyMethodDef Dtool_Methods_AnimChannelScalarDynamic[] = {
  {"set_value", &Dtool_AnimChannelScalarDynamic_set_value_143, METH_O, (const char *)Dtool_AnimChannelScalarDynamic_set_value_143_comment},
  {"setValue", &Dtool_AnimChannelScalarDynamic_set_value_143, METH_O, (const char *)Dtool_AnimChannelScalarDynamic_set_value_143_comment},
  {"set_value_node", &Dtool_AnimChannelScalarDynamic_set_value_node_144, METH_O, (const char *)Dtool_AnimChannelScalarDynamic_set_value_node_144_comment},
  {"setValueNode", &Dtool_AnimChannelScalarDynamic_set_value_node_144, METH_O, (const char *)Dtool_AnimChannelScalarDynamic_set_value_node_144_comment},
  {"get_class_type", &Dtool_AnimChannelScalarDynamic_get_class_type_151, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelScalarDynamic_get_class_type_151_comment},
  {"getClassType", &Dtool_AnimChannelScalarDynamic_get_class_type_151, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelScalarDynamic_get_class_type_151_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_AnimChannelScalarDynamic[] = {
  {(char *)"value", &Dtool_AnimChannelScalarDynamic_value_Getter, &Dtool_AnimChannelScalarDynamic_value_Setter, nullptr, nullptr},
  {(char *)"value_node", &Dtool_AnimChannelScalarDynamic_value_node_Getter, &Dtool_AnimChannelScalarDynamic_value_node_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_AnimChannelScalarDynamic = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimChannelScalarDynamic = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AnimChannelScalarDynamic = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AnimChannelScalarDynamic = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AnimChannelScalarDynamic = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AnimChannelScalarDynamic = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AnimChannelScalarDynamic",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimChannelScalarDynamic,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AnimChannelScalarDynamic,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AnimChannelScalarDynamic,
    &Dtool_SequenceMethods_AnimChannelScalarDynamic,
    &Dtool_MappingMethods_AnimChannelScalarDynamic,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AnimChannelScalarDynamic,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An animation channel that accepts a scalar each frame from some dynamic\n"
    " * input provided by code.\n"
    " *\n"
    " * This object operates in two modes: in explicit mode, the programmer should\n"
    " * call set_value() each frame to indicate the new value; in implicit mode,\n"
    " * the programmer should call set_value_node() to indicate the node whose X\n"
    " * component will be copied to the scalar each frame.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AnimChannelScalarDynamic,
    nullptr, // tp_members
    Dtool_Properties_AnimChannelScalarDynamic,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AnimChannelScalarDynamic,
    PyType_GenericAlloc,
    Dtool_new_AnimChannelScalarDynamic,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimChannelScalarDynamic,
  Dtool_UpcastInterface_AnimChannelScalarDynamic,
  Dtool_DowncastInterface_AnimChannelScalarDynamic,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AnimChannelScalarDynamic(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AnimChannel_ACScalarSwitchType(nullptr);
    Dtool_AnimChannelScalarDynamic._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AnimChannel_ACScalarSwitchType);
    Dtool_AnimChannelScalarDynamic._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AnimChannelScalarDynamic._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimChannelScalarDynamic) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimChannelScalarDynamic)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimChannelScalarDynamic);
  }
}

/**
 * Python method tables for AnimChannelScalarTable (AnimChannelScalarTable)
 */
static PyMethodDef Dtool_Methods_AnimChannelScalarTable[] = {
  {"set_table", &Dtool_AnimChannelScalarTable_set_table_155, METH_O, (const char *)Dtool_AnimChannelScalarTable_set_table_155_comment},
  {"setTable", &Dtool_AnimChannelScalarTable_set_table_155, METH_O, (const char *)Dtool_AnimChannelScalarTable_set_table_155_comment},
  {"get_table", &Dtool_AnimChannelScalarTable_get_table_156, METH_NOARGS, (const char *)Dtool_AnimChannelScalarTable_get_table_156_comment},
  {"getTable", &Dtool_AnimChannelScalarTable_get_table_156, METH_NOARGS, (const char *)Dtool_AnimChannelScalarTable_get_table_156_comment},
  {"has_table", &Dtool_AnimChannelScalarTable_has_table_157, METH_NOARGS, (const char *)Dtool_AnimChannelScalarTable_has_table_157_comment},
  {"hasTable", &Dtool_AnimChannelScalarTable_has_table_157, METH_NOARGS, (const char *)Dtool_AnimChannelScalarTable_has_table_157_comment},
  {"clear_table", &Dtool_AnimChannelScalarTable_clear_table_158, METH_NOARGS, (const char *)Dtool_AnimChannelScalarTable_clear_table_158_comment},
  {"clearTable", &Dtool_AnimChannelScalarTable_clear_table_158, METH_NOARGS, (const char *)Dtool_AnimChannelScalarTable_clear_table_158_comment},
  {"get_class_type", &Dtool_AnimChannelScalarTable_get_class_type_160, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelScalarTable_get_class_type_160_comment},
  {"getClassType", &Dtool_AnimChannelScalarTable_get_class_type_160, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimChannelScalarTable_get_class_type_160_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_AnimChannelScalarTable[] = {
  {(char *)"table", &Dtool_AnimChannelScalarTable_table_Getter, &Dtool_AnimChannelScalarTable_table_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_AnimChannelScalarTable = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimChannelScalarTable = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AnimChannelScalarTable = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AnimChannelScalarTable = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AnimChannelScalarTable = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AnimChannelScalarTable = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AnimChannelScalarTable",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimChannelScalarTable,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AnimChannelScalarTable,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AnimChannelScalarTable,
    &Dtool_SequenceMethods_AnimChannelScalarTable,
    &Dtool_MappingMethods_AnimChannelScalarTable,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AnimChannelScalarTable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An animation channel that issues a scalar each frame, read from a table\n"
    " * such as might have been read from an egg file.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AnimChannelScalarTable,
    nullptr, // tp_members
    Dtool_Properties_AnimChannelScalarTable,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AnimChannelScalarTable,
    PyType_GenericAlloc,
    Dtool_new_AnimChannelScalarTable,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimChannelScalarTable,
  Dtool_UpcastInterface_AnimChannelScalarTable,
  Dtool_DowncastInterface_AnimChannelScalarTable,
  (CoerceFunction)Dtool_ConstCoerce_AnimChannelScalarTable,
  (CoerceFunction)Dtool_Coerce_AnimChannelScalarTable,
};

static void Dtool_PyModuleClassInit_AnimChannelScalarTable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AnimChannel_ACScalarSwitchType(nullptr);
    Dtool_AnimChannelScalarTable._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AnimChannel_ACScalarSwitchType);
    Dtool_AnimChannelScalarTable._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AnimChannelScalarTable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimChannelScalarTable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimChannelScalarTable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimChannelScalarTable);
  }
}

/**
 * Python method tables for AnimControlCollection (AnimControlCollection)
 */
static PyMethodDef Dtool_Methods_AnimControlCollection[] = {
  {"store_anim", (PyCFunction) &Dtool_AnimControlCollection_store_anim_165, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_store_anim_165_comment},
  {"storeAnim", (PyCFunction) &Dtool_AnimControlCollection_store_anim_165, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_store_anim_165_comment},
  {"find_anim", &Dtool_AnimControlCollection_find_anim_166, METH_O, (const char *)Dtool_AnimControlCollection_find_anim_166_comment},
  {"findAnim", &Dtool_AnimControlCollection_find_anim_166, METH_O, (const char *)Dtool_AnimControlCollection_find_anim_166_comment},
  {"unbind_anim", &Dtool_AnimControlCollection_unbind_anim_167, METH_O, (const char *)Dtool_AnimControlCollection_unbind_anim_167_comment},
  {"unbindAnim", &Dtool_AnimControlCollection_unbind_anim_167, METH_O, (const char *)Dtool_AnimControlCollection_unbind_anim_167_comment},
  {"get_num_anims", &Dtool_AnimControlCollection_get_num_anims_168, METH_NOARGS, (const char *)Dtool_AnimControlCollection_get_num_anims_168_comment},
  {"getNumAnims", &Dtool_AnimControlCollection_get_num_anims_168, METH_NOARGS, (const char *)Dtool_AnimControlCollection_get_num_anims_168_comment},
  {"get_anim", &Dtool_AnimControlCollection_get_anim_169, METH_O, (const char *)Dtool_AnimControlCollection_get_anim_169_comment},
  {"getAnim", &Dtool_AnimControlCollection_get_anim_169, METH_O, (const char *)Dtool_AnimControlCollection_get_anim_169_comment},
  {"get_anim_name", &Dtool_AnimControlCollection_get_anim_name_170, METH_O, (const char *)Dtool_AnimControlCollection_get_anim_name_170_comment},
  {"getAnimName", &Dtool_AnimControlCollection_get_anim_name_170, METH_O, (const char *)Dtool_AnimControlCollection_get_anim_name_170_comment},
  {"clear_anims", &Dtool_AnimControlCollection_clear_anims_173, METH_NOARGS, (const char *)Dtool_AnimControlCollection_clear_anims_173_comment},
  {"clearAnims", &Dtool_AnimControlCollection_clear_anims_173, METH_NOARGS, (const char *)Dtool_AnimControlCollection_clear_anims_173_comment},
  {"play", (PyCFunction) &Dtool_AnimControlCollection_play_174, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_play_174_comment},
  {"loop", (PyCFunction) &Dtool_AnimControlCollection_loop_175, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_loop_175_comment},
  {"stop", &Dtool_AnimControlCollection_stop_176, METH_O, (const char *)Dtool_AnimControlCollection_stop_176_comment},
  {"pose", (PyCFunction) &Dtool_AnimControlCollection_pose_177, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_pose_177_comment},
  {"play_all", (PyCFunction) &Dtool_AnimControlCollection_play_all_178, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_play_all_178_comment},
  {"playAll", (PyCFunction) &Dtool_AnimControlCollection_play_all_178, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_play_all_178_comment},
  {"loop_all", (PyCFunction) &Dtool_AnimControlCollection_loop_all_179, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_loop_all_179_comment},
  {"loopAll", (PyCFunction) &Dtool_AnimControlCollection_loop_all_179, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimControlCollection_loop_all_179_comment},
  {"stop_all", &Dtool_AnimControlCollection_stop_all_180, METH_NOARGS, (const char *)Dtool_AnimControlCollection_stop_all_180_comment},
  {"stopAll", &Dtool_AnimControlCollection_stop_all_180, METH_NOARGS, (const char *)Dtool_AnimControlCollection_stop_all_180_comment},
  {"pose_all", &Dtool_AnimControlCollection_pose_all_181, METH_O, (const char *)Dtool_AnimControlCollection_pose_all_181_comment},
  {"poseAll", &Dtool_AnimControlCollection_pose_all_181, METH_O, (const char *)Dtool_AnimControlCollection_pose_all_181_comment},
  {"get_frame", &Dtool_AnimControlCollection_get_frame_182, METH_VARARGS, (const char *)Dtool_AnimControlCollection_get_frame_182_comment},
  {"getFrame", &Dtool_AnimControlCollection_get_frame_182, METH_VARARGS, (const char *)Dtool_AnimControlCollection_get_frame_182_comment},
  {"get_num_frames", &Dtool_AnimControlCollection_get_num_frames_183, METH_VARARGS, (const char *)Dtool_AnimControlCollection_get_num_frames_183_comment},
  {"getNumFrames", &Dtool_AnimControlCollection_get_num_frames_183, METH_VARARGS, (const char *)Dtool_AnimControlCollection_get_num_frames_183_comment},
  {"is_playing", &Dtool_AnimControlCollection_is_playing_184, METH_VARARGS, (const char *)Dtool_AnimControlCollection_is_playing_184_comment},
  {"isPlaying", &Dtool_AnimControlCollection_is_playing_184, METH_VARARGS, (const char *)Dtool_AnimControlCollection_is_playing_184_comment},
  {"which_anim_playing", &Dtool_AnimControlCollection_which_anim_playing_185, METH_NOARGS, (const char *)Dtool_AnimControlCollection_which_anim_playing_185_comment},
  {"whichAnimPlaying", &Dtool_AnimControlCollection_which_anim_playing_185, METH_NOARGS, (const char *)Dtool_AnimControlCollection_which_anim_playing_185_comment},
  {"output", &Dtool_AnimControlCollection_output_186, METH_O, (const char *)Dtool_AnimControlCollection_output_186_comment},
  {"write", &Dtool_AnimControlCollection_write_187, METH_O, (const char *)Dtool_AnimControlCollection_write_187_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_anims", (PyCFunction) &MakeSeq_AnimControlCollection_get_anims, METH_NOARGS, nullptr},
  { "getAnims", (PyCFunction) &MakeSeq_AnimControlCollection_get_anims, METH_NOARGS, nullptr},
  {"get_anim_names", (PyCFunction) &MakeSeq_AnimControlCollection_get_anim_names, METH_NOARGS, nullptr},
  { "getAnimNames", (PyCFunction) &MakeSeq_AnimControlCollection_get_anim_names, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     AnimControlCollection
//////////////////
static PyObject *Dtool_Repr_AnimControlCollection(PyObject *self) {
  AnimControlCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AnimControlCollection
//////////////////
static PyObject *Dtool_Str_AnimControlCollection(PyObject *self) {
  AnimControlCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimControlCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AnimControlCollection = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_AnimControlCollection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AnimControlCollection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimControlCollection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_AnimControlCollection,
    &Dtool_NumberMethods_AnimControlCollection,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_AnimControlCollection,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a named collection of AnimControl pointers.  An AnimControl may be\n"
    " * added to the collection by name.  While an AnimControl is associated, its\n"
    " * reference count is maintained; associating a new AnimControl with the same\n"
    " * name will decrement the previous control's reference count (and possibly\n"
    " * delete it, unbinding its animation).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AnimControlCollection,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AnimControlCollection,
    PyType_GenericAlloc,
    Dtool_new_AnimControlCollection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimControlCollection,
  Dtool_UpcastInterface_AnimControlCollection,
  Dtool_DowncastInterface_AnimControlCollection,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AnimControlCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_AnimControlCollection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AnimControlCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimControlCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimControlCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimControlCollection);
  }
}

/**
 * Python method tables for AnimPreloadTable (AnimPreloadTable)
 */
static PyMethodDef Dtool_Methods_AnimPreloadTable[] = {
  {"get_num_anims", &Dtool_AnimPreloadTable_get_num_anims_191, METH_NOARGS, (const char *)Dtool_AnimPreloadTable_get_num_anims_191_comment},
  {"getNumAnims", &Dtool_AnimPreloadTable_get_num_anims_191, METH_NOARGS, (const char *)Dtool_AnimPreloadTable_get_num_anims_191_comment},
  {"find_anim", &Dtool_AnimPreloadTable_find_anim_192, METH_O, (const char *)Dtool_AnimPreloadTable_find_anim_192_comment},
  {"findAnim", &Dtool_AnimPreloadTable_find_anim_192, METH_O, (const char *)Dtool_AnimPreloadTable_find_anim_192_comment},
  {"get_basename", &Dtool_AnimPreloadTable_get_basename_193, METH_O, (const char *)Dtool_AnimPreloadTable_get_basename_193_comment},
  {"getBasename", &Dtool_AnimPreloadTable_get_basename_193, METH_O, (const char *)Dtool_AnimPreloadTable_get_basename_193_comment},
  {"get_base_frame_rate", &Dtool_AnimPreloadTable_get_base_frame_rate_194, METH_O, (const char *)Dtool_AnimPreloadTable_get_base_frame_rate_194_comment},
  {"getBaseFrameRate", &Dtool_AnimPreloadTable_get_base_frame_rate_194, METH_O, (const char *)Dtool_AnimPreloadTable_get_base_frame_rate_194_comment},
  {"get_num_frames", &Dtool_AnimPreloadTable_get_num_frames_195, METH_O, (const char *)Dtool_AnimPreloadTable_get_num_frames_195_comment},
  {"getNumFrames", &Dtool_AnimPreloadTable_get_num_frames_195, METH_O, (const char *)Dtool_AnimPreloadTable_get_num_frames_195_comment},
  {"clear_anims", &Dtool_AnimPreloadTable_clear_anims_196, METH_NOARGS, (const char *)Dtool_AnimPreloadTable_clear_anims_196_comment},
  {"clearAnims", &Dtool_AnimPreloadTable_clear_anims_196, METH_NOARGS, (const char *)Dtool_AnimPreloadTable_clear_anims_196_comment},
  {"remove_anim", &Dtool_AnimPreloadTable_remove_anim_197, METH_O, (const char *)Dtool_AnimPreloadTable_remove_anim_197_comment},
  {"removeAnim", &Dtool_AnimPreloadTable_remove_anim_197, METH_O, (const char *)Dtool_AnimPreloadTable_remove_anim_197_comment},
  {"add_anim", (PyCFunction) &Dtool_AnimPreloadTable_add_anim_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimPreloadTable_add_anim_198_comment},
  {"addAnim", (PyCFunction) &Dtool_AnimPreloadTable_add_anim_198, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimPreloadTable_add_anim_198_comment},
  {"add_anims_from", &Dtool_AnimPreloadTable_add_anims_from_199, METH_O, (const char *)Dtool_AnimPreloadTable_add_anims_from_199_comment},
  {"addAnimsFrom", &Dtool_AnimPreloadTable_add_anims_from_199, METH_O, (const char *)Dtool_AnimPreloadTable_add_anims_from_199_comment},
  {"output", &Dtool_AnimPreloadTable_output_200, METH_O, (const char *)Dtool_AnimPreloadTable_output_200_comment},
  {"write", (PyCFunction) &Dtool_AnimPreloadTable_write_201, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimPreloadTable_write_201_comment},
  {"get_class_type", &Dtool_AnimPreloadTable_get_class_type_202, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimPreloadTable_get_class_type_202_comment},
  {"getClassType", &Dtool_AnimPreloadTable_get_class_type_202, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimPreloadTable_get_class_type_202_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     AnimPreloadTable
//////////////////
static PyObject *Dtool_Repr_AnimPreloadTable(PyObject *self) {
  AnimPreloadTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimPreloadTable, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     AnimPreloadTable
//////////////////
static PyObject *Dtool_Str_AnimPreloadTable(PyObject *self) {
  AnimPreloadTable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimPreloadTable, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os, 0);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_AnimPreloadTable = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AnimPreloadTable = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AnimPreloadTable = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AnimPreloadTable = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AnimPreloadTable = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AnimPreloadTable = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AnimPreloadTable",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimPreloadTable,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AnimPreloadTable,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_AnimPreloadTable,
    &Dtool_NumberMethods_AnimPreloadTable,
    &Dtool_SequenceMethods_AnimPreloadTable,
    &Dtool_MappingMethods_AnimPreloadTable,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_AnimPreloadTable,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AnimPreloadTable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This table records data about a list of animations for a particular model,\n"
    " * such as number of frames and frame rate.  It's used for implementating\n"
    " * asynchronous binding.\n"
    " *\n"
    " * This table is normally built by an offline tool, such as egg-optchar.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AnimPreloadTable,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AnimPreloadTable,
    PyType_GenericAlloc,
    Dtool_new_AnimPreloadTable,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimPreloadTable,
  Dtool_UpcastInterface_AnimPreloadTable,
  Dtool_DowncastInterface_AnimPreloadTable,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AnimPreloadTable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CopyOnWriteObject != nullptr);
    assert(Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_CopyOnWriteObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_AnimPreloadTable._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_CopyOnWriteObject);
    Dtool_AnimPreloadTable._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AnimPreloadTable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimPreloadTable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimPreloadTable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimPreloadTable);
  }
}

/**
 * Python method tables for PartSubset (PartSubset)
 */
static PyMethodDef Dtool_Methods_PartSubset[] = {
  {"assign", &Dtool_PartSubset_operator_206, METH_O, (const char *)Dtool_PartSubset_operator_206_comment},
  {"add_include_joint", &Dtool_PartSubset_add_include_joint_207, METH_O, (const char *)Dtool_PartSubset_add_include_joint_207_comment},
  {"addIncludeJoint", &Dtool_PartSubset_add_include_joint_207, METH_O, (const char *)Dtool_PartSubset_add_include_joint_207_comment},
  {"add_exclude_joint", &Dtool_PartSubset_add_exclude_joint_208, METH_O, (const char *)Dtool_PartSubset_add_exclude_joint_208_comment},
  {"addExcludeJoint", &Dtool_PartSubset_add_exclude_joint_208, METH_O, (const char *)Dtool_PartSubset_add_exclude_joint_208_comment},
  {"append", &Dtool_PartSubset_append_209, METH_O, (const char *)Dtool_PartSubset_append_209_comment},
  {"output", &Dtool_PartSubset_output_210, METH_O, (const char *)Dtool_PartSubset_output_210_comment},
  {"is_include_empty", &Dtool_PartSubset_is_include_empty_211, METH_NOARGS, (const char *)Dtool_PartSubset_is_include_empty_211_comment},
  {"isIncludeEmpty", &Dtool_PartSubset_is_include_empty_211, METH_NOARGS, (const char *)Dtool_PartSubset_is_include_empty_211_comment},
  {"matches_include", &Dtool_PartSubset_matches_include_212, METH_O, (const char *)Dtool_PartSubset_matches_include_212_comment},
  {"matchesInclude", &Dtool_PartSubset_matches_include_212, METH_O, (const char *)Dtool_PartSubset_matches_include_212_comment},
  {"matches_exclude", &Dtool_PartSubset_matches_exclude_213, METH_O, (const char *)Dtool_PartSubset_matches_exclude_213_comment},
  {"matchesExclude", &Dtool_PartSubset_matches_exclude_213, METH_O, (const char *)Dtool_PartSubset_matches_exclude_213_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PartSubset
//////////////////
static PyObject *Dtool_Repr_PartSubset(PyObject *self) {
  PartSubset *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartSubset, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PartSubset = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_PartSubset = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PartSubset",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PartSubset,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PartSubset,
    &Dtool_NumberMethods_PartSubset,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PartSubset,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is used to define a subset of part names to apply to the\n"
    " * PartBundle::bind_anim() operation.  Only those part names within the subset\n"
    " * will be included in the bind.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PartSubset,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PartSubset,
    PyType_GenericAlloc,
    Dtool_new_PartSubset,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PartSubset,
  Dtool_UpcastInterface_PartSubset,
  Dtool_DowncastInterface_PartSubset,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PartSubset(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PartSubset._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PartSubset._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PartSubset) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PartSubset)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PartSubset);
  }
}

/**
 * Python method tables for BindAnimRequest (BindAnimRequest)
 */
static PyMethodDef Dtool_Methods_BindAnimRequest[] = {
  {"get_class_type", &Dtool_BindAnimRequest_get_class_type_218, METH_NOARGS | METH_STATIC, (const char *)Dtool_BindAnimRequest_get_class_type_218_comment},
  {"getClassType", &Dtool_BindAnimRequest_get_class_type_218, METH_NOARGS | METH_STATIC, (const char *)Dtool_BindAnimRequest_get_class_type_218_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BindAnimRequest = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BindAnimRequest = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BindAnimRequest = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BindAnimRequest = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BindAnimRequest = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BindAnimRequest = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BindAnimRequest",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BindAnimRequest,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BindAnimRequest,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BindAnimRequest,
    &Dtool_SequenceMethods_BindAnimRequest,
    &Dtool_MappingMethods_BindAnimRequest,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BindAnimRequest,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class object manages an asynchronous load-and-bind animation request,\n"
    " * as issued through PartBundle::load_bind_anim().\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BindAnimRequest,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BindAnimRequest,
    PyType_GenericAlloc,
    Dtool_new_BindAnimRequest,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BindAnimRequest,
  Dtool_UpcastInterface_BindAnimRequest,
  Dtool_DowncastInterface_BindAnimRequest,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BindAnimRequest(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ModelLoadRequest != nullptr);
    assert(Dtool_Ptr_ModelLoadRequest->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ModelLoadRequest->_Dtool_ModuleClassInit(nullptr);
    Dtool_BindAnimRequest._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ModelLoadRequest);
    Dtool_BindAnimRequest._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BindAnimRequest._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BindAnimRequest) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BindAnimRequest)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BindAnimRequest);
  }
}

/**
 * Python method tables for PartBundle (PartBundle)
 */
static PyMethodDef Dtool_Methods_PartBundle[] = {
  {"get_anim_preload", &Dtool_PartBundle_get_anim_preload_222, METH_NOARGS, (const char *)Dtool_PartBundle_get_anim_preload_222_comment},
  {"getAnimPreload", &Dtool_PartBundle_get_anim_preload_222, METH_NOARGS, (const char *)Dtool_PartBundle_get_anim_preload_222_comment},
  {"modify_anim_preload", &Dtool_PartBundle_modify_anim_preload_223, METH_NOARGS, (const char *)Dtool_PartBundle_modify_anim_preload_223_comment},
  {"modifyAnimPreload", &Dtool_PartBundle_modify_anim_preload_223, METH_NOARGS, (const char *)Dtool_PartBundle_modify_anim_preload_223_comment},
  {"set_anim_preload", &Dtool_PartBundle_set_anim_preload_224, METH_O, (const char *)Dtool_PartBundle_set_anim_preload_224_comment},
  {"setAnimPreload", &Dtool_PartBundle_set_anim_preload_224, METH_O, (const char *)Dtool_PartBundle_set_anim_preload_224_comment},
  {"clear_anim_preload", &Dtool_PartBundle_clear_anim_preload_225, METH_NOARGS, (const char *)Dtool_PartBundle_clear_anim_preload_225_comment},
  {"clearAnimPreload", &Dtool_PartBundle_clear_anim_preload_225, METH_NOARGS, (const char *)Dtool_PartBundle_clear_anim_preload_225_comment},
  {"merge_anim_preloads", &Dtool_PartBundle_merge_anim_preloads_226, METH_O, (const char *)Dtool_PartBundle_merge_anim_preloads_226_comment},
  {"mergeAnimPreloads", &Dtool_PartBundle_merge_anim_preloads_226, METH_O, (const char *)Dtool_PartBundle_merge_anim_preloads_226_comment},
  {"set_blend_type", &Dtool_PartBundle_set_blend_type_228, METH_O, (const char *)Dtool_PartBundle_set_blend_type_228_comment},
  {"setBlendType", &Dtool_PartBundle_set_blend_type_228, METH_O, (const char *)Dtool_PartBundle_set_blend_type_228_comment},
  {"get_blend_type", &Dtool_PartBundle_get_blend_type_229, METH_NOARGS, (const char *)Dtool_PartBundle_get_blend_type_229_comment},
  {"getBlendType", &Dtool_PartBundle_get_blend_type_229, METH_NOARGS, (const char *)Dtool_PartBundle_get_blend_type_229_comment},
  {"set_anim_blend_flag", &Dtool_PartBundle_set_anim_blend_flag_230, METH_O, (const char *)Dtool_PartBundle_set_anim_blend_flag_230_comment},
  {"setAnimBlendFlag", &Dtool_PartBundle_set_anim_blend_flag_230, METH_O, (const char *)Dtool_PartBundle_set_anim_blend_flag_230_comment},
  {"get_anim_blend_flag", &Dtool_PartBundle_get_anim_blend_flag_231, METH_NOARGS, (const char *)Dtool_PartBundle_get_anim_blend_flag_231_comment},
  {"getAnimBlendFlag", &Dtool_PartBundle_get_anim_blend_flag_231, METH_NOARGS, (const char *)Dtool_PartBundle_get_anim_blend_flag_231_comment},
  {"set_frame_blend_flag", &Dtool_PartBundle_set_frame_blend_flag_232, METH_O, (const char *)Dtool_PartBundle_set_frame_blend_flag_232_comment},
  {"setFrameBlendFlag", &Dtool_PartBundle_set_frame_blend_flag_232, METH_O, (const char *)Dtool_PartBundle_set_frame_blend_flag_232_comment},
  {"get_frame_blend_flag", &Dtool_PartBundle_get_frame_blend_flag_233, METH_NOARGS, (const char *)Dtool_PartBundle_get_frame_blend_flag_233_comment},
  {"getFrameBlendFlag", &Dtool_PartBundle_get_frame_blend_flag_233, METH_NOARGS, (const char *)Dtool_PartBundle_get_frame_blend_flag_233_comment},
  {"set_root_xform", &Dtool_PartBundle_set_root_xform_234, METH_O, (const char *)Dtool_PartBundle_set_root_xform_234_comment},
  {"setRootXform", &Dtool_PartBundle_set_root_xform_234, METH_O, (const char *)Dtool_PartBundle_set_root_xform_234_comment},
  {"xform", &Dtool_PartBundle_xform_235, METH_O, (const char *)Dtool_PartBundle_xform_235_comment},
  {"get_root_xform", &Dtool_PartBundle_get_root_xform_236, METH_NOARGS, (const char *)Dtool_PartBundle_get_root_xform_236_comment},
  {"getRootXform", &Dtool_PartBundle_get_root_xform_236, METH_NOARGS, (const char *)Dtool_PartBundle_get_root_xform_236_comment},
  {"apply_transform", &Dtool_PartBundle_apply_transform_237, METH_O, (const char *)Dtool_PartBundle_apply_transform_237_comment},
  {"applyTransform", &Dtool_PartBundle_apply_transform_237, METH_O, (const char *)Dtool_PartBundle_apply_transform_237_comment},
  {"get_num_nodes", &Dtool_PartBundle_get_num_nodes_238, METH_NOARGS, (const char *)Dtool_PartBundle_get_num_nodes_238_comment},
  {"getNumNodes", &Dtool_PartBundle_get_num_nodes_238, METH_NOARGS, (const char *)Dtool_PartBundle_get_num_nodes_238_comment},
  {"get_node", &Dtool_PartBundle_get_node_239, METH_O, (const char *)Dtool_PartBundle_get_node_239_comment},
  {"getNode", &Dtool_PartBundle_get_node_239, METH_O, (const char *)Dtool_PartBundle_get_node_239_comment},
  {"clear_control_effects", &Dtool_PartBundle_clear_control_effects_267, METH_NOARGS, (const char *)Dtool_PartBundle_clear_control_effects_267_comment},
  {"clearControlEffects", &Dtool_PartBundle_clear_control_effects_267, METH_NOARGS, (const char *)Dtool_PartBundle_clear_control_effects_267_comment},
  {"set_control_effect", (PyCFunction) &Dtool_PartBundle_set_control_effect_268, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_set_control_effect_268_comment},
  {"setControlEffect", (PyCFunction) &Dtool_PartBundle_set_control_effect_268, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_set_control_effect_268_comment},
  {"get_control_effect", &Dtool_PartBundle_get_control_effect_269, METH_O, (const char *)Dtool_PartBundle_get_control_effect_269_comment},
  {"getControlEffect", &Dtool_PartBundle_get_control_effect_269, METH_O, (const char *)Dtool_PartBundle_get_control_effect_269_comment},
  {"output", &Dtool_PartBundle_output_270, METH_O, (const char *)Dtool_PartBundle_output_270_comment},
  {"bind_anim", (PyCFunction) &Dtool_PartBundle_bind_anim_271, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_bind_anim_271_comment},
  {"bindAnim", (PyCFunction) &Dtool_PartBundle_bind_anim_271, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_bind_anim_271_comment},
  {"load_bind_anim", (PyCFunction) &Dtool_PartBundle_load_bind_anim_272, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_load_bind_anim_272_comment},
  {"loadBindAnim", (PyCFunction) &Dtool_PartBundle_load_bind_anim_272, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_load_bind_anim_272_comment},
  {"wait_pending", &Dtool_PartBundle_wait_pending_273, METH_NOARGS, (const char *)Dtool_PartBundle_wait_pending_273_comment},
  {"waitPending", &Dtool_PartBundle_wait_pending_273, METH_NOARGS, (const char *)Dtool_PartBundle_wait_pending_273_comment},
  {"freeze_joint", (PyCFunction) &Dtool_PartBundle_freeze_joint_274, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_freeze_joint_274_comment},
  {"freezeJoint", (PyCFunction) &Dtool_PartBundle_freeze_joint_274, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_freeze_joint_274_comment},
  {"control_joint", (PyCFunction) &Dtool_PartBundle_control_joint_275, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_control_joint_275_comment},
  {"controlJoint", (PyCFunction) &Dtool_PartBundle_control_joint_275, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PartBundle_control_joint_275_comment},
  {"release_joint", &Dtool_PartBundle_release_joint_276, METH_O, (const char *)Dtool_PartBundle_release_joint_276_comment},
  {"releaseJoint", &Dtool_PartBundle_release_joint_276, METH_O, (const char *)Dtool_PartBundle_release_joint_276_comment},
  {"update", &Dtool_PartBundle_update_277, METH_NOARGS, (const char *)Dtool_PartBundle_update_277_comment},
  {"force_update", &Dtool_PartBundle_force_update_278, METH_NOARGS, (const char *)Dtool_PartBundle_force_update_278_comment},
  {"forceUpdate", &Dtool_PartBundle_force_update_278, METH_NOARGS, (const char *)Dtool_PartBundle_force_update_278_comment},
  {"get_class_type", &Dtool_PartBundle_get_class_type_279, METH_NOARGS | METH_STATIC, (const char *)Dtool_PartBundle_get_class_type_279_comment},
  {"getClassType", &Dtool_PartBundle_get_class_type_279, METH_NOARGS | METH_STATIC, (const char *)Dtool_PartBundle_get_class_type_279_comment},
  {"get_nodes", (PyCFunction) &MakeSeq_PartBundle_get_nodes, METH_NOARGS, nullptr},
  { "getNodes", (PyCFunction) &MakeSeq_PartBundle_get_nodes, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PartBundle
//////////////////
static PyObject *Dtool_Repr_PartBundle(PyObject *self) {
  PartBundle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PartBundle, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_PartBundle[] = {
  {(char *)"blend_type", &Dtool_PartBundle_blend_type_Getter, &Dtool_PartBundle_blend_type_Setter, nullptr, nullptr},
  {(char *)"anim_blend_flag", &Dtool_PartBundle_anim_blend_flag_Getter, &Dtool_PartBundle_anim_blend_flag_Setter, nullptr, nullptr},
  {(char *)"frame_blend_flag", &Dtool_PartBundle_frame_blend_flag_Getter, &Dtool_PartBundle_frame_blend_flag_Setter, nullptr, nullptr},
  {(char *)"root_xform", &Dtool_PartBundle_root_xform_Getter, &Dtool_PartBundle_root_xform_Setter, nullptr, nullptr},
  {(char *)"nodes", &Dtool_PartBundle_nodes_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PartBundle = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PartBundle = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PartBundle = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PartBundle = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PartBundle = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PartBundle = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PartBundle",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PartBundle,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PartBundle,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PartBundle,
    &Dtool_NumberMethods_PartBundle,
    &Dtool_SequenceMethods_PartBundle,
    &Dtool_MappingMethods_PartBundle,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PartBundle,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PartBundle,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the root of a MovingPart hierarchy.  It defines the hierarchy of\n"
    " * moving parts that make up an animatable object.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PartBundle,
    nullptr, // tp_members
    Dtool_Properties_PartBundle,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PartBundle,
    PyType_GenericAlloc,
    Dtool_new_PartBundle,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PartBundle,
  Dtool_UpcastInterface_PartBundle,
  Dtool_DowncastInterface_PartBundle,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PartBundle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PartGroup(nullptr);
    Dtool_PartBundle._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PartGroup);
    Dtool_PartBundle._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(9);
    Dtool_PartBundle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum PartBundle::BlendType;
    PyDict_SetItemString(dict, "BT_linear", Dtool_WrapValue(PartBundle::BT_linear));
    PyDict_SetItemString(dict, "BTLinear", Dtool_WrapValue(PartBundle::BT_linear));
    PyDict_SetItemString(dict, "BT_normalized_linear", Dtool_WrapValue(PartBundle::BT_normalized_linear));
    PyDict_SetItemString(dict, "BTNormalizedLinear", Dtool_WrapValue(PartBundle::BT_normalized_linear));
    PyDict_SetItemString(dict, "BT_componentwise", Dtool_WrapValue(PartBundle::BT_componentwise));
    PyDict_SetItemString(dict, "BTComponentwise", Dtool_WrapValue(PartBundle::BT_componentwise));
    PyDict_SetItemString(dict, "BT_componentwise_quat", Dtool_WrapValue(PartBundle::BT_componentwise_quat));
    PyDict_SetItemString(dict, "BTComponentwiseQuat", Dtool_WrapValue(PartBundle::BT_componentwise_quat));
    if (PyType_Ready((PyTypeObject *)&Dtool_PartBundle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PartBundle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PartBundle);
  }
}

/**
 * Python method tables for PartBundleNode (PartBundleNode)
 */
static PyMethodDef Dtool_Methods_PartBundleNode[] = {
  {"get_num_bundles", &Dtool_PartBundleNode_get_num_bundles_251, METH_NOARGS, (const char *)Dtool_PartBundleNode_get_num_bundles_251_comment},
  {"getNumBundles", &Dtool_PartBundleNode_get_num_bundles_251, METH_NOARGS, (const char *)Dtool_PartBundleNode_get_num_bundles_251_comment},
  {"get_bundle", &Dtool_PartBundleNode_get_bundle_252, METH_O, (const char *)Dtool_PartBundleNode_get_bundle_252_comment},
  {"getBundle", &Dtool_PartBundleNode_get_bundle_252, METH_O, (const char *)Dtool_PartBundleNode_get_bundle_252_comment},
  {"get_bundle_handle", &Dtool_PartBundleNode_get_bundle_handle_254, METH_O, (const char *)Dtool_PartBundleNode_get_bundle_handle_254_comment},
  {"getBundleHandle", &Dtool_PartBundleNode_get_bundle_handle_254, METH_O, (const char *)Dtool_PartBundleNode_get_bundle_handle_254_comment},
  {"get_class_type", &Dtool_PartBundleNode_get_class_type_266, METH_NOARGS | METH_STATIC, (const char *)Dtool_PartBundleNode_get_class_type_266_comment},
  {"getClassType", &Dtool_PartBundleNode_get_class_type_266, METH_NOARGS | METH_STATIC, (const char *)Dtool_PartBundleNode_get_class_type_266_comment},
  {"get_bundles", (PyCFunction) &MakeSeq_PartBundleNode_get_bundles, METH_NOARGS, nullptr},
  { "getBundles", (PyCFunction) &MakeSeq_PartBundleNode_get_bundles, METH_NOARGS, nullptr},
  {"get_bundle_handles", (PyCFunction) &MakeSeq_PartBundleNode_get_bundle_handles, METH_NOARGS, nullptr},
  { "getBundleHandles", (PyCFunction) &MakeSeq_PartBundleNode_get_bundle_handles, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_PartBundleNode[] = {
  {(char *)"bundles", &Dtool_PartBundleNode_bundles_Getter, nullptr, nullptr, nullptr},
  {(char *)"bundle_handles", &Dtool_PartBundleNode_bundle_handles_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PartBundleNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PartBundleNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PartBundleNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PartBundleNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PartBundleNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PartBundleNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PartBundleNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PartBundleNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PartBundleNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PartBundleNode,
    &Dtool_SequenceMethods_PartBundleNode,
    &Dtool_MappingMethods_PartBundleNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PartBundleNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a node that contains a pointer to an PartBundle.  Like\n"
    " * AnimBundleNode, it exists to make it easy to store PartBundles in the scene\n"
    " * graph.\n"
    " *\n"
    " * (Unlike AnimBundleNode, however, PartBundleNode has an additional function:\n"
    " * it is also the base class of the Character node type, which adds additional\n"
    " * functionality.)\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PartBundleNode,
    nullptr, // tp_members
    Dtool_Properties_PartBundleNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PartBundleNode,
    PyType_GenericAlloc,
    Dtool_new_PartBundleNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PartBundleNode,
  Dtool_UpcastInterface_PartBundleNode,
  Dtool_DowncastInterface_PartBundleNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PartBundleNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_PartBundleNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    Dtool_PartBundleNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PartBundleNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PartBundleNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PartBundleNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PartBundleNode);
  }
}

/**
 * Python method tables for PartBundleHandle (PartBundleHandle)
 */
static PyMethodDef Dtool_Methods_PartBundleHandle[] = {
  {"get_bundle", &Dtool_PartBundleHandle_get_bundle_263, METH_NOARGS, (const char *)Dtool_PartBundleHandle_get_bundle_263_comment},
  {"getBundle", &Dtool_PartBundleHandle_get_bundle_263, METH_NOARGS, (const char *)Dtool_PartBundleHandle_get_bundle_263_comment},
  {"set_bundle", &Dtool_PartBundleHandle_set_bundle_264, METH_O, (const char *)Dtool_PartBundleHandle_set_bundle_264_comment},
  {"setBundle", &Dtool_PartBundleHandle_set_bundle_264, METH_O, (const char *)Dtool_PartBundleHandle_set_bundle_264_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_PartBundleHandle[] = {
  {(char *)"bundle", &Dtool_PartBundleHandle_bundle_Getter, &Dtool_PartBundleHandle_bundle_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PartBundleHandle = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PartBundleHandle = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PartBundleHandle = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PartBundleHandle = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PartBundleHandle = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PartBundleHandle = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PartBundleHandle",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PartBundleHandle,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PartBundleHandle,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PartBundleHandle,
    &Dtool_SequenceMethods_PartBundleHandle,
    &Dtool_MappingMethods_PartBundleHandle,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PartBundleHandle,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a trivial class returned by PartBundleNode::get_bundle().  Its\n"
    " * purpose is to hold the actual PartBundle pointer contained within the\n"
    " * PartBundleNode, so that scene graph flatten operations can safely combine\n"
    " * or duplicate PartBundles as necessary without affecting high-level bundle\n"
    " * operations.\n"
    " *\n"
    " * The high-level Actor class defined in direct/src/actor, for instance, will\n"
    " * store a list of PartBundleHandles instead of on actual PartBundles, so that\n"
    " * it will be immune to changes from these flatten operations.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PartBundleHandle,
    nullptr, // tp_members
    Dtool_Properties_PartBundleHandle,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PartBundleHandle,
    PyType_GenericAlloc,
    Dtool_new_PartBundleHandle,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PartBundleHandle,
  Dtool_UpcastInterface_PartBundleHandle,
  Dtool_DowncastInterface_PartBundleHandle,
  (CoerceFunction)Dtool_ConstCoerce_PartBundleHandle,
  (CoerceFunction)Dtool_Coerce_PartBundleHandle,
};

static void Dtool_PyModuleClassInit_PartBundleHandle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_PartBundleHandle._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_PartBundleHandle._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PartBundleHandle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PartBundleHandle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PartBundleHandle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PartBundleHandle);
  }
}

/**
 * Python method tables for MovingPartBase (MovingPartBase)
 */
static PyMethodDef Dtool_Methods_MovingPartBase[] = {
  {"get_max_bound", &Dtool_MovingPartBase_get_max_bound_282, METH_NOARGS, (const char *)Dtool_MovingPartBase_get_max_bound_282_comment},
  {"getMaxBound", &Dtool_MovingPartBase_get_max_bound_282, METH_NOARGS, (const char *)Dtool_MovingPartBase_get_max_bound_282_comment},
  {"get_bound", &Dtool_MovingPartBase_get_bound_283, METH_O, (const char *)Dtool_MovingPartBase_get_bound_283_comment},
  {"getBound", &Dtool_MovingPartBase_get_bound_283, METH_O, (const char *)Dtool_MovingPartBase_get_bound_283_comment},
  {"output_value", &Dtool_MovingPartBase_output_value_284, METH_O, (const char *)Dtool_MovingPartBase_output_value_284_comment},
  {"outputValue", &Dtool_MovingPartBase_output_value_284, METH_O, (const char *)Dtool_MovingPartBase_output_value_284_comment},
  {"get_class_type", &Dtool_MovingPartBase_get_class_type_285, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPartBase_get_class_type_285_comment},
  {"getClassType", &Dtool_MovingPartBase_get_class_type_285, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPartBase_get_class_type_285_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_MovingPartBase = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MovingPartBase = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_MovingPartBase = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_MovingPartBase = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_MovingPartBase = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_MovingPartBase = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MovingPartBase",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MovingPartBase,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_MovingPartBase,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MovingPartBase,
    &Dtool_SequenceMethods_MovingPartBase,
    &Dtool_MappingMethods_MovingPartBase,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_MovingPartBase,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the base class for a single animatable piece that may be bound to\n"
    " * one channel (or more, if blending is in effect).  It corresponds to, for\n"
    " * instance, a single joint or slider of a character.\n"
    " *\n"
    " * MovingPartBase does not have a particular value type.  See the derived\n"
    " * template class, MovingPart, for this.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MovingPartBase,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MovingPartBase,
    PyType_GenericAlloc,
    Dtool_new_MovingPartBase,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MovingPartBase,
  Dtool_UpcastInterface_MovingPartBase,
  Dtool_DowncastInterface_MovingPartBase,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MovingPartBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PartGroup(nullptr);
    Dtool_MovingPartBase._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PartGroup);
    Dtool_MovingPartBase._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MovingPartBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MovingPartBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MovingPartBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MovingPartBase);
  }
}

/**
 * Python method tables for MovingPartMatrix (MovingPartMatrix)
 */
static PyMethodDef Dtool_Methods_MovingPartMatrix[] = {
  {"get_class_type", &Dtool_MovingPartMatrix_get_class_type_293, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPartMatrix_get_class_type_293_comment},
  {"getClassType", &Dtool_MovingPartMatrix_get_class_type_293, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPartMatrix_get_class_type_293_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_MovingPartMatrix = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MovingPartMatrix = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_MovingPartMatrix = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_MovingPartMatrix = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_MovingPartMatrix = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_MovingPartMatrix = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MovingPartMatrix",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MovingPartMatrix,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_MovingPartMatrix,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MovingPartMatrix,
    &Dtool_SequenceMethods_MovingPartMatrix,
    &Dtool_MappingMethods_MovingPartMatrix,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_MovingPartMatrix,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a particular kind of MovingPart that accepts a matrix each frame.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MovingPartMatrix,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MovingPartMatrix,
    PyType_GenericAlloc,
    Dtool_new_MovingPartMatrix,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MovingPartMatrix,
  Dtool_UpcastInterface_MovingPartMatrix,
  Dtool_DowncastInterface_MovingPartMatrix,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MovingPartMatrix(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovingPart_ACMatrixSwitchType(nullptr);
    Dtool_MovingPartMatrix._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovingPart_ACMatrixSwitchType);
    Dtool_MovingPartMatrix._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MovingPartMatrix._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MovingPartMatrix) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MovingPartMatrix)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MovingPartMatrix);
  }
}

/**
 * Python method tables for MovingPart_ACMatrixSwitchType (MovingPart_ACMatrixSwitchType)
 */
static PyMethodDef Dtool_Methods_MovingPart_ACMatrixSwitchType[] = {
  {"get_class_type", &Dtool_MovingPart_ACMatrixSwitchType_get_class_type_289, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPart_ACMatrixSwitchType_get_class_type_289_comment},
  {"getClassType", &Dtool_MovingPart_ACMatrixSwitchType_get_class_type_289, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPart_ACMatrixSwitchType_get_class_type_289_comment},
  {"get_value", &Dtool_MovingPart_ACMatrixSwitchType_get_value_290, METH_NOARGS, (const char *)Dtool_MovingPart_ACMatrixSwitchType_get_value_290_comment},
  {"getValue", &Dtool_MovingPart_ACMatrixSwitchType_get_value_290, METH_NOARGS, (const char *)Dtool_MovingPart_ACMatrixSwitchType_get_value_290_comment},
  {"get_default_value", &Dtool_MovingPart_ACMatrixSwitchType_get_default_value_291, METH_NOARGS, (const char *)Dtool_MovingPart_ACMatrixSwitchType_get_default_value_291_comment},
  {"getDefaultValue", &Dtool_MovingPart_ACMatrixSwitchType_get_default_value_291, METH_NOARGS, (const char *)Dtool_MovingPart_ACMatrixSwitchType_get_default_value_291_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_MovingPart_ACMatrixSwitchType = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MovingPart_ACMatrixSwitchType = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_MovingPart_ACMatrixSwitchType = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_MovingPart_ACMatrixSwitchType = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_MovingPart_ACMatrixSwitchType = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_MovingPart_ACMatrixSwitchType = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MovingPart_ACMatrixSwitchType",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MovingPart_ACMatrixSwitchType,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_MovingPart_ACMatrixSwitchType,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MovingPart_ACMatrixSwitchType,
    &Dtool_SequenceMethods_MovingPart_ACMatrixSwitchType,
    &Dtool_MappingMethods_MovingPart_ACMatrixSwitchType,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_MovingPart_ACMatrixSwitchType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MovingPart_ACMatrixSwitchType,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MovingPart_ACMatrixSwitchType,
    PyType_GenericAlloc,
    Dtool_new_MovingPart_ACMatrixSwitchType,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MovingPart_ACMatrixSwitchType,
  Dtool_UpcastInterface_MovingPart_ACMatrixSwitchType,
  Dtool_DowncastInterface_MovingPart_ACMatrixSwitchType,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MovingPart_ACMatrixSwitchType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovingPartBase(nullptr);
    Dtool_MovingPart_ACMatrixSwitchType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovingPartBase);
    Dtool_MovingPart_ACMatrixSwitchType._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MovingPart_ACMatrixSwitchType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MovingPart_ACMatrixSwitchType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MovingPart_ACMatrixSwitchType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MovingPart_ACMatrixSwitchType);
  }
}

/**
 * Python method tables for MovingPartScalar (MovingPartScalar)
 */
static PyMethodDef Dtool_Methods_MovingPartScalar[] = {
  {"get_class_type", &Dtool_MovingPartScalar_get_class_type_300, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPartScalar_get_class_type_300_comment},
  {"getClassType", &Dtool_MovingPartScalar_get_class_type_300, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPartScalar_get_class_type_300_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_MovingPartScalar = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MovingPartScalar = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_MovingPartScalar = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_MovingPartScalar = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_MovingPartScalar = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_MovingPartScalar = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MovingPartScalar",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MovingPartScalar,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_MovingPartScalar,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MovingPartScalar,
    &Dtool_SequenceMethods_MovingPartScalar,
    &Dtool_MappingMethods_MovingPartScalar,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_MovingPartScalar,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a particular kind of MovingPart that accepts a scalar each frame.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MovingPartScalar,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MovingPartScalar,
    PyType_GenericAlloc,
    Dtool_new_MovingPartScalar,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MovingPartScalar,
  Dtool_UpcastInterface_MovingPartScalar,
  Dtool_DowncastInterface_MovingPartScalar,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MovingPartScalar(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovingPart_ACScalarSwitchType(nullptr);
    Dtool_MovingPartScalar._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovingPart_ACScalarSwitchType);
    Dtool_MovingPartScalar._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MovingPartScalar._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MovingPartScalar) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MovingPartScalar)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MovingPartScalar);
  }
}

/**
 * Python method tables for MovingPart_ACScalarSwitchType (MovingPart_ACScalarSwitchType)
 */
static PyMethodDef Dtool_Methods_MovingPart_ACScalarSwitchType[] = {
  {"get_class_type", &Dtool_MovingPart_ACScalarSwitchType_get_class_type_296, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPart_ACScalarSwitchType_get_class_type_296_comment},
  {"getClassType", &Dtool_MovingPart_ACScalarSwitchType_get_class_type_296, METH_NOARGS | METH_STATIC, (const char *)Dtool_MovingPart_ACScalarSwitchType_get_class_type_296_comment},
  {"get_value", &Dtool_MovingPart_ACScalarSwitchType_get_value_297, METH_NOARGS, (const char *)Dtool_MovingPart_ACScalarSwitchType_get_value_297_comment},
  {"getValue", &Dtool_MovingPart_ACScalarSwitchType_get_value_297, METH_NOARGS, (const char *)Dtool_MovingPart_ACScalarSwitchType_get_value_297_comment},
  {"get_default_value", &Dtool_MovingPart_ACScalarSwitchType_get_default_value_298, METH_NOARGS, (const char *)Dtool_MovingPart_ACScalarSwitchType_get_default_value_298_comment},
  {"getDefaultValue", &Dtool_MovingPart_ACScalarSwitchType_get_default_value_298, METH_NOARGS, (const char *)Dtool_MovingPart_ACScalarSwitchType_get_default_value_298_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_MovingPart_ACScalarSwitchType = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_MovingPart_ACScalarSwitchType = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_MovingPart_ACScalarSwitchType = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_MovingPart_ACScalarSwitchType = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_MovingPart_ACScalarSwitchType = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_MovingPart_ACScalarSwitchType = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MovingPart_ACScalarSwitchType",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MovingPart_ACScalarSwitchType,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_MovingPart_ACScalarSwitchType,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MovingPart_ACScalarSwitchType,
    &Dtool_SequenceMethods_MovingPart_ACScalarSwitchType,
    &Dtool_MappingMethods_MovingPart_ACScalarSwitchType,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_MovingPart_ACScalarSwitchType,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MovingPart_ACScalarSwitchType,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MovingPart_ACScalarSwitchType,
    PyType_GenericAlloc,
    Dtool_new_MovingPart_ACScalarSwitchType,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MovingPart_ACScalarSwitchType,
  Dtool_UpcastInterface_MovingPart_ACScalarSwitchType,
  Dtool_DowncastInterface_MovingPart_ACScalarSwitchType,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MovingPart_ACScalarSwitchType(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_MovingPartBase(nullptr);
    Dtool_MovingPart_ACScalarSwitchType._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_MovingPartBase);
    Dtool_MovingPart_ACScalarSwitchType._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MovingPart_ACScalarSwitchType._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MovingPart_ACScalarSwitchType) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MovingPart_ACScalarSwitchType)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MovingPart_ACScalarSwitchType);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3chan_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    AnimGroup::init_type();
    TypeHandle handle = AnimGroup::get_class_type();
    Dtool_AnimGroup._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AnimGroup);
  }
  {
    AnimBundle::init_type();
    TypeHandle handle = AnimBundle::get_class_type();
    Dtool_AnimBundle._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AnimBundle);
  }
  {
    AnimBundleNode::init_type();
    TypeHandle handle = AnimBundleNode::get_class_type();
    Dtool_AnimBundleNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AnimBundleNode);
  }
  {
    PartGroup::init_type();
    TypeHandle handle = PartGroup::get_class_type();
    Dtool_PartGroup._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PartGroup);
  }
  {
    AnimControl::init_type();
    TypeHandle handle = AnimControl::get_class_type();
    Dtool_AnimControl._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AnimControl);
  }
  {
    AnimChannelBase::init_type();
    TypeHandle handle = AnimChannelBase::get_class_type();
    Dtool_AnimChannelBase._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AnimChannelBase);
  }
  {
    AnimChannel< ACMatrixSwitchType >::init_type();
    TypeHandle handle = AnimChannel< ACMatrixSwitchType >::get_class_type();
    Dtool_AnimChannel_ACMatrixSwitchType._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AnimChannel_ACMatrixSwitchType);
  }
  {
    AnimChannel< ACScalarSwitchType >::init_type();
    TypeHandle handle = AnimChannel< ACScalarSwitchType >::get_class_type();
    Dtool_AnimChannel_ACScalarSwitchType._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AnimChannel_ACScalarSwitchType);
  }
  {
    AnimChannelMatrixDynamic::init_type();
    TypeHandle handle = AnimChannelMatrixDynamic::get_class_type();
    Dtool_AnimChannelMatrixDynamic._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AnimChannelMatrixDynamic);
  }
  {
    AnimChannelMatrixXfmTable::init_type();
    TypeHandle handle = AnimChannelMatrixXfmTable::get_class_type();
    Dtool_AnimChannelMatrixXfmTable._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AnimChannelMatrixXfmTable);
  }
  {
    AnimChannelScalarDynamic::init_type();
    TypeHandle handle = AnimChannelScalarDynamic::get_class_type();
    Dtool_AnimChannelScalarDynamic._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AnimChannelScalarDynamic);
  }
  {
    AnimChannelScalarTable::init_type();
    TypeHandle handle = AnimChannelScalarTable::get_class_type();
    Dtool_AnimChannelScalarTable._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AnimChannelScalarTable);
  }
  {
    AnimPreloadTable::init_type();
    TypeHandle handle = AnimPreloadTable::get_class_type();
    Dtool_AnimPreloadTable._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AnimPreloadTable);
  }
  {
    BindAnimRequest::init_type();
    TypeHandle handle = BindAnimRequest::get_class_type();
    Dtool_BindAnimRequest._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BindAnimRequest);
  }
  {
    PartBundle::init_type();
    TypeHandle handle = PartBundle::get_class_type();
    Dtool_PartBundle._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PartBundle);
  }
  {
    PartBundleNode::init_type();
    TypeHandle handle = PartBundleNode::get_class_type();
    Dtool_PartBundleNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PartBundleNode);
  }
  {
    MovingPartBase::init_type();
    TypeHandle handle = MovingPartBase::get_class_type();
    Dtool_MovingPartBase._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_MovingPartBase);
  }
  {
    MovingPartMatrix::init_type();
    TypeHandle handle = MovingPartMatrix::get_class_type();
    Dtool_MovingPartMatrix._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_MovingPartMatrix);
  }
  {
    MovingPart< ACMatrixSwitchType >::init_type();
    TypeHandle handle = MovingPart< ACMatrixSwitchType >::get_class_type();
    Dtool_MovingPart_ACMatrixSwitchType._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_MovingPart_ACMatrixSwitchType);
  }
  {
    MovingPartScalar::init_type();
    TypeHandle handle = MovingPartScalar::get_class_type();
    Dtool_MovingPartScalar._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_MovingPartScalar);
  }
  {
    MovingPart< ACScalarSwitchType >::init_type();
    TypeHandle handle = MovingPart< ACScalarSwitchType >::get_class_type();
    Dtool_MovingPart_ACScalarSwitchType._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_MovingPart_ACScalarSwitchType);
  }
}

void Dtool_libp3chan_BuildInstants(PyObject *module) {
  (void) module;
  // AnimGroup
  Dtool_PyModuleClassInit_AnimGroup(module);
  PyModule_AddObject(module, "AnimGroup", (PyObject *)&Dtool_AnimGroup);
  // AnimBundle
  Dtool_PyModuleClassInit_AnimBundle(module);
  PyModule_AddObject(module, "AnimBundle", (PyObject *)&Dtool_AnimBundle);
  // AnimBundleNode
  Dtool_PyModuleClassInit_AnimBundleNode(module);
  PyModule_AddObject(module, "AnimBundleNode", (PyObject *)&Dtool_AnimBundleNode);
  // PartGroup
  Dtool_PyModuleClassInit_PartGroup(module);
  PyModule_AddObject(module, "PartGroup", (PyObject *)&Dtool_PartGroup);
  // AnimControl
  Dtool_PyModuleClassInit_AnimControl(module);
  PyModule_AddObject(module, "AnimControl", (PyObject *)&Dtool_AnimControl);
  // AnimChannelBase
  Dtool_PyModuleClassInit_AnimChannelBase(module);
  PyModule_AddObject(module, "AnimChannelBase", (PyObject *)&Dtool_AnimChannelBase);
  // AnimChannel< ACMatrixSwitchType >
  Dtool_PyModuleClassInit_AnimChannel_ACMatrixSwitchType(module);
  PyModule_AddObject(module, "AnimChannel_ACMatrixSwitchType", (PyObject *)&Dtool_AnimChannel_ACMatrixSwitchType);
  Py_INCREF(Dtool_Ptr_AnimChannel_ACMatrixSwitchType);
  PyModule_AddObject(module, "AnimChannelACMatrixSwitchType", (PyObject *)&Dtool_AnimChannel_ACMatrixSwitchType);
  // typedef AnimChannel< ACMatrixSwitchType > AnimChannelMatrix
  Dtool_PyModuleClassInit_AnimChannel_ACMatrixSwitchType(module);
  Py_INCREF((PyObject *)&Dtool_AnimChannel_ACMatrixSwitchType);
  PyModule_AddObject(module, "AnimChannelMatrix", (PyObject *)&Dtool_AnimChannel_ACMatrixSwitchType);
  // AnimChannel< ACScalarSwitchType >
  Dtool_PyModuleClassInit_AnimChannel_ACScalarSwitchType(module);
  PyModule_AddObject(module, "AnimChannel_ACScalarSwitchType", (PyObject *)&Dtool_AnimChannel_ACScalarSwitchType);
  Py_INCREF(Dtool_Ptr_AnimChannel_ACScalarSwitchType);
  PyModule_AddObject(module, "AnimChannelACScalarSwitchType", (PyObject *)&Dtool_AnimChannel_ACScalarSwitchType);
  // typedef AnimChannel< ACScalarSwitchType > AnimChannelScalar
  Dtool_PyModuleClassInit_AnimChannel_ACScalarSwitchType(module);
  Py_INCREF((PyObject *)&Dtool_AnimChannel_ACScalarSwitchType);
  PyModule_AddObject(module, "AnimChannelScalar", (PyObject *)&Dtool_AnimChannel_ACScalarSwitchType);
  // AnimChannelMatrixDynamic
  Dtool_PyModuleClassInit_AnimChannelMatrixDynamic(module);
  PyModule_AddObject(module, "AnimChannelMatrixDynamic", (PyObject *)&Dtool_AnimChannelMatrixDynamic);
  // AnimChannelMatrixXfmTable
  Dtool_PyModuleClassInit_AnimChannelMatrixXfmTable(module);
  PyModule_AddObject(module, "AnimChannelMatrixXfmTable", (PyObject *)&Dtool_AnimChannelMatrixXfmTable);
  // AnimChannelScalarDynamic
  Dtool_PyModuleClassInit_AnimChannelScalarDynamic(module);
  PyModule_AddObject(module, "AnimChannelScalarDynamic", (PyObject *)&Dtool_AnimChannelScalarDynamic);
  // AnimChannelScalarTable
  Dtool_PyModuleClassInit_AnimChannelScalarTable(module);
  PyModule_AddObject(module, "AnimChannelScalarTable", (PyObject *)&Dtool_AnimChannelScalarTable);
  // AnimControlCollection
  Dtool_PyModuleClassInit_AnimControlCollection(module);
  PyModule_AddObject(module, "AnimControlCollection", (PyObject *)&Dtool_AnimControlCollection);
  // AnimPreloadTable
  Dtool_PyModuleClassInit_AnimPreloadTable(module);
  PyModule_AddObject(module, "AnimPreloadTable", (PyObject *)&Dtool_AnimPreloadTable);
  // PartSubset
  Dtool_PyModuleClassInit_PartSubset(module);
  PyModule_AddObject(module, "PartSubset", (PyObject *)&Dtool_PartSubset);
  // BindAnimRequest
  Dtool_PyModuleClassInit_BindAnimRequest(module);
  PyModule_AddObject(module, "BindAnimRequest", (PyObject *)&Dtool_BindAnimRequest);
  // PartBundle
  Dtool_PyModuleClassInit_PartBundle(module);
  PyModule_AddObject(module, "PartBundle", (PyObject *)&Dtool_PartBundle);
  // PartBundleNode
  Dtool_PyModuleClassInit_PartBundleNode(module);
  PyModule_AddObject(module, "PartBundleNode", (PyObject *)&Dtool_PartBundleNode);
  // PartBundleHandle
  Dtool_PyModuleClassInit_PartBundleHandle(module);
  PyModule_AddObject(module, "PartBundleHandle", (PyObject *)&Dtool_PartBundleHandle);
  // MovingPartBase
  Dtool_PyModuleClassInit_MovingPartBase(module);
  PyModule_AddObject(module, "MovingPartBase", (PyObject *)&Dtool_MovingPartBase);
  // MovingPartMatrix
  Dtool_PyModuleClassInit_MovingPartMatrix(module);
  PyModule_AddObject(module, "MovingPartMatrix", (PyObject *)&Dtool_MovingPartMatrix);
  // MovingPart< ACMatrixSwitchType >
  Dtool_PyModuleClassInit_MovingPart_ACMatrixSwitchType(module);
  PyModule_AddObject(module, "MovingPart_ACMatrixSwitchType", (PyObject *)&Dtool_MovingPart_ACMatrixSwitchType);
  Py_INCREF(Dtool_Ptr_MovingPart_ACMatrixSwitchType);
  PyModule_AddObject(module, "MovingPartACMatrixSwitchType", (PyObject *)&Dtool_MovingPart_ACMatrixSwitchType);
  // MovingPartScalar
  Dtool_PyModuleClassInit_MovingPartScalar(module);
  PyModule_AddObject(module, "MovingPartScalar", (PyObject *)&Dtool_MovingPartScalar);
  // MovingPart< ACScalarSwitchType >
  Dtool_PyModuleClassInit_MovingPart_ACScalarSwitchType(module);
  PyModule_AddObject(module, "MovingPart_ACScalarSwitchType", (PyObject *)&Dtool_MovingPart_ACScalarSwitchType);
  Py_INCREF(Dtool_Ptr_MovingPart_ACScalarSwitchType);
  PyModule_AddObject(module, "MovingPartACScalarSwitchType", (PyObject *)&Dtool_MovingPart_ACScalarSwitchType);
}

static PyMethodDef python_simple_funcs[] = {
  {"auto_bind", (PyCFunction) &Dtool_auto_bind_203, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_auto_bind_203_comment},
  {"autoBind", (PyCFunction) &Dtool_auto_bind_203, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_auto_bind_203_comment},
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3chan_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3chan_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583613589,  /* file_identifier */
  "libp3chan",  /* library_name */
  "8NZB",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3chan.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  607  /* next_index */
};

Configure(_in_configure_libp3chan);
ConfigureFn(_in_configure_libp3chan) {
  interrogate_request_module(&_in_module_def);
}

