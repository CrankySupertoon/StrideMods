/*
 * This file was generated by:
 * built/bin/interrogate -srcdir direct/src/distributed -Idirect/src/distributed -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3distributed_igate.cxx -od built/pandac/input/libp3distributed.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Idirect/src/distributed -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -DWITHIN_PANDA=1 -module panda3d.direct -library libp3distributed cConnectionRepository.cxx cConnectionRepository.h cDistributedSmoothNodeBase.cxx cDistributedSmoothNodeBase.h config_distributed.cxx config_distributed.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "cConnectionRepository.h"
#include "cDistributedSmoothNodeBase.h"
#include "config_distributed.h"
#include "config_downloader.h"
#include "datagramIterator.h"
#include "dcClass.h"
#include "dcClass_ext.h"
#include "dcField.h"
#include "dcPacker.h"
#include "dcmsgtypes.h"
#include "dconfig.h"
#include "httpChannel.h"
#include "pStatTimer.h"
#include "py_panda.h"
#include "throw_event.h"
#include "urlSpec.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class CConnectionRepository
 */
typedef CConnectionRepository CConnectionRepository_localtype;
Define_Module_Class(panda3d.direct, CConnectionRepository, CConnectionRepository_localtype, CConnectionRepository);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CConnectionRepository = &Dtool_CConnectionRepository;
static void Dtool_PyModuleClassInit_CConnectionRepository(PyObject *module);

/**
 * Forward declarations for top-level class CDistributedSmoothNodeBase
 */
typedef CDistributedSmoothNodeBase CDistributedSmoothNodeBase_localtype;
Define_Module_Class(panda3d.direct, CDistributedSmoothNodeBase, CDistributedSmoothNodeBase_localtype, CDistributedSmoothNodeBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CDistributedSmoothNodeBase = &Dtool_CDistributedSmoothNodeBase;
static void Dtool_PyModuleClassInit_CDistributedSmoothNodeBase(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"CConnectionRepository", &Dtool_CConnectionRepository},
  {"CDistributedSmoothNodeBase", &Dtool_CDistributedSmoothNodeBase},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"DCFile", nullptr},
#define Dtool_Ptr_DCFile (imports[0].type)
  {"Datagram", nullptr},
#define Dtool_Ptr_Datagram (imports[1].type)
  {"DatagramIterator", nullptr},
#define Dtool_Ptr_DatagramIterator (imports[2].type)
  {"QueuedConnectionManager", nullptr},
#define Dtool_Ptr_QueuedConnectionManager (imports[3].type)
  {"ConnectionWriter", nullptr},
#define Dtool_Ptr_ConnectionWriter (imports[4].type)
  {"QueuedConnectionReader", nullptr},
#define Dtool_Ptr_QueuedConnectionReader (imports[5].type)
  {"Buffered_DatagramConnection", nullptr},
#define Dtool_Ptr_Buffered_DatagramConnection (imports[6].type)
  {"DCClass", nullptr},
#define Dtool_Ptr_DCClass (imports[7].type)
  {"URLSpec", nullptr},
#define Dtool_Ptr_URLSpec (imports[8].type)
  {"SocketStream", nullptr},
#define Dtool_Ptr_SocketStream (imports[9].type)
  {"HTTPChannel", nullptr},
#define Dtool_Ptr_HTTPChannel (imports[10].type)
  {"NodePath", nullptr},
#define Dtool_Ptr_NodePath (imports[11].type)
  {nullptr, nullptr},
};
#endif

// DCFile
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DCFile;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCFile = &Dtool_DCFile;
#endif
// Datagram
#ifndef LINK_ALL_STATIC
inline static Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced) {
  nassertr(Dtool_Ptr_Datagram != nullptr, nullptr);
  nassertr(Dtool_Ptr_Datagram->_Dtool_Coerce != nullptr, nullptr);
  return ((Datagram *(*)(PyObject *, Datagram &))Dtool_Ptr_Datagram->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Datagram;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Datagram = &Dtool_Datagram;
extern Datagram *Dtool_Coerce_Datagram(PyObject *args, Datagram &coerced);
#endif
// DatagramIterator
#ifndef LINK_ALL_STATIC
inline static DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced) {
  nassertr(Dtool_Ptr_DatagramIterator != nullptr, nullptr);
  nassertr(Dtool_Ptr_DatagramIterator->_Dtool_Coerce != nullptr, nullptr);
  return ((DatagramIterator *(*)(PyObject *, DatagramIterator &))Dtool_Ptr_DatagramIterator->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DatagramIterator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramIterator = &Dtool_DatagramIterator;
extern DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced);
#endif
// QueuedConnectionManager
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_QueuedConnectionManager;
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedConnectionManager = &Dtool_QueuedConnectionManager;
#endif
// ConnectionWriter
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ConnectionWriter;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConnectionWriter = &Dtool_ConnectionWriter;
#endif
// QueuedConnectionReader
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_QueuedConnectionReader;
static struct Dtool_PyTypedObject *const Dtool_Ptr_QueuedConnectionReader = &Dtool_QueuedConnectionReader;
#endif
// Buffered_DatagramConnection
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Buffered_DatagramConnection;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Buffered_DatagramConnection = &Dtool_Buffered_DatagramConnection;
#endif
// DCClass
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DCClass;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DCClass = &Dtool_DCClass;
#endif
// URLSpec
#ifndef LINK_ALL_STATIC
inline static URLSpec *Dtool_Coerce_URLSpec(PyObject *args, URLSpec &coerced) {
  nassertr(Dtool_Ptr_URLSpec != nullptr, nullptr);
  nassertr(Dtool_Ptr_URLSpec->_Dtool_Coerce != nullptr, nullptr);
  return ((URLSpec *(*)(PyObject *, URLSpec &))Dtool_Ptr_URLSpec->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_URLSpec;
static struct Dtool_PyTypedObject *const Dtool_Ptr_URLSpec = &Dtool_URLSpec;
extern URLSpec *Dtool_Coerce_URLSpec(PyObject *args, URLSpec &coerced);
#endif
// SocketStream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_SocketStream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_SocketStream = &Dtool_SocketStream;
#endif
// HTTPChannel
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_HTTPChannel;
static struct Dtool_PyTypedObject *const Dtool_Ptr_HTTPChannel = &Dtool_HTTPChannel;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class CConnectionRepository
 */
/**
 * Python function wrapper for:
 * inline DCFile &CConnectionRepository::get_dc_file(void)
 */
static PyObject *Dtool_CConnectionRepository_get_dc_file_4(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.get_dc_file")) {
    return nullptr;
  }
  // 1-inline DCFile &CConnectionRepository::get_dc_file(void)
  DCFile *return_value = &(((*local_this).get_dc_file)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DCFile, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_dc_file_4_comment =
  "C++ Interface:\n"
  "get_dc_file(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the DCFile object associated with this repository.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_dc_file_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::has_owner_view(void) const
 */
static PyObject *Dtool_CConnectionRepository_has_owner_view_5(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConnectionRepository)) {
    return nullptr;
  }
  // 1-inline bool CConnectionRepository::has_owner_view(void) const
  bool return_value = ((*(const CConnectionRepository*)local_this).has_owner_view)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_has_owner_view_5_comment =
  "C++ Interface:\n"
  "has_owner_view(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns true if this repository can have 'owner' views of distributed\n"
  " * objects.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_has_owner_view_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_handle_c_updates(bool handle_c_updates)
 */
static PyObject *Dtool_CConnectionRepository_set_handle_c_updates_6(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_handle_c_updates")) {
    return nullptr;
  }
  // 1-inline void CConnectionRepository::set_handle_c_updates(bool handle_c_updates)
  ((*local_this).set_handle_c_updates)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_handle_c_updates(const CConnectionRepository self, bool handle_c_updates)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_handle_c_updates_6_comment =
  "C++ Interface:\n"
  "set_handle_c_updates(const CConnectionRepository self, bool handle_c_updates)\n"
  "\n"
  "/**\n"
  " * Set true to specify this repository should process distributed updates\n"
  " * internally in C++ code, or false if it should return them to Python.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_handle_c_updates_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::get_handle_c_updates(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_handle_c_updates_7(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConnectionRepository)) {
    return nullptr;
  }
  // 1-inline bool CConnectionRepository::get_handle_c_updates(void) const
  bool return_value = ((*(const CConnectionRepository*)local_this).get_handle_c_updates)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_handle_c_updates_7_comment =
  "C++ Interface:\n"
  "get_handle_c_updates(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns true if this repository will process distributed updates internally\n"
  " * in C++ code, or false if it will return them to Python.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_handle_c_updates_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_client_datagram(bool client_datagram)
 */
static PyObject *Dtool_CConnectionRepository_set_client_datagram_8(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_client_datagram")) {
    return nullptr;
  }
  // 1-inline void CConnectionRepository::set_client_datagram(bool client_datagram)
  ((*local_this).set_client_datagram)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_client_datagram(const CConnectionRepository self, bool client_datagram)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_client_datagram_8_comment =
  "C++ Interface:\n"
  "set_client_datagram(const CConnectionRepository self, bool client_datagram)\n"
  "\n"
  "/**\n"
  " * Sets the client_datagram flag.  If this is true, incoming datagrams are not\n"
  " * expected to be prefixed with the server routing information like message\n"
  " * sender, channel number, etc.; otherwise, these server fields are parsed and\n"
  " * removed from each incoming datagram.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_client_datagram_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::get_client_datagram(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_client_datagram_9(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConnectionRepository)) {
    return nullptr;
  }
  // 1-inline bool CConnectionRepository::get_client_datagram(void) const
  bool return_value = ((*(const CConnectionRepository*)local_this).get_client_datagram)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_client_datagram_9_comment =
  "C++ Interface:\n"
  "get_client_datagram(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the client_datagram flag.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_client_datagram_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_handle_datagrams_internally(bool handle_datagrams_internally)
 */
static PyObject *Dtool_CConnectionRepository_set_handle_datagrams_internally_10(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_handle_datagrams_internally")) {
    return nullptr;
  }
  // 1-inline void CConnectionRepository::set_handle_datagrams_internally(bool handle_datagrams_internally)
  ((*local_this).set_handle_datagrams_internally)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_handle_datagrams_internally(const CConnectionRepository self, bool handle_datagrams_internally)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_handle_datagrams_internally_10_comment =
  "C++ Interface:\n"
  "set_handle_datagrams_internally(const CConnectionRepository self, bool handle_datagrams_internally)\n"
  "\n"
  "/**\n"
  " * Sets the handle_datagrams_internally flag.  When true, certain message\n"
  " * types can be handled by the C++ code in in this module.  When false, all\n"
  " * datagrams, regardless of message type, are passed up to Python for\n"
  " * processing.\n"
  " *\n"
  " * The CMU distributed-object implementation requires this to be set false.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_handle_datagrams_internally_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::get_handle_datagrams_internally(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_handle_datagrams_internally_11(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConnectionRepository)) {
    return nullptr;
  }
  // 1-inline bool CConnectionRepository::get_handle_datagrams_internally(void) const
  bool return_value = ((*(const CConnectionRepository*)local_this).get_handle_datagrams_internally)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_handle_datagrams_internally_11_comment =
  "C++ Interface:\n"
  "get_handle_datagrams_internally(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the handle_datagrams_internally flag.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_handle_datagrams_internally_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CConnectionRepository::set_tcp_header_size(int tcp_header_size)
 */
static PyObject *Dtool_CConnectionRepository_set_tcp_header_size_12(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_tcp_header_size")) {
    return nullptr;
  }
  // 1-void CConnectionRepository::set_tcp_header_size(int tcp_header_size)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_tcp_header_size)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_tcp_header_size(const CConnectionRepository self, int tcp_header_size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_tcp_header_size_12_comment =
  "C++ Interface:\n"
  "set_tcp_header_size(const CConnectionRepository self, int tcp_header_size)\n"
  "\n"
  "/**\n"
  " * Sets the header size of TCP packets.  At the present, legal values for this\n"
  " * are 0, 2, or 4; this specifies the number of bytes to use encode the\n"
  " * datagram length at the start of each TCP datagram.  Sender and receiver\n"
  " * must independently agree on this.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_tcp_header_size_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int CConnectionRepository::get_tcp_header_size(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_tcp_header_size_13(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConnectionRepository)) {
    return nullptr;
  }
  // 1-inline int CConnectionRepository::get_tcp_header_size(void) const
  int return_value = ((*(const CConnectionRepository*)local_this).get_tcp_header_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_tcp_header_size_13_comment =
  "C++ Interface:\n"
  "get_tcp_header_size(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of TCP header size.  See set_tcp_header_size().\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_tcp_header_size_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_python_repository(PyObject *python_repository)
 */
static PyObject *Dtool_CConnectionRepository_set_python_repository_14(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_python_repository")) {
    return nullptr;
  }
  // 1-inline void CConnectionRepository::set_python_repository(PyObject *python_repository)
  ((*local_this).set_python_repository)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_python_repository(const CConnectionRepository self, object python_repository)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_python_repository_14_comment =
  "C++ Interface:\n"
  "set_python_repository(const CConnectionRepository self, object python_repository)\n"
  "\n"
  "/**\n"
  " * Records the pointer to the Python class that derives from\n"
  " * CConnectionRepository.  This allows the C++ implementation to directly\n"
  " * manipulation some python structures on the repository.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_python_repository_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CConnectionRepository::set_connection_http(HTTPChannel *channel)
 */
static PyObject *Dtool_CConnectionRepository_set_connection_http_15(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_connection_http")) {
    return nullptr;
  }
  // 1-void CConnectionRepository::set_connection_http(HTTPChannel *channel)
  HTTPChannel *arg_this = (HTTPChannel *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HTTPChannel, 1, "CConnectionRepository.set_connection_http", false, true);
  if (arg_this != nullptr) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).set_connection_http)(arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_connection_http(const CConnectionRepository self, HTTPChannel channel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_connection_http_15_comment =
  "C++ Interface:\n"
  "set_connection_http(const CConnectionRepository self, HTTPChannel channel)\n"
  "\n"
  "/**\n"
  " * Once a connection has been established via the HTTP interface, gets the\n"
  " * connection and uses it.  The supplied HTTPChannel object must have a\n"
  " * connection available via get_connection().\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_connection_http_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * SocketStream *CConnectionRepository::get_stream(void)
 */
static PyObject *Dtool_CConnectionRepository_get_stream_16(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.get_stream")) {
    return nullptr;
  }
  // 1-SocketStream *CConnectionRepository::get_stream(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  SocketStream *return_value = ((*local_this).get_stream)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SocketStream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_stream_16_comment =
  "C++ Interface:\n"
  "get_stream(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the SocketStream that internally represents the already-established\n"
  " * HTTP connection.  Returns NULL if there is no current HTTP connection.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_stream_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CConnectionRepository::try_connect_net(URLSpec const &url)
 */
static PyObject *Dtool_CConnectionRepository_try_connect_net_17(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.try_connect_net")) {
    return nullptr;
  }
  // 1-bool CConnectionRepository::try_connect_net(URLSpec const &url)
  URLSpec arg_local;
  URLSpec const *arg_this = Dtool_Coerce_URLSpec(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CConnectionRepository.try_connect_net", "URLSpec");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).try_connect_net)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "try_connect_net(const CConnectionRepository self, const URLSpec url)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_try_connect_net_17_comment =
  "C++ Interface:\n"
  "try_connect_net(const CConnectionRepository self, const URLSpec url)\n"
  "\n"
  "/**\n"
  " * Uses Panda's \"net\" library to try to connect to the server and port named\n"
  " * in the indicated URL.  Returns true if successful, false otherwise.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_try_connect_net_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline QueuedConnectionManager &CConnectionRepository::get_qcm(void)
 */
static PyObject *Dtool_CConnectionRepository_get_qcm_18(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.get_qcm")) {
    return nullptr;
  }
  // 1-inline QueuedConnectionManager &CConnectionRepository::get_qcm(void)
  QueuedConnectionManager *return_value = &(((*local_this).get_qcm)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedConnectionManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_qcm_18_comment =
  "C++ Interface:\n"
  "get_qcm(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the QueuedConnectionManager object associated with the repository.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_qcm_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConnectionWriter &CConnectionRepository::get_cw(void)
 */
static PyObject *Dtool_CConnectionRepository_get_cw_19(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.get_cw")) {
    return nullptr;
  }
  // 1-inline ConnectionWriter &CConnectionRepository::get_cw(void)
  ConnectionWriter *return_value = &(((*local_this).get_cw)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConnectionWriter, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_cw_19_comment =
  "C++ Interface:\n"
  "get_cw(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the ConnectionWriter object associated with the repository.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_cw_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline QueuedConnectionReader &CConnectionRepository::get_qcr(void)
 */
static PyObject *Dtool_CConnectionRepository_get_qcr_20(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.get_qcr")) {
    return nullptr;
  }
  // 1-inline QueuedConnectionReader &CConnectionRepository::get_qcr(void)
  QueuedConnectionReader *return_value = &(((*local_this).get_qcr)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_QueuedConnectionReader, false, false);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_qcr_20_comment =
  "C++ Interface:\n"
  "get_qcr(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the QueuedConnectionReader object associated with the repository.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_qcr_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CConnectionRepository::connect_native(URLSpec const &url)
 */
static PyObject *Dtool_CConnectionRepository_connect_native_21(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.connect_native")) {
    return nullptr;
  }
  // 1-bool CConnectionRepository::connect_native(URLSpec const &url)
  URLSpec arg_local;
  URLSpec const *arg_this = Dtool_Coerce_URLSpec(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CConnectionRepository.connect_native", "URLSpec");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).connect_native)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "connect_native(const CConnectionRepository self, const URLSpec url)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_connect_native_21_comment =
  "C++ Interface:\n"
  "connect_native(const CConnectionRepository self, const URLSpec url)\n"
  "\n"
  "/**\n"
  " * Connects to the server using Panda's low-level and fast \"native net\"\n"
  " * library.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_connect_native_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Buffered_DatagramConnection &CConnectionRepository::get_bdc(void)
 */
static PyObject *Dtool_CConnectionRepository_get_bdc_22(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.get_bdc")) {
    return nullptr;
  }
  // 1-inline Buffered_DatagramConnection &CConnectionRepository::get_bdc(void)
  Buffered_DatagramConnection *return_value = &(((*local_this).get_bdc)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Buffered_DatagramConnection, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_bdc_22_comment =
  "C++ Interface:\n"
  "get_bdc(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the Buffered_DatagramConnection object associated with the\n"
  " * repository.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_bdc_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CConnectionRepository::check_datagram(void)
 */
static PyObject *Dtool_CConnectionRepository_check_datagram_23(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.check_datagram")) {
    return nullptr;
  }
  // 1-bool CConnectionRepository::check_datagram(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).check_datagram)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_check_datagram_23_comment =
  "C++ Interface:\n"
  "check_datagram(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns true if a new datagram is available, false otherwise.  If the\n"
  " * return value is true, the new datagram may be retrieved via get_datagram(),\n"
  " * or preferably, with get_datagram_iterator() and get_msg_type().\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_check_datagram_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::get_datagram(Datagram &dg)
 */
static PyObject *Dtool_CConnectionRepository_get_datagram_24(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.get_datagram")) {
    return nullptr;
  }
  // 1-inline void CConnectionRepository::get_datagram(Datagram &dg)
  Datagram arg_local;
  Datagram *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CConnectionRepository.get_datagram", "Datagram");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).get_datagram)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_datagram(const CConnectionRepository self, Datagram dg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_datagram_24_comment =
  "C++ Interface:\n"
  "get_datagram(const CConnectionRepository self, Datagram dg)\n"
  "\n"
  "/**\n"
  " * Fills the datagram object with the datagram most recently retrieved by\n"
  " * check_datagram().\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_datagram_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::get_datagram_iterator(DatagramIterator &di)
 */
static PyObject *Dtool_CConnectionRepository_get_datagram_iterator_25(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.get_datagram_iterator")) {
    return nullptr;
  }
  // 1-inline void CConnectionRepository::get_datagram_iterator(DatagramIterator &di)
  DatagramIterator arg_local;
  DatagramIterator *arg_this = Dtool_Coerce_DatagramIterator(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CConnectionRepository.get_datagram_iterator", "DatagramIterator");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).get_datagram_iterator)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_datagram_iterator(const CConnectionRepository self, DatagramIterator di)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_datagram_iterator_25_comment =
  "C++ Interface:\n"
  "get_datagram_iterator(const CConnectionRepository self, DatagramIterator di)\n"
  "\n"
  "/**\n"
  " * Fills the DatagramIterator object with the iterator for the datagram most\n"
  " * recently retrieved by check_datagram().  This iterator has already read\n"
  " * past the datagram header and the message type, and is positioned at the\n"
  " * beginning of data.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_datagram_iterator_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CHANNEL_TYPE CConnectionRepository::get_msg_channel(int offset = 0) const
 */
static PyObject *Dtool_CConnectionRepository_get_msg_channel_26(PyObject *self, PyObject *args, PyObject *kwds) {
  CConnectionRepository *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConnectionRepository)) {
    return nullptr;
  }
  // 1-inline CHANNEL_TYPE CConnectionRepository::get_msg_channel(int offset = 0) const
  int param1 = 0;
  static const char *keyword_list[] = {"offset", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:get_msg_channel", (char **)keyword_list, &param1)) {
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    CHANNEL_TYPE return_value = ((*(const CConnectionRepository*)local_this).get_msg_channel)((int)param1);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_msg_channel(CConnectionRepository self, int offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_msg_channel_26_comment =
  "C++ Interface:\n"
  "get_msg_channel(CConnectionRepository self, int offset)\n"
  "\n"
  "/**\n"
  " * Returns the channel(s) to which the current message was sent, according to\n"
  " * the datagram headers.  This information is not available to the client.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_msg_channel_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int CConnectionRepository::get_msg_channel_count(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_msg_channel_count_27(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConnectionRepository)) {
    return nullptr;
  }
  // 1-inline int CConnectionRepository::get_msg_channel_count(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  int return_value = ((*(const CConnectionRepository*)local_this).get_msg_channel_count)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_msg_channel_count_27_comment =
  "C++ Interface:\n"
  "get_msg_channel_count(CConnectionRepository self)\n";
#else
static const char *Dtool_CConnectionRepository_get_msg_channel_count_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CHANNEL_TYPE CConnectionRepository::get_msg_sender(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_msg_sender_28(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConnectionRepository)) {
    return nullptr;
  }
  // 1-inline CHANNEL_TYPE CConnectionRepository::get_msg_sender(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  CHANNEL_TYPE return_value = ((*(const CConnectionRepository*)local_this).get_msg_sender)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_msg_sender_28_comment =
  "C++ Interface:\n"
  "get_msg_sender(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the sender ID of the current message, according to the datagram\n"
  " * headers.  This information is not available to the client.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_msg_sender_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned int CConnectionRepository::get_msg_type(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_msg_type_29(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConnectionRepository)) {
    return nullptr;
  }
  // 1-inline unsigned int CConnectionRepository::get_msg_type(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  unsigned int return_value = ((*(const CConnectionRepository*)local_this).get_msg_type)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_msg_type_29_comment =
  "C++ Interface:\n"
  "get_msg_type(CConnectionRepository self)\n"
  "\n"
  "// INLINE unsigned char get_sec_code() const;\n"
  "\n"
  "/**\n"
  " * Returns the type ID of the current message, according to the datagram\n"
  " * headers.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_msg_type_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline std::string const &CConnectionRepository::get_overflow_event_name(void)
 */
static PyObject *Dtool_CConnectionRepository_get_overflow_event_name_30(PyObject *, PyObject *) {
  // 1-static inline std::string const &CConnectionRepository::get_overflow_event_name(void)
  std::string const &return_value = (CConnectionRepository::get_overflow_event_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_overflow_event_name_30_comment =
  "C++ Interface:\n"
  "get_overflow_event_name()\n"
  "\n"
  "/**\n"
  " * Returns event string that will be thrown if the datagram reader queue\n"
  " * overflows.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_overflow_event_name_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CConnectionRepository::is_connected(void)
 */
static PyObject *Dtool_CConnectionRepository_is_connected_31(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.is_connected")) {
    return nullptr;
  }
  // 1-bool CConnectionRepository::is_connected(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).is_connected)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_is_connected_31_comment =
  "C++ Interface:\n"
  "is_connected(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns true if the connection to the gameserver is established and still\n"
  " * good, false if we are not connected.  A false value means either (a) we\n"
  " * never successfully connected, (b) we explicitly called disconnect(), or (c)\n"
  " * we were connected, but the connection was spontaneously lost.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_is_connected_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CConnectionRepository::send_datagram(Datagram const &dg)
 */
static PyObject *Dtool_CConnectionRepository_send_datagram_32(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.send_datagram")) {
    return nullptr;
  }
  // 1-bool CConnectionRepository::send_datagram(Datagram const &dg)
  Datagram arg_local;
  Datagram const *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CConnectionRepository.send_datagram", "Datagram");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).send_datagram)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "send_datagram(const CConnectionRepository self, const Datagram dg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_send_datagram_32_comment =
  "C++ Interface:\n"
  "send_datagram(const CConnectionRepository self, const Datagram dg)\n"
  "\n"
  "/**\n"
  " * Queues the indicated datagram for sending to the server.  It may not get\n"
  " * sent immediately if collect_tcp is in effect; call flush() to guarantee it\n"
  " * is sent now.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_send_datagram_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_want_message_bundling(bool flag)
 */
static PyObject *Dtool_CConnectionRepository_set_want_message_bundling_33(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_want_message_bundling")) {
    return nullptr;
  }
  // 1-inline void CConnectionRepository::set_want_message_bundling(bool flag)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).set_want_message_bundling)((PyObject_IsTrue(arg) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_want_message_bundling(const CConnectionRepository self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_want_message_bundling_33_comment =
  "C++ Interface:\n"
  "set_want_message_bundling(const CConnectionRepository self, bool flag)\n"
  "\n"
  "/**\n"
  " * Enable/disable outbound message bundling\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_want_message_bundling_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::get_want_message_bundling(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_want_message_bundling_34(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConnectionRepository)) {
    return nullptr;
  }
  // 1-inline bool CConnectionRepository::get_want_message_bundling(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*(const CConnectionRepository*)local_this).get_want_message_bundling)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_want_message_bundling_34_comment =
  "C++ Interface:\n"
  "get_want_message_bundling(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns true if message bundling enabled\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_want_message_bundling_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_in_quiet_zone(bool flag)
 */
static PyObject *Dtool_CConnectionRepository_set_in_quiet_zone_35(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_in_quiet_zone")) {
    return nullptr;
  }
  // 1-inline void CConnectionRepository::set_in_quiet_zone(bool flag)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).set_in_quiet_zone)((PyObject_IsTrue(arg) != 0));
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_in_quiet_zone(const CConnectionRepository self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_in_quiet_zone_35_comment =
  "C++ Interface:\n"
  "set_in_quiet_zone(const CConnectionRepository self, bool flag)\n"
  "\n"
  "/**\n"
  " * Enables/disables quiet zone mode\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_in_quiet_zone_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::get_in_quiet_zone(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_in_quiet_zone_36(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConnectionRepository)) {
    return nullptr;
  }
  // 1-inline bool CConnectionRepository::get_in_quiet_zone(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*(const CConnectionRepository*)local_this).get_in_quiet_zone)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_in_quiet_zone_36_comment =
  "C++ Interface:\n"
  "get_in_quiet_zone(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns true if repository is in quiet zone mode\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_in_quiet_zone_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CConnectionRepository::start_message_bundle(void)
 */
static PyObject *Dtool_CConnectionRepository_start_message_bundle_37(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.start_message_bundle")) {
    return nullptr;
  }
  // 1-void CConnectionRepository::start_message_bundle(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).start_message_bundle)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_start_message_bundle_37_comment =
  "C++ Interface:\n"
  "start_message_bundle(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Send a set of messages to the state server that will be processed\n"
  " * atomically.  For instance, you can do a combined setLocation/setPos and\n"
  " * prevent race conditions where clients briefly get the setLocation but not\n"
  " * the setPos, because the state server hasn't processed the setPos yet\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_start_message_bundle_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::is_bundling_messages(void) const
 */
static PyObject *Dtool_CConnectionRepository_is_bundling_messages_38(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConnectionRepository)) {
    return nullptr;
  }
  // 1-inline bool CConnectionRepository::is_bundling_messages(void) const
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*(const CConnectionRepository*)local_this).is_bundling_messages)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_is_bundling_messages_38_comment =
  "C++ Interface:\n"
  "is_bundling_messages(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns true if repository is queueing outgoing messages into a message\n"
  " * bundle\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_is_bundling_messages_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CConnectionRepository::send_message_bundle(unsigned int channel, unsigned int sender_channel)
 */
static PyObject *Dtool_CConnectionRepository_send_message_bundle_39(PyObject *self, PyObject *args, PyObject *kwds) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.send_message_bundle")) {
    return nullptr;
  }
  // 1-void CConnectionRepository::send_message_bundle(unsigned int channel, unsigned int sender_channel)
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"channel", "sender_channel", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:send_message_bundle", (char **)keyword_list, &param1, &param2)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param2 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param2);
    }
#endif
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    PyThreadState *_save;
    Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    ((*local_this).send_message_bundle)((unsigned int)param1, (unsigned int)param2);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
    Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "send_message_bundle(const CConnectionRepository self, int channel, int sender_channel)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_send_message_bundle_39_comment =
  "C++ Interface:\n"
  "send_message_bundle(const CConnectionRepository self, int channel, int sender_channel)\n"
  "\n"
  "/**\n"
  " * Send network messages queued up since startMessageBundle was called.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_send_message_bundle_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CConnectionRepository::abandon_message_bundles(void)
 */
static PyObject *Dtool_CConnectionRepository_abandon_message_bundles_40(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.abandon_message_bundles")) {
    return nullptr;
  }
  // 1-void CConnectionRepository::abandon_message_bundles(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).abandon_message_bundles)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_abandon_message_bundles_40_comment =
  "C++ Interface:\n"
  "abandon_message_bundles(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * throw out any msgs that have been queued up for message bundles\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_abandon_message_bundles_40_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CConnectionRepository::bundle_msg(Datagram const &dg)
 */
static PyObject *Dtool_CConnectionRepository_bundle_msg_41(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.bundle_msg")) {
    return nullptr;
  }
  // 1-void CConnectionRepository::bundle_msg(Datagram const &dg)
  Datagram arg_local;
  Datagram const *arg_this = Dtool_Coerce_Datagram(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "CConnectionRepository.bundle_msg", "Datagram");
  }
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).bundle_msg)(*arg_this);
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bundle_msg(const CConnectionRepository self, const Datagram dg)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_bundle_msg_41_comment =
  "C++ Interface:\n"
  "bundle_msg(const CConnectionRepository self, const Datagram dg)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_bundle_msg_41_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CConnectionRepository::consider_flush(void)
 */
static PyObject *Dtool_CConnectionRepository_consider_flush_42(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.consider_flush")) {
    return nullptr;
  }
  // 1-bool CConnectionRepository::consider_flush(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).consider_flush)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_consider_flush_42_comment =
  "C++ Interface:\n"
  "consider_flush(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Sends the most recently queued data if enough time has elapsed.  This only\n"
  " * has meaning if set_collect_tcp() has been set to true.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_consider_flush_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool CConnectionRepository::flush(void)
 */
static PyObject *Dtool_CConnectionRepository_flush_43(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.flush")) {
    return nullptr;
  }
  // 1-bool CConnectionRepository::flush(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  bool return_value = ((*local_this).flush)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_flush_43_comment =
  "C++ Interface:\n"
  "flush(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Sends the most recently queued data now.  This only has meaning if\n"
  " * set_collect_tcp() has been set to true.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_flush_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CConnectionRepository::disconnect(void)
 */
static PyObject *Dtool_CConnectionRepository_disconnect_44(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.disconnect")) {
    return nullptr;
  }
  // 1-void CConnectionRepository::disconnect(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).disconnect)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_disconnect_44_comment =
  "C++ Interface:\n"
  "disconnect(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Closes the connection to the server.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_disconnect_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CConnectionRepository::shutdown(void)
 */
static PyObject *Dtool_CConnectionRepository_shutdown_45(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.shutdown")) {
    return nullptr;
  }
  // 1-void CConnectionRepository::shutdown(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  ((*local_this).shutdown)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_shutdown_45_comment =
  "C++ Interface:\n"
  "shutdown(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * May be called at application shutdown to ensure all threads are cleaned up.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_shutdown_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_simulated_disconnect(bool simulated_disconnect)
 */
static PyObject *Dtool_CConnectionRepository_set_simulated_disconnect_46(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_simulated_disconnect")) {
    return nullptr;
  }
  // 1-inline void CConnectionRepository::set_simulated_disconnect(bool simulated_disconnect)
  ((*local_this).set_simulated_disconnect)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_simulated_disconnect(const CConnectionRepository self, bool simulated_disconnect)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_simulated_disconnect_46_comment =
  "C++ Interface:\n"
  "set_simulated_disconnect(const CConnectionRepository self, bool simulated_disconnect)\n"
  "\n"
  "/**\n"
  " * Sets the simulated disconnect flag.  While this is true, no datagrams will\n"
  " * be retrieved from or sent to the server.  The idea is to simulate a\n"
  " * temporary network outage.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_simulated_disconnect_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::get_simulated_disconnect(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_simulated_disconnect_47(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConnectionRepository)) {
    return nullptr;
  }
  // 1-inline bool CConnectionRepository::get_simulated_disconnect(void) const
  bool return_value = ((*(const CConnectionRepository*)local_this).get_simulated_disconnect)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_simulated_disconnect_47_comment =
  "C++ Interface:\n"
  "get_simulated_disconnect(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the simulated disconnect flag.  While this is true, no datagrams\n"
  " * will be retrieved from or sent to the server.  The idea is to simulate a\n"
  " * temporary network outage.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_simulated_disconnect_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::toggle_verbose(void)
 */
static PyObject *Dtool_CConnectionRepository_toggle_verbose_48(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.toggle_verbose")) {
    return nullptr;
  }
  // 1-inline void CConnectionRepository::toggle_verbose(void)
  ((*local_this).toggle_verbose)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_toggle_verbose_48_comment =
  "C++ Interface:\n"
  "toggle_verbose(const CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Toggles the current setting of the verbose flag.  When true, this describes\n"
  " * every message going back and forth on the wire.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_toggle_verbose_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_verbose(bool verbose)
 */
static PyObject *Dtool_CConnectionRepository_set_verbose_49(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_verbose")) {
    return nullptr;
  }
  // 1-inline void CConnectionRepository::set_verbose(bool verbose)
  ((*local_this).set_verbose)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_verbose(const CConnectionRepository self, bool verbose)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_verbose_49_comment =
  "C++ Interface:\n"
  "set_verbose(const CConnectionRepository self, bool verbose)\n"
  "\n"
  "/**\n"
  " * Directly sets the verbose flag.  When true, this describes every message\n"
  " * going back and forth on the wire.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_verbose_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CConnectionRepository::get_verbose(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_verbose_50(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConnectionRepository)) {
    return nullptr;
  }
  // 1-inline bool CConnectionRepository::get_verbose(void) const
  bool return_value = ((*(const CConnectionRepository*)local_this).get_verbose)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_verbose_50_comment =
  "C++ Interface:\n"
  "get_verbose(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the verbose flag.  When true, this describes\n"
  " * every message going back and forth on the wire.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_verbose_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CConnectionRepository::set_time_warning(float time_warning)
 */
static PyObject *Dtool_CConnectionRepository_set_time_warning_51(PyObject *self, PyObject *arg) {
  CConnectionRepository *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CConnectionRepository, (void **)&local_this, "CConnectionRepository.set_time_warning")) {
    return nullptr;
  }
  // 1-inline void CConnectionRepository::set_time_warning(float time_warning)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_time_warning)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_time_warning(const CConnectionRepository self, float time_warning)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_set_time_warning_51_comment =
  "C++ Interface:\n"
  "set_time_warning(const CConnectionRepository self, float time_warning)\n"
  "\n"
  "/**\n"
  " * Directly sets the time_warning field.  When non zero, this describes every\n"
  " * message going back and forth on the wire when the msg handling time is over\n"
  " * it\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_set_time_warning_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float CConnectionRepository::get_time_warning(void) const
 */
static PyObject *Dtool_CConnectionRepository_get_time_warning_52(PyObject *self, PyObject *) {
  CConnectionRepository *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CConnectionRepository)) {
    return nullptr;
  }
  // 1-inline float CConnectionRepository::get_time_warning(void) const
  float return_value = ((*(const CConnectionRepository*)local_this).get_time_warning)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CConnectionRepository_get_time_warning_52_comment =
  "C++ Interface:\n"
  "get_time_warning(CConnectionRepository self)\n"
  "\n"
  "/**\n"
  " * Returns the current setting of the time_warning field.\n"
  " */";
#else
static const char *Dtool_CConnectionRepository_get_time_warning_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit CConnectionRepository::CConnectionRepository(bool has_owner_view = false, bool threaded_net = false)
 */
static int Dtool_Init_CConnectionRepository(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit CConnectionRepository::CConnectionRepository(bool has_owner_view = false, bool threaded_net = false)
  PyObject *param0 = Py_False;
  PyObject *param1 = Py_False;
  static const char *keyword_list[] = {"has_owner_view", "threaded_net", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|OO:CConnectionRepository", (char **)keyword_list, &param0, &param1)) {
    CConnectionRepository *return_value = new CConnectionRepository((PyObject_IsTrue(param0) != 0), (PyObject_IsTrue(param1) != 0));
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CConnectionRepository, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CConnectionRepository(bool has_owner_view, bool threaded_net)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CConnectionRepository(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CConnectionRepository) {
    printf("CConnectionRepository ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CConnectionRepository *local_this = (CConnectionRepository *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CConnectionRepository) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CConnectionRepository(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CConnectionRepository) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CDistributedSmoothNodeBase
 */
/**
 * Python function wrapper for:
 * inline void CDistributedSmoothNodeBase::set_repository(CConnectionRepository *repository, bool is_ai, CHANNEL_TYPE ai_id)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_set_repository_56(PyObject *self, PyObject *args, PyObject *kwds) {
  CDistributedSmoothNodeBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.set_repository")) {
    return nullptr;
  }
  // 1-inline void CDistributedSmoothNodeBase::set_repository(CConnectionRepository *repository, bool is_ai, CHANNEL_TYPE ai_id)
  PyObject *param1;
  PyObject *param2;
  unsigned PY_LONG_LONG param3;
  static const char *keyword_list[] = {"repository", "is_ai", "ai_id", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOK:set_repository", (char **)keyword_list, &param1, &param2, &param3)) {
    CConnectionRepository *param1_this = (CConnectionRepository *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_CConnectionRepository, 1, "CDistributedSmoothNodeBase.set_repository", false, true);
    if (param1_this != nullptr) {
      ((*local_this).set_repository)(param1_this, (PyObject_IsTrue(param2) != 0), (CHANNEL_TYPE)param3);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_repository(const CDistributedSmoothNodeBase self, CConnectionRepository repository, bool is_ai, long ai_id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_set_repository_56_comment =
  "C++ Interface:\n"
  "set_repository(const CDistributedSmoothNodeBase self, CConnectionRepository repository, bool is_ai, long ai_id)\n"
  "\n"
  "/**\n"
  " * Tells the C++ instance definition about the AI or Client repository, used\n"
  " * for sending datagrams.\n"
  " */";
#else
static const char *Dtool_CDistributedSmoothNodeBase_set_repository_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CDistributedSmoothNodeBase::set_clock_delta(PyObject *clock_delta)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_set_clock_delta_57(PyObject *self, PyObject *arg) {
  CDistributedSmoothNodeBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.set_clock_delta")) {
    return nullptr;
  }
  // 1-inline void CDistributedSmoothNodeBase::set_clock_delta(PyObject *clock_delta)
  ((*local_this).set_clock_delta)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clock_delta(const CDistributedSmoothNodeBase self, object clock_delta)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_set_clock_delta_57_comment =
  "C++ Interface:\n"
  "set_clock_delta(const CDistributedSmoothNodeBase self, object clock_delta)\n"
  "\n"
  "/**\n"
  " * Tells the C++ instance definition about the global ClockDelta object.\n"
  " */";
#else
static const char *Dtool_CDistributedSmoothNodeBase_set_clock_delta_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CDistributedSmoothNodeBase::initialize(NodePath const &node_path, DCClass *dclass, CHANNEL_TYPE do_id)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_initialize_58(PyObject *self, PyObject *args, PyObject *kwds) {
  CDistributedSmoothNodeBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.initialize")) {
    return nullptr;
  }
  // 1-void CDistributedSmoothNodeBase::initialize(NodePath const &node_path, DCClass *dclass, CHANNEL_TYPE do_id)
  PyObject *param1;
  PyObject *param2;
  unsigned PY_LONG_LONG param3;
  static const char *keyword_list[] = {"node_path", "dclass", "do_id", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOK:initialize", (char **)keyword_list, &param1, &param2, &param3)) {
    NodePath const *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_NodePath, 1, "CDistributedSmoothNodeBase.initialize", true, true);
    DCClass *param2_this = (DCClass *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_DCClass, 2, "CDistributedSmoothNodeBase.initialize", false, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      ((*local_this).initialize)(*param1_this, param2_this, (CHANNEL_TYPE)param3);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "initialize(const CDistributedSmoothNodeBase self, const NodePath node_path, DCClass dclass, long do_id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_initialize_58_comment =
  "C++ Interface:\n"
  "initialize(const CDistributedSmoothNodeBase self, const NodePath node_path, DCClass dclass, long do_id)\n"
  "\n"
  "/**\n"
  " * Initializes the internal structures from some constructs that are normally\n"
  " * stored only in Python.  Also reads the current node's pos & hpr values in\n"
  " * preparation for transmitting them via one of the broadcast_pos_hpr_*()\n"
  " * methods.\n"
  " */";
#else
static const char *Dtool_CDistributedSmoothNodeBase_initialize_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CDistributedSmoothNodeBase::send_everything(void)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_send_everything_59(PyObject *self, PyObject *) {
  CDistributedSmoothNodeBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.send_everything")) {
    return nullptr;
  }
  // 1-void CDistributedSmoothNodeBase::send_everything(void)
  ((*local_this).send_everything)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_send_everything_59_comment =
  "C++ Interface:\n"
  "send_everything(const CDistributedSmoothNodeBase self)\n"
  "\n"
  "/**\n"
  " * Broadcasts the current pos/hpr in its complete form.\n"
  " */";
#else
static const char *Dtool_CDistributedSmoothNodeBase_send_everything_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CDistributedSmoothNodeBase::broadcast_pos_hpr_full(void)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_60(PyObject *self, PyObject *) {
  CDistributedSmoothNodeBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.broadcast_pos_hpr_full")) {
    return nullptr;
  }
  // 1-void CDistributedSmoothNodeBase::broadcast_pos_hpr_full(void)
  ((*local_this).broadcast_pos_hpr_full)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_60_comment =
  "C++ Interface:\n"
  "broadcast_pos_hpr_full(const CDistributedSmoothNodeBase self)\n"
  "\n"
  "/**\n"
  " * Examines the complete pos/hpr information to see which of the six elements\n"
  " * have changed, and broadcasts the appropriate messages.\n"
  " */";
#else
static const char *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CDistributedSmoothNodeBase::broadcast_pos_hpr_xyh(void)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_61(PyObject *self, PyObject *) {
  CDistributedSmoothNodeBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.broadcast_pos_hpr_xyh")) {
    return nullptr;
  }
  // 1-void CDistributedSmoothNodeBase::broadcast_pos_hpr_xyh(void)
  ((*local_this).broadcast_pos_hpr_xyh)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_61_comment =
  "C++ Interface:\n"
  "broadcast_pos_hpr_xyh(const CDistributedSmoothNodeBase self)\n"
  "\n"
  "/**\n"
  " * Examines only X, Y, and H of the pos/hpr information, and broadcasts the\n"
  " * appropriate messages.\n"
  " */";
#else
static const char *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_61_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CDistributedSmoothNodeBase::broadcast_pos_hpr_xy(void)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_62(PyObject *self, PyObject *) {
  CDistributedSmoothNodeBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.broadcast_pos_hpr_xy")) {
    return nullptr;
  }
  // 1-void CDistributedSmoothNodeBase::broadcast_pos_hpr_xy(void)
  ((*local_this).broadcast_pos_hpr_xy)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_62_comment =
  "C++ Interface:\n"
  "broadcast_pos_hpr_xy(const CDistributedSmoothNodeBase self)\n"
  "\n"
  "/**\n"
  " * Examines only X and Y of the pos/hpr information, and broadcasts the\n"
  " * appropriate messages.\n"
  " */";
#else
static const char *Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CDistributedSmoothNodeBase::set_curr_l(uint64_t l)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_set_curr_l_63(PyObject *self, PyObject *arg) {
  CDistributedSmoothNodeBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.set_curr_l")) {
    return nullptr;
  }
  // 1-void CDistributedSmoothNodeBase::set_curr_l(uint64_t l)
  unsigned PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "K:set_curr_l", &param1)) {
    ((*local_this).set_curr_l)((uint64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_curr_l(const CDistributedSmoothNodeBase self, long l)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_set_curr_l_63_comment =
  "C++ Interface:\n"
  "set_curr_l(const CDistributedSmoothNodeBase self, long l)\n"
  "\n"
  "/**\n"
  " * Appends the timestamp and sends the update.\n"
  " */";
#else
static const char *Dtool_CDistributedSmoothNodeBase_set_curr_l_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void CDistributedSmoothNodeBase::print_curr_l(void)
 */
static PyObject *Dtool_CDistributedSmoothNodeBase_print_curr_l_64(PyObject *self, PyObject *) {
  CDistributedSmoothNodeBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CDistributedSmoothNodeBase, (void **)&local_this, "CDistributedSmoothNodeBase.print_curr_l")) {
    return nullptr;
  }
  // 1-void CDistributedSmoothNodeBase::print_curr_l(void)
  ((*local_this).print_curr_l)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CDistributedSmoothNodeBase_print_curr_l_64_comment =
  "C++ Interface:\n"
  "print_curr_l(const CDistributedSmoothNodeBase self)\n";
#else
static const char *Dtool_CDistributedSmoothNodeBase_print_curr_l_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CDistributedSmoothNodeBase::CDistributedSmoothNodeBase(void)
 * inline CDistributedSmoothNodeBase::CDistributedSmoothNodeBase(CDistributedSmoothNodeBase const &) = default
 */
static int Dtool_Init_CDistributedSmoothNodeBase(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CDistributedSmoothNodeBase() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-CDistributedSmoothNodeBase::CDistributedSmoothNodeBase(void)
      CDistributedSmoothNodeBase *return_value = new CDistributedSmoothNodeBase();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CDistributedSmoothNodeBase, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline CDistributedSmoothNodeBase::CDistributedSmoothNodeBase(CDistributedSmoothNodeBase const &) = default
      CDistributedSmoothNodeBase const *arg_this = (CDistributedSmoothNodeBase *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_CDistributedSmoothNodeBase, 0, "CDistributedSmoothNodeBase.CDistributedSmoothNodeBase", true, true);
      if (arg_this != nullptr) {
        CDistributedSmoothNodeBase *return_value = new CDistributedSmoothNodeBase(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CDistributedSmoothNodeBase, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "CDistributedSmoothNodeBase() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CDistributedSmoothNodeBase()\n"
      "CDistributedSmoothNodeBase(const CDistributedSmoothNodeBase param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_CDistributedSmoothNodeBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CDistributedSmoothNodeBase) {
    printf("CDistributedSmoothNodeBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CDistributedSmoothNodeBase *local_this = (CDistributedSmoothNodeBase *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CDistributedSmoothNodeBase) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CDistributedSmoothNodeBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CDistributedSmoothNodeBase) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python method tables for CConnectionRepository (CConnectionRepository)
 */
static PyMethodDef Dtool_Methods_CConnectionRepository[] = {
  {"get_dc_file", &Dtool_CConnectionRepository_get_dc_file_4, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_dc_file_4_comment},
  {"getDcFile", &Dtool_CConnectionRepository_get_dc_file_4, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_dc_file_4_comment},
  {"has_owner_view", &Dtool_CConnectionRepository_has_owner_view_5, METH_NOARGS, (const char *)Dtool_CConnectionRepository_has_owner_view_5_comment},
  {"hasOwnerView", &Dtool_CConnectionRepository_has_owner_view_5, METH_NOARGS, (const char *)Dtool_CConnectionRepository_has_owner_view_5_comment},
  {"set_handle_c_updates", &Dtool_CConnectionRepository_set_handle_c_updates_6, METH_O, (const char *)Dtool_CConnectionRepository_set_handle_c_updates_6_comment},
  {"setHandleCUpdates", &Dtool_CConnectionRepository_set_handle_c_updates_6, METH_O, (const char *)Dtool_CConnectionRepository_set_handle_c_updates_6_comment},
  {"get_handle_c_updates", &Dtool_CConnectionRepository_get_handle_c_updates_7, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_handle_c_updates_7_comment},
  {"getHandleCUpdates", &Dtool_CConnectionRepository_get_handle_c_updates_7, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_handle_c_updates_7_comment},
  {"set_client_datagram", &Dtool_CConnectionRepository_set_client_datagram_8, METH_O, (const char *)Dtool_CConnectionRepository_set_client_datagram_8_comment},
  {"setClientDatagram", &Dtool_CConnectionRepository_set_client_datagram_8, METH_O, (const char *)Dtool_CConnectionRepository_set_client_datagram_8_comment},
  {"get_client_datagram", &Dtool_CConnectionRepository_get_client_datagram_9, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_client_datagram_9_comment},
  {"getClientDatagram", &Dtool_CConnectionRepository_get_client_datagram_9, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_client_datagram_9_comment},
  {"set_handle_datagrams_internally", &Dtool_CConnectionRepository_set_handle_datagrams_internally_10, METH_O, (const char *)Dtool_CConnectionRepository_set_handle_datagrams_internally_10_comment},
  {"setHandleDatagramsInternally", &Dtool_CConnectionRepository_set_handle_datagrams_internally_10, METH_O, (const char *)Dtool_CConnectionRepository_set_handle_datagrams_internally_10_comment},
  {"get_handle_datagrams_internally", &Dtool_CConnectionRepository_get_handle_datagrams_internally_11, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_handle_datagrams_internally_11_comment},
  {"getHandleDatagramsInternally", &Dtool_CConnectionRepository_get_handle_datagrams_internally_11, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_handle_datagrams_internally_11_comment},
  {"set_tcp_header_size", &Dtool_CConnectionRepository_set_tcp_header_size_12, METH_O, (const char *)Dtool_CConnectionRepository_set_tcp_header_size_12_comment},
  {"setTcpHeaderSize", &Dtool_CConnectionRepository_set_tcp_header_size_12, METH_O, (const char *)Dtool_CConnectionRepository_set_tcp_header_size_12_comment},
  {"get_tcp_header_size", &Dtool_CConnectionRepository_get_tcp_header_size_13, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_tcp_header_size_13_comment},
  {"getTcpHeaderSize", &Dtool_CConnectionRepository_get_tcp_header_size_13, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_tcp_header_size_13_comment},
  {"set_python_repository", &Dtool_CConnectionRepository_set_python_repository_14, METH_O, (const char *)Dtool_CConnectionRepository_set_python_repository_14_comment},
  {"setPythonRepository", &Dtool_CConnectionRepository_set_python_repository_14, METH_O, (const char *)Dtool_CConnectionRepository_set_python_repository_14_comment},
  {"set_connection_http", &Dtool_CConnectionRepository_set_connection_http_15, METH_O, (const char *)Dtool_CConnectionRepository_set_connection_http_15_comment},
  {"setConnectionHttp", &Dtool_CConnectionRepository_set_connection_http_15, METH_O, (const char *)Dtool_CConnectionRepository_set_connection_http_15_comment},
  {"get_stream", &Dtool_CConnectionRepository_get_stream_16, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_stream_16_comment},
  {"getStream", &Dtool_CConnectionRepository_get_stream_16, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_stream_16_comment},
  {"try_connect_net", &Dtool_CConnectionRepository_try_connect_net_17, METH_O, (const char *)Dtool_CConnectionRepository_try_connect_net_17_comment},
  {"tryConnectNet", &Dtool_CConnectionRepository_try_connect_net_17, METH_O, (const char *)Dtool_CConnectionRepository_try_connect_net_17_comment},
  {"get_qcm", &Dtool_CConnectionRepository_get_qcm_18, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_qcm_18_comment},
  {"getQcm", &Dtool_CConnectionRepository_get_qcm_18, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_qcm_18_comment},
  {"get_cw", &Dtool_CConnectionRepository_get_cw_19, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_cw_19_comment},
  {"getCw", &Dtool_CConnectionRepository_get_cw_19, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_cw_19_comment},
  {"get_qcr", &Dtool_CConnectionRepository_get_qcr_20, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_qcr_20_comment},
  {"getQcr", &Dtool_CConnectionRepository_get_qcr_20, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_qcr_20_comment},
  {"connect_native", &Dtool_CConnectionRepository_connect_native_21, METH_O, (const char *)Dtool_CConnectionRepository_connect_native_21_comment},
  {"connectNative", &Dtool_CConnectionRepository_connect_native_21, METH_O, (const char *)Dtool_CConnectionRepository_connect_native_21_comment},
  {"get_bdc", &Dtool_CConnectionRepository_get_bdc_22, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_bdc_22_comment},
  {"getBdc", &Dtool_CConnectionRepository_get_bdc_22, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_bdc_22_comment},
  {"check_datagram", &Dtool_CConnectionRepository_check_datagram_23, METH_NOARGS, (const char *)Dtool_CConnectionRepository_check_datagram_23_comment},
  {"checkDatagram", &Dtool_CConnectionRepository_check_datagram_23, METH_NOARGS, (const char *)Dtool_CConnectionRepository_check_datagram_23_comment},
  {"get_datagram", &Dtool_CConnectionRepository_get_datagram_24, METH_O, (const char *)Dtool_CConnectionRepository_get_datagram_24_comment},
  {"getDatagram", &Dtool_CConnectionRepository_get_datagram_24, METH_O, (const char *)Dtool_CConnectionRepository_get_datagram_24_comment},
  {"get_datagram_iterator", &Dtool_CConnectionRepository_get_datagram_iterator_25, METH_O, (const char *)Dtool_CConnectionRepository_get_datagram_iterator_25_comment},
  {"getDatagramIterator", &Dtool_CConnectionRepository_get_datagram_iterator_25, METH_O, (const char *)Dtool_CConnectionRepository_get_datagram_iterator_25_comment},
  {"get_msg_channel", (PyCFunction) &Dtool_CConnectionRepository_get_msg_channel_26, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CConnectionRepository_get_msg_channel_26_comment},
  {"getMsgChannel", (PyCFunction) &Dtool_CConnectionRepository_get_msg_channel_26, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CConnectionRepository_get_msg_channel_26_comment},
  {"get_msg_channel_count", &Dtool_CConnectionRepository_get_msg_channel_count_27, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_msg_channel_count_27_comment},
  {"getMsgChannelCount", &Dtool_CConnectionRepository_get_msg_channel_count_27, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_msg_channel_count_27_comment},
  {"get_msg_sender", &Dtool_CConnectionRepository_get_msg_sender_28, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_msg_sender_28_comment},
  {"getMsgSender", &Dtool_CConnectionRepository_get_msg_sender_28, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_msg_sender_28_comment},
  {"get_msg_type", &Dtool_CConnectionRepository_get_msg_type_29, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_msg_type_29_comment},
  {"getMsgType", &Dtool_CConnectionRepository_get_msg_type_29, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_msg_type_29_comment},
  {"get_overflow_event_name", &Dtool_CConnectionRepository_get_overflow_event_name_30, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConnectionRepository_get_overflow_event_name_30_comment},
  {"getOverflowEventName", &Dtool_CConnectionRepository_get_overflow_event_name_30, METH_NOARGS | METH_STATIC, (const char *)Dtool_CConnectionRepository_get_overflow_event_name_30_comment},
  {"is_connected", &Dtool_CConnectionRepository_is_connected_31, METH_NOARGS, (const char *)Dtool_CConnectionRepository_is_connected_31_comment},
  {"isConnected", &Dtool_CConnectionRepository_is_connected_31, METH_NOARGS, (const char *)Dtool_CConnectionRepository_is_connected_31_comment},
  {"send_datagram", &Dtool_CConnectionRepository_send_datagram_32, METH_O, (const char *)Dtool_CConnectionRepository_send_datagram_32_comment},
  {"sendDatagram", &Dtool_CConnectionRepository_send_datagram_32, METH_O, (const char *)Dtool_CConnectionRepository_send_datagram_32_comment},
  {"set_want_message_bundling", &Dtool_CConnectionRepository_set_want_message_bundling_33, METH_O, (const char *)Dtool_CConnectionRepository_set_want_message_bundling_33_comment},
  {"setWantMessageBundling", &Dtool_CConnectionRepository_set_want_message_bundling_33, METH_O, (const char *)Dtool_CConnectionRepository_set_want_message_bundling_33_comment},
  {"get_want_message_bundling", &Dtool_CConnectionRepository_get_want_message_bundling_34, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_want_message_bundling_34_comment},
  {"getWantMessageBundling", &Dtool_CConnectionRepository_get_want_message_bundling_34, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_want_message_bundling_34_comment},
  {"set_in_quiet_zone", &Dtool_CConnectionRepository_set_in_quiet_zone_35, METH_O, (const char *)Dtool_CConnectionRepository_set_in_quiet_zone_35_comment},
  {"setInQuietZone", &Dtool_CConnectionRepository_set_in_quiet_zone_35, METH_O, (const char *)Dtool_CConnectionRepository_set_in_quiet_zone_35_comment},
  {"get_in_quiet_zone", &Dtool_CConnectionRepository_get_in_quiet_zone_36, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_in_quiet_zone_36_comment},
  {"getInQuietZone", &Dtool_CConnectionRepository_get_in_quiet_zone_36, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_in_quiet_zone_36_comment},
  {"start_message_bundle", &Dtool_CConnectionRepository_start_message_bundle_37, METH_NOARGS, (const char *)Dtool_CConnectionRepository_start_message_bundle_37_comment},
  {"startMessageBundle", &Dtool_CConnectionRepository_start_message_bundle_37, METH_NOARGS, (const char *)Dtool_CConnectionRepository_start_message_bundle_37_comment},
  {"is_bundling_messages", &Dtool_CConnectionRepository_is_bundling_messages_38, METH_NOARGS, (const char *)Dtool_CConnectionRepository_is_bundling_messages_38_comment},
  {"isBundlingMessages", &Dtool_CConnectionRepository_is_bundling_messages_38, METH_NOARGS, (const char *)Dtool_CConnectionRepository_is_bundling_messages_38_comment},
  {"send_message_bundle", (PyCFunction) &Dtool_CConnectionRepository_send_message_bundle_39, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CConnectionRepository_send_message_bundle_39_comment},
  {"sendMessageBundle", (PyCFunction) &Dtool_CConnectionRepository_send_message_bundle_39, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CConnectionRepository_send_message_bundle_39_comment},
  {"abandon_message_bundles", &Dtool_CConnectionRepository_abandon_message_bundles_40, METH_NOARGS, (const char *)Dtool_CConnectionRepository_abandon_message_bundles_40_comment},
  {"abandonMessageBundles", &Dtool_CConnectionRepository_abandon_message_bundles_40, METH_NOARGS, (const char *)Dtool_CConnectionRepository_abandon_message_bundles_40_comment},
  {"bundle_msg", &Dtool_CConnectionRepository_bundle_msg_41, METH_O, (const char *)Dtool_CConnectionRepository_bundle_msg_41_comment},
  {"bundleMsg", &Dtool_CConnectionRepository_bundle_msg_41, METH_O, (const char *)Dtool_CConnectionRepository_bundle_msg_41_comment},
  {"consider_flush", &Dtool_CConnectionRepository_consider_flush_42, METH_NOARGS, (const char *)Dtool_CConnectionRepository_consider_flush_42_comment},
  {"considerFlush", &Dtool_CConnectionRepository_consider_flush_42, METH_NOARGS, (const char *)Dtool_CConnectionRepository_consider_flush_42_comment},
  {"flush", &Dtool_CConnectionRepository_flush_43, METH_NOARGS, (const char *)Dtool_CConnectionRepository_flush_43_comment},
  {"disconnect", &Dtool_CConnectionRepository_disconnect_44, METH_NOARGS, (const char *)Dtool_CConnectionRepository_disconnect_44_comment},
  {"shutdown", &Dtool_CConnectionRepository_shutdown_45, METH_NOARGS, (const char *)Dtool_CConnectionRepository_shutdown_45_comment},
  {"set_simulated_disconnect", &Dtool_CConnectionRepository_set_simulated_disconnect_46, METH_O, (const char *)Dtool_CConnectionRepository_set_simulated_disconnect_46_comment},
  {"setSimulatedDisconnect", &Dtool_CConnectionRepository_set_simulated_disconnect_46, METH_O, (const char *)Dtool_CConnectionRepository_set_simulated_disconnect_46_comment},
  {"get_simulated_disconnect", &Dtool_CConnectionRepository_get_simulated_disconnect_47, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_simulated_disconnect_47_comment},
  {"getSimulatedDisconnect", &Dtool_CConnectionRepository_get_simulated_disconnect_47, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_simulated_disconnect_47_comment},
  {"toggle_verbose", &Dtool_CConnectionRepository_toggle_verbose_48, METH_NOARGS, (const char *)Dtool_CConnectionRepository_toggle_verbose_48_comment},
  {"toggleVerbose", &Dtool_CConnectionRepository_toggle_verbose_48, METH_NOARGS, (const char *)Dtool_CConnectionRepository_toggle_verbose_48_comment},
  {"set_verbose", &Dtool_CConnectionRepository_set_verbose_49, METH_O, (const char *)Dtool_CConnectionRepository_set_verbose_49_comment},
  {"setVerbose", &Dtool_CConnectionRepository_set_verbose_49, METH_O, (const char *)Dtool_CConnectionRepository_set_verbose_49_comment},
  {"get_verbose", &Dtool_CConnectionRepository_get_verbose_50, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_verbose_50_comment},
  {"getVerbose", &Dtool_CConnectionRepository_get_verbose_50, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_verbose_50_comment},
  {"set_time_warning", &Dtool_CConnectionRepository_set_time_warning_51, METH_O, (const char *)Dtool_CConnectionRepository_set_time_warning_51_comment},
  {"setTimeWarning", &Dtool_CConnectionRepository_set_time_warning_51, METH_O, (const char *)Dtool_CConnectionRepository_set_time_warning_51_comment},
  {"get_time_warning", &Dtool_CConnectionRepository_get_time_warning_52, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_time_warning_52_comment},
  {"getTimeWarning", &Dtool_CConnectionRepository_get_time_warning_52, METH_NOARGS, (const char *)Dtool_CConnectionRepository_get_time_warning_52_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CConnectionRepository = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_CConnectionRepository = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.CConnectionRepository",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CConnectionRepository,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CConnectionRepository,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class implements the C++ side of the ConnectionRepository object.  In\n"
    " * particular, it manages the connection to the server once it has been opened\n"
    " * (but does not open it directly).  It manages reading and writing datagrams\n"
    " * on the connection and monitoring for unexpected disconnects as well as\n"
    " * handling intentional disconnects.\n"
    " *\n"
    " * Certain server messages, like field updates, are handled entirely within\n"
    " * the C++ layer, while server messages that are not understood by the C++\n"
    " * layer are returned up to the Python layer for processing.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CConnectionRepository,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CConnectionRepository,
    PyType_GenericAlloc,
    Dtool_new_CConnectionRepository,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CConnectionRepository,
  Dtool_UpcastInterface_CConnectionRepository,
  Dtool_DowncastInterface_CConnectionRepository,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CConnectionRepository(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_CConnectionRepository._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CConnectionRepository._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CConnectionRepository) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CConnectionRepository)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CConnectionRepository);
  }
}

/**
 * Python method tables for CDistributedSmoothNodeBase (CDistributedSmoothNodeBase)
 */
static PyMethodDef Dtool_Methods_CDistributedSmoothNodeBase[] = {
  {"set_repository", (PyCFunction) &Dtool_CDistributedSmoothNodeBase_set_repository_56, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CDistributedSmoothNodeBase_set_repository_56_comment},
  {"setRepository", (PyCFunction) &Dtool_CDistributedSmoothNodeBase_set_repository_56, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CDistributedSmoothNodeBase_set_repository_56_comment},
  {"set_clock_delta", &Dtool_CDistributedSmoothNodeBase_set_clock_delta_57, METH_O, (const char *)Dtool_CDistributedSmoothNodeBase_set_clock_delta_57_comment},
  {"setClockDelta", &Dtool_CDistributedSmoothNodeBase_set_clock_delta_57, METH_O, (const char *)Dtool_CDistributedSmoothNodeBase_set_clock_delta_57_comment},
  {"initialize", (PyCFunction) &Dtool_CDistributedSmoothNodeBase_initialize_58, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_CDistributedSmoothNodeBase_initialize_58_comment},
  {"send_everything", &Dtool_CDistributedSmoothNodeBase_send_everything_59, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_send_everything_59_comment},
  {"sendEverything", &Dtool_CDistributedSmoothNodeBase_send_everything_59, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_send_everything_59_comment},
  {"broadcast_pos_hpr_full", &Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_60, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_60_comment},
  {"broadcastPosHprFull", &Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_60, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_full_60_comment},
  {"broadcast_pos_hpr_xyh", &Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_61, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_61_comment},
  {"broadcastPosHprXyh", &Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_61, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xyh_61_comment},
  {"broadcast_pos_hpr_xy", &Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_62, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_62_comment},
  {"broadcastPosHprXy", &Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_62, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_broadcast_pos_hpr_xy_62_comment},
  {"set_curr_l", &Dtool_CDistributedSmoothNodeBase_set_curr_l_63, METH_O, (const char *)Dtool_CDistributedSmoothNodeBase_set_curr_l_63_comment},
  {"setCurrL", &Dtool_CDistributedSmoothNodeBase_set_curr_l_63, METH_O, (const char *)Dtool_CDistributedSmoothNodeBase_set_curr_l_63_comment},
  {"print_curr_l", &Dtool_CDistributedSmoothNodeBase_print_curr_l_64, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_print_curr_l_64_comment},
  {"printCurrL", &Dtool_CDistributedSmoothNodeBase_print_curr_l_64, METH_NOARGS, (const char *)Dtool_CDistributedSmoothNodeBase_print_curr_l_64_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CDistributedSmoothNodeBase = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_CDistributedSmoothNodeBase = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.direct.CDistributedSmoothNodeBase",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CDistributedSmoothNodeBase,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CDistributedSmoothNodeBase,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class defines some basic methods of DistributedSmoothNodeBase which\n"
    " * have been moved into C++ as a performance optimization.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CDistributedSmoothNodeBase,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CDistributedSmoothNodeBase,
    PyType_GenericAlloc,
    Dtool_new_CDistributedSmoothNodeBase,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CDistributedSmoothNodeBase,
  Dtool_UpcastInterface_CDistributedSmoothNodeBase,
  Dtool_DowncastInterface_CDistributedSmoothNodeBase,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CDistributedSmoothNodeBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_CDistributedSmoothNodeBase._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CDistributedSmoothNodeBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CDistributedSmoothNodeBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CDistributedSmoothNodeBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CDistributedSmoothNodeBase);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3distributed_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
}

void Dtool_libp3distributed_BuildInstants(PyObject *module) {
  (void) module;
  // CConnectionRepository
  Dtool_PyModuleClassInit_CConnectionRepository(module);
  PyModule_AddObject(module, "CConnectionRepository", (PyObject *)&Dtool_CConnectionRepository);
  // CDistributedSmoothNodeBase
  Dtool_PyModuleClassInit_CDistributedSmoothNodeBase(module);
  PyModule_AddObject(module, "CDistributedSmoothNodeBase", (PyObject *)&Dtool_CDistributedSmoothNodeBase);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3distributed_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3distributed_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583614783,  /* file_identifier */
  "libp3distributed",  /* library_name */
  "nqI8",  /* library_hash_name */
  "panda3d.direct",  /* module_name */
  "libp3distributed.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  172  /* next_index */
};

Configure(_in_configure_libp3distributed);
ConfigureFn(_in_configure_libp3distributed) {
  interrogate_request_module(&_in_module_def);
}

