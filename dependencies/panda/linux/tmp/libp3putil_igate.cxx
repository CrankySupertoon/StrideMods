/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/putil -Ipanda/src/putil -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3putil_igate.cxx -od built/pandac/input/libp3putil.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/putil -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.core -library libp3putil animInterface.h autoTextureScale.h bam.h bamCache.h bamCacheIndex.h bamCacheRecord.h bamEnums.h bamReader.h bamReaderParam.h bamReader_ext.h bamWriter.h bitArray.h bitMask.h buttonHandle.h buttonMap.h buttonRegistry.h cPointerCallbackObject.h cachedTypedWritableReferenceCount.h callbackData.h callbackObject.h callbackObject_ext.h clockObject.h collideMask.h colorSpace.h compareTo.h config_putil.h configurable.h copyOnWriteObject.h copyOnWritePointer.h datagramBuffer.h datagramInputFile.h datagramOutputFile.h doubleBitMask.h drawMask.h factory.h factoryBase.h factoryParam.h factoryParams.h firstOfPairCompare.h firstOfPairLess.h gamepadButton.h globalPointerRegistry.h indirectCompareNames.h indirectCompareSort.h indirectCompareTo.h ioPtaDatagramFloat.h ioPtaDatagramInt.h ioPtaDatagramShort.h iterator_types.h keyboardButton.h linkedListNode.h load_prc_file.h loaderOptions.h modifierButtons.h mouseButton.h mouseData.h nameUniquifier.h nodeCachedReferenceCount.h p3putil_composite1.cxx p3putil_composite2.cxx p3putil_ext_composite.cxx paramValue.h pbitops.h pointerData.h portalMask.h pta_ushort.h pythonCallbackObject.h simpleHashMap.h sparseArray.h timedCycle.h typedWritable.h typedWritableReferenceCount.h typedWritable_ext.h uniqueIdAllocator.h updateSeq.h vector_typedWritable.h vector_ulong.h vector_ushort.h vector_writable.h writableConfigurable.h writableParam.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include <algorithm>
#include "animInterface.h"
#include "autoTextureScale.h"
#include "bam.h"
#include "bamCache.h"
#include "bamCacheIndex.h"
#include "bamCacheRecord.h"
#include "bamEnums.h"
#include "bamReader.h"
#include "bamReaderParam.h"
#include "bamReader_ext.h"
#include "bamWriter.h"
#include "bitArray.h"
#include "bitMask.h"
#include "buttonHandle.h"
#include "buttonMap.h"
#include "buttonRegistry.h"
#include "cPointerCallbackObject.h"
#include "cachedTypedWritableReferenceCount.h"
#include "callbackData.h"
#include "callbackObject.h"
#include "callbackObject_ext.h"
#include "checksumHashGenerator.h"
#include "clockObject.h"
#include "collideMask.h"
#include "colorSpace.h"
#include "compareTo.h"
#include "conditionVar.h"
#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "configVariableEnum.h"
#include "configVariableInt.h"
#include "configVariableSearchPath.h"
#include "config_putil.h"
#include "configurable.h"
#include "copyOnWriteObject.h"
#include "copyOnWritePointer.h"
#include "cycleData.h"
#include "cycleDataReader.h"
#include "cycleDataStageReader.h"
#include "cycleDataWriter.h"
#include "datagramBuffer.h"
#include "datagramGenerator.h"
#include "datagramInputFile.h"
#include "datagramIterator.h"
#include "datagramOutputFile.h"
#include "datagramSink.h"
#include "dcast.h"
#include "dconfig.h"
#include "doubleBitMask.h"
#include "drawMask.h"
#include "dtoolbase.h"
#include "extension.h"
#include "factory.h"
#include "factoryBase.h"
#include "factoryParam.h"
#include "factoryParams.h"
#include "fileReference.h"
#include "filename.h"
#include "firstOfPairCompare.h"
#include "firstOfPairLess.h"
#include "gamepadButton.h"
#include "globalPointerRegistry.h"
#include "indent.h"
#include "indirectCompareNames.h"
#include "indirectCompareSort.h"
#include "indirectCompareTo.h"
#include "ioPtaDatagramFloat.h"
#include "ioPtaDatagramInt.h"
#include "ioPtaDatagramShort.h"
#include "iterator_types.h"
#include "keyboardButton.h"
#include "linkedListNode.h"
#include "load_prc_file.h"
#include "loaderOptions.h"
#include "modifierButtons.h"
#include "mouseButton.h"
#include "mouseData.h"
#include "mutexHolder.h"
#include "nameUniquifier.h"
#include "nodeCachedReferenceCount.h"
#include "nodeReferenceCount.h"
#include "notifyCategoryProxy.h"
#include "numeric_types.h"
#include "pandabase.h"
#include "paramValue.h"
#include "pbitops.h"
#include "pdeque.h"
#include "pipelineCycler.h"
#include "pipelineCyclerBase.h"
#include "pmap.h"
#include "pmutex.h"
#include "pnotify.h"
#include "pointerData.h"
#include "pointerTo.h"
#include "pointerToArray.h"
#include "pointerToArray_ext.h"
#include "portalMask.h"
#include "pset.h"
#include "pta_int.h"
#include "pta_stdfloat.h"
#include "pta_ushort.h"
#include "pvector.h"
#include "py_panda.h"
#include "pythonCallbackObject.h"
#include "reMutex.h"
#include "reMutexHolder.h"
#include "referenceCount.h"
#include "register_type.h"
#include "simpleHashMap.h"
#include "sparseArray.h"
#include <string>
#include "subfileInfo.h"
#include "thread.h"
#include <time.h>
#include "timedCycle.h"
#include "trueClock.h"
#include "typeHandle.h"
#include "typedObject.h"
#include "typedReferenceCount.h"
#include "typedWritable.h"
#include "typedWritableReferenceCount.h"
#include "typedWritable_ext.h"
#include "typedef.h"
#include "uniqueIdAllocator.h"
#include "updateSeq.h"
#include "vector_double.h"
#include "vector_int.h"
#include "vector_typedWritable.h"
#include "vector_uchar.h"
#include "vector_ulong.h"
#include "vector_ushort.h"
#include "vector_writable.h"
#include "virtualFile.h"
#include "virtualFileSystem.h"
#include "writableConfigurable.h"
#include "writableParam.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class ConstPointerToArray_ushort
 */
typedef ConstPointerToArray< ushort > ConstPointerToArray_ushort_localtype;
Define_Module_Class(panda3d.core, ConstPointerToArray_ushort, ConstPointerToArray_ushort_localtype, ConstPointerToArray_ushort);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConstPointerToArray_ushort = &Dtool_ConstPointerToArray_ushort;
static void Dtool_PyModuleClassInit_ConstPointerToArray_ushort(PyObject *module);
ConstPointerToArray< ushort > *Dtool_Coerce_ConstPointerToArray_ushort(PyObject *args, ConstPointerToArray< ushort > &coerced);

/**
 * Forward declarations for top-level class PointerToArrayBase_ushort
 */
typedef PointerToArrayBase< ushort > PointerToArrayBase_ushort_localtype;
Define_Module_Class(panda3d.core, PointerToArrayBase_ushort, PointerToArrayBase_ushort_localtype, PointerToArrayBase_ushort);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArrayBase_ushort = &Dtool_PointerToArrayBase_ushort;
static void Dtool_PyModuleClassInit_PointerToArrayBase_ushort(PyObject *module);

/**
 * Forward declarations for top-level class PointerToBase_ReferenceCountedVector_ushort
 */
typedef PointerToBase< ReferenceCountedVector< ushort > > PointerToBase_ReferenceCountedVector_ushort_localtype;
Define_Module_Class_Private(panda3d.core, PointerToBase_ReferenceCountedVector_ushort, PointerToBase_ReferenceCountedVector_ushort_localtype, PointerToBase_ReferenceCountedVector_ushort);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort = &Dtool_PointerToBase_ReferenceCountedVector_ushort;
static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_ushort(PyObject *module);

/**
 * Forward declarations for top-level class PointerToArray_ushort
 */
typedef PointerToArray< ushort > PointerToArray_ushort_localtype;
Define_Module_Class(panda3d.core, PointerToArray_ushort, PointerToArray_ushort_localtype, PointerToArray_ushort);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToArray_ushort = &Dtool_PointerToArray_ushort;
static void Dtool_PyModuleClassInit_PointerToArray_ushort(PyObject *module);
PointerToArray< ushort > *Dtool_Coerce_PointerToArray_ushort(PyObject *args, PointerToArray< ushort > &coerced);

/**
 * Forward declarations for top-level class AnimInterface
 */
typedef AnimInterface AnimInterface_localtype;
Define_Module_Class(panda3d.core, AnimInterface, AnimInterface_localtype, AnimInterface);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AnimInterface = &Dtool_AnimInterface;
static void Dtool_PyModuleClassInit_AnimInterface(PyObject *module);

/**
 * Forward declarations for top-level class UpdateSeq
 */
typedef UpdateSeq UpdateSeq_localtype;
Define_Module_Class(panda3d.core, UpdateSeq, UpdateSeq_localtype, UpdateSeq);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UpdateSeq = &Dtool_UpdateSeq;
static void Dtool_PyModuleClassInit_UpdateSeq(PyObject *module);

/**
 * Forward declarations for top-level class TypedWritable
 */
typedef TypedWritable TypedWritable_localtype;
Define_Module_Class(panda3d.core, TypedWritable, TypedWritable_localtype, TypedWritable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
static void Dtool_PyModuleClassInit_TypedWritable(PyObject *module);

/**
 * Forward declarations for top-level class TypedWritableReferenceCount
 */
typedef TypedWritableReferenceCount TypedWritableReferenceCount_localtype;
Define_Module_ClassRef(panda3d.core, TypedWritableReferenceCount, TypedWritableReferenceCount_localtype, TypedWritableReferenceCount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
static void Dtool_PyModuleClassInit_TypedWritableReferenceCount(PyObject *module);

/**
 * Forward declarations for top-level class BamCacheRecord
 */
typedef BamCacheRecord BamCacheRecord_localtype;
Define_Module_ClassRef(panda3d.core, BamCacheRecord, BamCacheRecord_localtype, BamCacheRecord);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamCacheRecord = &Dtool_BamCacheRecord;
static void Dtool_PyModuleClassInit_BamCacheRecord(PyObject *module);

/**
 * Forward declarations for top-level class BamCache
 */
typedef BamCache BamCache_localtype;
Define_Module_Class(panda3d.core, BamCache, BamCache_localtype, BamCache);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamCache = &Dtool_BamCache;
static void Dtool_PyModuleClassInit_BamCache(PyObject *module);

/**
 * Forward declarations for top-level class BamEnums
 */
typedef BamEnums BamEnums_localtype;
Define_Module_Class(panda3d.core, BamEnums, BamEnums_localtype, BamEnums);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamEnums = &Dtool_BamEnums;
static void Dtool_PyModuleClassInit_BamEnums(PyObject *module);

/**
 * Forward declarations for top-level class LoaderOptions
 */
typedef LoaderOptions LoaderOptions_localtype;
Define_Module_Class(panda3d.core, LoaderOptions, LoaderOptions_localtype, LoaderOptions);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LoaderOptions = &Dtool_LoaderOptions;
static void Dtool_PyModuleClassInit_LoaderOptions(PyObject *module);
LoaderOptions *Dtool_Coerce_LoaderOptions(PyObject *args, LoaderOptions &coerced);

/**
 * Forward declarations for top-level class BamReader
 */
typedef BamReader BamReader_localtype;
Define_Module_Class(panda3d.core, BamReader, BamReader_localtype, BamReader);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamReader = &Dtool_BamReader;
static void Dtool_PyModuleClassInit_BamReader(PyObject *module);

/**
 * Forward declarations for top-level class BamWriter
 */
typedef BamWriter BamWriter_localtype;
Define_Module_Class(panda3d.core, BamWriter, BamWriter_localtype, BamWriter);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BamWriter = &Dtool_BamWriter;
static void Dtool_PyModuleClassInit_BamWriter(PyObject *module);

/**
 * Forward declarations for top-level class BitMask_uint16_t_16
 */
typedef BitMask< uint16_t, 16 > BitMask_uint16_t_16_localtype;
Define_Module_Class(panda3d.core, BitMask_uint16_t_16, BitMask_uint16_t_16_localtype, BitMask_uint16_t_16);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint16_t_16 = &Dtool_BitMask_uint16_t_16;
static void Dtool_PyModuleClassInit_BitMask_uint16_t_16(PyObject *module);
BitMask< uint16_t, 16 > *Dtool_Coerce_BitMask_uint16_t_16(PyObject *args, BitMask< uint16_t, 16 > &coerced);

/**
 * Forward declarations for top-level class BitMask_uint32_t_32
 */
typedef BitMask< uint32_t, 32 > BitMask_uint32_t_32_localtype;
Define_Module_Class(panda3d.core, BitMask_uint32_t_32, BitMask_uint32_t_32_localtype, BitMask_uint32_t_32);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint32_t_32 = &Dtool_BitMask_uint32_t_32;
static void Dtool_PyModuleClassInit_BitMask_uint32_t_32(PyObject *module);
BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced);

/**
 * Forward declarations for top-level class BitMask_uint64_t_64
 */
typedef BitMask< uint64_t, 64 > BitMask_uint64_t_64_localtype;
Define_Module_Class(panda3d.core, BitMask_uint64_t_64, BitMask_uint64_t_64_localtype, BitMask_uint64_t_64);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitMask_uint64_t_64 = &Dtool_BitMask_uint64_t_64;
static void Dtool_PyModuleClassInit_BitMask_uint64_t_64(PyObject *module);
BitMask< uint64_t, 64 > *Dtool_Coerce_BitMask_uint64_t_64(PyObject *args, BitMask< uint64_t, 64 > &coerced);

/**
 * Forward declarations for top-level class BitArray
 */
typedef BitArray BitArray_localtype;
Define_Module_Class(panda3d.core, BitArray, BitArray_localtype, BitArray);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BitArray = &Dtool_BitArray;
static void Dtool_PyModuleClassInit_BitArray(PyObject *module);
BitArray *Dtool_Coerce_BitArray(PyObject *args, BitArray &coerced);

/**
 * Forward declarations for top-level class ButtonHandle
 */
typedef ButtonHandle ButtonHandle_localtype;
Define_Module_Class(panda3d.core, ButtonHandle, ButtonHandle_localtype, ButtonHandle);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ButtonHandle = &Dtool_ButtonHandle;
static void Dtool_PyModuleClassInit_ButtonHandle(PyObject *module);
ButtonHandle *Dtool_Coerce_ButtonHandle(PyObject *args, ButtonHandle &coerced);

/**
 * Forward declarations for top-level class ButtonRegistry
 */
typedef ButtonRegistry ButtonRegistry_localtype;
Define_Module_Class(panda3d.core, ButtonRegistry, ButtonRegistry_localtype, ButtonRegistry);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ButtonRegistry = &Dtool_ButtonRegistry;
static void Dtool_PyModuleClassInit_ButtonRegistry(PyObject *module);

/**
 * Forward declarations for top-level class ButtonMap
 */
typedef ButtonMap ButtonMap_localtype;
Define_Module_ClassRef(panda3d.core, ButtonMap, ButtonMap_localtype, ButtonMap);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ButtonMap = &Dtool_ButtonMap;
static void Dtool_PyModuleClassInit_ButtonMap(PyObject *module);

/**
 * Forward declarations for top-level class CallbackObject
 */
typedef CallbackObject CallbackObject_localtype;
Define_Module_ClassRef(panda3d.core, CallbackObject, CallbackObject_localtype, CallbackObject);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackObject = &Dtool_CallbackObject;
static void Dtool_PyModuleClassInit_CallbackObject(PyObject *module);
bool Dtool_ConstCoerce_CallbackObject(PyObject *args, CPT(CallbackObject) &coerced);
bool Dtool_Coerce_CallbackObject(PyObject *args, PT(CallbackObject) &coerced);

/**
 * Forward declarations for top-level class CachedTypedWritableReferenceCount
 */
typedef CachedTypedWritableReferenceCount CachedTypedWritableReferenceCount_localtype;
Define_Module_ClassRef_Private(panda3d.core, CachedTypedWritableReferenceCount, CachedTypedWritableReferenceCount_localtype, CachedTypedWritableReferenceCount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CachedTypedWritableReferenceCount = &Dtool_CachedTypedWritableReferenceCount;
static void Dtool_PyModuleClassInit_CachedTypedWritableReferenceCount(PyObject *module);

/**
 * Forward declarations for top-level class CallbackData
 */
typedef CallbackData CallbackData_localtype;
Define_Module_Class(panda3d.core, CallbackData, CallbackData_localtype, CallbackData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackData = &Dtool_CallbackData;
static void Dtool_PyModuleClassInit_CallbackData(PyObject *module);

/**
 * Forward declarations for top-level class PythonCallbackObject
 */
typedef PythonCallbackObject PythonCallbackObject_localtype;
Define_Module_ClassRef(panda3d.core, PythonCallbackObject, PythonCallbackObject_localtype, PythonCallbackObject);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PythonCallbackObject = &Dtool_PythonCallbackObject;
static void Dtool_PyModuleClassInit_PythonCallbackObject(PyObject *module);
bool Dtool_ConstCoerce_PythonCallbackObject(PyObject *args, CPT(PythonCallbackObject) &coerced);
bool Dtool_Coerce_PythonCallbackObject(PyObject *args, PT(PythonCallbackObject) &coerced);

/**
 * Forward declarations for top-level class TimeVal
 */
typedef TimeVal TimeVal_localtype;
Define_Module_Class(panda3d.core, TimeVal, TimeVal_localtype, TimeVal);
static struct Dtool_PyTypedObject *const Dtool_Ptr_TimeVal = &Dtool_TimeVal;
static void Dtool_PyModuleClassInit_TimeVal(PyObject *module);

/**
 * Forward declarations for top-level class ClockObject
 */
typedef ClockObject ClockObject_localtype;
Define_Module_ClassRef(panda3d.core, ClockObject, ClockObject_localtype, ClockObject);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ClockObject = &Dtool_ClockObject;
static void Dtool_PyModuleClassInit_ClockObject(PyObject *module);
bool Dtool_ConstCoerce_ClockObject(PyObject *args, CPT(ClockObject) &coerced);
bool Dtool_Coerce_ClockObject(PyObject *args, PT(ClockObject) &coerced);

/**
 * Forward declarations for top-level class CopyOnWriteObject
 */
typedef CopyOnWriteObject CopyOnWriteObject_localtype;
Define_Module_ClassRef(panda3d.core, CopyOnWriteObject, CopyOnWriteObject_localtype, CopyOnWriteObject);
static struct Dtool_PyTypedObject *const Dtool_Ptr_CopyOnWriteObject = &Dtool_CopyOnWriteObject;
static void Dtool_PyModuleClassInit_CopyOnWriteObject(PyObject *module);

/**
 * Forward declarations for top-level class DatagramBuffer
 */
typedef DatagramBuffer DatagramBuffer_localtype;
Define_Module_Class(panda3d.core, DatagramBuffer, DatagramBuffer_localtype, DatagramBuffer);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramBuffer = &Dtool_DatagramBuffer;
static void Dtool_PyModuleClassInit_DatagramBuffer(PyObject *module);

/**
 * Forward declarations for top-level class DatagramInputFile
 */
typedef DatagramInputFile DatagramInputFile_localtype;
Define_Module_Class(panda3d.core, DatagramInputFile, DatagramInputFile_localtype, DatagramInputFile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramInputFile = &Dtool_DatagramInputFile;
static void Dtool_PyModuleClassInit_DatagramInputFile(PyObject *module);

/**
 * Forward declarations for top-level class DatagramOutputFile
 */
typedef DatagramOutputFile DatagramOutputFile_localtype;
Define_Module_Class(panda3d.core, DatagramOutputFile, DatagramOutputFile_localtype, DatagramOutputFile);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramOutputFile = &Dtool_DatagramOutputFile;
static void Dtool_PyModuleClassInit_DatagramOutputFile(PyObject *module);

/**
 * Forward declarations for top-level class DoubleBitMask_BitMaskNative
 */
typedef DoubleBitMask< BitMaskNative > DoubleBitMask_BitMaskNative_localtype;
Define_Module_Class(panda3d.core, DoubleBitMask_BitMaskNative, DoubleBitMask_BitMaskNative_localtype, DoubleBitMask_BitMaskNative);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DoubleBitMask_BitMaskNative = &Dtool_DoubleBitMask_BitMaskNative;
static void Dtool_PyModuleClassInit_DoubleBitMask_BitMaskNative(PyObject *module);

/**
 * Forward declarations for top-level class DoubleBitMask_DoubleBitMaskNative
 */
typedef DoubleBitMask< DoubleBitMaskNative > DoubleBitMask_DoubleBitMaskNative_localtype;
Define_Module_Class(panda3d.core, DoubleBitMask_DoubleBitMaskNative, DoubleBitMask_DoubleBitMaskNative_localtype, DoubleBitMask_DoubleBitMaskNative);
static struct Dtool_PyTypedObject *const Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative = &Dtool_DoubleBitMask_DoubleBitMaskNative;
static void Dtool_PyModuleClassInit_DoubleBitMask_DoubleBitMaskNative(PyObject *module);

/**
 * Forward declarations for top-level class GamepadButton
 */
typedef GamepadButton GamepadButton_localtype;
Define_Module_Class(panda3d.core, GamepadButton, GamepadButton_localtype, GamepadButton);
static struct Dtool_PyTypedObject *const Dtool_Ptr_GamepadButton = &Dtool_GamepadButton;
static void Dtool_PyModuleClassInit_GamepadButton(PyObject *module);

/**
 * Forward declarations for top-level class KeyboardButton
 */
typedef KeyboardButton KeyboardButton_localtype;
Define_Module_Class(panda3d.core, KeyboardButton, KeyboardButton_localtype, KeyboardButton);
static struct Dtool_PyTypedObject *const Dtool_Ptr_KeyboardButton = &Dtool_KeyboardButton;
static void Dtool_PyModuleClassInit_KeyboardButton(PyObject *module);

/**
 * Forward declarations for top-level class ModifierButtons
 */
typedef ModifierButtons ModifierButtons_localtype;
Define_Module_Class(panda3d.core, ModifierButtons, ModifierButtons_localtype, ModifierButtons);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ModifierButtons = &Dtool_ModifierButtons;
static void Dtool_PyModuleClassInit_ModifierButtons(PyObject *module);

/**
 * Forward declarations for top-level class MouseButton
 */
typedef MouseButton MouseButton_localtype;
Define_Module_Class(panda3d.core, MouseButton, MouseButton_localtype, MouseButton);
static struct Dtool_PyTypedObject *const Dtool_Ptr_MouseButton = &Dtool_MouseButton;
static void Dtool_PyModuleClassInit_MouseButton(PyObject *module);

static PyTypeObject *Dtool_Ptr_PointerType = nullptr;
/**
 * Forward declarations for top-level class PointerData
 */
typedef PointerData PointerData_localtype;
Define_Module_Class(panda3d.core, PointerData, PointerData_localtype, PointerData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerData = &Dtool_PointerData;
static void Dtool_PyModuleClassInit_PointerData(PyObject *module);

/**
 * Forward declarations for top-level class NodeCachedReferenceCount
 */
typedef NodeCachedReferenceCount NodeCachedReferenceCount_localtype;
Define_Module_ClassRef_Private(panda3d.core, NodeCachedReferenceCount, NodeCachedReferenceCount_localtype, NodeCachedReferenceCount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodeCachedReferenceCount = &Dtool_NodeCachedReferenceCount;
static void Dtool_PyModuleClassInit_NodeCachedReferenceCount(PyObject *module);

/**
 * Forward declarations for top-level class SparseArray
 */
typedef SparseArray SparseArray_localtype;
Define_Module_Class(panda3d.core, SparseArray, SparseArray_localtype, SparseArray);
static struct Dtool_PyTypedObject *const Dtool_Ptr_SparseArray = &Dtool_SparseArray;
static void Dtool_PyModuleClassInit_SparseArray(PyObject *module);
SparseArray *Dtool_Coerce_SparseArray(PyObject *args, SparseArray &coerced);

/**
 * Forward declarations for top-level class ParamValueBase
 */
typedef ParamValueBase ParamValueBase_localtype;
Define_Module_ClassRef(panda3d.core, ParamValueBase, ParamValueBase_localtype, ParamValueBase);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValueBase = &Dtool_ParamValueBase;
static void Dtool_PyModuleClassInit_ParamValueBase(PyObject *module);

/**
 * Forward declarations for top-level class ParamTypedRefCount
 */
typedef ParamTypedRefCount ParamTypedRefCount_localtype;
Define_Module_ClassRef(panda3d.core, ParamTypedRefCount, ParamTypedRefCount_localtype, ParamTypedRefCount);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamTypedRefCount = &Dtool_ParamTypedRefCount;
static void Dtool_PyModuleClassInit_ParamTypedRefCount(PyObject *module);
bool Dtool_ConstCoerce_ParamTypedRefCount(PyObject *args, CPT(ParamTypedRefCount) &coerced);
bool Dtool_Coerce_ParamTypedRefCount(PyObject *args, PT(ParamTypedRefCount) &coerced);

/**
 * Forward declarations for top-level class ParamValue_std_string
 */
typedef ParamValue< std::string > ParamValue_std_string_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_std_string, ParamValue_std_string_localtype, ParamValue_string);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_std_string = &Dtool_ParamValue_std_string;
static void Dtool_PyModuleClassInit_ParamValue_std_string(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_std_string(PyObject *args, CPT(ParamValue< std::string >) &coerced);
bool Dtool_Coerce_ParamValue_std_string(PyObject *args, PT(ParamValue< std::string >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_std_wstring
 */
typedef ParamValue< std::wstring > ParamValue_std_wstring_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_std_wstring, ParamValue_std_wstring_localtype, ParamValue_wstring);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_std_wstring = &Dtool_ParamValue_std_wstring;
static void Dtool_PyModuleClassInit_ParamValue_std_wstring(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_std_wstring(PyObject *args, CPT(ParamValue< std::wstring >) &coerced);
bool Dtool_Coerce_ParamValue_std_wstring(PyObject *args, PT(ParamValue< std::wstring >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase2d
 */
typedef ParamValue< LVecBase2d > ParamValue_LVecBase2d_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase2d, ParamValue_LVecBase2d_localtype, ParamValue_LVecBase2d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase2d = &Dtool_ParamValue_LVecBase2d;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase2d(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase2d(PyObject *args, CPT(ParamValue< LVecBase2d >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase2d(PyObject *args, PT(ParamValue< LVecBase2d >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase2f
 */
typedef ParamValue< LVecBase2f > ParamValue_LVecBase2f_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase2f, ParamValue_LVecBase2f_localtype, ParamValue_LVecBase2f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase2f = &Dtool_ParamValue_LVecBase2f;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase2f(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase2f(PyObject *args, CPT(ParamValue< LVecBase2f >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase2f(PyObject *args, PT(ParamValue< LVecBase2f >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase2i
 */
typedef ParamValue< LVecBase2i > ParamValue_LVecBase2i_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase2i, ParamValue_LVecBase2i_localtype, ParamValue_LVecBase2i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase2i = &Dtool_ParamValue_LVecBase2i;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase2i(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase2i(PyObject *args, CPT(ParamValue< LVecBase2i >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase2i(PyObject *args, PT(ParamValue< LVecBase2i >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase3d
 */
typedef ParamValue< LVecBase3d > ParamValue_LVecBase3d_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase3d, ParamValue_LVecBase3d_localtype, ParamValue_LVecBase3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase3d = &Dtool_ParamValue_LVecBase3d;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase3d(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase3d(PyObject *args, CPT(ParamValue< LVecBase3d >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase3d(PyObject *args, PT(ParamValue< LVecBase3d >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase3f
 */
typedef ParamValue< LVecBase3f > ParamValue_LVecBase3f_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase3f, ParamValue_LVecBase3f_localtype, ParamValue_LVecBase3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase3f = &Dtool_ParamValue_LVecBase3f;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase3f(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase3f(PyObject *args, CPT(ParamValue< LVecBase3f >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase3f(PyObject *args, PT(ParamValue< LVecBase3f >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase3i
 */
typedef ParamValue< LVecBase3i > ParamValue_LVecBase3i_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase3i, ParamValue_LVecBase3i_localtype, ParamValue_LVecBase3i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase3i = &Dtool_ParamValue_LVecBase3i;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase3i(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase3i(PyObject *args, CPT(ParamValue< LVecBase3i >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase3i(PyObject *args, PT(ParamValue< LVecBase3i >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase4d
 */
typedef ParamValue< LVecBase4d > ParamValue_LVecBase4d_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase4d, ParamValue_LVecBase4d_localtype, ParamValue_LVecBase4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase4d = &Dtool_ParamValue_LVecBase4d;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase4d(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase4d(PyObject *args, CPT(ParamValue< LVecBase4d >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase4d(PyObject *args, PT(ParamValue< LVecBase4d >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase4f
 */
typedef ParamValue< LVecBase4f > ParamValue_LVecBase4f_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase4f, ParamValue_LVecBase4f_localtype, ParamValue_LVecBase4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase4f = &Dtool_ParamValue_LVecBase4f;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase4f(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase4f(PyObject *args, CPT(ParamValue< LVecBase4f >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase4f(PyObject *args, PT(ParamValue< LVecBase4f >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LVecBase4i
 */
typedef ParamValue< LVecBase4i > ParamValue_LVecBase4i_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LVecBase4i, ParamValue_LVecBase4i_localtype, ParamValue_LVecBase4i);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LVecBase4i = &Dtool_ParamValue_LVecBase4i;
static void Dtool_PyModuleClassInit_ParamValue_LVecBase4i(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LVecBase4i(PyObject *args, CPT(ParamValue< LVecBase4i >) &coerced);
bool Dtool_Coerce_ParamValue_LVecBase4i(PyObject *args, PT(ParamValue< LVecBase4i >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LMatrix3d
 */
typedef ParamValue< LMatrix3d > ParamValue_LMatrix3d_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LMatrix3d, ParamValue_LMatrix3d_localtype, ParamValue_LMatrix3d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LMatrix3d = &Dtool_ParamValue_LMatrix3d;
static void Dtool_PyModuleClassInit_ParamValue_LMatrix3d(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LMatrix3d(PyObject *args, CPT(ParamValue< LMatrix3d >) &coerced);
bool Dtool_Coerce_ParamValue_LMatrix3d(PyObject *args, PT(ParamValue< LMatrix3d >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LMatrix3f
 */
typedef ParamValue< LMatrix3f > ParamValue_LMatrix3f_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LMatrix3f, ParamValue_LMatrix3f_localtype, ParamValue_LMatrix3f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LMatrix3f = &Dtool_ParamValue_LMatrix3f;
static void Dtool_PyModuleClassInit_ParamValue_LMatrix3f(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LMatrix3f(PyObject *args, CPT(ParamValue< LMatrix3f >) &coerced);
bool Dtool_Coerce_ParamValue_LMatrix3f(PyObject *args, PT(ParamValue< LMatrix3f >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LMatrix4d
 */
typedef ParamValue< LMatrix4d > ParamValue_LMatrix4d_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LMatrix4d, ParamValue_LMatrix4d_localtype, ParamValue_LMatrix4d);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LMatrix4d = &Dtool_ParamValue_LMatrix4d;
static void Dtool_PyModuleClassInit_ParamValue_LMatrix4d(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LMatrix4d(PyObject *args, CPT(ParamValue< LMatrix4d >) &coerced);
bool Dtool_Coerce_ParamValue_LMatrix4d(PyObject *args, PT(ParamValue< LMatrix4d >) &coerced);

/**
 * Forward declarations for top-level class ParamValue_LMatrix4f
 */
typedef ParamValue< LMatrix4f > ParamValue_LMatrix4f_localtype;
Define_Module_ClassRef(panda3d.core, ParamValue_LMatrix4f, ParamValue_LMatrix4f_localtype, ParamValue_LMatrix4f);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ParamValue_LMatrix4f = &Dtool_ParamValue_LMatrix4f;
static void Dtool_PyModuleClassInit_ParamValue_LMatrix4f(PyObject *module);
bool Dtool_ConstCoerce_ParamValue_LMatrix4f(PyObject *args, CPT(ParamValue< LMatrix4f >) &coerced);
bool Dtool_Coerce_ParamValue_LMatrix4f(PyObject *args, PT(ParamValue< LMatrix4f >) &coerced);

/**
 * Forward declarations for top-level class WritableConfigurable
 */
typedef WritableConfigurable WritableConfigurable_localtype;
Define_Module_Class(panda3d.core, WritableConfigurable, WritableConfigurable_localtype, WritableConfigurable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_WritableConfigurable = &Dtool_WritableConfigurable;
static void Dtool_PyModuleClassInit_WritableConfigurable(PyObject *module);

/**
 * Forward declarations for top-level class UniqueIdAllocator
 */
typedef UniqueIdAllocator UniqueIdAllocator_localtype;
Define_Module_Class(panda3d.core, UniqueIdAllocator, UniqueIdAllocator_localtype, UniqueIdAllocator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_UniqueIdAllocator = &Dtool_UniqueIdAllocator;
static void Dtool_PyModuleClassInit_UniqueIdAllocator(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"ConstPointerToArray< ushort >", &Dtool_ConstPointerToArray_ushort},
  {"PointerToArrayBase< ushort >", &Dtool_PointerToArrayBase_ushort},
  {"PointerToBase< ReferenceCountedVector< ushort > >", &Dtool_PointerToBase_ReferenceCountedVector_ushort},
  {"PointerToArray< ushort >", &Dtool_PointerToArray_ushort},
  {"AnimInterface", &Dtool_AnimInterface},
  {"UpdateSeq", &Dtool_UpdateSeq},
  {"TypedWritable", &Dtool_TypedWritable},
  {"TypedWritableReferenceCount", &Dtool_TypedWritableReferenceCount},
  {"BamCacheRecord", &Dtool_BamCacheRecord},
  {"BamCache", &Dtool_BamCache},
  {"BamEnums", &Dtool_BamEnums},
  {"LoaderOptions", &Dtool_LoaderOptions},
  {"BamReader", &Dtool_BamReader},
  {"BamWriter", &Dtool_BamWriter},
  {"BitMask< uint16_t, 16 >", &Dtool_BitMask_uint16_t_16},
  {"BitMask< uint32_t, 32 >", &Dtool_BitMask_uint32_t_32},
  {"BitMask< uint64_t, 64 >", &Dtool_BitMask_uint64_t_64},
  {"BitArray", &Dtool_BitArray},
  {"ButtonHandle", &Dtool_ButtonHandle},
  {"ButtonRegistry", &Dtool_ButtonRegistry},
  {"ButtonMap", &Dtool_ButtonMap},
  {"CallbackObject", &Dtool_CallbackObject},
  {"CachedTypedWritableReferenceCount", &Dtool_CachedTypedWritableReferenceCount},
  {"CallbackData", &Dtool_CallbackData},
  {"PythonCallbackObject", &Dtool_PythonCallbackObject},
  {"TimeVal", &Dtool_TimeVal},
  {"ClockObject", &Dtool_ClockObject},
  {"CopyOnWriteObject", &Dtool_CopyOnWriteObject},
  {"DatagramBuffer", &Dtool_DatagramBuffer},
  {"DatagramInputFile", &Dtool_DatagramInputFile},
  {"DatagramOutputFile", &Dtool_DatagramOutputFile},
  {"DoubleBitMask< BitMaskNative >", &Dtool_DoubleBitMask_BitMaskNative},
  {"DoubleBitMask< DoubleBitMaskNative >", &Dtool_DoubleBitMask_DoubleBitMaskNative},
  {"GamepadButton", &Dtool_GamepadButton},
  {"KeyboardButton", &Dtool_KeyboardButton},
  {"ModifierButtons", &Dtool_ModifierButtons},
  {"MouseButton", &Dtool_MouseButton},
  {"PointerData", &Dtool_PointerData},
  {"NodeCachedReferenceCount", &Dtool_NodeCachedReferenceCount},
  {"SparseArray", &Dtool_SparseArray},
  {"ParamValueBase", &Dtool_ParamValueBase},
  {"ParamTypedRefCount", &Dtool_ParamTypedRefCount},
  {"ParamValue< std::string >", &Dtool_ParamValue_std_string},
  {"ParamValue< std::wstring >", &Dtool_ParamValue_std_wstring},
  {"ParamValue< LVecBase2d >", &Dtool_ParamValue_LVecBase2d},
  {"ParamValue< LVecBase2f >", &Dtool_ParamValue_LVecBase2f},
  {"ParamValue< LVecBase2i >", &Dtool_ParamValue_LVecBase2i},
  {"ParamValue< LVecBase3d >", &Dtool_ParamValue_LVecBase3d},
  {"ParamValue< LVecBase3f >", &Dtool_ParamValue_LVecBase3f},
  {"ParamValue< LVecBase3i >", &Dtool_ParamValue_LVecBase3i},
  {"ParamValue< LVecBase4d >", &Dtool_ParamValue_LVecBase4d},
  {"ParamValue< LVecBase4f >", &Dtool_ParamValue_LVecBase4f},
  {"ParamValue< LVecBase4i >", &Dtool_ParamValue_LVecBase4i},
  {"ParamValue< LMatrix3d >", &Dtool_ParamValue_LMatrix3d},
  {"ParamValue< LMatrix3f >", &Dtool_ParamValue_LMatrix3f},
  {"ParamValue< LMatrix4d >", &Dtool_ParamValue_LMatrix4d},
  {"ParamValue< LMatrix4f >", &Dtool_ParamValue_LMatrix4f},
  {"WritableConfigurable", &Dtool_WritableConfigurable},
  {"UniqueIdAllocator", &Dtool_UniqueIdAllocator},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"std::istream", nullptr},
#define Dtool_Ptr_std_istream (imports[1].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[2].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[3].type)
  {"Filename", nullptr},
#define Dtool_Ptr_Filename (imports[4].type)
  {"ConfigPage", nullptr},
#define Dtool_Ptr_ConfigPage (imports[5].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[6].type)
  {"PointerToVoid", nullptr},
#define Dtool_Ptr_PointerToVoid (imports[7].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[8].type)
  {"Thread", nullptr},
#define Dtool_Ptr_Thread (imports[9].type)
  {"DatagramGenerator", nullptr},
#define Dtool_Ptr_DatagramGenerator (imports[10].type)
  {"DatagramIterator", nullptr},
#define Dtool_Ptr_DatagramIterator (imports[11].type)
  {"FileReference", nullptr},
#define Dtool_Ptr_FileReference (imports[12].type)
  {"DatagramSink", nullptr},
#define Dtool_Ptr_DatagramSink (imports[13].type)
  {"ConfigVariableSearchPath", nullptr},
#define Dtool_Ptr_ConfigVariableSearchPath (imports[14].type)
  {"VirtualFile", nullptr},
#define Dtool_Ptr_VirtualFile (imports[15].type)
  {"HashVal", nullptr},
#define Dtool_Ptr_HashVal (imports[16].type)
  {"LVecBase2f", nullptr},
#define Dtool_Ptr_LVecBase2f (imports[17].type)
  {"LVecBase2d", nullptr},
#define Dtool_Ptr_LVecBase2d (imports[18].type)
  {"LVecBase2i", nullptr},
#define Dtool_Ptr_LVecBase2i (imports[19].type)
  {"LVecBase3f", nullptr},
#define Dtool_Ptr_LVecBase3f (imports[20].type)
  {"LVecBase3d", nullptr},
#define Dtool_Ptr_LVecBase3d (imports[21].type)
  {"LVecBase3i", nullptr},
#define Dtool_Ptr_LVecBase3i (imports[22].type)
  {"LVecBase4f", nullptr},
#define Dtool_Ptr_LVecBase4f (imports[23].type)
  {"LVecBase4d", nullptr},
#define Dtool_Ptr_LVecBase4d (imports[24].type)
  {"LVecBase4i", nullptr},
#define Dtool_Ptr_LVecBase4i (imports[25].type)
  {"LMatrix3f", nullptr},
#define Dtool_Ptr_LMatrix3f (imports[26].type)
  {"LMatrix4f", nullptr},
#define Dtool_Ptr_LMatrix4f (imports[27].type)
  {"LMatrix3d", nullptr},
#define Dtool_Ptr_LMatrix3d (imports[28].type)
  {"LMatrix4d", nullptr},
#define Dtool_Ptr_LMatrix4d (imports[29].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// std::istream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_istream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_istream = &Dtool_std_istream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Filename
#ifndef LINK_ALL_STATIC
inline static Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced) {
  nassertr(Dtool_Ptr_Filename != nullptr, nullptr);
  nassertr(Dtool_Ptr_Filename->_Dtool_Coerce != nullptr, nullptr);
  return ((Filename *(*)(PyObject *, Filename &))Dtool_Ptr_Filename->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_Filename;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Filename = &Dtool_Filename;
extern Filename *Dtool_Coerce_Filename(PyObject *args, Filename &coerced);
#endif
// ConfigPage
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ConfigPage;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigPage = &Dtool_ConfigPage;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// PointerToVoid
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PointerToVoid;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PointerToVoid = &Dtool_PointerToVoid;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// Thread
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Thread;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Thread = &Dtool_Thread;
#endif
// DatagramGenerator
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DatagramGenerator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramGenerator = &Dtool_DatagramGenerator;
#endif
// DatagramIterator
#ifndef LINK_ALL_STATIC
inline static DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced) {
  nassertr(Dtool_Ptr_DatagramIterator != nullptr, nullptr);
  nassertr(Dtool_Ptr_DatagramIterator->_Dtool_Coerce != nullptr, nullptr);
  return ((DatagramIterator *(*)(PyObject *, DatagramIterator &))Dtool_Ptr_DatagramIterator->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DatagramIterator;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramIterator = &Dtool_DatagramIterator;
extern DatagramIterator *Dtool_Coerce_DatagramIterator(PyObject *args, DatagramIterator &coerced);
#endif
// FileReference
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_FileReference(PyObject *args, CPT(FileReference) &coerced) {
  nassertr(Dtool_Ptr_FileReference != nullptr, false);
  nassertr(Dtool_Ptr_FileReference->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(FileReference) &))Dtool_Ptr_FileReference->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_FileReference(PyObject *args, PT(FileReference) &coerced) {
  nassertr(Dtool_Ptr_FileReference != nullptr, false);
  nassertr(Dtool_Ptr_FileReference->_Dtool_Coerce != nullptr, false);
  return ((bool (*)(PyObject *, PT(FileReference) &))Dtool_Ptr_FileReference->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_FileReference;
static struct Dtool_PyTypedObject *const Dtool_Ptr_FileReference = &Dtool_FileReference;
extern bool Dtool_ConstCoerce_FileReference(PyObject *args, CPT(FileReference) &coerced);
extern bool Dtool_Coerce_FileReference(PyObject *args, PT(FileReference) &coerced);
#endif
// DatagramSink
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DatagramSink;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DatagramSink = &Dtool_DatagramSink;
#endif
// ConfigVariableSearchPath
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ConfigVariableSearchPath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ConfigVariableSearchPath = &Dtool_ConfigVariableSearchPath;
#endif
// VirtualFile
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_VirtualFile;
static struct Dtool_PyTypedObject *const Dtool_Ptr_VirtualFile = &Dtool_VirtualFile;
#endif
// HashVal
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_HashVal;
static struct Dtool_PyTypedObject *const Dtool_Ptr_HashVal = &Dtool_HashVal;
#endif
// LVecBase2f
#ifndef LINK_ALL_STATIC
inline static LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced) {
  nassertr(Dtool_Ptr_LVecBase2f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2f *(*)(PyObject *, LVecBase2f &))Dtool_Ptr_LVecBase2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2f = &Dtool_LVecBase2f;
extern LVecBase2f *Dtool_Coerce_LVecBase2f(PyObject *args, LVecBase2f &coerced);
#endif
// LVecBase2d
#ifndef LINK_ALL_STATIC
inline static LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced) {
  nassertr(Dtool_Ptr_LVecBase2d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2d *(*)(PyObject *, LVecBase2d &))Dtool_Ptr_LVecBase2d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2d = &Dtool_LVecBase2d;
extern LVecBase2d *Dtool_Coerce_LVecBase2d(PyObject *args, LVecBase2d &coerced);
#endif
// LVecBase2i
#ifndef LINK_ALL_STATIC
inline static LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced) {
  nassertr(Dtool_Ptr_LVecBase2i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase2i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase2i *(*)(PyObject *, LVecBase2i &))Dtool_Ptr_LVecBase2i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase2i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase2i = &Dtool_LVecBase2i;
extern LVecBase2i *Dtool_Coerce_LVecBase2i(PyObject *args, LVecBase2i &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LVecBase3d
#ifndef LINK_ALL_STATIC
inline static LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced) {
  nassertr(Dtool_Ptr_LVecBase3d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3d *(*)(PyObject *, LVecBase3d &))Dtool_Ptr_LVecBase3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3d = &Dtool_LVecBase3d;
extern LVecBase3d *Dtool_Coerce_LVecBase3d(PyObject *args, LVecBase3d &coerced);
#endif
// LVecBase3i
#ifndef LINK_ALL_STATIC
inline static LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced) {
  nassertr(Dtool_Ptr_LVecBase3i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3i *(*)(PyObject *, LVecBase3i &))Dtool_Ptr_LVecBase3i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3i = &Dtool_LVecBase3i;
extern LVecBase3i *Dtool_Coerce_LVecBase3i(PyObject *args, LVecBase3i &coerced);
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LVecBase4d
#ifndef LINK_ALL_STATIC
inline static LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced) {
  nassertr(Dtool_Ptr_LVecBase4d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4d->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4d *(*)(PyObject *, LVecBase4d &))Dtool_Ptr_LVecBase4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4d = &Dtool_LVecBase4d;
extern LVecBase4d *Dtool_Coerce_LVecBase4d(PyObject *args, LVecBase4d &coerced);
#endif
// LVecBase4i
#ifndef LINK_ALL_STATIC
inline static LVecBase4i *Dtool_Coerce_LVecBase4i(PyObject *args, LVecBase4i &coerced) {
  nassertr(Dtool_Ptr_LVecBase4i != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4i->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4i *(*)(PyObject *, LVecBase4i &))Dtool_Ptr_LVecBase4i->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4i;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4i = &Dtool_LVecBase4i;
extern LVecBase4i *Dtool_Coerce_LVecBase4i(PyObject *args, LVecBase4i &coerced);
#endif
// LMatrix3f
#ifndef LINK_ALL_STATIC
inline static LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced) {
  nassertr(Dtool_Ptr_LMatrix3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix3f *(*)(PyObject *, LMatrix3f &))Dtool_Ptr_LMatrix3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3f = &Dtool_LMatrix3f;
extern LMatrix3f *Dtool_Coerce_LMatrix3f(PyObject *args, LMatrix3f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// LMatrix3d
#ifndef LINK_ALL_STATIC
inline static LMatrix3d *Dtool_Coerce_LMatrix3d(PyObject *args, LMatrix3d &coerced) {
  nassertr(Dtool_Ptr_LMatrix3d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix3d->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix3d *(*)(PyObject *, LMatrix3d &))Dtool_Ptr_LMatrix3d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix3d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix3d = &Dtool_LMatrix3d;
extern LMatrix3d *Dtool_Coerce_LMatrix3d(PyObject *args, LMatrix3d &coerced);
#endif
// LMatrix4d
#ifndef LINK_ALL_STATIC
inline static LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced) {
  nassertr(Dtool_Ptr_LMatrix4d != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix4d->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix4d *(*)(PyObject *, LMatrix4d &))Dtool_Ptr_LMatrix4d->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4d;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4d = &Dtool_LMatrix4d;
extern LMatrix4d *Dtool_Coerce_LMatrix4d(PyObject *args, LMatrix4d &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python function wrapper for:
 * ColorSpace parse_color_space_string(std::string const &str)
 */
static PyObject *Dtool_parse_color_space_string_663(PyObject *, PyObject *arg) {
  // 1-ColorSpace parse_color_space_string(std::string const &str)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
  param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
    param0_str = nullptr;
  }
#endif
  if (param0_str != nullptr) {
    ColorSpace return_value = (::parse_color_space_string)(std::string(param0_str, param0_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "parse_color_space_string(str str)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_parse_color_space_string_663_comment =
  "C++ Interface:\n"
  "parse_color_space_string(str str)\n";
#else
static const char *Dtool_parse_color_space_string_663_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string format_color_space(ColorSpace cs)
 */
static PyObject *Dtool_format_color_space_664(PyObject *, PyObject *arg) {
  // 1-std::string format_color_space(ColorSpace cs)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    std::string return_value = (::format_color_space)((ColorSpace)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "format_color_space(int cs)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_format_color_space_664_comment =
  "C++ Interface:\n"
  "format_color_space(int cs)\n";
#else
static const char *Dtool_format_color_space_664_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConfigVariableSearchPath &get_model_path(void)
 */
static PyObject *Dtool_get_model_path_665(PyObject *, PyObject *) {
  // 1-ConfigVariableSearchPath &get_model_path(void)
  ConfigVariableSearchPath *return_value = &((::get_model_path)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableSearchPath, false, false);
}

#ifndef NDEBUG
static const char *Dtool_get_model_path_665_comment =
  "C++ Interface:\n"
  "get_model_path()\n";
#else
static const char *Dtool_get_model_path_665_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConfigVariableSearchPath &get_plugin_path(void)
 */
static PyObject *Dtool_get_plugin_path_666(PyObject *, PyObject *) {
  // 1-ConfigVariableSearchPath &get_plugin_path(void)
  ConfigVariableSearchPath *return_value = &((::get_plugin_path)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigVariableSearchPath, false, false);
}

#ifndef NDEBUG
static const char *Dtool_get_plugin_path_666_comment =
  "C++ Interface:\n"
  "get_plugin_path()\n";
#else
static const char *Dtool_get_plugin_path_666_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConfigPage *load_prc_file(Filename const &filename)
 */
static PyObject *Dtool_load_prc_file_900(PyObject *, PyObject *arg) {
  // 1-ConfigPage *load_prc_file(Filename const &filename)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "load_prc_file", "Filename");
  }
  ConfigPage *return_value = (::load_prc_file)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_prc_file(const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_load_prc_file_900_comment =
  "C++ Interface:\n"
  "load_prc_file(const Filename filename)\n"
  "\n"
  "/**\n"
  " * A convenience function for loading explicit prc files from a disk file or\n"
  " * from within a multifile (via the virtual file system).  Save the return\n"
  " * value and pass it to unload_prc_file() if you ever want to unload this file\n"
  " * later.\n"
  " *\n"
  " * The filename is first searched along the default prc search path, and then\n"
  " * also along the model path, for convenience.\n"
  " *\n"
  " * This function is defined in putil instead of in dtool with the read of the\n"
  " * prc stuff, so that it can take advantage of the virtual file system (which\n"
  " * is defined in express), and the model path (which is in putil).\n"
  " */\n"
  "\n"
  "/**\n"
  " * A convenience function for loading explicit prc files from a disk file or\n"
  " * from within a multifile (via the virtual file system).  Save the return\n"
  " * value and pass it to unload_prc_file() if you ever want to unload this file\n"
  " * later.\n"
  " *\n"
  " * The filename is first searched along the default prc search path, and then\n"
  " * also along the model path, for convenience.\n"
  " *\n"
  " * This function is defined in putil instead of in dtool with the read of the\n"
  " * prc stuff, so that it can take advantage of the virtual file system (which\n"
  " * is defined in express), and the model path (which is in putil).\n"
  " */";
#else
static const char *Dtool_load_prc_file_900_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ConfigPage *load_prc_file_data(std::string const &name, std::string const &data)
 */
static PyObject *Dtool_load_prc_file_data_901(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-ConfigPage *load_prc_file_data(std::string const &name, std::string const &data)
  const char *param0_str = nullptr;
  Py_ssize_t param0_len;
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"name", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:load_prc_file_data", (char **)keyword_list, &param0_str, &param0_len, &param1_str, &param1_len)) {
    ConfigPage *return_value = (::load_prc_file_data)(std::string(param0_str, param0_len), std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ConfigPage, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_prc_file_data(str name, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_load_prc_file_data_901_comment =
  "C++ Interface:\n"
  "load_prc_file_data(str name, str data)\n"
  "\n"
  "/**\n"
  " * Another convenience function to load a prc file from an explicit string,\n"
  " * which represents the contents of the prc file.\n"
  " *\n"
  " * The first parameter is an arbitrary name to assign to this in-memory prc\n"
  " * file.  Supply a filename if the data was read from a file, or use any other\n"
  " * name that is meaningful to you.  The name is only used when the set of\n"
  " * loaded prc files is listed.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Another convenience function to load a prc file from an explicit string,\n"
  " * which represents the contents of the prc file.\n"
  " *\n"
  " * The first parameter is an arbitrary name to assign to this in-memory prc\n"
  " * file.  Supply a filename if the data was read from a file, or use any other\n"
  " * name that is meaningful to you.  The name is only used when the set of\n"
  " * loaded prc files is listed.\n"
  " */";
#else
static const char *Dtool_load_prc_file_data_901_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool unload_prc_file(ConfigPage *page)
 */
static PyObject *Dtool_unload_prc_file_902(PyObject *, PyObject *arg) {
  // 1-bool unload_prc_file(ConfigPage *page)
  ConfigPage *arg_this = (ConfigPage *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ConfigPage, 0, "unload_prc_file", false, true);
  if (arg_this != nullptr) {
    bool return_value = (::unload_prc_file)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unload_prc_file(ConfigPage page)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_unload_prc_file_902_comment =
  "C++ Interface:\n"
  "unload_prc_file(ConfigPage page)\n";
#else
static const char *Dtool_unload_prc_file_902_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void hash_prc_variables(HashVal &hash)
 */
static PyObject *Dtool_hash_prc_variables_903(PyObject *, PyObject *arg) {
  // 1-void hash_prc_variables(HashVal &hash)
  HashVal *arg_this = (HashVal *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_HashVal, 0, "hash_prc_variables", false, true);
  if (arg_this != nullptr) {
    (::hash_prc_variables)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "hash_prc_variables(HashVal hash)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_hash_prc_variables_903_comment =
  "C++ Interface:\n"
  "hash_prc_variables(HashVal hash)\n";
#else
static const char *Dtool_hash_prc_variables_903_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *py_decode_TypedWritable_from_bam_stream(PyObject *this_class, vector_uchar const &data)
 */
static PyObject *Dtool_py_decode_TypedWritable_from_bam_stream_1160(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-PyObject *py_decode_TypedWritable_from_bam_stream(PyObject *this_class, vector_uchar const &data)
  PyObject *param0;
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  static const char *keyword_list[] = {"this_class", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O" FMTCHAR_BYTES "#:py_decode_TypedWritable_from_bam_stream", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
    PyObject *return_value = (::py_decode_TypedWritable_from_bam_stream)(param0, vector_uchar(param1_str, param1_str + param1_len));
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "py_decode_TypedWritable_from_bam_stream(object this_class, bytes data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_py_decode_TypedWritable_from_bam_stream_1160_comment =
  "C++ Interface:\n"
  "py_decode_TypedWritable_from_bam_stream(object this_class, bytes data)\n"
  "\n"
  "/**\n"
  " * This wrapper is defined as a global function to suit pickle's needs.\n"
  " *\n"
  " * This hooks into the native pickle and cPickle modules, but it cannot\n"
  " * properly handle self-referential BAM objects.\n"
  " */";
#else
static const char *Dtool_py_decode_TypedWritable_from_bam_stream_1160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *py_decode_TypedWritable_from_bam_stream_persist(PyObject *unpickler, PyObject *this_class, vector_uchar const &data)
 */
static PyObject *Dtool_py_decode_TypedWritable_from_bam_stream_persist_1161(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-PyObject *py_decode_TypedWritable_from_bam_stream_persist(PyObject *unpickler, PyObject *this_class, vector_uchar const &data)
  PyObject *param0;
  PyObject *param1;
  unsigned char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"unpickler", "this_class", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO" FMTCHAR_BYTES "#:py_decode_TypedWritable_from_bam_stream_persist", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len)) {
    PyObject *return_value = (::py_decode_TypedWritable_from_bam_stream_persist)(param0, param1, vector_uchar(param2_str, param2_str + param2_len));
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "py_decode_TypedWritable_from_bam_stream_persist(object unpickler, object this_class, bytes data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_py_decode_TypedWritable_from_bam_stream_persist_1161_comment =
  "C++ Interface:\n"
  "py_decode_TypedWritable_from_bam_stream_persist(object unpickler, object this_class, bytes data)\n"
  "\n"
  "/**\n"
  " * This wrapper is defined as a global function to suit pickle's needs.\n"
  " *\n"
  " * This is similar to py_decode_TypedWritable_from_bam_stream, but it provides\n"
  " * additional support for the missing persistent-state object needed to\n"
  " * properly support self-referential BAM objects written to the pickle stream.\n"
  " * This hooks into the pickle and cPickle modules implemented in\n"
  " * direct/src/stdpy.\n"
  " */";
#else
static const char *Dtool_py_decode_TypedWritable_from_bam_stream_persist_1161_comment = nullptr;
#endif

/**
 * Python wrappers for functions of class ConstPointerToArray< ushort >
 */
/**
 * Python function wrapper for:
 * inline void ConstPointerToArray< ushort >::clear(void)
 */
static PyObject *Dtool_ConstPointerToArray_ushort_clear_9(PyObject *self, PyObject *) {
  ConstPointerToArray< ushort > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ConstPointerToArray_ushort, (void **)&local_this, "ConstPointerToArray_ushort.clear")) {
    return nullptr;
  }
  // 1-inline void ConstPointerToArray< ushort >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_ushort_clear_9_comment =
  "C++ Interface:\n"
  "clear(const ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_ushort_clear_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ushort const &ConstPointerToArray< ushort >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_ConstPointerToArray_ushort_get_element_11(PyObject *self, PyObject *arg) {
  ConstPointerToArray< ushort > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_ushort)) {
    return nullptr;
  }
  // 1-inline ushort const &ConstPointerToArray< ushort >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    ushort return_value = ((*(const ConstPointerToArray< ushort >*)local_this).get_element)((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(ConstPointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_ushort_get_element_11_comment =
  "C++ Interface:\n"
  "get_element(ConstPointerToArray self, int n)\n";
#else
static const char *Dtool_ConstPointerToArray_ushort_get_element_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< ushort >::get_data(void) const
 */
static PyObject *Dtool_ConstPointerToArray_ushort_get_data_13(PyObject *self, PyObject *) {
  ConstPointerToArray< ushort > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_ushort)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< ushort >::get_data(void) const
  PyObject *return_value = invoke_extension((const ConstPointerToArray< ushort >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_ushort_get_data_13_comment =
  "C++ Interface:\n"
  "get_data(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_ushort_get_data_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *ConstPointerToArray< ushort >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_ConstPointerToArray_ushort_get_subdata_14(PyObject *self, PyObject *args, PyObject *kwds) {
  ConstPointerToArray< ushort > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_ushort)) {
    return nullptr;
  }
  // 1-PyObject *ConstPointerToArray< ushort >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const ConstPointerToArray< ushort >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(ConstPointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_ushort_get_subdata_14_comment =
  "C++ Interface:\n"
  "get_subdata(ConstPointerToArray self, int n, int count)\n";
#else
static const char *Dtool_ConstPointerToArray_ushort_get_subdata_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< ushort >::get_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_ushort_get_ref_count_15(PyObject *self, PyObject *) {
  ConstPointerToArray< ushort > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_ushort)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< ushort >::get_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< ushort >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_ushort_get_ref_count_15_comment =
  "C++ Interface:\n"
  "get_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_ushort_get_ref_count_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ConstPointerToArray< ushort >::get_node_ref_count(void) const
 */
static PyObject *Dtool_ConstPointerToArray_ushort_get_node_ref_count_16(PyObject *self, PyObject *) {
  ConstPointerToArray< ushort > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_ushort)) {
    return nullptr;
  }
  // 1-inline int ConstPointerToArray< ushort >::get_node_ref_count(void) const
  int return_value = ((*(const ConstPointerToArray< ushort >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_ushort_get_node_ref_count_16_comment =
  "C++ Interface:\n"
  "get_node_ref_count(ConstPointerToArray self)\n";
#else
static const char *Dtool_ConstPointerToArray_ushort_get_node_ref_count_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int ConstPointerToArray< ushort >::count(ushort const &) const
 */
static PyObject *Dtool_ConstPointerToArray_ushort_count_17(PyObject *self, PyObject *arg) {
  ConstPointerToArray< ushort > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ConstPointerToArray_ushort)) {
    return nullptr;
  }
  // 1-inline unsigned long int ConstPointerToArray< ushort >::count(ushort const &) const
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    unsigned long int return_value = ((*(const ConstPointerToArray< ushort >*)local_this).count)((ushort)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(ConstPointerToArray self, int param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ConstPointerToArray_ushort_count_17_comment =
  "C++ Interface:\n"
  "count(ConstPointerToArray self, int param0)\n";
#else
static const char *Dtool_ConstPointerToArray_ushort_count_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerToArray< ushort >::ConstPointerToArray(ConstPointerToArray< ushort > const &copy)
 * inline ConstPointerToArray< ushort >::ConstPointerToArray(PointerToArray< ushort > const &copy)
 */
static int Dtool_Init_ConstPointerToArray_ushort(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ConstPointerToArray() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    {
      // -2 inline ConstPointerToArray< ushort >::ConstPointerToArray(ConstPointerToArray< ushort > const &copy)
      ConstPointerToArray< ushort > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ConstPointerToArray_ushort);
      if (arg_this != nullptr) {
        ConstPointerToArray< ushort > *return_value = new ConstPointerToArray< ushort >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_ushort, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< ushort >::ConstPointerToArray(PointerToArray< ushort > const &copy)
      PointerToArray< ushort > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_ushort);
      if (arg_this != nullptr) {
        ConstPointerToArray< ushort > *return_value = new ConstPointerToArray< ushort >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_ushort, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< ushort >::ConstPointerToArray(ConstPointerToArray< ushort > const &copy)
      ConstPointerToArray< ushort > arg_local;
      ConstPointerToArray< ushort > const *arg_this = Dtool_Coerce_ConstPointerToArray_ushort(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< ushort > *return_value = new ConstPointerToArray< ushort >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_ushort, true, false);
      }
    }

    {
      // -2 inline ConstPointerToArray< ushort >::ConstPointerToArray(PointerToArray< ushort > const &copy)
      PointerToArray< ushort > arg_local;
      PointerToArray< ushort > const *arg_this = Dtool_Coerce_PointerToArray_ushort(arg, arg_local);
      if ((arg_this != nullptr)) {
        ConstPointerToArray< ushort > *return_value = new ConstPointerToArray< ushort >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ConstPointerToArray_ushort, true, false);
      }
    }

  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ConstPointerToArray(const ConstPointerToArray copy)\n"
      "ConstPointerToArray(const PointerToArray copy)\n");
  }
  return -1;
}

ConstPointerToArray< ushort > *Dtool_Coerce_ConstPointerToArray_ushort(PyObject *args, ConstPointerToArray< ushort > &coerced) {
  ConstPointerToArray< ushort > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ConstPointerToArray_ushort)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ConstPointerToArray< ushort > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ConstPointerToArray< ushort >::ConstPointerToArray(PointerToArray< ushort > const &copy)
    PointerToArray< ushort > const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_PointerToArray_ushort);
    if (arg_this != nullptr) {
      coerced = ConstPointerToArray< ushort >(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ConstPointerToArray_ushort(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ConstPointerToArray_ushort) {
    printf("ConstPointerToArray_ushort ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ConstPointerToArray< ushort > *local_this = (ConstPointerToArray< ushort > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ConstPointerToArray_ushort) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_ushort) {
    return (PointerToArrayBase< ushort > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort) {
    return (PointerToBase< ReferenceCountedVector< ushort > > *)(PointerToArrayBase< ushort > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< ushort > > *)(PointerToArrayBase< ushort > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ConstPointerToArray_ushort(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ConstPointerToArray_ushort) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_ushort) {
    PointerToArrayBase< ushort >* other_this = (PointerToArrayBase< ushort >*)from_this;
    return (ConstPointerToArray< ushort >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort) {
    PointerToBase< ReferenceCountedVector< ushort > >* other_this = (PointerToBase< ReferenceCountedVector< ushort > >*)from_this;
    return (ConstPointerToArray< ushort >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (ConstPointerToArray< ushort >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArrayBase< ushort >
 */
static int Dtool_Init_PointerToArrayBase_ushort(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToArrayBase_ushort(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArrayBase_ushort) {
    printf("PointerToArrayBase_ushort ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArrayBase< ushort > *local_this = (PointerToArrayBase< ushort > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArrayBase_ushort) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort) {
    return (PointerToBase< ReferenceCountedVector< ushort > > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< ushort > > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArrayBase_ushort(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_ushort) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort) {
    PointerToBase< ReferenceCountedVector< ushort > >* other_this = (PointerToBase< ReferenceCountedVector< ushort > >*)from_this;
    return (PointerToArrayBase< ushort >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArrayBase< ushort >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToBase< ReferenceCountedVector< ushort > >
 */
/**
 * Python function wrapper for:
 * inline void PointerToBase< ReferenceCountedVector< ushort > >::clear(void)
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_ushort_clear_5(PyObject *self, PyObject *) {
  PointerToBase< ReferenceCountedVector< ushort > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToBase_ReferenceCountedVector_ushort, (void **)&local_this, "PointerToBase_ReferenceCountedVector_ushort.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToBase< ReferenceCountedVector< ushort > >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_ushort_clear_5_comment =
  "C++ Interface:\n"
  "clear(const PointerToBase self)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_ushort_clear_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToBase< ReferenceCountedVector< ushort > >::output(std::ostream &out) const
 */
static PyObject *Dtool_PointerToBase_ReferenceCountedVector_ushort_output_6(PyObject *self, PyObject *arg) {
  PointerToBase< ReferenceCountedVector< ushort > > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToBase_ReferenceCountedVector_ushort)) {
    return nullptr;
  }
  // 1-void PointerToBase< ReferenceCountedVector< ushort > >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PointerToBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PointerToBase< ReferenceCountedVector< ushort > >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PointerToBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToBase_ReferenceCountedVector_ushort_output_6_comment =
  "C++ Interface:\n"
  "output(PointerToBase self, ostream out)\n";
#else
static const char *Dtool_PointerToBase_ReferenceCountedVector_ushort_output_6_comment = nullptr;
#endif

static int Dtool_Init_PointerToBase_ReferenceCountedVector_ushort(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_ushort(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToBase_ReferenceCountedVector_ushort) {
    printf("PointerToBase_ReferenceCountedVector_ushort ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToBase< ReferenceCountedVector< ushort > > *local_this = (PointerToBase< ReferenceCountedVector< ushort > > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToBase_ReferenceCountedVector_ushort) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_ushort(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToBase< ReferenceCountedVector< ushort > >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerToArray< ushort >
 */
/**
 * Python function wrapper for:
 * static inline PointerToArray< ushort > PointerToArray< ushort >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((ushort const *)(0))))
 */
static PyObject *Dtool_PointerToArray_ushort_empty_array_23(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline PointerToArray< ushort > PointerToArray< ushort >::empty_array(unsigned long int n, TypeHandle type_handle = (::_get_type_handle((ushort const *)(0))))
  unsigned long param0;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"n", "type_handle", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "k|O:empty_array", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param1_local;
    TypeHandle *param1_this;
    if (param1 != nullptr) {
      param1_this = Dtool_Coerce_TypeHandle(param1, param1_local);
    } else {
      param1_local = (::_get_type_handle((ushort const *)(0)));
      param1_this = &param1_local;
    }
    if (param1 != nullptr && !(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PointerToArray.empty_array", "TypeHandle");
    }
    PointerToArray< ushort > *return_value = new PointerToArray< ushort >((PointerToArray< ushort >::empty_array)((unsigned long int)param0, *param1_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PointerToArray_ushort, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "empty_array(int n, TypeHandle type_handle)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_empty_array_23_comment =
  "C++ Interface:\n"
  "empty_array(int n, TypeHandle type_handle)\n";
#else
static const char *Dtool_PointerToArray_ushort_empty_array_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< ushort >::clear(void)
 */
static PyObject *Dtool_PointerToArray_ushort_clear_24(PyObject *self, PyObject *) {
  PointerToArray< ushort > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_ushort, (void **)&local_this, "PointerToArray_ushort.clear")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< ushort >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_clear_24_comment =
  "C++ Interface:\n"
  "clear(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_ushort_clear_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< ushort >::push_back(ushort const &x)
 */
static PyObject *Dtool_PointerToArray_ushort_push_back_26(PyObject *self, PyObject *arg) {
  PointerToArray< ushort > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_ushort, (void **)&local_this, "PointerToArray_ushort.push_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< ushort >::push_back(ushort const &x)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    ((*local_this).push_back)((ushort)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "push_back(const PointerToArray self, int x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_push_back_26_comment =
  "C++ Interface:\n"
  "push_back(const PointerToArray self, int x)\n";
#else
static const char *Dtool_PointerToArray_ushort_push_back_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< ushort >::pop_back(void)
 */
static PyObject *Dtool_PointerToArray_ushort_pop_back_27(PyObject *self, PyObject *) {
  PointerToArray< ushort > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_ushort, (void **)&local_this, "PointerToArray_ushort.pop_back")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< ushort >::pop_back(void)
  ((*local_this).pop_back)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_pop_back_27_comment =
  "C++ Interface:\n"
  "pop_back(const PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_ushort_pop_back_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ushort const &PointerToArray< ushort >::get_element(unsigned long int n) const
 */
static PyObject *Dtool_PointerToArray_ushort_get_element_28(PyObject *self, PyObject *arg) {
  PointerToArray< ushort > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_ushort)) {
    return nullptr;
  }
  // 1-inline ushort const &PointerToArray< ushort >::get_element(unsigned long int n) const
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
    ushort return_value = ((*(const PointerToArray< ushort >*)local_this).get_element)((unsigned long int)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_element(PointerToArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_get_element_28_comment =
  "C++ Interface:\n"
  "get_element(PointerToArray self, int n)\n";
#else
static const char *Dtool_PointerToArray_ushort_get_element_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< ushort >::set_element(unsigned long int n, ushort const &value)
 */
static PyObject *Dtool_PointerToArray_ushort_set_element_29(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< ushort > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_ushort, (void **)&local_this, "PointerToArray_ushort.set_element")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< ushort >::set_element(unsigned long int n, ushort const &value)
  unsigned long param1;
  long param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kl:set_element", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param2 < 0 || param2 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param2);
    }
#endif
    ((*local_this).set_element)((unsigned long int)param1, (ushort const &)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_element(const PointerToArray self, int n, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_set_element_29_comment =
  "C++ Interface:\n"
  "set_element(const PointerToArray self, int n, int value)\n";
#else
static const char *Dtool_PointerToArray_ushort_set_element_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< ushort >::get_data(void) const
 */
static PyObject *Dtool_PointerToArray_ushort_get_data_32(PyObject *self, PyObject *) {
  PointerToArray< ushort > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_ushort)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< ushort >::get_data(void) const
  PyObject *return_value = invoke_extension((const PointerToArray< ushort >*)local_this).get_data();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_get_data_32_comment =
  "C++ Interface:\n"
  "get_data(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_ushort_get_data_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PointerToArray< ushort >::set_data(PyObject *data)
 */
static PyObject *Dtool_PointerToArray_ushort_set_data_33(PyObject *self, PyObject *arg) {
  PointerToArray< ushort > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_ushort, (void **)&local_this, "PointerToArray_ushort.set_data")) {
    return nullptr;
  }
  // 1-void PointerToArray< ushort >::set_data(PyObject *data)
  invoke_extension(local_this).set_data(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const PointerToArray self, object data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_set_data_33_comment =
  "C++ Interface:\n"
  "set_data(const PointerToArray self, object data)\n";
#else
static const char *Dtool_PointerToArray_ushort_set_data_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PointerToArray< ushort >::get_subdata(unsigned long int n, unsigned long int count) const
 */
static PyObject *Dtool_PointerToArray_ushort_get_subdata_34(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< ushort > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_ushort)) {
    return nullptr;
  }
  // 1-PyObject *PointerToArray< ushort >::get_subdata(unsigned long int n, unsigned long int count) const
  unsigned long param1;
  unsigned long param2;
  static const char *keyword_list[] = {"n", "count", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kk:get_subdata", (char **)keyword_list, &param1, &param2)) {
    PyObject *return_value = invoke_extension((const PointerToArray< ushort >*)local_this).get_subdata((unsigned long int)param1, (unsigned long int)param2);
    return Dtool_Return(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subdata(PointerToArray self, int n, int count)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_get_subdata_34_comment =
  "C++ Interface:\n"
  "get_subdata(PointerToArray self, int n, int count)\n";
#else
static const char *Dtool_PointerToArray_ushort_get_subdata_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PointerToArray< ushort >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
 */
static PyObject *Dtool_PointerToArray_ushort_set_subdata_35(PyObject *self, PyObject *args, PyObject *kwds) {
  PointerToArray< ushort > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PointerToArray_ushort, (void **)&local_this, "PointerToArray_ushort.set_subdata")) {
    return nullptr;
  }
  // 1-inline void PointerToArray< ushort >::set_subdata(unsigned long int n, unsigned long int count, std::basic_string< char > const &data)
  unsigned long param1;
  unsigned long param2;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"n", "count", "data", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kks#:set_subdata", (char **)keyword_list, &param1, &param2, &param3_str, &param3_len)) {
    ((*local_this).set_subdata)((unsigned long int)param1, (unsigned long int)param2, std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_subdata(const PointerToArray self, int n, int count, str data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_set_subdata_35_comment =
  "C++ Interface:\n"
  "set_subdata(const PointerToArray self, int n, int count, str data)\n";
#else
static const char *Dtool_PointerToArray_ushort_set_subdata_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< ushort >::get_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_ushort_get_ref_count_36(PyObject *self, PyObject *) {
  PointerToArray< ushort > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_ushort)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< ushort >::get_ref_count(void) const
  int return_value = ((*(const PointerToArray< ushort >*)local_this).get_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_get_ref_count_36_comment =
  "C++ Interface:\n"
  "get_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_ushort_get_ref_count_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int PointerToArray< ushort >::get_node_ref_count(void) const
 */
static PyObject *Dtool_PointerToArray_ushort_get_node_ref_count_37(PyObject *self, PyObject *) {
  PointerToArray< ushort > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_ushort)) {
    return nullptr;
  }
  // 1-inline int PointerToArray< ushort >::get_node_ref_count(void) const
  int return_value = ((*(const PointerToArray< ushort >*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_get_node_ref_count_37_comment =
  "C++ Interface:\n"
  "get_node_ref_count(PointerToArray self)\n";
#else
static const char *Dtool_PointerToArray_ushort_get_node_ref_count_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline unsigned long int PointerToArray< ushort >::count(ushort const &) const
 */
static PyObject *Dtool_PointerToArray_ushort_count_38(PyObject *self, PyObject *arg) {
  PointerToArray< ushort > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerToArray_ushort)) {
    return nullptr;
  }
  // 1-inline unsigned long int PointerToArray< ushort >::count(ushort const &) const
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    unsigned long int return_value = ((*(const PointerToArray< ushort >*)local_this).count)((ushort)param1);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "count(PointerToArray self, int param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PointerToArray_ushort_count_38_comment =
  "C++ Interface:\n"
  "count(PointerToArray self, int param0)\n";
#else
static const char *Dtool_PointerToArray_ushort_count_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerToArray< ushort >::PointerToArray(PointerToArray< ushort > const &copy)
 * PointerToArray< ushort >::PointerToArray(PyObject *self, PyObject *source)
 * inline PointerToArray< ushort >::PointerToArray(TypeHandle type_handle = (::_get_type_handle((ushort const *)(0))))
 */
static int Dtool_Init_PointerToArray_ushort(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerToArray< ushort >::PointerToArray(TypeHandle type_handle)
      PointerToArray< ushort > *return_value = new PointerToArray< ushort >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_ushort, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PointerToArray< ushort >::PointerToArray(PointerToArray< ushort > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< ushort > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PointerToArray_ushort);
          if (param0_this != nullptr) {
            PointerToArray< ushort > *return_value = new PointerToArray< ushort >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_ushort, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< ushort >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_TypeHandle);
          if (param0_this != nullptr) {
            PointerToArray< ushort > *return_value = new PointerToArray< ushort >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_ushort, true, false);
          }
        }
      }

      {
        // -2 PointerToArray< ushort >::PointerToArray(PyObject *self, PyObject *source)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "source")) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_PointerToArray_ushort, false, false);
          PointerToArray< ushort > *result = new PointerToArray< ushort >;
          invoke_extension(result).__init__(self, param0);
          PointerToArray< ushort > *return_value = result;
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            delete return_value;
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              delete return_value;
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_ushort, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< ushort >::PointerToArray(PointerToArray< ushort > const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          PointerToArray< ushort > param0_local;
          PointerToArray< ushort > const *param0_this = Dtool_Coerce_PointerToArray_ushort(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< ushort > *return_value = new PointerToArray< ushort >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_ushort, true, false);
          }
        }
      }

      {
        // -2 inline PointerToArray< ushort >::PointerToArray(TypeHandle type_handle)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "type_handle")) {
          TypeHandle param0_local;
          TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            PointerToArray< ushort > *return_value = new PointerToArray< ushort >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerToArray_ushort, true, false);
          }
        }
      }

      // No coercion possible: PointerToArray< ushort >::PointerToArray(PyObject *self, PyObject *source)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerToArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerToArray()\n"
      "PointerToArray(const PointerToArray copy)\n"
      "PointerToArray(TypeHandle type_handle)\n"
      "PointerToArray(object source)\n");
  }
  return -1;
}

PointerToArray< ushort > *Dtool_Coerce_PointerToArray_ushort(PyObject *args, PointerToArray< ushort > &coerced) {
  PointerToArray< ushort > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_PointerToArray_ushort)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const PointerToArray< ushort > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 inline PointerToArray< ushort >::PointerToArray(TypeHandle type_handle)
      TypeHandle *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypeHandle);
      if (arg_this != nullptr) {
        coerced = PointerToArray< ushort >(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 PointerToArray< ushort >::PointerToArray(PyObject *self, PyObject *source)
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_PointerToArray_ushort(&Dtool_PointerToArray_ushort._PyType, nullptr, nullptr);
      invoke_extension(&coerced).__init__(self, arg);
      PyObject_Del(self);
      PyObject *exception = _PyErr_OCCURRED();
      if (exception == PyExc_TypeError) {
        // TypeError raised; continue to next overload type.
      } else if (exception != nullptr) {
        return nullptr;
      } else {
        return &coerced;
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_PointerToArray_ushort(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerToArray_ushort) {
    printf("PointerToArray_ushort ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerToArray< ushort > *local_this = (PointerToArray< ushort > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerToArray_ushort) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToArrayBase_ushort) {
    return (PointerToArrayBase< ushort > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort) {
    return (PointerToBase< ReferenceCountedVector< ushort > > *)(PointerToArrayBase< ushort > *) local_this;
  }
  if (requested_type == Dtool_Ptr_PointerToVoid) {
    return (PointerToVoid *)(PointerToBase< ReferenceCountedVector< ushort > > *)(PointerToArrayBase< ushort > *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerToArray_ushort(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerToArray_ushort) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_PointerToArrayBase_ushort) {
    PointerToArrayBase< ushort >* other_this = (PointerToArrayBase< ushort >*)from_this;
    return (PointerToArray< ushort >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort) {
    PointerToBase< ReferenceCountedVector< ushort > >* other_this = (PointerToBase< ReferenceCountedVector< ushort > >*)from_this;
    return (PointerToArray< ushort >*)other_this;
  }
  if (from_type == Dtool_Ptr_PointerToVoid) {
    PointerToVoid* other_this = (PointerToVoid*)from_this;
    return (PointerToArray< ushort >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AnimInterface
 */
/**
 * Python function wrapper for:
 * inline void AnimInterface::play(void)
 * inline void AnimInterface::play(double from, double to)
 */
static PyObject *Dtool_AnimInterface_play_44(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimInterface, (void **)&local_this, "AnimInterface.play")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline void AnimInterface::play(void)
      ((*local_this).play)();
      return Dtool_Return_None();
    }
    break;
  case 2:
    {
      // 1-inline void AnimInterface::play(double from, double to)
      double param1;
      double param2;
      static const char *keyword_list[] = {"from", "to", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "dd:play", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).play)((double)param1, (double)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "play() takes 1 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "play(const AnimInterface self)\n"
      "play(const AnimInterface self, double from, double to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_play_44_comment =
  "C++ Interface:\n"
  "play(const AnimInterface self)\n"
  "play(const AnimInterface self, double from, double to)\n"
  "\n"
  "/**\n"
  " * Runs the entire animation from beginning to end and stops.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Runs the animation from the frame \"from\" to and including the frame \"to\",\n"
  " * at which point the animation is stopped.  Both \"from\" and \"to\" frame\n"
  " * numbers may be outside the range (0, get_num_frames()) and the animation\n"
  " * will follow the range correctly, reporting numbers modulo get_num_frames().\n"
  " * For instance, play(0, get_num_frames() * 2) will play the animation twice\n"
  " * and then stop.\n"
  " */";
#else
static const char *Dtool_AnimInterface_play_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AnimInterface::loop(bool restart)
 * inline void AnimInterface::loop(bool restart, double from, double to)
 */
static PyObject *Dtool_AnimInterface_loop_45(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimInterface, (void **)&local_this, "AnimInterface.loop")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "restart")) {
        // 1-inline void AnimInterface::loop(bool restart)
        ((*local_this).loop)((PyObject_IsTrue(arg) != 0));
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void AnimInterface::loop(bool restart, double from, double to)
      PyObject *param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"restart", "from", "to", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Odd:loop", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).loop)((PyObject_IsTrue(param1) != 0), (double)param2, (double)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "loop() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "loop(const AnimInterface self, bool restart)\n"
      "loop(const AnimInterface self, bool restart, double from, double to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_loop_45_comment =
  "C++ Interface:\n"
  "loop(const AnimInterface self, bool restart)\n"
  "loop(const AnimInterface self, bool restart, double from, double to)\n"
  "\n"
  "/**\n"
  " * Starts the entire animation looping.  If restart is true, the animation is\n"
  " * restarted from the beginning; otherwise, it continues from the current\n"
  " * frame.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Loops the animation from the frame \"from\" to and including the frame \"to\",\n"
  " * indefinitely.  If restart is true, the animation is restarted from the\n"
  " * beginning; otherwise, it continues from the current frame.\n"
  " */";
#else
static const char *Dtool_AnimInterface_loop_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AnimInterface::pingpong(bool restart)
 * inline void AnimInterface::pingpong(bool restart, double from, double to)
 */
static PyObject *Dtool_AnimInterface_pingpong_46(PyObject *self, PyObject *args, PyObject *kwds) {
  AnimInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimInterface, (void **)&local_this, "AnimInterface.pingpong")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "restart")) {
        // 1-inline void AnimInterface::pingpong(bool restart)
        ((*local_this).pingpong)((PyObject_IsTrue(arg) != 0));
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void AnimInterface::pingpong(bool restart, double from, double to)
      PyObject *param1;
      double param2;
      double param3;
      static const char *keyword_list[] = {"restart", "from", "to", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Odd:pingpong", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).pingpong)((PyObject_IsTrue(param1) != 0), (double)param2, (double)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "pingpong() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pingpong(const AnimInterface self, bool restart)\n"
      "pingpong(const AnimInterface self, bool restart, double from, double to)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_pingpong_46_comment =
  "C++ Interface:\n"
  "pingpong(const AnimInterface self, bool restart)\n"
  "pingpong(const AnimInterface self, bool restart, double from, double to)\n"
  "\n"
  "/**\n"
  " * Starts the entire animation bouncing back and forth between its first frame\n"
  " * and last frame.  If restart is true, the animation is restarted from the\n"
  " * beginning; otherwise, it continues from the current frame.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Loops the animation from the frame \"from\" to and including the frame \"to\",\n"
  " * and then back in the opposite direction, indefinitely.\n"
  " */";
#else
static const char *Dtool_AnimInterface_pingpong_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AnimInterface::stop(void)
 */
static PyObject *Dtool_AnimInterface_stop_47(PyObject *self, PyObject *) {
  AnimInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimInterface, (void **)&local_this, "AnimInterface.stop")) {
    return nullptr;
  }
  // 1-inline void AnimInterface::stop(void)
  ((*local_this).stop)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_stop_47_comment =
  "C++ Interface:\n"
  "stop(const AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Stops a currently playing or looping animation right where it is.  The\n"
  " * animation remains posed at the current frame.\n"
  " */";
#else
static const char *Dtool_AnimInterface_stop_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AnimInterface::pose(double frame)
 */
static PyObject *Dtool_AnimInterface_pose_48(PyObject *self, PyObject *arg) {
  AnimInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimInterface, (void **)&local_this, "AnimInterface.pose")) {
    return nullptr;
  }
  // 1-inline void AnimInterface::pose(double frame)
  if (PyNumber_Check(arg)) {
    ((*local_this).pose)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "pose(const AnimInterface self, double frame)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_pose_48_comment =
  "C++ Interface:\n"
  "pose(const AnimInterface self, double frame)\n"
  "\n"
  "/**\n"
  " * Sets the animation to the indicated frame and holds it there.\n"
  " */";
#else
static const char *Dtool_AnimInterface_pose_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AnimInterface::set_play_rate(double play_rate)
 */
static PyObject *Dtool_AnimInterface_set_play_rate_49(PyObject *self, PyObject *arg) {
  AnimInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimInterface, (void **)&local_this, "AnimInterface.set_play_rate")) {
    return nullptr;
  }
  // 1-inline void AnimInterface::set_play_rate(double play_rate)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_play_rate)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_play_rate(const AnimInterface self, double play_rate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_set_play_rate_49_comment =
  "C++ Interface:\n"
  "set_play_rate(const AnimInterface self, double play_rate)\n"
  "\n"
  "/**\n"
  " * Changes the rate at which the animation plays.  1.0 is the normal speed,\n"
  " * 2.0 is twice normal speed, and 0.5 is half normal speed.  0.0 is legal to\n"
  " * pause the animation, and a negative value will play the animation\n"
  " * backwards.\n"
  " */";
#else
static const char *Dtool_AnimInterface_set_play_rate_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double AnimInterface::get_play_rate(void) const
 */
static PyObject *Dtool_AnimInterface_get_play_rate_50(PyObject *self, PyObject *) {
  AnimInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimInterface)) {
    return nullptr;
  }
  // 1-inline double AnimInterface::get_play_rate(void) const
  double return_value = ((*(const AnimInterface*)local_this).get_play_rate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_play_rate_50_comment =
  "C++ Interface:\n"
  "get_play_rate(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the rate at which the animation plays.  See set_play_rate().\n"
  " */";
#else
static const char *Dtool_AnimInterface_get_play_rate_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double AnimInterface::get_frame_rate(void) const
 */
static PyObject *Dtool_AnimInterface_get_frame_rate_51(PyObject *self, PyObject *) {
  AnimInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimInterface)) {
    return nullptr;
  }
  // 1-inline double AnimInterface::get_frame_rate(void) const
  double return_value = ((*(const AnimInterface*)local_this).get_frame_rate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_frame_rate_51_comment =
  "C++ Interface:\n"
  "get_frame_rate(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the native frame rate of the animation.  This is the number of\n"
  " * frames per second that will elapse when the play_rate is set to 1.0.  It is\n"
  " * a fixed property of the animation and may not be adjusted by the user.\n"
  " */";
#else
static const char *Dtool_AnimInterface_get_frame_rate_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual int AnimInterface::get_num_frames(void) const
 */
static PyObject *Dtool_AnimInterface_get_num_frames_52(PyObject *self, PyObject *) {
  AnimInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimInterface)) {
    return nullptr;
  }
  // 1-virtual int AnimInterface::get_num_frames(void) const
  int return_value = ((*(const AnimInterface*)local_this).get_num_frames)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_num_frames_52_comment =
  "C++ Interface:\n"
  "get_num_frames(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the number of frames in the animation.  This is a property of the\n"
  " * animation and may not be directly adjusted by the user (although it may\n"
  " * change without warning with certain kinds of animations, since this is a\n"
  " * virtual method that may be overridden).\n"
  " */";
#else
static const char *Dtool_AnimInterface_get_num_frames_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int AnimInterface::get_frame(void) const
 */
static PyObject *Dtool_AnimInterface_get_frame_53(PyObject *self, PyObject *) {
  AnimInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimInterface)) {
    return nullptr;
  }
  // 1-inline int AnimInterface::get_frame(void) const
  int return_value = ((*(const AnimInterface*)local_this).get_frame)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_frame_53_comment =
  "C++ Interface:\n"
  "get_frame(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the current integer frame number.  This number will be in the range\n"
  " * 0 <= f < get_num_frames().\n"
  " */";
#else
static const char *Dtool_AnimInterface_get_frame_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int AnimInterface::get_next_frame(void) const
 */
static PyObject *Dtool_AnimInterface_get_next_frame_54(PyObject *self, PyObject *) {
  AnimInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimInterface)) {
    return nullptr;
  }
  // 1-inline int AnimInterface::get_next_frame(void) const
  int return_value = ((*(const AnimInterface*)local_this).get_next_frame)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_next_frame_54_comment =
  "C++ Interface:\n"
  "get_next_frame(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the current integer frame number + 1, constrained to the range 0 <=\n"
  " * f < get_num_frames().\n"
  " *\n"
  " * If the play mode is PM_play, this will clamp to the same value as\n"
  " * get_frame() at the end of the animation.  If the play mode is any other\n"
  " * value, this will wrap around to frame 0 at the end of the animation.\n"
  " */";
#else
static const char *Dtool_AnimInterface_get_next_frame_54_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double AnimInterface::get_frac(void) const
 */
static PyObject *Dtool_AnimInterface_get_frac_55(PyObject *self, PyObject *) {
  AnimInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimInterface)) {
    return nullptr;
  }
  // 1-inline double AnimInterface::get_frac(void) const
  double return_value = ((*(const AnimInterface*)local_this).get_frac)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_frac_55_comment =
  "C++ Interface:\n"
  "get_frac(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the fractional part of the current frame.  Normally, this is in the\n"
  " * range 0.0 <= f < 1.0, but in the one special case of an animation playing\n"
  " * to its end frame and stopping, it might exactly equal 1.0.\n"
  " *\n"
  " * It will always be true that get_full_frame() + get_frac() ==\n"
  " * get_full_fframe().\n"
  " */";
#else
static const char *Dtool_AnimInterface_get_frac_55_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int AnimInterface::get_full_frame(void) const
 */
static PyObject *Dtool_AnimInterface_get_full_frame_56(PyObject *self, PyObject *) {
  AnimInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimInterface)) {
    return nullptr;
  }
  // 1-inline int AnimInterface::get_full_frame(void) const
  int return_value = ((*(const AnimInterface*)local_this).get_full_frame)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_full_frame_56_comment =
  "C++ Interface:\n"
  "get_full_frame(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the current integer frame number.\n"
  " *\n"
  " * Unlike the value returned by get_frame(), this frame number may extend\n"
  " * beyond the range of get_num_frames() if the frame range passed to play(),\n"
  " * loop(), etc.  did.\n"
  " *\n"
  " * Unlike the value returned by get_full_fframe(), this return value will\n"
  " * never exceed the value passed to to_frame in the play() method.\n"
  " */";
#else
static const char *Dtool_AnimInterface_get_full_frame_56_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double AnimInterface::get_full_fframe(void) const
 */
static PyObject *Dtool_AnimInterface_get_full_fframe_57(PyObject *self, PyObject *) {
  AnimInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimInterface)) {
    return nullptr;
  }
  // 1-inline double AnimInterface::get_full_fframe(void) const
  double return_value = ((*(const AnimInterface*)local_this).get_full_fframe)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_full_fframe_57_comment =
  "C++ Interface:\n"
  "get_full_fframe(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns the current floating-point frame number.\n"
  " *\n"
  " * Unlike the value returned by get_frame(), this frame number may extend\n"
  " * beyond the range of get_num_frames() if the frame range passed to play(),\n"
  " * loop(), etc.  did.\n"
  " *\n"
  " * Unlike the value returned by get_full_frame(), this return value may equal\n"
  " * (to_frame + 1.0), when the animation has played to its natural end.\n"
  " * However, in this case the return value of get_full_frame() will be\n"
  " * to_frame, not (to_frame + 1).\n"
  " */";
#else
static const char *Dtool_AnimInterface_get_full_fframe_57_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool AnimInterface::is_playing(void) const
 */
static PyObject *Dtool_AnimInterface_is_playing_58(PyObject *self, PyObject *) {
  AnimInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimInterface)) {
    return nullptr;
  }
  // 1-inline bool AnimInterface::is_playing(void) const
  bool return_value = ((*(const AnimInterface*)local_this).is_playing)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_is_playing_58_comment =
  "C++ Interface:\n"
  "is_playing(AnimInterface self)\n"
  "\n"
  "/**\n"
  " * Returns true if the animation is currently playing, false if it is stopped\n"
  " * (e.g.  because stop() or pose() was called, or because it reached the end\n"
  " * of the animation after play() was called).\n"
  " */";
#else
static const char *Dtool_AnimInterface_is_playing_58_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void AnimInterface::output(std::ostream &out) const
 */
static PyObject *Dtool_AnimInterface_output_59(PyObject *self, PyObject *arg) {
  AnimInterface *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AnimInterface)) {
    return nullptr;
  }
  // 1-virtual void AnimInterface::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "AnimInterface.output", false, true);
  if (arg_this != nullptr) {
    ((*(const AnimInterface*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(AnimInterface self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_output_59_comment =
  "C++ Interface:\n"
  "output(AnimInterface self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_AnimInterface_output_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AnimInterface::get_class_type(void)
 */
static PyObject *Dtool_AnimInterface_get_class_type_72(PyObject *, PyObject *) {
  // 1-static TypeHandle AnimInterface::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AnimInterface::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AnimInterface_get_class_type_72_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AnimInterface_get_class_type_72_comment = nullptr;
#endif

static PyObject *Dtool_AnimInterface_play_rate_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double AnimInterface::get_play_rate(void) const
  double return_value = ((*(const AnimInterface*)local_this).get_play_rate)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_AnimInterface_play_rate_Setter(PyObject *self, PyObject *arg, void *) {
  AnimInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AnimInterface, (void **)&local_this, "AnimInterface.play_rate")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete play_rate attribute");
    return -1;
  }
  // 1-inline void AnimInterface::set_play_rate(double play_rate)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_play_rate)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_play_rate(const AnimInterface self, double play_rate)\n");
  }
  return -1;
}

static PyObject *Dtool_AnimInterface_frame_rate_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double AnimInterface::get_frame_rate(void) const
  double return_value = ((*(const AnimInterface*)local_this).get_frame_rate)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AnimInterface_num_frames_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return nullptr;
  }

  // 1-virtual int AnimInterface::get_num_frames(void) const
  int return_value = ((*(const AnimInterface*)local_this).get_num_frames)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AnimInterface_frame_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int AnimInterface::get_frame(void) const
  int return_value = ((*(const AnimInterface*)local_this).get_frame)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AnimInterface_next_frame_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int AnimInterface::get_next_frame(void) const
  int return_value = ((*(const AnimInterface*)local_this).get_next_frame)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AnimInterface_frac_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double AnimInterface::get_frac(void) const
  double return_value = ((*(const AnimInterface*)local_this).get_frac)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AnimInterface_full_frame_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int AnimInterface::get_full_frame(void) const
  int return_value = ((*(const AnimInterface*)local_this).get_full_frame)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AnimInterface_full_fframe_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double AnimInterface::get_full_fframe(void) const
  double return_value = ((*(const AnimInterface*)local_this).get_full_fframe)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_AnimInterface_playing_Getter(PyObject *self, void *) {
  const AnimInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool AnimInterface::is_playing(void) const
  bool return_value = ((*(const AnimInterface*)local_this).is_playing)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_AnimInterface(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AnimInterface(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AnimInterface) {
    printf("AnimInterface ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AnimInterface *local_this = (AnimInterface *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AnimInterface) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AnimInterface(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AnimInterface) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class UpdateSeq
 */
/**
 * Python function wrapper for:
 * static constexpr UpdateSeq UpdateSeq::initial(void)
 */
static PyObject *Dtool_UpdateSeq_initial_76(PyObject *, PyObject *) {
  // 1-static constexpr UpdateSeq UpdateSeq::initial(void)
  UpdateSeq *return_value = new UpdateSeq((UpdateSeq::initial)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_initial_76_comment =
  "C++ Interface:\n"
  "initial()\n";
#else
static const char *Dtool_UpdateSeq_initial_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr UpdateSeq UpdateSeq::old(void)
 */
static PyObject *Dtool_UpdateSeq_old_77(PyObject *, PyObject *) {
  // 1-static constexpr UpdateSeq UpdateSeq::old(void)
  UpdateSeq *return_value = new UpdateSeq((UpdateSeq::old)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_old_77_comment =
  "C++ Interface:\n"
  "old()\n";
#else
static const char *Dtool_UpdateSeq_old_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr UpdateSeq UpdateSeq::fresh(void)
 */
static PyObject *Dtool_UpdateSeq_fresh_78(PyObject *, PyObject *) {
  // 1-static constexpr UpdateSeq UpdateSeq::fresh(void)
  UpdateSeq *return_value = new UpdateSeq((UpdateSeq::fresh)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_fresh_78_comment =
  "C++ Interface:\n"
  "fresh()\n";
#else
static const char *Dtool_UpdateSeq_fresh_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void UpdateSeq::operator =(UpdateSeq const &copy)
 */
static PyObject *Dtool_UpdateSeq_operator_79(PyObject *self, PyObject *arg) {
  UpdateSeq *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UpdateSeq, (void **)&local_this, "UpdateSeq.assign")) {
    return nullptr;
  }
  // 1-inline void UpdateSeq::operator =(UpdateSeq const &copy)
  UpdateSeq const *arg_this = (UpdateSeq *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_UpdateSeq, 1, "UpdateSeq.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    UpdateSeq *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const UpdateSeq self, const UpdateSeq copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_operator_79_comment =
  "C++ Interface:\n"
  "assign(const UpdateSeq self, const UpdateSeq copy)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UpdateSeq_operator_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void UpdateSeq::clear(void)
 */
static PyObject *Dtool_UpdateSeq_clear_80(PyObject *self, PyObject *) {
  UpdateSeq *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UpdateSeq, (void **)&local_this, "UpdateSeq.clear")) {
    return nullptr;
  }
  // 1-inline void UpdateSeq::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_clear_80_comment =
  "C++ Interface:\n"
  "clear(const UpdateSeq self)\n"
  "\n"
  "/**\n"
  " * Resets the UpdateSeq to the 'initial' state.\n"
  " */";
#else
static const char *Dtool_UpdateSeq_clear_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool UpdateSeq::is_initial(void) const
 */
static PyObject *Dtool_UpdateSeq_is_initial_81(PyObject *self, PyObject *) {
  UpdateSeq *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_UpdateSeq)) {
    return nullptr;
  }
  // 1-inline bool UpdateSeq::is_initial(void) const
  bool return_value = ((*(const UpdateSeq*)local_this).is_initial)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_is_initial_81_comment =
  "C++ Interface:\n"
  "is_initial(UpdateSeq self)\n"
  "\n"
  "/**\n"
  " * Returns true if the UpdateSeq is in the 'initial' state.\n"
  " */";
#else
static const char *Dtool_UpdateSeq_is_initial_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool UpdateSeq::is_old(void) const
 */
static PyObject *Dtool_UpdateSeq_is_old_82(PyObject *self, PyObject *) {
  UpdateSeq *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_UpdateSeq)) {
    return nullptr;
  }
  // 1-inline bool UpdateSeq::is_old(void) const
  bool return_value = ((*(const UpdateSeq*)local_this).is_old)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_is_old_82_comment =
  "C++ Interface:\n"
  "is_old(UpdateSeq self)\n"
  "\n"
  "/**\n"
  " * Returns true if the UpdateSeq is in the 'old' state.\n"
  " */";
#else
static const char *Dtool_UpdateSeq_is_old_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool UpdateSeq::is_fresh(void) const
 */
static PyObject *Dtool_UpdateSeq_is_fresh_83(PyObject *self, PyObject *) {
  UpdateSeq *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_UpdateSeq)) {
    return nullptr;
  }
  // 1-inline bool UpdateSeq::is_fresh(void) const
  bool return_value = ((*(const UpdateSeq*)local_this).is_fresh)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_is_fresh_83_comment =
  "C++ Interface:\n"
  "is_fresh(UpdateSeq self)\n"
  "\n"
  "/**\n"
  " * Returns true if the UpdateSeq is in the 'fresh' state.\n"
  " */";
#else
static const char *Dtool_UpdateSeq_is_fresh_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool UpdateSeq::is_special(void) const
 */
static PyObject *Dtool_UpdateSeq_is_special_84(PyObject *self, PyObject *) {
  UpdateSeq *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_UpdateSeq)) {
    return nullptr;
  }
  // 1-inline bool UpdateSeq::is_special(void) const
  bool return_value = ((*(const UpdateSeq*)local_this).is_special)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_is_special_84_comment =
  "C++ Interface:\n"
  "is_special(UpdateSeq self)\n"
  "\n"
  "/**\n"
  " * Returns true if the UpdateSeq is in any special states, i.e.  'initial',\n"
  " * 'old', or 'fresh'.\n"
  " */";
#else
static const char *Dtool_UpdateSeq_is_special_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq UpdateSeq::operator ++(void)
 */
static PyObject *Dtool_UpdateSeq_operator_91(PyObject *self, PyObject *) {
  UpdateSeq *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UpdateSeq, (void **)&local_this, "UpdateSeq.increment")) {
    return nullptr;
  }
  // 1-inline UpdateSeq UpdateSeq::operator ++(void)
  UpdateSeq *return_value = new UpdateSeq(((*local_this).operator ++)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_operator_91_comment =
  "C++ Interface:\n"
  "increment(const UpdateSeq self)\n";
#else
static const char *Dtool_UpdateSeq_operator_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq UpdateSeq::operator ++(int )
 */
static PyObject *Dtool_UpdateSeq_operator_92(PyObject *self, PyObject *arg) {
  UpdateSeq *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UpdateSeq, (void **)&local_this, "UpdateSeq.increment")) {
    return nullptr;
  }
  // 1-inline UpdateSeq UpdateSeq::operator ++(int )
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    UpdateSeq *return_value = new UpdateSeq(((*local_this).operator ++)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "increment(const UpdateSeq self, int param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_operator_92_comment =
  "C++ Interface:\n"
  "increment(const UpdateSeq self, int param0)\n";
#else
static const char *Dtool_UpdateSeq_operator_92_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AtomicAdjust::Integer UpdateSeq::get_seq(void) const
 */
static PyObject *Dtool_UpdateSeq_get_seq_93(PyObject *self, PyObject *) {
  UpdateSeq *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_UpdateSeq)) {
    return nullptr;
  }
  // 1-inline AtomicAdjust::Integer UpdateSeq::get_seq(void) const
  AtomicAdjust::Integer return_value = ((*(const UpdateSeq*)local_this).get_seq)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_get_seq_93_comment =
  "C++ Interface:\n"
  "get_seq(UpdateSeq self)\n"
  "\n"
  "/**\n"
  " * Returns the internal integer value associated with the UpdateSeq.  Useful\n"
  " * for debugging only.\n"
  " */";
#else
static const char *Dtool_UpdateSeq_get_seq_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void UpdateSeq::output(std::ostream &out) const
 */
static PyObject *Dtool_UpdateSeq_output_98(PyObject *self, PyObject *arg) {
  UpdateSeq *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_UpdateSeq)) {
    return nullptr;
  }
  // 1-inline void UpdateSeq::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "UpdateSeq.output", false, true);
  if (arg_this != nullptr) {
    ((*(const UpdateSeq*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(UpdateSeq self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UpdateSeq_output_98_comment =
  "C++ Interface:\n"
  "output(UpdateSeq self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_UpdateSeq_output_98_comment = nullptr;
#endif

static PyObject *Dtool_UpdateSeq_seq_Getter(PyObject *self, void *) {
  const UpdateSeq *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UpdateSeq, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline AtomicAdjust::Integer UpdateSeq::get_seq(void) const
  AtomicAdjust::Integer return_value = ((*(const UpdateSeq*)local_this).get_seq)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * constexpr UpdateSeq::UpdateSeq(void)
 * inline UpdateSeq::UpdateSeq(UpdateSeq const &copy)
 */
static int Dtool_Init_UpdateSeq(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-constexpr UpdateSeq::UpdateSeq(void)
      UpdateSeq *return_value = new UpdateSeq();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UpdateSeq, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-inline UpdateSeq::UpdateSeq(UpdateSeq const &copy)
        UpdateSeq const *arg_this = (UpdateSeq *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_UpdateSeq, 0, "UpdateSeq.UpdateSeq", true, true);
        if (arg_this != nullptr) {
          UpdateSeq *return_value = new UpdateSeq(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UpdateSeq, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "UpdateSeq() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UpdateSeq()\n"
      "UpdateSeq(const UpdateSeq copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_UpdateSeq(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_UpdateSeq) {
    printf("UpdateSeq ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  UpdateSeq *local_this = (UpdateSeq *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_UpdateSeq) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_UpdateSeq(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_UpdateSeq) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TypedWritable
 */
/**
 * Python function wrapper for:
 * virtual void TypedWritable::fillin(DatagramIterator &scan, BamReader *manager)
 */
static PyObject *Dtool_TypedWritable_fillin_102(PyObject *self, PyObject *args, PyObject *kwds) {
  TypedWritable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedWritable, (void **)&local_this, "TypedWritable.fillin")) {
    return nullptr;
  }
  // 1-virtual void TypedWritable::fillin(DatagramIterator &scan, BamReader *manager)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"scan", "manager", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:fillin", (char **)keyword_list, &param1, &param2)) {
    DatagramIterator param1_local;
    DatagramIterator *param1_this = Dtool_Coerce_DatagramIterator(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "TypedWritable.fillin", "DatagramIterator");
    }
    BamReader *param2_this = (BamReader *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_BamReader, 2, "TypedWritable.fillin", false, true);
    if (param2_this != nullptr) {
      ((*local_this).fillin)(*param1_this, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "fillin(const TypedWritable self, DatagramIterator scan, BamReader manager)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypedWritable_fillin_102_comment =
  "C++ Interface:\n"
  "fillin(const TypedWritable self, DatagramIterator scan, BamReader manager)\n"
  "\n"
  "/**\n"
  " * This internal function is intended to be called by each class's\n"
  " * make_from_bam() method to read in all of the relevant data from the BamFile\n"
  " * for the new object.  It is also called directly by the BamReader to re-read\n"
  " * the data for an object that has been placed on the stream for an update.\n"
  " */";
#else
static const char *Dtool_TypedWritable_fillin_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void TypedWritable::mark_bam_modified(void)
 */
static PyObject *Dtool_TypedWritable_mark_bam_modified_103(PyObject *self, PyObject *) {
  TypedWritable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedWritable, (void **)&local_this, "TypedWritable.mark_bam_modified")) {
    return nullptr;
  }
  // 1-inline void TypedWritable::mark_bam_modified(void)
  ((*local_this).mark_bam_modified)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_TypedWritable_mark_bam_modified_103_comment =
  "C++ Interface:\n"
  "mark_bam_modified(const TypedWritable self)\n"
  "\n"
  "/**\n"
  " * Increments the bam_modified counter, so that this object will be\n"
  " * invalidated and retransmitted on any open bam streams.  This should\n"
  " * normally not need to be called by user code; it should be called internally\n"
  " * when the object has been changed in a way that legitimately requires its\n"
  " * retransmission to any connected clients.\n"
  " */";
#else
static const char *Dtool_TypedWritable_mark_bam_modified_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UpdateSeq TypedWritable::get_bam_modified(void) const
 */
static PyObject *Dtool_TypedWritable_get_bam_modified_104(PyObject *self, PyObject *) {
  TypedWritable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypedWritable)) {
    return nullptr;
  }
  // 1-inline UpdateSeq TypedWritable::get_bam_modified(void) const
  UpdateSeq *return_value = new UpdateSeq(((*(const TypedWritable*)local_this).get_bam_modified)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_UpdateSeq, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypedWritable_get_bam_modified_104_comment =
  "C++ Interface:\n"
  "get_bam_modified(TypedWritable self)\n"
  "\n"
  "/**\n"
  " * Returns the current bam_modified counter.  This counter is normally\n"
  " * incremented automatically whenever the object is modified.\n"
  " */";
#else
static const char *Dtool_TypedWritable_get_bam_modified_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *TypedWritable::__reduce__(PyObject *self) const
 */
static PyObject *Dtool_TypedWritable_reduce_105(PyObject *self, PyObject *) {
  TypedWritable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypedWritable)) {
    return nullptr;
  }
  // 1-PyObject *TypedWritable::__reduce__(PyObject *self) const
  PyObject *return_value = invoke_extension((const TypedWritable*)local_this).__reduce__(self);
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TypedWritable_reduce_105_comment =
  "C++ Interface:\n"
  "__reduce__(TypedWritable self)\n";
#else
static const char *Dtool_TypedWritable_reduce_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *TypedWritable::__reduce_persist__(PyObject *self, PyObject *pickler) const
 */
static PyObject *Dtool_TypedWritable_reduce_persist_106(PyObject *self, PyObject *arg) {
  TypedWritable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypedWritable)) {
    return nullptr;
  }
  // 1-PyObject *TypedWritable::__reduce_persist__(PyObject *self, PyObject *pickler) const
  PyObject *return_value = invoke_extension((const TypedWritable*)local_this).__reduce_persist__(self, arg);
  return Dtool_Return(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__reduce_persist__(TypedWritable self, object pickler)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypedWritable_reduce_persist_106_comment =
  "C++ Interface:\n"
  "__reduce_persist__(TypedWritable self, object pickler)\n";
#else
static const char *Dtool_TypedWritable_reduce_persist_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline vector_uchar TypedWritable::encode_to_bam_stream(void) const
 * Rejected Remap [bool TypedWritable::encode_to_bam_stream(vector_uchar &data, BamWriter *writer) const]
 */
static PyObject *Dtool_TypedWritable_encode_to_bam_stream_107(PyObject *self, PyObject *args, PyObject *kwds) {
  TypedWritable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TypedWritable)) {
    return nullptr;
  }
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("function takes no keyword arguments");
#else
    return Dtool_Raise_TypeError("encode_to_bam_stream() takes no keyword arguments");
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    return Dtool_Raise_TypeError("function takes no arguments");
#else
    return PyErr_Format(PyExc_TypeError,
                        "encode_to_bam_stream() takes no arguments (%d given)",
                        parameter_count);
#endif
  }
  // 1-inline vector_uchar TypedWritable::encode_to_bam_stream(void) const
  vector_uchar return_value = ((*(const TypedWritable*)local_this).encode_to_bam_stream)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "encode_to_bam_stream(TypedWritable self)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypedWritable_encode_to_bam_stream_107_comment =
  "C++ Interface:\n"
  "encode_to_bam_stream(TypedWritable self)\n"
  "\n"
  "/**\n"
  " * Converts the TypedWritable object into a single stream of data using a\n"
  " * BamWriter, and returns that data as a bytes object.  Returns an empty bytes\n"
  " * object on failure.\n"
  " *\n"
  " * This is a convenience method particularly useful for cases when you are\n"
  " * only serializing a single object.  If you have many objects to process, it\n"
  " * is more efficient to use the same BamWriter to serialize all of them\n"
  " * together.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Converts the TypedWritable object into a single stream of data using a\n"
  " * BamWriter, and stores that data in the indicated string.  Returns true on\n"
  " * success, false on failure.\n"
  " *\n"
  " * This is a convenience method particularly useful for cases when you are\n"
  " * only serializing a single object.  If you have many objects to process, it\n"
  " * is more efficient to use the same BamWriter to serialize all of them\n"
  " * together.\n"
  " */";
#else
static const char *Dtool_TypedWritable_encode_to_bam_stream_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TypedWritable::get_class_type(void)
 */
static PyObject *Dtool_TypedWritable_get_class_type_109(PyObject *, PyObject *) {
  // 1-static TypeHandle TypedWritable::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TypedWritable::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypedWritable_get_class_type_109_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TypedWritable_get_class_type_109_comment = nullptr;
#endif

static int Dtool_Init_TypedWritable(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TypedWritable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TypedWritable) {
    printf("TypedWritable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TypedWritable *local_this = (TypedWritable *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TypedWritable) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TypedWritable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TypedWritable*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TypedWritableReferenceCount
 */
/**
 * Python function wrapper for:
 * static PointerTo< TypedWritableReferenceCount > TypedWritableReferenceCount::decode_from_bam_stream(vector_uchar data, BamReader *reader = nullptr)
 */
static PyObject *Dtool_TypedWritableReferenceCount_decode_from_bam_stream_116(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static PointerTo< TypedWritableReferenceCount > TypedWritableReferenceCount::decode_from_bam_stream(vector_uchar data, BamReader *reader = nullptr)
  unsigned char *param0_str = nullptr;
  Py_ssize_t param0_len;
  PyObject *param1 = nullptr;
  static const char *keyword_list[] = {"data", "reader", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "" FMTCHAR_BYTES "#|O:decode_from_bam_stream", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
    BamReader *param1_this = nullptr;
    if (param1 != nullptr && param1 != Py_None) {
      param1_this = (BamReader *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_BamReader, 1, "TypedWritableReferenceCount.decode_from_bam_stream", false, true);
    }
    if ((param1 == nullptr || param1 == Py_None || param1_this != nullptr)) {
      PointerTo< TypedWritableReferenceCount > return_value = (TypedWritableReferenceCount::decode_from_bam_stream)(vector_uchar(param0_str, param0_str + param0_len), param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      TypedWritableReferenceCount *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "decode_from_bam_stream(bytes data, BamReader reader)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_TypedWritableReferenceCount_decode_from_bam_stream_116_comment =
  "C++ Interface:\n"
  "decode_from_bam_stream(bytes data, BamReader reader)\n"
  "\n"
  "/**\n"
  " * Reads the bytes created by a previous call to encode_to_bam_stream(), and\n"
  " * extracts and returns the single object on those bytes.  Returns NULL on\n"
  " * error.\n"
  " *\n"
  " * This method is intended to replace decode_raw_from_bam_stream() when you\n"
  " * know the stream in question returns an object of type\n"
  " * TypedWritableReferenceCount, allowing for easier reference count\n"
  " * management.  Note that the caller is still responsible for maintaining the\n"
  " * reference count on the return value.\n"
  " */";
#else
static const char *Dtool_TypedWritableReferenceCount_decode_from_bam_stream_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle TypedWritableReferenceCount::get_class_type(void)
 */
static PyObject *Dtool_TypedWritableReferenceCount_get_class_type_117(PyObject *, PyObject *) {
  // 1-static TypeHandle TypedWritableReferenceCount::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((TypedWritableReferenceCount::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypedWritableReferenceCount_get_class_type_117_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_TypedWritableReferenceCount_get_class_type_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedWritable *TypedWritableReferenceCount::upcast_to_TypedWritable(void)
 */
static PyObject *Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_111(PyObject *self, PyObject *) {
  TypedWritableReferenceCount *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedWritableReferenceCount, (void **)&local_this, "TypedWritableReferenceCount.upcast_to_TypedWritable")) {
    return nullptr;
  }
  // 1-TypedWritable *TypedWritableReferenceCount::upcast_to_TypedWritable(void)
  TypedWritable *return_value = (TypedWritable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    ReferenceCount *rc = return_value->as_reference_count();
    bool is_refcount = (rc != nullptr);
    if (is_refcount) {
      rc->ref();
    }
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritable, is_refcount, false, return_value->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_111_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritable(const TypedWritableReferenceCount self)\n"
  "\n"
  "upcast from TypedWritableReferenceCount to TypedWritable";
#else
static const char *Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ReferenceCount *TypedWritableReferenceCount::upcast_to_ReferenceCount(void)
 */
static PyObject *Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_114(PyObject *self, PyObject *) {
  TypedWritableReferenceCount *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_TypedWritableReferenceCount, (void **)&local_this, "TypedWritableReferenceCount.upcast_to_ReferenceCount")) {
    return nullptr;
  }
  // 1-ReferenceCount *TypedWritableReferenceCount::upcast_to_ReferenceCount(void)
  ReferenceCount *return_value = (ReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReferenceCount, true, false);
}

#ifndef NDEBUG
static const char *Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_114_comment =
  "C++ Interface:\n"
  "upcast_to_ReferenceCount(const TypedWritableReferenceCount self)\n"
  "\n"
  "upcast from TypedWritableReferenceCount to ReferenceCount";
#else
static const char *Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_114_comment = nullptr;
#endif

static int Dtool_Init_TypedWritableReferenceCount(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_TypedWritableReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TypedWritableReferenceCount) {
    printf("TypedWritableReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TypedWritableReferenceCount *local_this = (TypedWritableReferenceCount *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TypedWritableReferenceCount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TypedWritableReferenceCount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (TypedWritableReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (TypedWritableReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (TypedWritableReferenceCount*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BamCacheRecord
 */
/**
 * Python function wrapper for:
 * inline PointerTo< BamCacheRecord > BamCacheRecord::make_copy(void) const
 */
static PyObject *Dtool_BamCacheRecord_make_copy_126(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCacheRecord)) {
    return nullptr;
  }
  // 1-inline PointerTo< BamCacheRecord > BamCacheRecord::make_copy(void) const
  PointerTo< BamCacheRecord > return_value = ((*(const BamCacheRecord*)local_this).make_copy)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  BamCacheRecord *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BamCacheRecord, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_make_copy_126_comment =
  "C++ Interface:\n"
  "make_copy(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns a duplicate of the BamCacheRecord.  The duplicate will not have a\n"
  " * data pointer set, even though one may have been assigned to the original\n"
  " * via set_data().\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_make_copy_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &BamCacheRecord::get_source_pathname(void) const
 */
static PyObject *Dtool_BamCacheRecord_get_source_pathname_128(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCacheRecord)) {
    return nullptr;
  }
  // 1-inline Filename const &BamCacheRecord::get_source_pathname(void) const
  Filename const *return_value = &(((*(const BamCacheRecord*)local_this).get_source_pathname)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_get_source_pathname_128_comment =
  "C++ Interface:\n"
  "get_source_pathname(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns the full pathname to the source file that originally generated this\n"
  " * cache request.  In some cases, for instance in the case of a of a multipage\n"
  " * texture like \"cube_#.png\", this may not not a true filename on disk.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_get_source_pathname_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &BamCacheRecord::get_cache_filename(void) const
 */
static PyObject *Dtool_BamCacheRecord_get_cache_filename_129(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCacheRecord)) {
    return nullptr;
  }
  // 1-inline Filename const &BamCacheRecord::get_cache_filename(void) const
  Filename const *return_value = &(((*(const BamCacheRecord*)local_this).get_cache_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_get_cache_filename_129_comment =
  "C++ Interface:\n"
  "get_cache_filename(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the cache file as hashed from the source_pathname.\n"
  " * This will be relative to the root of the cache directory, and it will not\n"
  " * include any suffixes that may be appended to resolve hash conflicts.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_get_cache_filename_129_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline time_t BamCacheRecord::get_source_timestamp(void) const
 */
static PyObject *Dtool_BamCacheRecord_get_source_timestamp_130(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCacheRecord)) {
    return nullptr;
  }
  // 1-inline time_t BamCacheRecord::get_source_timestamp(void) const
  time_t return_value = ((*(const BamCacheRecord*)local_this).get_source_timestamp)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_get_source_timestamp_130_comment =
  "C++ Interface:\n"
  "get_source_timestamp(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns the file timestamp of the original source file that generated this\n"
  " * cache record, if available.  In some cases the original file timestamp is\n"
  " * not available, and this will return 0.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_get_source_timestamp_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline time_t BamCacheRecord::get_recorded_time(void) const
 */
static PyObject *Dtool_BamCacheRecord_get_recorded_time_131(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCacheRecord)) {
    return nullptr;
  }
  // 1-inline time_t BamCacheRecord::get_recorded_time(void) const
  time_t return_value = ((*(const BamCacheRecord*)local_this).get_recorded_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_get_recorded_time_131_comment =
  "C++ Interface:\n"
  "get_recorded_time(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns the time at which this particular record was recorded or updated.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_get_recorded_time_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BamCacheRecord::get_num_dependent_files(void) const
 */
static PyObject *Dtool_BamCacheRecord_get_num_dependent_files_139(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCacheRecord)) {
    return nullptr;
  }
  // 1-inline int BamCacheRecord::get_num_dependent_files(void) const
  int return_value = ((*(const BamCacheRecord*)local_this).get_num_dependent_files)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_get_num_dependent_files_139_comment =
  "C++ Interface:\n"
  "get_num_dependent_files(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns the number of source files that contribute to the cache.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_get_num_dependent_files_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &BamCacheRecord::get_dependent_pathname(int n) const
 */
static PyObject *Dtool_BamCacheRecord_get_dependent_pathname_140(PyObject *self, PyObject *arg) {
  BamCacheRecord *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCacheRecord)) {
    return nullptr;
  }
  // 1-inline Filename const &BamCacheRecord::get_dependent_pathname(int n) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    Filename const *return_value = &(((*(const BamCacheRecord*)local_this).get_dependent_pathname)((int)arg_val));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_dependent_pathname(BamCacheRecord self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_get_dependent_pathname_140_comment =
  "C++ Interface:\n"
  "get_dependent_pathname(BamCacheRecord self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the full pathname of the nth source files that contributes to the\n"
  " * cache.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_get_dependent_pathname_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BamCacheRecord::dependents_unchanged(void) const
 */
static PyObject *Dtool_BamCacheRecord_dependents_unchanged_141(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCacheRecord)) {
    return nullptr;
  }
  // 1-bool BamCacheRecord::dependents_unchanged(void) const
  bool return_value = ((*(const BamCacheRecord*)local_this).dependents_unchanged)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_dependents_unchanged_141_comment =
  "C++ Interface:\n"
  "dependents_unchanged(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns true if all of the dependent files are still the same as when the\n"
  " * cache was recorded, false otherwise.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_dependents_unchanged_141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BamCacheRecord::clear_dependent_files(void)
 */
static PyObject *Dtool_BamCacheRecord_clear_dependent_files_142(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCacheRecord, (void **)&local_this, "BamCacheRecord.clear_dependent_files")) {
    return nullptr;
  }
  // 1-void BamCacheRecord::clear_dependent_files(void)
  ((*local_this).clear_dependent_files)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_clear_dependent_files_142_comment =
  "C++ Interface:\n"
  "clear_dependent_files(const BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Empties the list of files that contribute to the data in this record.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_clear_dependent_files_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BamCacheRecord::add_dependent_file(Filename const &pathname)
 * void BamCacheRecord::add_dependent_file(VirtualFile const *file)
 */
static PyObject *Dtool_BamCacheRecord_add_dependent_file_143(PyObject *self, PyObject *arg) {
  BamCacheRecord *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCacheRecord, (void **)&local_this, "BamCacheRecord.add_dependent_file")) {
    return nullptr;
  }
  {
    // -2 void BamCacheRecord::add_dependent_file(Filename const &pathname)
    Filename const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_Filename);
    if (arg_this != nullptr) {
      ((*local_this).add_dependent_file)(*arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void BamCacheRecord::add_dependent_file(VirtualFile const *file)
    VirtualFile const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_VirtualFile);
    if (arg_this != nullptr) {
      ((*local_this).add_dependent_file)(arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void BamCacheRecord::add_dependent_file(Filename const &pathname)
    Filename arg_local;
    Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).add_dependent_file)(*arg_this);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void BamCacheRecord::add_dependent_file(VirtualFile const *file)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_dependent_file(const BamCacheRecord self, const Filename pathname)\n"
      "add_dependent_file(const BamCacheRecord self, const VirtualFile file)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_add_dependent_file_143_comment =
  "C++ Interface:\n"
  "add_dependent_file(const BamCacheRecord self, const Filename pathname)\n"
  "add_dependent_file(const BamCacheRecord self, const VirtualFile file)\n"
  "\n"
  "/**\n"
  " * Adds the indicated file to the list of files that will be loaded to\n"
  " * generate the data in this record.  This should be called once for the\n"
  " * primary source file, and again for each secondary source file, if any.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Variant of add_dependent_file that takes an already opened VirtualFile.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_add_dependent_file_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BamCacheRecord::has_data(void) const
 */
static PyObject *Dtool_BamCacheRecord_has_data_144(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCacheRecord)) {
    return nullptr;
  }
  // 1-inline bool BamCacheRecord::has_data(void) const
  bool return_value = ((*(const BamCacheRecord*)local_this).has_data)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_has_data_144_comment =
  "C++ Interface:\n"
  "has_data(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns true if this cache record has an in-memory data object associated--\n"
  " * that is, the object stored in the cache.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_has_data_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BamCacheRecord::clear_data(void)
 */
static PyObject *Dtool_BamCacheRecord_clear_data_145(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCacheRecord, (void **)&local_this, "BamCacheRecord.clear_data")) {
    return nullptr;
  }
  // 1-inline void BamCacheRecord::clear_data(void)
  ((*local_this).clear_data)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_clear_data_145_comment =
  "C++ Interface:\n"
  "clear_data(const BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Removes the in-memory data object associated with this record, if any.\n"
  " * This does not affect the on-disk representation of the record.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_clear_data_145_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TypedWritable *BamCacheRecord::get_data(void) const
 */
static PyObject *Dtool_BamCacheRecord_get_data_146(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCacheRecord)) {
    return nullptr;
  }
  // 1-inline TypedWritable *BamCacheRecord::get_data(void) const
  TypedWritable *return_value = ((*(const BamCacheRecord*)local_this).get_data)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    ReferenceCount *rc = return_value->as_reference_count();
    bool is_refcount = (rc != nullptr);
    if (is_refcount) {
      rc->ref();
    }
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritable, is_refcount, false, return_value->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_get_data_146_comment =
  "C++ Interface:\n"
  "get_data(BamCacheRecord self)\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the data stored in the record, or NULL if there is no\n"
  " * data.  The pointer is not removed from the record.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_get_data_146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BamCacheRecord::set_data(TypedWritable *ptr)
 * inline void BamCacheRecord::set_data(TypedWritable *ptr, ReferenceCount *ref_ptr)
 * inline void BamCacheRecord::set_data(TypedWritable *ptr, int dummy)
 * inline void BamCacheRecord::set_data(TypedWritableReferenceCount *ptr)
 */
static PyObject *Dtool_BamCacheRecord_set_data_148(PyObject *self, PyObject *args, PyObject *kwds) {
  BamCacheRecord *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCacheRecord, (void **)&local_this, "BamCacheRecord.set_data")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "ptr")) {
        {
          // -2 inline void BamCacheRecord::set_data(TypedWritableReferenceCount *ptr)
          TypedWritableReferenceCount *arg_this = (TypedWritableReferenceCount *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritableReferenceCount, 1, "BamCacheRecord.set_data", false, false);
          if (arg_this != nullptr) {
            ((*local_this).set_data)(arg_this);
            return Dtool_Return_None();
          }
        }

        {
          // -2 inline void BamCacheRecord::set_data(TypedWritable *ptr)
          TypedWritable *arg_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritable, 1, "BamCacheRecord.set_data", false, false);
          if (arg_this != nullptr) {
            ((*local_this).set_data)(arg_this);
            return Dtool_Return_None();
          }
        }

        // No coercion possible: inline void BamCacheRecord::set_data(TypedWritableReferenceCount *ptr)
        // No coercion possible: inline void BamCacheRecord::set_data(TypedWritable *ptr)
      }
    }
    break;
  case 2:
    {
      {
        // -2 inline void BamCacheRecord::set_data(TypedWritable *ptr, ReferenceCount *ref_ptr)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"ptr", "ref_ptr", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_data", (char **)keyword_list, &param1, &param2)) {
          TypedWritable *param1_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TypedWritable, 1, "BamCacheRecord.set_data", false, false);
          ReferenceCount *param2_this = (ReferenceCount *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_ReferenceCount, 2, "BamCacheRecord.set_data", false, false);
          if (param1_this != nullptr && param2_this != nullptr) {
            ((*local_this).set_data)(param1_this, param2_this);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void BamCacheRecord::set_data(TypedWritable *ptr, int dummy)
        PyObject *param1;
        int param2;
        static const char *keyword_list[] = {"ptr", "dummy", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Oi:set_data", (char **)keyword_list, &param1, &param2)) {
          TypedWritable *param1_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TypedWritable, 1, "BamCacheRecord.set_data", false, false);
          if (param1_this != nullptr) {
            ((*local_this).set_data)(param1_this, (int)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void BamCacheRecord::set_data(TypedWritable *ptr, ReferenceCount *ref_ptr)
      // No coercion possible: inline void BamCacheRecord::set_data(TypedWritable *ptr, int dummy)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_data() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_data(const BamCacheRecord self, TypedWritableReferenceCount ptr)\n"
      "set_data(const BamCacheRecord self, TypedWritable ptr)\n"
      "set_data(const BamCacheRecord self, TypedWritable ptr, ReferenceCount ref_ptr)\n"
      "set_data(const BamCacheRecord self, TypedWritable ptr, int dummy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_set_data_148_comment =
  "C++ Interface:\n"
  "set_data(const BamCacheRecord self, TypedWritableReferenceCount ptr)\n"
  "set_data(const BamCacheRecord self, TypedWritable ptr)\n"
  "set_data(const BamCacheRecord self, TypedWritable ptr, ReferenceCount ref_ptr)\n"
  "set_data(const BamCacheRecord self, TypedWritable ptr, int dummy)\n"
  "\n"
  "/**\n"
  " * Stores a new data object on the record.  You should pass the same pointer\n"
  " * twice, to both parameters; this allows the C++ typecasting to automatically\n"
  " * convert the pointer into both a TypedWritable and a ReferenceCount pointer,\n"
  " * so that the BamCacheRecord object can reliably manage the reference counts.\n"
  " *\n"
  " * You may pass 0 or NULL as the second parameter.  If you do this, the\n"
  " * BamCacheRecord will not manage the object's reference count; it will be up\n"
  " * to you to ensure the object is not deleted during the lifetime of the\n"
  " * BamCacheRecord object.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This variant on set_data() is provided to easily pass objects deriving from\n"
  " * TypedWritable.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This variant on set_data() is provided to easily pass objects deriving from\n"
  " * TypedWritableReferenceCount.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This variant on set_data() is provided just to allow Python code to pass a\n"
  " * 0 as the second parameter.\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_set_data_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BamCacheRecord::output(std::ostream &out) const
 */
static PyObject *Dtool_BamCacheRecord_output_151(PyObject *self, PyObject *arg) {
  BamCacheRecord *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCacheRecord)) {
    return nullptr;
  }
  // 1-void BamCacheRecord::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "BamCacheRecord.output", false, true);
  if (arg_this != nullptr) {
    ((*(const BamCacheRecord*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BamCacheRecord self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_output_151_comment =
  "C++ Interface:\n"
  "output(BamCacheRecord self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_output_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BamCacheRecord::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_BamCacheRecord_write_152(PyObject *self, PyObject *args, PyObject *kwds) {
  BamCacheRecord *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCacheRecord)) {
    return nullptr;
  }
  // 1-void BamCacheRecord::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BamCacheRecord.write", false, true);
    if (param1_this != nullptr) {
      ((*(const BamCacheRecord*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BamCacheRecord self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_write_152_comment =
  "C++ Interface:\n"
  "write(BamCacheRecord self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_BamCacheRecord_write_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BamCacheRecord::get_class_type(void)
 */
static PyObject *Dtool_BamCacheRecord_get_class_type_153(PyObject *, PyObject *) {
  // 1-static TypeHandle BamCacheRecord::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BamCacheRecord::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_get_class_type_153_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BamCacheRecord_get_class_type_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedWritableReferenceCount *BamCacheRecord::upcast_to_TypedWritableReferenceCount(void)
 */
static PyObject *Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_120(PyObject *self, PyObject *) {
  BamCacheRecord *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCacheRecord, (void **)&local_this, "BamCacheRecord.upcast_to_TypedWritableReferenceCount")) {
    return nullptr;
  }
  // 1-TypedWritableReferenceCount *BamCacheRecord::upcast_to_TypedWritableReferenceCount(void)
  TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritableReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_120_comment =
  "C++ Interface:\n"
  "upcast_to_TypedWritableReferenceCount(const BamCacheRecord self)\n"
  "\n"
  "upcast from BamCacheRecord to TypedWritableReferenceCount";
#else
static const char *Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_120_comment = nullptr;
#endif

static PyObject *Dtool_BamCacheRecord_source_pathname_Getter(PyObject *self, void *) {
  const BamCacheRecord *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Filename const &BamCacheRecord::get_source_pathname(void) const
  Filename const *return_value = &(((*(const BamCacheRecord*)local_this).get_source_pathname)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static PyObject *Dtool_BamCacheRecord_cache_filename_Getter(PyObject *self, void *) {
  const BamCacheRecord *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Filename const &BamCacheRecord::get_cache_filename(void) const
  Filename const *return_value = &(((*(const BamCacheRecord*)local_this).get_cache_filename)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static PyObject *Dtool_BamCacheRecord_source_timestamp_Getter(PyObject *self, void *) {
  const BamCacheRecord *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline time_t BamCacheRecord::get_source_timestamp(void) const
  time_t return_value = ((*(const BamCacheRecord*)local_this).get_source_timestamp)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BamCacheRecord_recorded_time_Getter(PyObject *self, void *) {
  const BamCacheRecord *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline time_t BamCacheRecord::get_recorded_time(void) const
  time_t return_value = ((*(const BamCacheRecord*)local_this).get_recorded_time)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BamCacheRecord_data_Getter(PyObject *self, void *) {
  const BamCacheRecord *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_data()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline TypedWritable *BamCacheRecord::get_data(void) const
  TypedWritable *return_value = ((*(const BamCacheRecord*)local_this).get_data)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    ReferenceCount *rc = return_value->as_reference_count();
    bool is_refcount = (rc != nullptr);
    if (is_refcount) {
      rc->ref();
    }
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritable, is_refcount, false, return_value->get_type_index());
  }
}

static int Dtool_BamCacheRecord_data_Setter(PyObject *self, PyObject *arg, void *) {
  BamCacheRecord *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCacheRecord, (void **)&local_this, "BamCacheRecord.data")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete data attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_data();
    return 0;
  }
  {
    // -2 inline void BamCacheRecord::set_data(TypedWritableReferenceCount *ptr)
    TypedWritableReferenceCount *arg_this = (TypedWritableReferenceCount *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritableReferenceCount, 1, "BamCacheRecord.set_data", false, false);
    if (arg_this != nullptr) {
      ((*local_this).set_data)(arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  {
    // -2 inline void BamCacheRecord::set_data(TypedWritable *ptr)
    TypedWritable *arg_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritable, 1, "BamCacheRecord.set_data", false, false);
    if (arg_this != nullptr) {
      ((*local_this).set_data)(arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  // No coercion possible: inline void BamCacheRecord::set_data(TypedWritableReferenceCount *ptr)
  // No coercion possible: inline void BamCacheRecord::set_data(TypedWritable *ptr)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_data(const BamCacheRecord self, TypedWritableReferenceCount ptr)\n"
      "set_data(const BamCacheRecord self, TypedWritable ptr)\n");
  }
  return -1;
}

static int Dtool_Init_BamCacheRecord(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_BamCacheRecord(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BamCacheRecord) {
    printf("BamCacheRecord ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BamCacheRecord *local_this = (BamCacheRecord *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BamCacheRecord) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BamCacheRecord(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BamCacheRecord) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BamCacheRecord*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BamCacheRecord*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (BamCacheRecord*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (BamCacheRecord*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BamCache
 */
/**
 * Python function wrapper for:
 * inline void BamCache::set_active(bool flag)
 */
static PyObject *Dtool_BamCache_set_active_157(PyObject *self, PyObject *arg) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_active")) {
    return nullptr;
  }
  // 1-inline void BamCache::set_active(bool flag)
  ((*local_this).set_active)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active(const BamCache self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_active_157_comment =
  "C++ Interface:\n"
  "set_active(const BamCache self, bool flag)\n"
  "\n"
  "/**\n"
  " * Changes the state of the active flag.  \"active\" means that the cache should\n"
  " * be consulted automatically on loads, \"not active\" means that objects should\n"
  " * be loaded directly without consulting the cache.\n"
  " *\n"
  " * This represents the global flag.  Also see the individual cache_models,\n"
  " * cache_textures, cache_compressed_textures flags.\n"
  " */";
#else
static const char *Dtool_BamCache_set_active_157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BamCache::get_active(void) const
 */
static PyObject *Dtool_BamCache_get_active_158(PyObject *self, PyObject *) {
  BamCache *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCache)) {
    return nullptr;
  }
  // 1-inline bool BamCache::get_active(void) const
  bool return_value = ((*(const BamCache*)local_this).get_active)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_active_158_comment =
  "C++ Interface:\n"
  "get_active(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns true if the BamCache is currently active, false if it is not.\n"
  " * \"active\" means that the cache should be consulted automatically on loads,\n"
  " * \"not active\" means that objects should be loaded directly without\n"
  " * consulting the cache.\n"
  " *\n"
  " * This represents the global flag.  Also see the individual cache_models,\n"
  " * cache_textures, cache_compressed_textures flags.\n"
  " */";
#else
static const char *Dtool_BamCache_get_active_158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BamCache::set_cache_models(bool flag)
 */
static PyObject *Dtool_BamCache_set_cache_models_159(PyObject *self, PyObject *arg) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_cache_models")) {
    return nullptr;
  }
  // 1-inline void BamCache::set_cache_models(bool flag)
  ((*local_this).set_cache_models)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cache_models(const BamCache self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_cache_models_159_comment =
  "C++ Interface:\n"
  "set_cache_models(const BamCache self, bool flag)\n"
  "\n"
  "/**\n"
  " * Indicates whether model files (e.g.  egg files and bam files) will be\n"
  " * stored in the cache, as bam files.\n"
  " */";
#else
static const char *Dtool_BamCache_set_cache_models_159_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BamCache::get_cache_models(void) const
 */
static PyObject *Dtool_BamCache_get_cache_models_160(PyObject *self, PyObject *) {
  BamCache *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCache)) {
    return nullptr;
  }
  // 1-inline bool BamCache::get_cache_models(void) const
  bool return_value = ((*(const BamCache*)local_this).get_cache_models)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_cache_models_160_comment =
  "C++ Interface:\n"
  "get_cache_models(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns whether model files (e.g.  egg files and bam files) will be stored\n"
  " * in the cache, as bam files.\n"
  " *\n"
  " * This also returns false if get_active() is false.\n"
  " */";
#else
static const char *Dtool_BamCache_get_cache_models_160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BamCache::set_cache_textures(bool flag)
 */
static PyObject *Dtool_BamCache_set_cache_textures_161(PyObject *self, PyObject *arg) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_cache_textures")) {
    return nullptr;
  }
  // 1-inline void BamCache::set_cache_textures(bool flag)
  ((*local_this).set_cache_textures)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cache_textures(const BamCache self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_cache_textures_161_comment =
  "C++ Interface:\n"
  "set_cache_textures(const BamCache self, bool flag)\n"
  "\n"
  "/**\n"
  " * Indicates whether texture files will be stored in the cache, as\n"
  " * uncompressed txo files.\n"
  " */";
#else
static const char *Dtool_BamCache_set_cache_textures_161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BamCache::get_cache_textures(void) const
 */
static PyObject *Dtool_BamCache_get_cache_textures_162(PyObject *self, PyObject *) {
  BamCache *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCache)) {
    return nullptr;
  }
  // 1-inline bool BamCache::get_cache_textures(void) const
  bool return_value = ((*(const BamCache*)local_this).get_cache_textures)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_cache_textures_162_comment =
  "C++ Interface:\n"
  "get_cache_textures(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns whether texture files (e.g.  egg files and bam files) will be\n"
  " * stored in the cache, as txo files.\n"
  " *\n"
  " * This also returns false if get_active() is false.\n"
  " */";
#else
static const char *Dtool_BamCache_get_cache_textures_162_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BamCache::set_cache_compressed_textures(bool flag)
 */
static PyObject *Dtool_BamCache_set_cache_compressed_textures_163(PyObject *self, PyObject *arg) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_cache_compressed_textures")) {
    return nullptr;
  }
  // 1-inline void BamCache::set_cache_compressed_textures(bool flag)
  ((*local_this).set_cache_compressed_textures)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cache_compressed_textures(const BamCache self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_cache_compressed_textures_163_comment =
  "C++ Interface:\n"
  "set_cache_compressed_textures(const BamCache self, bool flag)\n"
  "\n"
  "/**\n"
  " * Indicates whether compressed texture files will be stored in the cache, as\n"
  " * compressed txo files.  The compressed data may either be generated in-CPU,\n"
  " * via the squish library, or it may be extracted from the GSG after the\n"
  " * texture has been loaded.\n"
  " *\n"
  " * This may be set in conjunction with set_cache_textures(), or independently\n"
  " * of it.  If set_cache_textures() is true and this is false, all textures\n"
  " * will be cached in their uncompressed form.  If set_cache_textures() is\n"
  " * false and this is true, only compressed textures will be cached, and they\n"
  " * will be cached in their compressed form.  If both are true, all textures\n"
  " * will be cached, in their uncompressed or compressed form appropriately.\n"
  " */";
#else
static const char *Dtool_BamCache_set_cache_compressed_textures_163_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BamCache::get_cache_compressed_textures(void) const
 */
static PyObject *Dtool_BamCache_get_cache_compressed_textures_164(PyObject *self, PyObject *) {
  BamCache *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCache)) {
    return nullptr;
  }
  // 1-inline bool BamCache::get_cache_compressed_textures(void) const
  bool return_value = ((*(const BamCache*)local_this).get_cache_compressed_textures)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_cache_compressed_textures_164_comment =
  "C++ Interface:\n"
  "get_cache_compressed_textures(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns whether compressed texture files will be stored in the cache, as\n"
  " * compressed txo files.  See set_cache_compressed_textures().\n"
  " *\n"
  " * This also returns false if get_active() is false.\n"
  " */";
#else
static const char *Dtool_BamCache_get_cache_compressed_textures_164_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BamCache::set_cache_compiled_shaders(bool flag)
 */
static PyObject *Dtool_BamCache_set_cache_compiled_shaders_165(PyObject *self, PyObject *arg) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_cache_compiled_shaders")) {
    return nullptr;
  }
  // 1-inline void BamCache::set_cache_compiled_shaders(bool flag)
  ((*local_this).set_cache_compiled_shaders)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cache_compiled_shaders(const BamCache self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_cache_compiled_shaders_165_comment =
  "C++ Interface:\n"
  "set_cache_compiled_shaders(const BamCache self, bool flag)\n"
  "\n"
  "/**\n"
  " * Indicates whether compiled shader programs will be stored in the cache, as\n"
  " * binary .sho files.  This may not be supported by all shader languages or\n"
  " * graphics renderers.\n"
  " */";
#else
static const char *Dtool_BamCache_set_cache_compiled_shaders_165_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BamCache::get_cache_compiled_shaders(void) const
 */
static PyObject *Dtool_BamCache_get_cache_compiled_shaders_166(PyObject *self, PyObject *) {
  BamCache *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCache)) {
    return nullptr;
  }
  // 1-inline bool BamCache::get_cache_compiled_shaders(void) const
  bool return_value = ((*(const BamCache*)local_this).get_cache_compiled_shaders)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_cache_compiled_shaders_166_comment =
  "C++ Interface:\n"
  "get_cache_compiled_shaders(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns whether compiled shader programs will be stored in the cache, as\n"
  " * binary .txo files.  See set_cache_compiled_shaders().\n"
  " *\n"
  " * This also returns false if get_active() is false.\n"
  " */";
#else
static const char *Dtool_BamCache_get_cache_compiled_shaders_166_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BamCache::set_root(Filename const &root)
 */
static PyObject *Dtool_BamCache_set_root_167(PyObject *self, PyObject *arg) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_root")) {
    return nullptr;
  }
  // 1-void BamCache::set_root(Filename const &root)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BamCache.set_root", "Filename");
  }
  ((*local_this).set_root)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_root(const BamCache self, const Filename root)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_root_167_comment =
  "C++ Interface:\n"
  "set_root(const BamCache self, const Filename root)\n"
  "\n"
  "/**\n"
  " * Changes the current root pathname of the cache.  This specifies where the\n"
  " * cache files are stored on disk.  This should name a directory that is on a\n"
  " * disk local to the machine (not on a network-mounted disk), for instance,\n"
  " * /tmp/panda-cache or /c/panda-cache.\n"
  " *\n"
  " * If the directory does not already exist, it will be created as a result of\n"
  " * this call.\n"
  " */";
#else
static const char *Dtool_BamCache_set_root_167_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename BamCache::get_root(void) const
 */
static PyObject *Dtool_BamCache_get_root_168(PyObject *self, PyObject *) {
  BamCache *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCache)) {
    return nullptr;
  }
  // 1-inline Filename BamCache::get_root(void) const
  Filename *return_value = new Filename(((*(const BamCache*)local_this).get_root)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_root_168_comment =
  "C++ Interface:\n"
  "get_root(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns the current root pathname of the cache.  See set_root().\n"
  " */";
#else
static const char *Dtool_BamCache_get_root_168_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BamCache::set_flush_time(int flush_time)
 */
static PyObject *Dtool_BamCache_set_flush_time_169(PyObject *self, PyObject *arg) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_flush_time")) {
    return nullptr;
  }
  // 1-inline void BamCache::set_flush_time(int flush_time)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_flush_time)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_flush_time(const BamCache self, int flush_time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_flush_time_169_comment =
  "C++ Interface:\n"
  "set_flush_time(const BamCache self, int flush_time)\n"
  "\n"
  "/**\n"
  " * Specifies the time in seconds between automatic flushes of the cache index.\n"
  " */";
#else
static const char *Dtool_BamCache_set_flush_time_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BamCache::get_flush_time(void) const
 */
static PyObject *Dtool_BamCache_get_flush_time_170(PyObject *self, PyObject *) {
  BamCache *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCache)) {
    return nullptr;
  }
  // 1-inline int BamCache::get_flush_time(void) const
  int return_value = ((*(const BamCache*)local_this).get_flush_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_flush_time_170_comment =
  "C++ Interface:\n"
  "get_flush_time(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns the time in seconds between automatic flushes of the cache index.\n"
  " */";
#else
static const char *Dtool_BamCache_get_flush_time_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BamCache::set_cache_max_kbytes(int max_kbytes)
 */
static PyObject *Dtool_BamCache_set_cache_max_kbytes_171(PyObject *self, PyObject *arg) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_cache_max_kbytes")) {
    return nullptr;
  }
  // 1-inline void BamCache::set_cache_max_kbytes(int max_kbytes)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_cache_max_kbytes)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_cache_max_kbytes(const BamCache self, int max_kbytes)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_cache_max_kbytes_171_comment =
  "C++ Interface:\n"
  "set_cache_max_kbytes(const BamCache self, int max_kbytes)\n"
  "\n"
  "/**\n"
  " * Specifies the maximum size, in kilobytes, which the cache is allowed to\n"
  " * grow to.  If a newly cached file would exceed this size, an older file is\n"
  " * removed from the cache.\n"
  " *\n"
  " * Note that in the case of multiple different processes simultaneously\n"
  " * operating on the same cache directory, the actual cache size may slightly\n"
  " * exceed this value from time to time due to latency in checking between the\n"
  " * processes.\n"
  " */";
#else
static const char *Dtool_BamCache_set_cache_max_kbytes_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BamCache::get_cache_max_kbytes(void) const
 */
static PyObject *Dtool_BamCache_get_cache_max_kbytes_172(PyObject *self, PyObject *) {
  BamCache *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCache)) {
    return nullptr;
  }
  // 1-inline int BamCache::get_cache_max_kbytes(void) const
  int return_value = ((*(const BamCache*)local_this).get_cache_max_kbytes)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_cache_max_kbytes_172_comment =
  "C++ Interface:\n"
  "get_cache_max_kbytes(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns the maximum size, in kilobytes, which the cache is allowed to grow\n"
  " * to.  See set_cache_max_kbytes().\n"
  " */";
#else
static const char *Dtool_BamCache_get_cache_max_kbytes_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BamCache::set_read_only(bool ro)
 */
static PyObject *Dtool_BamCache_set_read_only_173(PyObject *self, PyObject *arg) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.set_read_only")) {
    return nullptr;
  }
  // 1-inline void BamCache::set_read_only(bool ro)
  ((*local_this).set_read_only)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_read_only(const BamCache self, bool ro)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_set_read_only_173_comment =
  "C++ Interface:\n"
  "set_read_only(const BamCache self, bool ro)\n"
  "\n"
  "/**\n"
  " * Can be used to put the cache in read-only mode, or take it out of read-only\n"
  " * mode.  Note that if you put it into read-write mode, and it discovers that\n"
  " * it does not have write access, it will put itself right back into read-only\n"
  " * mode.\n"
  " */";
#else
static const char *Dtool_BamCache_set_read_only_173_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BamCache::get_read_only(void) const
 */
static PyObject *Dtool_BamCache_get_read_only_174(PyObject *self, PyObject *) {
  BamCache *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCache)) {
    return nullptr;
  }
  // 1-inline bool BamCache::get_read_only(void) const
  bool return_value = ((*(const BamCache*)local_this).get_read_only)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_read_only_174_comment =
  "C++ Interface:\n"
  "get_read_only(BamCache self)\n"
  "\n"
  "/**\n"
  " * Returns true if the cache is in read-only mode.  Normally, the cache starts\n"
  " * in read-write mode.  It can put itself into read-only mode automatically if\n"
  " * it discovers that it does not have write access to the cache.\n"
  " */";
#else
static const char *Dtool_BamCache_get_read_only_174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< BamCacheRecord > BamCache::lookup(Filename const &source_filename, std::string const &cache_extension)
 */
static PyObject *Dtool_BamCache_lookup_175(PyObject *self, PyObject *args, PyObject *kwds) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.lookup")) {
    return nullptr;
  }
  // 1-PointerTo< BamCacheRecord > BamCache::lookup(Filename const &source_filename, std::string const &cache_extension)
  PyObject *param1;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"source_filename", "cache_extension", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:lookup", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
    Filename param1_local;
    Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "BamCache.lookup", "Filename");
    }
    PointerTo< BamCacheRecord > return_value = ((*local_this).lookup)(*param1_this, std::string(param2_str, param2_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    BamCacheRecord *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_BamCacheRecord, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lookup(const BamCache self, const Filename source_filename, str cache_extension)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_lookup_175_comment =
  "C++ Interface:\n"
  "lookup(const BamCache self, const Filename source_filename, str cache_extension)\n"
  "\n"
  "/**\n"
  " * Looks up a file in the cache.\n"
  " *\n"
  " * If the file is cacheable, then regardless of whether the file is found in\n"
  " * the cache or not, this returns a BamCacheRecord.  On the other hand, if the\n"
  " * file cannot be cached, returns NULL.\n"
  " *\n"
  " * If record->has_data() returns true, then the file was found in the cache,\n"
  " * and you may call record->extract_data() to get the object.  If\n"
  " * record->has_data() returns false, then the file was not found in the cache\n"
  " * or the cache was stale; and you should reload the source file (calling\n"
  " * record->add_dependent_file() for each file loaded, including the original\n"
  " * source file), and then call record->set_data() to record the resulting\n"
  " * loaded object; and finally, you should call store() to write the cached\n"
  " * record to disk.\n"
  " */";
#else
static const char *Dtool_BamCache_lookup_175_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BamCache::store(BamCacheRecord *record)
 */
static PyObject *Dtool_BamCache_store_176(PyObject *self, PyObject *arg) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.store")) {
    return nullptr;
  }
  // 1-bool BamCache::store(BamCacheRecord *record)
  BamCacheRecord *arg_this = (BamCacheRecord *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BamCacheRecord, 1, "BamCache.store", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).store)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store(const BamCache self, BamCacheRecord record)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_store_176_comment =
  "C++ Interface:\n"
  "store(const BamCache self, BamCacheRecord record)\n"
  "\n"
  "/**\n"
  " * Flushes a cache entry to disk.  You must have retrieved the cache record\n"
  " * via a prior call to lookup(), and then stored the data via\n"
  " * record->set_data().  Returns true on success, false on failure.\n"
  " */";
#else
static const char *Dtool_BamCache_store_176_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BamCache::consider_flush_index(void)
 */
static PyObject *Dtool_BamCache_consider_flush_index_177(PyObject *self, PyObject *) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.consider_flush_index")) {
    return nullptr;
  }
  // 1-void BamCache::consider_flush_index(void)
  ((*local_this).consider_flush_index)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BamCache_consider_flush_index_177_comment =
  "C++ Interface:\n"
  "consider_flush_index(const BamCache self)\n"
  "\n"
  "/**\n"
  " * Flushes the index if enough time has elapsed since the index was last\n"
  " * flushed.\n"
  " */";
#else
static const char *Dtool_BamCache_consider_flush_index_177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BamCache::flush_index(void)
 */
static PyObject *Dtool_BamCache_flush_index_178(PyObject *self, PyObject *) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.flush_index")) {
    return nullptr;
  }
  // 1-void BamCache::flush_index(void)
  ((*local_this).flush_index)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BamCache_flush_index_178_comment =
  "C++ Interface:\n"
  "flush_index(const BamCache self)\n"
  "\n"
  "/**\n"
  " * Ensures the index is written to disk.\n"
  " */";
#else
static const char *Dtool_BamCache_flush_index_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BamCache::list_index(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_BamCache_list_index_179(PyObject *self, PyObject *args, PyObject *kwds) {
  BamCache *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamCache)) {
    return nullptr;
  }
  // 1-void BamCache::list_index(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:list_index", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BamCache.list_index", false, true);
    if (param1_this != nullptr) {
      ((*(const BamCache*)local_this).list_index)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "list_index(BamCache self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamCache_list_index_179_comment =
  "C++ Interface:\n"
  "list_index(BamCache self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the contents of the index to standard output.\n"
  " */";
#else
static const char *Dtool_BamCache_list_index_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline BamCache *BamCache::get_global_ptr(void)
 */
static PyObject *Dtool_BamCache_get_global_ptr_180(PyObject *, PyObject *) {
  // 1-static inline BamCache *BamCache::get_global_ptr(void)
  BamCache *return_value = (BamCache::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BamCache, false, false);
}

#ifndef NDEBUG
static const char *Dtool_BamCache_get_global_ptr_180_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the global BamCache object, which is used\n"
  " * automatically by the ModelPool and TexturePool.\n"
  " */";
#else
static const char *Dtool_BamCache_get_global_ptr_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void BamCache::consider_flush_global_index(void)
 */
static PyObject *Dtool_BamCache_consider_flush_global_index_181(PyObject *, PyObject *) {
  // 1-static inline void BamCache::consider_flush_global_index(void)
  (BamCache::consider_flush_global_index)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BamCache_consider_flush_global_index_181_comment =
  "C++ Interface:\n"
  "consider_flush_global_index()\n"
  "\n"
  "/**\n"
  " * If there is a global BamCache object, calls consider_flush_index() on it.\n"
  " */";
#else
static const char *Dtool_BamCache_consider_flush_global_index_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void BamCache::flush_global_index(void)
 */
static PyObject *Dtool_BamCache_flush_global_index_182(PyObject *, PyObject *) {
  // 1-static inline void BamCache::flush_global_index(void)
  (BamCache::flush_global_index)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BamCache_flush_global_index_182_comment =
  "C++ Interface:\n"
  "flush_global_index()\n"
  "\n"
  "/**\n"
  " * If there is a global BamCache object, calls flush_index() on it.\n"
  " */";
#else
static const char *Dtool_BamCache_flush_global_index_182_comment = nullptr;
#endif

static PyObject *Dtool_BamCache_active_Getter(PyObject *self, void *) {
  const BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool BamCache::get_active(void) const
  bool return_value = ((*(const BamCache*)local_this).get_active)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_BamCache_active_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.active")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete active attribute");
    return -1;
  }
  // 1-inline void BamCache::set_active(bool flag)
  ((*local_this).set_active)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_active(const BamCache self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_BamCache_cache_models_Getter(PyObject *self, void *) {
  const BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool BamCache::get_cache_models(void) const
  bool return_value = ((*(const BamCache*)local_this).get_cache_models)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_BamCache_cache_models_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.cache_models")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete cache_models attribute");
    return -1;
  }
  // 1-inline void BamCache::set_cache_models(bool flag)
  ((*local_this).set_cache_models)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cache_models(const BamCache self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_BamCache_cache_textures_Getter(PyObject *self, void *) {
  const BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool BamCache::get_cache_textures(void) const
  bool return_value = ((*(const BamCache*)local_this).get_cache_textures)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_BamCache_cache_textures_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.cache_textures")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete cache_textures attribute");
    return -1;
  }
  // 1-inline void BamCache::set_cache_textures(bool flag)
  ((*local_this).set_cache_textures)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cache_textures(const BamCache self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_BamCache_cache_compressed_textures_Getter(PyObject *self, void *) {
  const BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool BamCache::get_cache_compressed_textures(void) const
  bool return_value = ((*(const BamCache*)local_this).get_cache_compressed_textures)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_BamCache_cache_compressed_textures_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.cache_compressed_textures")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete cache_compressed_textures attribute");
    return -1;
  }
  // 1-inline void BamCache::set_cache_compressed_textures(bool flag)
  ((*local_this).set_cache_compressed_textures)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cache_compressed_textures(const BamCache self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_BamCache_cache_compiled_shaders_Getter(PyObject *self, void *) {
  const BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool BamCache::get_cache_compiled_shaders(void) const
  bool return_value = ((*(const BamCache*)local_this).get_cache_compiled_shaders)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_BamCache_cache_compiled_shaders_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.cache_compiled_shaders")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete cache_compiled_shaders attribute");
    return -1;
  }
  // 1-inline void BamCache::set_cache_compiled_shaders(bool flag)
  ((*local_this).set_cache_compiled_shaders)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cache_compiled_shaders(const BamCache self, bool flag)\n");
  }
  return -1;
}

static PyObject *Dtool_BamCache_root_Getter(PyObject *self, void *) {
  const BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Filename BamCache::get_root(void) const
  Filename *return_value = new Filename(((*(const BamCache*)local_this).get_root)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, true, false);
}

static int Dtool_BamCache_root_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.root")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete root attribute");
    return -1;
  }
  // 1-void BamCache::set_root(Filename const &root)
  Filename arg_local;
  Filename const *arg_this = Dtool_Coerce_Filename(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BamCache.set_root", "Filename");
    return -1;
  }
  ((*local_this).set_root)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_root(const BamCache self, const Filename root)\n");
  }
  return -1;
}

static PyObject *Dtool_BamCache_flush_time_Getter(PyObject *self, void *) {
  const BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int BamCache::get_flush_time(void) const
  int return_value = ((*(const BamCache*)local_this).get_flush_time)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_BamCache_flush_time_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.flush_time")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete flush_time attribute");
    return -1;
  }
  // 1-inline void BamCache::set_flush_time(int flush_time)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_flush_time)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_flush_time(const BamCache self, int flush_time)\n");
  }
  return -1;
}

static PyObject *Dtool_BamCache_cache_max_kbytes_Getter(PyObject *self, void *) {
  const BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int BamCache::get_cache_max_kbytes(void) const
  int return_value = ((*(const BamCache*)local_this).get_cache_max_kbytes)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_BamCache_cache_max_kbytes_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.cache_max_kbytes")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete cache_max_kbytes attribute");
    return -1;
  }
  // 1-inline void BamCache::set_cache_max_kbytes(int max_kbytes)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_cache_max_kbytes)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_cache_max_kbytes(const BamCache self, int max_kbytes)\n");
  }
  return -1;
}

static PyObject *Dtool_BamCache_read_only_Getter(PyObject *self, void *) {
  const BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCache, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool BamCache::get_read_only(void) const
  bool return_value = ((*(const BamCache*)local_this).get_read_only)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_BamCache_read_only_Setter(PyObject *self, PyObject *arg, void *) {
  BamCache *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamCache, (void **)&local_this, "BamCache.read_only")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete read_only attribute");
    return -1;
  }
  // 1-inline void BamCache::set_read_only(bool ro)
  ((*local_this).set_read_only)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_read_only(const BamCache self, bool ro)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * BamCache::BamCache(void)
 */
static int Dtool_Init_BamCache(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("BamCache() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "BamCache() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-BamCache::BamCache(void)
  BamCache *return_value = new BamCache();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BamCache, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BamCache()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BamCache(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BamCache) {
    printf("BamCache ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BamCache *local_this = (BamCache *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BamCache) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BamCache(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BamCache) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BamEnums
 */
/**
 * Python function wrapper for:
 * inline BamEnums::BamEnums(void) = default
 * inline BamEnums::BamEnums(BamEnums const &) = default
 */
static int Dtool_Init_BamEnums(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("BamEnums() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BamEnums::BamEnums(void) = default
      BamEnums *return_value = new BamEnums();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BamEnums, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline BamEnums::BamEnums(BamEnums const &) = default
      BamEnums const *arg_this = (BamEnums *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BamEnums, 0, "BamEnums.BamEnums", true, true);
      if (arg_this != nullptr) {
        BamEnums *return_value = new BamEnums(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BamEnums, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BamEnums() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BamEnums()\n"
      "BamEnums(const BamEnums param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BamEnums(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BamEnums) {
    printf("BamEnums ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BamEnums *local_this = (BamEnums *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BamEnums) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BamEnums(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BamEnums) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LoaderOptions
 */
/**
 * Python function wrapper for:
 * inline void LoaderOptions::set_flags(int flags)
 */
static PyObject *Dtool_LoaderOptions_set_flags_202(PyObject *self, PyObject *arg) {
  LoaderOptions *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderOptions, (void **)&local_this, "LoaderOptions.set_flags")) {
    return nullptr;
  }
  // 1-inline void LoaderOptions::set_flags(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_flags)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_flags(const LoaderOptions self, int flags)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_set_flags_202_comment =
  "C++ Interface:\n"
  "set_flags(const LoaderOptions self, int flags)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LoaderOptions_set_flags_202_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int LoaderOptions::get_flags(void) const
 */
static PyObject *Dtool_LoaderOptions_get_flags_203(PyObject *self, PyObject *) {
  LoaderOptions *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LoaderOptions)) {
    return nullptr;
  }
  // 1-inline int LoaderOptions::get_flags(void) const
  int return_value = ((*(const LoaderOptions*)local_this).get_flags)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_get_flags_203_comment =
  "C++ Interface:\n"
  "get_flags(LoaderOptions self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LoaderOptions_get_flags_203_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LoaderOptions::set_texture_flags(int flags)
 */
static PyObject *Dtool_LoaderOptions_set_texture_flags_205(PyObject *self, PyObject *arg) {
  LoaderOptions *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderOptions, (void **)&local_this, "LoaderOptions.set_texture_flags")) {
    return nullptr;
  }
  // 1-inline void LoaderOptions::set_texture_flags(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_texture_flags)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture_flags(const LoaderOptions self, int flags)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_set_texture_flags_205_comment =
  "C++ Interface:\n"
  "set_texture_flags(const LoaderOptions self, int flags)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LoaderOptions_set_texture_flags_205_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int LoaderOptions::get_texture_flags(void) const
 */
static PyObject *Dtool_LoaderOptions_get_texture_flags_206(PyObject *self, PyObject *) {
  LoaderOptions *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LoaderOptions)) {
    return nullptr;
  }
  // 1-inline int LoaderOptions::get_texture_flags(void) const
  int return_value = ((*(const LoaderOptions*)local_this).get_texture_flags)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_get_texture_flags_206_comment =
  "C++ Interface:\n"
  "get_texture_flags(LoaderOptions self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LoaderOptions_get_texture_flags_206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LoaderOptions::set_texture_num_views(int num_views)
 */
static PyObject *Dtool_LoaderOptions_set_texture_num_views_207(PyObject *self, PyObject *arg) {
  LoaderOptions *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderOptions, (void **)&local_this, "LoaderOptions.set_texture_num_views")) {
    return nullptr;
  }
  // 1-inline void LoaderOptions::set_texture_num_views(int num_views)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_texture_num_views)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture_num_views(const LoaderOptions self, int num_views)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_set_texture_num_views_207_comment =
  "C++ Interface:\n"
  "set_texture_num_views(const LoaderOptions self, int num_views)\n"
  "\n"
  "/**\n"
  " * Specifies the expected number of views to load for the texture.  This is\n"
  " * ignored unless TF_multiview is included in texture_flags.  This must be\n"
  " * specified when loading a 3-d multiview texture or 2-d texture array, in\n"
  " * which case it is used to differentiate z levels from separate views; it\n"
  " * may be zero in the case of 2-d textures or cube maps, in which case the\n"
  " * number of views can be inferred from the number of images found on disk.\n"
  " */";
#else
static const char *Dtool_LoaderOptions_set_texture_num_views_207_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int LoaderOptions::get_texture_num_views(void) const
 */
static PyObject *Dtool_LoaderOptions_get_texture_num_views_208(PyObject *self, PyObject *) {
  LoaderOptions *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LoaderOptions)) {
    return nullptr;
  }
  // 1-inline int LoaderOptions::get_texture_num_views(void) const
  int return_value = ((*(const LoaderOptions*)local_this).get_texture_num_views)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_get_texture_num_views_208_comment =
  "C++ Interface:\n"
  "get_texture_num_views(LoaderOptions self)\n"
  "\n"
  "/**\n"
  " * See set_texture_num_views().\n"
  " */";
#else
static const char *Dtool_LoaderOptions_get_texture_num_views_208_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LoaderOptions::set_auto_texture_scale(AutoTextureScale scale)
 */
static PyObject *Dtool_LoaderOptions_set_auto_texture_scale_211(PyObject *self, PyObject *arg) {
  LoaderOptions *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderOptions, (void **)&local_this, "LoaderOptions.set_auto_texture_scale")) {
    return nullptr;
  }
  // 1-inline void LoaderOptions::set_auto_texture_scale(AutoTextureScale scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_auto_texture_scale)((AutoTextureScale)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_auto_texture_scale(const LoaderOptions self, int scale)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_set_auto_texture_scale_211_comment =
  "C++ Interface:\n"
  "set_auto_texture_scale(const LoaderOptions self, int scale)\n"
  "\n"
  "/**\n"
  " * Set this flag to ATS_none, ATS_up, ATS_down, or ATS_pad to control how a\n"
  " * texture is scaled from disk when it is subsequently loaded.  Set it to\n"
  " * ATS_unspecified to restore the default behavior.\n"
  " */";
#else
static const char *Dtool_LoaderOptions_set_auto_texture_scale_211_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline AutoTextureScale LoaderOptions::get_auto_texture_scale(void) const
 */
static PyObject *Dtool_LoaderOptions_get_auto_texture_scale_212(PyObject *self, PyObject *) {
  LoaderOptions *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LoaderOptions)) {
    return nullptr;
  }
  // 1-inline AutoTextureScale LoaderOptions::get_auto_texture_scale(void) const
  AutoTextureScale return_value = ((*(const LoaderOptions*)local_this).get_auto_texture_scale)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_get_auto_texture_scale_212_comment =
  "C++ Interface:\n"
  "get_auto_texture_scale(LoaderOptions self)\n"
  "\n"
  "/**\n"
  " * See set_auto_texture_scale().\n"
  " */";
#else
static const char *Dtool_LoaderOptions_get_auto_texture_scale_212_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LoaderOptions::output(std::ostream &out) const
 */
static PyObject *Dtool_LoaderOptions_output_214(PyObject *self, PyObject *arg) {
  LoaderOptions *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LoaderOptions)) {
    return nullptr;
  }
  // 1-void LoaderOptions::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "LoaderOptions.output", false, true);
  if (arg_this != nullptr) {
    ((*(const LoaderOptions*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(LoaderOptions self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LoaderOptions_output_214_comment =
  "C++ Interface:\n"
  "output(LoaderOptions self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LoaderOptions_output_214_comment = nullptr;
#endif

static PyObject *Dtool_LoaderOptions_flags_Getter(PyObject *self, void *) {
  const LoaderOptions *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderOptions, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int LoaderOptions::get_flags(void) const
  int return_value = ((*(const LoaderOptions*)local_this).get_flags)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LoaderOptions_flags_Setter(PyObject *self, PyObject *arg, void *) {
  LoaderOptions *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderOptions, (void **)&local_this, "LoaderOptions.flags")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete flags attribute");
    return -1;
  }
  // 1-inline void LoaderOptions::set_flags(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_flags)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_flags(const LoaderOptions self, int flags)\n");
  }
  return -1;
}

static PyObject *Dtool_LoaderOptions_texture_flags_Getter(PyObject *self, void *) {
  const LoaderOptions *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderOptions, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int LoaderOptions::get_texture_flags(void) const
  int return_value = ((*(const LoaderOptions*)local_this).get_texture_flags)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LoaderOptions_texture_flags_Setter(PyObject *self, PyObject *arg, void *) {
  LoaderOptions *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderOptions, (void **)&local_this, "LoaderOptions.texture_flags")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete texture_flags attribute");
    return -1;
  }
  // 1-inline void LoaderOptions::set_texture_flags(int flags)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_texture_flags)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_texture_flags(const LoaderOptions self, int flags)\n");
  }
  return -1;
}

static PyObject *Dtool_LoaderOptions_texture_num_views_Getter(PyObject *self, void *) {
  const LoaderOptions *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderOptions, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int LoaderOptions::get_texture_num_views(void) const
  int return_value = ((*(const LoaderOptions*)local_this).get_texture_num_views)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LoaderOptions_texture_num_views_Setter(PyObject *self, PyObject *arg, void *) {
  LoaderOptions *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderOptions, (void **)&local_this, "LoaderOptions.texture_num_views")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete texture_num_views attribute");
    return -1;
  }
  // 1-inline void LoaderOptions::set_texture_num_views(int num_views)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_texture_num_views)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_texture_num_views(const LoaderOptions self, int num_views)\n");
  }
  return -1;
}

static PyObject *Dtool_LoaderOptions_auto_texture_scale_Getter(PyObject *self, void *) {
  const LoaderOptions *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderOptions, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline AutoTextureScale LoaderOptions::get_auto_texture_scale(void) const
  AutoTextureScale return_value = ((*(const LoaderOptions*)local_this).get_auto_texture_scale)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LoaderOptions_auto_texture_scale_Setter(PyObject *self, PyObject *arg, void *) {
  LoaderOptions *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LoaderOptions, (void **)&local_this, "LoaderOptions.auto_texture_scale")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete auto_texture_scale attribute");
    return -1;
  }
  // 1-inline void LoaderOptions::set_auto_texture_scale(AutoTextureScale scale)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_auto_texture_scale)((AutoTextureScale)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_auto_texture_scale(const LoaderOptions self, int scale)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline LoaderOptions::LoaderOptions(LoaderOptions const &) = default
 * LoaderOptions::LoaderOptions(int flags = (::LoaderOptions::LF_search | ::LoaderOptions::LF_report_errors))
 * constexpr LoaderOptions::LoaderOptions(int flags, int texture_flags)
 */
static int Dtool_Init_LoaderOptions(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LoaderOptions::LoaderOptions(int flags)
      LoaderOptions *return_value = new LoaderOptions();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LoaderOptions, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LoaderOptions::LoaderOptions(LoaderOptions const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          LoaderOptions const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LoaderOptions);
          if (param0_this != nullptr) {
            LoaderOptions *return_value = new LoaderOptions(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LoaderOptions, true, false);
          }
        }
      }

      {
        // -2 LoaderOptions::LoaderOptions(int flags)
        int param0;
        static const char *keyword_list[] = {"flags", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:LoaderOptions", (char **)keyword_list, &param0)) {
          LoaderOptions *return_value = new LoaderOptions((int)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LoaderOptions, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LoaderOptions::LoaderOptions(LoaderOptions const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          LoaderOptions param0_local;
          LoaderOptions const *param0_this = Dtool_Coerce_LoaderOptions(param0, param0_local);
          if ((param0_this != nullptr)) {
            LoaderOptions *return_value = new LoaderOptions(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LoaderOptions, true, false);
          }
        }
      }

      // No coercion possible: LoaderOptions::LoaderOptions(int flags)
    }
    break;
  case 2:
    {
      // 1-constexpr LoaderOptions::LoaderOptions(int flags, int texture_flags)
      int param0;
      int param1;
      static const char *keyword_list[] = {"flags", "texture_flags", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:LoaderOptions", (char **)keyword_list, &param0, &param1)) {
        LoaderOptions *return_value = new LoaderOptions((int)param0, (int)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LoaderOptions, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LoaderOptions() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LoaderOptions()\n"
      "LoaderOptions(const LoaderOptions param0)\n"
      "LoaderOptions(int flags)\n"
      "LoaderOptions(int flags, int texture_flags)\n");
  }
  return -1;
}

LoaderOptions *Dtool_Coerce_LoaderOptions(PyObject *args, LoaderOptions &coerced) {
  LoaderOptions *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_LoaderOptions)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const LoaderOptions *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LoaderOptions::LoaderOptions(int flags)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return nullptr;
      }
#endif
      coerced = LoaderOptions((int)arg_val);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-constexpr LoaderOptions::LoaderOptions(int flags, int texture_flags)
      int param0;
      int param1;
      if (PyArg_ParseTuple(args, "ii:LoaderOptions", &param0, &param1)) {
        coerced = LoaderOptions((int)param0, (int)param1);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_LoaderOptions(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LoaderOptions) {
    printf("LoaderOptions ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LoaderOptions *local_this = (LoaderOptions *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LoaderOptions) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LoaderOptions(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LoaderOptions) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BamReader
 */
/**
 * Python function wrapper for:
 * void BamReader::set_source(DatagramGenerator *source)
 */
static PyObject *Dtool_BamReader_set_source_219(PyObject *self, PyObject *arg) {
  BamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.set_source")) {
    return nullptr;
  }
  // 1-void BamReader::set_source(DatagramGenerator *source)
  DatagramGenerator *arg_this = (DatagramGenerator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DatagramGenerator, 1, "BamReader.set_source", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_source)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_source(const BamReader self, DatagramGenerator source)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamReader_set_source_219_comment =
  "C++ Interface:\n"
  "set_source(const BamReader self, DatagramGenerator source)\n"
  "\n"
  "/**\n"
  " * Changes the source of future datagrams for this BamReader.  This also\n"
  " * implicitly calls init() if it has not already been called.\n"
  " */";
#else
static const char *Dtool_BamReader_set_source_219_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DatagramGenerator *BamReader::get_source(void)
 */
static PyObject *Dtool_BamReader_get_source_220(PyObject *self, PyObject *) {
  BamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.get_source")) {
    return nullptr;
  }
  // 1-inline DatagramGenerator *BamReader::get_source(void)
  DatagramGenerator *return_value = ((*local_this).get_source)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramGenerator, false, false);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_source_220_comment =
  "C++ Interface:\n"
  "get_source(const BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns the current source of the BamReader as set by set_source() or the\n"
  " * constructor.\n"
  " */";
#else
static const char *Dtool_BamReader_get_source_220_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BamReader::init(void)
 */
static PyObject *Dtool_BamReader_init_221(PyObject *self, PyObject *) {
  BamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.init")) {
    return nullptr;
  }
  // 1-bool BamReader::init(void)
  bool return_value = ((*local_this).init)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_init_221_comment =
  "C++ Interface:\n"
  "init(const BamReader self)\n"
  "\n"
  "/**\n"
  " * Initializes the BamReader prior to reading any objects from its source.\n"
  " * This includes reading the Bam header.\n"
  " *\n"
  " * This returns true if the BamReader successfully initialized, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_BamReader_init_221_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &BamReader::get_filename(void) const
 */
static PyObject *Dtool_BamReader_get_filename_224(PyObject *self, PyObject *) {
  BamReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamReader)) {
    return nullptr;
  }
  // 1-inline Filename const &BamReader::get_filename(void) const
  Filename const *return_value = &(((*(const BamReader*)local_this).get_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_filename_224_comment =
  "C++ Interface:\n"
  "get_filename(BamReader self)\n"
  "\n"
  "/**\n"
  " * If a BAM is a file, then the BamReader should contain the name of the file.\n"
  " * This enables the reader to interpret pathnames in the BAM as relative to\n"
  " * the directory containing the BAM.\n"
  " */";
#else
static const char *Dtool_BamReader_get_filename_224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LoaderOptions const &BamReader::get_loader_options(void) const
 */
static PyObject *Dtool_BamReader_get_loader_options_225(PyObject *self, PyObject *) {
  BamReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamReader)) {
    return nullptr;
  }
  // 1-inline LoaderOptions const &BamReader::get_loader_options(void) const
  LoaderOptions const *return_value = &(((*(const BamReader*)local_this).get_loader_options)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LoaderOptions, false, true);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_loader_options_225_comment =
  "C++ Interface:\n"
  "get_loader_options(BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns the LoaderOptions passed to the loader when the model was\n"
  " * requested, if any.\n"
  " */";
#else
static const char *Dtool_BamReader_get_loader_options_225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BamReader::set_loader_options(LoaderOptions const &options)
 */
static PyObject *Dtool_BamReader_set_loader_options_226(PyObject *self, PyObject *arg) {
  BamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.set_loader_options")) {
    return nullptr;
  }
  // 1-inline void BamReader::set_loader_options(LoaderOptions const &options)
  LoaderOptions arg_local;
  LoaderOptions const *arg_this = Dtool_Coerce_LoaderOptions(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BamReader.set_loader_options", "LoaderOptions");
  }
  ((*local_this).set_loader_options)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_loader_options(const BamReader self, const LoaderOptions options)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamReader_set_loader_options_226_comment =
  "C++ Interface:\n"
  "set_loader_options(const BamReader self, const LoaderOptions options)\n"
  "\n"
  "/**\n"
  " * Specifies the LoaderOptions for this BamReader.\n"
  " */";
#else
static const char *Dtool_BamReader_set_loader_options_226_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedWritable *BamReader::read_object(void)
 */
static PyObject *Dtool_BamReader_read_object_227(PyObject *self, PyObject *) {
  BamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.read_object")) {
    return nullptr;
  }
  // 1-TypedWritable *BamReader::read_object(void)
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  PyThreadState *_save;
  Py_UNBLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  TypedWritable *return_value = ((*local_this).read_object)();
#if defined(HAVE_THREADS) && !defined(SIMPLE_THREADS)
  Py_BLOCK_THREADS
#endif  // HAVE_THREADS && !SIMPLE_THREADS
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    ReferenceCount *rc = return_value->as_reference_count();
    bool is_refcount = (rc != nullptr);
    if (is_refcount) {
      rc->ref();
    }
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritable, is_refcount, false, return_value->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BamReader_read_object_227_comment =
  "C++ Interface:\n"
  "read_object(const BamReader self)\n"
  "\n"
  "/**\n"
  " * Reads a single object from the Bam file.  If the object type is known, a\n"
  " * new object of the appropriate type is created and returned; otherwise, NULL\n"
  " * is returned.  NULL is also returned when the end of the file is reached.\n"
  " * is_eof() may be called to differentiate between these two cases.\n"
  " *\n"
  " * This may be called repeatedly to extract out all the objects in the Bam\n"
  " * file, but typically (especially for scene graph files, indicated with the\n"
  " * .bam extension), only one object is retrieved directly from the Bam file:\n"
  " * the root of the scene graph.  The remaining objects will all be retrieved\n"
  " * recursively by the first object.\n"
  " *\n"
  " * Note that the object returned may not yet be complete.  In particular, some\n"
  " * of its pointers may not be filled in; you must call resolve() to fill in\n"
  " * all the available pointers before you can safely use any objects returned\n"
  " * by read_object().\n"
  " *\n"
  " * This flavor of read_object() requires the caller to know what type of\n"
  " * object it has received in order to properly manage the reference counts.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Reads a single object from the Bam file.\n"
  " *\n"
  " * This flavor of read_object() returns both a TypedWritable and a\n"
  " * ReferenceCount pointer to the same object, so the reference count may be\n"
  " * tracked reliably, without having to know precisely what type of object we\n"
  " * have.\n"
  " * @return true on success, or false on failure.\n"
  " */";
#else
static const char *Dtool_BamReader_read_object_227_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BamReader::is_eof(void) const
 */
static PyObject *Dtool_BamReader_is_eof_228(PyObject *self, PyObject *) {
  BamReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamReader)) {
    return nullptr;
  }
  // 1-inline bool BamReader::is_eof(void) const
  bool return_value = ((*(const BamReader*)local_this).is_eof)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_is_eof_228_comment =
  "C++ Interface:\n"
  "is_eof(BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns true if the reader has reached end-of-file, false otherwise.  This\n"
  " * call is only valid after a call to read_object().\n"
  " */";
#else
static const char *Dtool_BamReader_is_eof_228_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BamReader::resolve(void)
 */
static PyObject *Dtool_BamReader_resolve_229(PyObject *self, PyObject *) {
  BamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.resolve")) {
    return nullptr;
  }
  // 1-bool BamReader::resolve(void)
  bool return_value = ((*local_this).resolve)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_resolve_229_comment =
  "C++ Interface:\n"
  "resolve(const BamReader self)\n"
  "\n"
  "/**\n"
  " * This may be called at any time during processing of the Bam file to resolve\n"
  " * all the known pointers so far.  It is usually called at the end of the\n"
  " * processing, after all objects have been read, which is generally the best\n"
  " * time to call it.\n"
  " *\n"
  " * This must be called at least once after reading a particular object via\n"
  " * get_object() in order to validate that object.\n"
  " *\n"
  " * The return value is true if all objects have been resolved, or false if\n"
  " * some objects are still outstanding (in which case you will need to call\n"
  " * resolve() again later).\n"
  " */";
#else
static const char *Dtool_BamReader_resolve_229_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BamReader::change_pointer(TypedWritable const *orig_pointer, TypedWritable const *new_pointer)
 */
static PyObject *Dtool_BamReader_change_pointer_230(PyObject *self, PyObject *args, PyObject *kwds) {
  BamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.change_pointer")) {
    return nullptr;
  }
  // 1-bool BamReader::change_pointer(TypedWritable const *orig_pointer, TypedWritable const *new_pointer)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"orig_pointer", "new_pointer", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:change_pointer", (char **)keyword_list, &param1, &param2)) {
    TypedWritable const *param1_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_TypedWritable, 1, "BamReader.change_pointer", true, true);
    TypedWritable const *param2_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_TypedWritable, 2, "BamReader.change_pointer", true, true);
    if (param1_this != nullptr && param2_this != nullptr) {
      bool return_value = ((*local_this).change_pointer)(param1_this, param2_this);
      return Dtool_Return_Bool(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "change_pointer(const BamReader self, const TypedWritable orig_pointer, const TypedWritable new_pointer)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamReader_change_pointer_230_comment =
  "C++ Interface:\n"
  "change_pointer(const BamReader self, const TypedWritable orig_pointer, const TypedWritable new_pointer)\n"
  "\n"
  "/**\n"
  " * Indicates that an object recently read from the bam stream should be\n"
  " * replaced with a new object.  Any future occurrences of the original object\n"
  " * in the stream will henceforth return the new object instead.\n"
  " *\n"
  " * The return value is true if the replacement was successfully made, or false\n"
  " * if the object was not read from the stream (or if change_pointer had\n"
  " * already been called on it).\n"
  " */";
#else
static const char *Dtool_BamReader_change_pointer_230_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BamReader::get_file_major_ver(void) const
 */
static PyObject *Dtool_BamReader_get_file_major_ver_231(PyObject *self, PyObject *) {
  BamReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamReader)) {
    return nullptr;
  }
  // 1-inline int BamReader::get_file_major_ver(void) const
  int return_value = ((*(const BamReader*)local_this).get_file_major_ver)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_file_major_ver_231_comment =
  "C++ Interface:\n"
  "get_file_major_ver(BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns the major version number of the Bam file currently being read.\n"
  " */";
#else
static const char *Dtool_BamReader_get_file_major_ver_231_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BamReader::get_file_minor_ver(void) const
 */
static PyObject *Dtool_BamReader_get_file_minor_ver_232(PyObject *self, PyObject *) {
  BamReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamReader)) {
    return nullptr;
  }
  // 1-inline int BamReader::get_file_minor_ver(void) const
  int return_value = ((*(const BamReader*)local_this).get_file_minor_ver)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_file_minor_ver_232_comment =
  "C++ Interface:\n"
  "get_file_minor_ver(BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns the minor version number of the Bam file currently being read.\n"
  " */";
#else
static const char *Dtool_BamReader_get_file_minor_ver_232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BamEnums::BamEndian BamReader::get_file_endian(void) const
 */
static PyObject *Dtool_BamReader_get_file_endian_233(PyObject *self, PyObject *) {
  BamReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamReader)) {
    return nullptr;
  }
  // 1-inline BamEnums::BamEndian BamReader::get_file_endian(void) const
  BamEnums::BamEndian return_value = ((*(const BamReader*)local_this).get_file_endian)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_file_endian_233_comment =
  "C++ Interface:\n"
  "get_file_endian(BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns the endian preference indicated by the Bam file currently being\n"
  " * read.  This does not imply that every number is stored using the indicated\n"
  " * convention, but individual objects may choose to respect this flag when\n"
  " * recording data.\n"
  " */";
#else
static const char *Dtool_BamReader_get_file_endian_233_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BamReader::get_file_stdfloat_double(void) const
 */
static PyObject *Dtool_BamReader_get_file_stdfloat_double_234(PyObject *self, PyObject *) {
  BamReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamReader)) {
    return nullptr;
  }
  // 1-inline bool BamReader::get_file_stdfloat_double(void) const
  bool return_value = ((*(const BamReader*)local_this).get_file_stdfloat_double)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_file_stdfloat_double_234_comment =
  "C++ Interface:\n"
  "get_file_stdfloat_double(BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns true if the file stores all \"standard\" floats as 64-bit doubles, or\n"
  " * false if they are 32-bit floats.  This is determined by the compilation\n"
  " * flags of the version of Panda that generated this file.\n"
  " */";
#else
static const char *Dtool_BamReader_get_file_stdfloat_double_234_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BamReader::get_current_major_ver(void) const
 */
static PyObject *Dtool_BamReader_get_current_major_ver_235(PyObject *self, PyObject *) {
  BamReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamReader)) {
    return nullptr;
  }
  // 1-inline int BamReader::get_current_major_ver(void) const
  int return_value = ((*(const BamReader*)local_this).get_current_major_ver)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_current_major_ver_235_comment =
  "C++ Interface:\n"
  "get_current_major_ver(BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns the major version number of Bam files supported by the current code\n"
  " * base.  This must match get_file_major_ver() in order to successfully read a\n"
  " * file.\n"
  " */";
#else
static const char *Dtool_BamReader_get_current_major_ver_235_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BamReader::get_current_minor_ver(void) const
 */
static PyObject *Dtool_BamReader_get_current_minor_ver_236(PyObject *self, PyObject *) {
  BamReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamReader)) {
    return nullptr;
  }
  // 1-inline int BamReader::get_current_minor_ver(void) const
  int return_value = ((*(const BamReader*)local_this).get_current_minor_ver)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_current_minor_ver_236_comment =
  "C++ Interface:\n"
  "get_current_minor_ver(BamReader self)\n"
  "\n"
  "/**\n"
  " * Returns the minor version number of Bam files supported by the current code\n"
  " * base.  This must match or exceed get_file_minor_ver() in order to\n"
  " * successfully read a file.\n"
  " */";
#else
static const char *Dtool_BamReader_get_current_minor_ver_236_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *BamReader::get_file_version(void) const
 */
static PyObject *Dtool_BamReader_get_file_version_237(PyObject *self, PyObject *) {
  BamReader *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamReader)) {
    return nullptr;
  }
  // 1-PyObject *BamReader::get_file_version(void) const
  PyObject *return_value = invoke_extension((const BamReader*)local_this).get_file_version();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamReader_get_file_version_237_comment =
  "C++ Interface:\n"
  "get_file_version(BamReader self)\n";
#else
static const char *Dtool_BamReader_get_file_version_237_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static void BamReader::register_factory(TypeHandle handle, PyObject *func)
 */
static PyObject *Dtool_BamReader_register_factory_250(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static void BamReader::register_factory(TypeHandle handle, PyObject *func)
  PyObject *param0;
  PyObject *param1;
  static const char *keyword_list[] = {"handle", "func", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:register_factory", (char **)keyword_list, &param0, &param1)) {
    TypeHandle param0_local;
    TypeHandle *param0_this = Dtool_Coerce_TypeHandle(param0, param0_local);
    if (!(param0_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param0, 0, "BamReader.register_factory", "TypeHandle");
    }
    Extension<BamReader>::register_factory(*param0_this, param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "register_factory(TypeHandle handle, object func)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamReader_register_factory_250_comment =
  "C++ Interface:\n"
  "register_factory(TypeHandle handle, object func)\n"
  "\n"
  "/**\n"
  " * Registers a factory function that is called when an object of the given\n"
  " * type is encountered within the .bam stream.\n"
  " *\n"
  " * @param user_data an optional pointer to be passed along to the function.\n"
  " */";
#else
static const char *Dtool_BamReader_register_factory_250_comment = nullptr;
#endif

static PyObject *Dtool_BamReader_source_Getter(PyObject *self, void *) {
  BamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.source")) {
    return nullptr;
  }

  // 1-inline DatagramGenerator *BamReader::get_source(void)
  DatagramGenerator *return_value = ((*local_this).get_source)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramGenerator, false, false);
}

static int Dtool_BamReader_source_Setter(PyObject *self, PyObject *arg, void *) {
  BamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.source")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete source attribute");
    return -1;
  }
  // 1-void BamReader::set_source(DatagramGenerator *source)
  DatagramGenerator *arg_this = (DatagramGenerator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DatagramGenerator, 1, "BamReader.set_source", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_source)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_source(const BamReader self, DatagramGenerator source)\n");
  }
  return -1;
}

static PyObject *Dtool_BamReader_filename_Getter(PyObject *self, void *) {
  const BamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Filename const &BamReader::get_filename(void) const
  Filename const *return_value = &(((*(const BamReader*)local_this).get_filename)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static PyObject *Dtool_BamReader_loader_options_Getter(PyObject *self, void *) {
  const BamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LoaderOptions const &BamReader::get_loader_options(void) const
  LoaderOptions const *return_value = &(((*(const BamReader*)local_this).get_loader_options)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LoaderOptions, false, true);
}

static int Dtool_BamReader_loader_options_Setter(PyObject *self, PyObject *arg, void *) {
  BamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamReader, (void **)&local_this, "BamReader.loader_options")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete loader_options attribute");
    return -1;
  }
  // 1-inline void BamReader::set_loader_options(LoaderOptions const &options)
  LoaderOptions arg_local;
  LoaderOptions const *arg_this = Dtool_Coerce_LoaderOptions(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BamReader.set_loader_options", "LoaderOptions");
    return -1;
  }
  ((*local_this).set_loader_options)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_loader_options(const BamReader self, const LoaderOptions options)\n");
  }
  return -1;
}

static PyObject *Dtool_BamReader_file_version_Getter(PyObject *self, void *) {
  const BamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return nullptr;
  }

  // 1-PyObject *BamReader::get_file_version(void) const
  PyObject *return_value = invoke_extension((const BamReader*)local_this).get_file_version();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BamReader_file_endian_Getter(PyObject *self, void *) {
  const BamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline BamEnums::BamEndian BamReader::get_file_endian(void) const
  BamEnums::BamEndian return_value = ((*(const BamReader*)local_this).get_file_endian)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BamReader_file_stdfloat_double_Getter(PyObject *self, void *) {
  const BamReader *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamReader, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool BamReader::get_file_stdfloat_double(void) const
  bool return_value = ((*(const BamReader*)local_this).get_file_stdfloat_double)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * explicit BamReader::BamReader(DatagramGenerator *source = nullptr)
 */
static int Dtool_Init_BamReader(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-explicit BamReader::BamReader(DatagramGenerator *source = nullptr)
  PyObject *param0 = nullptr;
  if (Dtool_ExtractOptionalArg(&param0, args, kwds, "source")) {
    DatagramGenerator *param0_this = nullptr;
    if (param0 != nullptr && param0 != Py_None) {
      param0_this = (DatagramGenerator *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_DatagramGenerator, 0, "BamReader.BamReader", false, true);
    }
    if ((param0 == nullptr || param0 == Py_None || param0_this != nullptr)) {
      BamReader *return_value = new BamReader(param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BamReader, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BamReader(DatagramGenerator source)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BamReader(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BamReader) {
    printf("BamReader ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BamReader *local_this = (BamReader *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BamReader) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BamEnums) {
    return (BamEnums *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BamReader(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BamReader) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BamEnums) {
    BamEnums* other_this = (BamEnums*)from_this;
    return (BamReader*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BamWriter
 */
/**
 * Python function wrapper for:
 * void BamWriter::set_target(DatagramSink *target)
 */
static PyObject *Dtool_BamWriter_set_target_254(PyObject *self, PyObject *arg) {
  BamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.set_target")) {
    return nullptr;
  }
  // 1-void BamWriter::set_target(DatagramSink *target)
  DatagramSink *arg_this = (DatagramSink *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DatagramSink, 1, "BamWriter.set_target", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_target)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_target(const BamWriter self, DatagramSink target)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_set_target_254_comment =
  "C++ Interface:\n"
  "set_target(const BamWriter self, DatagramSink target)\n"
  "\n"
  "/**\n"
  " * Changes the destination of future datagrams written by the BamWriter.  This\n"
  " * also implicitly calls init() if it has not already been called.\n"
  " */";
#else
static const char *Dtool_BamWriter_set_target_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DatagramSink *BamWriter::get_target(void)
 */
static PyObject *Dtool_BamWriter_get_target_255(PyObject *self, PyObject *) {
  BamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.get_target")) {
    return nullptr;
  }
  // 1-inline DatagramSink *BamWriter::get_target(void)
  DatagramSink *return_value = ((*local_this).get_target)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramSink, false, false);
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_get_target_255_comment =
  "C++ Interface:\n"
  "get_target(const BamWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the current target of the BamWriter as set by set_target() or the\n"
  " * constructor.\n"
  " */";
#else
static const char *Dtool_BamWriter_get_target_255_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BamWriter::init(void)
 */
static PyObject *Dtool_BamWriter_init_256(PyObject *self, PyObject *) {
  BamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.init")) {
    return nullptr;
  }
  // 1-bool BamWriter::init(void)
  bool return_value = ((*local_this).init)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_init_256_comment =
  "C++ Interface:\n"
  "init(const BamWriter self)\n"
  "\n"
  "/**\n"
  " * Initializes the BamWriter prior to writing any objects to its output\n"
  " * stream.  This includes writing out the Bam header.\n"
  " *\n"
  " * This returns true if the BamWriter successfully initialized, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_BamWriter_init_256_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Filename const &BamWriter::get_filename(void) const
 */
static PyObject *Dtool_BamWriter_get_filename_257(PyObject *self, PyObject *) {
  BamWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamWriter)) {
    return nullptr;
  }
  // 1-inline Filename const &BamWriter::get_filename(void) const
  Filename const *return_value = &(((*(const BamWriter*)local_this).get_filename)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_get_filename_257_comment =
  "C++ Interface:\n"
  "get_filename(BamWriter self)\n"
  "\n"
  "/**\n"
  " * If a BAM is a file, then the BamWriter should contain the name of the file.\n"
  " * This enables the writer to convert pathnames in the BAM to relative to the\n"
  " * directory containing the BAM.\n"
  " */";
#else
static const char *Dtool_BamWriter_get_filename_257_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BamWriter::write_object(TypedWritable const *obj)
 */
static PyObject *Dtool_BamWriter_write_object_258(PyObject *self, PyObject *arg) {
  BamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.write_object")) {
    return nullptr;
  }
  // 1-bool BamWriter::write_object(TypedWritable const *obj)
  TypedWritable const *arg_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritable, 1, "BamWriter.write_object", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).write_object)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_object(const BamWriter self, const TypedWritable obj)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_write_object_258_comment =
  "C++ Interface:\n"
  "write_object(const BamWriter self, const TypedWritable obj)\n"
  "\n"
  "/**\n"
  " * Writes a single object to the Bam file, so that the\n"
  " * BamReader::read_object() can later correctly restore the object and all its\n"
  " * pointers.\n"
  " *\n"
  " * This implicitly also writes any additional objects this object references\n"
  " * (if they haven't already been written), so that pointers may be fully\n"
  " * resolved.\n"
  " *\n"
  " * This may be called repeatedly to write a sequence of objects to the Bam\n"
  " * file, but typically (especially for scene graph files, indicated with the\n"
  " * .bam extension), only one object is written directly from the Bam file: the\n"
  " * root of the scene graph.  The remaining objects will all be written\n"
  " * recursively by the first object.\n"
  " *\n"
  " * Returns true if the object is successfully written, false otherwise.\n"
  " */";
#else
static const char *Dtool_BamWriter_write_object_258_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BamWriter::has_object(TypedWritable const *obj) const
 */
static PyObject *Dtool_BamWriter_has_object_259(PyObject *self, PyObject *arg) {
  BamWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamWriter)) {
    return nullptr;
  }
  // 1-bool BamWriter::has_object(TypedWritable const *obj) const
  TypedWritable const *arg_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritable, 1, "BamWriter.has_object", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const BamWriter*)local_this).has_object)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_object(BamWriter self, const TypedWritable obj)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_has_object_259_comment =
  "C++ Interface:\n"
  "has_object(BamWriter self, const TypedWritable obj)\n"
  "\n"
  "/**\n"
  " * Returns true if the object has previously been written (or at least\n"
  " * requested to be written) to the bam file, or false if we've never heard of\n"
  " * it before.\n"
  " */";
#else
static const char *Dtool_BamWriter_has_object_259_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BamWriter::flush(void)
 */
static PyObject *Dtool_BamWriter_flush_260(PyObject *self, PyObject *) {
  BamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.flush")) {
    return nullptr;
  }
  // 1-void BamWriter::flush(void)
  ((*local_this).flush)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_flush_260_comment =
  "C++ Interface:\n"
  "flush(const BamWriter self)\n"
  "\n"
  "/**\n"
  " * Ensures that all data written thus far is manifested on the output stream.\n"
  " */";
#else
static const char *Dtool_BamWriter_flush_260_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BamWriter::get_file_major_ver(void) const
 */
static PyObject *Dtool_BamWriter_get_file_major_ver_261(PyObject *self, PyObject *) {
  BamWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamWriter)) {
    return nullptr;
  }
  // 1-inline int BamWriter::get_file_major_ver(void) const
  int return_value = ((*(const BamWriter*)local_this).get_file_major_ver)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_get_file_major_ver_261_comment =
  "C++ Interface:\n"
  "get_file_major_ver(BamWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the major version number of the Bam file currently being written.\n"
  " */";
#else
static const char *Dtool_BamWriter_get_file_major_ver_261_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BamWriter::get_file_minor_ver(void) const
 */
static PyObject *Dtool_BamWriter_get_file_minor_ver_262(PyObject *self, PyObject *) {
  BamWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamWriter)) {
    return nullptr;
  }
  // 1-inline int BamWriter::get_file_minor_ver(void) const
  int return_value = ((*(const BamWriter*)local_this).get_file_minor_ver)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_get_file_minor_ver_262_comment =
  "C++ Interface:\n"
  "get_file_minor_ver(BamWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the minor version number of the Bam file currently being written.\n"
  " */";
#else
static const char *Dtool_BamWriter_get_file_minor_ver_262_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BamWriter::set_file_minor_ver(int minor_ver)
 */
static PyObject *Dtool_BamWriter_set_file_minor_ver_263(PyObject *self, PyObject *arg) {
  BamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.set_file_minor_ver")) {
    return nullptr;
  }
  // 1-inline void BamWriter::set_file_minor_ver(int minor_ver)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_file_minor_ver)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_file_minor_ver(const BamWriter self, int minor_ver)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_set_file_minor_ver_263_comment =
  "C++ Interface:\n"
  "set_file_minor_ver(const BamWriter self, int minor_ver)\n"
  "\n"
  "/**\n"
  " * Changes the minor .bam version to write.  This should be called before\n"
  " * init().  Each Panda version has only a fairly narrow range of versions it\n"
  " * is able to write; consult the .bam documentation for more information.\n"
  " */";
#else
static const char *Dtool_BamWriter_set_file_minor_ver_263_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BamEnums::BamEndian BamWriter::get_file_endian(void) const
 */
static PyObject *Dtool_BamWriter_get_file_endian_264(PyObject *self, PyObject *) {
  BamWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamWriter)) {
    return nullptr;
  }
  // 1-inline BamEnums::BamEndian BamWriter::get_file_endian(void) const
  BamEnums::BamEndian return_value = ((*(const BamWriter*)local_this).get_file_endian)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_get_file_endian_264_comment =
  "C++ Interface:\n"
  "get_file_endian(BamWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the endian preference indicated by the Bam file currently being\n"
  " * written.  This does not imply that every number is stored using the\n"
  " * indicated convention, but individual objects may choose to respect this\n"
  " * flag when recording data.\n"
  " */";
#else
static const char *Dtool_BamWriter_get_file_endian_264_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BamWriter::get_file_stdfloat_double(void) const
 */
static PyObject *Dtool_BamWriter_get_file_stdfloat_double_265(PyObject *self, PyObject *) {
  BamWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamWriter)) {
    return nullptr;
  }
  // 1-inline bool BamWriter::get_file_stdfloat_double(void) const
  bool return_value = ((*(const BamWriter*)local_this).get_file_stdfloat_double)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_get_file_stdfloat_double_265_comment =
  "C++ Interface:\n"
  "get_file_stdfloat_double(BamWriter self)\n"
  "\n"
  "/**\n"
  " * Returns true if the file will store all \"standard\" floats as 64-bit\n"
  " * doubles, or false if they are 32-bit floats.  This isn't runtime settable;\n"
  " * it's based on the compilation flags of the version of Panda that generated\n"
  " * this file.\n"
  " */";
#else
static const char *Dtool_BamWriter_get_file_stdfloat_double_265_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BamEnums::BamTextureMode BamWriter::get_file_texture_mode(void) const
 */
static PyObject *Dtool_BamWriter_get_file_texture_mode_266(PyObject *self, PyObject *) {
  BamWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamWriter)) {
    return nullptr;
  }
  // 1-inline BamEnums::BamTextureMode BamWriter::get_file_texture_mode(void) const
  BamEnums::BamTextureMode return_value = ((*(const BamWriter*)local_this).get_file_texture_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_get_file_texture_mode_266_comment =
  "C++ Interface:\n"
  "get_file_texture_mode(BamWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the BamTextureMode preference indicated by the Bam file currently\n"
  " * being written.  Texture objects written to this Bam file will be encoded\n"
  " * according to the specified mode.\n"
  " */";
#else
static const char *Dtool_BamWriter_get_file_texture_mode_266_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BamWriter::set_file_texture_mode(BamEnums::BamTextureMode file_texture_mode)
 */
static PyObject *Dtool_BamWriter_set_file_texture_mode_267(PyObject *self, PyObject *arg) {
  BamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.set_file_texture_mode")) {
    return nullptr;
  }
  // 1-inline void BamWriter::set_file_texture_mode(BamEnums::BamTextureMode file_texture_mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_file_texture_mode)((BamEnums::BamTextureMode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_file_texture_mode(const BamWriter self, int file_texture_mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_set_file_texture_mode_267_comment =
  "C++ Interface:\n"
  "set_file_texture_mode(const BamWriter self, int file_texture_mode)\n"
  "\n"
  "/**\n"
  " * Changes the BamTextureMode preference for the Bam file currently being\n"
  " * written.  Texture objects written to this Bam file will be encoded\n"
  " * according to the specified mode.\n"
  " */";
#else
static const char *Dtool_BamWriter_set_file_texture_mode_267_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TypedWritable *BamWriter::get_root_node(void) const
 */
static PyObject *Dtool_BamWriter_get_root_node_268(PyObject *self, PyObject *) {
  BamWriter *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BamWriter)) {
    return nullptr;
  }
  // 1-inline TypedWritable *BamWriter::get_root_node(void) const
  TypedWritable *return_value = ((*(const BamWriter*)local_this).get_root_node)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    ReferenceCount *rc = return_value->as_reference_count();
    bool is_refcount = (rc != nullptr);
    if (is_refcount) {
      rc->ref();
    }
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritable, is_refcount, false, return_value->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_get_root_node_268_comment =
  "C++ Interface:\n"
  "get_root_node(BamWriter self)\n"
  "\n"
  "/**\n"
  " * Returns the root node of the part of the scene graph we are currently\n"
  " * writing out.  This is used for determining what to make NodePaths relative\n"
  " * to.\n"
  " */";
#else
static const char *Dtool_BamWriter_get_root_node_268_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BamWriter::set_root_node(TypedWritable *root_node)
 */
static PyObject *Dtool_BamWriter_set_root_node_269(PyObject *self, PyObject *arg) {
  BamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.set_root_node")) {
    return nullptr;
  }
  // 1-inline void BamWriter::set_root_node(TypedWritable *root_node)
  TypedWritable *arg_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritable, 1, "BamWriter.set_root_node", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_root_node)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_root_node(const BamWriter self, TypedWritable root_node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BamWriter_set_root_node_269_comment =
  "C++ Interface:\n"
  "set_root_node(const BamWriter self, TypedWritable root_node)\n"
  "\n"
  "/**\n"
  " * Sets the root node of the part of the scene graph we are currently writing\n"
  " * out.  NodePaths written to this bam file will be relative to this node.\n"
  " */";
#else
static const char *Dtool_BamWriter_set_root_node_269_comment = nullptr;
#endif

static PyObject *Dtool_BamWriter_target_Getter(PyObject *self, void *) {
  BamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.target")) {
    return nullptr;
  }

  // 1-inline DatagramSink *BamWriter::get_target(void)
  DatagramSink *return_value = ((*local_this).get_target)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramSink, false, false);
}

static int Dtool_BamWriter_target_Setter(PyObject *self, PyObject *arg, void *) {
  BamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.target")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete target attribute");
    return -1;
  }
  // 1-void BamWriter::set_target(DatagramSink *target)
  DatagramSink *arg_this = (DatagramSink *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DatagramSink, 1, "BamWriter.set_target", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_target)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_target(const BamWriter self, DatagramSink target)\n");
  }
  return -1;
}

static PyObject *Dtool_BamWriter_filename_Getter(PyObject *self, void *) {
  const BamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Filename const &BamWriter::get_filename(void) const
  Filename const *return_value = &(((*(const BamWriter*)local_this).get_filename)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_Filename, false, true);
}

static PyObject *Dtool_BamWriter_file_endian_Getter(PyObject *self, void *) {
  const BamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline BamEnums::BamEndian BamWriter::get_file_endian(void) const
  BamEnums::BamEndian return_value = ((*(const BamWriter*)local_this).get_file_endian)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BamWriter_file_stdfloat_double_Getter(PyObject *self, void *) {
  const BamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool BamWriter::get_file_stdfloat_double(void) const
  bool return_value = ((*(const BamWriter*)local_this).get_file_stdfloat_double)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BamWriter_file_texture_mode_Getter(PyObject *self, void *) {
  const BamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline BamEnums::BamTextureMode BamWriter::get_file_texture_mode(void) const
  BamEnums::BamTextureMode return_value = ((*(const BamWriter*)local_this).get_file_texture_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_BamWriter_root_node_Getter(PyObject *self, void *) {
  const BamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamWriter, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline TypedWritable *BamWriter::get_root_node(void) const
  TypedWritable *return_value = ((*(const BamWriter*)local_this).get_root_node)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    ReferenceCount *rc = return_value->as_reference_count();
    bool is_refcount = (rc != nullptr);
    if (is_refcount) {
      rc->ref();
    }
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedWritable, is_refcount, false, return_value->get_type_index());
  }
}

static int Dtool_BamWriter_root_node_Setter(PyObject *self, PyObject *arg, void *) {
  BamWriter *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BamWriter, (void **)&local_this, "BamWriter.root_node")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete root_node attribute");
    return -1;
  }
  // 1-inline void BamWriter::set_root_node(TypedWritable *root_node)
  TypedWritable *arg_this = (TypedWritable *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedWritable, 1, "BamWriter.set_root_node", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_root_node)(arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_root_node(const BamWriter self, TypedWritable root_node)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline BamWriter::BamWriter(BamWriter const &) = default
 * explicit BamWriter::BamWriter(DatagramSink *target = nullptr)
 */
static int Dtool_Init_BamWriter(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-explicit BamWriter::BamWriter(DatagramSink *target)
      BamWriter *return_value = new BamWriter();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BamWriter, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline BamWriter::BamWriter(BamWriter const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          BamWriter const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_BamWriter);
          if (param0_this != nullptr) {
            BamWriter *return_value = new BamWriter(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BamWriter, true, false);
          }
        }
      }

      {
        // -2 explicit BamWriter::BamWriter(DatagramSink *target)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "target")) {
          DatagramSink *param0_this = nullptr;
          if (param0 != Py_None) {
            param0_this = (DatagramSink *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_DatagramSink, 0, "BamWriter.BamWriter", false, false);
          }
          if ((param0 == Py_None || param0_this != nullptr)) {
            BamWriter *return_value = new BamWriter(param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BamWriter, true, false);
          }
        }
      }

      // No coercion possible: inline BamWriter::BamWriter(BamWriter const &) = default
      // No coercion possible: explicit BamWriter::BamWriter(DatagramSink *target)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BamWriter() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BamWriter()\n"
      "BamWriter(const BamWriter param0)\n"
      "BamWriter(DatagramSink target)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BamWriter(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BamWriter) {
    printf("BamWriter ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BamWriter *local_this = (BamWriter *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BamWriter) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BamEnums) {
    return (BamEnums *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BamWriter(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BamWriter) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BamEnums) {
    BamEnums* other_this = (BamEnums*)from_this;
    return (BamWriter*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BitMask< uint16_t, 16 >
 */
/**
 * Python function wrapper for:
 * static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::all_on(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_all_on_280(PyObject *, PyObject *) {
  // 1-static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::all_on(void)
  BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((BitMask< uint16_t, 16 >::all_on)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_all_on_280_comment =
  "C++ Interface:\n"
  "all_on()\n";
#else
static const char *Dtool_BitMask_uint16_t_16_all_on_280_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::all_off(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_all_off_281(PyObject *, PyObject *) {
  // 1-static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::all_off(void)
  BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((BitMask< uint16_t, 16 >::all_off)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_all_off_281_comment =
  "C++ Interface:\n"
  "all_off()\n";
#else
static const char *Dtool_BitMask_uint16_t_16_all_off_281_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::lower_on(int on_bits)
 */
static PyObject *Dtool_BitMask_uint16_t_16_lower_on_282(PyObject *, PyObject *arg) {
  // 1-static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::lower_on(int on_bits)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((BitMask< uint16_t, 16 >::lower_on)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lower_on(int on_bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_lower_on_282_comment =
  "C++ Interface:\n"
  "lower_on(int on_bits)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_lower_on_282_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::bit(int index)
 */
static PyObject *Dtool_BitMask_uint16_t_16_bit_283(PyObject *, PyObject *arg) {
  // 1-static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((BitMask< uint16_t, 16 >::bit)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bit(int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_bit_283_comment =
  "C++ Interface:\n"
  "bit(int index)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_bit_283_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint16_t_16_range_284(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::range(int low_bit, int size)
  int param0;
  int param1;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:range", (char **)keyword_list, &param0, &param1)) {
    BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((BitMask< uint16_t, 16 >::range)((int)param0, (int)param1));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "range(int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_range_284_comment =
  "C++ Interface:\n"
  "range(int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_range_284_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr bool BitMask< uint16_t, 16 >::has_max_num_bits(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_has_max_num_bits_285(PyObject *, PyObject *) {
  // 1-static constexpr bool BitMask< uint16_t, 16 >::has_max_num_bits(void)
  bool return_value = (BitMask< uint16_t, 16 >::has_max_num_bits)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_has_max_num_bits_285_comment =
  "C++ Interface:\n"
  "has_max_num_bits()\n";
#else
static const char *Dtool_BitMask_uint16_t_16_has_max_num_bits_285_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr int BitMask< uint16_t, 16 >::get_max_num_bits(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_max_num_bits_286(PyObject *, PyObject *) {
  // 1-static constexpr int BitMask< uint16_t, 16 >::get_max_num_bits(void)
  int return_value = (BitMask< uint16_t, 16 >::get_max_num_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_max_num_bits_286_comment =
  "C++ Interface:\n"
  "get_max_num_bits()\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_max_num_bits_286_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * constexpr int BitMask< uint16_t, 16 >::get_num_bits(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_num_bits_287(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-constexpr int BitMask< uint16_t, 16 >::get_num_bits(void) const
  int return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).get_num_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_num_bits_287_comment =
  "C++ Interface:\n"
  "get_num_bits(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_num_bits_287_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint16_t, 16 >::get_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_bit_288(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint16_t, 16 >::get_bit(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).get_bit)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bit(BitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_bit_288_comment =
  "C++ Interface:\n"
  "get_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_bit_288_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::set_bit(int index)
 */
static PyObject *Dtool_BitMask_uint16_t_16_set_bit_289(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.set_bit")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint16_t, 16 >::set_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_bit)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit(const BitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_set_bit_289_comment =
  "C++ Interface:\n"
  "set_bit(const BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_set_bit_289_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::clear_bit(int index)
 */
static PyObject *Dtool_BitMask_uint16_t_16_clear_bit_290(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.clear_bit")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint16_t, 16 >::clear_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).clear_bit)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_bit(const BitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_clear_bit_290_comment =
  "C++ Interface:\n"
  "clear_bit(const BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_clear_bit_290_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::set_bit_to(int index, bool value)
 */
static PyObject *Dtool_BitMask_uint16_t_16_set_bit_to_291(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.set_bit_to")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint16_t, 16 >::set_bit_to(int index, bool value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_bit_to", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_bit_to)((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit_to(const BitMask self, int index, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_set_bit_to_291_comment =
  "C++ Interface:\n"
  "set_bit_to(const BitMask self, int index, bool value)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_set_bit_to_291_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint16_t, 16 >::is_zero(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_is_zero_292(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint16_t, 16 >::is_zero(void) const
  bool return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).is_zero)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_is_zero_292_comment =
  "C++ Interface:\n"
  "is_zero(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_is_zero_292_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint16_t, 16 >::is_all_on(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_is_all_on_293(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint16_t, 16 >::is_all_on(void) const
  bool return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).is_all_on)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_is_all_on_293_comment =
  "C++ Interface:\n"
  "is_all_on(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_is_all_on_293_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint16_t BitMask< uint16_t, 16 >::extract(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_extract_294(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline uint16_t BitMask< uint16_t, 16 >::extract(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:extract", (char **)keyword_list, &param1, &param2)) {
    uint16_t return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).extract)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract(BitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_extract_294_comment =
  "C++ Interface:\n"
  "extract(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_extract_294_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::store(uint16_t value, int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint16_t_16_store_295(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.store")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint16_t, 16 >::store(uint16_t value, int low_bit, int size)
  long param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "lii:store", (char **)keyword_list, &param1, &param2, &param3)) {
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    ((*local_this).store)((uint16_t)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store(const BitMask self, int value, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_store_295_comment =
  "C++ Interface:\n"
  "store(const BitMask self, int value, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_store_295_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint16_t, 16 >::has_any_of(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_has_any_of_296(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint16_t, 16 >::has_any_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_any_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).has_any_of)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_any_of(BitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_has_any_of_296_comment =
  "C++ Interface:\n"
  "has_any_of(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_has_any_of_296_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint16_t, 16 >::has_all_of(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_has_all_of_297(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint16_t, 16 >::has_all_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_all_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).has_all_of)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_all_of(BitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_has_all_of_297_comment =
  "C++ Interface:\n"
  "has_all_of(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_has_all_of_297_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::set_range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint16_t_16_set_range_298(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.set_range")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint16_t, 16 >::set_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_range", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_range)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range(const BitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_set_range_298_comment =
  "C++ Interface:\n"
  "set_range(const BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_set_range_298_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::clear_range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint16_t_16_clear_range_299(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.clear_range")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint16_t, 16 >::clear_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:clear_range", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).clear_range)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_range(const BitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_clear_range_299_comment =
  "C++ Interface:\n"
  "clear_range(const BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_clear_range_299_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::set_range_to(bool value, int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint16_t_16_set_range_to_300(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.set_range_to")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint16_t, 16 >::set_range_to(bool value, int low_bit, int size)
  PyObject *param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_range_to", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_range_to)((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range_to(const BitMask self, bool value, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_set_range_to_300_comment =
  "C++ Interface:\n"
  "set_range_to(const BitMask self, bool value, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_set_range_to_300_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint16_t BitMask< uint16_t, 16 >::get_word(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_word_301(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline uint16_t BitMask< uint16_t, 16 >::get_word(void) const
  uint16_t return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).get_word)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_word_301_comment =
  "C++ Interface:\n"
  "get_word(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_word_301_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::set_word(uint16_t value)
 */
static PyObject *Dtool_BitMask_uint16_t_16_set_word_302(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.set_word")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint16_t, 16 >::set_word(uint16_t value)
  if (PyLongOrInt_Check(arg)) {
    long param1 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
    if (param1 < 0 || param1 > USHRT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for unsigned short integer",
                          param1);
    }
#endif
    ((*local_this).set_word)((uint16_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const BitMask self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_set_word_302_comment =
  "C++ Interface:\n"
  "set_word(const BitMask self, int value)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_set_word_302_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::get_num_on_bits(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_num_on_bits_303(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint16_t, 16 >::get_num_on_bits(void) const
  int return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).get_num_on_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_num_on_bits_303_comment =
  "C++ Interface:\n"
  "get_num_on_bits(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_num_on_bits_303_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::get_num_off_bits(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_num_off_bits_304(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint16_t, 16 >::get_num_off_bits(void) const
  int return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).get_num_off_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_num_off_bits_304_comment =
  "C++ Interface:\n"
  "get_num_off_bits(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_num_off_bits_304_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::get_lowest_on_bit(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_lowest_on_bit_305(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint16_t, 16 >::get_lowest_on_bit(void) const
  int return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).get_lowest_on_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_lowest_on_bit_305_comment =
  "C++ Interface:\n"
  "get_lowest_on_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_lowest_on_bit_305_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::get_lowest_off_bit(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_lowest_off_bit_306(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint16_t, 16 >::get_lowest_off_bit(void) const
  int return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).get_lowest_off_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_lowest_off_bit_306_comment =
  "C++ Interface:\n"
  "get_lowest_off_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_lowest_off_bit_306_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::get_highest_on_bit(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_highest_on_bit_307(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint16_t, 16 >::get_highest_on_bit(void) const
  int return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).get_highest_on_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_highest_on_bit_307_comment =
  "C++ Interface:\n"
  "get_highest_on_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_highest_on_bit_307_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::get_highest_off_bit(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_highest_off_bit_308(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint16_t, 16 >::get_highest_off_bit(void) const
  int return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).get_highest_off_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_highest_off_bit_308_comment =
  "C++ Interface:\n"
  "get_highest_off_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_highest_off_bit_308_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::get_next_higher_different_bit(int low_bit) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_next_higher_different_bit_309(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint16_t, 16 >::get_next_higher_different_bit(int low_bit) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).get_next_higher_different_bit)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_next_higher_different_bit(BitMask self, int low_bit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_next_higher_different_bit_309_comment =
  "C++ Interface:\n"
  "get_next_higher_different_bit(BitMask self, int low_bit)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_next_higher_different_bit_309_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::invert_in_place(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_invert_in_place_310(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.invert_in_place")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint16_t, 16 >::invert_in_place(void)
  ((*local_this).invert_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_invert_in_place_310_comment =
  "C++ Interface:\n"
  "invert_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_invert_in_place_310_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint16_t, 16 >::has_bits_in_common(BitMask< uint16_t, 16 > const &other) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_has_bits_in_common_311(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint16_t, 16 >::has_bits_in_common(BitMask< uint16_t, 16 > const &other) const
  BitMask< uint16_t, 16 > arg_local;
  BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.has_bits_in_common", "BitMask");
  }
  bool return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).has_bits_in_common)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_bits_in_common(BitMask self, const BitMask other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_has_bits_in_common_311_comment =
  "C++ Interface:\n"
  "has_bits_in_common(BitMask self, const BitMask other)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_has_bits_in_common_311_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::clear(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_clear_312(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.clear")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint16_t, 16 >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_clear_312_comment =
  "C++ Interface:\n"
  "clear(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_clear_312_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint16_t, 16 >::output(std::ostream &out) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_output_313(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-void BitMask< uint16_t, 16 >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "BitMask.output", false, true);
  if (arg_this != nullptr) {
    ((*(const BitMask< uint16_t, 16 >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BitMask self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_output_313_comment =
  "C++ Interface:\n"
  "output(BitMask self, ostream out)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_output_313_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint16_t, 16 >::output_binary(std::ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_output_binary_314(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-void BitMask< uint16_t, 16 >::output_binary(std::ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_binary", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BitMask.output_binary", false, true);
    if (param1_this != nullptr) {
      ((*(const BitMask< uint16_t, 16 >*)local_this).output_binary)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_binary(BitMask self, ostream out, int spaces_every)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_output_binary_314_comment =
  "C++ Interface:\n"
  "output_binary(BitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_output_binary_314_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint16_t, 16 >::output_hex(std::ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_output_hex_315(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-void BitMask< uint16_t, 16 >::output_hex(std::ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_hex", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BitMask.output_hex", false, true);
    if (param1_this != nullptr) {
      ((*(const BitMask< uint16_t, 16 >*)local_this).output_hex)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_hex(BitMask self, ostream out, int spaces_every)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_output_hex_315_comment =
  "C++ Interface:\n"
  "output_hex(BitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_output_hex_315_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint16_t, 16 >::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_write_316(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-void BitMask< uint16_t, 16 >::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BitMask.write", false, true);
    if (param1_this != nullptr) {
      ((*(const BitMask< uint16_t, 16 >*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BitMask self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_write_316_comment =
  "C++ Interface:\n"
  "write(BitMask self, ostream out, int indent_level)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_write_316_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::compare_to(BitMask< uint16_t, 16 > const &other) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_compare_to_320(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint16_t, 16 >::compare_to(BitMask< uint16_t, 16 > const &other) const
  BitMask< uint16_t, 16 > arg_local;
  BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.compare_to", "BitMask");
  }
  int return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).compare_to)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(BitMask self, const BitMask other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_compare_to_320_comment =
  "C++ Interface:\n"
  "compare_to(BitMask self, const BitMask other)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_compare_to_320_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::flood_down_in_place(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_flood_down_in_place_332(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.flood_down_in_place")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint16_t, 16 >::flood_down_in_place(void)
  ((*local_this).flood_down_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_flood_down_in_place_332_comment =
  "C++ Interface:\n"
  "flood_down_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_flood_down_in_place_332_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint16_t, 16 >::flood_up_in_place(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_flood_up_in_place_333(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint16_t_16, (void **)&local_this, "BitMask_uint16_t_16.flood_up_in_place")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint16_t, 16 >::flood_up_in_place(void)
  ((*local_this).flood_up_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_flood_up_in_place_333_comment =
  "C++ Interface:\n"
  "flood_up_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_flood_up_in_place_333_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::flood_bits_down(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_flood_bits_down_334(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::flood_bits_down(void) const
  BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(((*(const BitMask< uint16_t, 16 >*)local_this).flood_bits_down)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_flood_bits_down_334_comment =
  "C++ Interface:\n"
  "flood_bits_down(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_flood_bits_down_334_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::flood_bits_up(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_flood_bits_up_335(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::flood_bits_up(void) const
  BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(((*(const BitMask< uint16_t, 16 >*)local_this).flood_bits_up)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_flood_bits_up_335_comment =
  "C++ Interface:\n"
  "flood_bits_up(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_flood_bits_up_335_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(void) const
 * inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(BitMask< uint16_t, 16 > const &other) const
 * inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_keep_next_highest_bit_336(PyObject *self, PyObject *args) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(void) const
      BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(((*(const BitMask< uint16_t, 16 >*)local_this).keep_next_highest_bit)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(BitMask< uint16_t, 16 > const &other) const
        BitMask< uint16_t, 16 > const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_BitMask_uint16_t_16);
        if (arg_this != nullptr) {
          BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(((*(const BitMask< uint16_t, 16 >*)local_this).keep_next_highest_bit)(*arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
        }
      }

      {
        // -2 inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(int index) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(((*(const BitMask< uint16_t, 16 >*)local_this).keep_next_highest_bit)((int)arg_val));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
        }
      }

      {
        // -2 inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(BitMask< uint16_t, 16 > const &other) const
        BitMask< uint16_t, 16 > arg_local;
        BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
        if ((arg_this != nullptr)) {
          BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(((*(const BitMask< uint16_t, 16 >*)local_this).keep_next_highest_bit)(*arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
        }
      }

      // No coercion possible: inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_highest_bit(int index) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "keep_next_highest_bit() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "keep_next_highest_bit(BitMask self)\n"
      "keep_next_highest_bit(BitMask self, const BitMask other)\n"
      "keep_next_highest_bit(BitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_keep_next_highest_bit_336_comment =
  "C++ Interface:\n"
  "keep_next_highest_bit(BitMask self)\n"
  "keep_next_highest_bit(BitMask self, const BitMask other)\n"
  "keep_next_highest_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_keep_next_highest_bit_336_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(void) const
 * inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(BitMask< uint16_t, 16 > const &other) const
 * inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_keep_next_lowest_bit_337(PyObject *self, PyObject *args) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(void) const
      BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(((*(const BitMask< uint16_t, 16 >*)local_this).keep_next_lowest_bit)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(BitMask< uint16_t, 16 > const &other) const
        BitMask< uint16_t, 16 > const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_BitMask_uint16_t_16);
        if (arg_this != nullptr) {
          BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(((*(const BitMask< uint16_t, 16 >*)local_this).keep_next_lowest_bit)(*arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
        }
      }

      {
        // -2 inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(int index) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(((*(const BitMask< uint16_t, 16 >*)local_this).keep_next_lowest_bit)((int)arg_val));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
        }
      }

      {
        // -2 inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(BitMask< uint16_t, 16 > const &other) const
        BitMask< uint16_t, 16 > arg_local;
        BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
        if ((arg_this != nullptr)) {
          BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(((*(const BitMask< uint16_t, 16 >*)local_this).keep_next_lowest_bit)(*arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
        }
      }

      // No coercion possible: inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::keep_next_lowest_bit(int index) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "keep_next_lowest_bit() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "keep_next_lowest_bit(BitMask self)\n"
      "keep_next_lowest_bit(BitMask self, const BitMask other)\n"
      "keep_next_lowest_bit(BitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_keep_next_lowest_bit_337_comment =
  "C++ Interface:\n"
  "keep_next_lowest_bit(BitMask self)\n"
  "keep_next_lowest_bit(BitMask self, const BitMask other)\n"
  "keep_next_lowest_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_keep_next_lowest_bit_337_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint16_t, 16 >::get_key(void) const
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_key_338(PyObject *self, PyObject *) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint16_t_16)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint16_t, 16 >::get_key(void) const
  int return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).get_key)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_key_338_comment =
  "C++ Interface:\n"
  "get_key(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_key_338_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BitMask< uint16_t, 16 >::get_class_type(void)
 */
static PyObject *Dtool_BitMask_uint16_t_16_get_class_type_340(PyObject *, PyObject *) {
  // 1-static TypeHandle BitMask< uint16_t, 16 >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BitMask< uint16_t, 16 >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint16_t_16_get_class_type_340_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BitMask_uint16_t_16_get_class_type_340_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * constexpr BitMask< uint16_t, 16 >::BitMask(void) = default
 * inline BitMask< uint16_t, 16 >::BitMask(BitMask< uint16_t, 16 > const &) = default
 * inline constexpr BitMask< uint16_t, 16 >::BitMask(uint16_t init_value)
 */
static int Dtool_Init_BitMask_uint16_t_16(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-constexpr BitMask< uint16_t, 16 >::BitMask(void) = default
      BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint16_t_16, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline BitMask< uint16_t, 16 >::BitMask(BitMask< uint16_t, 16 > const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          BitMask< uint16_t, 16 > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_BitMask_uint16_t_16);
          if (param0_this != nullptr) {
            BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint16_t_16, true, false);
          }
        }
      }

      {
        // -2 inline constexpr BitMask< uint16_t, 16 >::BitMask(uint16_t init_value)
        long param0;
        static const char *keyword_list[] = {"init_value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "l:BitMask", (char **)keyword_list, &param0)) {
#ifndef NDEBUG
          if (param0 < 0 || param0 > USHRT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %ld out of range for unsigned short integer",
                         param0);
            return -1;
          }
#endif
          BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >((uint16_t)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint16_t_16, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline BitMask< uint16_t, 16 >::BitMask(BitMask< uint16_t, 16 > const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          BitMask< uint16_t, 16 > param0_local;
          BitMask< uint16_t, 16 > const *param0_this = Dtool_Coerce_BitMask_uint16_t_16(param0, param0_local);
          if ((param0_this != nullptr)) {
            BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint16_t_16, true, false);
          }
        }
      }

      // No coercion possible: inline constexpr BitMask< uint16_t, 16 >::BitMask(uint16_t init_value)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BitMask() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BitMask()\n"
      "BitMask(const BitMask param0)\n"
      "BitMask(int init_value)\n");
  }
  return -1;
}

BitMask< uint16_t, 16 > *Dtool_Coerce_BitMask_uint16_t_16(PyObject *args, BitMask< uint16_t, 16 > &coerced) {
  BitMask< uint16_t, 16 > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_BitMask_uint16_t_16)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const BitMask< uint16_t, 16 > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline constexpr BitMask< uint16_t, 16 >::BitMask(uint16_t init_value)
    if (PyLongOrInt_Check(arg)) {
      long param0 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
      if (param0 < 0 || param0 > USHRT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for unsigned short integer",
                     param0);
        return nullptr;
      }
#endif
      coerced = BitMask< uint16_t, 16 >((uint16_t)param0);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_BitMask_uint16_t_16(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BitMask_uint16_t_16) {
    printf("BitMask_uint16_t_16 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BitMask< uint16_t, 16 > *local_this = (BitMask< uint16_t, 16 > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BitMask_uint16_t_16) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BitMask_uint16_t_16(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BitMask_uint16_t_16) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BitMask< uint32_t, 32 >
 */
/**
 * Python function wrapper for:
 * static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::all_on(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_all_on_345(PyObject *, PyObject *) {
  // 1-static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::all_on(void)
  BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((BitMask< uint32_t, 32 >::all_on)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_all_on_345_comment =
  "C++ Interface:\n"
  "all_on()\n";
#else
static const char *Dtool_BitMask_uint32_t_32_all_on_345_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::all_off(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_all_off_346(PyObject *, PyObject *) {
  // 1-static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::all_off(void)
  BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((BitMask< uint32_t, 32 >::all_off)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_all_off_346_comment =
  "C++ Interface:\n"
  "all_off()\n";
#else
static const char *Dtool_BitMask_uint32_t_32_all_off_346_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::lower_on(int on_bits)
 */
static PyObject *Dtool_BitMask_uint32_t_32_lower_on_347(PyObject *, PyObject *arg) {
  // 1-static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::lower_on(int on_bits)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((BitMask< uint32_t, 32 >::lower_on)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lower_on(int on_bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_lower_on_347_comment =
  "C++ Interface:\n"
  "lower_on(int on_bits)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_lower_on_347_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::bit(int index)
 */
static PyObject *Dtool_BitMask_uint32_t_32_bit_348(PyObject *, PyObject *arg) {
  // 1-static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((BitMask< uint32_t, 32 >::bit)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bit(int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_bit_348_comment =
  "C++ Interface:\n"
  "bit(int index)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_bit_348_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint32_t_32_range_349(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::range(int low_bit, int size)
  int param0;
  int param1;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:range", (char **)keyword_list, &param0, &param1)) {
    BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((BitMask< uint32_t, 32 >::range)((int)param0, (int)param1));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "range(int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_range_349_comment =
  "C++ Interface:\n"
  "range(int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_range_349_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr bool BitMask< uint32_t, 32 >::has_max_num_bits(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_has_max_num_bits_350(PyObject *, PyObject *) {
  // 1-static constexpr bool BitMask< uint32_t, 32 >::has_max_num_bits(void)
  bool return_value = (BitMask< uint32_t, 32 >::has_max_num_bits)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_has_max_num_bits_350_comment =
  "C++ Interface:\n"
  "has_max_num_bits()\n";
#else
static const char *Dtool_BitMask_uint32_t_32_has_max_num_bits_350_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr int BitMask< uint32_t, 32 >::get_max_num_bits(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_max_num_bits_351(PyObject *, PyObject *) {
  // 1-static constexpr int BitMask< uint32_t, 32 >::get_max_num_bits(void)
  int return_value = (BitMask< uint32_t, 32 >::get_max_num_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_max_num_bits_351_comment =
  "C++ Interface:\n"
  "get_max_num_bits()\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_max_num_bits_351_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * constexpr int BitMask< uint32_t, 32 >::get_num_bits(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_num_bits_352(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-constexpr int BitMask< uint32_t, 32 >::get_num_bits(void) const
  int return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).get_num_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_num_bits_352_comment =
  "C++ Interface:\n"
  "get_num_bits(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_num_bits_352_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint32_t, 32 >::get_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_bit_353(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint32_t, 32 >::get_bit(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).get_bit)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bit(BitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_bit_353_comment =
  "C++ Interface:\n"
  "get_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_bit_353_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::set_bit(int index)
 */
static PyObject *Dtool_BitMask_uint32_t_32_set_bit_354(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.set_bit")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint32_t, 32 >::set_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_bit)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit(const BitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_set_bit_354_comment =
  "C++ Interface:\n"
  "set_bit(const BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_set_bit_354_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::clear_bit(int index)
 */
static PyObject *Dtool_BitMask_uint32_t_32_clear_bit_355(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.clear_bit")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint32_t, 32 >::clear_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).clear_bit)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_bit(const BitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_clear_bit_355_comment =
  "C++ Interface:\n"
  "clear_bit(const BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_clear_bit_355_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::set_bit_to(int index, bool value)
 */
static PyObject *Dtool_BitMask_uint32_t_32_set_bit_to_356(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.set_bit_to")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint32_t, 32 >::set_bit_to(int index, bool value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_bit_to", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_bit_to)((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit_to(const BitMask self, int index, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_set_bit_to_356_comment =
  "C++ Interface:\n"
  "set_bit_to(const BitMask self, int index, bool value)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_set_bit_to_356_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint32_t, 32 >::is_zero(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_is_zero_357(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint32_t, 32 >::is_zero(void) const
  bool return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).is_zero)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_is_zero_357_comment =
  "C++ Interface:\n"
  "is_zero(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_is_zero_357_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint32_t, 32 >::is_all_on(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_is_all_on_358(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint32_t, 32 >::is_all_on(void) const
  bool return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).is_all_on)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_is_all_on_358_comment =
  "C++ Interface:\n"
  "is_all_on(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_is_all_on_358_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint32_t BitMask< uint32_t, 32 >::extract(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_extract_359(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline uint32_t BitMask< uint32_t, 32 >::extract(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:extract", (char **)keyword_list, &param1, &param2)) {
    uint32_t return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).extract)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract(BitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_extract_359_comment =
  "C++ Interface:\n"
  "extract(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_extract_359_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::store(uint32_t value, int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint32_t_32_store_360(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.store")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint32_t, 32 >::store(uint32_t value, int low_bit, int size)
  unsigned long param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "kii:store", (char **)keyword_list, &param1, &param2, &param3)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).store)((uint32_t)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store(const BitMask self, int value, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_store_360_comment =
  "C++ Interface:\n"
  "store(const BitMask self, int value, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_store_360_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint32_t, 32 >::has_any_of(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_has_any_of_361(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint32_t, 32 >::has_any_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_any_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).has_any_of)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_any_of(BitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_has_any_of_361_comment =
  "C++ Interface:\n"
  "has_any_of(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_has_any_of_361_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint32_t, 32 >::has_all_of(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_has_all_of_362(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint32_t, 32 >::has_all_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_all_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).has_all_of)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_all_of(BitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_has_all_of_362_comment =
  "C++ Interface:\n"
  "has_all_of(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_has_all_of_362_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::set_range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint32_t_32_set_range_363(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.set_range")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint32_t, 32 >::set_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_range", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_range)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range(const BitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_set_range_363_comment =
  "C++ Interface:\n"
  "set_range(const BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_set_range_363_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::clear_range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint32_t_32_clear_range_364(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.clear_range")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint32_t, 32 >::clear_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:clear_range", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).clear_range)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_range(const BitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_clear_range_364_comment =
  "C++ Interface:\n"
  "clear_range(const BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_clear_range_364_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::set_range_to(bool value, int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint32_t_32_set_range_to_365(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.set_range_to")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint32_t, 32 >::set_range_to(bool value, int low_bit, int size)
  PyObject *param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_range_to", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_range_to)((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range_to(const BitMask self, bool value, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_set_range_to_365_comment =
  "C++ Interface:\n"
  "set_range_to(const BitMask self, bool value, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_set_range_to_365_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint32_t BitMask< uint32_t, 32 >::get_word(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_word_366(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline uint32_t BitMask< uint32_t, 32 >::get_word(void) const
  uint32_t return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).get_word)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_word_366_comment =
  "C++ Interface:\n"
  "get_word(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_word_366_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::set_word(uint32_t value)
 */
static PyObject *Dtool_BitMask_uint32_t_32_set_word_367(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.set_word")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint32_t, 32 >::set_word(uint32_t value)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).set_word)((uint32_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const BitMask self, int value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_set_word_367_comment =
  "C++ Interface:\n"
  "set_word(const BitMask self, int value)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_set_word_367_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::get_num_on_bits(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_num_on_bits_368(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint32_t, 32 >::get_num_on_bits(void) const
  int return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).get_num_on_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_num_on_bits_368_comment =
  "C++ Interface:\n"
  "get_num_on_bits(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_num_on_bits_368_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::get_num_off_bits(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_num_off_bits_369(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint32_t, 32 >::get_num_off_bits(void) const
  int return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).get_num_off_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_num_off_bits_369_comment =
  "C++ Interface:\n"
  "get_num_off_bits(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_num_off_bits_369_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::get_lowest_on_bit(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_lowest_on_bit_370(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint32_t, 32 >::get_lowest_on_bit(void) const
  int return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).get_lowest_on_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_lowest_on_bit_370_comment =
  "C++ Interface:\n"
  "get_lowest_on_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_lowest_on_bit_370_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::get_lowest_off_bit(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_lowest_off_bit_371(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint32_t, 32 >::get_lowest_off_bit(void) const
  int return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).get_lowest_off_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_lowest_off_bit_371_comment =
  "C++ Interface:\n"
  "get_lowest_off_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_lowest_off_bit_371_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::get_highest_on_bit(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_highest_on_bit_372(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint32_t, 32 >::get_highest_on_bit(void) const
  int return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).get_highest_on_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_highest_on_bit_372_comment =
  "C++ Interface:\n"
  "get_highest_on_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_highest_on_bit_372_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::get_highest_off_bit(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_highest_off_bit_373(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint32_t, 32 >::get_highest_off_bit(void) const
  int return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).get_highest_off_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_highest_off_bit_373_comment =
  "C++ Interface:\n"
  "get_highest_off_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_highest_off_bit_373_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::get_next_higher_different_bit(int low_bit) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_next_higher_different_bit_374(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint32_t, 32 >::get_next_higher_different_bit(int low_bit) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).get_next_higher_different_bit)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_next_higher_different_bit(BitMask self, int low_bit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_next_higher_different_bit_374_comment =
  "C++ Interface:\n"
  "get_next_higher_different_bit(BitMask self, int low_bit)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_next_higher_different_bit_374_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::invert_in_place(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_invert_in_place_375(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.invert_in_place")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint32_t, 32 >::invert_in_place(void)
  ((*local_this).invert_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_invert_in_place_375_comment =
  "C++ Interface:\n"
  "invert_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_invert_in_place_375_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint32_t, 32 >::has_bits_in_common(BitMask< uint32_t, 32 > const &other) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_has_bits_in_common_376(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint32_t, 32 >::has_bits_in_common(BitMask< uint32_t, 32 > const &other) const
  BitMask< uint32_t, 32 > arg_local;
  BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.has_bits_in_common", "BitMask");
  }
  bool return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).has_bits_in_common)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_bits_in_common(BitMask self, const BitMask other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_has_bits_in_common_376_comment =
  "C++ Interface:\n"
  "has_bits_in_common(BitMask self, const BitMask other)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_has_bits_in_common_376_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::clear(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_clear_377(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.clear")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint32_t, 32 >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_clear_377_comment =
  "C++ Interface:\n"
  "clear(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_clear_377_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint32_t, 32 >::output(std::ostream &out) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_output_378(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-void BitMask< uint32_t, 32 >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "BitMask.output", false, true);
  if (arg_this != nullptr) {
    ((*(const BitMask< uint32_t, 32 >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BitMask self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_output_378_comment =
  "C++ Interface:\n"
  "output(BitMask self, ostream out)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_output_378_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint32_t, 32 >::output_binary(std::ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_output_binary_379(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-void BitMask< uint32_t, 32 >::output_binary(std::ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_binary", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BitMask.output_binary", false, true);
    if (param1_this != nullptr) {
      ((*(const BitMask< uint32_t, 32 >*)local_this).output_binary)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_binary(BitMask self, ostream out, int spaces_every)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_output_binary_379_comment =
  "C++ Interface:\n"
  "output_binary(BitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_output_binary_379_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint32_t, 32 >::output_hex(std::ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_output_hex_380(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-void BitMask< uint32_t, 32 >::output_hex(std::ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_hex", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BitMask.output_hex", false, true);
    if (param1_this != nullptr) {
      ((*(const BitMask< uint32_t, 32 >*)local_this).output_hex)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_hex(BitMask self, ostream out, int spaces_every)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_output_hex_380_comment =
  "C++ Interface:\n"
  "output_hex(BitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_output_hex_380_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint32_t, 32 >::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_write_381(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-void BitMask< uint32_t, 32 >::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BitMask.write", false, true);
    if (param1_this != nullptr) {
      ((*(const BitMask< uint32_t, 32 >*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BitMask self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_write_381_comment =
  "C++ Interface:\n"
  "write(BitMask self, ostream out, int indent_level)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_write_381_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::compare_to(BitMask< uint32_t, 32 > const &other) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_compare_to_385(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint32_t, 32 >::compare_to(BitMask< uint32_t, 32 > const &other) const
  BitMask< uint32_t, 32 > arg_local;
  BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.compare_to", "BitMask");
  }
  int return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).compare_to)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(BitMask self, const BitMask other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_compare_to_385_comment =
  "C++ Interface:\n"
  "compare_to(BitMask self, const BitMask other)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_compare_to_385_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::flood_down_in_place(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_flood_down_in_place_397(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.flood_down_in_place")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint32_t, 32 >::flood_down_in_place(void)
  ((*local_this).flood_down_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_flood_down_in_place_397_comment =
  "C++ Interface:\n"
  "flood_down_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_flood_down_in_place_397_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint32_t, 32 >::flood_up_in_place(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_flood_up_in_place_398(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint32_t_32, (void **)&local_this, "BitMask_uint32_t_32.flood_up_in_place")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint32_t, 32 >::flood_up_in_place(void)
  ((*local_this).flood_up_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_flood_up_in_place_398_comment =
  "C++ Interface:\n"
  "flood_up_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_flood_up_in_place_398_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::flood_bits_down(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_flood_bits_down_399(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::flood_bits_down(void) const
  BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(((*(const BitMask< uint32_t, 32 >*)local_this).flood_bits_down)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_flood_bits_down_399_comment =
  "C++ Interface:\n"
  "flood_bits_down(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_flood_bits_down_399_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::flood_bits_up(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_flood_bits_up_400(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::flood_bits_up(void) const
  BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(((*(const BitMask< uint32_t, 32 >*)local_this).flood_bits_up)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_flood_bits_up_400_comment =
  "C++ Interface:\n"
  "flood_bits_up(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_flood_bits_up_400_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(void) const
 * inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(BitMask< uint32_t, 32 > const &other) const
 * inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_keep_next_highest_bit_401(PyObject *self, PyObject *args) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(void) const
      BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(((*(const BitMask< uint32_t, 32 >*)local_this).keep_next_highest_bit)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(BitMask< uint32_t, 32 > const &other) const
        BitMask< uint32_t, 32 > const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_BitMask_uint32_t_32);
        if (arg_this != nullptr) {
          BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(((*(const BitMask< uint32_t, 32 >*)local_this).keep_next_highest_bit)(*arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
        }
      }

      {
        // -2 inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(int index) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(((*(const BitMask< uint32_t, 32 >*)local_this).keep_next_highest_bit)((int)arg_val));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
        }
      }

      {
        // -2 inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(BitMask< uint32_t, 32 > const &other) const
        BitMask< uint32_t, 32 > arg_local;
        BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
        if ((arg_this != nullptr)) {
          BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(((*(const BitMask< uint32_t, 32 >*)local_this).keep_next_highest_bit)(*arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
        }
      }

      // No coercion possible: inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_highest_bit(int index) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "keep_next_highest_bit() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "keep_next_highest_bit(BitMask self)\n"
      "keep_next_highest_bit(BitMask self, const BitMask other)\n"
      "keep_next_highest_bit(BitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_keep_next_highest_bit_401_comment =
  "C++ Interface:\n"
  "keep_next_highest_bit(BitMask self)\n"
  "keep_next_highest_bit(BitMask self, const BitMask other)\n"
  "keep_next_highest_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_keep_next_highest_bit_401_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(void) const
 * inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(BitMask< uint32_t, 32 > const &other) const
 * inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_keep_next_lowest_bit_402(PyObject *self, PyObject *args) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(void) const
      BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(((*(const BitMask< uint32_t, 32 >*)local_this).keep_next_lowest_bit)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(BitMask< uint32_t, 32 > const &other) const
        BitMask< uint32_t, 32 > const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_BitMask_uint32_t_32);
        if (arg_this != nullptr) {
          BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(((*(const BitMask< uint32_t, 32 >*)local_this).keep_next_lowest_bit)(*arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
        }
      }

      {
        // -2 inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(int index) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(((*(const BitMask< uint32_t, 32 >*)local_this).keep_next_lowest_bit)((int)arg_val));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
        }
      }

      {
        // -2 inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(BitMask< uint32_t, 32 > const &other) const
        BitMask< uint32_t, 32 > arg_local;
        BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
        if ((arg_this != nullptr)) {
          BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(((*(const BitMask< uint32_t, 32 >*)local_this).keep_next_lowest_bit)(*arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
        }
      }

      // No coercion possible: inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::keep_next_lowest_bit(int index) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "keep_next_lowest_bit() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "keep_next_lowest_bit(BitMask self)\n"
      "keep_next_lowest_bit(BitMask self, const BitMask other)\n"
      "keep_next_lowest_bit(BitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_keep_next_lowest_bit_402_comment =
  "C++ Interface:\n"
  "keep_next_lowest_bit(BitMask self)\n"
  "keep_next_lowest_bit(BitMask self, const BitMask other)\n"
  "keep_next_lowest_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_keep_next_lowest_bit_402_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint32_t, 32 >::get_key(void) const
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_key_403(PyObject *self, PyObject *) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint32_t_32)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint32_t, 32 >::get_key(void) const
  int return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).get_key)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_key_403_comment =
  "C++ Interface:\n"
  "get_key(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_key_403_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BitMask< uint32_t, 32 >::get_class_type(void)
 */
static PyObject *Dtool_BitMask_uint32_t_32_get_class_type_405(PyObject *, PyObject *) {
  // 1-static TypeHandle BitMask< uint32_t, 32 >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BitMask< uint32_t, 32 >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint32_t_32_get_class_type_405_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BitMask_uint32_t_32_get_class_type_405_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * constexpr BitMask< uint32_t, 32 >::BitMask(void) = default
 * inline BitMask< uint32_t, 32 >::BitMask(BitMask< uint32_t, 32 > const &) = default
 * inline constexpr BitMask< uint32_t, 32 >::BitMask(uint32_t init_value)
 */
static int Dtool_Init_BitMask_uint32_t_32(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-constexpr BitMask< uint32_t, 32 >::BitMask(void) = default
      BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint32_t_32, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline BitMask< uint32_t, 32 >::BitMask(BitMask< uint32_t, 32 > const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          BitMask< uint32_t, 32 > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_BitMask_uint32_t_32);
          if (param0_this != nullptr) {
            BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint32_t_32, true, false);
          }
        }
      }

      {
        // -2 inline constexpr BitMask< uint32_t, 32 >::BitMask(uint32_t init_value)
        unsigned long param0;
        static const char *keyword_list[] = {"init_value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "k:BitMask", (char **)keyword_list, &param0)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (param0 > UINT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %lu out of range for unsigned integer",
                         param0);
            return -1;
          }
#endif
          BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >((uint32_t)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint32_t_32, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline BitMask< uint32_t, 32 >::BitMask(BitMask< uint32_t, 32 > const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          BitMask< uint32_t, 32 > param0_local;
          BitMask< uint32_t, 32 > const *param0_this = Dtool_Coerce_BitMask_uint32_t_32(param0, param0_local);
          if ((param0_this != nullptr)) {
            BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint32_t_32, true, false);
          }
        }
      }

      // No coercion possible: inline constexpr BitMask< uint32_t, 32 >::BitMask(uint32_t init_value)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BitMask() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BitMask()\n"
      "BitMask(const BitMask param0)\n"
      "BitMask(int init_value)\n");
  }
  return -1;
}

BitMask< uint32_t, 32 > *Dtool_Coerce_BitMask_uint32_t_32(PyObject *args, BitMask< uint32_t, 32 > &coerced) {
  BitMask< uint32_t, 32 > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_BitMask_uint32_t_32)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const BitMask< uint32_t, 32 > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline constexpr BitMask< uint32_t, 32 >::BitMask(uint32_t init_value)
    if (PyLongOrInt_Check(arg)) {
      unsigned long param0 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (param0 > UINT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %lu out of range for unsigned integer",
                     param0);
        return nullptr;
      }
#endif
      coerced = BitMask< uint32_t, 32 >((uint32_t)param0);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_BitMask_uint32_t_32(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BitMask_uint32_t_32) {
    printf("BitMask_uint32_t_32 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BitMask< uint32_t, 32 > *local_this = (BitMask< uint32_t, 32 > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BitMask_uint32_t_32) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BitMask_uint32_t_32(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BitMask_uint32_t_32) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BitMask< uint64_t, 64 >
 */
/**
 * Python function wrapper for:
 * static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::all_on(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_all_on_410(PyObject *, PyObject *) {
  // 1-static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::all_on(void)
  BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((BitMask< uint64_t, 64 >::all_on)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_all_on_410_comment =
  "C++ Interface:\n"
  "all_on()\n";
#else
static const char *Dtool_BitMask_uint64_t_64_all_on_410_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::all_off(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_all_off_411(PyObject *, PyObject *) {
  // 1-static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::all_off(void)
  BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((BitMask< uint64_t, 64 >::all_off)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_all_off_411_comment =
  "C++ Interface:\n"
  "all_off()\n";
#else
static const char *Dtool_BitMask_uint64_t_64_all_off_411_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::lower_on(int on_bits)
 */
static PyObject *Dtool_BitMask_uint64_t_64_lower_on_412(PyObject *, PyObject *arg) {
  // 1-static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::lower_on(int on_bits)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((BitMask< uint64_t, 64 >::lower_on)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lower_on(int on_bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_lower_on_412_comment =
  "C++ Interface:\n"
  "lower_on(int on_bits)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_lower_on_412_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::bit(int index)
 */
static PyObject *Dtool_BitMask_uint64_t_64_bit_413(PyObject *, PyObject *arg) {
  // 1-static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((BitMask< uint64_t, 64 >::bit)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bit(int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_bit_413_comment =
  "C++ Interface:\n"
  "bit(int index)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_bit_413_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint64_t_64_range_414(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::range(int low_bit, int size)
  int param0;
  int param1;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:range", (char **)keyword_list, &param0, &param1)) {
    BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((BitMask< uint64_t, 64 >::range)((int)param0, (int)param1));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "range(int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_range_414_comment =
  "C++ Interface:\n"
  "range(int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_range_414_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr bool BitMask< uint64_t, 64 >::has_max_num_bits(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_has_max_num_bits_415(PyObject *, PyObject *) {
  // 1-static constexpr bool BitMask< uint64_t, 64 >::has_max_num_bits(void)
  bool return_value = (BitMask< uint64_t, 64 >::has_max_num_bits)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_has_max_num_bits_415_comment =
  "C++ Interface:\n"
  "has_max_num_bits()\n";
#else
static const char *Dtool_BitMask_uint64_t_64_has_max_num_bits_415_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr int BitMask< uint64_t, 64 >::get_max_num_bits(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_max_num_bits_416(PyObject *, PyObject *) {
  // 1-static constexpr int BitMask< uint64_t, 64 >::get_max_num_bits(void)
  int return_value = (BitMask< uint64_t, 64 >::get_max_num_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_max_num_bits_416_comment =
  "C++ Interface:\n"
  "get_max_num_bits()\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_max_num_bits_416_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * constexpr int BitMask< uint64_t, 64 >::get_num_bits(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_num_bits_417(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-constexpr int BitMask< uint64_t, 64 >::get_num_bits(void) const
  int return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).get_num_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_num_bits_417_comment =
  "C++ Interface:\n"
  "get_num_bits(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_num_bits_417_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint64_t, 64 >::get_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_bit_418(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint64_t, 64 >::get_bit(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).get_bit)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bit(BitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_bit_418_comment =
  "C++ Interface:\n"
  "get_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_bit_418_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::set_bit(int index)
 */
static PyObject *Dtool_BitMask_uint64_t_64_set_bit_419(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.set_bit")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint64_t, 64 >::set_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_bit)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit(const BitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_set_bit_419_comment =
  "C++ Interface:\n"
  "set_bit(const BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_set_bit_419_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::clear_bit(int index)
 */
static PyObject *Dtool_BitMask_uint64_t_64_clear_bit_420(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.clear_bit")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint64_t, 64 >::clear_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).clear_bit)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_bit(const BitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_clear_bit_420_comment =
  "C++ Interface:\n"
  "clear_bit(const BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_clear_bit_420_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::set_bit_to(int index, bool value)
 */
static PyObject *Dtool_BitMask_uint64_t_64_set_bit_to_421(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.set_bit_to")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint64_t, 64 >::set_bit_to(int index, bool value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_bit_to", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_bit_to)((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit_to(const BitMask self, int index, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_set_bit_to_421_comment =
  "C++ Interface:\n"
  "set_bit_to(const BitMask self, int index, bool value)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_set_bit_to_421_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint64_t, 64 >::is_zero(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_is_zero_422(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint64_t, 64 >::is_zero(void) const
  bool return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).is_zero)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_is_zero_422_comment =
  "C++ Interface:\n"
  "is_zero(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_is_zero_422_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint64_t, 64 >::is_all_on(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_is_all_on_423(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint64_t, 64 >::is_all_on(void) const
  bool return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).is_all_on)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_is_all_on_423_comment =
  "C++ Interface:\n"
  "is_all_on(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_is_all_on_423_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t BitMask< uint64_t, 64 >::extract(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_extract_424(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline uint64_t BitMask< uint64_t, 64 >::extract(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:extract", (char **)keyword_list, &param1, &param2)) {
    uint64_t return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).extract)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract(BitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_extract_424_comment =
  "C++ Interface:\n"
  "extract(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_extract_424_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::store(uint64_t value, int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint64_t_64_store_425(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.store")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint64_t, 64 >::store(uint64_t value, int low_bit, int size)
  unsigned PY_LONG_LONG param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Kii:store", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).store)((uint64_t)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store(const BitMask self, long value, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_store_425_comment =
  "C++ Interface:\n"
  "store(const BitMask self, long value, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_store_425_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint64_t, 64 >::has_any_of(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_has_any_of_426(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint64_t, 64 >::has_any_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_any_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).has_any_of)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_any_of(BitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_has_any_of_426_comment =
  "C++ Interface:\n"
  "has_any_of(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_has_any_of_426_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint64_t, 64 >::has_all_of(int low_bit, int size) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_has_all_of_427(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint64_t, 64 >::has_all_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_all_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).has_all_of)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_all_of(BitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_has_all_of_427_comment =
  "C++ Interface:\n"
  "has_all_of(BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_has_all_of_427_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::set_range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint64_t_64_set_range_428(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.set_range")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint64_t, 64 >::set_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_range", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_range)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range(const BitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_set_range_428_comment =
  "C++ Interface:\n"
  "set_range(const BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_set_range_428_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::clear_range(int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint64_t_64_clear_range_429(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.clear_range")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint64_t, 64 >::clear_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:clear_range", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).clear_range)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_range(const BitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_clear_range_429_comment =
  "C++ Interface:\n"
  "clear_range(const BitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_clear_range_429_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::set_range_to(bool value, int low_bit, int size)
 */
static PyObject *Dtool_BitMask_uint64_t_64_set_range_to_430(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.set_range_to")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint64_t, 64 >::set_range_to(bool value, int low_bit, int size)
  PyObject *param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_range_to", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_range_to)((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range_to(const BitMask self, bool value, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_set_range_to_430_comment =
  "C++ Interface:\n"
  "set_range_to(const BitMask self, bool value, int low_bit, int size)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_set_range_to_430_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t BitMask< uint64_t, 64 >::get_word(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_word_431(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline uint64_t BitMask< uint64_t, 64 >::get_word(void) const
  uint64_t return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).get_word)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_word_431_comment =
  "C++ Interface:\n"
  "get_word(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_word_431_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::set_word(uint64_t value)
 */
static PyObject *Dtool_BitMask_uint64_t_64_set_word_432(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.set_word")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint64_t, 64 >::set_word(uint64_t value)
  unsigned PY_LONG_LONG param1;
  if (PyArg_Parse(arg, "K:set_word", &param1)) {
    ((*local_this).set_word)((uint64_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const BitMask self, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_set_word_432_comment =
  "C++ Interface:\n"
  "set_word(const BitMask self, long value)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_set_word_432_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::get_num_on_bits(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_num_on_bits_433(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint64_t, 64 >::get_num_on_bits(void) const
  int return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).get_num_on_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_num_on_bits_433_comment =
  "C++ Interface:\n"
  "get_num_on_bits(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_num_on_bits_433_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::get_num_off_bits(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_num_off_bits_434(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint64_t, 64 >::get_num_off_bits(void) const
  int return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).get_num_off_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_num_off_bits_434_comment =
  "C++ Interface:\n"
  "get_num_off_bits(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_num_off_bits_434_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::get_lowest_on_bit(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_lowest_on_bit_435(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint64_t, 64 >::get_lowest_on_bit(void) const
  int return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).get_lowest_on_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_lowest_on_bit_435_comment =
  "C++ Interface:\n"
  "get_lowest_on_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_lowest_on_bit_435_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::get_lowest_off_bit(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_lowest_off_bit_436(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint64_t, 64 >::get_lowest_off_bit(void) const
  int return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).get_lowest_off_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_lowest_off_bit_436_comment =
  "C++ Interface:\n"
  "get_lowest_off_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_lowest_off_bit_436_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::get_highest_on_bit(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_highest_on_bit_437(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint64_t, 64 >::get_highest_on_bit(void) const
  int return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).get_highest_on_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_highest_on_bit_437_comment =
  "C++ Interface:\n"
  "get_highest_on_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_highest_on_bit_437_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::get_highest_off_bit(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_highest_off_bit_438(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint64_t, 64 >::get_highest_off_bit(void) const
  int return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).get_highest_off_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_highest_off_bit_438_comment =
  "C++ Interface:\n"
  "get_highest_off_bit(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_highest_off_bit_438_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::get_next_higher_different_bit(int low_bit) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_next_higher_different_bit_439(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint64_t, 64 >::get_next_higher_different_bit(int low_bit) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).get_next_higher_different_bit)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_next_higher_different_bit(BitMask self, int low_bit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_next_higher_different_bit_439_comment =
  "C++ Interface:\n"
  "get_next_higher_different_bit(BitMask self, int low_bit)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_next_higher_different_bit_439_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::invert_in_place(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_invert_in_place_440(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.invert_in_place")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint64_t, 64 >::invert_in_place(void)
  ((*local_this).invert_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_invert_in_place_440_comment =
  "C++ Interface:\n"
  "invert_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_invert_in_place_440_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitMask< uint64_t, 64 >::has_bits_in_common(BitMask< uint64_t, 64 > const &other) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_has_bits_in_common_441(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline bool BitMask< uint64_t, 64 >::has_bits_in_common(BitMask< uint64_t, 64 > const &other) const
  BitMask< uint64_t, 64 > arg_local;
  BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.has_bits_in_common", "BitMask");
  }
  bool return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).has_bits_in_common)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_bits_in_common(BitMask self, const BitMask other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_has_bits_in_common_441_comment =
  "C++ Interface:\n"
  "has_bits_in_common(BitMask self, const BitMask other)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_has_bits_in_common_441_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::clear(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_clear_442(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.clear")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint64_t, 64 >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_clear_442_comment =
  "C++ Interface:\n"
  "clear(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_clear_442_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint64_t, 64 >::output(std::ostream &out) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_output_443(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-void BitMask< uint64_t, 64 >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "BitMask.output", false, true);
  if (arg_this != nullptr) {
    ((*(const BitMask< uint64_t, 64 >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BitMask self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_output_443_comment =
  "C++ Interface:\n"
  "output(BitMask self, ostream out)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_output_443_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint64_t, 64 >::output_binary(std::ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_output_binary_444(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-void BitMask< uint64_t, 64 >::output_binary(std::ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_binary", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BitMask.output_binary", false, true);
    if (param1_this != nullptr) {
      ((*(const BitMask< uint64_t, 64 >*)local_this).output_binary)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_binary(BitMask self, ostream out, int spaces_every)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_output_binary_444_comment =
  "C++ Interface:\n"
  "output_binary(BitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_output_binary_444_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint64_t, 64 >::output_hex(std::ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_output_hex_445(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-void BitMask< uint64_t, 64 >::output_hex(std::ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_hex", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BitMask.output_hex", false, true);
    if (param1_this != nullptr) {
      ((*(const BitMask< uint64_t, 64 >*)local_this).output_hex)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_hex(BitMask self, ostream out, int spaces_every)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_output_hex_445_comment =
  "C++ Interface:\n"
  "output_hex(BitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_output_hex_445_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitMask< uint64_t, 64 >::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_write_446(PyObject *self, PyObject *args, PyObject *kwds) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-void BitMask< uint64_t, 64 >::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BitMask.write", false, true);
    if (param1_this != nullptr) {
      ((*(const BitMask< uint64_t, 64 >*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BitMask self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_write_446_comment =
  "C++ Interface:\n"
  "write(BitMask self, ostream out, int indent_level)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_write_446_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::compare_to(BitMask< uint64_t, 64 > const &other) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_compare_to_450(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint64_t, 64 >::compare_to(BitMask< uint64_t, 64 > const &other) const
  BitMask< uint64_t, 64 > arg_local;
  BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.compare_to", "BitMask");
  }
  int return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).compare_to)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(BitMask self, const BitMask other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_compare_to_450_comment =
  "C++ Interface:\n"
  "compare_to(BitMask self, const BitMask other)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_compare_to_450_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::flood_down_in_place(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_flood_down_in_place_462(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.flood_down_in_place")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint64_t, 64 >::flood_down_in_place(void)
  ((*local_this).flood_down_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_flood_down_in_place_462_comment =
  "C++ Interface:\n"
  "flood_down_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_flood_down_in_place_462_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitMask< uint64_t, 64 >::flood_up_in_place(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_flood_up_in_place_463(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitMask_uint64_t_64, (void **)&local_this, "BitMask_uint64_t_64.flood_up_in_place")) {
    return nullptr;
  }
  // 1-inline void BitMask< uint64_t, 64 >::flood_up_in_place(void)
  ((*local_this).flood_up_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_flood_up_in_place_463_comment =
  "C++ Interface:\n"
  "flood_up_in_place(const BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_flood_up_in_place_463_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::flood_bits_down(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_flood_bits_down_464(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::flood_bits_down(void) const
  BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(((*(const BitMask< uint64_t, 64 >*)local_this).flood_bits_down)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_flood_bits_down_464_comment =
  "C++ Interface:\n"
  "flood_bits_down(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_flood_bits_down_464_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::flood_bits_up(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_flood_bits_up_465(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::flood_bits_up(void) const
  BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(((*(const BitMask< uint64_t, 64 >*)local_this).flood_bits_up)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_flood_bits_up_465_comment =
  "C++ Interface:\n"
  "flood_bits_up(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_flood_bits_up_465_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(void) const
 * inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(BitMask< uint64_t, 64 > const &other) const
 * inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_keep_next_highest_bit_466(PyObject *self, PyObject *args) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(void) const
      BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(((*(const BitMask< uint64_t, 64 >*)local_this).keep_next_highest_bit)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(BitMask< uint64_t, 64 > const &other) const
        BitMask< uint64_t, 64 > const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_BitMask_uint64_t_64);
        if (arg_this != nullptr) {
          BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(((*(const BitMask< uint64_t, 64 >*)local_this).keep_next_highest_bit)(*arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
        }
      }

      {
        // -2 inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(int index) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(((*(const BitMask< uint64_t, 64 >*)local_this).keep_next_highest_bit)((int)arg_val));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
        }
      }

      {
        // -2 inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(BitMask< uint64_t, 64 > const &other) const
        BitMask< uint64_t, 64 > arg_local;
        BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
        if ((arg_this != nullptr)) {
          BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(((*(const BitMask< uint64_t, 64 >*)local_this).keep_next_highest_bit)(*arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
        }
      }

      // No coercion possible: inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_highest_bit(int index) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "keep_next_highest_bit() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "keep_next_highest_bit(BitMask self)\n"
      "keep_next_highest_bit(BitMask self, const BitMask other)\n"
      "keep_next_highest_bit(BitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_keep_next_highest_bit_466_comment =
  "C++ Interface:\n"
  "keep_next_highest_bit(BitMask self)\n"
  "keep_next_highest_bit(BitMask self, const BitMask other)\n"
  "keep_next_highest_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_keep_next_highest_bit_466_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(void) const
 * inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(BitMask< uint64_t, 64 > const &other) const
 * inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(int index) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_keep_next_lowest_bit_467(PyObject *self, PyObject *args) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(void) const
      BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(((*(const BitMask< uint64_t, 64 >*)local_this).keep_next_lowest_bit)());
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(BitMask< uint64_t, 64 > const &other) const
        BitMask< uint64_t, 64 > const *arg_this = nullptr;
        DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_BitMask_uint64_t_64);
        if (arg_this != nullptr) {
          BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(((*(const BitMask< uint64_t, 64 >*)local_this).keep_next_lowest_bit)(*arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
        }
      }

      {
        // -2 inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(int index) const
        if (PyLongOrInt_Check(arg)) {
          long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (arg_val < INT_MIN || arg_val > INT_MAX) {
            return PyErr_Format(PyExc_OverflowError,
                                "value %ld out of range for signed integer",
                                arg_val);
          }
#endif
          BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(((*(const BitMask< uint64_t, 64 >*)local_this).keep_next_lowest_bit)((int)arg_val));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
        }
      }

      {
        // -2 inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(BitMask< uint64_t, 64 > const &other) const
        BitMask< uint64_t, 64 > arg_local;
        BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
        if ((arg_this != nullptr)) {
          BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(((*(const BitMask< uint64_t, 64 >*)local_this).keep_next_lowest_bit)(*arg_this));
          if (return_value == nullptr) {
            return PyErr_NoMemory();
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return nullptr;
          }
          return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
        }
      }

      // No coercion possible: inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::keep_next_lowest_bit(int index) const
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "keep_next_lowest_bit() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "keep_next_lowest_bit(BitMask self)\n"
      "keep_next_lowest_bit(BitMask self, const BitMask other)\n"
      "keep_next_lowest_bit(BitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_keep_next_lowest_bit_467_comment =
  "C++ Interface:\n"
  "keep_next_lowest_bit(BitMask self)\n"
  "keep_next_lowest_bit(BitMask self, const BitMask other)\n"
  "keep_next_lowest_bit(BitMask self, int index)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_keep_next_lowest_bit_467_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int BitMask< uint64_t, 64 >::get_key(void) const
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_key_468(PyObject *self, PyObject *) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitMask_uint64_t_64)) {
    return nullptr;
  }
  // 1-inline int BitMask< uint64_t, 64 >::get_key(void) const
  int return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).get_key)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_key_468_comment =
  "C++ Interface:\n"
  "get_key(BitMask self)\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_key_468_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BitMask< uint64_t, 64 >::get_class_type(void)
 */
static PyObject *Dtool_BitMask_uint64_t_64_get_class_type_470(PyObject *, PyObject *) {
  // 1-static TypeHandle BitMask< uint64_t, 64 >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BitMask< uint64_t, 64 >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitMask_uint64_t_64_get_class_type_470_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BitMask_uint64_t_64_get_class_type_470_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * constexpr BitMask< uint64_t, 64 >::BitMask(void) = default
 * inline BitMask< uint64_t, 64 >::BitMask(BitMask< uint64_t, 64 > const &) = default
 * inline constexpr BitMask< uint64_t, 64 >::BitMask(uint64_t init_value)
 */
static int Dtool_Init_BitMask_uint64_t_64(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-constexpr BitMask< uint64_t, 64 >::BitMask(void) = default
      BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint64_t_64, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline BitMask< uint64_t, 64 >::BitMask(BitMask< uint64_t, 64 > const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          BitMask< uint64_t, 64 > const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_BitMask_uint64_t_64);
          if (param0_this != nullptr) {
            BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint64_t_64, true, false);
          }
        }
      }

      {
        // -2 inline constexpr BitMask< uint64_t, 64 >::BitMask(uint64_t init_value)
        unsigned PY_LONG_LONG param0;
        static const char *keyword_list[] = {"init_value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "K:BitMask", (char **)keyword_list, &param0)) {
          BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >((uint64_t)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint64_t_64, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline BitMask< uint64_t, 64 >::BitMask(BitMask< uint64_t, 64 > const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          BitMask< uint64_t, 64 > param0_local;
          BitMask< uint64_t, 64 > const *param0_this = Dtool_Coerce_BitMask_uint64_t_64(param0, param0_local);
          if ((param0_this != nullptr)) {
            BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitMask_uint64_t_64, true, false);
          }
        }
      }

      // No coercion possible: inline constexpr BitMask< uint64_t, 64 >::BitMask(uint64_t init_value)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BitMask() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BitMask()\n"
      "BitMask(const BitMask param0)\n"
      "BitMask(long init_value)\n");
  }
  return -1;
}

BitMask< uint64_t, 64 > *Dtool_Coerce_BitMask_uint64_t_64(PyObject *args, BitMask< uint64_t, 64 > &coerced) {
  BitMask< uint64_t, 64 > *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_BitMask_uint64_t_64)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const BitMask< uint64_t, 64 > *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline constexpr BitMask< uint64_t, 64 >::BitMask(uint64_t init_value)
    unsigned PY_LONG_LONG param0;
    if (PyArg_Parse(arg, "K:BitMask", &param0)) {
      coerced = BitMask< uint64_t, 64 >((uint64_t)param0);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
    PyErr_Clear();
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_BitMask_uint64_t_64(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BitMask_uint64_t_64) {
    printf("BitMask_uint64_t_64 ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BitMask< uint64_t, 64 > *local_this = (BitMask< uint64_t, 64 > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BitMask_uint64_t_64) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BitMask_uint64_t_64(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BitMask_uint64_t_64) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BitArray
 */
/**
 * Python function wrapper for:
 * static inline BitArray BitArray::all_on(void)
 */
static PyObject *Dtool_BitArray_all_on_477(PyObject *, PyObject *) {
  // 1-static inline BitArray BitArray::all_on(void)
  BitArray *return_value = new BitArray((BitArray::all_on)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_all_on_477_comment =
  "C++ Interface:\n"
  "all_on()\n"
  "\n"
  "/**\n"
  " * Returns a BitArray with an infinite array of bits, all on.\n"
  " */";
#else
static const char *Dtool_BitArray_all_on_477_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline BitArray BitArray::all_off(void)
 */
static PyObject *Dtool_BitArray_all_off_478(PyObject *, PyObject *) {
  // 1-static inline BitArray BitArray::all_off(void)
  BitArray *return_value = new BitArray((BitArray::all_off)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_all_off_478_comment =
  "C++ Interface:\n"
  "all_off()\n"
  "\n"
  "/**\n"
  " * Returns a BitArray whose bits are all off.\n"
  " */";
#else
static const char *Dtool_BitArray_all_off_478_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline BitArray BitArray::lower_on(int on_bits)
 */
static PyObject *Dtool_BitArray_lower_on_479(PyObject *, PyObject *arg) {
  // 1-static inline BitArray BitArray::lower_on(int on_bits)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitArray *return_value = new BitArray((BitArray::lower_on)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lower_on(int on_bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_lower_on_479_comment =
  "C++ Interface:\n"
  "lower_on(int on_bits)\n"
  "\n"
  "/**\n"
  " * Returns a BitArray whose lower on_bits bits are on.\n"
  " */";
#else
static const char *Dtool_BitArray_lower_on_479_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline BitArray BitArray::bit(int index)
 */
static PyObject *Dtool_BitArray_bit_480(PyObject *, PyObject *arg) {
  // 1-static inline BitArray BitArray::bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitArray *return_value = new BitArray((BitArray::bit)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bit(int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_bit_480_comment =
  "C++ Interface:\n"
  "bit(int index)\n"
  "\n"
  "/**\n"
  " * Returns a BitArray with only the indicated bit on.\n"
  " */";
#else
static const char *Dtool_BitArray_bit_480_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline BitArray BitArray::range(int low_bit, int size)
 */
static PyObject *Dtool_BitArray_range_481(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline BitArray BitArray::range(int low_bit, int size)
  int param0;
  int param1;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:range", (char **)keyword_list, &param0, &param1)) {
    BitArray *return_value = new BitArray((BitArray::range)((int)param0, (int)param1));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "range(int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_range_481_comment =
  "C++ Interface:\n"
  "range(int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Returns a BitArray whose size bits, beginning at low_bit, are on.\n"
  " */";
#else
static const char *Dtool_BitArray_range_481_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr bool BitArray::has_max_num_bits(void)
 */
static PyObject *Dtool_BitArray_has_max_num_bits_482(PyObject *, PyObject *) {
  // 1-static constexpr bool BitArray::has_max_num_bits(void)
  bool return_value = (BitArray::has_max_num_bits)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_has_max_num_bits_482_comment =
  "C++ Interface:\n"
  "has_max_num_bits()\n";
#else
static const char *Dtool_BitArray_has_max_num_bits_482_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr int BitArray::get_max_num_bits(void)
 */
static PyObject *Dtool_BitArray_get_max_num_bits_483(PyObject *, PyObject *) {
  // 1-static constexpr int BitArray::get_max_num_bits(void)
  int return_value = (BitArray::get_max_num_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_max_num_bits_483_comment =
  "C++ Interface:\n"
  "get_max_num_bits()\n";
#else
static const char *Dtool_BitArray_get_max_num_bits_483_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr int BitArray::get_num_bits_per_word(void)
 */
static PyObject *Dtool_BitArray_get_num_bits_per_word_484(PyObject *, PyObject *) {
  // 1-static constexpr int BitArray::get_num_bits_per_word(void)
  int return_value = (BitArray::get_num_bits_per_word)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_num_bits_per_word_484_comment =
  "C++ Interface:\n"
  "get_num_bits_per_word()\n";
#else
static const char *Dtool_BitArray_get_num_bits_per_word_484_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t BitArray::get_num_bits(void) const
 */
static PyObject *Dtool_BitArray_get_num_bits_485(PyObject *self, PyObject *) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-inline std::size_t BitArray::get_num_bits(void) const
  std::size_t return_value = ((*(const BitArray*)local_this).get_num_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_num_bits_485_comment =
  "C++ Interface:\n"
  "get_num_bits(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns the current number of possibly different bits in this array.  There\n"
  " * are actually an infinite number of bits, but every bit higher than this bit\n"
  " * will have the same value, either 0 or 1 (see get_highest_bits()).\n"
  " *\n"
  " * This number may grow and/or shrink automatically as needed.\n"
  " */";
#else
static const char *Dtool_BitArray_get_num_bits_485_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitArray::get_bit(int index) const
 */
static PyObject *Dtool_BitArray_get_bit_486(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-inline bool BitArray::get_bit(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const BitArray*)local_this).get_bit)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bit(BitArray self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_bit_486_comment =
  "C++ Interface:\n"
  "get_bit(BitArray self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the nth bit is set, false if it is cleared.  It is valid\n"
  " * for n to increase beyond get_num_bits(), but the return value\n"
  " * get_num_bits() will always be the same.\n"
  " */";
#else
static const char *Dtool_BitArray_get_bit_486_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitArray::set_bit(int index)
 */
static PyObject *Dtool_BitArray_set_bit_487(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.set_bit")) {
    return nullptr;
  }
  // 1-inline void BitArray::set_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_bit)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit(const BitArray self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_set_bit_487_comment =
  "C++ Interface:\n"
  "set_bit(const BitArray self, int index)\n"
  "\n"
  "/**\n"
  " * Sets the nth bit on.  If n >= get_num_bits(), this automatically extends\n"
  " * the array.\n"
  " */";
#else
static const char *Dtool_BitArray_set_bit_487_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitArray::clear_bit(int index)
 */
static PyObject *Dtool_BitArray_clear_bit_488(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.clear_bit")) {
    return nullptr;
  }
  // 1-inline void BitArray::clear_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).clear_bit)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_bit(const BitArray self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_clear_bit_488_comment =
  "C++ Interface:\n"
  "clear_bit(const BitArray self, int index)\n"
  "\n"
  "/**\n"
  " * Sets the nth bit off.  If n >= get_num_bits(), this automatically extends\n"
  " * the array.\n"
  " */";
#else
static const char *Dtool_BitArray_clear_bit_488_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitArray::set_bit_to(int index, bool value)
 */
static PyObject *Dtool_BitArray_set_bit_to_489(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.set_bit_to")) {
    return nullptr;
  }
  // 1-inline void BitArray::set_bit_to(int index, bool value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_bit_to", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_bit_to)((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit_to(const BitArray self, int index, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_set_bit_to_489_comment =
  "C++ Interface:\n"
  "set_bit_to(const BitArray self, int index, bool value)\n"
  "\n"
  "/**\n"
  " * Sets the nth bit either on or off, according to the indicated bool value.\n"
  " */";
#else
static const char *Dtool_BitArray_set_bit_to_489_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool BitArray::get_highest_bits(void) const
 */
static PyObject *Dtool_BitArray_get_highest_bits_490(PyObject *self, PyObject *) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-inline bool BitArray::get_highest_bits(void) const
  bool return_value = ((*(const BitArray*)local_this).get_highest_bits)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_highest_bits_490_comment =
  "C++ Interface:\n"
  "get_highest_bits(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns true if the infinite set of bits beyond get_num_bits() are all on,\n"
  " * or false of they are all off.\n"
  " */";
#else
static const char *Dtool_BitArray_get_highest_bits_490_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BitArray::is_zero(void) const
 */
static PyObject *Dtool_BitArray_is_zero_491(PyObject *self, PyObject *) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-bool BitArray::is_zero(void) const
  bool return_value = ((*(const BitArray*)local_this).is_zero)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_is_zero_491_comment =
  "C++ Interface:\n"
  "is_zero(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns true if the entire bitmask is zero, false otherwise.\n"
  " */";
#else
static const char *Dtool_BitArray_is_zero_491_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BitArray::is_all_on(void) const
 */
static PyObject *Dtool_BitArray_is_all_on_492(PyObject *self, PyObject *) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-bool BitArray::is_all_on(void) const
  bool return_value = ((*(const BitArray*)local_this).is_all_on)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_is_all_on_492_comment =
  "C++ Interface:\n"
  "is_all_on(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns true if the entire bitmask is one, false otherwise.\n"
  " */";
#else
static const char *Dtool_BitArray_is_all_on_492_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitArray::WordType BitArray::extract(int low_bit, int size) const
 */
static PyObject *Dtool_BitArray_extract_493(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-inline BitArray::WordType BitArray::extract(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:extract", (char **)keyword_list, &param1, &param2)) {
    BitArray::WordType return_value = ((*(const BitArray*)local_this).extract)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract(BitArray self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_extract_493_comment =
  "C++ Interface:\n"
  "extract(BitArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Returns a word that represents only the indicated range of bits within this\n"
  " * BitArray, shifted to the least-significant position.  size must be <=\n"
  " * get_num_bits_per_word().\n"
  " */";
#else
static const char *Dtool_BitArray_extract_493_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitArray::store(BitArray::WordType value, int low_bit, int size)
 */
static PyObject *Dtool_BitArray_store_494(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.store")) {
    return nullptr;
  }
  // 1-inline void BitArray::store(BitArray::WordType value, int low_bit, int size)
  unsigned PY_LONG_LONG param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Kii:store", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).store)((BitArray::WordType)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store(const BitArray self, long value, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_store_494_comment =
  "C++ Interface:\n"
  "store(const BitArray self, long value, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Stores the indicated word into the indicated range of bits with this\n"
  " * BitArray.\n"
  " */";
#else
static const char *Dtool_BitArray_store_494_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BitArray::has_any_of(int low_bit, int size) const
 */
static PyObject *Dtool_BitArray_has_any_of_495(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-bool BitArray::has_any_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_any_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const BitArray*)local_this).has_any_of)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_any_of(BitArray self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_has_any_of_495_comment =
  "C++ Interface:\n"
  "has_any_of(BitArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Returns true if any bit in the indicated range is set, false otherwise.\n"
  " */";
#else
static const char *Dtool_BitArray_has_any_of_495_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BitArray::has_all_of(int low_bit, int size) const
 */
static PyObject *Dtool_BitArray_has_all_of_496(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-bool BitArray::has_all_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_all_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const BitArray*)local_this).has_all_of)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_all_of(BitArray self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_has_all_of_496_comment =
  "C++ Interface:\n"
  "has_all_of(BitArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Returns true if all bits in the indicated range are set, false otherwise.\n"
  " */";
#else
static const char *Dtool_BitArray_has_all_of_496_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitArray::set_range(int low_bit, int size)
 */
static PyObject *Dtool_BitArray_set_range_497(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.set_range")) {
    return nullptr;
  }
  // 1-void BitArray::set_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_range", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_range)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range(const BitArray self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_set_range_497_comment =
  "C++ Interface:\n"
  "set_range(const BitArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Sets the indicated range of bits on.\n"
  " */";
#else
static const char *Dtool_BitArray_set_range_497_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitArray::clear_range(int low_bit, int size)
 */
static PyObject *Dtool_BitArray_clear_range_498(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.clear_range")) {
    return nullptr;
  }
  // 1-void BitArray::clear_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:clear_range", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).clear_range)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_range(const BitArray self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_clear_range_498_comment =
  "C++ Interface:\n"
  "clear_range(const BitArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Sets the indicated range of bits off.\n"
  " */";
#else
static const char *Dtool_BitArray_clear_range_498_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitArray::set_range_to(bool value, int low_bit, int size)
 */
static PyObject *Dtool_BitArray_set_range_to_499(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.set_range_to")) {
    return nullptr;
  }
  // 1-inline void BitArray::set_range_to(bool value, int low_bit, int size)
  PyObject *param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_range_to", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_range_to)((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range_to(const BitArray self, bool value, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_set_range_to_499_comment =
  "C++ Interface:\n"
  "set_range_to(const BitArray self, bool value, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Sets the indicated range of bits to either on or off.\n"
  " */";
#else
static const char *Dtool_BitArray_set_range_to_499_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BitArray::get_num_on_bits(void) const
 */
static PyObject *Dtool_BitArray_get_num_on_bits_500(PyObject *self, PyObject *) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-int BitArray::get_num_on_bits(void) const
  int return_value = ((*(const BitArray*)local_this).get_num_on_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_num_on_bits_500_comment =
  "C++ Interface:\n"
  "get_num_on_bits(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bits that are set to 1 in the array.  Returns -1 if\n"
  " * there are an infinite number of 1 bits.\n"
  " */";
#else
static const char *Dtool_BitArray_get_num_on_bits_500_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BitArray::get_num_off_bits(void) const
 */
static PyObject *Dtool_BitArray_get_num_off_bits_501(PyObject *self, PyObject *) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-int BitArray::get_num_off_bits(void) const
  int return_value = ((*(const BitArray*)local_this).get_num_off_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_num_off_bits_501_comment =
  "C++ Interface:\n"
  "get_num_off_bits(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bits that are set to 0 in the array.  Returns -1 if\n"
  " * there are an infinite number of 0 bits.\n"
  " */";
#else
static const char *Dtool_BitArray_get_num_off_bits_501_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BitArray::get_lowest_on_bit(void) const
 */
static PyObject *Dtool_BitArray_get_lowest_on_bit_502(PyObject *self, PyObject *) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-int BitArray::get_lowest_on_bit(void) const
  int return_value = ((*(const BitArray*)local_this).get_lowest_on_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_lowest_on_bit_502_comment =
  "C++ Interface:\n"
  "get_lowest_on_bit(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the lowest 1 bit in the array.  Returns -1 if there\n"
  " * are no 1 bits.\n"
  " */";
#else
static const char *Dtool_BitArray_get_lowest_on_bit_502_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BitArray::get_lowest_off_bit(void) const
 */
static PyObject *Dtool_BitArray_get_lowest_off_bit_503(PyObject *self, PyObject *) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-int BitArray::get_lowest_off_bit(void) const
  int return_value = ((*(const BitArray*)local_this).get_lowest_off_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_lowest_off_bit_503_comment =
  "C++ Interface:\n"
  "get_lowest_off_bit(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the lowest 0 bit in the array.  Returns -1 if there\n"
  " * are no 0 bits.\n"
  " */";
#else
static const char *Dtool_BitArray_get_lowest_off_bit_503_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BitArray::get_highest_on_bit(void) const
 */
static PyObject *Dtool_BitArray_get_highest_on_bit_504(PyObject *self, PyObject *) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-int BitArray::get_highest_on_bit(void) const
  int return_value = ((*(const BitArray*)local_this).get_highest_on_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_highest_on_bit_504_comment =
  "C++ Interface:\n"
  "get_highest_on_bit(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the highest 1 bit in the array.  Returns -1 if there\n"
  " * are no 1 bits or if there an infinite number of 1 bits.\n"
  " */";
#else
static const char *Dtool_BitArray_get_highest_on_bit_504_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BitArray::get_highest_off_bit(void) const
 */
static PyObject *Dtool_BitArray_get_highest_off_bit_505(PyObject *self, PyObject *) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-int BitArray::get_highest_off_bit(void) const
  int return_value = ((*(const BitArray*)local_this).get_highest_off_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_highest_off_bit_505_comment =
  "C++ Interface:\n"
  "get_highest_off_bit(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the highest 0 bit in the array.  Returns -1 if there\n"
  " * are no 0 bits or if there an infinite number of 1 bits.\n"
  " */";
#else
static const char *Dtool_BitArray_get_highest_off_bit_505_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BitArray::get_next_higher_different_bit(int low_bit) const
 */
static PyObject *Dtool_BitArray_get_next_higher_different_bit_506(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-int BitArray::get_next_higher_different_bit(int low_bit) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const BitArray*)local_this).get_next_higher_different_bit)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_next_higher_different_bit(BitArray self, int low_bit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_next_higher_different_bit_506_comment =
  "C++ Interface:\n"
  "get_next_higher_different_bit(BitArray self, int low_bit)\n"
  "\n"
  "/**\n"
  " * Returns the index of the next bit in the array, above low_bit, whose value\n"
  " * is different that the value of low_bit.  Returns low_bit again if all bits\n"
  " * higher than low_bit have the same value.\n"
  " *\n"
  " * This can be used to quickly iterate through all of the bits in the array.\n"
  " */";
#else
static const char *Dtool_BitArray_get_next_higher_different_bit_506_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t BitArray::get_num_words(void) const
 */
static PyObject *Dtool_BitArray_get_num_words_507(PyObject *self, PyObject *) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-inline std::size_t BitArray::get_num_words(void) const
  std::size_t return_value = ((*(const BitArray*)local_this).get_num_words)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_num_words_507_comment =
  "C++ Interface:\n"
  "get_num_words(BitArray self)\n"
  "\n"
  "/**\n"
  " * Returns the number of possibly-unique words stored in the array.\n"
  " */";
#else
static const char *Dtool_BitArray_get_num_words_507_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitArray::MaskType BitArray::get_word(std::size_t n) const
 */
static PyObject *Dtool_BitArray_get_word_508(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-inline BitArray::MaskType BitArray::get_word(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    BitArray::MaskType *return_value = new BitArray::MaskType(((*(const BitArray*)local_this).get_word)(arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_word(BitArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_word_508_comment =
  "C++ Interface:\n"
  "get_word(BitArray self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the nth word in the array.  It is valid for n to be greater than\n"
  " * get_num_words(), but the return value beyond get_num_words() will always be\n"
  " * the same.\n"
  " */";
#else
static const char *Dtool_BitArray_get_word_508_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitArray::set_word(std::size_t n, BitArray::WordType value)
 */
static PyObject *Dtool_BitArray_set_word_509(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.set_word")) {
    return nullptr;
  }
  // 1-inline void BitArray::set_word(std::size_t n, BitArray::WordType value)
  Py_ssize_t param1;
  unsigned PY_LONG_LONG param2;
  static const char *keyword_list[] = {"n", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nK:set_word", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    ((*local_this).set_word)((std::size_t)param1, (BitArray::WordType)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_word(const BitArray self, int n, long value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_set_word_509_comment =
  "C++ Interface:\n"
  "set_word(const BitArray self, int n, long value)\n"
  "\n"
  "/**\n"
  " * Replaces the nth word in the array.  If n >= get_num_words(), this\n"
  " * automatically extends the array.\n"
  " */";
#else
static const char *Dtool_BitArray_set_word_509_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitArray::invert_in_place(void)
 */
static PyObject *Dtool_BitArray_invert_in_place_510(PyObject *self, PyObject *) {
  BitArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.invert_in_place")) {
    return nullptr;
  }
  // 1-void BitArray::invert_in_place(void)
  ((*local_this).invert_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitArray_invert_in_place_510_comment =
  "C++ Interface:\n"
  "invert_in_place(const BitArray self)\n"
  "\n"
  "/**\n"
  " * Inverts all the bits in the BitArray.  This is equivalent to array =\n"
  " * ~array.\n"
  " */";
#else
static const char *Dtool_BitArray_invert_in_place_510_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool BitArray::has_bits_in_common(BitArray const &other) const
 */
static PyObject *Dtool_BitArray_has_bits_in_common_511(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-bool BitArray::has_bits_in_common(BitArray const &other) const
  BitArray arg_local;
  BitArray const *arg_this = Dtool_Coerce_BitArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitArray.has_bits_in_common", "BitArray");
  }
  bool return_value = ((*(const BitArray*)local_this).has_bits_in_common)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_bits_in_common(BitArray self, const BitArray other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_has_bits_in_common_511_comment =
  "C++ Interface:\n"
  "has_bits_in_common(BitArray self, const BitArray other)\n"
  "\n"
  "/**\n"
  " * Returns true if this BitArray has any \"one\" bits in common with the other\n"
  " * one, false otherwise.\n"
  " *\n"
  " * This is equivalent to (array & other) != 0, but may be faster.\n"
  " */";
#else
static const char *Dtool_BitArray_has_bits_in_common_511_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BitArray::clear(void)
 */
static PyObject *Dtool_BitArray_clear_512(PyObject *self, PyObject *) {
  BitArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BitArray, (void **)&local_this, "BitArray.clear")) {
    return nullptr;
  }
  // 1-inline void BitArray::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_BitArray_clear_512_comment =
  "C++ Interface:\n"
  "clear(const BitArray self)\n"
  "\n"
  "/**\n"
  " * Sets all the bits in the BitArray off.\n"
  " */";
#else
static const char *Dtool_BitArray_clear_512_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitArray::output(std::ostream &out) const
 */
static PyObject *Dtool_BitArray_output_513(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-void BitArray::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "BitArray.output", false, true);
  if (arg_this != nullptr) {
    ((*(const BitArray*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BitArray self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_output_513_comment =
  "C++ Interface:\n"
  "output(BitArray self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes the BitArray out as a hex number.  For a BitArray, this is always\n"
  " * the same as output_hex(); it's too confusing for the output format to\n"
  " * change back and forth at runtime.\n"
  " */";
#else
static const char *Dtool_BitArray_output_513_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitArray::output_binary(std::ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_BitArray_output_binary_514(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-void BitArray::output_binary(std::ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_binary", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BitArray.output_binary", false, true);
    if (param1_this != nullptr) {
      ((*(const BitArray*)local_this).output_binary)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_binary(BitArray self, ostream out, int spaces_every)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_output_binary_514_comment =
  "C++ Interface:\n"
  "output_binary(BitArray self, ostream out, int spaces_every)\n"
  "\n"
  "/**\n"
  " * Writes the BitArray out as a binary number, with spaces every four bits.\n"
  " */";
#else
static const char *Dtool_BitArray_output_binary_514_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitArray::output_hex(std::ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_BitArray_output_hex_515(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-void BitArray::output_hex(std::ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_hex", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BitArray.output_hex", false, true);
    if (param1_this != nullptr) {
      ((*(const BitArray*)local_this).output_hex)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_hex(BitArray self, ostream out, int spaces_every)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_output_hex_515_comment =
  "C++ Interface:\n"
  "output_hex(BitArray self, ostream out, int spaces_every)\n"
  "\n"
  "/**\n"
  " * Writes the BitArray out as a hexadecimal number, with spaces every four\n"
  " * digits.\n"
  " */";
#else
static const char *Dtool_BitArray_output_hex_515_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void BitArray::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_BitArray_write_516(PyObject *self, PyObject *args, PyObject *kwds) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-void BitArray::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BitArray.write", false, true);
    if (param1_this != nullptr) {
      ((*(const BitArray*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BitArray self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_write_516_comment =
  "C++ Interface:\n"
  "write(BitArray self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes the BitArray out as a binary or a hex number, according to the\n"
  " * number of bits.\n"
  " */";
#else
static const char *Dtool_BitArray_write_516_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int BitArray::compare_to(BitArray const &other) const
 */
static PyObject *Dtool_BitArray_compare_to_520(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BitArray)) {
    return nullptr;
  }
  // 1-int BitArray::compare_to(BitArray const &other) const
  BitArray arg_local;
  BitArray const *arg_this = Dtool_Coerce_BitArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitArray.compare_to", "BitArray");
  }
  int return_value = ((*(const BitArray*)local_this).compare_to)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(BitArray self, const BitArray other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BitArray_compare_to_520_comment =
  "C++ Interface:\n"
  "compare_to(BitArray self, const BitArray other)\n"
  "\n"
  "/**\n"
  " * Returns a number less than zero if this BitArray sorts before the indicated\n"
  " * other BitArray, greater than zero if it sorts after, or 0 if they are\n"
  " * equivalent.  This is based on the same ordering defined by operator <.\n"
  " */";
#else
static const char *Dtool_BitArray_compare_to_520_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BitArray::get_class_type(void)
 */
static PyObject *Dtool_BitArray_get_class_type_532(PyObject *, PyObject *) {
  // 1-static TypeHandle BitArray::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BitArray::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BitArray_get_class_type_532_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BitArray_get_class_type_532_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BitArray::BitArray(void)
 * inline BitArray::BitArray(BitArray const &) = default
 * inline BitArray::BitArray(BitArray::WordType init_value)
 * BitArray::BitArray(SparseArray const &from)
 */
static int Dtool_Init_BitArray(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline BitArray::BitArray(void)
      BitArray *return_value = new BitArray();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitArray, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline BitArray::BitArray(BitArray const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          BitArray const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_BitArray);
          if (param0_this != nullptr) {
            BitArray *return_value = new BitArray(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitArray, true, false);
          }
        }
      }

      {
        // -2 BitArray::BitArray(SparseArray const &from)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "from")) {
          SparseArray const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_SparseArray);
          if (param0_this != nullptr) {
            BitArray *return_value = new BitArray(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitArray, true, false);
          }
        }
      }

      {
        // -2 inline BitArray::BitArray(BitArray::WordType init_value)
        unsigned PY_LONG_LONG param0;
        static const char *keyword_list[] = {"init_value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "K:BitArray", (char **)keyword_list, &param0)) {
          BitArray *return_value = new BitArray((BitArray::WordType)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitArray, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline BitArray::BitArray(BitArray const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          BitArray param0_local;
          BitArray const *param0_this = Dtool_Coerce_BitArray(param0, param0_local);
          if ((param0_this != nullptr)) {
            BitArray *return_value = new BitArray(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitArray, true, false);
          }
        }
      }

      {
        // -2 BitArray::BitArray(SparseArray const &from)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "from")) {
          SparseArray param0_local;
          SparseArray const *param0_this = Dtool_Coerce_SparseArray(param0, param0_local);
          if ((param0_this != nullptr)) {
            BitArray *return_value = new BitArray(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BitArray, true, false);
          }
        }
      }

      // No coercion possible: inline BitArray::BitArray(BitArray::WordType init_value)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "BitArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BitArray()\n"
      "BitArray(const BitArray param0)\n"
      "BitArray(const SparseArray from)\n"
      "BitArray(long init_value)\n");
  }
  return -1;
}

BitArray *Dtool_Coerce_BitArray(PyObject *args, BitArray &coerced) {
  BitArray *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_BitArray)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const BitArray *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 BitArray::BitArray(SparseArray const &from)
      SparseArray const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_SparseArray);
      if (arg_this != nullptr) {
        coerced = BitArray(*arg_this);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

    {
      // -2 inline BitArray::BitArray(BitArray::WordType init_value)
      unsigned PY_LONG_LONG param0;
      if (PyArg_Parse(arg, "K:BitArray", &param0)) {
        coerced = BitArray((BitArray::WordType)param0);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_BitArray(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BitArray) {
    printf("BitArray ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BitArray *local_this = (BitArray *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BitArray) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BitArray(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BitArray) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ButtonHandle
 */
/**
 * Python function wrapper for:
 * inline int ButtonHandle::compare_to(ButtonHandle const &other) const
 */
static PyObject *Dtool_ButtonHandle_compare_to_542(PyObject *self, PyObject *arg) {
  ButtonHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonHandle)) {
    return nullptr;
  }
  // 1-inline int ButtonHandle::compare_to(ButtonHandle const &other) const
  ButtonHandle arg_local;
  ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ButtonHandle.compare_to", "ButtonHandle");
  }
  int return_value = ((*(const ButtonHandle*)local_this).compare_to)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(ButtonHandle self, const ButtonHandle other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_compare_to_542_comment =
  "C++ Interface:\n"
  "compare_to(ButtonHandle self, const ButtonHandle other)\n"
  "\n"
  "/**\n"
  " * Sorts ButtonHandles arbitrarily (according to <, >, etc.).  Returns a\n"
  " * number less than 0 if this type sorts before the other one, greater than\n"
  " * zero if it sorts after, 0 if they are equivalent.\n"
  " */";
#else
static const char *Dtool_ButtonHandle_compare_to_542_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ButtonHandle::get_hash(void) const
 */
static PyObject *Dtool_ButtonHandle_get_hash_543(PyObject *self, PyObject *) {
  ButtonHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonHandle)) {
    return nullptr;
  }
  // 1-inline std::size_t ButtonHandle::get_hash(void) const
  std::size_t return_value = ((*(const ButtonHandle*)local_this).get_hash)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_get_hash_543_comment =
  "C++ Interface:\n"
  "get_hash(ButtonHandle self)\n"
  "\n"
  "/**\n"
  " * Returns a hash code suitable for phash_map.\n"
  " */";
#else
static const char *Dtool_ButtonHandle_get_hash_543_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string ButtonHandle::get_name(void) const
 */
static PyObject *Dtool_ButtonHandle_get_name_544(PyObject *self, PyObject *) {
  ButtonHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonHandle)) {
    return nullptr;
  }
  // 1-std::string ButtonHandle::get_name(void) const
  std::string return_value = ((*(const ButtonHandle*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_get_name_544_comment =
  "C++ Interface:\n"
  "get_name(ButtonHandle self)\n"
  "\n"
  "/**\n"
  " * Returns the name of the button.\n"
  " */";
#else
static const char *Dtool_ButtonHandle_get_name_544_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ButtonHandle::has_ascii_equivalent(void) const
 */
static PyObject *Dtool_ButtonHandle_has_ascii_equivalent_545(PyObject *self, PyObject *) {
  ButtonHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonHandle)) {
    return nullptr;
  }
  // 1-inline bool ButtonHandle::has_ascii_equivalent(void) const
  bool return_value = ((*(const ButtonHandle*)local_this).has_ascii_equivalent)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_has_ascii_equivalent_545_comment =
  "C++ Interface:\n"
  "has_ascii_equivalent(ButtonHandle self)\n"
  "\n"
  "/**\n"
  " * Returns true if the button was created with an ASCII equivalent code (e.g.\n"
  " * for a standard keyboard button).\n"
  " */";
#else
static const char *Dtool_ButtonHandle_has_ascii_equivalent_545_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline char ButtonHandle::get_ascii_equivalent(void) const
 */
static PyObject *Dtool_ButtonHandle_get_ascii_equivalent_546(PyObject *self, PyObject *) {
  ButtonHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonHandle)) {
    return nullptr;
  }
  // 1-inline char ButtonHandle::get_ascii_equivalent(void) const
  char return_value = ((*(const ButtonHandle*)local_this).get_ascii_equivalent)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_get_ascii_equivalent_546_comment =
  "C++ Interface:\n"
  "get_ascii_equivalent(ButtonHandle self)\n"
  "\n"
  "/**\n"
  " * Returns the character code associated with the button, or '\\0' if no ASCII\n"
  " * code was associated.\n"
  " */";
#else
static const char *Dtool_ButtonHandle_get_ascii_equivalent_546_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ButtonHandle ButtonHandle::get_alias(void) const
 */
static PyObject *Dtool_ButtonHandle_get_alias_547(PyObject *self, PyObject *) {
  ButtonHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonHandle)) {
    return nullptr;
  }
  // 1-ButtonHandle ButtonHandle::get_alias(void) const
  ButtonHandle *return_value = new ButtonHandle(((*(const ButtonHandle*)local_this).get_alias)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_get_alias_547_comment =
  "C++ Interface:\n"
  "get_alias(ButtonHandle self)\n"
  "\n"
  "/**\n"
  " * Returns the alias (alternate name) associated with the button, if any, or\n"
  " * ButtonHandle::none() if the button has no alias.\n"
  " *\n"
  " * Each button is allowed to have one alias, and multiple different buttons\n"
  " * can refer to the same alias.  The alias should be the more general name for\n"
  " * the button, for instance, shift is an alias for lshift, but not vice-versa.\n"
  " */";
#else
static const char *Dtool_ButtonHandle_get_alias_547_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ButtonHandle::matches(ButtonHandle const &other) const
 */
static PyObject *Dtool_ButtonHandle_matches_548(PyObject *self, PyObject *arg) {
  ButtonHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonHandle)) {
    return nullptr;
  }
  // 1-inline bool ButtonHandle::matches(ButtonHandle const &other) const
  ButtonHandle arg_local;
  ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ButtonHandle.matches", "ButtonHandle");
  }
  bool return_value = ((*(const ButtonHandle*)local_this).matches)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "matches(ButtonHandle self, const ButtonHandle other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_matches_548_comment =
  "C++ Interface:\n"
  "matches(ButtonHandle self, const ButtonHandle other)\n"
  "\n"
  "/**\n"
  " * Returns true if this ButtonHandle is the same as the other one, or if the\n"
  " * other one is an alias for this one.  (Does not return true if this button\n"
  " * is an alias for the other one, however.)\n"
  " *\n"
  " * This is a more general comparison than operator ==.\n"
  " */";
#else
static const char *Dtool_ButtonHandle_matches_548_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * constexpr int ButtonHandle::get_index(void) const
 */
static PyObject *Dtool_ButtonHandle_get_index_549(PyObject *self, PyObject *) {
  ButtonHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonHandle)) {
    return nullptr;
  }
  // 1-constexpr int ButtonHandle::get_index(void) const
  int return_value = ((*(const ButtonHandle*)local_this).get_index)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_get_index_549_comment =
  "C++ Interface:\n"
  "get_index(ButtonHandle self)\n"
  "\n"
  "/**\n"
  " * Returns the integer index associated with this ButtonHandle.  Each\n"
  " * different ButtonHandle will have a different index.  However, you probably\n"
  " * shouldn't be using this method; you should just treat the ButtonHandles as\n"
  " * opaque classes.  This is provided for the convenience of non-C++ scripting\n"
  " * languages to build a hashtable of ButtonHandles.\n"
  " */";
#else
static const char *Dtool_ButtonHandle_get_index_549_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ButtonHandle::output(std::ostream &out) const
 */
static PyObject *Dtool_ButtonHandle_output_550(PyObject *self, PyObject *arg) {
  ButtonHandle *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonHandle)) {
    return nullptr;
  }
  // 1-inline void ButtonHandle::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ButtonHandle.output", false, true);
  if (arg_this != nullptr) {
    ((*(const ButtonHandle*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ButtonHandle self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_output_550_comment =
  "C++ Interface:\n"
  "output(ButtonHandle self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ButtonHandle_output_550_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr ButtonHandle ButtonHandle::none(void)
 */
static PyObject *Dtool_ButtonHandle_none_551(PyObject *, PyObject *) {
  // 1-static constexpr ButtonHandle ButtonHandle::none(void)
  ButtonHandle *return_value = new ButtonHandle((ButtonHandle::none)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_none_551_comment =
  "C++ Interface:\n"
  "none()\n";
#else
static const char *Dtool_ButtonHandle_none_551_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ButtonHandle::get_class_type(void)
 */
static PyObject *Dtool_ButtonHandle_get_class_type_560(PyObject *, PyObject *) {
  // 1-static TypeHandle ButtonHandle::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ButtonHandle::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ButtonHandle_get_class_type_560_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ButtonHandle_get_class_type_560_comment = nullptr;
#endif

static PyObject *Dtool_ButtonHandle_index_Getter(PyObject *self, void *) {
  const ButtonHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return nullptr;
  }

  // 1-constexpr int ButtonHandle::get_index(void) const
  int return_value = ((*(const ButtonHandle*)local_this).get_index)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ButtonHandle_name_Getter(PyObject *self, void *) {
  const ButtonHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return nullptr;
  }

  // 1-std::string ButtonHandle::get_name(void) const
  std::string return_value = ((*(const ButtonHandle*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ButtonHandle_ascii_equivalent_Getter(PyObject *self, void *) {
  const ButtonHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_ascii_equivalent()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline char ButtonHandle::get_ascii_equivalent(void) const
  char return_value = ((*(const ButtonHandle*)local_this).get_ascii_equivalent)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ButtonHandle_alias_Getter(PyObject *self, void *) {
  const ButtonHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return nullptr;
  }

  // 1-ButtonHandle ButtonHandle::get_alias(void) const
  ButtonHandle *return_value = new ButtonHandle(((*(const ButtonHandle*)local_this).get_alias)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

/**
 * Python function wrapper for:
 * inline ButtonHandle::ButtonHandle(void) = default
 * inline ButtonHandle::ButtonHandle(ButtonHandle const &) = default
 * constexpr ButtonHandle::ButtonHandle(int index)
 * ButtonHandle::ButtonHandle(std::string const &name)
 */
static int Dtool_Init_ButtonHandle(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline ButtonHandle::ButtonHandle(void) = default
      ButtonHandle *return_value = new ButtonHandle(0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonHandle, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline ButtonHandle::ButtonHandle(ButtonHandle const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          ButtonHandle const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_ButtonHandle);
          if (param0_this != nullptr) {
            ButtonHandle *return_value = new ButtonHandle(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonHandle, true, false);
          }
        }
      }

      {
        // -2 ButtonHandle::ButtonHandle(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ButtonHandle", (char **)keyword_list, &param0_str, &param0_len)) {
          ButtonHandle *return_value = new ButtonHandle(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonHandle, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 constexpr ButtonHandle::ButtonHandle(int index)
        int param0;
        static const char *keyword_list[] = {"index", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:ButtonHandle", (char **)keyword_list, &param0)) {
          ButtonHandle *return_value = new ButtonHandle((int)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonHandle, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline ButtonHandle::ButtonHandle(ButtonHandle const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          ButtonHandle param0_local;
          ButtonHandle const *param0_this = Dtool_Coerce_ButtonHandle(param0, param0_local);
          if ((param0_this != nullptr)) {
            ButtonHandle *return_value = new ButtonHandle(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonHandle, true, false);
          }
        }
      }

      // No coercion possible: ButtonHandle::ButtonHandle(std::string const &name)
      // No coercion possible: constexpr ButtonHandle::ButtonHandle(int index)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ButtonHandle() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ButtonHandle()\n"
      "ButtonHandle(const ButtonHandle param0)\n"
      "ButtonHandle(str name)\n"
      "ButtonHandle(int index)\n");
  }
  return -1;
}

ButtonHandle *Dtool_Coerce_ButtonHandle(PyObject *args, ButtonHandle &coerced) {
  ButtonHandle *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_ButtonHandle)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const ButtonHandle *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 ButtonHandle::ButtonHandle(std::string const &name)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
      param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
      if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
        param0_str = nullptr;
      }
#endif
      if (param0_str != nullptr) {
        coerced = ButtonHandle(std::string(param0_str, param0_len));
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }

    {
      // -2 constexpr ButtonHandle::ButtonHandle(int index)
      if (PyLongOrInt_Check(arg)) {
        long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
        if (arg_val < INT_MIN || arg_val > INT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for signed integer",
                       arg_val);
          return nullptr;
        }
#endif
        coerced = ButtonHandle((int)arg_val);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
    }

  }
  return nullptr;
}

static void *Dtool_UpcastInterface_ButtonHandle(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ButtonHandle) {
    printf("ButtonHandle ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ButtonHandle *local_this = (ButtonHandle *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ButtonHandle) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ButtonHandle(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ButtonHandle) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ButtonRegistry
 */
/**
 * Python function wrapper for:
 * ButtonHandle ButtonRegistry::get_button(std::string const &name)
 */
static PyObject *Dtool_ButtonRegistry_get_button_563(PyObject *self, PyObject *arg) {
  ButtonRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonRegistry, (void **)&local_this, "ButtonRegistry.get_button")) {
    return nullptr;
  }
  // 1-ButtonHandle ButtonRegistry::get_button(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ButtonHandle *return_value = new ButtonHandle(((*local_this).get_button)(std::string(param1_str, param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_button(const ButtonRegistry self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonRegistry_get_button_563_comment =
  "C++ Interface:\n"
  "get_button(const ButtonRegistry self, str name)\n"
  "\n"
  "/**\n"
  " * Finds a ButtonHandle in the registry matching the indicated name.  If there\n"
  " * is no such ButtonHandle, registers a new one and returns it.\n"
  " */";
#else
static const char *Dtool_ButtonRegistry_get_button_563_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ButtonHandle ButtonRegistry::find_button(std::string const &name)
 */
static PyObject *Dtool_ButtonRegistry_find_button_564(PyObject *self, PyObject *arg) {
  ButtonRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ButtonRegistry, (void **)&local_this, "ButtonRegistry.find_button")) {
    return nullptr;
  }
  // 1-ButtonHandle ButtonRegistry::find_button(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ButtonHandle *return_value = new ButtonHandle(((*local_this).find_button)(std::string(param1_str, param1_len)));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_button(const ButtonRegistry self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonRegistry_find_button_564_comment =
  "C++ Interface:\n"
  "find_button(const ButtonRegistry self, str name)\n"
  "\n"
  "/**\n"
  " * Finds a ButtonHandle in the registry matching the indicated name.  If there\n"
  " * is no such ButtonHandle, returns ButtonHandle::none().\n"
  " */";
#else
static const char *Dtool_ButtonRegistry_find_button_564_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ButtonHandle ButtonRegistry::find_ascii_button(char ascii_equivalent) const
 */
static PyObject *Dtool_ButtonRegistry_find_ascii_button_565(PyObject *self, PyObject *arg) {
  ButtonRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonRegistry)) {
    return nullptr;
  }
  // 1-ButtonHandle ButtonRegistry::find_ascii_button(char ascii_equivalent) const
  char *param1_str;
  Py_ssize_t param1_len;
  if (PyArg_Parse(arg, "s#:find_ascii_button", &param1_str, &param1_len)) {
    if (param1_len == 1) {
      ButtonHandle *return_value = new ButtonHandle(((*(const ButtonRegistry*)local_this).find_ascii_button)(param1_str[0]));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_ascii_button(ButtonRegistry self, char ascii_equivalent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonRegistry_find_ascii_button_565_comment =
  "C++ Interface:\n"
  "find_ascii_button(ButtonRegistry self, char ascii_equivalent)\n"
  "\n"
  "/**\n"
  " * Finds a ButtonHandle in the registry matching the indicated ASCII\n"
  " * equivalent character.  If there is no such ButtonHandle, returns\n"
  " * ButtonHandle::none().\n"
  " */";
#else
static const char *Dtool_ButtonRegistry_find_ascii_button_565_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ButtonRegistry::write(std::ostream &out) const
 */
static PyObject *Dtool_ButtonRegistry_write_566(PyObject *self, PyObject *arg) {
  ButtonRegistry *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonRegistry)) {
    return nullptr;
  }
  // 1-void ButtonRegistry::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ButtonRegistry.write", false, true);
  if (arg_this != nullptr) {
    ((*(const ButtonRegistry*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ButtonRegistry self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonRegistry_write_566_comment =
  "C++ Interface:\n"
  "write(ButtonRegistry self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ButtonRegistry_write_566_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ButtonRegistry *ButtonRegistry::ptr(void)
 */
static PyObject *Dtool_ButtonRegistry_ptr_567(PyObject *, PyObject *) {
  // 1-static inline ButtonRegistry *ButtonRegistry::ptr(void)
  ButtonRegistry *return_value = (ButtonRegistry::ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonRegistry, false, false);
}

#ifndef NDEBUG
static const char *Dtool_ButtonRegistry_ptr_567_comment =
  "C++ Interface:\n"
  "ptr()\n"
  "\n"
  "// ptr() returns the pointer to the global ButtonRegistry object.\n"
  "\n"
  "/**\n"
  " * Returns the pointer to the global ButtonRegistry object.\n"
  " */";
#else
static const char *Dtool_ButtonRegistry_ptr_567_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ButtonRegistry::ButtonRegistry(ButtonRegistry const &) = default
 */
static int Dtool_Init_ButtonRegistry(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("ButtonRegistry() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline ButtonRegistry::ButtonRegistry(ButtonRegistry const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    ButtonRegistry const *param0_this = (ButtonRegistry *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_ButtonRegistry, 0, "ButtonRegistry.ButtonRegistry", true, true);
    if (param0_this != nullptr) {
      ButtonRegistry *return_value = new ButtonRegistry(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonRegistry, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ButtonRegistry(const ButtonRegistry param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ButtonRegistry(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ButtonRegistry) {
    printf("ButtonRegistry ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ButtonRegistry *local_this = (ButtonRegistry *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ButtonRegistry) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ButtonRegistry(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ButtonRegistry) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ButtonMap
 */
/**
 * Python function wrapper for:
 * inline std::size_t ButtonMap::get_num_buttons(void) const
 */
static PyObject *Dtool_ButtonMap_get_num_buttons_572(PyObject *self, PyObject *) {
  ButtonMap *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonMap)) {
    return nullptr;
  }
  // 1-inline std::size_t ButtonMap::get_num_buttons(void) const
  std::size_t return_value = ((*(const ButtonMap*)local_this).get_num_buttons)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ButtonMap_get_num_buttons_572_comment =
  "C++ Interface:\n"
  "get_num_buttons(ButtonMap self)\n"
  "\n"
  "/**\n"
  " * Returns the number of buttons that this button mapping specifies.\n"
  " */";
#else
static const char *Dtool_ButtonMap_get_num_buttons_572_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ButtonHandle ButtonMap::get_raw_button(std::size_t i) const
 */
static PyObject *Dtool_ButtonMap_get_raw_button_573(PyObject *self, PyObject *arg) {
  ButtonMap *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonMap)) {
    return nullptr;
  }
  // 1-inline ButtonHandle ButtonMap::get_raw_button(std::size_t i) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ButtonHandle *return_value = new ButtonHandle(((*(const ButtonMap*)local_this).get_raw_button)(arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_raw_button(ButtonMap self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonMap_get_raw_button_573_comment =
  "C++ Interface:\n"
  "get_raw_button(ButtonMap self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the underlying raw button associated with the nth button.\n"
  " */";
#else
static const char *Dtool_ButtonMap_get_raw_button_573_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ButtonHandle ButtonMap::get_mapped_button(ButtonHandle raw) const
 * inline ButtonHandle ButtonMap::get_mapped_button(std::size_t i) const
 * inline ButtonHandle ButtonMap::get_mapped_button(std::string const &raw_name) const
 */
static PyObject *Dtool_ButtonMap_get_mapped_button_574(PyObject *self, PyObject *arg) {
  ButtonMap *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonMap)) {
    return nullptr;
  }
  {
    // -2 inline ButtonHandle ButtonMap::get_mapped_button(ButtonHandle raw) const
    ButtonHandle *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ButtonHandle);
    if (arg_this != nullptr) {
      ButtonHandle *return_value = new ButtonHandle(((*(const ButtonMap*)local_this).get_mapped_button)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
    }
  }

  {
    // -2 inline ButtonHandle ButtonMap::get_mapped_button(std::string const &raw_name) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ButtonHandle *return_value = new ButtonHandle(((*(const ButtonMap*)local_this).get_mapped_button)(std::string(param1_str, param1_len)));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline ButtonHandle ButtonMap::get_mapped_button(std::size_t i) const
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return nullptr;
      }
#endif
      ButtonHandle *return_value = new ButtonHandle(((*(const ButtonMap*)local_this).get_mapped_button)(arg_val));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
    }
  }

  {
    // -2 inline ButtonHandle ButtonMap::get_mapped_button(ButtonHandle raw) const
    ButtonHandle arg_local;
    ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
    if ((arg_this != nullptr)) {
      ButtonHandle *return_value = new ButtonHandle(((*(const ButtonMap*)local_this).get_mapped_button)(*arg_this));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
    }
  }

  // No coercion possible: inline ButtonHandle ButtonMap::get_mapped_button(std::string const &raw_name) const
  // No coercion possible: inline ButtonHandle ButtonMap::get_mapped_button(std::size_t i) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_mapped_button(ButtonMap self, ButtonHandle raw)\n"
      "get_mapped_button(ButtonMap self, str raw_name)\n"
      "get_mapped_button(ButtonMap self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonMap_get_mapped_button_574_comment =
  "C++ Interface:\n"
  "get_mapped_button(ButtonMap self, ButtonHandle raw)\n"
  "get_mapped_button(ButtonMap self, str raw_name)\n"
  "get_mapped_button(ButtonMap self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the nth mapped button, meaning the button that the nth raw button\n"
  " * is mapped to.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the button that the given button is mapped to, or\n"
  " * ButtonHandle::none() if this map does not specify a mapped button for the\n"
  " * given raw button.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns the button that the given button is mapped to, or\n"
  " * ButtonHandle::none() if this map does not specify a mapped button for the\n"
  " * given raw button.\n"
  " */";
#else
static const char *Dtool_ButtonMap_get_mapped_button_574_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ButtonMap::get_mapped_button_label(ButtonHandle raw) const
 * inline std::string const &ButtonMap::get_mapped_button_label(std::size_t i) const
 * inline std::string const &ButtonMap::get_mapped_button_label(std::string const &raw_name) const
 */
static PyObject *Dtool_ButtonMap_get_mapped_button_label_575(PyObject *self, PyObject *arg) {
  ButtonMap *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonMap)) {
    return nullptr;
  }
  {
    // -2 inline std::string const &ButtonMap::get_mapped_button_label(ButtonHandle raw) const
    ButtonHandle *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ButtonHandle);
    if (arg_this != nullptr) {
      std::string const &return_value = ((*(const ButtonMap*)local_this).get_mapped_button_label)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline std::string const &ButtonMap::get_mapped_button_label(std::string const &raw_name) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      std::string const &return_value = ((*(const ButtonMap*)local_this).get_mapped_button_label)(std::string(param1_str, param1_len));
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 inline std::string const &ButtonMap::get_mapped_button_label(std::size_t i) const
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return nullptr;
      }
#endif
      std::string const &return_value = ((*(const ButtonMap*)local_this).get_mapped_button_label)(arg_val);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  {
    // -2 inline std::string const &ButtonMap::get_mapped_button_label(ButtonHandle raw) const
    ButtonHandle arg_local;
    ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
    if ((arg_this != nullptr)) {
      std::string const &return_value = ((*(const ButtonMap*)local_this).get_mapped_button_label)(*arg_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }

  // No coercion possible: inline std::string const &ButtonMap::get_mapped_button_label(std::string const &raw_name) const
  // No coercion possible: inline std::string const &ButtonMap::get_mapped_button_label(std::size_t i) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_mapped_button_label(ButtonMap self, ButtonHandle raw)\n"
      "get_mapped_button_label(ButtonMap self, str raw_name)\n"
      "get_mapped_button_label(ButtonMap self, int i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonMap_get_mapped_button_label_575_comment =
  "C++ Interface:\n"
  "get_mapped_button_label(ButtonMap self, ButtonHandle raw)\n"
  "get_mapped_button_label(ButtonMap self, str raw_name)\n"
  "get_mapped_button_label(ButtonMap self, int i)\n"
  "\n"
  "/**\n"
  " * Returns the label associated with the nth mapped button, meaning the button\n"
  " * that the nth raw button is mapped to.\n"
  " */\n"
  "\n"
  "/**\n"
  " * If the button map specifies a special name for the button (eg.  if the\n"
  " * operating system or keyboard device has a localized name describing the\n"
  " * key), returns it, or the empty string otherwise.\n"
  " *\n"
  " * Note that this is not the same as get_mapped_button().get_name(), which\n"
  " * returns the name of the Panda event associated with the button.\n"
  " */\n"
  "\n"
  "/**\n"
  " * If the button map specifies a special name for the button (eg.  if the\n"
  " * operating system or keyboard device has a localized name describing the\n"
  " * key), returns it, or the empty string otherwise.\n"
  " *\n"
  " * Note that this is not the same as get_mapped_button().get_name(), which\n"
  " * returns the name of the Panda event associated with the button.\n"
  " */";
#else
static const char *Dtool_ButtonMap_get_mapped_button_label_575_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ButtonMap::output(std::ostream &out) const
 */
static PyObject *Dtool_ButtonMap_output_576(PyObject *self, PyObject *arg) {
  ButtonMap *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonMap)) {
    return nullptr;
  }
  // 1-void ButtonMap::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ButtonMap.output", false, true);
  if (arg_this != nullptr) {
    ((*(const ButtonMap*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ButtonMap self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonMap_output_576_comment =
  "C++ Interface:\n"
  "output(ButtonMap self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ButtonMap_output_576_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ButtonMap::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_ButtonMap_write_577(PyObject *self, PyObject *args, PyObject *kwds) {
  ButtonMap *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ButtonMap)) {
    return nullptr;
  }
  // 1-void ButtonMap::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "ButtonMap.write", false, true);
    if (param1_this != nullptr) {
      ((*(const ButtonMap*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ButtonMap self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ButtonMap_write_577_comment =
  "C++ Interface:\n"
  "write(ButtonMap self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ButtonMap_write_577_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ButtonMap::get_class_type(void)
 */
static PyObject *Dtool_ButtonMap_get_class_type_578(PyObject *, PyObject *) {
  // 1-static TypeHandle ButtonMap::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ButtonMap::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ButtonMap_get_class_type_578_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ButtonMap_get_class_type_578_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ButtonMap::ButtonMap(void) = default
 * inline ButtonMap::ButtonMap(ButtonMap const &) = default
 */
static int Dtool_Init_ButtonMap(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("ButtonMap() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline ButtonMap::ButtonMap(void) = default
      ButtonMap *return_value = new ButtonMap();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonMap, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline ButtonMap::ButtonMap(ButtonMap const &) = default
      ButtonMap const *arg_this = (ButtonMap *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ButtonMap, 0, "ButtonMap.ButtonMap", true, true);
      if (arg_this != nullptr) {
        ButtonMap *return_value = new ButtonMap(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ButtonMap, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ButtonMap() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ButtonMap()\n"
      "ButtonMap(const ButtonMap param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ButtonMap(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ButtonMap) {
    printf("ButtonMap ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ButtonMap *local_this = (ButtonMap *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ButtonMap) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ButtonMap(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ButtonMap) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ButtonMap*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ButtonMap*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (ButtonMap*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CallbackObject
 */
/**
 * Python function wrapper for:
 * virtual void CallbackObject::output(std::ostream &out) const
 */
static PyObject *Dtool_CallbackObject_output_582(PyObject *self, PyObject *arg) {
  CallbackObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CallbackObject)) {
    return nullptr;
  }
  // 1-virtual void CallbackObject::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "CallbackObject.output", false, true);
  if (arg_this != nullptr) {
    ((*(const CallbackObject*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CallbackObject self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CallbackObject_output_582_comment =
  "C++ Interface:\n"
  "output(CallbackObject self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CallbackObject_output_582_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static PointerTo< CallbackObject > CallbackObject::make(PyObject *function)
 */
static PyObject *Dtool_CallbackObject_make_583(PyObject *, PyObject *arg) {
  // 1-static PointerTo< CallbackObject > CallbackObject::make(PyObject *function)
  PointerTo< CallbackObject > return_value = Extension<CallbackObject>::make(arg);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  CallbackObject *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_CallbackObject, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(object function)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CallbackObject_make_583_comment =
  "C++ Interface:\n"
  "make(object function)\n";
#else
static const char *Dtool_CallbackObject_make_583_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CallbackObject::get_class_type(void)
 */
static PyObject *Dtool_CallbackObject_get_class_type_584(PyObject *, PyObject *) {
  // 1-static TypeHandle CallbackObject::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CallbackObject::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CallbackObject_get_class_type_584_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CallbackObject_get_class_type_584_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline CallbackObject::CallbackObject(CallbackObject const &) = default
 */
static int Dtool_Init_CallbackObject(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("CallbackObject() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline CallbackObject::CallbackObject(CallbackObject const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    CPT(CallbackObject) param0_this;
    if (!Dtool_ConstCoerce_CallbackObject(param0, param0_this)) {
      Dtool_Raise_ArgTypeError(param0, 0, "CallbackObject.CallbackObject", "CallbackObject");
      return -1;
    }
    CallbackObject *return_value = new CallbackObject(*std::move(param0_this));
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_CallbackObject, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "CallbackObject(const CallbackObject param0)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_CallbackObject(PyObject *args, CPT(CallbackObject) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_CallbackObject)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static PointerTo< CallbackObject > CallbackObject::make(PyObject *function)
    PointerTo< CallbackObject > return_value = Extension<CallbackObject>::make(arg);
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != nullptr) {
      return false;
    } else {
      coerced = std::move(DCAST(CallbackObject, return_value.p()));
      return true;
    }
  }
  return false;
}

bool Dtool_Coerce_CallbackObject(PyObject *args, PT(CallbackObject) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_CallbackObject)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-static PointerTo< CallbackObject > CallbackObject::make(PyObject *function)
    PointerTo< CallbackObject > return_value = Extension<CallbackObject>::make(arg);
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != nullptr) {
      return false;
    } else {
      coerced = std::move(DCAST(CallbackObject, return_value.p()));
      return true;
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_CallbackObject(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CallbackObject) {
    printf("CallbackObject ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CallbackObject *local_this = (CallbackObject *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CallbackObject) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CallbackObject(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CallbackObject) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CallbackObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CallbackObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (CallbackObject*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CachedTypedWritableReferenceCount
 */
/**
 * Python function wrapper for:
 * inline int CachedTypedWritableReferenceCount::get_cache_ref_count(void) const
 */
static PyObject *Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_588(PyObject *self, PyObject *) {
  CachedTypedWritableReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CachedTypedWritableReferenceCount)) {
    return nullptr;
  }
  // 1-inline int CachedTypedWritableReferenceCount::get_cache_ref_count(void) const
  int return_value = ((*(const CachedTypedWritableReferenceCount*)local_this).get_cache_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_588_comment =
  "C++ Interface:\n"
  "get_cache_ref_count(CachedTypedWritableReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Returns the current reference count.\n"
  " */";
#else
static const char *Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_588_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void CachedTypedWritableReferenceCount::cache_ref(void) const
 */
static PyObject *Dtool_CachedTypedWritableReferenceCount_cache_ref_589(PyObject *self, PyObject *) {
  CachedTypedWritableReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CachedTypedWritableReferenceCount)) {
    return nullptr;
  }
  // 1-inline void CachedTypedWritableReferenceCount::cache_ref(void) const
  ((*(const CachedTypedWritableReferenceCount*)local_this).cache_ref)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CachedTypedWritableReferenceCount_cache_ref_589_comment =
  "C++ Interface:\n"
  "cache_ref(CachedTypedWritableReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Explicitly increments the cache reference count and the normal reference\n"
  " * count simultaneously.\n"
  " */";
#else
static const char *Dtool_CachedTypedWritableReferenceCount_cache_ref_589_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CachedTypedWritableReferenceCount::cache_unref(void) const
 */
static PyObject *Dtool_CachedTypedWritableReferenceCount_cache_unref_590(PyObject *self, PyObject *) {
  CachedTypedWritableReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CachedTypedWritableReferenceCount)) {
    return nullptr;
  }
  // 1-inline bool CachedTypedWritableReferenceCount::cache_unref(void) const
  bool return_value = ((*(const CachedTypedWritableReferenceCount*)local_this).cache_unref)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CachedTypedWritableReferenceCount_cache_unref_590_comment =
  "C++ Interface:\n"
  "cache_unref(CachedTypedWritableReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Explicitly decrements the cache reference count and the normal reference\n"
  " * count simultaneously.\n"
  " *\n"
  " * The return value is true if the new reference count is nonzero, false if it\n"
  " * is zero.\n"
  " */";
#else
static const char *Dtool_CachedTypedWritableReferenceCount_cache_unref_590_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CachedTypedWritableReferenceCount::test_ref_count_integrity(void) const
 */
static PyObject *Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_591(PyObject *self, PyObject *) {
  CachedTypedWritableReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CachedTypedWritableReferenceCount)) {
    return nullptr;
  }
  // 1-inline bool CachedTypedWritableReferenceCount::test_ref_count_integrity(void) const
  bool return_value = ((*(const CachedTypedWritableReferenceCount*)local_this).test_ref_count_integrity)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_591_comment =
  "C++ Interface:\n"
  "test_ref_count_integrity(CachedTypedWritableReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Does some easy checks to make sure that the reference count isn't\n"
  " * completely bogus.\n"
  " */";
#else
static const char *Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_591_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CachedTypedWritableReferenceCount::get_class_type(void)
 */
static PyObject *Dtool_CachedTypedWritableReferenceCount_get_class_type_593(PyObject *, PyObject *) {
  // 1-static TypeHandle CachedTypedWritableReferenceCount::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CachedTypedWritableReferenceCount::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CachedTypedWritableReferenceCount_get_class_type_593_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CachedTypedWritableReferenceCount_get_class_type_593_comment = nullptr;
#endif

static PyObject *Dtool_CachedTypedWritableReferenceCount_cache_ref_count_Getter(PyObject *self, void *) {
  const CachedTypedWritableReferenceCount *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CachedTypedWritableReferenceCount, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int CachedTypedWritableReferenceCount::get_cache_ref_count(void) const
  int return_value = ((*(const CachedTypedWritableReferenceCount*)local_this).get_cache_ref_count)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_CachedTypedWritableReferenceCount(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CachedTypedWritableReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CachedTypedWritableReferenceCount) {
    printf("CachedTypedWritableReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CachedTypedWritableReferenceCount *local_this = (CachedTypedWritableReferenceCount *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CachedTypedWritableReferenceCount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CachedTypedWritableReferenceCount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CachedTypedWritableReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CachedTypedWritableReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CachedTypedWritableReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CachedTypedWritableReferenceCount*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CallbackData
 */
/**
 * Python function wrapper for:
 * virtual void CallbackData::output(std::ostream &out) const
 */
static PyObject *Dtool_CallbackData_output_595(PyObject *self, PyObject *arg) {
  CallbackData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CallbackData)) {
    return nullptr;
  }
  // 1-virtual void CallbackData::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "CallbackData.output", false, true);
  if (arg_this != nullptr) {
    ((*(const CallbackData*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(CallbackData self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_CallbackData_output_595_comment =
  "C++ Interface:\n"
  "output(CallbackData self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_CallbackData_output_595_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void CallbackData::upcall(void)
 */
static PyObject *Dtool_CallbackData_upcall_596(PyObject *self, PyObject *) {
  CallbackData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_CallbackData, (void **)&local_this, "CallbackData.upcall")) {
    return nullptr;
  }
  // 1-virtual void CallbackData::upcall(void)
  ((*local_this).upcall)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CallbackData_upcall_596_comment =
  "C++ Interface:\n"
  "upcall(const CallbackData self)\n"
  "\n"
  "/**\n"
  " * You should make this call during the callback if you want to continue the\n"
  " * normal function that would have been done in the absence of a callback.\n"
  " */";
#else
static const char *Dtool_CallbackData_upcall_596_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CallbackData::get_class_type(void)
 */
static PyObject *Dtool_CallbackData_get_class_type_597(PyObject *, PyObject *) {
  // 1-static TypeHandle CallbackData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CallbackData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CallbackData_get_class_type_597_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CallbackData_get_class_type_597_comment = nullptr;
#endif

static int Dtool_Init_CallbackData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CallbackData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CallbackData) {
    printf("CallbackData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CallbackData *local_this = (CallbackData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CallbackData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CallbackData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CallbackData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CallbackData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PythonCallbackObject
 */
/**
 * Python function wrapper for:
 * void PythonCallbackObject::set_function(PyObject *function)
 */
static PyObject *Dtool_PythonCallbackObject_set_function_604(PyObject *self, PyObject *arg) {
  PythonCallbackObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonCallbackObject, (void **)&local_this, "PythonCallbackObject.set_function")) {
    return nullptr;
  }
  // 1-void PythonCallbackObject::set_function(PyObject *function)
  ((*local_this).set_function)(arg);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_function(const PythonCallbackObject self, object function)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PythonCallbackObject_set_function_604_comment =
  "C++ Interface:\n"
  "set_function(const PythonCallbackObject self, object function)\n"
  "\n"
  "/**\n"
  " * Replaces the function that is called for the callback.  runs.  The\n"
  " * parameter should be a Python callable object.\n"
  " */";
#else
static const char *Dtool_PythonCallbackObject_set_function_604_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PyObject *PythonCallbackObject::get_function(void)
 */
static PyObject *Dtool_PythonCallbackObject_get_function_605(PyObject *self, PyObject *) {
  PythonCallbackObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonCallbackObject, (void **)&local_this, "PythonCallbackObject.get_function")) {
    return nullptr;
  }
  // 1-PyObject *PythonCallbackObject::get_function(void)
  PyObject *return_value = ((*local_this).get_function)();
  return Dtool_Return(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PythonCallbackObject_get_function_605_comment =
  "C++ Interface:\n"
  "get_function(const PythonCallbackObject self)\n"
  "\n"
  "/**\n"
  " * Returns the function that is called for the callback.\n"
  " */";
#else
static const char *Dtool_PythonCallbackObject_get_function_605_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PythonCallbackObject::get_class_type(void)
 */
static PyObject *Dtool_PythonCallbackObject_get_class_type_607(PyObject *, PyObject *) {
  // 1-static TypeHandle PythonCallbackObject::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PythonCallbackObject::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PythonCallbackObject_get_class_type_607_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PythonCallbackObject_get_class_type_607_comment = nullptr;
#endif

static PyObject *Dtool_PythonCallbackObject_function_Getter(PyObject *self, void *) {
  PythonCallbackObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonCallbackObject, (void **)&local_this, "PythonCallbackObject.function")) {
    return nullptr;
  }

  // 1-PyObject *PythonCallbackObject::get_function(void)
  PyObject *return_value = ((*local_this).get_function)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_PythonCallbackObject_function_Setter(PyObject *self, PyObject *arg, void *) {
  PythonCallbackObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PythonCallbackObject, (void **)&local_this, "PythonCallbackObject.function")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete function attribute");
    return -1;
  }
  // 1-void PythonCallbackObject::set_function(PyObject *function)
  ((*local_this).set_function)(arg);
  if (Dtool_CheckErrorOccurred()) {
    return -1;
  }
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_function(const PythonCallbackObject self, object function)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * PythonCallbackObject::PythonCallbackObject(PyObject *function = (& ::_Py_NoneStruct))
 * inline PythonCallbackObject::PythonCallbackObject(PythonCallbackObject const &) = default
 */
static int Dtool_Init_PythonCallbackObject(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PythonCallbackObject::PythonCallbackObject(PyObject *function)
      PythonCallbackObject *return_value = new PythonCallbackObject();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PythonCallbackObject, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline PythonCallbackObject::PythonCallbackObject(PythonCallbackObject const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          PythonCallbackObject const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PythonCallbackObject);
          if (param0_this != nullptr) {
            PythonCallbackObject *return_value = new PythonCallbackObject(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PythonCallbackObject, true, false);
          }
        }
      }

      {
        // -2 PythonCallbackObject::PythonCallbackObject(PyObject *function)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "function")) {
          PythonCallbackObject *return_value = new PythonCallbackObject(param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          PyObject *exception = _PyErr_OCCURRED();
          if (exception == PyExc_TypeError) {
            // TypeError raised; continue to next overload type.
          } else if (exception != nullptr) {
            unref_delete(return_value);
            return -1;
          } else {
#ifndef NDEBUG
            Notify *notify = Notify::ptr();
            if (UNLIKELY(notify->has_assert_failed())) {
              unref_delete(return_value);
              Dtool_Raise_AssertionError();
              return -1;
            }
#endif
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PythonCallbackObject, true, false);
          }
        }
      }

      {
        // -2 inline PythonCallbackObject::PythonCallbackObject(PythonCallbackObject const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          CPT(PythonCallbackObject) param0_this;
          if (Dtool_ConstCoerce_PythonCallbackObject(param0, param0_this)) {
            PythonCallbackObject *return_value = new PythonCallbackObject(*std::move(param0_this));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PythonCallbackObject, true, false);
          }
        }
      }

      // No coercion possible: PythonCallbackObject::PythonCallbackObject(PyObject *function)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PythonCallbackObject() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PythonCallbackObject()\n"
      "PythonCallbackObject(const PythonCallbackObject param0)\n"
      "PythonCallbackObject(object function)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_PythonCallbackObject(PyObject *args, CPT(PythonCallbackObject) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PythonCallbackObject)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PythonCallbackObject::PythonCallbackObject(PyObject *function)
    PythonCallbackObject *return_value = new PythonCallbackObject(arg);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return false;
    }
    return_value->ref();
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != nullptr) {
      unref_delete(return_value);
      return false;
    } else {
      coerced = std::move(return_value);
      return true;
    }
  }
  return false;
}

bool Dtool_Coerce_PythonCallbackObject(PyObject *args, PT(PythonCallbackObject) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_PythonCallbackObject)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-PythonCallbackObject::PythonCallbackObject(PyObject *function)
    PythonCallbackObject *return_value = new PythonCallbackObject(arg);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return false;
    }
    return_value->ref();
    PyObject *exception = _PyErr_OCCURRED();
    if (exception == PyExc_TypeError) {
      // TypeError raised; continue to next overload type.
    } else if (exception != nullptr) {
      unref_delete(return_value);
      return false;
    } else {
      coerced = std::move(return_value);
      return true;
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_PythonCallbackObject(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PythonCallbackObject) {
    printf("PythonCallbackObject ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PythonCallbackObject *local_this = (PythonCallbackObject *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PythonCallbackObject) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CallbackObject) {
    return (CallbackObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CallbackObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CallbackObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CallbackObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PythonCallbackObject(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PythonCallbackObject) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CallbackObject) {
    CallbackObject* other_this = (CallbackObject*)from_this;
    return (PythonCallbackObject*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PythonCallbackObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PythonCallbackObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (PythonCallbackObject*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class TimeVal
 */
/**
 * Python function wrapper for:
 * inline ulong TimeVal::get_sec(void) const
 */
static PyObject *Dtool_TimeVal_get_sec_610(PyObject *self, PyObject *) {
  TimeVal *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TimeVal)) {
    return nullptr;
  }
  // 1-inline ulong TimeVal::get_sec(void) const
  ulong return_value = ((*(const TimeVal*)local_this).get_sec)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TimeVal_get_sec_610_comment =
  "C++ Interface:\n"
  "get_sec(TimeVal self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TimeVal_get_sec_610_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ulong TimeVal::get_usec(void) const
 */
static PyObject *Dtool_TimeVal_get_usec_611(PyObject *self, PyObject *) {
  TimeVal *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_TimeVal)) {
    return nullptr;
  }
  // 1-inline ulong TimeVal::get_usec(void) const
  ulong return_value = ((*(const TimeVal*)local_this).get_usec)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_TimeVal_get_usec_611_comment =
  "C++ Interface:\n"
  "get_usec(TimeVal self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_TimeVal_get_usec_611_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline TimeVal::TimeVal(void)
 * inline TimeVal::TimeVal(TimeVal const &) = default
 */
static int Dtool_Init_TimeVal(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("TimeVal() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline TimeVal::TimeVal(void)
      TimeVal *return_value = new TimeVal();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TimeVal, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline TimeVal::TimeVal(TimeVal const &) = default
      TimeVal const *arg_this = (TimeVal *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TimeVal, 0, "TimeVal.TimeVal", true, true);
      if (arg_this != nullptr) {
        TimeVal *return_value = new TimeVal(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_TimeVal, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "TimeVal() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "TimeVal()\n"
      "TimeVal(const TimeVal param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_TimeVal(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_TimeVal) {
    printf("TimeVal ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  TimeVal *local_this = (TimeVal *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_TimeVal) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_TimeVal(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_TimeVal) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ClockObject
 */
/**
 * Python function wrapper for:
 * void ClockObject::set_mode(ClockObject::Mode mode)
 */
static PyObject *Dtool_ClockObject_set_mode_622(PyObject *self, PyObject *arg) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_mode")) {
    return nullptr;
  }
  // 1-void ClockObject::set_mode(ClockObject::Mode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_mode)((ClockObject::Mode)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mode(const ClockObject self, int mode)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_mode_622_comment =
  "C++ Interface:\n"
  "set_mode(const ClockObject self, int mode)\n"
  "\n"
  "/**\n"
  " * Changes the mode of the clock.  Normally, the clock is in mode M_normal.\n"
  " * In this mode, each call to tick() will set the value returned by\n"
  " * get_frame_time() to the current real time; thus, the clock simply reports\n"
  " * time advancing.\n"
  " *\n"
  " * Other possible modes:\n"
  " *\n"
  " * M_non_real_time - the clock ignores real time completely; at each call to\n"
  " * tick(), it pretends that exactly dt seconds have elapsed since the last\n"
  " * call to tick().  You may set the value of dt with set_dt() or\n"
  " * set_frame_rate().\n"
  " *\n"
  " * M_limited - the clock will run as fast as it can, as in M_normal, but will\n"
  " * not run faster than the rate specified by set_frame_rate().  If the\n"
  " * application would run faster than this rate, the clock will slow down the\n"
  " * application.\n"
  " *\n"
  " * M_integer - the clock will run as fast as it can, but the rate will be\n"
  " * constrained to be an integer multiple or divisor of the rate specified by\n"
  " * set_frame_rate().  The clock will slow down the application a bit to\n"
  " * guarantee this.\n"
  " *\n"
  " * M_integer_limited - a combination of M_limited and M_integer; the clock\n"
  " * will not run faster than set_frame_rate(), and if it runs slower, it will\n"
  " * run at a integer divisor of that rate.\n"
  " *\n"
  " * M_forced - the clock forces the application to run at the rate specified by\n"
  " * set_frame_rate().  If the application would run faster than this rate, the\n"
  " * clock will slow down the application; if the application would run slower\n"
  " * than this rate, the clock slows down time so that the application believes\n"
  " * it is running at the given rate.\n"
  " *\n"
  " * M_degrade - the clock runs at real time, but the application is slowed down\n"
  " * by a set factor of its frame rate, specified by set_degrade_factor().\n"
  " *\n"
  " * M_slave - the clock does not advance, but relies on the user to call\n"
  " * set_frame_time() and/or set_frame_count() each frame.\n"
  " */";
#else
static const char *Dtool_ClockObject_set_mode_622_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ClockObject::Mode ClockObject::get_mode(void) const
 */
static PyObject *Dtool_ClockObject_get_mode_623(PyObject *self, PyObject *) {
  ClockObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClockObject)) {
    return nullptr;
  }
  // 1-inline ClockObject::Mode ClockObject::get_mode(void) const
  ClockObject::Mode return_value = ((*(const ClockObject*)local_this).get_mode)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_mode_623_comment =
  "C++ Interface:\n"
  "get_mode(ClockObject self)\n"
  "\n"
  "/**\n"
  " * Returns the current mode of the clock.  See set_mode().\n"
  " */";
#else
static const char *Dtool_ClockObject_get_mode_623_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double ClockObject::get_frame_time(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_ClockObject_get_frame_time_625(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClockObject)) {
    return nullptr;
  }
  // 1-inline double ClockObject::get_frame_time(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "ClockObject.get_frame_time", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      double return_value = ((*(const ClockObject*)local_this).get_frame_time)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_frame_time(ClockObject self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_frame_time_625_comment =
  "C++ Interface:\n"
  "get_frame_time(ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the time in seconds as of the last time tick() was called\n"
  " * (typically, this will be as of the start of the current frame).\n"
  " *\n"
  " * This is generally the kind of time you want to ask for in most rendering\n"
  " * and animation contexts, since it's important that all of the animation for\n"
  " * a given frame remains in sync with each other.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_frame_time_625_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double ClockObject::get_real_time(void) const
 */
static PyObject *Dtool_ClockObject_get_real_time_626(PyObject *self, PyObject *) {
  ClockObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClockObject)) {
    return nullptr;
  }
  // 1-inline double ClockObject::get_real_time(void) const
  double return_value = ((*(const ClockObject*)local_this).get_real_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_real_time_626_comment =
  "C++ Interface:\n"
  "get_real_time(ClockObject self)\n"
  "\n"
  "/**\n"
  " * Returns the actual number of seconds elapsed since the ClockObject was\n"
  " * created, or since it was last reset.  This is useful for doing real timing\n"
  " * measurements, e.g.  for performance statistics.\n"
  " *\n"
  " * This returns the most precise timer we have for short time intervals, but\n"
  " * it may tend to drift over the long haul.  If more accurate timekeeping is\n"
  " * needed over a long period of time, use get_long_time() instead.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_real_time_626_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double ClockObject::get_long_time(void) const
 */
static PyObject *Dtool_ClockObject_get_long_time_627(PyObject *self, PyObject *) {
  ClockObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClockObject)) {
    return nullptr;
  }
  // 1-inline double ClockObject::get_long_time(void) const
  double return_value = ((*(const ClockObject*)local_this).get_long_time)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_long_time_627_comment =
  "C++ Interface:\n"
  "get_long_time(ClockObject self)\n"
  "\n"
  "/**\n"
  " * Returns the actual number of seconds elapsed since the ClockObject was\n"
  " * created, or since it was last reset.\n"
  " *\n"
  " * This is similar to get_real_time(), except that it uses the most accurate\n"
  " * counter we have over a long period of time, and so it is less likely to\n"
  " * drift.  However, it may not be very precise for measuring short intervals.\n"
  " * On Windows, for instace, this is only accurate to within about 55\n"
  " * milliseconds.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_long_time_627_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ClockObject::reset(void)
 */
static PyObject *Dtool_ClockObject_reset_628(PyObject *self, PyObject *) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.reset")) {
    return nullptr;
  }
  // 1-inline void ClockObject::reset(void)
  ((*local_this).reset)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_reset_628_comment =
  "C++ Interface:\n"
  "reset(const ClockObject self)\n"
  "\n"
  "/**\n"
  " * Simultaneously resets both the time and the frame count to zero.\n"
  " */";
#else
static const char *Dtool_ClockObject_reset_628_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ClockObject::set_real_time(double time)
 */
static PyObject *Dtool_ClockObject_set_real_time_629(PyObject *self, PyObject *arg) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_real_time")) {
    return nullptr;
  }
  // 1-void ClockObject::set_real_time(double time)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_real_time)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_real_time(const ClockObject self, double time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_real_time_629_comment =
  "C++ Interface:\n"
  "set_real_time(const ClockObject self, double time)\n"
  "\n"
  "/**\n"
  " * Resets the clock to the indicated time.  This changes only the real time of\n"
  " * the clock as reported by get_real_time(), but does not immediately change\n"
  " * the time reported by get_frame_time()--that will change after the next call\n"
  " * to tick().  Also see reset(), set_frame_time(), and set_frame_count().\n"
  " */";
#else
static const char *Dtool_ClockObject_set_real_time_629_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ClockObject::set_frame_time(double time, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_ClockObject_set_frame_time_630(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_frame_time")) {
    return nullptr;
  }
  // 1-void ClockObject::set_frame_time(double time, Thread *current_thread = Thread::get_current_thread())
  double param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"time", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "d|O:set_frame_time", (char **)keyword_list, &param1, &param2)) {
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "ClockObject.set_frame_time", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      ((*local_this).set_frame_time)((double)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_time(const ClockObject self, double time, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_frame_time_630_comment =
  "C++ Interface:\n"
  "set_frame_time(const ClockObject self, double time, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Changes the time as reported for the current frame to the indicated time.\n"
  " * Normally, the way to adjust the frame time is via tick(); this function is\n"
  " * provided only for occasional special adjustments.\n"
  " */";
#else
static const char *Dtool_ClockObject_set_frame_time_630_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ClockObject::set_frame_count(int frame_count, Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_ClockObject_set_frame_count_631(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_frame_count")) {
    return nullptr;
  }
  // 1-void ClockObject::set_frame_count(int frame_count, Thread *current_thread = Thread::get_current_thread())
  int param1;
  PyObject *param2 = nullptr;
  static const char *keyword_list[] = {"frame_count", "current_thread", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:set_frame_count", (char **)keyword_list, &param1, &param2)) {
    Thread *param2_this;
    if (param2 == nullptr) {
      param2_this = Thread::get_current_thread();
    } else {
      param2_this = (Thread *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Thread, 2, "ClockObject.set_frame_count", false, true);
    }
    if ((param2 == nullptr || param2_this != nullptr)) {
      ((*local_this).set_frame_count)((int)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_count(const ClockObject self, int frame_count, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_frame_count_631_comment =
  "C++ Interface:\n"
  "set_frame_count(const ClockObject self, int frame_count, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Resets the number of frames counted to the indicated number.  Also see\n"
  " * reset(), set_real_time(), and set_frame_time().\n"
  " */";
#else
static const char *Dtool_ClockObject_set_frame_count_631_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ClockObject::get_frame_count(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_ClockObject_get_frame_count_632(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClockObject)) {
    return nullptr;
  }
  // 1-inline int ClockObject::get_frame_count(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "ClockObject.get_frame_count", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      int return_value = ((*(const ClockObject*)local_this).get_frame_count)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_frame_count(ClockObject self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_frame_count_632_comment =
  "C++ Interface:\n"
  "get_frame_count(ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the number of times tick() has been called since the ClockObject\n"
  " * was created, or since it was last reset.  This is generally the number of\n"
  " * frames that have been rendered.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_frame_count_632_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double ClockObject::get_net_frame_rate(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_ClockObject_get_net_frame_rate_633(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClockObject)) {
    return nullptr;
  }
  // 1-inline double ClockObject::get_net_frame_rate(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "ClockObject.get_net_frame_rate", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      double return_value = ((*(const ClockObject*)local_this).get_net_frame_rate)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_net_frame_rate(ClockObject self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_net_frame_rate_633_comment =
  "C++ Interface:\n"
  "get_net_frame_rate(ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the average frame rate since the last reset.  This is simply the\n"
  " * total number of frames divided by the total elapsed time.  This reports the\n"
  " * virtual frame rate if the clock is in (or has been in) M_non_real_time\n"
  " * mode.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_net_frame_rate_633_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double ClockObject::get_dt(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_ClockObject_get_dt_638(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClockObject)) {
    return nullptr;
  }
  // 1-inline double ClockObject::get_dt(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "ClockObject.get_dt", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      double return_value = ((*(const ClockObject*)local_this).get_dt)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_dt(ClockObject self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_dt_638_comment =
  "C++ Interface:\n"
  "get_dt(ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the elapsed time for the previous frame: the number of seconds\n"
  " * elapsed between the last two calls to tick().\n"
  " */";
#else
static const char *Dtool_ClockObject_get_dt_638_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ClockObject::set_dt(double dt)
 */
static PyObject *Dtool_ClockObject_set_dt_639(PyObject *self, PyObject *arg) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_dt")) {
    return nullptr;
  }
  // 1-void ClockObject::set_dt(double dt)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_dt)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dt(const ClockObject self, double dt)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_dt_639_comment =
  "C++ Interface:\n"
  "set_dt(const ClockObject self, double dt)\n"
  "\n"
  "/**\n"
  " * In non-real-time mode, sets the number of seconds that should appear to\n"
  " * elapse between frames.  In forced mode or limited mode, sets our target dt.\n"
  " * In normal mode, this has no effect.\n"
  " *\n"
  " * Also see set_frame_rate(), which is a different way to specify the same\n"
  " * quantity.\n"
  " */";
#else
static const char *Dtool_ClockObject_set_dt_639_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ClockObject::set_frame_rate(double frame_rate)
 */
static PyObject *Dtool_ClockObject_set_frame_rate_640(PyObject *self, PyObject *arg) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_frame_rate")) {
    return nullptr;
  }
  // 1-void ClockObject::set_frame_rate(double frame_rate)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_frame_rate)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_frame_rate(const ClockObject self, double frame_rate)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_frame_rate_640_comment =
  "C++ Interface:\n"
  "set_frame_rate(const ClockObject self, double frame_rate)\n"
  "\n"
  "/**\n"
  " * In non-real-time mode, sets the number of frames per second that we should\n"
  " * appear to be running.  In forced mode or limited mode, sets our target\n"
  " * frame rate.  In normal mode, this has no effect.\n"
  " *\n"
  " * Also see set_dt(), which is a different way to specify the same quantity.\n"
  " */";
#else
static const char *Dtool_ClockObject_set_frame_rate_640_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double ClockObject::get_max_dt(void) const
 */
static PyObject *Dtool_ClockObject_get_max_dt_642(PyObject *self, PyObject *) {
  ClockObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClockObject)) {
    return nullptr;
  }
  // 1-inline double ClockObject::get_max_dt(void) const
  double return_value = ((*(const ClockObject*)local_this).get_max_dt)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_max_dt_642_comment =
  "C++ Interface:\n"
  "get_max_dt(ClockObject self)\n"
  "\n"
  "/**\n"
  " * Returns the current maximum allowable time elapsed between any two frames.\n"
  " * See set_max_dt().\n"
  " */";
#else
static const char *Dtool_ClockObject_get_max_dt_642_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ClockObject::set_max_dt(double max_dt)
 */
static PyObject *Dtool_ClockObject_set_max_dt_643(PyObject *self, PyObject *arg) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_max_dt")) {
    return nullptr;
  }
  // 1-inline void ClockObject::set_max_dt(double max_dt)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_dt)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_max_dt(const ClockObject self, double max_dt)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_max_dt_643_comment =
  "C++ Interface:\n"
  "set_max_dt(const ClockObject self, double max_dt)\n"
  "\n"
  "/**\n"
  " * Sets a limit on the value returned by get_dt().  If this value is less than\n"
  " * zero, no limit is imposed; otherwise, this is the maximum value that will\n"
  " * ever be returned by get_dt(), regardless of how much time has actually\n"
  " * elapsed between frames.\n"
  " *\n"
  " * This limit is only imposed in real-time mode; in non-real-time mode, the dt\n"
  " * is fixed anyway and max_dt is ignored.\n"
  " *\n"
  " * This is generally used to guarantee reasonable behavior even in the\n"
  " * presence of a very slow or chuggy frame rame.\n"
  " */";
#else
static const char *Dtool_ClockObject_set_max_dt_643_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double ClockObject::get_degrade_factor(void) const
 */
static PyObject *Dtool_ClockObject_get_degrade_factor_645(PyObject *self, PyObject *) {
  ClockObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClockObject)) {
    return nullptr;
  }
  // 1-inline double ClockObject::get_degrade_factor(void) const
  double return_value = ((*(const ClockObject*)local_this).get_degrade_factor)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_degrade_factor_645_comment =
  "C++ Interface:\n"
  "get_degrade_factor(ClockObject self)\n"
  "\n"
  "/**\n"
  " * In degrade mode, returns the ratio by which the performance is degraded.  A\n"
  " * value of 2.0 causes the clock to be slowed down by a factor of two\n"
  " * (reducing performance to 1/2 what would be otherwise).\n"
  " *\n"
  " * This has no effect if mode is not M_degrade.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_degrade_factor_645_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ClockObject::set_degrade_factor(double degrade_factor)
 */
static PyObject *Dtool_ClockObject_set_degrade_factor_646(PyObject *self, PyObject *arg) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_degrade_factor")) {
    return nullptr;
  }
  // 1-inline void ClockObject::set_degrade_factor(double degrade_factor)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_degrade_factor)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_degrade_factor(const ClockObject self, double degrade_factor)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_degrade_factor_646_comment =
  "C++ Interface:\n"
  "set_degrade_factor(const ClockObject self, double degrade_factor)\n"
  "\n"
  "/**\n"
  " * In degrade mode, sets the ratio by which the performance is degraded.  A\n"
  " * value of 2.0 causes the clock to be slowed down by a factor of two\n"
  " * (reducing performance to 1/2 what would be otherwise).\n"
  " *\n"
  " * This has no effect if mode is not M_degrade.\n"
  " */";
#else
static const char *Dtool_ClockObject_set_degrade_factor_646_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ClockObject::set_average_frame_rate_interval(double time)
 */
static PyObject *Dtool_ClockObject_set_average_frame_rate_interval_648(PyObject *self, PyObject *arg) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.set_average_frame_rate_interval")) {
    return nullptr;
  }
  // 1-inline void ClockObject::set_average_frame_rate_interval(double time)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_average_frame_rate_interval)(PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_average_frame_rate_interval(const ClockObject self, double time)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_set_average_frame_rate_interval_648_comment =
  "C++ Interface:\n"
  "set_average_frame_rate_interval(const ClockObject self, double time)\n"
  "\n"
  "/**\n"
  " * Specifies the interval of time (in seconds) over which\n"
  " * get_average_frame_rate() averages the number of frames per second to\n"
  " * compute the frame rate.  Changing this does not necessarily immediately\n"
  " * change the result of get_average_frame_rate(), until this interval of time\n"
  " * has elapsed again.\n"
  " *\n"
  " * Setting this to zero disables the computation of get_average_frame_rate().\n"
  " */";
#else
static const char *Dtool_ClockObject_set_average_frame_rate_interval_648_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double ClockObject::get_average_frame_rate_interval(void) const
 */
static PyObject *Dtool_ClockObject_get_average_frame_rate_interval_649(PyObject *self, PyObject *) {
  ClockObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClockObject)) {
    return nullptr;
  }
  // 1-inline double ClockObject::get_average_frame_rate_interval(void) const
  double return_value = ((*(const ClockObject*)local_this).get_average_frame_rate_interval)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_average_frame_rate_interval_649_comment =
  "C++ Interface:\n"
  "get_average_frame_rate_interval(ClockObject self)\n"
  "\n"
  "/**\n"
  " * Returns the interval of time (in seconds) over which\n"
  " * get_average_frame_rate() averages the number of frames per second to\n"
  " * compute the frame rate.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_average_frame_rate_interval_649_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double ClockObject::get_average_frame_rate(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_ClockObject_get_average_frame_rate_651(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClockObject)) {
    return nullptr;
  }
  // 1-double ClockObject::get_average_frame_rate(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "ClockObject.get_average_frame_rate", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      double return_value = ((*(const ClockObject*)local_this).get_average_frame_rate)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_average_frame_rate(ClockObject self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_average_frame_rate_651_comment =
  "C++ Interface:\n"
  "get_average_frame_rate(ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the average frame rate in number of frames per second over the last\n"
  " * get_average_frame_rate_interval() seconds.  This measures the virtual frame\n"
  " * rate if the clock is in M_non_real_time mode.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_average_frame_rate_651_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double ClockObject::get_max_frame_duration(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_ClockObject_get_max_frame_duration_652(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClockObject)) {
    return nullptr;
  }
  // 1-double ClockObject::get_max_frame_duration(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "ClockObject.get_max_frame_duration", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      double return_value = ((*(const ClockObject*)local_this).get_max_frame_duration)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_max_frame_duration(ClockObject self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_max_frame_duration_652_comment =
  "C++ Interface:\n"
  "get_max_frame_duration(ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the maximum frame duration over the last\n"
  " * get_average_frame_rate_interval() seconds.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_max_frame_duration_652_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * double ClockObject::calc_frame_rate_deviation(Thread *current_thread = Thread::get_current_thread()) const
 */
static PyObject *Dtool_ClockObject_calc_frame_rate_deviation_653(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ClockObject)) {
    return nullptr;
  }
  // 1-double ClockObject::calc_frame_rate_deviation(Thread *current_thread = Thread::get_current_thread()) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "ClockObject.calc_frame_rate_deviation", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      double return_value = ((*(const ClockObject*)local_this).calc_frame_rate_deviation)(param1_this);
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      return Dtool_WrapValue(return_value);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "calc_frame_rate_deviation(ClockObject self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_calc_frame_rate_deviation_653_comment =
  "C++ Interface:\n"
  "calc_frame_rate_deviation(ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns the standard deviation of the frame times of the frames rendered\n"
  " * over the past get_average_frame_rate_interval() seconds.  This number gives\n"
  " * an estimate of the chugginess of the frame rate; if it is large, there is a\n"
  " * large variation in the frame rate; if is small, all of the frames are\n"
  " * consistent in length.\n"
  " *\n"
  " * A large value might also represent just a recent change in frame rate, for\n"
  " * instance, because the camera has just rotated from looking at a simple\n"
  " * scene to looking at a more complex scene.\n"
  " */";
#else
static const char *Dtool_ClockObject_calc_frame_rate_deviation_653_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ClockObject::tick(Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_ClockObject_tick_656(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.tick")) {
    return nullptr;
  }
  // 1-void ClockObject::tick(Thread *current_thread = Thread::get_current_thread())
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "ClockObject.tick", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*local_this).tick)(param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "tick(const ClockObject self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_tick_656_comment =
  "C++ Interface:\n"
  "tick(const ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Instructs the clock that a new frame has just begun.  In normal, real-time\n"
  " * mode, get_frame_time() will henceforth report the time as of this instant\n"
  " * as the current start-of-frame time.  In non-real-time mode,\n"
  " * get_frame_time() will be incremented by the value of dt.\n"
  " */";
#else
static const char *Dtool_ClockObject_tick_656_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ClockObject::sync_frame_time(Thread *current_thread = Thread::get_current_thread())
 */
static PyObject *Dtool_ClockObject_sync_frame_time_657(PyObject *self, PyObject *args, PyObject *kwds) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.sync_frame_time")) {
    return nullptr;
  }
  // 1-void ClockObject::sync_frame_time(Thread *current_thread = Thread::get_current_thread())
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "current_thread")) {
    Thread *param1_this;
    if (param1 == nullptr) {
      param1_this = Thread::get_current_thread();
    } else {
      param1_this = (Thread *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Thread, 1, "ClockObject.sync_frame_time", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*local_this).sync_frame_time)(param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "sync_frame_time(const ClockObject self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_sync_frame_time_657_comment =
  "C++ Interface:\n"
  "sync_frame_time(const ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Resets the frame time to the current real time.  This is similar to tick(),\n"
  " * except that it does not advance the frame counter and does not affect dt.\n"
  " * This is intended to be used in the middle of a particularly long frame to\n"
  " * compensate for the time that has already elapsed.\n"
  " *\n"
  " * In non-real-time mode, this function has no effect (because in this mode\n"
  " * all frames take the same length of time).\n"
  " */";
#else
static const char *Dtool_ClockObject_sync_frame_time_657_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ClockObject::check_errors(Thread *current_thread)
 */
static PyObject *Dtool_ClockObject_check_errors_658(PyObject *self, PyObject *arg) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.check_errors")) {
    return nullptr;
  }
  // 1-inline bool ClockObject::check_errors(Thread *current_thread)
  Thread *arg_this = (Thread *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Thread, 1, "ClockObject.check_errors", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).check_errors)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "check_errors(const ClockObject self, Thread current_thread)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_check_errors_658_comment =
  "C++ Interface:\n"
  "check_errors(const ClockObject self, Thread current_thread)\n"
  "\n"
  "/**\n"
  " * Returns true if a clock error was detected since the last time\n"
  " * check_errors() was called.  A clock error means that something happened, an\n"
  " * OS or BIOS bug, for instance, that makes the current value of the clock\n"
  " * somewhat suspect, and an application may wish to resynchronize with any\n"
  " * external clocks.\n"
  " */";
#else
static const char *Dtool_ClockObject_check_errors_658_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline ClockObject *ClockObject::get_global_clock(void)
 */
static PyObject *Dtool_ClockObject_get_global_clock_659(PyObject *, PyObject *) {
  // 1-static inline ClockObject *ClockObject::get_global_clock(void)
  ClockObject *return_value = (ClockObject::get_global_clock)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ClockObject, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_global_clock_659_comment =
  "C++ Interface:\n"
  "get_global_clock()\n"
  "\n"
  "/**\n"
  " * Returns a pointer to the global ClockObject.  This is the ClockObject that\n"
  " * most code should use for handling scene graph rendering and animation.\n"
  " */";
#else
static const char *Dtool_ClockObject_get_global_clock_659_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ClockObject::get_class_type(void)
 */
static PyObject *Dtool_ClockObject_get_class_type_660(PyObject *, PyObject *) {
  // 1-static TypeHandle ClockObject::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ClockObject::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ClockObject_get_class_type_660_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ClockObject_get_class_type_660_comment = nullptr;
#endif

static PyObject *Dtool_ClockObject_mode_Getter(PyObject *self, void *) {
  const ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline ClockObject::Mode ClockObject::get_mode(void) const
  ClockObject::Mode return_value = ((*(const ClockObject*)local_this).get_mode)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ClockObject_mode_Setter(PyObject *self, PyObject *arg, void *) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.mode")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete mode attribute");
    return -1;
  }
  // 1-void ClockObject::set_mode(ClockObject::Mode mode)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_mode)((ClockObject::Mode)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_mode(const ClockObject self, int mode)\n");
  }
  return -1;
}

static PyObject *Dtool_ClockObject_frame_time_Getter(PyObject *self, void *) {
  const ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double ClockObject::get_frame_time(Thread *current_thread) const
  double return_value = ((*(const ClockObject*)local_this).get_frame_time)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ClockObject_frame_time_Setter(PyObject *self, PyObject *arg, void *) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.frame_time")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete frame_time attribute");
    return -1;
  }
  // 1-void ClockObject::set_frame_time(double time, Thread *current_thread)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_frame_time)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_frame_time(const ClockObject self, double time)\n");
  }
  return -1;
}

static PyObject *Dtool_ClockObject_real_time_Getter(PyObject *self, void *) {
  const ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double ClockObject::get_real_time(void) const
  double return_value = ((*(const ClockObject*)local_this).get_real_time)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ClockObject_real_time_Setter(PyObject *self, PyObject *arg, void *) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.real_time")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete real_time attribute");
    return -1;
  }
  // 1-void ClockObject::set_real_time(double time)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_real_time)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_real_time(const ClockObject self, double time)\n");
  }
  return -1;
}

static PyObject *Dtool_ClockObject_long_time_Getter(PyObject *self, void *) {
  const ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double ClockObject::get_long_time(void) const
  double return_value = ((*(const ClockObject*)local_this).get_long_time)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ClockObject_frame_count_Getter(PyObject *self, void *) {
  const ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int ClockObject::get_frame_count(Thread *current_thread) const
  int return_value = ((*(const ClockObject*)local_this).get_frame_count)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ClockObject_frame_count_Setter(PyObject *self, PyObject *arg, void *) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.frame_count")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete frame_count attribute");
    return -1;
  }
  // 1-void ClockObject::set_frame_count(int frame_count, Thread *current_thread)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return -1;
    }
#endif
    ((*local_this).set_frame_count)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_frame_count(const ClockObject self, int frame_count)\n");
  }
  return -1;
}

static PyObject *Dtool_ClockObject_dt_Getter(PyObject *self, void *) {
  const ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double ClockObject::get_dt(Thread *current_thread) const
  double return_value = ((*(const ClockObject*)local_this).get_dt)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ClockObject_dt_Setter(PyObject *self, PyObject *arg, void *) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.dt")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete dt attribute");
    return -1;
  }
  // 1-void ClockObject::set_dt(double dt)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_dt)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_dt(const ClockObject self, double dt)\n");
  }
  return -1;
}

static PyObject *Dtool_ClockObject_max_dt_Getter(PyObject *self, void *) {
  const ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double ClockObject::get_max_dt(void) const
  double return_value = ((*(const ClockObject*)local_this).get_max_dt)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ClockObject_max_dt_Setter(PyObject *self, PyObject *arg, void *) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.max_dt")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete max_dt attribute");
    return -1;
  }
  // 1-inline void ClockObject::set_max_dt(double max_dt)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_max_dt)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_max_dt(const ClockObject self, double max_dt)\n");
  }
  return -1;
}

static PyObject *Dtool_ClockObject_degrade_factor_Getter(PyObject *self, void *) {
  const ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double ClockObject::get_degrade_factor(void) const
  double return_value = ((*(const ClockObject*)local_this).get_degrade_factor)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ClockObject_degrade_factor_Setter(PyObject *self, PyObject *arg, void *) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.degrade_factor")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete degrade_factor attribute");
    return -1;
  }
  // 1-inline void ClockObject::set_degrade_factor(double degrade_factor)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_degrade_factor)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_degrade_factor(const ClockObject self, double degrade_factor)\n");
  }
  return -1;
}

static PyObject *Dtool_ClockObject_average_frame_rate_interval_Getter(PyObject *self, void *) {
  const ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double ClockObject::get_average_frame_rate_interval(void) const
  double return_value = ((*(const ClockObject*)local_this).get_average_frame_rate_interval)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ClockObject_average_frame_rate_interval_Setter(PyObject *self, PyObject *arg, void *) {
  ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ClockObject, (void **)&local_this, "ClockObject.average_frame_rate_interval")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete average_frame_rate_interval attribute");
    return -1;
  }
  // 1-inline void ClockObject::set_average_frame_rate_interval(double time)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_average_frame_rate_interval)(PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_average_frame_rate_interval(const ClockObject self, double time)\n");
  }
  return -1;
}

static PyObject *Dtool_ClockObject_average_frame_rate_Getter(PyObject *self, void *) {
  const ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return nullptr;
  }

  // 1-double ClockObject::get_average_frame_rate(Thread *current_thread) const
  double return_value = ((*(const ClockObject*)local_this).get_average_frame_rate)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_ClockObject_max_frame_duration_Getter(PyObject *self, void *) {
  const ClockObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ClockObject, (void **)&local_this)) {
    return nullptr;
  }

  // 1-double ClockObject::get_max_frame_duration(Thread *current_thread) const
  double return_value = ((*(const ClockObject*)local_this).get_max_frame_duration)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * ClockObject::ClockObject(ClockObject const &copy)
 * ClockObject::ClockObject(ClockObject::Mode mode = ::ClockObject::M_normal)
 */
static int Dtool_Init_ClockObject(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-ClockObject::ClockObject(ClockObject::Mode mode)
      ClockObject *return_value = new ClockObject();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ClockObject, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 ClockObject::ClockObject(ClockObject const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          ClockObject const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_ClockObject);
          if (param0_this != nullptr) {
            ClockObject *return_value = new ClockObject(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ClockObject, true, false);
          }
        }
      }

      {
        // -2 ClockObject::ClockObject(ClockObject::Mode mode)
        int param0;
        static const char *keyword_list[] = {"mode", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i:ClockObject", (char **)keyword_list, &param0)) {
          ClockObject *return_value = new ClockObject((ClockObject::Mode)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ClockObject, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 ClockObject::ClockObject(ClockObject const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          CPT(ClockObject) param0_this;
          if (Dtool_ConstCoerce_ClockObject(param0, param0_this)) {
            ClockObject *return_value = new ClockObject(*std::move(param0_this));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ClockObject, true, false);
          }
        }
      }

      // No coercion possible: ClockObject::ClockObject(ClockObject::Mode mode)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ClockObject() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ClockObject()\n"
      "ClockObject(const ClockObject copy)\n"
      "ClockObject(int mode)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ClockObject(PyObject *args, CPT(ClockObject) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ClockObject)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ClockObject::ClockObject(ClockObject::Mode mode)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      ClockObject *return_value = new ClockObject((ClockObject::Mode)arg_val);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ClockObject(PyObject *args, PT(ClockObject) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ClockObject)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-ClockObject::ClockObject(ClockObject::Mode mode)
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        PyErr_Format(PyExc_OverflowError,
                     "value %ld out of range for signed integer",
                     arg_val);
        return false;
      }
#endif
      ClockObject *return_value = new ClockObject((ClockObject::Mode)arg_val);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ClockObject(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ClockObject) {
    printf("ClockObject ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ClockObject *local_this = (ClockObject *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ClockObject) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ClockObject(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ClockObject) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ClockObject*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class CopyOnWriteObject
 */
/**
 * Python function wrapper for:
 * inline void CopyOnWriteObject::cache_ref(void) const
 */
static PyObject *Dtool_CopyOnWriteObject_cache_ref_668(PyObject *self, PyObject *) {
  CopyOnWriteObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CopyOnWriteObject)) {
    return nullptr;
  }
  // 1-inline void CopyOnWriteObject::cache_ref(void) const
  ((*(const CopyOnWriteObject*)local_this).cache_ref)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_CopyOnWriteObject_cache_ref_668_comment =
  "C++ Interface:\n"
  "cache_ref(CopyOnWriteObject self)\n"
  "\n"
  "/**\n"
  " * @see CachedTypedWritableReferenceCount::cache_ref()\n"
  " */";
#else
static const char *Dtool_CopyOnWriteObject_cache_ref_668_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool CopyOnWriteObject::cache_unref(void) const
 */
static PyObject *Dtool_CopyOnWriteObject_cache_unref_669(PyObject *self, PyObject *) {
  CopyOnWriteObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_CopyOnWriteObject)) {
    return nullptr;
  }
  // 1-inline bool CopyOnWriteObject::cache_unref(void) const
  bool return_value = ((*(const CopyOnWriteObject*)local_this).cache_unref)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_CopyOnWriteObject_cache_unref_669_comment =
  "C++ Interface:\n"
  "cache_unref(CopyOnWriteObject self)\n"
  "\n"
  "/**\n"
  " * @see CachedTypedWritableReferenceCount::cache_unref()\n"
  " */";
#else
static const char *Dtool_CopyOnWriteObject_cache_unref_669_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle CopyOnWriteObject::get_class_type(void)
 */
static PyObject *Dtool_CopyOnWriteObject_get_class_type_670(PyObject *, PyObject *) {
  // 1-static TypeHandle CopyOnWriteObject::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((CopyOnWriteObject::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_CopyOnWriteObject_get_class_type_670_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_CopyOnWriteObject_get_class_type_670_comment = nullptr;
#endif

static int Dtool_Init_CopyOnWriteObject(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_CopyOnWriteObject(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_CopyOnWriteObject) {
    printf("CopyOnWriteObject ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  CopyOnWriteObject *local_this = (CopyOnWriteObject *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_CopyOnWriteObject) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_CopyOnWriteObject(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_CopyOnWriteObject) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (CopyOnWriteObject*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (CopyOnWriteObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (CopyOnWriteObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (CopyOnWriteObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (CopyOnWriteObject*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DatagramBuffer
 */
/**
 * Python function wrapper for:
 * inline void DatagramBuffer::clear(void)
 */
static PyObject *Dtool_DatagramBuffer_clear_678(PyObject *self, PyObject *) {
  DatagramBuffer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramBuffer, (void **)&local_this, "DatagramBuffer.clear")) {
    return nullptr;
  }
  // 1-inline void DatagramBuffer::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DatagramBuffer_clear_678_comment =
  "C++ Interface:\n"
  "clear(const DatagramBuffer self)\n"
  "\n"
  "/**\n"
  " * Clears the internal buffer.\n"
  " */";
#else
static const char *Dtool_DatagramBuffer_clear_678_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DatagramSink *DatagramBuffer::upcast_to_DatagramSink(void)
 */
static PyObject *Dtool_DatagramBuffer_upcast_to_DatagramSink_673(PyObject *self, PyObject *) {
  DatagramBuffer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramBuffer, (void **)&local_this, "DatagramBuffer.upcast_to_DatagramSink")) {
    return nullptr;
  }
  // 1-DatagramSink *DatagramBuffer::upcast_to_DatagramSink(void)
  DatagramSink *return_value = (DatagramSink *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramSink, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramBuffer_upcast_to_DatagramSink_673_comment =
  "C++ Interface:\n"
  "upcast_to_DatagramSink(const DatagramBuffer self)\n"
  "\n"
  "upcast from DatagramBuffer to DatagramSink";
#else
static const char *Dtool_DatagramBuffer_upcast_to_DatagramSink_673_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * DatagramGenerator *DatagramBuffer::upcast_to_DatagramGenerator(void)
 */
static PyObject *Dtool_DatagramBuffer_upcast_to_DatagramGenerator_675(PyObject *self, PyObject *) {
  DatagramBuffer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramBuffer, (void **)&local_this, "DatagramBuffer.upcast_to_DatagramGenerator")) {
    return nullptr;
  }
  // 1-DatagramGenerator *DatagramBuffer::upcast_to_DatagramGenerator(void)
  DatagramGenerator *return_value = (DatagramGenerator *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DatagramGenerator, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramBuffer_upcast_to_DatagramGenerator_675_comment =
  "C++ Interface:\n"
  "upcast_to_DatagramGenerator(const DatagramBuffer self)\n"
  "\n"
  "upcast from DatagramBuffer to DatagramGenerator";
#else
static const char *Dtool_DatagramBuffer_upcast_to_DatagramGenerator_675_comment = nullptr;
#endif

static PyObject *Dtool_DatagramBuffer_data_Getter(PyObject *self, void *) {
  const DatagramBuffer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DatagramBuffer, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline vector_uchar const &DatagramBuffer::get_data(void) const
  vector_uchar return_value = ((*(const DatagramBuffer*)local_this).get_data)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_DatagramBuffer_data_Setter(PyObject *self, PyObject *arg, void *) {
  DatagramBuffer *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramBuffer, (void **)&local_this, "DatagramBuffer.data")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete data attribute");
    return -1;
  }
  // 1-inline void DatagramBuffer::set_data(vector_uchar data)
  unsigned char *param1_str = nullptr;
  Py_ssize_t param1_len;
  if (PyBytes_AsStringAndSize(arg, (char **)&param1_str, &param1_len) >= 0) {
    ((*local_this).set_data)(vector_uchar(param1_str, param1_str + param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_data(const DatagramBuffer self, bytes data)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline DatagramBuffer::DatagramBuffer(void)
 * inline explicit DatagramBuffer::DatagramBuffer(vector_uchar data)
 */
static int Dtool_Init_DatagramBuffer(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline DatagramBuffer::DatagramBuffer(void)
      DatagramBuffer *return_value = new DatagramBuffer();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramBuffer, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "data")) {
        // 1-inline explicit DatagramBuffer::DatagramBuffer(vector_uchar data)
        unsigned char *param0_str = nullptr;
        Py_ssize_t param0_len;
        if (PyBytes_AsStringAndSize(arg, (char **)&param0_str, &param0_len) >= 0) {
          DatagramBuffer *return_value = new DatagramBuffer(vector_uchar(param0_str, param0_str + param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramBuffer, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DatagramBuffer() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DatagramBuffer()\n"
      "DatagramBuffer(bytes data)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DatagramBuffer(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DatagramBuffer) {
    printf("DatagramBuffer ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DatagramBuffer *local_this = (DatagramBuffer *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DatagramBuffer) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DatagramGenerator) {
    return (DatagramGenerator *) local_this;
  }
  if (requested_type == Dtool_Ptr_DatagramSink) {
    return (DatagramSink *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DatagramBuffer(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DatagramBuffer) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DatagramGenerator) {
    DatagramGenerator* other_this = (DatagramGenerator*)from_this;
    return (DatagramBuffer*)other_this;
  }
  if (from_type == Dtool_Ptr_DatagramSink) {
    DatagramSink* other_this = (DatagramSink*)from_this;
    return (DatagramBuffer*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DatagramInputFile
 */
/**
 * Python function wrapper for:
 * bool DatagramInputFile::open(FileReference const *file)
 * inline bool DatagramInputFile::open(Filename const &filename)
 * bool DatagramInputFile::open(std::istream &in, Filename const &filename = Filename())
 */
static PyObject *Dtool_DatagramInputFile_open_688(PyObject *self, PyObject *args, PyObject *kwds) {
  DatagramInputFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramInputFile, (void **)&local_this, "DatagramInputFile.open")) {
    return nullptr;
  }
  {
    // -2 bool DatagramInputFile::open(std::istream &in, Filename const &filename = Filename())
    PyObject *param1;
    PyObject *param2 = nullptr;
    static const char *keyword_list[] = {"in", "filename", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open", (char **)keyword_list, &param1, &param2)) {
      std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "DatagramInputFile.open", false, false);
      Filename const *param2_this;
      const Filename &param2_ref = Filename();
      if (param2 == nullptr) {
        param2_this = &param2_ref;
      } else {
        param2_this = nullptr;
        DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_Filename);
      }
      if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
        bool return_value = ((*local_this).open)(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool DatagramInputFile::open(FileReference const *file)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "file")) {
      FileReference const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_FileReference);
      if (param1_this != nullptr) {
        bool return_value = ((*local_this).open)(param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
  }

  {
    // -2 inline bool DatagramInputFile::open(Filename const &filename)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "filename")) {
      Filename const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_Filename);
      if (param1_this != nullptr) {
        bool return_value = ((*local_this).open)(*param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
  }

  {
    // -2 bool DatagramInputFile::open(std::istream &in, Filename const &filename = Filename())
    PyObject *param1;
    PyObject *param2 = nullptr;
    static const char *keyword_list[] = {"in", "filename", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open", (char **)keyword_list, &param1, &param2)) {
      std::istream *param1_this = (std::istream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_istream, 1, "DatagramInputFile.open", false, false);
      Filename param2_local;
      Filename const *param2_this;
      if (param2 != nullptr) {
        param2_this = Dtool_Coerce_Filename(param2, param2_local);
      } else {
        param2_local = Filename();
        param2_this = &param2_local;
      }
      if (param1_this != nullptr && (param2 == nullptr || (param2_this != nullptr))) {
        bool return_value = ((*local_this).open)(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool DatagramInputFile::open(FileReference const *file)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "file")) {
      CPT(FileReference) param1_this;
      if (Dtool_ConstCoerce_FileReference(param1, param1_this)) {
        bool return_value = ((*local_this).open)(std::move(param1_this));
        return Dtool_Return_Bool(return_value);
      }
    }
  }

  {
    // -2 inline bool DatagramInputFile::open(Filename const &filename)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "filename")) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != nullptr)) {
        bool return_value = ((*local_this).open)(*param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const DatagramInputFile self, istream in, const Filename filename)\n"
      "open(const DatagramInputFile self, const FileReference file)\n"
      "open(const DatagramInputFile self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DatagramInputFile_open_688_comment =
  "C++ Interface:\n"
  "open(const DatagramInputFile self, istream in, const Filename filename)\n"
  "open(const DatagramInputFile self, const FileReference file)\n"
  "open(const DatagramInputFile self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Opens the indicated filename for reading.  Returns true on success, false\n"
  " * on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Opens the indicated filename for reading.  Returns true on success, false\n"
  " * on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Starts reading from the indicated stream.  Returns true on success, false\n"
  " * on failure.  The DatagramInputFile does not take ownership of the stream;\n"
  " * you are responsible for closing or deleting it when you are done.\n"
  " */";
#else
static const char *Dtool_DatagramInputFile_open_688_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::istream &DatagramInputFile::get_stream(void)
 */
static PyObject *Dtool_DatagramInputFile_get_stream_689(PyObject *self, PyObject *) {
  DatagramInputFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramInputFile, (void **)&local_this, "DatagramInputFile.get_stream")) {
    return nullptr;
  }
  // 1-inline std::istream &DatagramInputFile::get_stream(void)
  std::istream *return_value = &(((*local_this).get_stream)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_istream, false, false);
}

#ifndef NDEBUG
static const char *Dtool_DatagramInputFile_get_stream_689_comment =
  "C++ Interface:\n"
  "get_stream(const DatagramInputFile self)\n"
  "\n"
  "/**\n"
  " * Returns the istream represented by the input file.\n"
  " */";
#else
static const char *Dtool_DatagramInputFile_get_stream_689_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DatagramInputFile::close(void)
 */
static PyObject *Dtool_DatagramInputFile_close_690(PyObject *self, PyObject *) {
  DatagramInputFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramInputFile, (void **)&local_this, "DatagramInputFile.close")) {
    return nullptr;
  }
  // 1-void DatagramInputFile::close(void)
  ((*local_this).close)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DatagramInputFile_close_690_comment =
  "C++ Interface:\n"
  "close(const DatagramInputFile self)\n"
  "\n"
  "/**\n"
  " * Closes the file.  This is also implicitly done when the DatagramInputFile\n"
  " * destructs.\n"
  " */";
#else
static const char *Dtool_DatagramInputFile_close_690_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DatagramInputFile::DatagramInputFile(void)
 */
static int Dtool_Init_DatagramInputFile(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("DatagramInputFile() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "DatagramInputFile() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline DatagramInputFile::DatagramInputFile(void)
  DatagramInputFile *return_value = new DatagramInputFile();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramInputFile, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DatagramInputFile()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DatagramInputFile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DatagramInputFile) {
    printf("DatagramInputFile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DatagramInputFile *local_this = (DatagramInputFile *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DatagramInputFile) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DatagramGenerator) {
    return (DatagramGenerator *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DatagramInputFile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DatagramInputFile) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DatagramGenerator) {
    DatagramGenerator* other_this = (DatagramGenerator*)from_this;
    return (DatagramInputFile*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DatagramOutputFile
 */
/**
 * Python function wrapper for:
 * bool DatagramOutputFile::open(FileReference const *file)
 * inline bool DatagramOutputFile::open(Filename const &filename)
 * bool DatagramOutputFile::open(std::ostream &out, Filename const &filename = Filename())
 */
static PyObject *Dtool_DatagramOutputFile_open_694(PyObject *self, PyObject *args, PyObject *kwds) {
  DatagramOutputFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramOutputFile, (void **)&local_this, "DatagramOutputFile.open")) {
    return nullptr;
  }
  {
    // -2 bool DatagramOutputFile::open(std::ostream &out, Filename const &filename = Filename())
    PyObject *param1;
    PyObject *param2 = nullptr;
    static const char *keyword_list[] = {"out", "filename", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open", (char **)keyword_list, &param1, &param2)) {
      std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "DatagramOutputFile.open", false, false);
      Filename const *param2_this;
      const Filename &param2_ref = Filename();
      if (param2 == nullptr) {
        param2_this = &param2_ref;
      } else {
        param2_this = nullptr;
        DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_Filename);
      }
      if (param1_this != nullptr && (param2 == nullptr || param2_this != nullptr)) {
        bool return_value = ((*local_this).open)(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool DatagramOutputFile::open(FileReference const *file)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "file")) {
      FileReference const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_FileReference);
      if (param1_this != nullptr) {
        bool return_value = ((*local_this).open)(param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
  }

  {
    // -2 inline bool DatagramOutputFile::open(Filename const &filename)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "filename")) {
      Filename const *param1_this = nullptr;
      DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_Filename);
      if (param1_this != nullptr) {
        bool return_value = ((*local_this).open)(*param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
  }

  {
    // -2 bool DatagramOutputFile::open(std::ostream &out, Filename const &filename = Filename())
    PyObject *param1;
    PyObject *param2 = nullptr;
    static const char *keyword_list[] = {"out", "filename", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "O|O:open", (char **)keyword_list, &param1, &param2)) {
      std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "DatagramOutputFile.open", false, false);
      Filename param2_local;
      Filename const *param2_this;
      if (param2 != nullptr) {
        param2_this = Dtool_Coerce_Filename(param2, param2_local);
      } else {
        param2_local = Filename();
        param2_this = &param2_local;
      }
      if (param1_this != nullptr && (param2 == nullptr || (param2_this != nullptr))) {
        bool return_value = ((*local_this).open)(*param1_this, *param2_this);
        return Dtool_Return_Bool(return_value);
      }
    }
    PyErr_Clear();
  }

  {
    // -2 bool DatagramOutputFile::open(FileReference const *file)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "file")) {
      CPT(FileReference) param1_this;
      if (Dtool_ConstCoerce_FileReference(param1, param1_this)) {
        bool return_value = ((*local_this).open)(std::move(param1_this));
        return Dtool_Return_Bool(return_value);
      }
    }
  }

  {
    // -2 inline bool DatagramOutputFile::open(Filename const &filename)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "filename")) {
      Filename param1_local;
      Filename const *param1_this = Dtool_Coerce_Filename(param1, param1_local);
      if ((param1_this != nullptr)) {
        bool return_value = ((*local_this).open)(*param1_this);
        return Dtool_Return_Bool(return_value);
      }
    }
  }

  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "open(const DatagramOutputFile self, ostream out, const Filename filename)\n"
      "open(const DatagramOutputFile self, const FileReference file)\n"
      "open(const DatagramOutputFile self, const Filename filename)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DatagramOutputFile_open_694_comment =
  "C++ Interface:\n"
  "open(const DatagramOutputFile self, ostream out, const Filename filename)\n"
  "open(const DatagramOutputFile self, const FileReference file)\n"
  "open(const DatagramOutputFile self, const Filename filename)\n"
  "\n"
  "/**\n"
  " * Opens the indicated filename for writing.  Returns true on success, false\n"
  " * on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Opens the indicated filename for writing.  Returns true if successful,\n"
  " * false on failure.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Starts writing to the indicated stream.  Returns true on success, false on\n"
  " * failure.  The DatagramOutputFile does not take ownership of the stream; you\n"
  " * are responsible for closing or deleting it when you are done.\n"
  " */";
#else
static const char *Dtool_DatagramOutputFile_open_694_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DatagramOutputFile::close(void)
 */
static PyObject *Dtool_DatagramOutputFile_close_695(PyObject *self, PyObject *) {
  DatagramOutputFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramOutputFile, (void **)&local_this, "DatagramOutputFile.close")) {
    return nullptr;
  }
  // 1-void DatagramOutputFile::close(void)
  ((*local_this).close)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DatagramOutputFile_close_695_comment =
  "C++ Interface:\n"
  "close(const DatagramOutputFile self)\n"
  "\n"
  "/**\n"
  " * Closes the file.  This is also implicitly done when the DatagramOutputFile\n"
  " * destructs.\n"
  " */";
#else
static const char *Dtool_DatagramOutputFile_close_695_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool DatagramOutputFile::write_header(std::string const &header)
 */
static PyObject *Dtool_DatagramOutputFile_write_header_696(PyObject *self, PyObject *arg) {
  DatagramOutputFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramOutputFile, (void **)&local_this, "DatagramOutputFile.write_header")) {
    return nullptr;
  }
  // 1-bool DatagramOutputFile::write_header(std::string const &header)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*local_this).write_header)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_header(const DatagramOutputFile self, str header)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DatagramOutputFile_write_header_696_comment =
  "C++ Interface:\n"
  "write_header(const DatagramOutputFile self, str header)\n"
  "\n"
  "/**\n"
  " * Writes a sequence of bytes to the beginning of the datagram file.  This may\n"
  " * be called any number of times after the file has been opened and before the\n"
  " * first datagram is written.  It may not be called once the first datagram is\n"
  " * written.\n"
  " */";
#else
static const char *Dtool_DatagramOutputFile_write_header_696_comment = nullptr;
#endif

static PyObject *Dtool_DatagramOutputFile_stream_Getter(PyObject *self, void *) {
  DatagramOutputFile *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DatagramOutputFile, (void **)&local_this, "DatagramOutputFile.stream")) {
    return nullptr;
  }

  // 1-inline std::ostream &DatagramOutputFile::get_stream(void)
  std::ostream *return_value = &(((*local_this).get_stream)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_std_ostream, false, false);
}

/**
 * Python function wrapper for:
 * inline DatagramOutputFile::DatagramOutputFile(void)
 */
static int Dtool_Init_DatagramOutputFile(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("DatagramOutputFile() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "DatagramOutputFile() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-inline DatagramOutputFile::DatagramOutputFile(void)
  DatagramOutputFile *return_value = new DatagramOutputFile();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DatagramOutputFile, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DatagramOutputFile()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DatagramOutputFile(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DatagramOutputFile) {
    printf("DatagramOutputFile ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DatagramOutputFile *local_this = (DatagramOutputFile *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DatagramOutputFile) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DatagramSink) {
    return (DatagramSink *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DatagramOutputFile(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DatagramOutputFile) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DatagramSink) {
    DatagramSink* other_this = (DatagramSink*)from_this;
    return (DatagramOutputFile*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DoubleBitMask< BitMaskNative >
 */
/**
 * Python function wrapper for:
 * static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::all_on(void)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_all_on_702(PyObject *, PyObject *) {
  // 1-static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::all_on(void)
  DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >((DoubleBitMask< BitMaskNative >::all_on)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_all_on_702_comment =
  "C++ Interface:\n"
  "all_on()\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_all_on_702_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::all_off(void)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_all_off_703(PyObject *, PyObject *) {
  // 1-static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::all_off(void)
  DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >((DoubleBitMask< BitMaskNative >::all_off)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_all_off_703_comment =
  "C++ Interface:\n"
  "all_off()\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_all_off_703_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::lower_on(int on_bits)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_lower_on_704(PyObject *, PyObject *arg) {
  // 1-static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::lower_on(int on_bits)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >((DoubleBitMask< BitMaskNative >::lower_on)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lower_on(int on_bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_lower_on_704_comment =
  "C++ Interface:\n"
  "lower_on(int on_bits)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_lower_on_704_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::bit(int index)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_bit_705(PyObject *, PyObject *arg) {
  // 1-static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >((DoubleBitMask< BitMaskNative >::bit)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bit(int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_bit_705_comment =
  "C++ Interface:\n"
  "bit(int index)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_bit_705_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::range(int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_range_706(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::range(int low_bit, int size)
  int param0;
  int param1;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:range", (char **)keyword_list, &param0, &param1)) {
    DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >((DoubleBitMask< BitMaskNative >::range)((int)param0, (int)param1));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "range(int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_range_706_comment =
  "C++ Interface:\n"
  "range(int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_range_706_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr bool DoubleBitMask< BitMaskNative >::has_max_num_bits(void)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_has_max_num_bits_707(PyObject *, PyObject *) {
  // 1-static constexpr bool DoubleBitMask< BitMaskNative >::has_max_num_bits(void)
  bool return_value = (DoubleBitMask< BitMaskNative >::has_max_num_bits)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_has_max_num_bits_707_comment =
  "C++ Interface:\n"
  "has_max_num_bits()\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_has_max_num_bits_707_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr int DoubleBitMask< BitMaskNative >::get_max_num_bits(void)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_max_num_bits_708(PyObject *, PyObject *) {
  // 1-static constexpr int DoubleBitMask< BitMaskNative >::get_max_num_bits(void)
  int return_value = (DoubleBitMask< BitMaskNative >::get_max_num_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_max_num_bits_708_comment =
  "C++ Interface:\n"
  "get_max_num_bits()\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_max_num_bits_708_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * constexpr int DoubleBitMask< BitMaskNative >::get_num_bits(void) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_num_bits_709(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-constexpr int DoubleBitMask< BitMaskNative >::get_num_bits(void) const
  int return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).get_num_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_num_bits_709_comment =
  "C++ Interface:\n"
  "get_num_bits(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_num_bits_709_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< BitMaskNative >::get_bit(int index) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_bit_710(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-inline bool DoubleBitMask< BitMaskNative >::get_bit(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).get_bit)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bit(DoubleBitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_bit_710_comment =
  "C++ Interface:\n"
  "get_bit(DoubleBitMask self, int index)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_bit_710_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::set_bit(int index)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_set_bit_711(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.set_bit")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::set_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_bit)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit(const DoubleBitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_set_bit_711_comment =
  "C++ Interface:\n"
  "set_bit(const DoubleBitMask self, int index)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_set_bit_711_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::clear_bit(int index)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_clear_bit_712(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.clear_bit")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::clear_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).clear_bit)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_bit(const DoubleBitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_clear_bit_712_comment =
  "C++ Interface:\n"
  "clear_bit(const DoubleBitMask self, int index)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_clear_bit_712_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::set_bit_to(int index, bool value)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_set_bit_to_713(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.set_bit_to")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::set_bit_to(int index, bool value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_bit_to", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_bit_to)((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit_to(const DoubleBitMask self, int index, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_set_bit_to_713_comment =
  "C++ Interface:\n"
  "set_bit_to(const DoubleBitMask self, int index, bool value)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_set_bit_to_713_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< BitMaskNative >::is_zero(void) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_is_zero_714(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-inline bool DoubleBitMask< BitMaskNative >::is_zero(void) const
  bool return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).is_zero)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_is_zero_714_comment =
  "C++ Interface:\n"
  "is_zero(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_is_zero_714_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< BitMaskNative >::is_all_on(void) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_is_all_on_715(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-inline bool DoubleBitMask< BitMaskNative >::is_all_on(void) const
  bool return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).is_all_on)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_is_all_on_715_comment =
  "C++ Interface:\n"
  "is_all_on(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_is_all_on_715_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t DoubleBitMask< BitMaskNative >::extract(int low_bit, int size) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_extract_716(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-inline uint64_t DoubleBitMask< BitMaskNative >::extract(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:extract", (char **)keyword_list, &param1, &param2)) {
    uint64_t return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).extract)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract(DoubleBitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_extract_716_comment =
  "C++ Interface:\n"
  "extract(DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_extract_716_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::store(uint64_t value, int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_store_717(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.store")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::store(uint64_t value, int low_bit, int size)
  unsigned PY_LONG_LONG param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Kii:store", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).store)((uint64_t)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store(const DoubleBitMask self, long value, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_store_717_comment =
  "C++ Interface:\n"
  "store(const DoubleBitMask self, long value, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_store_717_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< BitMaskNative >::has_any_of(int low_bit, int size) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_has_any_of_718(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-inline bool DoubleBitMask< BitMaskNative >::has_any_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_any_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).has_any_of)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_any_of(DoubleBitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_has_any_of_718_comment =
  "C++ Interface:\n"
  "has_any_of(DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_has_any_of_718_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< BitMaskNative >::has_all_of(int low_bit, int size) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_has_all_of_719(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-inline bool DoubleBitMask< BitMaskNative >::has_all_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_all_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).has_all_of)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_all_of(DoubleBitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_has_all_of_719_comment =
  "C++ Interface:\n"
  "has_all_of(DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_has_all_of_719_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::set_range(int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_set_range_720(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.set_range")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::set_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_range", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_range)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range(const DoubleBitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_set_range_720_comment =
  "C++ Interface:\n"
  "set_range(const DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_set_range_720_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::clear_range(int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_clear_range_721(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.clear_range")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::clear_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:clear_range", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).clear_range)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_range(const DoubleBitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_clear_range_721_comment =
  "C++ Interface:\n"
  "clear_range(const DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_clear_range_721_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::set_range_to(bool value, int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_set_range_to_722(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.set_range_to")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::set_range_to(bool value, int low_bit, int size)
  PyObject *param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_range_to", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_range_to)((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range_to(const DoubleBitMask self, bool value, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_set_range_to_722_comment =
  "C++ Interface:\n"
  "set_range_to(const DoubleBitMask self, bool value, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_set_range_to_722_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< BitMaskNative >::get_num_on_bits(void) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_num_on_bits_723(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-inline int DoubleBitMask< BitMaskNative >::get_num_on_bits(void) const
  int return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).get_num_on_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_num_on_bits_723_comment =
  "C++ Interface:\n"
  "get_num_on_bits(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_num_on_bits_723_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< BitMaskNative >::get_num_off_bits(void) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_num_off_bits_724(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-inline int DoubleBitMask< BitMaskNative >::get_num_off_bits(void) const
  int return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).get_num_off_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_num_off_bits_724_comment =
  "C++ Interface:\n"
  "get_num_off_bits(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_num_off_bits_724_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< BitMaskNative >::get_lowest_on_bit(void) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_lowest_on_bit_725(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-inline int DoubleBitMask< BitMaskNative >::get_lowest_on_bit(void) const
  int return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).get_lowest_on_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_lowest_on_bit_725_comment =
  "C++ Interface:\n"
  "get_lowest_on_bit(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_lowest_on_bit_725_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< BitMaskNative >::get_lowest_off_bit(void) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_lowest_off_bit_726(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-inline int DoubleBitMask< BitMaskNative >::get_lowest_off_bit(void) const
  int return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).get_lowest_off_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_lowest_off_bit_726_comment =
  "C++ Interface:\n"
  "get_lowest_off_bit(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_lowest_off_bit_726_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< BitMaskNative >::get_highest_on_bit(void) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_highest_on_bit_727(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-inline int DoubleBitMask< BitMaskNative >::get_highest_on_bit(void) const
  int return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).get_highest_on_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_highest_on_bit_727_comment =
  "C++ Interface:\n"
  "get_highest_on_bit(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_highest_on_bit_727_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< BitMaskNative >::get_highest_off_bit(void) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_highest_off_bit_728(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-inline int DoubleBitMask< BitMaskNative >::get_highest_off_bit(void) const
  int return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).get_highest_off_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_highest_off_bit_728_comment =
  "C++ Interface:\n"
  "get_highest_off_bit(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_highest_off_bit_728_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< BitMaskNative >::get_next_higher_different_bit(int low_bit) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_next_higher_different_bit_729(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-inline int DoubleBitMask< BitMaskNative >::get_next_higher_different_bit(int low_bit) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).get_next_higher_different_bit)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_next_higher_different_bit(DoubleBitMask self, int low_bit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_next_higher_different_bit_729_comment =
  "C++ Interface:\n"
  "get_next_higher_different_bit(DoubleBitMask self, int low_bit)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_next_higher_different_bit_729_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::invert_in_place(void)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_invert_in_place_730(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.invert_in_place")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::invert_in_place(void)
  ((*local_this).invert_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_invert_in_place_730_comment =
  "C++ Interface:\n"
  "invert_in_place(const DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_invert_in_place_730_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< BitMaskNative >::has_bits_in_common(DoubleBitMask< BitMaskNative > const &other) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_has_bits_in_common_731(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-inline bool DoubleBitMask< BitMaskNative >::has_bits_in_common(DoubleBitMask< BitMaskNative > const &other) const
  DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.has_bits_in_common", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).has_bits_in_common)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_bits_in_common(DoubleBitMask self, const DoubleBitMask other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_has_bits_in_common_731_comment =
  "C++ Interface:\n"
  "has_bits_in_common(DoubleBitMask self, const DoubleBitMask other)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_has_bits_in_common_731_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< BitMaskNative >::clear(void)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_clear_732(PyObject *self, PyObject *) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this, "DoubleBitMask_BitMaskNative.clear")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_clear_732_comment =
  "C++ Interface:\n"
  "clear(const DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_clear_732_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DoubleBitMask< BitMaskNative >::output(std::ostream &out) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_output_733(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-void DoubleBitMask< BitMaskNative >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "DoubleBitMask.output", false, true);
  if (arg_this != nullptr) {
    ((*(const DoubleBitMask< BitMaskNative >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DoubleBitMask self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_output_733_comment =
  "C++ Interface:\n"
  "output(DoubleBitMask self, ostream out)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_output_733_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DoubleBitMask< BitMaskNative >::output_binary(std::ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_output_binary_734(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-void DoubleBitMask< BitMaskNative >::output_binary(std::ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_binary", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "DoubleBitMask.output_binary", false, true);
    if (param1_this != nullptr) {
      ((*(const DoubleBitMask< BitMaskNative >*)local_this).output_binary)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_binary(DoubleBitMask self, ostream out, int spaces_every)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_output_binary_734_comment =
  "C++ Interface:\n"
  "output_binary(DoubleBitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_output_binary_734_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DoubleBitMask< BitMaskNative >::output_hex(std::ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_output_hex_735(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-void DoubleBitMask< BitMaskNative >::output_hex(std::ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_hex", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "DoubleBitMask.output_hex", false, true);
    if (param1_this != nullptr) {
      ((*(const DoubleBitMask< BitMaskNative >*)local_this).output_hex)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_hex(DoubleBitMask self, ostream out, int spaces_every)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_output_hex_735_comment =
  "C++ Interface:\n"
  "output_hex(DoubleBitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_output_hex_735_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DoubleBitMask< BitMaskNative >::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_write_736(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-void DoubleBitMask< BitMaskNative >::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "DoubleBitMask.write", false, true);
    if (param1_this != nullptr) {
      ((*(const DoubleBitMask< BitMaskNative >*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DoubleBitMask self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_write_736_comment =
  "C++ Interface:\n"
  "write(DoubleBitMask self, ostream out, int indent_level)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_write_736_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< BitMaskNative >::compare_to(DoubleBitMask< BitMaskNative > const &other) const
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_compare_to_740(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_BitMaskNative)) {
    return nullptr;
  }
  // 1-inline int DoubleBitMask< BitMaskNative >::compare_to(DoubleBitMask< BitMaskNative > const &other) const
  DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(DoubleBitMask self, const DoubleBitMask other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_compare_to_740_comment =
  "C++ Interface:\n"
  "compare_to(DoubleBitMask self, const DoubleBitMask other)\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_compare_to_740_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DoubleBitMask< BitMaskNative >::get_class_type(void)
 */
static PyObject *Dtool_DoubleBitMask_BitMaskNative_get_class_type_752(PyObject *, PyObject *) {
  // 1-static TypeHandle DoubleBitMask< BitMaskNative >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((DoubleBitMask< BitMaskNative >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_BitMaskNative_get_class_type_752_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DoubleBitMask_BitMaskNative_get_class_type_752_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * constexpr DoubleBitMask< BitMaskNative >::DoubleBitMask(void) = default
 * inline DoubleBitMask< BitMaskNative >::DoubleBitMask(DoubleBitMask< BitMaskNative > const &) = default
 */
static int Dtool_Init_DoubleBitMask_BitMaskNative(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("DoubleBitMask() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-constexpr DoubleBitMask< BitMaskNative >::DoubleBitMask(void) = default
      DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DoubleBitMask_BitMaskNative, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline DoubleBitMask< BitMaskNative >::DoubleBitMask(DoubleBitMask< BitMaskNative > const &) = default
      DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 0, "DoubleBitMask.DoubleBitMask", true, true);
      if (arg_this != nullptr) {
        DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DoubleBitMask_BitMaskNative, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DoubleBitMask() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DoubleBitMask()\n"
      "DoubleBitMask(const DoubleBitMask param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DoubleBitMask_BitMaskNative(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DoubleBitMask_BitMaskNative) {
    printf("DoubleBitMask_BitMaskNative ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DoubleBitMask< BitMaskNative > *local_this = (DoubleBitMask< BitMaskNative > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DoubleBitMask_BitMaskNative) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DoubleBitMask_BitMaskNative(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DoubleBitMask_BitMaskNative) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class DoubleBitMask< DoubleBitMaskNative >
 */
/**
 * Python function wrapper for:
 * static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::all_on(void)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_all_on_757(PyObject *, PyObject *) {
  // 1-static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::all_on(void)
  DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >((DoubleBitMask< DoubleBitMaskNative >::all_on)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_all_on_757_comment =
  "C++ Interface:\n"
  "all_on()\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_all_on_757_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::all_off(void)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_all_off_758(PyObject *, PyObject *) {
  // 1-static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::all_off(void)
  DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >((DoubleBitMask< DoubleBitMaskNative >::all_off)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_all_off_758_comment =
  "C++ Interface:\n"
  "all_off()\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_all_off_758_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::lower_on(int on_bits)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_lower_on_759(PyObject *, PyObject *arg) {
  // 1-static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::lower_on(int on_bits)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >((DoubleBitMask< DoubleBitMaskNative >::lower_on)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lower_on(int on_bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_lower_on_759_comment =
  "C++ Interface:\n"
  "lower_on(int on_bits)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_lower_on_759_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::bit(int index)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_bit_760(PyObject *, PyObject *arg) {
  // 1-static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >((DoubleBitMask< DoubleBitMaskNative >::bit)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bit(int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_bit_760_comment =
  "C++ Interface:\n"
  "bit(int index)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_bit_760_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::range(int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_range_761(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::range(int low_bit, int size)
  int param0;
  int param1;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:range", (char **)keyword_list, &param0, &param1)) {
    DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >((DoubleBitMask< DoubleBitMaskNative >::range)((int)param0, (int)param1));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "range(int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_range_761_comment =
  "C++ Interface:\n"
  "range(int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_range_761_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr bool DoubleBitMask< DoubleBitMaskNative >::has_max_num_bits(void)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_has_max_num_bits_762(PyObject *, PyObject *) {
  // 1-static constexpr bool DoubleBitMask< DoubleBitMaskNative >::has_max_num_bits(void)
  bool return_value = (DoubleBitMask< DoubleBitMaskNative >::has_max_num_bits)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_has_max_num_bits_762_comment =
  "C++ Interface:\n"
  "has_max_num_bits()\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_has_max_num_bits_762_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static constexpr int DoubleBitMask< DoubleBitMaskNative >::get_max_num_bits(void)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_max_num_bits_763(PyObject *, PyObject *) {
  // 1-static constexpr int DoubleBitMask< DoubleBitMaskNative >::get_max_num_bits(void)
  int return_value = (DoubleBitMask< DoubleBitMaskNative >::get_max_num_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_max_num_bits_763_comment =
  "C++ Interface:\n"
  "get_max_num_bits()\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_max_num_bits_763_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * constexpr int DoubleBitMask< DoubleBitMaskNative >::get_num_bits(void) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_bits_764(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-constexpr int DoubleBitMask< DoubleBitMaskNative >::get_num_bits(void) const
  int return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).get_num_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_bits_764_comment =
  "C++ Interface:\n"
  "get_num_bits(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_bits_764_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< DoubleBitMaskNative >::get_bit(int index) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_bit_765(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::get_bit(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).get_bit)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bit(DoubleBitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_bit_765_comment =
  "C++ Interface:\n"
  "get_bit(DoubleBitMask self, int index)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_bit_765_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::set_bit(int index)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_766(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.set_bit")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::set_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_bit)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit(const DoubleBitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_766_comment =
  "C++ Interface:\n"
  "set_bit(const DoubleBitMask self, int index)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_766_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::clear_bit(int index)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_bit_767(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.clear_bit")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::clear_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).clear_bit)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_bit(const DoubleBitMask self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_bit_767_comment =
  "C++ Interface:\n"
  "clear_bit(const DoubleBitMask self, int index)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_bit_767_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::set_bit_to(int index, bool value)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_to_768(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.set_bit_to")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::set_bit_to(int index, bool value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_bit_to", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_bit_to)((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit_to(const DoubleBitMask self, int index, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_to_768_comment =
  "C++ Interface:\n"
  "set_bit_to(const DoubleBitMask self, int index, bool value)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_to_768_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< DoubleBitMaskNative >::is_zero(void) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_is_zero_769(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::is_zero(void) const
  bool return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).is_zero)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_is_zero_769_comment =
  "C++ Interface:\n"
  "is_zero(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_is_zero_769_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< DoubleBitMaskNative >::is_all_on(void) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_is_all_on_770(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::is_all_on(void) const
  bool return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).is_all_on)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_is_all_on_770_comment =
  "C++ Interface:\n"
  "is_all_on(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_is_all_on_770_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline uint64_t DoubleBitMask< DoubleBitMaskNative >::extract(int low_bit, int size) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_extract_771(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-inline uint64_t DoubleBitMask< DoubleBitMaskNative >::extract(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:extract", (char **)keyword_list, &param1, &param2)) {
    uint64_t return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).extract)((int)param1, (int)param2);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "extract(DoubleBitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_extract_771_comment =
  "C++ Interface:\n"
  "extract(DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_extract_771_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::store(uint64_t value, int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_store_772(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.store")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::store(uint64_t value, int low_bit, int size)
  unsigned PY_LONG_LONG param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Kii:store", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).store)((uint64_t)param1, (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "store(const DoubleBitMask self, long value, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_store_772_comment =
  "C++ Interface:\n"
  "store(const DoubleBitMask self, long value, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_store_772_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< DoubleBitMaskNative >::has_any_of(int low_bit, int size) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_has_any_of_773(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::has_any_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_any_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).has_any_of)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_any_of(DoubleBitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_has_any_of_773_comment =
  "C++ Interface:\n"
  "has_any_of(DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_has_any_of_773_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< DoubleBitMaskNative >::has_all_of(int low_bit, int size) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_has_all_of_774(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::has_all_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_all_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).has_all_of)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_all_of(DoubleBitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_has_all_of_774_comment =
  "C++ Interface:\n"
  "has_all_of(DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_has_all_of_774_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::set_range(int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_775(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.set_range")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::set_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_range", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_range)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range(const DoubleBitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_775_comment =
  "C++ Interface:\n"
  "set_range(const DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_775_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::clear_range(int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_range_776(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.clear_range")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::clear_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:clear_range", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).clear_range)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_range(const DoubleBitMask self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_range_776_comment =
  "C++ Interface:\n"
  "clear_range(const DoubleBitMask self, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_range_776_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::set_range_to(bool value, int low_bit, int size)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_to_777(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.set_range_to")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::set_range_to(bool value, int low_bit, int size)
  PyObject *param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_range_to", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_range_to)((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range_to(const DoubleBitMask self, bool value, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_to_777_comment =
  "C++ Interface:\n"
  "set_range_to(const DoubleBitMask self, bool value, int low_bit, int size)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_to_777_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< DoubleBitMaskNative >::get_num_on_bits(void) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_on_bits_778(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::get_num_on_bits(void) const
  int return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).get_num_on_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_on_bits_778_comment =
  "C++ Interface:\n"
  "get_num_on_bits(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_on_bits_778_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< DoubleBitMaskNative >::get_num_off_bits(void) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_off_bits_779(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::get_num_off_bits(void) const
  int return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).get_num_off_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_off_bits_779_comment =
  "C++ Interface:\n"
  "get_num_off_bits(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_off_bits_779_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< DoubleBitMaskNative >::get_lowest_on_bit(void) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_on_bit_780(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::get_lowest_on_bit(void) const
  int return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).get_lowest_on_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_on_bit_780_comment =
  "C++ Interface:\n"
  "get_lowest_on_bit(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_on_bit_780_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< DoubleBitMaskNative >::get_lowest_off_bit(void) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_off_bit_781(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::get_lowest_off_bit(void) const
  int return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).get_lowest_off_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_off_bit_781_comment =
  "C++ Interface:\n"
  "get_lowest_off_bit(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_off_bit_781_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< DoubleBitMaskNative >::get_highest_on_bit(void) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_on_bit_782(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::get_highest_on_bit(void) const
  int return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).get_highest_on_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_on_bit_782_comment =
  "C++ Interface:\n"
  "get_highest_on_bit(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_on_bit_782_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< DoubleBitMaskNative >::get_highest_off_bit(void) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_off_bit_783(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::get_highest_off_bit(void) const
  int return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).get_highest_off_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_off_bit_783_comment =
  "C++ Interface:\n"
  "get_highest_off_bit(DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_off_bit_783_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< DoubleBitMaskNative >::get_next_higher_different_bit(int low_bit) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_next_higher_different_bit_784(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::get_next_higher_different_bit(int low_bit) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).get_next_higher_different_bit)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_next_higher_different_bit(DoubleBitMask self, int low_bit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_next_higher_different_bit_784_comment =
  "C++ Interface:\n"
  "get_next_higher_different_bit(DoubleBitMask self, int low_bit)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_next_higher_different_bit_784_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::invert_in_place(void)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_invert_in_place_785(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.invert_in_place")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::invert_in_place(void)
  ((*local_this).invert_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_invert_in_place_785_comment =
  "C++ Interface:\n"
  "invert_in_place(const DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_invert_in_place_785_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool DoubleBitMask< DoubleBitMaskNative >::has_bits_in_common(DoubleBitMask< DoubleBitMaskNative > const &other) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_has_bits_in_common_786(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::has_bits_in_common(DoubleBitMask< DoubleBitMaskNative > const &other) const
  DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.has_bits_in_common", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).has_bits_in_common)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_bits_in_common(DoubleBitMask self, const DoubleBitMask other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_has_bits_in_common_786_comment =
  "C++ Interface:\n"
  "has_bits_in_common(DoubleBitMask self, const DoubleBitMask other)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_has_bits_in_common_786_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void DoubleBitMask< DoubleBitMaskNative >::clear(void)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_787(PyObject *self, PyObject *) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this, "DoubleBitMask_DoubleBitMaskNative.clear")) {
    return nullptr;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_787_comment =
  "C++ Interface:\n"
  "clear(const DoubleBitMask self)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_clear_787_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DoubleBitMask< DoubleBitMaskNative >::output(std::ostream &out) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_output_788(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-void DoubleBitMask< DoubleBitMaskNative >::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "DoubleBitMask.output", false, true);
  if (arg_this != nullptr) {
    ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(DoubleBitMask self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_output_788_comment =
  "C++ Interface:\n"
  "output(DoubleBitMask self, ostream out)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_output_788_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DoubleBitMask< DoubleBitMaskNative >::output_binary(std::ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_output_binary_789(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-void DoubleBitMask< DoubleBitMaskNative >::output_binary(std::ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_binary", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "DoubleBitMask.output_binary", false, true);
    if (param1_this != nullptr) {
      ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).output_binary)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_binary(DoubleBitMask self, ostream out, int spaces_every)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_output_binary_789_comment =
  "C++ Interface:\n"
  "output_binary(DoubleBitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_output_binary_789_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DoubleBitMask< DoubleBitMaskNative >::output_hex(std::ostream &out, int spaces_every = 4) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_output_hex_790(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-void DoubleBitMask< DoubleBitMaskNative >::output_hex(std::ostream &out, int spaces_every = 4) const
  PyObject *param1;
  int param2 = 4;
  static const char *keyword_list[] = {"out", "spaces_every", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:output_hex", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "DoubleBitMask.output_hex", false, true);
    if (param1_this != nullptr) {
      ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).output_hex)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output_hex(DoubleBitMask self, ostream out, int spaces_every)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_output_hex_790_comment =
  "C++ Interface:\n"
  "output_hex(DoubleBitMask self, ostream out, int spaces_every)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_output_hex_790_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void DoubleBitMask< DoubleBitMaskNative >::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_write_791(PyObject *self, PyObject *args, PyObject *kwds) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-void DoubleBitMask< DoubleBitMaskNative >::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "DoubleBitMask.write", false, true);
    if (param1_this != nullptr) {
      ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(DoubleBitMask self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_write_791_comment =
  "C++ Interface:\n"
  "write(DoubleBitMask self, ostream out, int indent_level)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_write_791_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int DoubleBitMask< DoubleBitMaskNative >::compare_to(DoubleBitMask< DoubleBitMaskNative > const &other) const
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_795(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_DoubleBitMask_DoubleBitMaskNative)) {
    return nullptr;
  }
  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::compare_to(DoubleBitMask< DoubleBitMaskNative > const &other) const
  DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).compare_to)(*arg_this);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(DoubleBitMask self, const DoubleBitMask other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_795_comment =
  "C++ Interface:\n"
  "compare_to(DoubleBitMask self, const DoubleBitMask other)\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_795_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle DoubleBitMask< DoubleBitMaskNative >::get_class_type(void)
 */
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_get_class_type_807(PyObject *, PyObject *) {
  // 1-static TypeHandle DoubleBitMask< DoubleBitMaskNative >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((DoubleBitMask< DoubleBitMaskNative >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_class_type_807_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_DoubleBitMask_DoubleBitMaskNative_get_class_type_807_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * constexpr DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(void) = default
 * inline DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(DoubleBitMask< DoubleBitMaskNative > const &) = default
 */
static int Dtool_Init_DoubleBitMask_DoubleBitMaskNative(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("DoubleBitMask() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-constexpr DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(void) = default
      DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DoubleBitMask_DoubleBitMaskNative, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline DoubleBitMask< DoubleBitMaskNative >::DoubleBitMask(DoubleBitMask< DoubleBitMaskNative > const &) = default
      DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 0, "DoubleBitMask.DoubleBitMask", true, true);
      if (arg_this != nullptr) {
        DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_DoubleBitMask_DoubleBitMaskNative, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "DoubleBitMask() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "DoubleBitMask()\n"
      "DoubleBitMask(const DoubleBitMask param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_DoubleBitMask_DoubleBitMaskNative(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_DoubleBitMask_DoubleBitMaskNative) {
    printf("DoubleBitMask_DoubleBitMaskNative ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  DoubleBitMask< DoubleBitMaskNative > *local_this = (DoubleBitMask< DoubleBitMaskNative > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_DoubleBitMask_DoubleBitMaskNative) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_DoubleBitMask_DoubleBitMaskNative(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class GamepadButton
 */
/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::lstick(void)
 */
static PyObject *Dtool_GamepadButton_lstick_812(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::lstick(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::lstick)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_lstick_812_comment =
  "C++ Interface:\n"
  "lstick()\n";
#else
static const char *Dtool_GamepadButton_lstick_812_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::rstick(void)
 */
static PyObject *Dtool_GamepadButton_rstick_813(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::rstick(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::rstick)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_rstick_813_comment =
  "C++ Interface:\n"
  "rstick()\n";
#else
static const char *Dtool_GamepadButton_rstick_813_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::lshoulder(void)
 */
static PyObject *Dtool_GamepadButton_lshoulder_814(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::lshoulder(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::lshoulder)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_lshoulder_814_comment =
  "C++ Interface:\n"
  "lshoulder()\n";
#else
static const char *Dtool_GamepadButton_lshoulder_814_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::rshoulder(void)
 */
static PyObject *Dtool_GamepadButton_rshoulder_815(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::rshoulder(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::rshoulder)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_rshoulder_815_comment =
  "C++ Interface:\n"
  "rshoulder()\n";
#else
static const char *Dtool_GamepadButton_rshoulder_815_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::ltrigger(void)
 */
static PyObject *Dtool_GamepadButton_ltrigger_816(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::ltrigger(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::ltrigger)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_ltrigger_816_comment =
  "C++ Interface:\n"
  "ltrigger()\n";
#else
static const char *Dtool_GamepadButton_ltrigger_816_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::rtrigger(void)
 */
static PyObject *Dtool_GamepadButton_rtrigger_817(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::rtrigger(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::rtrigger)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_rtrigger_817_comment =
  "C++ Interface:\n"
  "rtrigger()\n";
#else
static const char *Dtool_GamepadButton_rtrigger_817_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::lgrip(void)
 */
static PyObject *Dtool_GamepadButton_lgrip_818(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::lgrip(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::lgrip)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_lgrip_818_comment =
  "C++ Interface:\n"
  "lgrip()\n";
#else
static const char *Dtool_GamepadButton_lgrip_818_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::rgrip(void)
 */
static PyObject *Dtool_GamepadButton_rgrip_819(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::rgrip(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::rgrip)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_rgrip_819_comment =
  "C++ Interface:\n"
  "rgrip()\n";
#else
static const char *Dtool_GamepadButton_rgrip_819_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::dpad_left(void)
 */
static PyObject *Dtool_GamepadButton_dpad_left_820(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::dpad_left(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::dpad_left)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_dpad_left_820_comment =
  "C++ Interface:\n"
  "dpad_left()\n";
#else
static const char *Dtool_GamepadButton_dpad_left_820_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::dpad_right(void)
 */
static PyObject *Dtool_GamepadButton_dpad_right_821(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::dpad_right(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::dpad_right)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_dpad_right_821_comment =
  "C++ Interface:\n"
  "dpad_right()\n";
#else
static const char *Dtool_GamepadButton_dpad_right_821_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::dpad_up(void)
 */
static PyObject *Dtool_GamepadButton_dpad_up_822(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::dpad_up(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::dpad_up)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_dpad_up_822_comment =
  "C++ Interface:\n"
  "dpad_up()\n";
#else
static const char *Dtool_GamepadButton_dpad_up_822_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::dpad_down(void)
 */
static PyObject *Dtool_GamepadButton_dpad_down_823(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::dpad_down(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::dpad_down)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_dpad_down_823_comment =
  "C++ Interface:\n"
  "dpad_down()\n";
#else
static const char *Dtool_GamepadButton_dpad_down_823_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::back(void)
 */
static PyObject *Dtool_GamepadButton_back_824(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::back(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::back)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_back_824_comment =
  "C++ Interface:\n"
  "back()\n";
#else
static const char *Dtool_GamepadButton_back_824_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::guide(void)
 */
static PyObject *Dtool_GamepadButton_guide_825(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::guide(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::guide)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_guide_825_comment =
  "C++ Interface:\n"
  "guide()\n";
#else
static const char *Dtool_GamepadButton_guide_825_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::start(void)
 */
static PyObject *Dtool_GamepadButton_start_826(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::start(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::start)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_start_826_comment =
  "C++ Interface:\n"
  "start()\n";
#else
static const char *Dtool_GamepadButton_start_826_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::next(void)
 */
static PyObject *Dtool_GamepadButton_next_827(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::next(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::next)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_next_827_comment =
  "C++ Interface:\n"
  "next()\n";
#else
static const char *Dtool_GamepadButton_next_827_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::previous(void)
 */
static PyObject *Dtool_GamepadButton_previous_828(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::previous(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::previous)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_previous_828_comment =
  "C++ Interface:\n"
  "previous()\n";
#else
static const char *Dtool_GamepadButton_previous_828_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::face_a(void)
 */
static PyObject *Dtool_GamepadButton_face_a_829(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::face_a(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::face_a)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_face_a_829_comment =
  "C++ Interface:\n"
  "face_a()\n";
#else
static const char *Dtool_GamepadButton_face_a_829_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::face_b(void)
 */
static PyObject *Dtool_GamepadButton_face_b_830(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::face_b(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::face_b)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_face_b_830_comment =
  "C++ Interface:\n"
  "face_b()\n";
#else
static const char *Dtool_GamepadButton_face_b_830_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::face_c(void)
 */
static PyObject *Dtool_GamepadButton_face_c_831(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::face_c(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::face_c)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_face_c_831_comment =
  "C++ Interface:\n"
  "face_c()\n";
#else
static const char *Dtool_GamepadButton_face_c_831_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::face_x(void)
 */
static PyObject *Dtool_GamepadButton_face_x_832(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::face_x(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::face_x)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_face_x_832_comment =
  "C++ Interface:\n"
  "face_x()\n";
#else
static const char *Dtool_GamepadButton_face_x_832_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::face_y(void)
 */
static PyObject *Dtool_GamepadButton_face_y_833(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::face_y(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::face_y)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_face_y_833_comment =
  "C++ Interface:\n"
  "face_y()\n";
#else
static const char *Dtool_GamepadButton_face_y_833_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::face_z(void)
 */
static PyObject *Dtool_GamepadButton_face_z_834(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::face_z(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::face_z)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_face_z_834_comment =
  "C++ Interface:\n"
  "face_z()\n";
#else
static const char *Dtool_GamepadButton_face_z_834_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::face_1(void)
 */
static PyObject *Dtool_GamepadButton_face_1_835(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::face_1(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::face_1)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_face_1_835_comment =
  "C++ Interface:\n"
  "face_1()\n";
#else
static const char *Dtool_GamepadButton_face_1_835_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::face_2(void)
 */
static PyObject *Dtool_GamepadButton_face_2_836(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::face_2(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::face_2)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_face_2_836_comment =
  "C++ Interface:\n"
  "face_2()\n";
#else
static const char *Dtool_GamepadButton_face_2_836_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::trigger(void)
 */
static PyObject *Dtool_GamepadButton_trigger_837(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::trigger(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::trigger)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_trigger_837_comment =
  "C++ Interface:\n"
  "trigger()\n"
  "\n"
  "// Flight stick buttons, takes zero-based index.  First is always trigger.";
#else
static const char *Dtool_GamepadButton_trigger_837_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::joystick(int button_number)
 */
static PyObject *Dtool_GamepadButton_joystick_838(PyObject *, PyObject *arg) {
  // 1-static ButtonHandle GamepadButton::joystick(int button_number)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ButtonHandle *return_value = new ButtonHandle((GamepadButton::joystick)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "joystick(int button_number)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_joystick_838_comment =
  "C++ Interface:\n"
  "joystick(int button_number)\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle associated with the particular numbered joystick\n"
  " * button (zero-based), if there is one, or ButtonHandle::none() if there is\n"
  " * not.\n"
  " */";
#else
static const char *Dtool_GamepadButton_joystick_838_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::hat_up(void)
 */
static PyObject *Dtool_GamepadButton_hat_up_839(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::hat_up(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::hat_up)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_hat_up_839_comment =
  "C++ Interface:\n"
  "hat_up()\n";
#else
static const char *Dtool_GamepadButton_hat_up_839_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::hat_down(void)
 */
static PyObject *Dtool_GamepadButton_hat_down_840(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::hat_down(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::hat_down)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_hat_down_840_comment =
  "C++ Interface:\n"
  "hat_down()\n";
#else
static const char *Dtool_GamepadButton_hat_down_840_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::hat_left(void)
 */
static PyObject *Dtool_GamepadButton_hat_left_841(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::hat_left(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::hat_left)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_hat_left_841_comment =
  "C++ Interface:\n"
  "hat_left()\n";
#else
static const char *Dtool_GamepadButton_hat_left_841_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle GamepadButton::hat_right(void)
 */
static PyObject *Dtool_GamepadButton_hat_right_842(PyObject *, PyObject *) {
  // 1-static ButtonHandle GamepadButton::hat_right(void)
  ButtonHandle *return_value = new ButtonHandle((GamepadButton::hat_right)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_GamepadButton_hat_right_842_comment =
  "C++ Interface:\n"
  "hat_right()\n";
#else
static const char *Dtool_GamepadButton_hat_right_842_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline GamepadButton::GamepadButton(void) = default
 * inline GamepadButton::GamepadButton(GamepadButton const &) = default
 */
static int Dtool_Init_GamepadButton(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("GamepadButton() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline GamepadButton::GamepadButton(void) = default
      GamepadButton *return_value = new GamepadButton();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GamepadButton, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline GamepadButton::GamepadButton(GamepadButton const &) = default
      GamepadButton const *arg_this = (GamepadButton *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_GamepadButton, 0, "GamepadButton.GamepadButton", true, true);
      if (arg_this != nullptr) {
        GamepadButton *return_value = new GamepadButton(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_GamepadButton, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "GamepadButton() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "GamepadButton()\n"
      "GamepadButton(const GamepadButton param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_GamepadButton(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_GamepadButton) {
    printf("GamepadButton ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  GamepadButton *local_this = (GamepadButton *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_GamepadButton) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_GamepadButton(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_GamepadButton) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class KeyboardButton
 */
/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::ascii_key(char ascii_equivalent)
 */
static PyObject *Dtool_KeyboardButton_ascii_key_846(PyObject *, PyObject *arg) {
  // 1-static ButtonHandle KeyboardButton::ascii_key(char ascii_equivalent)
  char *param0_str;
  Py_ssize_t param0_len;
  if (PyArg_Parse(arg, "s#:ascii_key", &param0_str, &param0_len)) {
    if (param0_len == 1) {
      ButtonHandle *return_value = new ButtonHandle((KeyboardButton::ascii_key)(param0_str[0]));
      if (return_value == nullptr) {
        return PyErr_NoMemory();
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return nullptr;
      }
      return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ascii_key(char ascii_equivalent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_ascii_key_846_comment =
  "C++ Interface:\n"
  "ascii_key(char ascii_equivalent)\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle associated with the particular ASCII character, if\n"
  " * there is one, or ButtonHandle::none() if there is not.\n"
  " */";
#else
static const char *Dtool_KeyboardButton_ascii_key_846_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::space(void)
 */
static PyObject *Dtool_KeyboardButton_space_847(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::space(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::space)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_space_847_comment =
  "C++ Interface:\n"
  "space()\n";
#else
static const char *Dtool_KeyboardButton_space_847_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::backspace(void)
 */
static PyObject *Dtool_KeyboardButton_backspace_848(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::backspace(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::backspace)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_backspace_848_comment =
  "C++ Interface:\n"
  "backspace()\n";
#else
static const char *Dtool_KeyboardButton_backspace_848_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::tab(void)
 */
static PyObject *Dtool_KeyboardButton_tab_849(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::tab(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::tab)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_tab_849_comment =
  "C++ Interface:\n"
  "tab()\n";
#else
static const char *Dtool_KeyboardButton_tab_849_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::enter(void)
 */
static PyObject *Dtool_KeyboardButton_enter_850(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::enter(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::enter)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_enter_850_comment =
  "C++ Interface:\n"
  "enter()\n";
#else
static const char *Dtool_KeyboardButton_enter_850_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::escape(void)
 */
static PyObject *Dtool_KeyboardButton_escape_851(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::escape(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::escape)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_escape_851_comment =
  "C++ Interface:\n"
  "escape()\n";
#else
static const char *Dtool_KeyboardButton_escape_851_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f1(void)
 */
static PyObject *Dtool_KeyboardButton_f1_852(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f1(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::f1)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f1_852_comment =
  "C++ Interface:\n"
  "f1()\n";
#else
static const char *Dtool_KeyboardButton_f1_852_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f2(void)
 */
static PyObject *Dtool_KeyboardButton_f2_853(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f2(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::f2)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f2_853_comment =
  "C++ Interface:\n"
  "f2()\n";
#else
static const char *Dtool_KeyboardButton_f2_853_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f3(void)
 */
static PyObject *Dtool_KeyboardButton_f3_854(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f3(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::f3)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f3_854_comment =
  "C++ Interface:\n"
  "f3()\n";
#else
static const char *Dtool_KeyboardButton_f3_854_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f4(void)
 */
static PyObject *Dtool_KeyboardButton_f4_855(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f4(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::f4)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f4_855_comment =
  "C++ Interface:\n"
  "f4()\n";
#else
static const char *Dtool_KeyboardButton_f4_855_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f5(void)
 */
static PyObject *Dtool_KeyboardButton_f5_856(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f5(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::f5)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f5_856_comment =
  "C++ Interface:\n"
  "f5()\n";
#else
static const char *Dtool_KeyboardButton_f5_856_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f6(void)
 */
static PyObject *Dtool_KeyboardButton_f6_857(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f6(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::f6)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f6_857_comment =
  "C++ Interface:\n"
  "f6()\n";
#else
static const char *Dtool_KeyboardButton_f6_857_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f7(void)
 */
static PyObject *Dtool_KeyboardButton_f7_858(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f7(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::f7)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f7_858_comment =
  "C++ Interface:\n"
  "f7()\n";
#else
static const char *Dtool_KeyboardButton_f7_858_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f8(void)
 */
static PyObject *Dtool_KeyboardButton_f8_859(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f8(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::f8)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f8_859_comment =
  "C++ Interface:\n"
  "f8()\n";
#else
static const char *Dtool_KeyboardButton_f8_859_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f9(void)
 */
static PyObject *Dtool_KeyboardButton_f9_860(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f9(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::f9)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f9_860_comment =
  "C++ Interface:\n"
  "f9()\n";
#else
static const char *Dtool_KeyboardButton_f9_860_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f10(void)
 */
static PyObject *Dtool_KeyboardButton_f10_861(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f10(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::f10)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f10_861_comment =
  "C++ Interface:\n"
  "f10()\n";
#else
static const char *Dtool_KeyboardButton_f10_861_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f11(void)
 */
static PyObject *Dtool_KeyboardButton_f11_862(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f11(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::f11)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f11_862_comment =
  "C++ Interface:\n"
  "f11()\n";
#else
static const char *Dtool_KeyboardButton_f11_862_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f12(void)
 */
static PyObject *Dtool_KeyboardButton_f12_863(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f12(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::f12)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f12_863_comment =
  "C++ Interface:\n"
  "f12()\n";
#else
static const char *Dtool_KeyboardButton_f12_863_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f13(void)
 */
static PyObject *Dtool_KeyboardButton_f13_864(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f13(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::f13)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f13_864_comment =
  "C++ Interface:\n"
  "f13()\n"
  "\n"
  "// PC keyboards don't have these four buttons, but Macs do.";
#else
static const char *Dtool_KeyboardButton_f13_864_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f14(void)
 */
static PyObject *Dtool_KeyboardButton_f14_865(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f14(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::f14)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f14_865_comment =
  "C++ Interface:\n"
  "f14()\n";
#else
static const char *Dtool_KeyboardButton_f14_865_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f15(void)
 */
static PyObject *Dtool_KeyboardButton_f15_866(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f15(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::f15)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f15_866_comment =
  "C++ Interface:\n"
  "f15()\n";
#else
static const char *Dtool_KeyboardButton_f15_866_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::f16(void)
 */
static PyObject *Dtool_KeyboardButton_f16_867(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::f16(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::f16)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_f16_867_comment =
  "C++ Interface:\n"
  "f16()\n";
#else
static const char *Dtool_KeyboardButton_f16_867_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::left(void)
 */
static PyObject *Dtool_KeyboardButton_left_868(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::left(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::left)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_left_868_comment =
  "C++ Interface:\n"
  "left()\n";
#else
static const char *Dtool_KeyboardButton_left_868_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::right(void)
 */
static PyObject *Dtool_KeyboardButton_right_869(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::right(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::right)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_right_869_comment =
  "C++ Interface:\n"
  "right()\n";
#else
static const char *Dtool_KeyboardButton_right_869_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::up(void)
 */
static PyObject *Dtool_KeyboardButton_up_870(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::up(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::up)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_up_870_comment =
  "C++ Interface:\n"
  "up()\n";
#else
static const char *Dtool_KeyboardButton_up_870_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::down(void)
 */
static PyObject *Dtool_KeyboardButton_down_871(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::down(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::down)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_down_871_comment =
  "C++ Interface:\n"
  "down()\n";
#else
static const char *Dtool_KeyboardButton_down_871_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::page_up(void)
 */
static PyObject *Dtool_KeyboardButton_page_up_872(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::page_up(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::page_up)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_page_up_872_comment =
  "C++ Interface:\n"
  "page_up()\n";
#else
static const char *Dtool_KeyboardButton_page_up_872_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::page_down(void)
 */
static PyObject *Dtool_KeyboardButton_page_down_873(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::page_down(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::page_down)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_page_down_873_comment =
  "C++ Interface:\n"
  "page_down()\n";
#else
static const char *Dtool_KeyboardButton_page_down_873_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::home(void)
 */
static PyObject *Dtool_KeyboardButton_home_874(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::home(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::home)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_home_874_comment =
  "C++ Interface:\n"
  "home()\n";
#else
static const char *Dtool_KeyboardButton_home_874_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::end(void)
 */
static PyObject *Dtool_KeyboardButton_end_875(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::end(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::end)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_end_875_comment =
  "C++ Interface:\n"
  "end()\n";
#else
static const char *Dtool_KeyboardButton_end_875_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::insert(void)
 */
static PyObject *Dtool_KeyboardButton_insert_876(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::insert(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::insert)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_insert_876_comment =
  "C++ Interface:\n"
  "insert()\n";
#else
static const char *Dtool_KeyboardButton_insert_876_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::del(void)
 */
static PyObject *Dtool_KeyboardButton_del_877(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::del(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::del)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_del_877_comment =
  "C++ Interface:\n"
  "_del()\n"
  "\n"
  "// delete is a C++ keyword.";
#else
static const char *Dtool_KeyboardButton_del_877_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::help(void)
 */
static PyObject *Dtool_KeyboardButton_help_878(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::help(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::help)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_help_878_comment =
  "C++ Interface:\n"
  "help()\n"
  "\n"
  "// delete is a C++ keyword.";
#else
static const char *Dtool_KeyboardButton_help_878_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::menu(void)
 */
static PyObject *Dtool_KeyboardButton_menu_879(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::menu(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::menu)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_menu_879_comment =
  "C++ Interface:\n"
  "menu()\n";
#else
static const char *Dtool_KeyboardButton_menu_879_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::shift(void)
 */
static PyObject *Dtool_KeyboardButton_shift_880(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::shift(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::shift)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_shift_880_comment =
  "C++ Interface:\n"
  "shift()\n";
#else
static const char *Dtool_KeyboardButton_shift_880_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::control(void)
 */
static PyObject *Dtool_KeyboardButton_control_881(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::control(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::control)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_control_881_comment =
  "C++ Interface:\n"
  "control()\n";
#else
static const char *Dtool_KeyboardButton_control_881_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::alt(void)
 */
static PyObject *Dtool_KeyboardButton_alt_882(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::alt(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::alt)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_alt_882_comment =
  "C++ Interface:\n"
  "alt()\n";
#else
static const char *Dtool_KeyboardButton_alt_882_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::meta(void)
 */
static PyObject *Dtool_KeyboardButton_meta_883(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::meta(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::meta)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_meta_883_comment =
  "C++ Interface:\n"
  "meta()\n";
#else
static const char *Dtool_KeyboardButton_meta_883_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::caps_lock(void)
 */
static PyObject *Dtool_KeyboardButton_caps_lock_884(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::caps_lock(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::caps_lock)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_caps_lock_884_comment =
  "C++ Interface:\n"
  "caps_lock()\n";
#else
static const char *Dtool_KeyboardButton_caps_lock_884_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::shift_lock(void)
 */
static PyObject *Dtool_KeyboardButton_shift_lock_885(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::shift_lock(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::shift_lock)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_shift_lock_885_comment =
  "C++ Interface:\n"
  "shift_lock()\n";
#else
static const char *Dtool_KeyboardButton_shift_lock_885_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::num_lock(void)
 */
static PyObject *Dtool_KeyboardButton_num_lock_886(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::num_lock(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::num_lock)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_num_lock_886_comment =
  "C++ Interface:\n"
  "num_lock()\n";
#else
static const char *Dtool_KeyboardButton_num_lock_886_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::scroll_lock(void)
 */
static PyObject *Dtool_KeyboardButton_scroll_lock_887(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::scroll_lock(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::scroll_lock)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_scroll_lock_887_comment =
  "C++ Interface:\n"
  "scroll_lock()\n";
#else
static const char *Dtool_KeyboardButton_scroll_lock_887_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::print_screen(void)
 */
static PyObject *Dtool_KeyboardButton_print_screen_888(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::print_screen(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::print_screen)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_print_screen_888_comment =
  "C++ Interface:\n"
  "print_screen()\n";
#else
static const char *Dtool_KeyboardButton_print_screen_888_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::pause(void)
 */
static PyObject *Dtool_KeyboardButton_pause_889(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::pause(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::pause)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_pause_889_comment =
  "C++ Interface:\n"
  "pause()\n";
#else
static const char *Dtool_KeyboardButton_pause_889_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::lshift(void)
 */
static PyObject *Dtool_KeyboardButton_lshift_890(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::lshift(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::lshift)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_lshift_890_comment =
  "C++ Interface:\n"
  "lshift()\n";
#else
static const char *Dtool_KeyboardButton_lshift_890_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::rshift(void)
 */
static PyObject *Dtool_KeyboardButton_rshift_891(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::rshift(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::rshift)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_rshift_891_comment =
  "C++ Interface:\n"
  "rshift()\n";
#else
static const char *Dtool_KeyboardButton_rshift_891_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::lcontrol(void)
 */
static PyObject *Dtool_KeyboardButton_lcontrol_892(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::lcontrol(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::lcontrol)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_lcontrol_892_comment =
  "C++ Interface:\n"
  "lcontrol()\n";
#else
static const char *Dtool_KeyboardButton_lcontrol_892_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::rcontrol(void)
 */
static PyObject *Dtool_KeyboardButton_rcontrol_893(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::rcontrol(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::rcontrol)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_rcontrol_893_comment =
  "C++ Interface:\n"
  "rcontrol()\n";
#else
static const char *Dtool_KeyboardButton_rcontrol_893_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::lalt(void)
 */
static PyObject *Dtool_KeyboardButton_lalt_894(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::lalt(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::lalt)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_lalt_894_comment =
  "C++ Interface:\n"
  "lalt()\n";
#else
static const char *Dtool_KeyboardButton_lalt_894_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::ralt(void)
 */
static PyObject *Dtool_KeyboardButton_ralt_895(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::ralt(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::ralt)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_ralt_895_comment =
  "C++ Interface:\n"
  "ralt()\n";
#else
static const char *Dtool_KeyboardButton_ralt_895_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::lmeta(void)
 */
static PyObject *Dtool_KeyboardButton_lmeta_896(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::lmeta(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::lmeta)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_lmeta_896_comment =
  "C++ Interface:\n"
  "lmeta()\n";
#else
static const char *Dtool_KeyboardButton_lmeta_896_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle KeyboardButton::rmeta(void)
 */
static PyObject *Dtool_KeyboardButton_rmeta_897(PyObject *, PyObject *) {
  // 1-static ButtonHandle KeyboardButton::rmeta(void)
  ButtonHandle *return_value = new ButtonHandle((KeyboardButton::rmeta)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_KeyboardButton_rmeta_897_comment =
  "C++ Interface:\n"
  "rmeta()\n";
#else
static const char *Dtool_KeyboardButton_rmeta_897_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline KeyboardButton::KeyboardButton(void) = default
 * inline KeyboardButton::KeyboardButton(KeyboardButton const &) = default
 */
static int Dtool_Init_KeyboardButton(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("KeyboardButton() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline KeyboardButton::KeyboardButton(void) = default
      KeyboardButton *return_value = new KeyboardButton();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_KeyboardButton, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline KeyboardButton::KeyboardButton(KeyboardButton const &) = default
      KeyboardButton const *arg_this = (KeyboardButton *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_KeyboardButton, 0, "KeyboardButton.KeyboardButton", true, true);
      if (arg_this != nullptr) {
        KeyboardButton *return_value = new KeyboardButton(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_KeyboardButton, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "KeyboardButton() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "KeyboardButton()\n"
      "KeyboardButton(const KeyboardButton param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_KeyboardButton(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_KeyboardButton) {
    printf("KeyboardButton ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  KeyboardButton *local_this = (KeyboardButton *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_KeyboardButton) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_KeyboardButton(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_KeyboardButton) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ModifierButtons
 */
/**
 * Python function wrapper for:
 * inline void ModifierButtons::operator =(ModifierButtons const &copy)
 */
static PyObject *Dtool_ModifierButtons_operator_907(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModifierButtons, (void **)&local_this, "ModifierButtons.assign")) {
    return nullptr;
  }
  // 1-inline void ModifierButtons::operator =(ModifierButtons const &copy)
  ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "ModifierButtons.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    ModifierButtons *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ModifierButtons, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const ModifierButtons self, const ModifierButtons copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_operator_907_comment =
  "C++ Interface:\n"
  "assign(const ModifierButtons self, const ModifierButtons copy)\n";
#else
static const char *Dtool_ModifierButtons_operator_907_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ModifierButtons::set_button_list(ModifierButtons const &other)
 */
static PyObject *Dtool_ModifierButtons_set_button_list_915(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModifierButtons, (void **)&local_this, "ModifierButtons.set_button_list")) {
    return nullptr;
  }
  // 1-void ModifierButtons::set_button_list(ModifierButtons const &other)
  ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "ModifierButtons.set_button_list", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_button_list)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_button_list(const ModifierButtons self, const ModifierButtons other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_set_button_list_915_comment =
  "C++ Interface:\n"
  "set_button_list(const ModifierButtons self, const ModifierButtons other)\n"
  "\n"
  "/**\n"
  " * Sets the list of buttons to watch to be the same as that of the other\n"
  " * ModifierButtons object.  This makes the lists pointer equivalent (until one\n"
  " * or the other is later modified).\n"
  " *\n"
  " * This will preserve the state of any button that was on the original list\n"
  " * and is also on the new lists.  Any other buttons will get reset to the\n"
  " * default state of \"up\".\n"
  " */";
#else
static const char *Dtool_ModifierButtons_set_button_list_915_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ModifierButtons::matches(ModifierButtons const &other) const
 */
static PyObject *Dtool_ModifierButtons_matches_916(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModifierButtons)) {
    return nullptr;
  }
  // 1-bool ModifierButtons::matches(ModifierButtons const &other) const
  ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "ModifierButtons.matches", true, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const ModifierButtons*)local_this).matches)(*arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "matches(ModifierButtons self, const ModifierButtons other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_matches_916_comment =
  "C++ Interface:\n"
  "matches(ModifierButtons self, const ModifierButtons other)\n"
  "\n"
  "/**\n"
  " * Returns true if the set of buttons indicated as down by this\n"
  " * ModifierButtons object is the same set of buttons indicated as down by the\n"
  " * other ModifierButtons object.  The buttons indicated as up are not\n"
  " * relevant.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_matches_916_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ModifierButtons::add_button(ButtonHandle button)
 */
static PyObject *Dtool_ModifierButtons_add_button_917(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModifierButtons, (void **)&local_this, "ModifierButtons.add_button")) {
    return nullptr;
  }
  // 1-bool ModifierButtons::add_button(ButtonHandle button)
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ModifierButtons.add_button", "ButtonHandle");
  }
  bool return_value = ((*local_this).add_button)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_button(const ModifierButtons self, ButtonHandle button)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_add_button_917_comment =
  "C++ Interface:\n"
  "add_button(const ModifierButtons self, ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Adds the indicated button to the set of buttons that will be monitored for\n"
  " * upness and downness.  Returns true if the button was added, false if it was\n"
  " * already being monitored or if too many buttons are currently being\n"
  " * monitored.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_add_button_917_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ModifierButtons::has_button(ButtonHandle button) const
 */
static PyObject *Dtool_ModifierButtons_has_button_918(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModifierButtons)) {
    return nullptr;
  }
  // 1-bool ModifierButtons::has_button(ButtonHandle button) const
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ModifierButtons.has_button", "ButtonHandle");
  }
  bool return_value = ((*(const ModifierButtons*)local_this).has_button)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_button(ModifierButtons self, ButtonHandle button)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_has_button_918_comment =
  "C++ Interface:\n"
  "has_button(ModifierButtons self, ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated button is in the set of buttons being\n"
  " * monitored, false otherwise.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_has_button_918_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ModifierButtons::remove_button(ButtonHandle button)
 */
static PyObject *Dtool_ModifierButtons_remove_button_919(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModifierButtons, (void **)&local_this, "ModifierButtons.remove_button")) {
    return nullptr;
  }
  // 1-bool ModifierButtons::remove_button(ButtonHandle button)
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ModifierButtons.remove_button", "ButtonHandle");
  }
  bool return_value = ((*local_this).remove_button)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_button(const ModifierButtons self, ButtonHandle button)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_remove_button_919_comment =
  "C++ Interface:\n"
  "remove_button(const ModifierButtons self, ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Removes the indicated button from the set of buttons being monitored.\n"
  " * Returns true if the button was removed, false if it was not being monitored\n"
  " * in the first place.\n"
  " *\n"
  " * Unlike the other methods, you cannot remove a button by removing its alias;\n"
  " * you have to remove exactly the button itself.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_remove_button_919_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int ModifierButtons::get_num_buttons(void) const
 */
static PyObject *Dtool_ModifierButtons_get_num_buttons_920(PyObject *self, PyObject *) {
  ModifierButtons *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModifierButtons)) {
    return nullptr;
  }
  // 1-inline int ModifierButtons::get_num_buttons(void) const
  int return_value = ((*(const ModifierButtons*)local_this).get_num_buttons)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_get_num_buttons_920_comment =
  "C++ Interface:\n"
  "get_num_buttons(ModifierButtons self)\n"
  "\n"
  "/**\n"
  " * Returns the number of buttons that the ModifierButtons object is monitoring\n"
  " * (e.g.  the number of buttons passed to add_button()).\n"
  " */";
#else
static const char *Dtool_ModifierButtons_get_num_buttons_920_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ButtonHandle ModifierButtons::get_button(int index) const
 */
static PyObject *Dtool_ModifierButtons_get_button_921(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModifierButtons)) {
    return nullptr;
  }
  // 1-inline ButtonHandle ModifierButtons::get_button(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ButtonHandle *return_value = new ButtonHandle(((*(const ModifierButtons*)local_this).get_button)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_button(ModifierButtons self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_get_button_921_comment =
  "C++ Interface:\n"
  "get_button(ModifierButtons self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth button that the ModifierButtons object is monitoring (the\n"
  " * nth button passed to add_button()).  This must be in the range 0 <= index <\n"
  " * get_num_buttons().\n"
  " */";
#else
static const char *Dtool_ModifierButtons_get_button_921_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ModifierButtons::button_down(ButtonHandle button)
 */
static PyObject *Dtool_ModifierButtons_button_down_924(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModifierButtons, (void **)&local_this, "ModifierButtons.button_down")) {
    return nullptr;
  }
  // 1-bool ModifierButtons::button_down(ButtonHandle button)
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ModifierButtons.button_down", "ButtonHandle");
  }
  bool return_value = ((*local_this).button_down)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "button_down(const ModifierButtons self, ButtonHandle button)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_button_down_924_comment =
  "C++ Interface:\n"
  "button_down(const ModifierButtons self, ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Records that a particular button has been pressed.  If the given button is\n"
  " * one of the buttons that is currently being monitored, this will update the\n"
  " * internal state appropriately; otherwise, it will do nothing.  Returns true\n"
  " * if the button is one that was monitored, or false otherwise.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_button_down_924_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ModifierButtons::button_up(ButtonHandle button)
 */
static PyObject *Dtool_ModifierButtons_button_up_925(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModifierButtons, (void **)&local_this, "ModifierButtons.button_up")) {
    return nullptr;
  }
  // 1-bool ModifierButtons::button_up(ButtonHandle button)
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ModifierButtons.button_up", "ButtonHandle");
  }
  bool return_value = ((*local_this).button_up)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "button_up(const ModifierButtons self, ButtonHandle button)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_button_up_925_comment =
  "C++ Interface:\n"
  "button_up(const ModifierButtons self, ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Records that a particular button has been released.  If the given button is\n"
  " * one of the buttons that is currently being monitored, this will update the\n"
  " * internal state appropriately; otherwise, it will do nothing.  Returns true\n"
  " * if the button is one that was monitored, or false otherwise.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_button_up_925_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ModifierButtons::all_buttons_up(void)
 */
static PyObject *Dtool_ModifierButtons_all_buttons_up_926(PyObject *self, PyObject *) {
  ModifierButtons *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ModifierButtons, (void **)&local_this, "ModifierButtons.all_buttons_up")) {
    return nullptr;
  }
  // 1-inline void ModifierButtons::all_buttons_up(void)
  ((*local_this).all_buttons_up)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_all_buttons_up_926_comment =
  "C++ Interface:\n"
  "all_buttons_up(const ModifierButtons self)\n"
  "\n"
  "/**\n"
  " * Marks all monitored buttons as being in the \"up\" state.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_all_buttons_up_926_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool ModifierButtons::is_down(ButtonHandle button) const
 * inline bool ModifierButtons::is_down(int index) const
 */
static PyObject *Dtool_ModifierButtons_is_down_927(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModifierButtons)) {
    return nullptr;
  }
  {
    // -2 bool ModifierButtons::is_down(ButtonHandle button) const
    ButtonHandle *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ButtonHandle);
    if (arg_this != nullptr) {
      bool return_value = ((*(const ModifierButtons*)local_this).is_down)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 inline bool ModifierButtons::is_down(int index) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      bool return_value = ((*(const ModifierButtons*)local_this).is_down)((int)arg_val);
      return Dtool_Return_Bool(return_value);
    }
  }

  {
    // -2 bool ModifierButtons::is_down(ButtonHandle button) const
    ButtonHandle arg_local;
    ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
    if ((arg_this != nullptr)) {
      bool return_value = ((*(const ModifierButtons*)local_this).is_down)(*arg_this);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: inline bool ModifierButtons::is_down(int index) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_down(ModifierButtons self, ButtonHandle button)\n"
      "is_down(ModifierButtons self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_is_down_927_comment =
  "C++ Interface:\n"
  "is_down(ModifierButtons self, ButtonHandle button)\n"
  "is_down(ModifierButtons self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated button is known to be down, or false if it is\n"
  " * known to be up.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated button is known to be down, or false if it is\n"
  " * known to be up or if it is not in the set of buttons being tracked.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_is_down_927_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool ModifierButtons::is_any_down(void) const
 */
static PyObject *Dtool_ModifierButtons_is_any_down_928(PyObject *self, PyObject *) {
  ModifierButtons *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModifierButtons)) {
    return nullptr;
  }
  // 1-inline bool ModifierButtons::is_any_down(void) const
  bool return_value = ((*(const ModifierButtons*)local_this).is_any_down)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_is_any_down_928_comment =
  "C++ Interface:\n"
  "is_any_down(ModifierButtons self)\n"
  "\n"
  "/**\n"
  " * Returns true if any of the tracked button are known to be down, or false if\n"
  " * all of them are up.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_is_any_down_928_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string ModifierButtons::get_prefix(void) const
 */
static PyObject *Dtool_ModifierButtons_get_prefix_929(PyObject *self, PyObject *) {
  ModifierButtons *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModifierButtons)) {
    return nullptr;
  }
  // 1-std::string ModifierButtons::get_prefix(void) const
  std::string return_value = ((*(const ModifierButtons*)local_this).get_prefix)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_get_prefix_929_comment =
  "C++ Interface:\n"
  "get_prefix(ModifierButtons self)\n"
  "\n"
  "/**\n"
  " * Returns a string which can be used to prefix any button name or event name\n"
  " * with the unique set of modifier buttons currently being held.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_get_prefix_929_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ModifierButtons::output(std::ostream &out) const
 */
static PyObject *Dtool_ModifierButtons_output_930(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModifierButtons)) {
    return nullptr;
  }
  // 1-void ModifierButtons::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ModifierButtons.output", false, true);
  if (arg_this != nullptr) {
    ((*(const ModifierButtons*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ModifierButtons self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_output_930_comment =
  "C++ Interface:\n"
  "output(ModifierButtons self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a one-line summary of the buttons known to be down.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_output_930_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ModifierButtons::write(std::ostream &out) const
 */
static PyObject *Dtool_ModifierButtons_write_931(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ModifierButtons)) {
    return nullptr;
  }
  // 1-void ModifierButtons::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ModifierButtons.write", false, true);
  if (arg_this != nullptr) {
    ((*(const ModifierButtons*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(ModifierButtons self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ModifierButtons_write_931_comment =
  "C++ Interface:\n"
  "write(ModifierButtons self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a multi-line summary including all of the buttons being monitored\n"
  " * and which ones are known to be down.\n"
  " */";
#else
static const char *Dtool_ModifierButtons_write_931_comment = nullptr;
#endif

/**
 * sequence length function for property ModifierButtons::buttons
 */
static Py_ssize_t Dtool_ModifierButtons_buttons_Len(PyObject *self) {
  ModifierButtons *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_buttons)();
}

/**
 * sequence getter for property ModifierButtons::buttons
 */
static PyObject *Dtool_ModifierButtons_buttons_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  ModifierButtons *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_buttons)()) {
    PyErr_SetString(PyExc_IndexError, "ModifierButtons.buttons[] index out of range");
    return nullptr;
  }
  // 1-inline ButtonHandle ModifierButtons::get_button(int index) const
  ButtonHandle *return_value = new ButtonHandle(((*(const ModifierButtons*)local_this).get_button)(index));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_button(ModifierButtons self, index)\n");
  }
}

static PyObject *Dtool_ModifierButtons_buttons_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_SequenceWrapper *wrap = Dtool_NewSequenceWrapper(self, "ModifierButtons.buttons");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_ModifierButtons_buttons_Len;
    wrap->_getitem_func = &Dtool_ModifierButtons_buttons_Sequence_Getitem;
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * ModifierButtons::ModifierButtons(void)
 * ModifierButtons::ModifierButtons(ModifierButtons const &copy)
 */
static int Dtool_Init_ModifierButtons(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-ModifierButtons::ModifierButtons(void)
      ModifierButtons *return_value = new ModifierButtons();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ModifierButtons, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-ModifierButtons::ModifierButtons(ModifierButtons const &copy)
        ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 0, "ModifierButtons.ModifierButtons", true, true);
        if (arg_this != nullptr) {
          ModifierButtons *return_value = new ModifierButtons(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ModifierButtons, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ModifierButtons() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ModifierButtons()\n"
      "ModifierButtons(const ModifierButtons copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ModifierButtons_get_buttons(PyObject *self, PyObject *) {
  ModifierButtons *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_buttons)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ModifierButtons_get_button_921(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ModifierButtons(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ModifierButtons) {
    printf("ModifierButtons ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ModifierButtons *local_this = (ModifierButtons *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ModifierButtons) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ModifierButtons(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ModifierButtons) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class MouseButton
 */
/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::button(int button_number)
 */
static PyObject *Dtool_MouseButton_button_933(PyObject *, PyObject *arg) {
  // 1-static ButtonHandle MouseButton::button(int button_number)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ButtonHandle *return_value = new ButtonHandle((MouseButton::button)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "button(int button_number)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_button_933_comment =
  "C++ Interface:\n"
  "button(int button_number)\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle associated with the particular numbered mouse\n"
  " * button (zero-based), if there is one, or ButtonHandle::none() if there is\n"
  " * not.\n"
  " */";
#else
static const char *Dtool_MouseButton_button_933_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::one(void)
 */
static PyObject *Dtool_MouseButton_one_934(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::one(void)
  ButtonHandle *return_value = new ButtonHandle((MouseButton::one)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_one_934_comment =
  "C++ Interface:\n"
  "one()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle associated with the first mouse button.\n"
  " */";
#else
static const char *Dtool_MouseButton_one_934_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::two(void)
 */
static PyObject *Dtool_MouseButton_two_935(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::two(void)
  ButtonHandle *return_value = new ButtonHandle((MouseButton::two)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_two_935_comment =
  "C++ Interface:\n"
  "two()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle associated with the second mouse button.\n"
  " */";
#else
static const char *Dtool_MouseButton_two_935_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::three(void)
 */
static PyObject *Dtool_MouseButton_three_936(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::three(void)
  ButtonHandle *return_value = new ButtonHandle((MouseButton::three)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_three_936_comment =
  "C++ Interface:\n"
  "three()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle associated with the third mouse button.\n"
  " */";
#else
static const char *Dtool_MouseButton_three_936_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::four(void)
 */
static PyObject *Dtool_MouseButton_four_937(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::four(void)
  ButtonHandle *return_value = new ButtonHandle((MouseButton::four)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_four_937_comment =
  "C++ Interface:\n"
  "four()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle associated with the fourth mouse button.\n"
  " */";
#else
static const char *Dtool_MouseButton_four_937_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::five(void)
 */
static PyObject *Dtool_MouseButton_five_938(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::five(void)
  ButtonHandle *return_value = new ButtonHandle((MouseButton::five)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_five_938_comment =
  "C++ Interface:\n"
  "five()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle associated with the fifth mouse button.\n"
  " */";
#else
static const char *Dtool_MouseButton_five_938_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::wheel_up(void)
 */
static PyObject *Dtool_MouseButton_wheel_up_939(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::wheel_up(void)
  ButtonHandle *return_value = new ButtonHandle((MouseButton::wheel_up)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_wheel_up_939_comment =
  "C++ Interface:\n"
  "wheel_up()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle generated when the mouse wheel is rolled one notch\n"
  " * upwards.\n"
  " */";
#else
static const char *Dtool_MouseButton_wheel_up_939_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::wheel_down(void)
 */
static PyObject *Dtool_MouseButton_wheel_down_940(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::wheel_down(void)
  ButtonHandle *return_value = new ButtonHandle((MouseButton::wheel_down)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_wheel_down_940_comment =
  "C++ Interface:\n"
  "wheel_down()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle generated when the mouse wheel is rolled one notch\n"
  " * downwards.\n"
  " */";
#else
static const char *Dtool_MouseButton_wheel_down_940_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::wheel_left(void)
 */
static PyObject *Dtool_MouseButton_wheel_left_941(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::wheel_left(void)
  ButtonHandle *return_value = new ButtonHandle((MouseButton::wheel_left)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_wheel_left_941_comment =
  "C++ Interface:\n"
  "wheel_left()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle generated when the mouse is scrolled to the left.\n"
  " * Usually, you'll only find the horizontal scroll on laptops.\n"
  " */";
#else
static const char *Dtool_MouseButton_wheel_left_941_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static ButtonHandle MouseButton::wheel_right(void)
 */
static PyObject *Dtool_MouseButton_wheel_right_942(PyObject *, PyObject *) {
  // 1-static ButtonHandle MouseButton::wheel_right(void)
  ButtonHandle *return_value = new ButtonHandle((MouseButton::wheel_right)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ButtonHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_wheel_right_942_comment =
  "C++ Interface:\n"
  "wheel_right()\n"
  "\n"
  "/**\n"
  " * Returns the ButtonHandle generated when the mouse is scrolled to the right.\n"
  " * Usually, you'll only find the horizontal scroll on laptops.\n"
  " */";
#else
static const char *Dtool_MouseButton_wheel_right_942_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static bool MouseButton::is_mouse_button(ButtonHandle button)
 */
static PyObject *Dtool_MouseButton_is_mouse_button_943(PyObject *, PyObject *arg) {
  // 1-static bool MouseButton::is_mouse_button(ButtonHandle button)
  ButtonHandle arg_local;
  ButtonHandle *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 0, "MouseButton.is_mouse_button", "ButtonHandle");
  }
  bool return_value = (MouseButton::is_mouse_button)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_mouse_button(ButtonHandle button)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_MouseButton_is_mouse_button_943_comment =
  "C++ Interface:\n"
  "is_mouse_button(ButtonHandle button)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated ButtonHandle is a mouse button, false if it\n"
  " * is some other kind of button.\n"
  " */";
#else
static const char *Dtool_MouseButton_is_mouse_button_943_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline MouseButton::MouseButton(void) = default
 * inline MouseButton::MouseButton(MouseButton const &) = default
 */
static int Dtool_Init_MouseButton(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("MouseButton() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline MouseButton::MouseButton(void) = default
      MouseButton *return_value = new MouseButton();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseButton, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline MouseButton::MouseButton(MouseButton const &) = default
      MouseButton const *arg_this = (MouseButton *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_MouseButton, 0, "MouseButton.MouseButton", true, true);
      if (arg_this != nullptr) {
        MouseButton *return_value = new MouseButton(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_MouseButton, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "MouseButton() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "MouseButton()\n"
      "MouseButton(const MouseButton param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_MouseButton(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_MouseButton) {
    printf("MouseButton ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  MouseButton *local_this = (MouseButton *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_MouseButton) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_MouseButton(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_MouseButton) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PointerData
 */
/**
 * Python function wrapper for:
 * inline double PointerData::get_x(void) const
 */
static PyObject *Dtool_PointerData_get_x_948(PyObject *self, PyObject *) {
  PointerData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerData)) {
    return nullptr;
  }
  // 1-inline double PointerData::get_x(void) const
  double return_value = ((*(const PointerData*)local_this).get_x)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerData_get_x_948_comment =
  "C++ Interface:\n"
  "get_x(PointerData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PointerData_get_x_948_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline double PointerData::get_y(void) const
 */
static PyObject *Dtool_PointerData_get_y_949(PyObject *self, PyObject *) {
  PointerData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerData)) {
    return nullptr;
  }
  // 1-inline double PointerData::get_y(void) const
  double return_value = ((*(const PointerData*)local_this).get_y)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerData_get_y_949_comment =
  "C++ Interface:\n"
  "get_y(PointerData self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PointerData_get_y_949_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PointerData::get_in_window(void) const
 */
static PyObject *Dtool_PointerData_get_in_window_950(PyObject *self, PyObject *) {
  PointerData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PointerData)) {
    return nullptr;
  }
  // 1-inline bool PointerData::get_in_window(void) const
  bool return_value = ((*(const PointerData*)local_this).get_in_window)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PointerData_get_in_window_950_comment =
  "C++ Interface:\n"
  "get_in_window(PointerData self)\n"
  "\n"
  "/**\n"
  " * If this returns false, the pointer is not currently present in the window\n"
  " * and the values returned by get_x() and get_y() may not be meaningful.\n"
  " */";
#else
static const char *Dtool_PointerData_get_in_window_950_comment = nullptr;
#endif

static PyObject *Dtool_PointerData_x_Getter(PyObject *self, void *) {
  const PointerData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double PointerData::get_x(void) const
  double return_value = ((*(const PointerData*)local_this).get_x)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PointerData_y_Getter(PyObject *self, void *) {
  const PointerData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double PointerData::get_y(void) const
  double return_value = ((*(const PointerData*)local_this).get_y)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PointerData_type_Getter(PyObject *self, void *) {
  const PointerData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PointerType PointerData::get_type(void) const
  PointerType return_value = ((*(const PointerData*)local_this).get_type)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return PyObject_CallFunction((PyObject *)Dtool_Ptr_PointerType, "l", (long)(return_value));
}

static PyObject *Dtool_PointerData_id_Getter(PyObject *self, void *) {
  const PointerData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int PointerData::get_id(void) const
  int return_value = ((*(const PointerData*)local_this).get_id)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PointerData_in_window_Getter(PyObject *self, void *) {
  const PointerData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool PointerData::get_in_window(void) const
  bool return_value = ((*(const PointerData*)local_this).get_in_window)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_PointerData_pressure_Getter(PyObject *self, void *) {
  const PointerData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline double PointerData::get_pressure(void) const
  double return_value = ((*(const PointerData*)local_this).get_pressure)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

/**
 * Python function wrapper for:
 * inline PointerData::PointerData(void) = default
 * inline PointerData::PointerData(PointerData const &) = default
 */
static int Dtool_Init_PointerData(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("PointerData() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline PointerData::PointerData(void) = default
      PointerData *return_value = new PointerData();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerData, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PointerData::PointerData(PointerData const &) = default
      PointerData const *arg_this = (PointerData *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PointerData, 0, "PointerData.PointerData", true, true);
      if (arg_this != nullptr) {
        PointerData *return_value = new PointerData(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PointerData, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PointerData() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PointerData()\n"
      "PointerData(const PointerData param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PointerData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PointerData) {
    printf("PointerData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PointerData *local_this = (PointerData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PointerData) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PointerData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PointerData) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class NodeCachedReferenceCount
 */
/**
 * Python function wrapper for:
 * inline int NodeCachedReferenceCount::get_node_ref_count(void) const
 */
static PyObject *Dtool_NodeCachedReferenceCount_get_node_ref_count_964(PyObject *self, PyObject *) {
  NodeCachedReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodeCachedReferenceCount)) {
    return nullptr;
  }
  // 1-inline int NodeCachedReferenceCount::get_node_ref_count(void) const
  int return_value = ((*(const NodeCachedReferenceCount*)local_this).get_node_ref_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodeCachedReferenceCount_get_node_ref_count_964_comment =
  "C++ Interface:\n"
  "get_node_ref_count(NodeCachedReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Returns the current reference count.\n"
  " */";
#else
static const char *Dtool_NodeCachedReferenceCount_get_node_ref_count_964_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void NodeCachedReferenceCount::node_ref(void) const
 */
static PyObject *Dtool_NodeCachedReferenceCount_node_ref_965(PyObject *self, PyObject *) {
  NodeCachedReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodeCachedReferenceCount)) {
    return nullptr;
  }
  // 1-inline void NodeCachedReferenceCount::node_ref(void) const
  ((*(const NodeCachedReferenceCount*)local_this).node_ref)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_NodeCachedReferenceCount_node_ref_965_comment =
  "C++ Interface:\n"
  "node_ref(NodeCachedReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Explicitly increments the reference count.\n"
  " *\n"
  " * This function is const, even though it changes the object, because\n"
  " * generally fiddling with an object's reference count isn't considered part\n"
  " * of fiddling with the object.  An object might be const in other ways, but\n"
  " * we still need to accurately count the number of references to it.\n"
  " */";
#else
static const char *Dtool_NodeCachedReferenceCount_node_ref_965_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodeCachedReferenceCount::node_unref(void) const
 */
static PyObject *Dtool_NodeCachedReferenceCount_node_unref_966(PyObject *self, PyObject *) {
  NodeCachedReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodeCachedReferenceCount)) {
    return nullptr;
  }
  // 1-inline bool NodeCachedReferenceCount::node_unref(void) const
  bool return_value = ((*(const NodeCachedReferenceCount*)local_this).node_unref)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodeCachedReferenceCount_node_unref_966_comment =
  "C++ Interface:\n"
  "node_unref(NodeCachedReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Explicitly decrements the node reference count and the normal reference\n"
  " * count simultaneously.\n"
  " *\n"
  " * The return value is true if the new reference count is nonzero, false if it\n"
  " * is zero.\n"
  " */";
#else
static const char *Dtool_NodeCachedReferenceCount_node_unref_966_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool NodeCachedReferenceCount::test_ref_count_integrity(void) const
 */
static PyObject *Dtool_NodeCachedReferenceCount_test_ref_count_integrity_967(PyObject *self, PyObject *) {
  NodeCachedReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodeCachedReferenceCount)) {
    return nullptr;
  }
  // 1-inline bool NodeCachedReferenceCount::test_ref_count_integrity(void) const
  bool return_value = ((*(const NodeCachedReferenceCount*)local_this).test_ref_count_integrity)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodeCachedReferenceCount_test_ref_count_integrity_967_comment =
  "C++ Interface:\n"
  "test_ref_count_integrity(NodeCachedReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Does some easy checks to make sure that the reference count isn't\n"
  " * completely bogus.\n"
  " */";
#else
static const char *Dtool_NodeCachedReferenceCount_test_ref_count_integrity_967_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int NodeCachedReferenceCount::get_referenced_bits(void) const
 */
static PyObject *Dtool_NodeCachedReferenceCount_get_referenced_bits_969(PyObject *self, PyObject *) {
  NodeCachedReferenceCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_NodeCachedReferenceCount)) {
    return nullptr;
  }
  // 1-inline int NodeCachedReferenceCount::get_referenced_bits(void) const
  int return_value = ((*(const NodeCachedReferenceCount*)local_this).get_referenced_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_NodeCachedReferenceCount_get_referenced_bits_969_comment =
  "C++ Interface:\n"
  "get_referenced_bits(NodeCachedReferenceCount self)\n"
  "\n"
  "/**\n"
  " * Returns the union of the values defined in the Referenced enum that\n"
  " * represents the various things that appear to be holding a pointer to this\n"
  " * object.\n"
  " *\n"
  " * If R_node is included, at least one node is holding a pointer; if R_cache\n"
  " * is included, at least one cache element is.\n"
  " */";
#else
static const char *Dtool_NodeCachedReferenceCount_get_referenced_bits_969_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle NodeCachedReferenceCount::get_class_type(void)
 */
static PyObject *Dtool_NodeCachedReferenceCount_get_class_type_970(PyObject *, PyObject *) {
  // 1-static TypeHandle NodeCachedReferenceCount::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((NodeCachedReferenceCount::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_NodeCachedReferenceCount_get_class_type_970_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_NodeCachedReferenceCount_get_class_type_970_comment = nullptr;
#endif

static int Dtool_Init_NodeCachedReferenceCount(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_NodeCachedReferenceCount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_NodeCachedReferenceCount) {
    printf("NodeCachedReferenceCount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  NodeCachedReferenceCount *local_this = (NodeCachedReferenceCount *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_NodeCachedReferenceCount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    return (CachedTypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(CachedTypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_NodeCachedReferenceCount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_NodeCachedReferenceCount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CachedTypedWritableReferenceCount) {
    CachedTypedWritableReferenceCount* other_this = (CachedTypedWritableReferenceCount*)from_this;
    return (NodeCachedReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (NodeCachedReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (NodeCachedReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (NodeCachedReferenceCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (NodeCachedReferenceCount*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class SparseArray
 */
/**
 * Python function wrapper for:
 * static inline SparseArray SparseArray::all_on(void)
 */
static PyObject *Dtool_SparseArray_all_on_973(PyObject *, PyObject *) {
  // 1-static inline SparseArray SparseArray::all_on(void)
  SparseArray *return_value = new SparseArray((SparseArray::all_on)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_all_on_973_comment =
  "C++ Interface:\n"
  "all_on()\n"
  "\n"
  "/**\n"
  " * Returns a SparseArray with an infinite array of bits, all on.\n"
  " */";
#else
static const char *Dtool_SparseArray_all_on_973_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline SparseArray SparseArray::all_off(void)
 */
static PyObject *Dtool_SparseArray_all_off_974(PyObject *, PyObject *) {
  // 1-static inline SparseArray SparseArray::all_off(void)
  SparseArray *return_value = new SparseArray((SparseArray::all_off)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_all_off_974_comment =
  "C++ Interface:\n"
  "all_off()\n"
  "\n"
  "/**\n"
  " * Returns a SparseArray whose bits are all off.\n"
  " */";
#else
static const char *Dtool_SparseArray_all_off_974_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline SparseArray SparseArray::lower_on(int on_bits)
 */
static PyObject *Dtool_SparseArray_lower_on_975(PyObject *, PyObject *arg) {
  // 1-static inline SparseArray SparseArray::lower_on(int on_bits)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    SparseArray *return_value = new SparseArray((SparseArray::lower_on)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "lower_on(int on_bits)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_lower_on_975_comment =
  "C++ Interface:\n"
  "lower_on(int on_bits)\n"
  "\n"
  "/**\n"
  " * Returns a SparseArray whose lower on_bits bits are on.\n"
  " */";
#else
static const char *Dtool_SparseArray_lower_on_975_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline SparseArray SparseArray::bit(int index)
 */
static PyObject *Dtool_SparseArray_bit_976(PyObject *, PyObject *arg) {
  // 1-static inline SparseArray SparseArray::bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    SparseArray *return_value = new SparseArray((SparseArray::bit)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bit(int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_bit_976_comment =
  "C++ Interface:\n"
  "bit(int index)\n"
  "\n"
  "/**\n"
  " * Returns a SparseArray with only the indicated bit on.\n"
  " */";
#else
static const char *Dtool_SparseArray_bit_976_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline SparseArray SparseArray::range(int low_bit, int size)
 */
static PyObject *Dtool_SparseArray_range_977(PyObject *, PyObject *args, PyObject *kwds) {
  // 1-static inline SparseArray SparseArray::range(int low_bit, int size)
  int param0;
  int param1;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:range", (char **)keyword_list, &param0, &param1)) {
    SparseArray *return_value = new SparseArray((SparseArray::range)((int)param0, (int)param1));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "range(int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_range_977_comment =
  "C++ Interface:\n"
  "range(int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Returns a SparseArray whose size bits, beginning at low_bit, are on.\n"
  " */";
#else
static const char *Dtool_SparseArray_range_977_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline bool SparseArray::has_max_num_bits(void)
 */
static PyObject *Dtool_SparseArray_has_max_num_bits_978(PyObject *, PyObject *) {
  // 1-static inline bool SparseArray::has_max_num_bits(void)
  bool return_value = (SparseArray::has_max_num_bits)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_has_max_num_bits_978_comment =
  "C++ Interface:\n"
  "has_max_num_bits()\n"
  "\n"
  "/**\n"
  " * Returns true if there is a maximum number of bits that may be stored in\n"
  " * this structure, false otherwise.  If this returns true, the number may be\n"
  " * queried in get_max_num_bits().\n"
  " *\n"
  " * This method always returns false.  The SparseArray has no maximum number of\n"
  " * bits.  This method is defined so generic programming algorithms can use\n"
  " * BitMask or SparseArray interchangeably.\n"
  " */";
#else
static const char *Dtool_SparseArray_has_max_num_bits_978_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline int SparseArray::get_max_num_bits(void)
 */
static PyObject *Dtool_SparseArray_get_max_num_bits_979(PyObject *, PyObject *) {
  // 1-static inline int SparseArray::get_max_num_bits(void)
  int return_value = (SparseArray::get_max_num_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_max_num_bits_979_comment =
  "C++ Interface:\n"
  "get_max_num_bits()\n"
  "\n"
  "/**\n"
  " * If get_max_num_bits() returned true, this method may be called to return\n"
  " * the maximum number of bits that may be stored in this structure.  It is an\n"
  " * error to call this if get_max_num_bits() return false.\n"
  " *\n"
  " * It is always an error to call this method.  The SparseArray has no maximum\n"
  " * number of bits.  This method is defined so generic programming algorithms\n"
  " * can use BitMask or SparseArray interchangeably.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_max_num_bits_979_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SparseArray::get_num_bits(void) const
 */
static PyObject *Dtool_SparseArray_get_num_bits_980(PyObject *self, PyObject *) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-inline int SparseArray::get_num_bits(void) const
  int return_value = ((*(const SparseArray*)local_this).get_num_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_num_bits_980_comment =
  "C++ Interface:\n"
  "get_num_bits(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns the current number of possibly different bits in this array.  There\n"
  " * are actually an infinite number of bits, but every bit higher than this bit\n"
  " * will have the same value, either 0 or 1 (see get_highest_bits()).\n"
  " *\n"
  " * This number may grow and/or shrink automatically as needed.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_num_bits_980_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SparseArray::get_bit(int index) const
 */
static PyObject *Dtool_SparseArray_get_bit_981(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-inline bool SparseArray::get_bit(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    bool return_value = ((*(const SparseArray*)local_this).get_bit)((int)arg_val);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_bit(SparseArray self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_bit_981_comment =
  "C++ Interface:\n"
  "get_bit(SparseArray self, int index)\n"
  "\n"
  "/**\n"
  " * Returns true if the nth bit is set, false if it is cleared.  It is valid\n"
  " * for n to increase beyond get_num_bits(), but the return value\n"
  " * get_num_bits() will always be the same.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_bit_981_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SparseArray::set_bit(int index)
 */
static PyObject *Dtool_SparseArray_set_bit_982(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.set_bit")) {
    return nullptr;
  }
  // 1-inline void SparseArray::set_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_bit)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit(const SparseArray self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_set_bit_982_comment =
  "C++ Interface:\n"
  "set_bit(const SparseArray self, int index)\n"
  "\n"
  "/**\n"
  " * Sets the nth bit on.  If n >= get_num_bits(), this automatically extends\n"
  " * the array.\n"
  " */";
#else
static const char *Dtool_SparseArray_set_bit_982_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SparseArray::clear_bit(int index)
 */
static PyObject *Dtool_SparseArray_clear_bit_983(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.clear_bit")) {
    return nullptr;
  }
  // 1-inline void SparseArray::clear_bit(int index)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).clear_bit)((int)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_bit(const SparseArray self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_clear_bit_983_comment =
  "C++ Interface:\n"
  "clear_bit(const SparseArray self, int index)\n"
  "\n"
  "/**\n"
  " * Sets the nth bit off.  If n >= get_num_bits(), this automatically extends\n"
  " * the array.\n"
  " */";
#else
static const char *Dtool_SparseArray_clear_bit_983_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SparseArray::set_bit_to(int index, bool value)
 */
static PyObject *Dtool_SparseArray_set_bit_to_984(PyObject *self, PyObject *args, PyObject *kwds) {
  SparseArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.set_bit_to")) {
    return nullptr;
  }
  // 1-inline void SparseArray::set_bit_to(int index, bool value)
  int param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "value", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "iO:set_bit_to", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_bit_to)((int)param1, (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bit_to(const SparseArray self, int index, bool value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_set_bit_to_984_comment =
  "C++ Interface:\n"
  "set_bit_to(const SparseArray self, int index, bool value)\n"
  "\n"
  "/**\n"
  " * Sets the nth bit either on or off, according to the indicated bool value.\n"
  " */";
#else
static const char *Dtool_SparseArray_set_bit_to_984_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SparseArray::get_highest_bits(void) const
 */
static PyObject *Dtool_SparseArray_get_highest_bits_985(PyObject *self, PyObject *) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-inline bool SparseArray::get_highest_bits(void) const
  bool return_value = ((*(const SparseArray*)local_this).get_highest_bits)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_highest_bits_985_comment =
  "C++ Interface:\n"
  "get_highest_bits(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns true if the infinite set of bits beyond get_num_bits() are all on,\n"
  " * or false of they are all off.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_highest_bits_985_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SparseArray::is_zero(void) const
 */
static PyObject *Dtool_SparseArray_is_zero_986(PyObject *self, PyObject *) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-inline bool SparseArray::is_zero(void) const
  bool return_value = ((*(const SparseArray*)local_this).is_zero)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_is_zero_986_comment =
  "C++ Interface:\n"
  "is_zero(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns true if the entire bitmask is zero, false otherwise.\n"
  " */";
#else
static const char *Dtool_SparseArray_is_zero_986_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SparseArray::is_all_on(void) const
 */
static PyObject *Dtool_SparseArray_is_all_on_987(PyObject *self, PyObject *) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-inline bool SparseArray::is_all_on(void) const
  bool return_value = ((*(const SparseArray*)local_this).is_all_on)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_is_all_on_987_comment =
  "C++ Interface:\n"
  "is_all_on(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns true if the entire bitmask is one, false otherwise.\n"
  " */";
#else
static const char *Dtool_SparseArray_is_all_on_987_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SparseArray::has_any_of(int low_bit, int size) const
 */
static PyObject *Dtool_SparseArray_has_any_of_988(PyObject *self, PyObject *args, PyObject *kwds) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-inline bool SparseArray::has_any_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_any_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const SparseArray*)local_this).has_any_of)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_any_of(SparseArray self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_has_any_of_988_comment =
  "C++ Interface:\n"
  "has_any_of(SparseArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Returns true if any bit in the indicated range is set, false otherwise.\n"
  " */";
#else
static const char *Dtool_SparseArray_has_any_of_988_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SparseArray::has_all_of(int low_bit, int size) const
 */
static PyObject *Dtool_SparseArray_has_all_of_989(PyObject *self, PyObject *args, PyObject *kwds) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-inline bool SparseArray::has_all_of(int low_bit, int size) const
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:has_all_of", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const SparseArray*)local_this).has_all_of)((int)param1, (int)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_all_of(SparseArray self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_has_all_of_989_comment =
  "C++ Interface:\n"
  "has_all_of(SparseArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Returns true if all bits in the indicated range are set, false otherwise.\n"
  " */";
#else
static const char *Dtool_SparseArray_has_all_of_989_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SparseArray::set_range(int low_bit, int size)
 */
static PyObject *Dtool_SparseArray_set_range_990(PyObject *self, PyObject *args, PyObject *kwds) {
  SparseArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.set_range")) {
    return nullptr;
  }
  // 1-inline void SparseArray::set_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:set_range", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_range)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range(const SparseArray self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_set_range_990_comment =
  "C++ Interface:\n"
  "set_range(const SparseArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Sets the indicated range of bits on.\n"
  " */";
#else
static const char *Dtool_SparseArray_set_range_990_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SparseArray::clear_range(int low_bit, int size)
 */
static PyObject *Dtool_SparseArray_clear_range_991(PyObject *self, PyObject *args, PyObject *kwds) {
  SparseArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.clear_range")) {
    return nullptr;
  }
  // 1-inline void SparseArray::clear_range(int low_bit, int size)
  int param1;
  int param2;
  static const char *keyword_list[] = {"low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ii:clear_range", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).clear_range)((int)param1, (int)param2);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "clear_range(const SparseArray self, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_clear_range_991_comment =
  "C++ Interface:\n"
  "clear_range(const SparseArray self, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Sets the indicated range of bits off.\n"
  " */";
#else
static const char *Dtool_SparseArray_clear_range_991_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SparseArray::set_range_to(bool value, int low_bit, int size)
 */
static PyObject *Dtool_SparseArray_set_range_to_992(PyObject *self, PyObject *args, PyObject *kwds) {
  SparseArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.set_range_to")) {
    return nullptr;
  }
  // 1-inline void SparseArray::set_range_to(bool value, int low_bit, int size)
  PyObject *param1;
  int param2;
  int param3;
  static const char *keyword_list[] = {"value", "low_bit", "size", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "Oii:set_range_to", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_range_to)((PyObject_IsTrue(param1) != 0), (int)param2, (int)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_range_to(const SparseArray self, bool value, int low_bit, int size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_set_range_to_992_comment =
  "C++ Interface:\n"
  "set_range_to(const SparseArray self, bool value, int low_bit, int size)\n"
  "\n"
  "/**\n"
  " * Sets the indicated range of bits to either on or off.\n"
  " */";
#else
static const char *Dtool_SparseArray_set_range_to_992_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int SparseArray::get_num_on_bits(void) const
 */
static PyObject *Dtool_SparseArray_get_num_on_bits_993(PyObject *self, PyObject *) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-int SparseArray::get_num_on_bits(void) const
  int return_value = ((*(const SparseArray*)local_this).get_num_on_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_num_on_bits_993_comment =
  "C++ Interface:\n"
  "get_num_on_bits(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bits that are set to 1 in the array.  Returns -1 if\n"
  " * there are an infinite number of 1 bits.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_num_on_bits_993_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int SparseArray::get_num_off_bits(void) const
 */
static PyObject *Dtool_SparseArray_get_num_off_bits_994(PyObject *self, PyObject *) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-int SparseArray::get_num_off_bits(void) const
  int return_value = ((*(const SparseArray*)local_this).get_num_off_bits)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_num_off_bits_994_comment =
  "C++ Interface:\n"
  "get_num_off_bits(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns the number of bits that are set to 0 in the array.  Returns -1 if\n"
  " * there are an infinite number of 0 bits.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_num_off_bits_994_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int SparseArray::get_lowest_on_bit(void) const
 */
static PyObject *Dtool_SparseArray_get_lowest_on_bit_995(PyObject *self, PyObject *) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-int SparseArray::get_lowest_on_bit(void) const
  int return_value = ((*(const SparseArray*)local_this).get_lowest_on_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_lowest_on_bit_995_comment =
  "C++ Interface:\n"
  "get_lowest_on_bit(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the lowest 1 bit in the array.  Returns -1 if there\n"
  " * are no 1 bits or if there are an infinite number of 1 bits.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_lowest_on_bit_995_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int SparseArray::get_lowest_off_bit(void) const
 */
static PyObject *Dtool_SparseArray_get_lowest_off_bit_996(PyObject *self, PyObject *) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-int SparseArray::get_lowest_off_bit(void) const
  int return_value = ((*(const SparseArray*)local_this).get_lowest_off_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_lowest_off_bit_996_comment =
  "C++ Interface:\n"
  "get_lowest_off_bit(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the lowest 0 bit in the array.  Returns -1 if there\n"
  " * are no 0 bits or if there are an infinite number of 1 bits.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_lowest_off_bit_996_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int SparseArray::get_highest_on_bit(void) const
 */
static PyObject *Dtool_SparseArray_get_highest_on_bit_997(PyObject *self, PyObject *) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-int SparseArray::get_highest_on_bit(void) const
  int return_value = ((*(const SparseArray*)local_this).get_highest_on_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_highest_on_bit_997_comment =
  "C++ Interface:\n"
  "get_highest_on_bit(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the highest 1 bit in the array.  Returns -1 if there\n"
  " * are no 1 bits or if there an infinite number of 1 bits.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_highest_on_bit_997_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int SparseArray::get_highest_off_bit(void) const
 */
static PyObject *Dtool_SparseArray_get_highest_off_bit_998(PyObject *self, PyObject *) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-int SparseArray::get_highest_off_bit(void) const
  int return_value = ((*(const SparseArray*)local_this).get_highest_off_bit)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_highest_off_bit_998_comment =
  "C++ Interface:\n"
  "get_highest_off_bit(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns the index of the highest 0 bit in the array.  Returns -1 if there\n"
  " * are no 0 bits or if there an infinite number of 1 bits.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_highest_off_bit_998_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int SparseArray::get_next_higher_different_bit(int low_bit) const
 */
static PyObject *Dtool_SparseArray_get_next_higher_different_bit_999(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-int SparseArray::get_next_higher_different_bit(int low_bit) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    int return_value = ((*(const SparseArray*)local_this).get_next_higher_different_bit)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_next_higher_different_bit(SparseArray self, int low_bit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_next_higher_different_bit_999_comment =
  "C++ Interface:\n"
  "get_next_higher_different_bit(SparseArray self, int low_bit)\n"
  "\n"
  "/**\n"
  " * Returns the index of the next bit in the array, above low_bit, whose value\n"
  " * is different that the value of low_bit.  Returns low_bit again if all bits\n"
  " * higher than low_bit have the same value.\n"
  " *\n"
  " * This can be used to quickly iterate through all of the bits in the array.\n"
  " */";
#else
static const char *Dtool_SparseArray_get_next_higher_different_bit_999_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SparseArray::invert_in_place(void)
 */
static PyObject *Dtool_SparseArray_invert_in_place_1000(PyObject *self, PyObject *) {
  SparseArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.invert_in_place")) {
    return nullptr;
  }
  // 1-inline void SparseArray::invert_in_place(void)
  ((*local_this).invert_in_place)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_invert_in_place_1000_comment =
  "C++ Interface:\n"
  "invert_in_place(const SparseArray self)\n"
  "\n"
  "/**\n"
  " * Inverts all the bits in the SparseArray.  This is equivalent to array =\n"
  " * ~array.\n"
  " */";
#else
static const char *Dtool_SparseArray_invert_in_place_1000_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool SparseArray::has_bits_in_common(SparseArray const &other) const
 */
static PyObject *Dtool_SparseArray_has_bits_in_common_1001(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-bool SparseArray::has_bits_in_common(SparseArray const &other) const
  SparseArray arg_local;
  SparseArray const *arg_this = Dtool_Coerce_SparseArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.has_bits_in_common", "SparseArray");
  }
  bool return_value = ((*(const SparseArray*)local_this).has_bits_in_common)(*arg_this);
  return Dtool_Return_Bool(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_bits_in_common(SparseArray self, const SparseArray other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_has_bits_in_common_1001_comment =
  "C++ Interface:\n"
  "has_bits_in_common(SparseArray self, const SparseArray other)\n"
  "\n"
  "/**\n"
  " * Returns true if this SparseArray has any \"one\" bits in common with the\n"
  " * other one, false otherwise.\n"
  " *\n"
  " * This is equivalent to (array & other) != 0, but may be faster.\n"
  " */";
#else
static const char *Dtool_SparseArray_has_bits_in_common_1001_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void SparseArray::clear(void)
 */
static PyObject *Dtool_SparseArray_clear_1002(PyObject *self, PyObject *) {
  SparseArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_SparseArray, (void **)&local_this, "SparseArray.clear")) {
    return nullptr;
  }
  // 1-inline void SparseArray::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_clear_1002_comment =
  "C++ Interface:\n"
  "clear(const SparseArray self)\n"
  "\n"
  "/**\n"
  " * Sets all the bits in the SparseArray off.\n"
  " */";
#else
static const char *Dtool_SparseArray_clear_1002_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void SparseArray::output(std::ostream &out) const
 */
static PyObject *Dtool_SparseArray_output_1003(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-void SparseArray::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "SparseArray.output", false, true);
  if (arg_this != nullptr) {
    ((*(const SparseArray*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(SparseArray self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_output_1003_comment =
  "C++ Interface:\n"
  "output(SparseArray self, ostream out)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_SparseArray_output_1003_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int SparseArray::compare_to(SparseArray const &other) const
 */
static PyObject *Dtool_SparseArray_compare_to_1007(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-int SparseArray::compare_to(SparseArray const &other) const
  SparseArray arg_local;
  SparseArray const *arg_this = Dtool_Coerce_SparseArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.compare_to", "SparseArray");
  }
  int return_value = ((*(const SparseArray*)local_this).compare_to)(*arg_this);
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "compare_to(SparseArray self, const SparseArray other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_compare_to_1007_comment =
  "C++ Interface:\n"
  "compare_to(SparseArray self, const SparseArray other)\n"
  "\n"
  "/**\n"
  " * Returns a number less than zero if this SparseArray sorts before the\n"
  " * indicated other SparseArray, greater than zero if it sorts after, or 0 if\n"
  " * they are equivalent.  This is based on the same ordering defined by\n"
  " * operator <.\n"
  " */";
#else
static const char *Dtool_SparseArray_compare_to_1007_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool SparseArray::is_inverse(void) const
 */
static PyObject *Dtool_SparseArray_is_inverse_1019(PyObject *self, PyObject *) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-inline bool SparseArray::is_inverse(void) const
  bool return_value = ((*(const SparseArray*)local_this).is_inverse)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_is_inverse_1019_comment =
  "C++ Interface:\n"
  "is_inverse(SparseArray self)\n"
  "\n"
  "/**\n"
  " * If this is true, the SparseArray is actually defined as a list of subranges\n"
  " * of integers that are *not* in the set.  If this is false (the default),\n"
  " * then the subranges define the integers that *are* in the set.  This affects\n"
  " * the interpretation of the values returned by iterating through\n"
  " * get_num_subranges().\n"
  " */";
#else
static const char *Dtool_SparseArray_is_inverse_1019_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t SparseArray::get_num_subranges(void) const
 */
static PyObject *Dtool_SparseArray_get_num_subranges_1020(PyObject *self, PyObject *) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-inline std::size_t SparseArray::get_num_subranges(void) const
  std::size_t return_value = ((*(const SparseArray*)local_this).get_num_subranges)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_num_subranges_1020_comment =
  "C++ Interface:\n"
  "get_num_subranges(SparseArray self)\n"
  "\n"
  "/**\n"
  " * Returns the number of separate subranges stored in the SparseArray.  You\n"
  " * can use this limit to iterate through the subranges, calling\n"
  " * get_subrange_begin() and get_subrange_end() for each one.\n"
  " *\n"
  " * Also see is_inverse().\n"
  " */";
#else
static const char *Dtool_SparseArray_get_num_subranges_1020_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SparseArray::get_subrange_begin(std::size_t n) const
 */
static PyObject *Dtool_SparseArray_get_subrange_begin_1021(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-inline int SparseArray::get_subrange_begin(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    int return_value = ((*(const SparseArray*)local_this).get_subrange_begin)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subrange_begin(SparseArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_subrange_begin_1021_comment =
  "C++ Interface:\n"
  "get_subrange_begin(SparseArray self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the first numeric element in the nth subrange.\n"
  " *\n"
  " * Also see is_inverse().\n"
  " */";
#else
static const char *Dtool_SparseArray_get_subrange_begin_1021_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int SparseArray::get_subrange_end(std::size_t n) const
 */
static PyObject *Dtool_SparseArray_get_subrange_end_1022(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_SparseArray)) {
    return nullptr;
  }
  // 1-inline int SparseArray::get_subrange_end(std::size_t n) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    int return_value = ((*(const SparseArray*)local_this).get_subrange_end)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_subrange_end(SparseArray self, int n)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_subrange_end_1022_comment =
  "C++ Interface:\n"
  "get_subrange_end(SparseArray self, int n)\n"
  "\n"
  "/**\n"
  " * Returns the last numeric element, plus one, in the nth subrange.\n"
  " *\n"
  " * Also see is_inverse().\n"
  " */";
#else
static const char *Dtool_SparseArray_get_subrange_end_1022_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle SparseArray::get_class_type(void)
 */
static PyObject *Dtool_SparseArray_get_class_type_1023(PyObject *, PyObject *) {
  // 1-static TypeHandle SparseArray::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((SparseArray::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_SparseArray_get_class_type_1023_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_SparseArray_get_class_type_1023_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline SparseArray::SparseArray(void)
 * SparseArray::SparseArray(BitArray const &from)
 * inline SparseArray::SparseArray(SparseArray const &) = default
 */
static int Dtool_Init_SparseArray(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-inline SparseArray::SparseArray(void)
      SparseArray *return_value = new SparseArray();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SparseArray, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 SparseArray::SparseArray(BitArray const &from)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "from")) {
          BitArray const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_BitArray);
          if (param0_this != nullptr) {
            SparseArray *return_value = new SparseArray(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SparseArray, true, false);
          }
        }
      }

      {
        // -2 inline SparseArray::SparseArray(SparseArray const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          SparseArray const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_SparseArray);
          if (param0_this != nullptr) {
            SparseArray *return_value = new SparseArray(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SparseArray, true, false);
          }
        }
      }

      {
        // -2 SparseArray::SparseArray(BitArray const &from)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "from")) {
          BitArray param0_local;
          BitArray const *param0_this = Dtool_Coerce_BitArray(param0, param0_local);
          if ((param0_this != nullptr)) {
            SparseArray *return_value = new SparseArray(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SparseArray, true, false);
          }
        }
      }

      {
        // -2 inline SparseArray::SparseArray(SparseArray const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          SparseArray param0_local;
          SparseArray const *param0_this = Dtool_Coerce_SparseArray(param0, param0_local);
          if ((param0_this != nullptr)) {
            SparseArray *return_value = new SparseArray(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_SparseArray, true, false);
          }
        }
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "SparseArray() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "SparseArray()\n"
      "SparseArray(const BitArray from)\n"
      "SparseArray(const SparseArray param0)\n");
  }
  return -1;
}

SparseArray *Dtool_Coerce_SparseArray(PyObject *args, SparseArray &coerced) {
  SparseArray *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_SparseArray)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const SparseArray *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-SparseArray::SparseArray(BitArray const &from)
    BitArray const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_BitArray);
    if (arg_this != nullptr) {
      coerced = SparseArray(*arg_this);
      if (_PyErr_OCCURRED()) {
        return nullptr;
      } else {
        return &coerced;
      }
    }
  }
  return nullptr;
}

static void *Dtool_UpcastInterface_SparseArray(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_SparseArray) {
    printf("SparseArray ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  SparseArray *local_this = (SparseArray *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_SparseArray) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_SparseArray(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_SparseArray) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamValueBase
 */
/**
 * Python function wrapper for:
 * virtual inline TypeHandle ParamValueBase::get_value_type(void) const
 */
static PyObject *Dtool_ParamValueBase_get_value_type_1026(PyObject *self, PyObject *) {
  ParamValueBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamValueBase)) {
    return nullptr;
  }
  // 1-virtual inline TypeHandle ParamValueBase::get_value_type(void) const
  TypeHandle *return_value = new TypeHandle(((*(const ParamValueBase*)local_this).get_value_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValueBase_get_value_type_1026_comment =
  "C++ Interface:\n"
  "get_value_type(ParamValueBase self)\n"
  "\n"
  "/**\n"
  " * Returns the type of the underlying value.\n"
  " */";
#else
static const char *Dtool_ParamValueBase_get_value_type_1026_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void ParamValueBase::output(std::ostream &out) const = 0
 */
static PyObject *Dtool_ParamValueBase_output_1027(PyObject *self, PyObject *arg) {
  ParamValueBase *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamValueBase)) {
    return nullptr;
  }
  // 1-virtual void ParamValueBase::output(std::ostream &out) const = 0
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "ParamValueBase.output", false, true);
  if (arg_this != nullptr) {
    ((*(const ParamValueBase*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(ParamValueBase self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParamValueBase_output_1027_comment =
  "C++ Interface:\n"
  "output(ParamValueBase self, ostream out)\n";
#else
static const char *Dtool_ParamValueBase_output_1027_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValueBase::get_class_type(void)
 */
static PyObject *Dtool_ParamValueBase_get_class_type_1028(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValueBase::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamValueBase::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValueBase_get_class_type_1028_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValueBase_get_class_type_1028_comment = nullptr;
#endif

static int Dtool_Init_ParamValueBase(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_ParamValueBase(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamValueBase) {
    printf("ParamValueBase ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamValueBase *local_this = (ParamValueBase *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamValueBase) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamValueBase(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValueBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValueBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValueBase*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValueBase*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamTypedRefCount
 */
/**
 * Python function wrapper for:
 * inline TypedReferenceCount *ParamTypedRefCount::get_value(void) const
 */
static PyObject *Dtool_ParamTypedRefCount_get_value_1031(PyObject *self, PyObject *) {
  ParamTypedRefCount *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamTypedRefCount)) {
    return nullptr;
  }
  // 1-inline TypedReferenceCount *ParamTypedRefCount::get_value(void) const
  TypedReferenceCount *return_value = ((*(const ParamTypedRefCount*)local_this).get_value)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ParamTypedRefCount_get_value_1031_comment =
  "C++ Interface:\n"
  "get_value(ParamTypedRefCount self)\n"
  "\n"
  "/**\n"
  " * Retrieves the value stored in the parameter.\n"
  " */";
#else
static const char *Dtool_ParamTypedRefCount_get_value_1031_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamTypedRefCount::get_class_type(void)
 */
static PyObject *Dtool_ParamTypedRefCount_get_class_type_1034(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamTypedRefCount::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamTypedRefCount::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamTypedRefCount_get_class_type_1034_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamTypedRefCount_get_class_type_1034_comment = nullptr;
#endif

static PyObject *Dtool_ParamTypedRefCount_value_Getter(PyObject *self, void *) {
  const ParamTypedRefCount *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamTypedRefCount, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline TypedReferenceCount *ParamTypedRefCount::get_value(void) const
  TypedReferenceCount *return_value = ((*(const ParamTypedRefCount*)local_this).get_value)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

/**
 * Python function wrapper for:
 * inline ParamTypedRefCount::ParamTypedRefCount(TypedReferenceCount const *value)
 */
static int Dtool_Init_ParamTypedRefCount(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamTypedRefCount() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
    // 1-inline ParamTypedRefCount::ParamTypedRefCount(TypedReferenceCount const *value)
    TypedReferenceCount const *arg_this = (TypedReferenceCount *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_TypedReferenceCount, 0, "ParamTypedRefCount.ParamTypedRefCount", true, true);
    if (arg_this != nullptr) {
      ParamTypedRefCount *return_value = new ParamTypedRefCount(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamTypedRefCount, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamTypedRefCount(const TypedReferenceCount value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamTypedRefCount(PyObject *args, CPT(ParamTypedRefCount) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamTypedRefCount)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamTypedRefCount::ParamTypedRefCount(TypedReferenceCount const *value)
    TypedReferenceCount const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypedReferenceCount);
    if (arg_this != nullptr) {
      ParamTypedRefCount *return_value = new ParamTypedRefCount(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamTypedRefCount(PyObject *args, PT(ParamTypedRefCount) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamTypedRefCount)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamTypedRefCount::ParamTypedRefCount(TypedReferenceCount const *value)
    TypedReferenceCount const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_TypedReferenceCount);
    if (arg_this != nullptr) {
      ParamTypedRefCount *return_value = new ParamTypedRefCount(arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamTypedRefCount(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamTypedRefCount) {
    printf("ParamTypedRefCount ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamTypedRefCount *local_this = (ParamTypedRefCount *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamTypedRefCount) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamTypedRefCount(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamTypedRefCount) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamTypedRefCount*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamTypedRefCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamTypedRefCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamTypedRefCount*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamTypedRefCount*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamValue< std::string >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< string >::set_value(std::string const &value)
 */
static PyObject *Dtool_ParamValue_string_set_value_1037(PyObject *self, PyObject *arg) {
  ParamValue< std::string > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_std_string, (void **)&local_this, "ParamValue_std::string.set_value")) {
    return nullptr;
  }
  // 1-inline void ParamValue< string >::set_value(std::string const &value)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_value)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, str value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_string_set_value_1037_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, str value)\n";
#else
static const char *Dtool_ParamValue_string_set_value_1037_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &ParamValue< string >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_string_get_value_1038(PyObject *self, PyObject *) {
  ParamValue< std::string > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamValue_std_string)) {
    return nullptr;
  }
  // 1-inline std::string const &ParamValue< string >::get_value(void) const
  std::string const &return_value = ((*(const ParamValue< std::string >*)local_this).get_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_string_get_value_1038_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_string_get_value_1038_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< string >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_string_get_class_type_1042(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< string >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamValue< std::string >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_string_get_class_type_1042_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_string_get_class_type_1042_comment = nullptr;
#endif

static PyObject *Dtool_ParamValue_std_string_value_Getter(PyObject *self, void *) {
  const ParamValue< std::string > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_std_string, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &ParamValue< string >::get_value(void) const
  std::string const &return_value = ((*(const ParamValue< std::string >*)local_this).get_value)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ParamValue_std_string_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< std::string > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_std_string, (void **)&local_this, "ParamValue_std::string.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< string >::set_value(std::string const &value)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_value)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, str value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< string >::ParamValue(std::string const &value)
 */
static int Dtool_Init_ParamValue_std_string(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
    // 1-inline ParamValue< string >::ParamValue(std::string const &value)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      ParamValue< std::string > *return_value = new ParamValue< std::string >(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_std_string, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(str value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_std_string(PyObject *args, CPT(ParamValue< std::string >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_std_string)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< string >::ParamValue(std::string const &value)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      ParamValue< std::string > *return_value = new ParamValue< std::string >(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_ParamValue_std_string(PyObject *args, PT(ParamValue< std::string >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_std_string)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< string >::ParamValue(std::string const &value)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      ParamValue< std::string > *return_value = new ParamValue< std::string >(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_std_string(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamValue_std_string) {
    printf("ParamValue_std_string ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamValue< std::string > *local_this = (ParamValue< std::string > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamValue_std_string) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamValue_std_string(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamValue_std_string) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< std::string >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< std::string >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< std::string >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< std::string >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< std::string >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamValue< std::wstring >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< wstring >::set_value(std::wstring const &value)
 */
static PyObject *Dtool_ParamValue_wstring_set_value_1046(PyObject *self, PyObject *arg) {
  ParamValue< std::wstring > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_std_wstring, (void **)&local_this, "ParamValue_std::wstring.set_value")) {
    return nullptr;
  }
  // 1-inline void ParamValue< wstring >::set_value(std::wstring const &value)
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
#else
  PyUnicodeObject *param1;
#endif
  if (PyArg_Parse(arg, "U:set_value", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    ((*local_this).set_value)(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, unicode value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_wstring_set_value_1046_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, unicode value)\n";
#else
static const char *Dtool_ParamValue_wstring_set_value_1046_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::wstring const &ParamValue< wstring >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_wstring_get_value_1047(PyObject *self, PyObject *) {
  ParamValue< std::wstring > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamValue_std_wstring)) {
    return nullptr;
  }
  // 1-inline std::wstring const &ParamValue< wstring >::get_value(void) const
  std::wstring const &return_value = ((*(const ParamValue< std::wstring >*)local_this).get_value)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_wstring_get_value_1047_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_wstring_get_value_1047_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< wstring >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_wstring_get_class_type_1049(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< wstring >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamValue< std::wstring >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_wstring_get_class_type_1049_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_wstring_get_class_type_1049_comment = nullptr;
#endif

static PyObject *Dtool_ParamValue_std_wstring_value_Getter(PyObject *self, void *) {
  const ParamValue< std::wstring > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_std_wstring, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::wstring const &ParamValue< wstring >::get_value(void) const
  std::wstring const &return_value = ((*(const ParamValue< std::wstring >*)local_this).get_value)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_ParamValue_std_wstring_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< std::wstring > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_std_wstring, (void **)&local_this, "ParamValue_std::wstring.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< wstring >::set_value(std::wstring const &value)
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
#else
  PyUnicodeObject *param1;
#endif
  if (PyArg_Parse(arg, "U:set_value", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    ((*local_this).set_value)(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, unicode value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< wstring >::ParamValue(std::wstring const &value)
 */
static int Dtool_Init_ParamValue_std_wstring(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
    // 1-inline ParamValue< wstring >::ParamValue(std::wstring const &value)
#if PY_VERSION_HEX >= 0x03020000
    PyObject *param0;
#else
    PyUnicodeObject *param0;
#endif
    if (PyArg_Parse(arg, "U:ParamValue", &param0)) {
#if PY_VERSION_HEX >= 0x03030000
      Py_ssize_t param0_len;
      wchar_t *param0_str = PyUnicode_AsWideCharString(param0, &param0_len);
#else
      Py_ssize_t param0_len = PyUnicode_GET_SIZE(param0);
      wchar_t *param0_str = (wchar_t *)alloca(sizeof(wchar_t) * (param0_len + 1));
      PyUnicode_AsWideChar(param0, param0_str, param0_len);
#endif
      ParamValue< std::wstring > *return_value = new ParamValue< std::wstring >(std::wstring(param0_str, param0_len));
#if PY_VERSION_HEX >= 0x03030000
      PyMem_Free(param0_str);
#endif
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_std_wstring, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(unicode value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_std_wstring(PyObject *args, CPT(ParamValue< std::wstring >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_std_wstring)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< wstring >::ParamValue(std::wstring const &value)
#if PY_VERSION_HEX >= 0x03020000
    PyObject *param0;
#else
    PyUnicodeObject *param0;
#endif
    if (PyArg_Parse(arg, "U:ParamValue", &param0)) {
#if PY_VERSION_HEX >= 0x03030000
      Py_ssize_t param0_len;
      wchar_t *param0_str = PyUnicode_AsWideCharString(param0, &param0_len);
#else
      Py_ssize_t param0_len = PyUnicode_GET_SIZE(param0);
      wchar_t *param0_str = (wchar_t *)alloca(sizeof(wchar_t) * (param0_len + 1));
      PyUnicode_AsWideChar(param0, param0_str, param0_len);
#endif
      ParamValue< std::wstring > *return_value = new ParamValue< std::wstring >(std::wstring(param0_str, param0_len));
#if PY_VERSION_HEX >= 0x03030000
      PyMem_Free(param0_str);
#endif
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_ParamValue_std_wstring(PyObject *args, PT(ParamValue< std::wstring >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_std_wstring)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< wstring >::ParamValue(std::wstring const &value)
#if PY_VERSION_HEX >= 0x03020000
    PyObject *param0;
#else
    PyUnicodeObject *param0;
#endif
    if (PyArg_Parse(arg, "U:ParamValue", &param0)) {
#if PY_VERSION_HEX >= 0x03030000
      Py_ssize_t param0_len;
      wchar_t *param0_str = PyUnicode_AsWideCharString(param0, &param0_len);
#else
      Py_ssize_t param0_len = PyUnicode_GET_SIZE(param0);
      wchar_t *param0_str = (wchar_t *)alloca(sizeof(wchar_t) * (param0_len + 1));
      PyUnicode_AsWideChar(param0, param0_str, param0_len);
#endif
      ParamValue< std::wstring > *return_value = new ParamValue< std::wstring >(std::wstring(param0_str, param0_len));
#if PY_VERSION_HEX >= 0x03030000
      PyMem_Free(param0_str);
#endif
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_std_wstring(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamValue_std_wstring) {
    printf("ParamValue_std_wstring ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamValue< std::wstring > *local_this = (ParamValue< std::wstring > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamValue_std_wstring) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamValue_std_wstring(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamValue_std_wstring) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< std::wstring >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< std::wstring >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< std::wstring >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< std::wstring >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< std::wstring >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase2d >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase2d >::set_value(LVecBase2d const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase2d_set_value_1053(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase2d, (void **)&local_this, "ParamValue_LVecBase2d.set_value")) {
    return nullptr;
  }
  // 1-inline void ParamValue< LVecBase2d >::set_value(LVecBase2d const &value)
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase2d");
  }
  ((*local_this).set_value)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase2d value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2d_set_value_1053_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase2d value)\n";
#else
static const char *Dtool_ParamValue_LVecBase2d_set_value_1053_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2d const &ParamValue< LVecBase2d >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase2d_get_value_1054(PyObject *self, PyObject *) {
  ParamValue< LVecBase2d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamValue_LVecBase2d)) {
    return nullptr;
  }
  // 1-inline LVecBase2d const &ParamValue< LVecBase2d >::get_value(void) const
  LVecBase2d const *return_value = &(((*(const ParamValue< LVecBase2d >*)local_this).get_value)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2d_get_value_1054_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase2d_get_value_1054_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase2d >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase2d_get_class_type_1056(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase2d >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamValue< LVecBase2d >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2d_get_class_type_1056_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase2d_get_class_type_1056_comment = nullptr;
#endif

static PyObject *Dtool_ParamValue_LVecBase2d_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase2d, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase2d const &ParamValue< LVecBase2d >::get_value(void) const
  LVecBase2d const *return_value = &(((*(const ParamValue< LVecBase2d >*)local_this).get_value)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2d, false, true);
}

static int Dtool_ParamValue_LVecBase2d_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase2d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase2d, (void **)&local_this, "ParamValue_LVecBase2d.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase2d >::set_value(LVecBase2d const &value)
  LVecBase2d arg_local;
  LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase2d");
    return -1;
  }
  ((*local_this).set_value)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase2d value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase2d >::ParamValue(LVecBase2d const &value)
 */
static int Dtool_Init_ParamValue_LVecBase2d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
    // 1-inline ParamValue< LVecBase2d >::ParamValue(LVecBase2d const &value)
    LVecBase2d arg_local;
    LVecBase2d const *arg_this = Dtool_Coerce_LVecBase2d(arg, arg_local);
    if (!(arg_this != nullptr)) {
      Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase2d");
      return -1;
    }
    ParamValue< LVecBase2d > *return_value = new ParamValue< LVecBase2d >(*arg_this);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase2d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase2d value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase2d(PyObject *args, CPT(ParamValue< LVecBase2d >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase2d)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase2d >::ParamValue(LVecBase2d const &value)
    LVecBase2d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2d);
    if (arg_this != nullptr) {
      ParamValue< LVecBase2d > *return_value = new ParamValue< LVecBase2d >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase2d(PyObject *args, PT(ParamValue< LVecBase2d >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase2d)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase2d >::ParamValue(LVecBase2d const &value)
    LVecBase2d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2d);
    if (arg_this != nullptr) {
      ParamValue< LVecBase2d > *return_value = new ParamValue< LVecBase2d >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase2d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamValue_LVecBase2d) {
    printf("ParamValue_LVecBase2d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamValue< LVecBase2d > *local_this = (ParamValue< LVecBase2d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamValue_LVecBase2d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase2d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase2d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase2d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase2d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase2f >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase2f >::set_value(LVecBase2f const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase2f_set_value_1060(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase2f, (void **)&local_this, "ParamValue_LVecBase2f.set_value")) {
    return nullptr;
  }
  // 1-inline void ParamValue< LVecBase2f >::set_value(LVecBase2f const &value)
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase2f");
  }
  ((*local_this).set_value)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase2f value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2f_set_value_1060_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase2f value)\n";
#else
static const char *Dtool_ParamValue_LVecBase2f_set_value_1060_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2f const &ParamValue< LVecBase2f >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase2f_get_value_1061(PyObject *self, PyObject *) {
  ParamValue< LVecBase2f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamValue_LVecBase2f)) {
    return nullptr;
  }
  // 1-inline LVecBase2f const &ParamValue< LVecBase2f >::get_value(void) const
  LVecBase2f const *return_value = &(((*(const ParamValue< LVecBase2f >*)local_this).get_value)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2f_get_value_1061_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase2f_get_value_1061_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase2f >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase2f_get_class_type_1063(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase2f >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamValue< LVecBase2f >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2f_get_class_type_1063_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase2f_get_class_type_1063_comment = nullptr;
#endif

static PyObject *Dtool_ParamValue_LVecBase2f_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase2f, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase2f const &ParamValue< LVecBase2f >::get_value(void) const
  LVecBase2f const *return_value = &(((*(const ParamValue< LVecBase2f >*)local_this).get_value)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2f, false, true);
}

static int Dtool_ParamValue_LVecBase2f_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase2f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase2f, (void **)&local_this, "ParamValue_LVecBase2f.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase2f >::set_value(LVecBase2f const &value)
  LVecBase2f arg_local;
  LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase2f");
    return -1;
  }
  ((*local_this).set_value)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase2f value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase2f >::ParamValue(LVecBase2f const &value)
 */
static int Dtool_Init_ParamValue_LVecBase2f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
    // 1-inline ParamValue< LVecBase2f >::ParamValue(LVecBase2f const &value)
    LVecBase2f arg_local;
    LVecBase2f const *arg_this = Dtool_Coerce_LVecBase2f(arg, arg_local);
    if (!(arg_this != nullptr)) {
      Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase2f");
      return -1;
    }
    ParamValue< LVecBase2f > *return_value = new ParamValue< LVecBase2f >(*arg_this);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase2f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase2f value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase2f(PyObject *args, CPT(ParamValue< LVecBase2f >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase2f)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase2f >::ParamValue(LVecBase2f const &value)
    LVecBase2f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2f);
    if (arg_this != nullptr) {
      ParamValue< LVecBase2f > *return_value = new ParamValue< LVecBase2f >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase2f(PyObject *args, PT(ParamValue< LVecBase2f >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase2f)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase2f >::ParamValue(LVecBase2f const &value)
    LVecBase2f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2f);
    if (arg_this != nullptr) {
      ParamValue< LVecBase2f > *return_value = new ParamValue< LVecBase2f >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase2f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamValue_LVecBase2f) {
    printf("ParamValue_LVecBase2f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamValue< LVecBase2f > *local_this = (ParamValue< LVecBase2f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamValue_LVecBase2f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase2f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase2f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase2f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase2f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase2i >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase2i >::set_value(LVecBase2i const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase2i_set_value_1067(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase2i, (void **)&local_this, "ParamValue_LVecBase2i.set_value")) {
    return nullptr;
  }
  // 1-inline void ParamValue< LVecBase2i >::set_value(LVecBase2i const &value)
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase2i");
  }
  ((*local_this).set_value)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase2i value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2i_set_value_1067_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase2i value)\n";
#else
static const char *Dtool_ParamValue_LVecBase2i_set_value_1067_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase2i const &ParamValue< LVecBase2i >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase2i_get_value_1068(PyObject *self, PyObject *) {
  ParamValue< LVecBase2i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamValue_LVecBase2i)) {
    return nullptr;
  }
  // 1-inline LVecBase2i const &ParamValue< LVecBase2i >::get_value(void) const
  LVecBase2i const *return_value = &(((*(const ParamValue< LVecBase2i >*)local_this).get_value)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2i_get_value_1068_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase2i_get_value_1068_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase2i >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase2i_get_class_type_1070(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase2i >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamValue< LVecBase2i >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase2i_get_class_type_1070_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase2i_get_class_type_1070_comment = nullptr;
#endif

static PyObject *Dtool_ParamValue_LVecBase2i_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase2i, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase2i const &ParamValue< LVecBase2i >::get_value(void) const
  LVecBase2i const *return_value = &(((*(const ParamValue< LVecBase2i >*)local_this).get_value)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase2i, false, true);
}

static int Dtool_ParamValue_LVecBase2i_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase2i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase2i, (void **)&local_this, "ParamValue_LVecBase2i.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase2i >::set_value(LVecBase2i const &value)
  LVecBase2i arg_local;
  LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase2i");
    return -1;
  }
  ((*local_this).set_value)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase2i value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase2i >::ParamValue(LVecBase2i const &value)
 */
static int Dtool_Init_ParamValue_LVecBase2i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
    // 1-inline ParamValue< LVecBase2i >::ParamValue(LVecBase2i const &value)
    LVecBase2i arg_local;
    LVecBase2i const *arg_this = Dtool_Coerce_LVecBase2i(arg, arg_local);
    if (!(arg_this != nullptr)) {
      Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase2i");
      return -1;
    }
    ParamValue< LVecBase2i > *return_value = new ParamValue< LVecBase2i >(*arg_this);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase2i, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase2i value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase2i(PyObject *args, CPT(ParamValue< LVecBase2i >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase2i)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase2i >::ParamValue(LVecBase2i const &value)
    LVecBase2i const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2i);
    if (arg_this != nullptr) {
      ParamValue< LVecBase2i > *return_value = new ParamValue< LVecBase2i >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase2i(PyObject *args, PT(ParamValue< LVecBase2i >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase2i)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase2i >::ParamValue(LVecBase2i const &value)
    LVecBase2i const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase2i);
    if (arg_this != nullptr) {
      ParamValue< LVecBase2i > *return_value = new ParamValue< LVecBase2i >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase2i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamValue_LVecBase2i) {
    printf("ParamValue_LVecBase2i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamValue< LVecBase2i > *local_this = (ParamValue< LVecBase2i > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamValue_LVecBase2i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase2i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase2i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase2i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase2i >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase3d >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase3d >::set_value(LVecBase3d const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase3d_set_value_1074(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase3d, (void **)&local_this, "ParamValue_LVecBase3d.set_value")) {
    return nullptr;
  }
  // 1-inline void ParamValue< LVecBase3d >::set_value(LVecBase3d const &value)
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase3d");
  }
  ((*local_this).set_value)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase3d value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3d_set_value_1074_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase3d value)\n";
#else
static const char *Dtool_ParamValue_LVecBase3d_set_value_1074_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3d const &ParamValue< LVecBase3d >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase3d_get_value_1075(PyObject *self, PyObject *) {
  ParamValue< LVecBase3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamValue_LVecBase3d)) {
    return nullptr;
  }
  // 1-inline LVecBase3d const &ParamValue< LVecBase3d >::get_value(void) const
  LVecBase3d const *return_value = &(((*(const ParamValue< LVecBase3d >*)local_this).get_value)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3d_get_value_1075_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase3d_get_value_1075_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase3d >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase3d_get_class_type_1077(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase3d >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamValue< LVecBase3d >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3d_get_class_type_1077_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase3d_get_class_type_1077_comment = nullptr;
#endif

static PyObject *Dtool_ParamValue_LVecBase3d_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase3d, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase3d const &ParamValue< LVecBase3d >::get_value(void) const
  LVecBase3d const *return_value = &(((*(const ParamValue< LVecBase3d >*)local_this).get_value)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3d, false, true);
}

static int Dtool_ParamValue_LVecBase3d_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase3d, (void **)&local_this, "ParamValue_LVecBase3d.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase3d >::set_value(LVecBase3d const &value)
  LVecBase3d arg_local;
  LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase3d");
    return -1;
  }
  ((*local_this).set_value)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase3d value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase3d >::ParamValue(LVecBase3d const &value)
 */
static int Dtool_Init_ParamValue_LVecBase3d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
    // 1-inline ParamValue< LVecBase3d >::ParamValue(LVecBase3d const &value)
    LVecBase3d arg_local;
    LVecBase3d const *arg_this = Dtool_Coerce_LVecBase3d(arg, arg_local);
    if (!(arg_this != nullptr)) {
      Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase3d");
      return -1;
    }
    ParamValue< LVecBase3d > *return_value = new ParamValue< LVecBase3d >(*arg_this);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase3d value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase3d(PyObject *args, CPT(ParamValue< LVecBase3d >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase3d)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase3d >::ParamValue(LVecBase3d const &value)
    LVecBase3d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3d);
    if (arg_this != nullptr) {
      ParamValue< LVecBase3d > *return_value = new ParamValue< LVecBase3d >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase3d(PyObject *args, PT(ParamValue< LVecBase3d >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase3d)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase3d >::ParamValue(LVecBase3d const &value)
    LVecBase3d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3d);
    if (arg_this != nullptr) {
      ParamValue< LVecBase3d > *return_value = new ParamValue< LVecBase3d >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamValue_LVecBase3d) {
    printf("ParamValue_LVecBase3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamValue< LVecBase3d > *local_this = (ParamValue< LVecBase3d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamValue_LVecBase3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase3d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase3f >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase3f >::set_value(LVecBase3f const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase3f_set_value_1081(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase3f, (void **)&local_this, "ParamValue_LVecBase3f.set_value")) {
    return nullptr;
  }
  // 1-inline void ParamValue< LVecBase3f >::set_value(LVecBase3f const &value)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase3f");
  }
  ((*local_this).set_value)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase3f value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3f_set_value_1081_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase3f value)\n";
#else
static const char *Dtool_ParamValue_LVecBase3f_set_value_1081_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3f const &ParamValue< LVecBase3f >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase3f_get_value_1082(PyObject *self, PyObject *) {
  ParamValue< LVecBase3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamValue_LVecBase3f)) {
    return nullptr;
  }
  // 1-inline LVecBase3f const &ParamValue< LVecBase3f >::get_value(void) const
  LVecBase3f const *return_value = &(((*(const ParamValue< LVecBase3f >*)local_this).get_value)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3f_get_value_1082_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase3f_get_value_1082_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase3f >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase3f_get_class_type_1084(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase3f >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamValue< LVecBase3f >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3f_get_class_type_1084_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase3f_get_class_type_1084_comment = nullptr;
#endif

static PyObject *Dtool_ParamValue_LVecBase3f_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase3f, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase3f const &ParamValue< LVecBase3f >::get_value(void) const
  LVecBase3f const *return_value = &(((*(const ParamValue< LVecBase3f >*)local_this).get_value)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3f, false, true);
}

static int Dtool_ParamValue_LVecBase3f_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase3f, (void **)&local_this, "ParamValue_LVecBase3f.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase3f >::set_value(LVecBase3f const &value)
  LVecBase3f arg_local;
  LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase3f");
    return -1;
  }
  ((*local_this).set_value)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase3f value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase3f >::ParamValue(LVecBase3f const &value)
 */
static int Dtool_Init_ParamValue_LVecBase3f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
    // 1-inline ParamValue< LVecBase3f >::ParamValue(LVecBase3f const &value)
    LVecBase3f arg_local;
    LVecBase3f const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if (!(arg_this != nullptr)) {
      Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase3f");
      return -1;
    }
    ParamValue< LVecBase3f > *return_value = new ParamValue< LVecBase3f >(*arg_this);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase3f value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase3f(PyObject *args, CPT(ParamValue< LVecBase3f >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase3f)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase3f >::ParamValue(LVecBase3f const &value)
    LVecBase3f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3f);
    if (arg_this != nullptr) {
      ParamValue< LVecBase3f > *return_value = new ParamValue< LVecBase3f >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase3f(PyObject *args, PT(ParamValue< LVecBase3f >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase3f)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase3f >::ParamValue(LVecBase3f const &value)
    LVecBase3f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3f);
    if (arg_this != nullptr) {
      ParamValue< LVecBase3f > *return_value = new ParamValue< LVecBase3f >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamValue_LVecBase3f) {
    printf("ParamValue_LVecBase3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamValue< LVecBase3f > *local_this = (ParamValue< LVecBase3f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamValue_LVecBase3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase3f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase3i >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase3i >::set_value(LVecBase3i const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase3i_set_value_1088(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase3i, (void **)&local_this, "ParamValue_LVecBase3i.set_value")) {
    return nullptr;
  }
  // 1-inline void ParamValue< LVecBase3i >::set_value(LVecBase3i const &value)
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase3i");
  }
  ((*local_this).set_value)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase3i value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3i_set_value_1088_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase3i value)\n";
#else
static const char *Dtool_ParamValue_LVecBase3i_set_value_1088_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase3i const &ParamValue< LVecBase3i >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase3i_get_value_1089(PyObject *self, PyObject *) {
  ParamValue< LVecBase3i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamValue_LVecBase3i)) {
    return nullptr;
  }
  // 1-inline LVecBase3i const &ParamValue< LVecBase3i >::get_value(void) const
  LVecBase3i const *return_value = &(((*(const ParamValue< LVecBase3i >*)local_this).get_value)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3i_get_value_1089_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase3i_get_value_1089_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase3i >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase3i_get_class_type_1091(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase3i >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamValue< LVecBase3i >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase3i_get_class_type_1091_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase3i_get_class_type_1091_comment = nullptr;
#endif

static PyObject *Dtool_ParamValue_LVecBase3i_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase3i, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase3i const &ParamValue< LVecBase3i >::get_value(void) const
  LVecBase3i const *return_value = &(((*(const ParamValue< LVecBase3i >*)local_this).get_value)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase3i, false, true);
}

static int Dtool_ParamValue_LVecBase3i_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase3i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase3i, (void **)&local_this, "ParamValue_LVecBase3i.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase3i >::set_value(LVecBase3i const &value)
  LVecBase3i arg_local;
  LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase3i");
    return -1;
  }
  ((*local_this).set_value)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase3i value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase3i >::ParamValue(LVecBase3i const &value)
 */
static int Dtool_Init_ParamValue_LVecBase3i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
    // 1-inline ParamValue< LVecBase3i >::ParamValue(LVecBase3i const &value)
    LVecBase3i arg_local;
    LVecBase3i const *arg_this = Dtool_Coerce_LVecBase3i(arg, arg_local);
    if (!(arg_this != nullptr)) {
      Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase3i");
      return -1;
    }
    ParamValue< LVecBase3i > *return_value = new ParamValue< LVecBase3i >(*arg_this);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase3i, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase3i value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase3i(PyObject *args, CPT(ParamValue< LVecBase3i >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase3i)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase3i >::ParamValue(LVecBase3i const &value)
    LVecBase3i const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3i);
    if (arg_this != nullptr) {
      ParamValue< LVecBase3i > *return_value = new ParamValue< LVecBase3i >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase3i(PyObject *args, PT(ParamValue< LVecBase3i >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase3i)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase3i >::ParamValue(LVecBase3i const &value)
    LVecBase3i const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3i);
    if (arg_this != nullptr) {
      ParamValue< LVecBase3i > *return_value = new ParamValue< LVecBase3i >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase3i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamValue_LVecBase3i) {
    printf("ParamValue_LVecBase3i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamValue< LVecBase3i > *local_this = (ParamValue< LVecBase3i > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamValue_LVecBase3i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase3i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase3i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase3i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase3i >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase4d >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase4d >::set_value(LVecBase4d const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase4d_set_value_1095(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase4d, (void **)&local_this, "ParamValue_LVecBase4d.set_value")) {
    return nullptr;
  }
  // 1-inline void ParamValue< LVecBase4d >::set_value(LVecBase4d const &value)
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase4d");
  }
  ((*local_this).set_value)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase4d value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4d_set_value_1095_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase4d value)\n";
#else
static const char *Dtool_ParamValue_LVecBase4d_set_value_1095_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4d const &ParamValue< LVecBase4d >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase4d_get_value_1096(PyObject *self, PyObject *) {
  ParamValue< LVecBase4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamValue_LVecBase4d)) {
    return nullptr;
  }
  // 1-inline LVecBase4d const &ParamValue< LVecBase4d >::get_value(void) const
  LVecBase4d const *return_value = &(((*(const ParamValue< LVecBase4d >*)local_this).get_value)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4d_get_value_1096_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase4d_get_value_1096_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase4d >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase4d_get_class_type_1098(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase4d >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamValue< LVecBase4d >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4d_get_class_type_1098_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase4d_get_class_type_1098_comment = nullptr;
#endif

static PyObject *Dtool_ParamValue_LVecBase4d_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase4d, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase4d const &ParamValue< LVecBase4d >::get_value(void) const
  LVecBase4d const *return_value = &(((*(const ParamValue< LVecBase4d >*)local_this).get_value)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4d, false, true);
}

static int Dtool_ParamValue_LVecBase4d_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase4d, (void **)&local_this, "ParamValue_LVecBase4d.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase4d >::set_value(LVecBase4d const &value)
  LVecBase4d arg_local;
  LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase4d");
    return -1;
  }
  ((*local_this).set_value)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase4d value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase4d >::ParamValue(LVecBase4d const &value)
 */
static int Dtool_Init_ParamValue_LVecBase4d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
    // 1-inline ParamValue< LVecBase4d >::ParamValue(LVecBase4d const &value)
    LVecBase4d arg_local;
    LVecBase4d const *arg_this = Dtool_Coerce_LVecBase4d(arg, arg_local);
    if (!(arg_this != nullptr)) {
      Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase4d");
      return -1;
    }
    ParamValue< LVecBase4d > *return_value = new ParamValue< LVecBase4d >(*arg_this);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase4d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase4d value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase4d(PyObject *args, CPT(ParamValue< LVecBase4d >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase4d)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase4d >::ParamValue(LVecBase4d const &value)
    LVecBase4d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase4d);
    if (arg_this != nullptr) {
      ParamValue< LVecBase4d > *return_value = new ParamValue< LVecBase4d >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase4d(PyObject *args, PT(ParamValue< LVecBase4d >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase4d)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase4d >::ParamValue(LVecBase4d const &value)
    LVecBase4d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase4d);
    if (arg_this != nullptr) {
      ParamValue< LVecBase4d > *return_value = new ParamValue< LVecBase4d >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamValue_LVecBase4d) {
    printf("ParamValue_LVecBase4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamValue< LVecBase4d > *local_this = (ParamValue< LVecBase4d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamValue_LVecBase4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase4d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase4f >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase4f >::set_value(LVecBase4f const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase4f_set_value_1102(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase4f, (void **)&local_this, "ParamValue_LVecBase4f.set_value")) {
    return nullptr;
  }
  // 1-inline void ParamValue< LVecBase4f >::set_value(LVecBase4f const &value)
  LVecBase4f arg_local;
  LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase4f");
  }
  ((*local_this).set_value)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase4f value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4f_set_value_1102_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase4f value)\n";
#else
static const char *Dtool_ParamValue_LVecBase4f_set_value_1102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4f const &ParamValue< LVecBase4f >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase4f_get_value_1103(PyObject *self, PyObject *) {
  ParamValue< LVecBase4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamValue_LVecBase4f)) {
    return nullptr;
  }
  // 1-inline LVecBase4f const &ParamValue< LVecBase4f >::get_value(void) const
  LVecBase4f const *return_value = &(((*(const ParamValue< LVecBase4f >*)local_this).get_value)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4f_get_value_1103_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase4f_get_value_1103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase4f >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase4f_get_class_type_1105(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase4f >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamValue< LVecBase4f >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4f_get_class_type_1105_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase4f_get_class_type_1105_comment = nullptr;
#endif

static PyObject *Dtool_ParamValue_LVecBase4f_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase4f, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase4f const &ParamValue< LVecBase4f >::get_value(void) const
  LVecBase4f const *return_value = &(((*(const ParamValue< LVecBase4f >*)local_this).get_value)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_ParamValue_LVecBase4f_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase4f, (void **)&local_this, "ParamValue_LVecBase4f.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase4f >::set_value(LVecBase4f const &value)
  LVecBase4f arg_local;
  LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase4f");
    return -1;
  }
  ((*local_this).set_value)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase4f value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase4f >::ParamValue(LVecBase4f const &value)
 */
static int Dtool_Init_ParamValue_LVecBase4f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
    // 1-inline ParamValue< LVecBase4f >::ParamValue(LVecBase4f const &value)
    LVecBase4f arg_local;
    LVecBase4f const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if (!(arg_this != nullptr)) {
      Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase4f");
      return -1;
    }
    ParamValue< LVecBase4f > *return_value = new ParamValue< LVecBase4f >(*arg_this);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase4f value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase4f(PyObject *args, CPT(ParamValue< LVecBase4f >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase4f)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase4f >::ParamValue(LVecBase4f const &value)
    LVecBase4f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase4f);
    if (arg_this != nullptr) {
      ParamValue< LVecBase4f > *return_value = new ParamValue< LVecBase4f >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase4f(PyObject *args, PT(ParamValue< LVecBase4f >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase4f)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase4f >::ParamValue(LVecBase4f const &value)
    LVecBase4f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase4f);
    if (arg_this != nullptr) {
      ParamValue< LVecBase4f > *return_value = new ParamValue< LVecBase4f >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamValue_LVecBase4f) {
    printf("ParamValue_LVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamValue< LVecBase4f > *local_this = (ParamValue< LVecBase4f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamValue_LVecBase4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase4f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamValue< LVecBase4i >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LVecBase4i >::set_value(LVecBase4i const &value)
 */
static PyObject *Dtool_ParamValue_LVecBase4i_set_value_1109(PyObject *self, PyObject *arg) {
  ParamValue< LVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase4i, (void **)&local_this, "ParamValue_LVecBase4i.set_value")) {
    return nullptr;
  }
  // 1-inline void ParamValue< LVecBase4i >::set_value(LVecBase4i const &value)
  LVecBase4i arg_local;
  LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase4i");
  }
  ((*local_this).set_value)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase4i value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4i_set_value_1109_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LVecBase4i value)\n";
#else
static const char *Dtool_ParamValue_LVecBase4i_set_value_1109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVecBase4i const &ParamValue< LVecBase4i >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LVecBase4i_get_value_1110(PyObject *self, PyObject *) {
  ParamValue< LVecBase4i > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamValue_LVecBase4i)) {
    return nullptr;
  }
  // 1-inline LVecBase4i const &ParamValue< LVecBase4i >::get_value(void) const
  LVecBase4i const *return_value = &(((*(const ParamValue< LVecBase4i >*)local_this).get_value)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4i_get_value_1110_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LVecBase4i_get_value_1110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LVecBase4i >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LVecBase4i_get_class_type_1112(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LVecBase4i >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamValue< LVecBase4i >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LVecBase4i_get_class_type_1112_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LVecBase4i_get_class_type_1112_comment = nullptr;
#endif

static PyObject *Dtool_ParamValue_LVecBase4i_value_Getter(PyObject *self, void *) {
  const ParamValue< LVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LVecBase4i, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LVecBase4i const &ParamValue< LVecBase4i >::get_value(void) const
  LVecBase4i const *return_value = &(((*(const ParamValue< LVecBase4i >*)local_this).get_value)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4i, false, true);
}

static int Dtool_ParamValue_LVecBase4i_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LVecBase4i > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LVecBase4i, (void **)&local_this, "ParamValue_LVecBase4i.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LVecBase4i >::set_value(LVecBase4i const &value)
  LVecBase4i arg_local;
  LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LVecBase4i");
    return -1;
  }
  ((*local_this).set_value)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LVecBase4i value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LVecBase4i >::ParamValue(LVecBase4i const &value)
 */
static int Dtool_Init_ParamValue_LVecBase4i(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
    // 1-inline ParamValue< LVecBase4i >::ParamValue(LVecBase4i const &value)
    LVecBase4i arg_local;
    LVecBase4i const *arg_this = Dtool_Coerce_LVecBase4i(arg, arg_local);
    if (!(arg_this != nullptr)) {
      Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LVecBase4i");
      return -1;
    }
    ParamValue< LVecBase4i > *return_value = new ParamValue< LVecBase4i >(*arg_this);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LVecBase4i, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LVecBase4i value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LVecBase4i(PyObject *args, CPT(ParamValue< LVecBase4i >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase4i)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase4i >::ParamValue(LVecBase4i const &value)
    LVecBase4i const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase4i);
    if (arg_this != nullptr) {
      ParamValue< LVecBase4i > *return_value = new ParamValue< LVecBase4i >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LVecBase4i(PyObject *args, PT(ParamValue< LVecBase4i >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LVecBase4i)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LVecBase4i >::ParamValue(LVecBase4i const &value)
    LVecBase4i const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase4i);
    if (arg_this != nullptr) {
      ParamValue< LVecBase4i > *return_value = new ParamValue< LVecBase4i >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LVecBase4i(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamValue_LVecBase4i) {
    printf("ParamValue_LVecBase4i ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamValue< LVecBase4i > *local_this = (ParamValue< LVecBase4i > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamValue_LVecBase4i) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamValue_LVecBase4i(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamValue_LVecBase4i) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LVecBase4i >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LVecBase4i >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamValue< LMatrix3d >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LMatrix3d >::set_value(LMatrix3d const &value)
 */
static PyObject *Dtool_ParamValue_LMatrix3d_set_value_1116(PyObject *self, PyObject *arg) {
  ParamValue< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LMatrix3d, (void **)&local_this, "ParamValue_LMatrix3d.set_value")) {
    return nullptr;
  }
  // 1-inline void ParamValue< LMatrix3d >::set_value(LMatrix3d const &value)
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LMatrix3d");
  }
  ((*local_this).set_value)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LMatrix3d value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix3d_set_value_1116_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LMatrix3d value)\n";
#else
static const char *Dtool_ParamValue_LMatrix3d_set_value_1116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3d const &ParamValue< LMatrix3d >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LMatrix3d_get_value_1117(PyObject *self, PyObject *) {
  ParamValue< LMatrix3d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamValue_LMatrix3d)) {
    return nullptr;
  }
  // 1-inline LMatrix3d const &ParamValue< LMatrix3d >::get_value(void) const
  LMatrix3d const *return_value = &(((*(const ParamValue< LMatrix3d >*)local_this).get_value)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix3d_get_value_1117_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LMatrix3d_get_value_1117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LMatrix3d >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LMatrix3d_get_class_type_1119(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LMatrix3d >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamValue< LMatrix3d >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix3d_get_class_type_1119_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LMatrix3d_get_class_type_1119_comment = nullptr;
#endif

static PyObject *Dtool_ParamValue_LMatrix3d_value_Getter(PyObject *self, void *) {
  const ParamValue< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LMatrix3d, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LMatrix3d const &ParamValue< LMatrix3d >::get_value(void) const
  LMatrix3d const *return_value = &(((*(const ParamValue< LMatrix3d >*)local_this).get_value)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3d, false, true);
}

static int Dtool_ParamValue_LMatrix3d_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LMatrix3d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LMatrix3d, (void **)&local_this, "ParamValue_LMatrix3d.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LMatrix3d >::set_value(LMatrix3d const &value)
  LMatrix3d arg_local;
  LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LMatrix3d");
    return -1;
  }
  ((*local_this).set_value)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LMatrix3d value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LMatrix3d >::ParamValue(LMatrix3d const &value)
 */
static int Dtool_Init_ParamValue_LMatrix3d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
    // 1-inline ParamValue< LMatrix3d >::ParamValue(LMatrix3d const &value)
    LMatrix3d arg_local;
    LMatrix3d const *arg_this = Dtool_Coerce_LMatrix3d(arg, arg_local);
    if (!(arg_this != nullptr)) {
      Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LMatrix3d");
      return -1;
    }
    ParamValue< LMatrix3d > *return_value = new ParamValue< LMatrix3d >(*arg_this);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LMatrix3d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LMatrix3d value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LMatrix3d(PyObject *args, CPT(ParamValue< LMatrix3d >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LMatrix3d)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LMatrix3d >::ParamValue(LMatrix3d const &value)
    LMatrix3d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LMatrix3d);
    if (arg_this != nullptr) {
      ParamValue< LMatrix3d > *return_value = new ParamValue< LMatrix3d >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LMatrix3d(PyObject *args, PT(ParamValue< LMatrix3d >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LMatrix3d)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LMatrix3d >::ParamValue(LMatrix3d const &value)
    LMatrix3d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LMatrix3d);
    if (arg_this != nullptr) {
      ParamValue< LMatrix3d > *return_value = new ParamValue< LMatrix3d >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LMatrix3d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamValue_LMatrix3d) {
    printf("ParamValue_LMatrix3d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamValue< LMatrix3d > *local_this = (ParamValue< LMatrix3d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamValue_LMatrix3d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamValue_LMatrix3d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamValue_LMatrix3d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LMatrix3d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LMatrix3d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamValue< LMatrix3f >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LMatrix3f >::set_value(LMatrix3f const &value)
 */
static PyObject *Dtool_ParamValue_LMatrix3f_set_value_1123(PyObject *self, PyObject *arg) {
  ParamValue< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LMatrix3f, (void **)&local_this, "ParamValue_LMatrix3f.set_value")) {
    return nullptr;
  }
  // 1-inline void ParamValue< LMatrix3f >::set_value(LMatrix3f const &value)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LMatrix3f");
  }
  ((*local_this).set_value)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LMatrix3f value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix3f_set_value_1123_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LMatrix3f value)\n";
#else
static const char *Dtool_ParamValue_LMatrix3f_set_value_1123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix3f const &ParamValue< LMatrix3f >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LMatrix3f_get_value_1124(PyObject *self, PyObject *) {
  ParamValue< LMatrix3f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamValue_LMatrix3f)) {
    return nullptr;
  }
  // 1-inline LMatrix3f const &ParamValue< LMatrix3f >::get_value(void) const
  LMatrix3f const *return_value = &(((*(const ParamValue< LMatrix3f >*)local_this).get_value)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix3f_get_value_1124_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LMatrix3f_get_value_1124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LMatrix3f >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LMatrix3f_get_class_type_1126(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LMatrix3f >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamValue< LMatrix3f >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix3f_get_class_type_1126_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LMatrix3f_get_class_type_1126_comment = nullptr;
#endif

static PyObject *Dtool_ParamValue_LMatrix3f_value_Getter(PyObject *self, void *) {
  const ParamValue< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LMatrix3f, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LMatrix3f const &ParamValue< LMatrix3f >::get_value(void) const
  LMatrix3f const *return_value = &(((*(const ParamValue< LMatrix3f >*)local_this).get_value)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix3f, false, true);
}

static int Dtool_ParamValue_LMatrix3f_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LMatrix3f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LMatrix3f, (void **)&local_this, "ParamValue_LMatrix3f.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LMatrix3f >::set_value(LMatrix3f const &value)
  LMatrix3f arg_local;
  LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LMatrix3f");
    return -1;
  }
  ((*local_this).set_value)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LMatrix3f value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LMatrix3f >::ParamValue(LMatrix3f const &value)
 */
static int Dtool_Init_ParamValue_LMatrix3f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
    // 1-inline ParamValue< LMatrix3f >::ParamValue(LMatrix3f const &value)
    LMatrix3f arg_local;
    LMatrix3f const *arg_this = Dtool_Coerce_LMatrix3f(arg, arg_local);
    if (!(arg_this != nullptr)) {
      Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LMatrix3f");
      return -1;
    }
    ParamValue< LMatrix3f > *return_value = new ParamValue< LMatrix3f >(*arg_this);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LMatrix3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LMatrix3f value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LMatrix3f(PyObject *args, CPT(ParamValue< LMatrix3f >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LMatrix3f)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LMatrix3f >::ParamValue(LMatrix3f const &value)
    LMatrix3f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LMatrix3f);
    if (arg_this != nullptr) {
      ParamValue< LMatrix3f > *return_value = new ParamValue< LMatrix3f >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LMatrix3f(PyObject *args, PT(ParamValue< LMatrix3f >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LMatrix3f)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LMatrix3f >::ParamValue(LMatrix3f const &value)
    LMatrix3f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LMatrix3f);
    if (arg_this != nullptr) {
      ParamValue< LMatrix3f > *return_value = new ParamValue< LMatrix3f >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LMatrix3f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamValue_LMatrix3f) {
    printf("ParamValue_LMatrix3f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamValue< LMatrix3f > *local_this = (ParamValue< LMatrix3f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamValue_LMatrix3f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamValue_LMatrix3f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamValue_LMatrix3f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LMatrix3f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LMatrix3f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamValue< LMatrix4d >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LMatrix4d >::set_value(LMatrix4d const &value)
 */
static PyObject *Dtool_ParamValue_LMatrix4d_set_value_1130(PyObject *self, PyObject *arg) {
  ParamValue< LMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LMatrix4d, (void **)&local_this, "ParamValue_LMatrix4d.set_value")) {
    return nullptr;
  }
  // 1-inline void ParamValue< LMatrix4d >::set_value(LMatrix4d const &value)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LMatrix4d");
  }
  ((*local_this).set_value)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LMatrix4d value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix4d_set_value_1130_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LMatrix4d value)\n";
#else
static const char *Dtool_ParamValue_LMatrix4d_set_value_1130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4d const &ParamValue< LMatrix4d >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LMatrix4d_get_value_1131(PyObject *self, PyObject *) {
  ParamValue< LMatrix4d > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamValue_LMatrix4d)) {
    return nullptr;
  }
  // 1-inline LMatrix4d const &ParamValue< LMatrix4d >::get_value(void) const
  LMatrix4d const *return_value = &(((*(const ParamValue< LMatrix4d >*)local_this).get_value)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix4d_get_value_1131_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LMatrix4d_get_value_1131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LMatrix4d >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LMatrix4d_get_class_type_1133(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LMatrix4d >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamValue< LMatrix4d >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix4d_get_class_type_1133_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LMatrix4d_get_class_type_1133_comment = nullptr;
#endif

static PyObject *Dtool_ParamValue_LMatrix4d_value_Getter(PyObject *self, void *) {
  const ParamValue< LMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LMatrix4d, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LMatrix4d const &ParamValue< LMatrix4d >::get_value(void) const
  LMatrix4d const *return_value = &(((*(const ParamValue< LMatrix4d >*)local_this).get_value)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4d, false, true);
}

static int Dtool_ParamValue_LMatrix4d_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LMatrix4d > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LMatrix4d, (void **)&local_this, "ParamValue_LMatrix4d.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LMatrix4d >::set_value(LMatrix4d const &value)
  LMatrix4d arg_local;
  LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LMatrix4d");
    return -1;
  }
  ((*local_this).set_value)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LMatrix4d value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LMatrix4d >::ParamValue(LMatrix4d const &value)
 */
static int Dtool_Init_ParamValue_LMatrix4d(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
    // 1-inline ParamValue< LMatrix4d >::ParamValue(LMatrix4d const &value)
    LMatrix4d arg_local;
    LMatrix4d const *arg_this = Dtool_Coerce_LMatrix4d(arg, arg_local);
    if (!(arg_this != nullptr)) {
      Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LMatrix4d");
      return -1;
    }
    ParamValue< LMatrix4d > *return_value = new ParamValue< LMatrix4d >(*arg_this);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LMatrix4d, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LMatrix4d value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LMatrix4d(PyObject *args, CPT(ParamValue< LMatrix4d >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LMatrix4d)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LMatrix4d >::ParamValue(LMatrix4d const &value)
    LMatrix4d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LMatrix4d);
    if (arg_this != nullptr) {
      ParamValue< LMatrix4d > *return_value = new ParamValue< LMatrix4d >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LMatrix4d(PyObject *args, PT(ParamValue< LMatrix4d >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LMatrix4d)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LMatrix4d >::ParamValue(LMatrix4d const &value)
    LMatrix4d const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LMatrix4d);
    if (arg_this != nullptr) {
      ParamValue< LMatrix4d > *return_value = new ParamValue< LMatrix4d >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LMatrix4d(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamValue_LMatrix4d) {
    printf("ParamValue_LMatrix4d ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamValue< LMatrix4d > *local_this = (ParamValue< LMatrix4d > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamValue_LMatrix4d) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamValue_LMatrix4d(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamValue_LMatrix4d) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LMatrix4d >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LMatrix4d >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ParamValue< LMatrix4f >
 */
/**
 * Python function wrapper for:
 * inline void ParamValue< LMatrix4f >::set_value(LMatrix4f const &value)
 */
static PyObject *Dtool_ParamValue_LMatrix4f_set_value_1137(PyObject *self, PyObject *arg) {
  ParamValue< LMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LMatrix4f, (void **)&local_this, "ParamValue_LMatrix4f.set_value")) {
    return nullptr;
  }
  // 1-inline void ParamValue< LMatrix4f >::set_value(LMatrix4f const &value)
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LMatrix4f");
  }
  ((*local_this).set_value)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LMatrix4f value)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix4f_set_value_1137_comment =
  "C++ Interface:\n"
  "set_value(const ParamValue self, const LMatrix4f value)\n";
#else
static const char *Dtool_ParamValue_LMatrix4f_set_value_1137_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LMatrix4f const &ParamValue< LMatrix4f >::get_value(void) const
 */
static PyObject *Dtool_ParamValue_LMatrix4f_get_value_1138(PyObject *self, PyObject *) {
  ParamValue< LMatrix4f > *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ParamValue_LMatrix4f)) {
    return nullptr;
  }
  // 1-inline LMatrix4f const &ParamValue< LMatrix4f >::get_value(void) const
  LMatrix4f const *return_value = &(((*(const ParamValue< LMatrix4f >*)local_this).get_value)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix4f_get_value_1138_comment =
  "C++ Interface:\n"
  "get_value(ParamValue self)\n";
#else
static const char *Dtool_ParamValue_LMatrix4f_get_value_1138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ParamValue< LMatrix4f >::get_class_type(void)
 */
static PyObject *Dtool_ParamValue_LMatrix4f_get_class_type_1140(PyObject *, PyObject *) {
  // 1-static TypeHandle ParamValue< LMatrix4f >::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ParamValue< LMatrix4f >::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ParamValue_LMatrix4f_get_class_type_1140_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ParamValue_LMatrix4f_get_class_type_1140_comment = nullptr;
#endif

static PyObject *Dtool_ParamValue_LMatrix4f_value_Getter(PyObject *self, void *) {
  const ParamValue< LMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValue_LMatrix4f, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LMatrix4f const &ParamValue< LMatrix4f >::get_value(void) const
  LMatrix4f const *return_value = &(((*(const ParamValue< LMatrix4f >*)local_this).get_value)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, false, true);
}

static int Dtool_ParamValue_LMatrix4f_value_Setter(PyObject *self, PyObject *arg, void *) {
  ParamValue< LMatrix4f > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ParamValue_LMatrix4f, (void **)&local_this, "ParamValue_LMatrix4f.value")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete value attribute");
    return -1;
  }
  // 1-inline void ParamValue< LMatrix4f >::set_value(LMatrix4f const &value)
  LMatrix4f arg_local;
  LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ParamValue.set_value", "LMatrix4f");
    return -1;
  }
  ((*local_this).set_value)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_value(const ParamValue self, const LMatrix4f value)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * inline ParamValue< LMatrix4f >::ParamValue(LMatrix4f const &value)
 */
static int Dtool_Init_ParamValue_LMatrix4f(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ParamValue() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "value")) {
    // 1-inline ParamValue< LMatrix4f >::ParamValue(LMatrix4f const &value)
    LMatrix4f arg_local;
    LMatrix4f const *arg_this = Dtool_Coerce_LMatrix4f(arg, arg_local);
    if (!(arg_this != nullptr)) {
      Dtool_Raise_ArgTypeError(arg, 0, "ParamValue.ParamValue", "LMatrix4f");
      return -1;
    }
    ParamValue< LMatrix4f > *return_value = new ParamValue< LMatrix4f >(*arg_this);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ParamValue_LMatrix4f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ParamValue(const LMatrix4f value)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_ParamValue_LMatrix4f(PyObject *args, CPT(ParamValue< LMatrix4f >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LMatrix4f)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LMatrix4f >::ParamValue(LMatrix4f const &value)
    LMatrix4f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LMatrix4f);
    if (arg_this != nullptr) {
      ParamValue< LMatrix4f > *return_value = new ParamValue< LMatrix4f >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_ParamValue_LMatrix4f(PyObject *args, PT(ParamValue< LMatrix4f >) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_ParamValue_LMatrix4f)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-inline ParamValue< LMatrix4f >::ParamValue(LMatrix4f const &value)
    LMatrix4f const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LMatrix4f);
    if (arg_this != nullptr) {
      ParamValue< LMatrix4f > *return_value = new ParamValue< LMatrix4f >(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_ParamValue_LMatrix4f(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ParamValue_LMatrix4f) {
    printf("ParamValue_LMatrix4f ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ParamValue< LMatrix4f > *local_this = (ParamValue< LMatrix4f > *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ParamValue_LMatrix4f) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ParamValueBase) {
    return (ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(ParamValueBase *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ParamValue_LMatrix4f(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ParamValue_LMatrix4f) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ParamValueBase) {
    ParamValueBase* other_this = (ParamValueBase*)from_this;
    return (ParamValue< LMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ParamValue< LMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ParamValue< LMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ParamValue< LMatrix4f >*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ParamValue< LMatrix4f >*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class WritableConfigurable
 */
/**
 * Python function wrapper for:
 * static TypeHandle WritableConfigurable::get_class_type(void)
 */
static PyObject *Dtool_WritableConfigurable_get_class_type_1148(PyObject *, PyObject *) {
  // 1-static TypeHandle WritableConfigurable::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((WritableConfigurable::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_WritableConfigurable_get_class_type_1148_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_WritableConfigurable_get_class_type_1148_comment = nullptr;
#endif

static int Dtool_Init_WritableConfigurable(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_WritableConfigurable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_WritableConfigurable) {
    printf("WritableConfigurable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  WritableConfigurable *local_this = (WritableConfigurable *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_WritableConfigurable) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_WritableConfigurable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_WritableConfigurable) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (WritableConfigurable*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (WritableConfigurable*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class UniqueIdAllocator
 */
/**
 * Python function wrapper for:
 * uint32_t UniqueIdAllocator::allocate(void)
 */
static PyObject *Dtool_UniqueIdAllocator_allocate_1153(PyObject *self, PyObject *) {
  UniqueIdAllocator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UniqueIdAllocator, (void **)&local_this, "UniqueIdAllocator.allocate")) {
    return nullptr;
  }
  // 1-uint32_t UniqueIdAllocator::allocate(void)
  uint32_t return_value = ((*local_this).allocate)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UniqueIdAllocator_allocate_1153_comment =
  "C++ Interface:\n"
  "allocate(const UniqueIdAllocator self)\n"
  "\n"
  "/**\n"
  " * Returns an id between _min and _max (that were passed to the constructor).\n"
  " * IndexEnd is returned if no ids are available.\n"
  " */";
#else
static const char *Dtool_UniqueIdAllocator_allocate_1153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void UniqueIdAllocator::initial_reserve_id(uint32_t id)
 */
static PyObject *Dtool_UniqueIdAllocator_initial_reserve_id_1154(PyObject *self, PyObject *arg) {
  UniqueIdAllocator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UniqueIdAllocator, (void **)&local_this, "UniqueIdAllocator.initial_reserve_id")) {
    return nullptr;
  }
  // 1-void UniqueIdAllocator::initial_reserve_id(uint32_t id)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).initial_reserve_id)((uint32_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "initial_reserve_id(const UniqueIdAllocator self, int id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UniqueIdAllocator_initial_reserve_id_1154_comment =
  "C++ Interface:\n"
  "initial_reserve_id(const UniqueIdAllocator self, int id)\n"
  "\n"
  "/**\n"
  " * This may be called to mark a particular id as having already been allocated\n"
  " * (for instance, by a prior pass).  The specified id is removed from the\n"
  " * available pool.\n"
  " *\n"
  " * Because of the limitations of this algorithm, this is most efficient when\n"
  " * it is called before the first call to allocate(), and when all the calls to\n"
  " * initial_reserve_id() are made in descending order by id.  However, this is\n"
  " * a performance warning only; if performance is not an issue, any id may be\n"
  " * reserved at any time.\n"
  " */";
#else
static const char *Dtool_UniqueIdAllocator_initial_reserve_id_1154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool UniqueIdAllocator::is_allocated(uint32_t index)
 */
static PyObject *Dtool_UniqueIdAllocator_is_allocated_1155(PyObject *self, PyObject *arg) {
  UniqueIdAllocator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UniqueIdAllocator, (void **)&local_this, "UniqueIdAllocator.is_allocated")) {
    return nullptr;
  }
  // 1-bool UniqueIdAllocator::is_allocated(uint32_t index)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    bool return_value = ((*local_this).is_allocated)((uint32_t)param1);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "is_allocated(const UniqueIdAllocator self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UniqueIdAllocator_is_allocated_1155_comment =
  "C++ Interface:\n"
  "is_allocated(const UniqueIdAllocator self, int index)\n"
  "\n"
  "/**\n"
  " * Checks the allocated state of an index. Returns true for\n"
  " * indices that are currently allocated and in use.\n"
  " */";
#else
static const char *Dtool_UniqueIdAllocator_is_allocated_1155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void UniqueIdAllocator::free(uint32_t index)
 */
static PyObject *Dtool_UniqueIdAllocator_free_1156(PyObject *self, PyObject *arg) {
  UniqueIdAllocator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_UniqueIdAllocator, (void **)&local_this, "UniqueIdAllocator.free")) {
    return nullptr;
  }
  // 1-void UniqueIdAllocator::free(uint32_t index)
  if (PyLongOrInt_Check(arg)) {
    unsigned long param1 = PyLong_AsUnsignedLong(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (param1 > UINT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %lu out of range for unsigned integer",
                          param1);
    }
#endif
    ((*local_this).free)((uint32_t)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "free(const UniqueIdAllocator self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UniqueIdAllocator_free_1156_comment =
  "C++ Interface:\n"
  "free(const UniqueIdAllocator self, int index)\n"
  "\n"
  "/**\n"
  " * Free an allocated index (index must be between _min and _max that were\n"
  " * passed to the constructor).\n"
  " */";
#else
static const char *Dtool_UniqueIdAllocator_free_1156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PN_stdfloat UniqueIdAllocator::fraction_used(void) const
 */
static PyObject *Dtool_UniqueIdAllocator_fraction_used_1157(PyObject *self, PyObject *) {
  UniqueIdAllocator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_UniqueIdAllocator)) {
    return nullptr;
  }
  // 1-PN_stdfloat UniqueIdAllocator::fraction_used(void) const
  PN_stdfloat return_value = ((*(const UniqueIdAllocator*)local_this).fraction_used)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_UniqueIdAllocator_fraction_used_1157_comment =
  "C++ Interface:\n"
  "fraction_used(UniqueIdAllocator self)\n"
  "\n"
  "/**\n"
  " * return the decimal fraction of the pool that is used.  The range is 0 to\n"
  " * 1.0 (e.g.  75% would be 0.75).\n"
  " */";
#else
static const char *Dtool_UniqueIdAllocator_fraction_used_1157_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void UniqueIdAllocator::output(std::ostream &out) const
 */
static PyObject *Dtool_UniqueIdAllocator_output_1158(PyObject *self, PyObject *arg) {
  UniqueIdAllocator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_UniqueIdAllocator)) {
    return nullptr;
  }
  // 1-void UniqueIdAllocator::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "UniqueIdAllocator.output", false, true);
  if (arg_this != nullptr) {
    ((*(const UniqueIdAllocator*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(UniqueIdAllocator self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UniqueIdAllocator_output_1158_comment =
  "C++ Interface:\n"
  "output(UniqueIdAllocator self, ostream out)\n"
  "\n"
  "/**\n"
  " * ...intended for debugging only.\n"
  " */";
#else
static const char *Dtool_UniqueIdAllocator_output_1158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void UniqueIdAllocator::write(std::ostream &out) const
 */
static PyObject *Dtool_UniqueIdAllocator_write_1159(PyObject *self, PyObject *arg) {
  UniqueIdAllocator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_UniqueIdAllocator)) {
    return nullptr;
  }
  // 1-void UniqueIdAllocator::write(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "UniqueIdAllocator.write", false, true);
  if (arg_this != nullptr) {
    ((*(const UniqueIdAllocator*)local_this).write)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(UniqueIdAllocator self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_UniqueIdAllocator_write_1159_comment =
  "C++ Interface:\n"
  "write(UniqueIdAllocator self, ostream out)\n"
  "\n"
  "/**\n"
  " * ...intended for debugging only.\n"
  " */";
#else
static const char *Dtool_UniqueIdAllocator_write_1159_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline UniqueIdAllocator::UniqueIdAllocator(UniqueIdAllocator const &) = default
 * explicit UniqueIdAllocator::UniqueIdAllocator(uint32_t min = 0, uint32_t max = 20)
 */
static int Dtool_Init_UniqueIdAllocator(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-explicit UniqueIdAllocator::UniqueIdAllocator(uint32_t min, uint32_t max)
      UniqueIdAllocator *return_value = new UniqueIdAllocator();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UniqueIdAllocator, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 explicit UniqueIdAllocator::UniqueIdAllocator(uint32_t min, uint32_t max = 20)
        unsigned long param0;
        unsigned long param1 = 20;
        static const char *keyword_list[] = {"min", "max", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "k|k:UniqueIdAllocator", (char **)keyword_list, &param0, &param1)) {
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (param0 > UINT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %lu out of range for unsigned integer",
                         param0);
            return -1;
          }
#endif
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
          if (param1 > UINT_MAX) {
            PyErr_Format(PyExc_OverflowError,
                         "value %lu out of range for unsigned integer",
                         param1);
            return -1;
          }
#endif
          UniqueIdAllocator *return_value = new UniqueIdAllocator((uint32_t)param0, (uint32_t)param1);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UniqueIdAllocator, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline UniqueIdAllocator::UniqueIdAllocator(UniqueIdAllocator const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          UniqueIdAllocator const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_UniqueIdAllocator);
          if (param0_this != nullptr) {
            UniqueIdAllocator *return_value = new UniqueIdAllocator(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_UniqueIdAllocator, true, false);
          }
        }
      }

      // No coercion possible: explicit UniqueIdAllocator::UniqueIdAllocator(uint32_t min, uint32_t max = 20)
      // No coercion possible: inline UniqueIdAllocator::UniqueIdAllocator(UniqueIdAllocator const &) = default
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "UniqueIdAllocator() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "UniqueIdAllocator()\n"
      "UniqueIdAllocator(int min, int max)\n"
      "UniqueIdAllocator(const UniqueIdAllocator param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_UniqueIdAllocator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_UniqueIdAllocator) {
    printf("UniqueIdAllocator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  UniqueIdAllocator *local_this = (UniqueIdAllocator *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_UniqueIdAllocator) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_UniqueIdAllocator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_UniqueIdAllocator) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python method tables for ConstPointerToArray_ushort (ConstPointerToArray_ushort)
 */
static PyMethodDef Dtool_Methods_ConstPointerToArray_ushort[] = {
  {"clear", &Dtool_ConstPointerToArray_ushort_clear_9, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_ushort_clear_9_comment},
  {"get_element", &Dtool_ConstPointerToArray_ushort_get_element_11, METH_O, (const char *)Dtool_ConstPointerToArray_ushort_get_element_11_comment},
  {"getElement", &Dtool_ConstPointerToArray_ushort_get_element_11, METH_O, (const char *)Dtool_ConstPointerToArray_ushort_get_element_11_comment},
  {"get_data", &Dtool_ConstPointerToArray_ushort_get_data_13, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_ushort_get_data_13_comment},
  {"getData", &Dtool_ConstPointerToArray_ushort_get_data_13, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_ushort_get_data_13_comment},
  {"get_subdata", (PyCFunction) &Dtool_ConstPointerToArray_ushort_get_subdata_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_ushort_get_subdata_14_comment},
  {"getSubdata", (PyCFunction) &Dtool_ConstPointerToArray_ushort_get_subdata_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ConstPointerToArray_ushort_get_subdata_14_comment},
  {"get_ref_count", &Dtool_ConstPointerToArray_ushort_get_ref_count_15, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_ushort_get_ref_count_15_comment},
  {"getRefCount", &Dtool_ConstPointerToArray_ushort_get_ref_count_15, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_ushort_get_ref_count_15_comment},
  {"get_node_ref_count", &Dtool_ConstPointerToArray_ushort_get_node_ref_count_16, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_ushort_get_node_ref_count_16_comment},
  {"getNodeRefCount", &Dtool_ConstPointerToArray_ushort_get_node_ref_count_16, METH_NOARGS, (const char *)Dtool_ConstPointerToArray_ushort_get_node_ref_count_16_comment},
  {"count", &Dtool_ConstPointerToArray_ushort_count_17, METH_O, (const char *)Dtool_ConstPointerToArray_ushort_count_17_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_ushort slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_ConstPointerToArray_ushort_getbuffer_18_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  ConstPointerToArray< ushort > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_ushort, (void **)&local_this)) {
    return -1;
  }

  return invoke_extension((const ConstPointerToArray< ushort > *)local_this).__getbuffer__(self, buffer, flags);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_ushort slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_ConstPointerToArray_ushort_releasebuffer_19_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  ConstPointerToArray< ushort > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_ushort, (void **)&local_this)) {
    return;
  }

  invoke_extension((const ConstPointerToArray< ushort > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_ushort slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_ConstPointerToArray_ushort_getitem_12_sq_item(PyObject *self, Py_ssize_t index) {
  ConstPointerToArray< ushort > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_ushort, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "ConstPointerToArray_ushort index out of range");
    return nullptr;
  }
  // 1-ushort const &ConstPointerToArray< ushort >::__getitem__(unsigned long int n) const
  ushort return_value = invoke_extension((const ConstPointerToArray< ushort >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(ConstPointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ConstPointerToArray_ushort slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_ConstPointerToArray_ushort_size_10_sq_length(PyObject *self) {
  ConstPointerToArray< ushort > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ConstPointerToArray_ushort, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_ConstPointerToArray_ushort = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ConstPointerToArray_ushort = {
  &Dtool_ConstPointerToArray_ushort_size_10_sq_length,
  nullptr,
  nullptr,
  &Dtool_ConstPointerToArray_ushort_getitem_12_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ConstPointerToArray_ushort = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ConstPointerToArray_ushort = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_ConstPointerToArray_ushort_getbuffer_18_bf_getbuffer,
  &Dtool_ConstPointerToArray_ushort_releasebuffer_19_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ConstPointerToArray_ushort = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ConstPointerToArray_ushort = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ConstPointerToArray_ushort",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ConstPointerToArray_ushort,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ConstPointerToArray_ushort,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ConstPointerToArray_ushort,
    &Dtool_SequenceMethods_ConstPointerToArray_ushort,
    &Dtool_MappingMethods_ConstPointerToArray_ushort,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ConstPointerToArray_ushort,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ConstPointerToArray_ushort,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ConstPointerToArray_ushort,
    PyType_GenericAlloc,
    Dtool_new_ConstPointerToArray_ushort,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ConstPointerToArray_ushort,
  Dtool_UpcastInterface_ConstPointerToArray_ushort,
  Dtool_DowncastInterface_ConstPointerToArray_ushort,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ConstPointerToArray_ushort,
};

static void Dtool_PyModuleClassInit_ConstPointerToArray_ushort(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_ushort(nullptr);
    Dtool_ConstPointerToArray_ushort._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_ushort);
    Dtool_ConstPointerToArray_ushort._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ConstPointerToArray_ushort._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ConstPointerToArray_ushort) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ConstPointerToArray_ushort)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ConstPointerToArray_ushort);
  }
}

/**
 * Python method tables for PointerToArrayBase_ushort (PointerToArrayBase_ushort)
 */
static PyMethodDef Dtool_Methods_PointerToArrayBase_ushort[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PointerToArrayBase_ushort = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArrayBase_ushort = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArrayBase_ushort = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArrayBase_ushort = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArrayBase_ushort = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArrayBase_ushort = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArrayBase_ushort",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArrayBase_ushort,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArrayBase_ushort,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArrayBase_ushort,
    &Dtool_SequenceMethods_PointerToArrayBase_ushort,
    &Dtool_MappingMethods_PointerToArrayBase_ushort,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArrayBase_ushort,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArrayBase_ushort,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArrayBase_ushort,
    PyType_GenericAlloc,
    Dtool_new_PointerToArrayBase_ushort,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArrayBase_ushort,
  Dtool_UpcastInterface_PointerToArrayBase_ushort,
  Dtool_DowncastInterface_PointerToArrayBase_ushort,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToArrayBase_ushort(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_ushort(nullptr);
    Dtool_PointerToArrayBase_ushort._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_ushort);
    Dtool_PointerToArrayBase_ushort._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArrayBase_ushort._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArrayBase_ushort) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArrayBase_ushort)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArrayBase_ushort);
  }
}

/**
 * Python method tables for PointerToBase_ReferenceCountedVector_ushort (PointerToBase_ReferenceCountedVector_ushort)
 */
static PyMethodDef Dtool_Methods_PointerToBase_ReferenceCountedVector_ushort[] = {
  {"clear", &Dtool_PointerToBase_ReferenceCountedVector_ushort_clear_5, METH_NOARGS, (const char *)Dtool_PointerToBase_ReferenceCountedVector_ushort_clear_5_comment},
  {"output", &Dtool_PointerToBase_ReferenceCountedVector_ushort_output_6, METH_O, (const char *)Dtool_PointerToBase_ReferenceCountedVector_ushort_output_6_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PointerToBase_ReferenceCountedVector_ushort
//////////////////
static PyObject *Dtool_Repr_PointerToBase_ReferenceCountedVector_ushort(PyObject *self) {
  PointerToBase< ReferenceCountedVector< ushort > > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToBase_ReferenceCountedVector_ushort, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_ushort = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_ushort = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_ushort = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_ushort = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_ushort = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToBase_ReferenceCountedVector_ushort = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToBase_ReferenceCountedVector_ushort",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToBase_ReferenceCountedVector_ushort,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToBase_ReferenceCountedVector_ushort,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_ushort,
    &Dtool_NumberMethods_PointerToBase_ReferenceCountedVector_ushort,
    &Dtool_SequenceMethods_PointerToBase_ReferenceCountedVector_ushort,
    &Dtool_MappingMethods_PointerToBase_ReferenceCountedVector_ushort,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_PointerToBase_ReferenceCountedVector_ushort,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToBase_ReferenceCountedVector_ushort,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToBase_ReferenceCountedVector_ushort,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToBase_ReferenceCountedVector_ushort,
    PyType_GenericAlloc,
    Dtool_new_PointerToBase_ReferenceCountedVector_ushort,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_ushort,
  Dtool_UpcastInterface_PointerToBase_ReferenceCountedVector_ushort,
  Dtool_DowncastInterface_PointerToBase_ReferenceCountedVector_ushort,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_ushort(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PointerToVoid != nullptr);
    assert(Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PointerToVoid->_Dtool_ModuleClassInit(nullptr);
    Dtool_PointerToBase_ReferenceCountedVector_ushort._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PointerToVoid);
    Dtool_PointerToBase_ReferenceCountedVector_ushort._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToBase_ReferenceCountedVector_ushort._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_ushort) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToBase_ReferenceCountedVector_ushort)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToBase_ReferenceCountedVector_ushort);
  }
}

/**
 * Python method tables for PointerToArray_ushort (PointerToArray_ushort)
 */
static PyMethodDef Dtool_Methods_PointerToArray_ushort[] = {
  {"empty_array", (PyCFunction) &Dtool_PointerToArray_ushort_empty_array_23, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_ushort_empty_array_23_comment},
  {"emptyArray", (PyCFunction) &Dtool_PointerToArray_ushort_empty_array_23, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_PointerToArray_ushort_empty_array_23_comment},
  {"clear", &Dtool_PointerToArray_ushort_clear_24, METH_NOARGS, (const char *)Dtool_PointerToArray_ushort_clear_24_comment},
  {"push_back", &Dtool_PointerToArray_ushort_push_back_26, METH_O, (const char *)Dtool_PointerToArray_ushort_push_back_26_comment},
  {"pushBack", &Dtool_PointerToArray_ushort_push_back_26, METH_O, (const char *)Dtool_PointerToArray_ushort_push_back_26_comment},
  {"pop_back", &Dtool_PointerToArray_ushort_pop_back_27, METH_NOARGS, (const char *)Dtool_PointerToArray_ushort_pop_back_27_comment},
  {"popBack", &Dtool_PointerToArray_ushort_pop_back_27, METH_NOARGS, (const char *)Dtool_PointerToArray_ushort_pop_back_27_comment},
  {"get_element", &Dtool_PointerToArray_ushort_get_element_28, METH_O, (const char *)Dtool_PointerToArray_ushort_get_element_28_comment},
  {"getElement", &Dtool_PointerToArray_ushort_get_element_28, METH_O, (const char *)Dtool_PointerToArray_ushort_get_element_28_comment},
  {"set_element", (PyCFunction) &Dtool_PointerToArray_ushort_set_element_29, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_ushort_set_element_29_comment},
  {"setElement", (PyCFunction) &Dtool_PointerToArray_ushort_set_element_29, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_ushort_set_element_29_comment},
  {"get_data", &Dtool_PointerToArray_ushort_get_data_32, METH_NOARGS, (const char *)Dtool_PointerToArray_ushort_get_data_32_comment},
  {"getData", &Dtool_PointerToArray_ushort_get_data_32, METH_NOARGS, (const char *)Dtool_PointerToArray_ushort_get_data_32_comment},
  {"set_data", &Dtool_PointerToArray_ushort_set_data_33, METH_O, (const char *)Dtool_PointerToArray_ushort_set_data_33_comment},
  {"setData", &Dtool_PointerToArray_ushort_set_data_33, METH_O, (const char *)Dtool_PointerToArray_ushort_set_data_33_comment},
  {"get_subdata", (PyCFunction) &Dtool_PointerToArray_ushort_get_subdata_34, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_ushort_get_subdata_34_comment},
  {"getSubdata", (PyCFunction) &Dtool_PointerToArray_ushort_get_subdata_34, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_ushort_get_subdata_34_comment},
  {"set_subdata", (PyCFunction) &Dtool_PointerToArray_ushort_set_subdata_35, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_ushort_set_subdata_35_comment},
  {"setSubdata", (PyCFunction) &Dtool_PointerToArray_ushort_set_subdata_35, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PointerToArray_ushort_set_subdata_35_comment},
  {"get_ref_count", &Dtool_PointerToArray_ushort_get_ref_count_36, METH_NOARGS, (const char *)Dtool_PointerToArray_ushort_get_ref_count_36_comment},
  {"getRefCount", &Dtool_PointerToArray_ushort_get_ref_count_36, METH_NOARGS, (const char *)Dtool_PointerToArray_ushort_get_ref_count_36_comment},
  {"get_node_ref_count", &Dtool_PointerToArray_ushort_get_node_ref_count_37, METH_NOARGS, (const char *)Dtool_PointerToArray_ushort_get_node_ref_count_37_comment},
  {"getNodeRefCount", &Dtool_PointerToArray_ushort_get_node_ref_count_37, METH_NOARGS, (const char *)Dtool_PointerToArray_ushort_get_node_ref_count_37_comment},
  {"count", &Dtool_PointerToArray_ushort_count_38, METH_O, (const char *)Dtool_PointerToArray_ushort_count_38_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_ushort slot bf_getbuffer -> __getbuffer__
//////////////////
static int Dtool_PointerToArray_ushort_getbuffer_39_bf_getbuffer(PyObject *self, Py_buffer *buffer, int flags) {
  PointerToArray< ushort > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_ushort, (void **)&local_this)) {
    return -1;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    return invoke_extension(local_this).__getbuffer__(self, buffer, flags);
  } else {
    Dtool_Raise_TypeError("Cannot call PointerToArray_ushort.__getbuffer__() on a const object.");
    return -1;
  }
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_ushort slot bf_releasebuffer -> __releasebuffer__
//////////////////
static void Dtool_PointerToArray_ushort_releasebuffer_40_bf_releasebuffer(PyObject *self, Py_buffer *buffer) {
  PointerToArray< ushort > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_ushort, (void **)&local_this)) {
    return;
  }

  invoke_extension((const PointerToArray< ushort > *)local_this).__releasebuffer__(self, buffer);
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_ushort slot sq_ass_item -> __setitem__
//////////////////
static int Dtool_PointerToArray_ushort_setitem_31_sq_ass_item(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PointerToArray< ushort > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_ushort, (void **)&local_this)) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_ushort index out of range");
    return -1;
  }
  if (arg != nullptr) { // __setitem__
    if (!DtoolInstance_IS_CONST(self)) {
      // 1-void PointerToArray< ushort >::__setitem__(unsigned long int n, ushort const &value)
      if (PyLongOrInt_Check(arg)) {
        long param2 = PyLongOrInt_AS_LONG(arg);
#ifndef NDEBUG
        if (param2 < 0 || param2 > USHRT_MAX) {
          PyErr_Format(PyExc_OverflowError,
                       "value %ld out of range for unsigned short integer",
                       param2);
          return -1;
        }
#endif
        invoke_extension(local_this).__setitem__(index, (ushort)param2);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          Dtool_Raise_AssertionError();
          return -1;
        }
#endif
        return 0;
      }
    } else {
#ifdef NDEBUG
      Dtool_Raise_TypeError("non-const method called on const object");
      return -1;
#else
      Dtool_Raise_TypeError("Cannot call PointerToArray.__setitem__() on a const object.");
      return -1;
#endif
    }
  } else { // __delitem__
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "__setitem__(const PointerToArray self, index, int value)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_ushort slot sq_item -> __getitem__
//////////////////
static PyObject *Dtool_PointerToArray_ushort_getitem_30_sq_item(PyObject *self, Py_ssize_t index) {
  PointerToArray< ushort > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_ushort, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PointerToArray_ushort index out of range");
    return nullptr;
  }
  // 1-ushort const &PointerToArray< ushort >::__getitem__(unsigned long int n) const
  ushort return_value = invoke_extension((const PointerToArray< ushort >*)local_this).__getitem__(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PointerToArray self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PointerToArray_ushort slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PointerToArray_ushort_size_25_sq_length(PyObject *self) {
  PointerToArray< ushort > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PointerToArray_ushort, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

static PyNumberMethods Dtool_NumberMethods_PointerToArray_ushort = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PointerToArray_ushort = {
  &Dtool_PointerToArray_ushort_size_25_sq_length,
  nullptr,
  nullptr,
  &Dtool_PointerToArray_ushort_getitem_30_sq_item,
  nullptr, // sq_slice
  &Dtool_PointerToArray_ushort_setitem_31_sq_ass_item,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PointerToArray_ushort = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PointerToArray_ushort = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  &Dtool_PointerToArray_ushort_getbuffer_39_bf_getbuffer,
  &Dtool_PointerToArray_ushort_releasebuffer_40_bf_releasebuffer,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PointerToArray_ushort = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PointerToArray_ushort = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerToArray_ushort",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerToArray_ushort,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PointerToArray_ushort,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerToArray_ushort,
    &Dtool_SequenceMethods_PointerToArray_ushort,
    &Dtool_MappingMethods_PointerToArray_ushort,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PointerToArray_ushort,
#if PY_VERSION_HEX >= 0x02060000 && PY_VERSION_HEX < 0x03000000
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES | Py_TPFLAGS_HAVE_NEWBUFFER,
#else
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#endif
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerToArray_ushort,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerToArray_ushort,
    PyType_GenericAlloc,
    Dtool_new_PointerToArray_ushort,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerToArray_ushort,
  Dtool_UpcastInterface_PointerToArray_ushort,
  Dtool_DowncastInterface_PointerToArray_ushort,
  nullptr,
  (CoerceFunction)Dtool_Coerce_PointerToArray_ushort,
};

static void Dtool_PyModuleClassInit_PointerToArray_ushort(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PointerToArrayBase_ushort(nullptr);
    Dtool_PointerToArray_ushort._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PointerToArrayBase_ushort);
    Dtool_PointerToArray_ushort._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerToArray_ushort._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerToArray_ushort) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerToArray_ushort)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerToArray_ushort);
  }
}

/**
 * Python method tables for AnimInterface (AnimInterface)
 */
static PyMethodDef Dtool_Methods_AnimInterface[] = {
  {"play", (PyCFunction) &Dtool_AnimInterface_play_44, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimInterface_play_44_comment},
  {"loop", (PyCFunction) &Dtool_AnimInterface_loop_45, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimInterface_loop_45_comment},
  {"pingpong", (PyCFunction) &Dtool_AnimInterface_pingpong_46, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AnimInterface_pingpong_46_comment},
  {"stop", &Dtool_AnimInterface_stop_47, METH_NOARGS, (const char *)Dtool_AnimInterface_stop_47_comment},
  {"pose", &Dtool_AnimInterface_pose_48, METH_O, (const char *)Dtool_AnimInterface_pose_48_comment},
  {"set_play_rate", &Dtool_AnimInterface_set_play_rate_49, METH_O, (const char *)Dtool_AnimInterface_set_play_rate_49_comment},
  {"setPlayRate", &Dtool_AnimInterface_set_play_rate_49, METH_O, (const char *)Dtool_AnimInterface_set_play_rate_49_comment},
  {"get_play_rate", &Dtool_AnimInterface_get_play_rate_50, METH_NOARGS, (const char *)Dtool_AnimInterface_get_play_rate_50_comment},
  {"getPlayRate", &Dtool_AnimInterface_get_play_rate_50, METH_NOARGS, (const char *)Dtool_AnimInterface_get_play_rate_50_comment},
  {"get_frame_rate", &Dtool_AnimInterface_get_frame_rate_51, METH_NOARGS, (const char *)Dtool_AnimInterface_get_frame_rate_51_comment},
  {"getFrameRate", &Dtool_AnimInterface_get_frame_rate_51, METH_NOARGS, (const char *)Dtool_AnimInterface_get_frame_rate_51_comment},
  {"get_num_frames", &Dtool_AnimInterface_get_num_frames_52, METH_NOARGS, (const char *)Dtool_AnimInterface_get_num_frames_52_comment},
  {"getNumFrames", &Dtool_AnimInterface_get_num_frames_52, METH_NOARGS, (const char *)Dtool_AnimInterface_get_num_frames_52_comment},
  {"get_frame", &Dtool_AnimInterface_get_frame_53, METH_NOARGS, (const char *)Dtool_AnimInterface_get_frame_53_comment},
  {"getFrame", &Dtool_AnimInterface_get_frame_53, METH_NOARGS, (const char *)Dtool_AnimInterface_get_frame_53_comment},
  {"get_next_frame", &Dtool_AnimInterface_get_next_frame_54, METH_NOARGS, (const char *)Dtool_AnimInterface_get_next_frame_54_comment},
  {"getNextFrame", &Dtool_AnimInterface_get_next_frame_54, METH_NOARGS, (const char *)Dtool_AnimInterface_get_next_frame_54_comment},
  {"get_frac", &Dtool_AnimInterface_get_frac_55, METH_NOARGS, (const char *)Dtool_AnimInterface_get_frac_55_comment},
  {"getFrac", &Dtool_AnimInterface_get_frac_55, METH_NOARGS, (const char *)Dtool_AnimInterface_get_frac_55_comment},
  {"get_full_frame", &Dtool_AnimInterface_get_full_frame_56, METH_NOARGS, (const char *)Dtool_AnimInterface_get_full_frame_56_comment},
  {"getFullFrame", &Dtool_AnimInterface_get_full_frame_56, METH_NOARGS, (const char *)Dtool_AnimInterface_get_full_frame_56_comment},
  {"get_full_fframe", &Dtool_AnimInterface_get_full_fframe_57, METH_NOARGS, (const char *)Dtool_AnimInterface_get_full_fframe_57_comment},
  {"getFullFframe", &Dtool_AnimInterface_get_full_fframe_57, METH_NOARGS, (const char *)Dtool_AnimInterface_get_full_fframe_57_comment},
  {"is_playing", &Dtool_AnimInterface_is_playing_58, METH_NOARGS, (const char *)Dtool_AnimInterface_is_playing_58_comment},
  {"isPlaying", &Dtool_AnimInterface_is_playing_58, METH_NOARGS, (const char *)Dtool_AnimInterface_is_playing_58_comment},
  {"output", &Dtool_AnimInterface_output_59, METH_O, (const char *)Dtool_AnimInterface_output_59_comment},
  {"get_class_type", &Dtool_AnimInterface_get_class_type_72, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimInterface_get_class_type_72_comment},
  {"getClassType", &Dtool_AnimInterface_get_class_type_72, METH_NOARGS | METH_STATIC, (const char *)Dtool_AnimInterface_get_class_type_72_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     AnimInterface
//////////////////
static PyObject *Dtool_Repr_AnimInterface(PyObject *self) {
  AnimInterface *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_AnimInterface, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_AnimInterface[] = {
  {(char *)"play_rate", &Dtool_AnimInterface_play_rate_Getter, &Dtool_AnimInterface_play_rate_Setter, nullptr, nullptr},
  {(char *)"frame_rate", &Dtool_AnimInterface_frame_rate_Getter, nullptr, nullptr, nullptr},
  {(char *)"num_frames", &Dtool_AnimInterface_num_frames_Getter, nullptr, nullptr, nullptr},
  {(char *)"frame", &Dtool_AnimInterface_frame_Getter, nullptr, nullptr, nullptr},
  {(char *)"next_frame", &Dtool_AnimInterface_next_frame_Getter, nullptr, nullptr, nullptr},
  {(char *)"frac", &Dtool_AnimInterface_frac_Getter, nullptr, nullptr, nullptr},
  {(char *)"full_frame", &Dtool_AnimInterface_full_frame_Getter, nullptr, nullptr, nullptr},
  {(char *)"full_fframe", &Dtool_AnimInterface_full_fframe_Getter, nullptr, nullptr, nullptr},
  {(char *)"playing", &Dtool_AnimInterface_playing_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_AnimInterface = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_AnimInterface = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.AnimInterface",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AnimInterface,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_AnimInterface,
    &Dtool_NumberMethods_AnimInterface,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_AnimInterface,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the fundamental interface for things that have a play/loop/stop\n"
    " * type interface for frame-based animation, such as animated characters.\n"
    " * This is the base class for AnimControl and other, similar classes.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AnimInterface,
    nullptr, // tp_members
    Dtool_Properties_AnimInterface,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AnimInterface,
    PyType_GenericAlloc,
    Dtool_new_AnimInterface,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AnimInterface,
  Dtool_UpcastInterface_AnimInterface,
  Dtool_DowncastInterface_AnimInterface,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AnimInterface(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_AnimInterface._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AnimInterface._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AnimInterface) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AnimInterface)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AnimInterface);
  }
}

/**
 * Python method tables for UpdateSeq (UpdateSeq)
 */
static PyMethodDef Dtool_Methods_UpdateSeq[] = {
  {"initial", &Dtool_UpdateSeq_initial_76, METH_NOARGS | METH_STATIC, (const char *)Dtool_UpdateSeq_initial_76_comment},
  {"old", &Dtool_UpdateSeq_old_77, METH_NOARGS | METH_STATIC, (const char *)Dtool_UpdateSeq_old_77_comment},
  {"fresh", &Dtool_UpdateSeq_fresh_78, METH_NOARGS | METH_STATIC, (const char *)Dtool_UpdateSeq_fresh_78_comment},
  {"assign", &Dtool_UpdateSeq_operator_79, METH_O, (const char *)Dtool_UpdateSeq_operator_79_comment},
  {"clear", &Dtool_UpdateSeq_clear_80, METH_NOARGS, (const char *)Dtool_UpdateSeq_clear_80_comment},
  {"is_initial", &Dtool_UpdateSeq_is_initial_81, METH_NOARGS, (const char *)Dtool_UpdateSeq_is_initial_81_comment},
  {"isInitial", &Dtool_UpdateSeq_is_initial_81, METH_NOARGS, (const char *)Dtool_UpdateSeq_is_initial_81_comment},
  {"is_old", &Dtool_UpdateSeq_is_old_82, METH_NOARGS, (const char *)Dtool_UpdateSeq_is_old_82_comment},
  {"isOld", &Dtool_UpdateSeq_is_old_82, METH_NOARGS, (const char *)Dtool_UpdateSeq_is_old_82_comment},
  {"is_fresh", &Dtool_UpdateSeq_is_fresh_83, METH_NOARGS, (const char *)Dtool_UpdateSeq_is_fresh_83_comment},
  {"isFresh", &Dtool_UpdateSeq_is_fresh_83, METH_NOARGS, (const char *)Dtool_UpdateSeq_is_fresh_83_comment},
  {"is_special", &Dtool_UpdateSeq_is_special_84, METH_NOARGS, (const char *)Dtool_UpdateSeq_is_special_84_comment},
  {"isSpecial", &Dtool_UpdateSeq_is_special_84, METH_NOARGS, (const char *)Dtool_UpdateSeq_is_special_84_comment},
  {"increment", &Dtool_UpdateSeq_operator_91, METH_NOARGS, (const char *)Dtool_UpdateSeq_operator_91_comment},
  {"increment", &Dtool_UpdateSeq_operator_92, METH_O, (const char *)Dtool_UpdateSeq_operator_92_comment},
  {"get_seq", &Dtool_UpdateSeq_get_seq_93, METH_NOARGS, (const char *)Dtool_UpdateSeq_get_seq_93_comment},
  {"getSeq", &Dtool_UpdateSeq_get_seq_93, METH_NOARGS, (const char *)Dtool_UpdateSeq_get_seq_93_comment},
  {"output", &Dtool_UpdateSeq_output_98, METH_O, (const char *)Dtool_UpdateSeq_output_98_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     UpdateSeq
//////////////////
static PyObject *Dtool_Repr_UpdateSeq(PyObject *self) {
  UpdateSeq *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UpdateSeq, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     UpdateSeq
//////////////////
static PyObject *Dtool_RichCompare_UpdateSeq(PyObject *self, PyObject *arg, int op) {
  UpdateSeq *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UpdateSeq, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool UpdateSeq::operator ==(UpdateSeq const &other) const
      UpdateSeq const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_UpdateSeq);
      if (arg_this != nullptr) {
        bool return_value = ((*(const UpdateSeq*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool UpdateSeq::operator !=(UpdateSeq const &other) const
      UpdateSeq const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_UpdateSeq);
      if (arg_this != nullptr) {
        bool return_value = ((*(const UpdateSeq*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool UpdateSeq::operator <(UpdateSeq const &other) const
      UpdateSeq const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_UpdateSeq);
      if (arg_this != nullptr) {
        bool return_value = ((*(const UpdateSeq*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LE:
    {
      // 1-inline bool UpdateSeq::operator <=(UpdateSeq const &other) const
      UpdateSeq const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_UpdateSeq);
      if (arg_this != nullptr) {
        bool return_value = ((*(const UpdateSeq*)local_this).operator <=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_GT:
    {
      // 1-inline bool UpdateSeq::operator >(UpdateSeq const &other) const
      UpdateSeq const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_UpdateSeq);
      if (arg_this != nullptr) {
        bool return_value = ((*(const UpdateSeq*)local_this).operator >)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_GE:
    {
      // 1-inline bool UpdateSeq::operator >=(UpdateSeq const &other) const
      UpdateSeq const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_UpdateSeq);
      if (arg_this != nullptr) {
        bool return_value = ((*(const UpdateSeq*)local_this).operator >=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_UpdateSeq[] = {
  {(char *)"seq", &Dtool_UpdateSeq_seq_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_UpdateSeq = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_UpdateSeq = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.UpdateSeq",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_UpdateSeq,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    &Dtool_Repr_UpdateSeq,
    &Dtool_NumberMethods_UpdateSeq,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Repr_UpdateSeq,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a sequence number that increments monotonically.  It can be used to\n"
    " * track cache updates, or serve as a kind of timestamp for any changing\n"
    " * properties.\n"
    " *\n"
    " * A special class is used instead of simply an int, so we can elegantly\n"
    " * handle such things as wraparound and special cases.  There are two special\n"
    " * cases.  Firstly, a sequence number is 'initial' when it is first created.\n"
    " * This sequence is older than any other sequence number.  Secondly, a\n"
    " * sequence number may be explicitly set to 'old'.  This is older than any\n"
    " * other sequence number except 'initial'.  Finally, we have the explicit\n"
    " * number 'fresh', which is newer than any other sequence number.  All other\n"
    " * sequences are numeric and are monotonically increasing.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_UpdateSeq,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_UpdateSeq,
    nullptr, // tp_members
    Dtool_Properties_UpdateSeq,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_UpdateSeq,
    PyType_GenericAlloc,
    Dtool_new_UpdateSeq,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UpdateSeq,
  Dtool_UpcastInterface_UpdateSeq,
  Dtool_DowncastInterface_UpdateSeq,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_UpdateSeq(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_UpdateSeq._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_UpdateSeq._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_UpdateSeq) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UpdateSeq)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UpdateSeq);
  }
}

/**
 * Python method tables for TypedWritable (TypedWritable)
 */
static PyMethodDef Dtool_Methods_TypedWritable[] = {
  {"fillin", (PyCFunction) &Dtool_TypedWritable_fillin_102, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypedWritable_fillin_102_comment},
  {"mark_bam_modified", &Dtool_TypedWritable_mark_bam_modified_103, METH_NOARGS, (const char *)Dtool_TypedWritable_mark_bam_modified_103_comment},
  {"markBamModified", &Dtool_TypedWritable_mark_bam_modified_103, METH_NOARGS, (const char *)Dtool_TypedWritable_mark_bam_modified_103_comment},
  {"get_bam_modified", &Dtool_TypedWritable_get_bam_modified_104, METH_NOARGS, (const char *)Dtool_TypedWritable_get_bam_modified_104_comment},
  {"getBamModified", &Dtool_TypedWritable_get_bam_modified_104, METH_NOARGS, (const char *)Dtool_TypedWritable_get_bam_modified_104_comment},
  {"__reduce__", &Dtool_TypedWritable_reduce_105, METH_NOARGS, (const char *)Dtool_TypedWritable_reduce_105_comment},
  {"__reduce_persist__", &Dtool_TypedWritable_reduce_persist_106, METH_O, (const char *)Dtool_TypedWritable_reduce_persist_106_comment},
  {"encode_to_bam_stream", (PyCFunction) &Dtool_TypedWritable_encode_to_bam_stream_107, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypedWritable_encode_to_bam_stream_107_comment},
  {"encodeToBamStream", (PyCFunction) &Dtool_TypedWritable_encode_to_bam_stream_107, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_TypedWritable_encode_to_bam_stream_107_comment},
  {"get_class_type", &Dtool_TypedWritable_get_class_type_109, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedWritable_get_class_type_109_comment},
  {"getClassType", &Dtool_TypedWritable_get_class_type_109, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedWritable_get_class_type_109_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TypedWritable = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TypedWritable = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TypedWritable = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TypedWritable = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TypedWritable = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TypedWritable = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TypedWritable",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TypedWritable,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TypedWritable,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TypedWritable,
    &Dtool_SequenceMethods_TypedWritable,
    &Dtool_MappingMethods_TypedWritable,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TypedWritable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Base class for objects that can be written to and read from Bam files.\n"
    " *\n"
    " * See also TypedObject for detailed instructions.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TypedWritable,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TypedWritable,
    PyType_GenericAlloc,
    Dtool_new_TypedWritable,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TypedWritable,
  Dtool_UpcastInterface_TypedWritable,
  Dtool_DowncastInterface_TypedWritable,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TypedWritable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != nullptr);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_TypedWritable._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    Dtool_TypedWritable._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TypedWritable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TypedWritable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TypedWritable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TypedWritable);
  }
}

/**
 * Python method tables for TypedWritableReferenceCount (TypedWritableReferenceCount)
 */
static PyMethodDef Dtool_Methods_TypedWritableReferenceCount[] = {
  {"decode_from_bam_stream", (PyCFunction) &Dtool_TypedWritableReferenceCount_decode_from_bam_stream_116, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TypedWritableReferenceCount_decode_from_bam_stream_116_comment},
  {"decodeFromBamStream", (PyCFunction) &Dtool_TypedWritableReferenceCount_decode_from_bam_stream_116, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_TypedWritableReferenceCount_decode_from_bam_stream_116_comment},
  {"get_class_type", &Dtool_TypedWritableReferenceCount_get_class_type_117, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedWritableReferenceCount_get_class_type_117_comment},
  {"getClassType", &Dtool_TypedWritableReferenceCount_get_class_type_117, METH_NOARGS | METH_STATIC, (const char *)Dtool_TypedWritableReferenceCount_get_class_type_117_comment},
  {"upcast_to_TypedWritable", &Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_111, METH_NOARGS, (const char *)Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_111_comment},
  {"upcastToTypedWritable", &Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_111, METH_NOARGS, (const char *)Dtool_TypedWritableReferenceCount_upcast_to_TypedWritable_111_comment},
  {"upcast_to_ReferenceCount", &Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_114, METH_NOARGS, (const char *)Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_114_comment},
  {"upcastToReferenceCount", &Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_114, METH_NOARGS, (const char *)Dtool_TypedWritableReferenceCount_upcast_to_ReferenceCount_114_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TypedWritableReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_TypedWritableReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_TypedWritableReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_TypedWritableReferenceCount = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_TypedWritableReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TypedWritableReferenceCount",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TypedWritableReferenceCount,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_TypedWritableReferenceCount,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TypedWritableReferenceCount,
    &Dtool_SequenceMethods_TypedWritableReferenceCount,
    &Dtool_MappingMethods_TypedWritableReferenceCount,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_TypedWritableReferenceCount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A base class for things which need to inherit from both TypedWritable and\n"
    " * from ReferenceCount.  It's convenient to define this intermediate base\n"
    " * class instead of multiply inheriting from the two classes each time they\n"
    " * are needed, so that we can sensibly pass around pointers to things which\n"
    " * are both TypedWritables and ReferenceCounters.\n"
    " *\n"
    " * See also TypedObject for detailed instructions.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TypedWritableReferenceCount,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TypedWritableReferenceCount,
    PyType_GenericAlloc,
    Dtool_new_TypedWritableReferenceCount,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TypedWritableReferenceCount,
  Dtool_UpcastInterface_TypedWritableReferenceCount,
  Dtool_DowncastInterface_TypedWritableReferenceCount,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TypedWritableReferenceCount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedWritable(nullptr);
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_TypedWritableReferenceCount._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)&Dtool_TypedWritable, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_TypedWritableReferenceCount._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TypedWritableReferenceCount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TypedWritableReferenceCount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TypedWritableReferenceCount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TypedWritableReferenceCount);
  }
}

/**
 * Python method tables for BamCacheRecord (BamCacheRecord)
 */
static PyMethodDef Dtool_Methods_BamCacheRecord[] = {
  {"make_copy", &Dtool_BamCacheRecord_make_copy_126, METH_NOARGS, (const char *)Dtool_BamCacheRecord_make_copy_126_comment},
  {"makeCopy", &Dtool_BamCacheRecord_make_copy_126, METH_NOARGS, (const char *)Dtool_BamCacheRecord_make_copy_126_comment},
  {"get_source_pathname", &Dtool_BamCacheRecord_get_source_pathname_128, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_source_pathname_128_comment},
  {"getSourcePathname", &Dtool_BamCacheRecord_get_source_pathname_128, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_source_pathname_128_comment},
  {"get_cache_filename", &Dtool_BamCacheRecord_get_cache_filename_129, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_cache_filename_129_comment},
  {"getCacheFilename", &Dtool_BamCacheRecord_get_cache_filename_129, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_cache_filename_129_comment},
  {"get_source_timestamp", &Dtool_BamCacheRecord_get_source_timestamp_130, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_source_timestamp_130_comment},
  {"getSourceTimestamp", &Dtool_BamCacheRecord_get_source_timestamp_130, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_source_timestamp_130_comment},
  {"get_recorded_time", &Dtool_BamCacheRecord_get_recorded_time_131, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_recorded_time_131_comment},
  {"getRecordedTime", &Dtool_BamCacheRecord_get_recorded_time_131, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_recorded_time_131_comment},
  {"get_num_dependent_files", &Dtool_BamCacheRecord_get_num_dependent_files_139, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_num_dependent_files_139_comment},
  {"getNumDependentFiles", &Dtool_BamCacheRecord_get_num_dependent_files_139, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_num_dependent_files_139_comment},
  {"get_dependent_pathname", &Dtool_BamCacheRecord_get_dependent_pathname_140, METH_O, (const char *)Dtool_BamCacheRecord_get_dependent_pathname_140_comment},
  {"getDependentPathname", &Dtool_BamCacheRecord_get_dependent_pathname_140, METH_O, (const char *)Dtool_BamCacheRecord_get_dependent_pathname_140_comment},
  {"dependents_unchanged", &Dtool_BamCacheRecord_dependents_unchanged_141, METH_NOARGS, (const char *)Dtool_BamCacheRecord_dependents_unchanged_141_comment},
  {"dependentsUnchanged", &Dtool_BamCacheRecord_dependents_unchanged_141, METH_NOARGS, (const char *)Dtool_BamCacheRecord_dependents_unchanged_141_comment},
  {"clear_dependent_files", &Dtool_BamCacheRecord_clear_dependent_files_142, METH_NOARGS, (const char *)Dtool_BamCacheRecord_clear_dependent_files_142_comment},
  {"clearDependentFiles", &Dtool_BamCacheRecord_clear_dependent_files_142, METH_NOARGS, (const char *)Dtool_BamCacheRecord_clear_dependent_files_142_comment},
  {"add_dependent_file", &Dtool_BamCacheRecord_add_dependent_file_143, METH_O, (const char *)Dtool_BamCacheRecord_add_dependent_file_143_comment},
  {"addDependentFile", &Dtool_BamCacheRecord_add_dependent_file_143, METH_O, (const char *)Dtool_BamCacheRecord_add_dependent_file_143_comment},
  {"has_data", &Dtool_BamCacheRecord_has_data_144, METH_NOARGS, (const char *)Dtool_BamCacheRecord_has_data_144_comment},
  {"hasData", &Dtool_BamCacheRecord_has_data_144, METH_NOARGS, (const char *)Dtool_BamCacheRecord_has_data_144_comment},
  {"clear_data", &Dtool_BamCacheRecord_clear_data_145, METH_NOARGS, (const char *)Dtool_BamCacheRecord_clear_data_145_comment},
  {"clearData", &Dtool_BamCacheRecord_clear_data_145, METH_NOARGS, (const char *)Dtool_BamCacheRecord_clear_data_145_comment},
  {"get_data", &Dtool_BamCacheRecord_get_data_146, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_data_146_comment},
  {"getData", &Dtool_BamCacheRecord_get_data_146, METH_NOARGS, (const char *)Dtool_BamCacheRecord_get_data_146_comment},
  {"set_data", (PyCFunction) &Dtool_BamCacheRecord_set_data_148, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamCacheRecord_set_data_148_comment},
  {"setData", (PyCFunction) &Dtool_BamCacheRecord_set_data_148, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamCacheRecord_set_data_148_comment},
  {"output", &Dtool_BamCacheRecord_output_151, METH_O, (const char *)Dtool_BamCacheRecord_output_151_comment},
  {"write", (PyCFunction) &Dtool_BamCacheRecord_write_152, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamCacheRecord_write_152_comment},
  {"get_class_type", &Dtool_BamCacheRecord_get_class_type_153, METH_NOARGS | METH_STATIC, (const char *)Dtool_BamCacheRecord_get_class_type_153_comment},
  {"getClassType", &Dtool_BamCacheRecord_get_class_type_153, METH_NOARGS | METH_STATIC, (const char *)Dtool_BamCacheRecord_get_class_type_153_comment},
  {"upcast_to_TypedWritableReferenceCount", &Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_120, METH_NOARGS, (const char *)Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_120_comment},
  {"upcastToTypedWritableReferenceCount", &Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_120, METH_NOARGS, (const char *)Dtool_BamCacheRecord_upcast_to_TypedWritableReferenceCount_120_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     BamCacheRecord
//////////////////
static PyObject *Dtool_Repr_BamCacheRecord(PyObject *self) {
  BamCacheRecord *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BamCacheRecord
//////////////////
static PyObject *Dtool_Str_BamCacheRecord(PyObject *self) {
  BamCacheRecord *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     BamCacheRecord
//////////////////
static PyObject *Dtool_RichCompare_BamCacheRecord(PyObject *self, PyObject *arg, int op) {
  BamCacheRecord *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BamCacheRecord, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool BamCacheRecord::operator ==(BamCacheRecord const &other) const
      BamCacheRecord const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_BamCacheRecord);
      if (arg_this != nullptr) {
        bool return_value = ((*(const BamCacheRecord*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_BamCacheRecord[] = {
  {(char *)"source_pathname", &Dtool_BamCacheRecord_source_pathname_Getter, nullptr, nullptr, nullptr},
  {(char *)"cache_filename", &Dtool_BamCacheRecord_cache_filename_Getter, nullptr, nullptr, nullptr},
  {(char *)"source_timestamp", &Dtool_BamCacheRecord_source_timestamp_Getter, nullptr, nullptr, nullptr},
  {(char *)"recorded_time", &Dtool_BamCacheRecord_recorded_time_Getter, nullptr, nullptr, nullptr},
  {(char *)"data", &Dtool_BamCacheRecord_data_Getter, &Dtool_BamCacheRecord_data_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_BamCacheRecord = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BamCacheRecord = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BamCacheRecord = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BamCacheRecord = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BamCacheRecord = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BamCacheRecord = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BamCacheRecord",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BamCacheRecord,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BamCacheRecord,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    &Dtool_Repr_BamCacheRecord,
    &Dtool_NumberMethods_BamCacheRecord,
    &Dtool_SequenceMethods_BamCacheRecord,
    &Dtool_MappingMethods_BamCacheRecord,
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_BamCacheRecord,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BamCacheRecord,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * An instance of this class is written to the front of a Bam or Txo file to\n"
    " * make the file a cached instance of some other loadable resource.  This\n"
    " * record contains information needed to test the validity of the cache.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_BamCacheRecord,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BamCacheRecord,
    nullptr, // tp_members
    Dtool_Properties_BamCacheRecord,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BamCacheRecord,
    PyType_GenericAlloc,
    Dtool_new_BamCacheRecord,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BamCacheRecord,
  Dtool_UpcastInterface_BamCacheRecord,
  Dtool_DowncastInterface_BamCacheRecord,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BamCacheRecord(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedWritableReferenceCount(nullptr);
    Dtool_BamCacheRecord._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TypedWritableReferenceCount);
    Dtool_BamCacheRecord._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BamCacheRecord._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BamCacheRecord) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BamCacheRecord)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BamCacheRecord);
  }
}

/**
 * Python method tables for BamCache (BamCache)
 */
static PyMethodDef Dtool_Methods_BamCache[] = {
  {"set_active", &Dtool_BamCache_set_active_157, METH_O, (const char *)Dtool_BamCache_set_active_157_comment},
  {"setActive", &Dtool_BamCache_set_active_157, METH_O, (const char *)Dtool_BamCache_set_active_157_comment},
  {"get_active", &Dtool_BamCache_get_active_158, METH_NOARGS, (const char *)Dtool_BamCache_get_active_158_comment},
  {"getActive", &Dtool_BamCache_get_active_158, METH_NOARGS, (const char *)Dtool_BamCache_get_active_158_comment},
  {"set_cache_models", &Dtool_BamCache_set_cache_models_159, METH_O, (const char *)Dtool_BamCache_set_cache_models_159_comment},
  {"setCacheModels", &Dtool_BamCache_set_cache_models_159, METH_O, (const char *)Dtool_BamCache_set_cache_models_159_comment},
  {"get_cache_models", &Dtool_BamCache_get_cache_models_160, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_models_160_comment},
  {"getCacheModels", &Dtool_BamCache_get_cache_models_160, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_models_160_comment},
  {"set_cache_textures", &Dtool_BamCache_set_cache_textures_161, METH_O, (const char *)Dtool_BamCache_set_cache_textures_161_comment},
  {"setCacheTextures", &Dtool_BamCache_set_cache_textures_161, METH_O, (const char *)Dtool_BamCache_set_cache_textures_161_comment},
  {"get_cache_textures", &Dtool_BamCache_get_cache_textures_162, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_textures_162_comment},
  {"getCacheTextures", &Dtool_BamCache_get_cache_textures_162, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_textures_162_comment},
  {"set_cache_compressed_textures", &Dtool_BamCache_set_cache_compressed_textures_163, METH_O, (const char *)Dtool_BamCache_set_cache_compressed_textures_163_comment},
  {"setCacheCompressedTextures", &Dtool_BamCache_set_cache_compressed_textures_163, METH_O, (const char *)Dtool_BamCache_set_cache_compressed_textures_163_comment},
  {"get_cache_compressed_textures", &Dtool_BamCache_get_cache_compressed_textures_164, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_compressed_textures_164_comment},
  {"getCacheCompressedTextures", &Dtool_BamCache_get_cache_compressed_textures_164, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_compressed_textures_164_comment},
  {"set_cache_compiled_shaders", &Dtool_BamCache_set_cache_compiled_shaders_165, METH_O, (const char *)Dtool_BamCache_set_cache_compiled_shaders_165_comment},
  {"setCacheCompiledShaders", &Dtool_BamCache_set_cache_compiled_shaders_165, METH_O, (const char *)Dtool_BamCache_set_cache_compiled_shaders_165_comment},
  {"get_cache_compiled_shaders", &Dtool_BamCache_get_cache_compiled_shaders_166, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_compiled_shaders_166_comment},
  {"getCacheCompiledShaders", &Dtool_BamCache_get_cache_compiled_shaders_166, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_compiled_shaders_166_comment},
  {"set_root", &Dtool_BamCache_set_root_167, METH_O, (const char *)Dtool_BamCache_set_root_167_comment},
  {"setRoot", &Dtool_BamCache_set_root_167, METH_O, (const char *)Dtool_BamCache_set_root_167_comment},
  {"get_root", &Dtool_BamCache_get_root_168, METH_NOARGS, (const char *)Dtool_BamCache_get_root_168_comment},
  {"getRoot", &Dtool_BamCache_get_root_168, METH_NOARGS, (const char *)Dtool_BamCache_get_root_168_comment},
  {"set_flush_time", &Dtool_BamCache_set_flush_time_169, METH_O, (const char *)Dtool_BamCache_set_flush_time_169_comment},
  {"setFlushTime", &Dtool_BamCache_set_flush_time_169, METH_O, (const char *)Dtool_BamCache_set_flush_time_169_comment},
  {"get_flush_time", &Dtool_BamCache_get_flush_time_170, METH_NOARGS, (const char *)Dtool_BamCache_get_flush_time_170_comment},
  {"getFlushTime", &Dtool_BamCache_get_flush_time_170, METH_NOARGS, (const char *)Dtool_BamCache_get_flush_time_170_comment},
  {"set_cache_max_kbytes", &Dtool_BamCache_set_cache_max_kbytes_171, METH_O, (const char *)Dtool_BamCache_set_cache_max_kbytes_171_comment},
  {"setCacheMaxKbytes", &Dtool_BamCache_set_cache_max_kbytes_171, METH_O, (const char *)Dtool_BamCache_set_cache_max_kbytes_171_comment},
  {"get_cache_max_kbytes", &Dtool_BamCache_get_cache_max_kbytes_172, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_max_kbytes_172_comment},
  {"getCacheMaxKbytes", &Dtool_BamCache_get_cache_max_kbytes_172, METH_NOARGS, (const char *)Dtool_BamCache_get_cache_max_kbytes_172_comment},
  {"set_read_only", &Dtool_BamCache_set_read_only_173, METH_O, (const char *)Dtool_BamCache_set_read_only_173_comment},
  {"setReadOnly", &Dtool_BamCache_set_read_only_173, METH_O, (const char *)Dtool_BamCache_set_read_only_173_comment},
  {"get_read_only", &Dtool_BamCache_get_read_only_174, METH_NOARGS, (const char *)Dtool_BamCache_get_read_only_174_comment},
  {"getReadOnly", &Dtool_BamCache_get_read_only_174, METH_NOARGS, (const char *)Dtool_BamCache_get_read_only_174_comment},
  {"lookup", (PyCFunction) &Dtool_BamCache_lookup_175, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamCache_lookup_175_comment},
  {"store", &Dtool_BamCache_store_176, METH_O, (const char *)Dtool_BamCache_store_176_comment},
  {"consider_flush_index", &Dtool_BamCache_consider_flush_index_177, METH_NOARGS, (const char *)Dtool_BamCache_consider_flush_index_177_comment},
  {"considerFlushIndex", &Dtool_BamCache_consider_flush_index_177, METH_NOARGS, (const char *)Dtool_BamCache_consider_flush_index_177_comment},
  {"flush_index", &Dtool_BamCache_flush_index_178, METH_NOARGS, (const char *)Dtool_BamCache_flush_index_178_comment},
  {"flushIndex", &Dtool_BamCache_flush_index_178, METH_NOARGS, (const char *)Dtool_BamCache_flush_index_178_comment},
  {"list_index", (PyCFunction) &Dtool_BamCache_list_index_179, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamCache_list_index_179_comment},
  {"listIndex", (PyCFunction) &Dtool_BamCache_list_index_179, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamCache_list_index_179_comment},
  {"get_global_ptr", &Dtool_BamCache_get_global_ptr_180, METH_NOARGS | METH_STATIC, (const char *)Dtool_BamCache_get_global_ptr_180_comment},
  {"getGlobalPtr", &Dtool_BamCache_get_global_ptr_180, METH_NOARGS | METH_STATIC, (const char *)Dtool_BamCache_get_global_ptr_180_comment},
  {"consider_flush_global_index", &Dtool_BamCache_consider_flush_global_index_181, METH_NOARGS | METH_STATIC, (const char *)Dtool_BamCache_consider_flush_global_index_181_comment},
  {"considerFlushGlobalIndex", &Dtool_BamCache_consider_flush_global_index_181, METH_NOARGS | METH_STATIC, (const char *)Dtool_BamCache_consider_flush_global_index_181_comment},
  {"flush_global_index", &Dtool_BamCache_flush_global_index_182, METH_NOARGS | METH_STATIC, (const char *)Dtool_BamCache_flush_global_index_182_comment},
  {"flushGlobalIndex", &Dtool_BamCache_flush_global_index_182, METH_NOARGS | METH_STATIC, (const char *)Dtool_BamCache_flush_global_index_182_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_BamCache[] = {
  {(char *)"active", &Dtool_BamCache_active_Getter, &Dtool_BamCache_active_Setter, nullptr, nullptr},
  {(char *)"cache_models", &Dtool_BamCache_cache_models_Getter, &Dtool_BamCache_cache_models_Setter, nullptr, nullptr},
  {(char *)"cache_textures", &Dtool_BamCache_cache_textures_Getter, &Dtool_BamCache_cache_textures_Setter, nullptr, nullptr},
  {(char *)"cache_compressed_textures", &Dtool_BamCache_cache_compressed_textures_Getter, &Dtool_BamCache_cache_compressed_textures_Setter, nullptr, nullptr},
  {(char *)"cache_compiled_shaders", &Dtool_BamCache_cache_compiled_shaders_Getter, &Dtool_BamCache_cache_compiled_shaders_Setter, nullptr, nullptr},
  {(char *)"root", &Dtool_BamCache_root_Getter, &Dtool_BamCache_root_Setter, nullptr, nullptr},
  {(char *)"flush_time", &Dtool_BamCache_flush_time_Getter, &Dtool_BamCache_flush_time_Setter, nullptr, nullptr},
  {(char *)"cache_max_kbytes", &Dtool_BamCache_cache_max_kbytes_Getter, &Dtool_BamCache_cache_max_kbytes_Setter, nullptr, nullptr},
  {(char *)"read_only", &Dtool_BamCache_read_only_Getter, &Dtool_BamCache_read_only_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_BamCache = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_BamCache = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BamCache",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BamCache,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BamCache,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class maintains a cache of Bam and/or Txo objects generated from model\n"
    " * files and texture images (as well as possibly other kinds of loadable\n"
    " * objects that can be stored in bam file format).\n"
    " *\n"
    " * This class also maintains a persistent index that lists all of the cached\n"
    " * objects (see BamCacheIndex). We go through some considerable effort to make\n"
    " * sure this index gets saved correctly to disk, even in the presence of\n"
    " * multiple different processes writing to the same index, and without relying\n"
    " * too heavily on low-level os-provided file locks (which work poorly with C++\n"
    " * iostreams).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BamCache,
    nullptr, // tp_members
    Dtool_Properties_BamCache,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BamCache,
    PyType_GenericAlloc,
    Dtool_new_BamCache,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BamCache,
  Dtool_UpcastInterface_BamCache,
  Dtool_DowncastInterface_BamCache,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BamCache(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_BamCache._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BamCache._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BamCache) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BamCache)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BamCache);
  }
}

/**
 * Python method tables for BamEnums (BamEnums)
 */
static PyMethodDef Dtool_Methods_BamEnums[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_BamEnums = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_BamEnums = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BamEnums",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BamEnums,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BamEnums,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class exists just to provide scoping for the enums shared by BamReader\n"
    " * and BamWriter.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BamEnums,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BamEnums,
    PyType_GenericAlloc,
    Dtool_new_BamEnums,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BamEnums,
  Dtool_UpcastInterface_BamEnums,
  Dtool_DowncastInterface_BamEnums,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BamEnums(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_BamEnums._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(27);
    Dtool_BamEnums._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum BamEnums::BamEndian;
    PyDict_SetItemString(dict, "BE_bigendian", Dtool_WrapValue(BamEnums::BE_bigendian));
    PyDict_SetItemString(dict, "BEBigendian", Dtool_WrapValue(BamEnums::BE_bigendian));
    PyDict_SetItemString(dict, "BE_littleendian", Dtool_WrapValue(BamEnums::BE_littleendian));
    PyDict_SetItemString(dict, "BELittleendian", Dtool_WrapValue(BamEnums::BE_littleendian));
    PyDict_SetItemString(dict, "BE_native", Dtool_WrapValue(BamEnums::BE_native));
    PyDict_SetItemString(dict, "BENative", Dtool_WrapValue(BamEnums::BE_native));
    // enum BamEnums::BamObjectCode;
    PyDict_SetItemString(dict, "BOC_push", Dtool_WrapValue(BamEnums::BOC_push));
    PyDict_SetItemString(dict, "BOCPush", Dtool_WrapValue(BamEnums::BOC_push));
    PyDict_SetItemString(dict, "BOC_pop", Dtool_WrapValue(BamEnums::BOC_pop));
    PyDict_SetItemString(dict, "BOCPop", Dtool_WrapValue(BamEnums::BOC_pop));
    PyDict_SetItemString(dict, "BOC_adjunct", Dtool_WrapValue(BamEnums::BOC_adjunct));
    PyDict_SetItemString(dict, "BOCAdjunct", Dtool_WrapValue(BamEnums::BOC_adjunct));
    PyDict_SetItemString(dict, "BOC_remove", Dtool_WrapValue(BamEnums::BOC_remove));
    PyDict_SetItemString(dict, "BOCRemove", Dtool_WrapValue(BamEnums::BOC_remove));
    PyDict_SetItemString(dict, "BOC_file_data", Dtool_WrapValue(BamEnums::BOC_file_data));
    PyDict_SetItemString(dict, "BOCFileData", Dtool_WrapValue(BamEnums::BOC_file_data));
    // enum BamEnums::BamTextureMode;
    PyDict_SetItemString(dict, "BTM_unchanged", Dtool_WrapValue(BamEnums::BTM_unchanged));
    PyDict_SetItemString(dict, "BTMUnchanged", Dtool_WrapValue(BamEnums::BTM_unchanged));
    PyDict_SetItemString(dict, "BTM_fullpath", Dtool_WrapValue(BamEnums::BTM_fullpath));
    PyDict_SetItemString(dict, "BTMFullpath", Dtool_WrapValue(BamEnums::BTM_fullpath));
    PyDict_SetItemString(dict, "BTM_relative", Dtool_WrapValue(BamEnums::BTM_relative));
    PyDict_SetItemString(dict, "BTMRelative", Dtool_WrapValue(BamEnums::BTM_relative));
    PyDict_SetItemString(dict, "BTM_basename", Dtool_WrapValue(BamEnums::BTM_basename));
    PyDict_SetItemString(dict, "BTMBasename", Dtool_WrapValue(BamEnums::BTM_basename));
    PyDict_SetItemString(dict, "BTM_rawdata", Dtool_WrapValue(BamEnums::BTM_rawdata));
    PyDict_SetItemString(dict, "BTMRawdata", Dtool_WrapValue(BamEnums::BTM_rawdata));
    if (PyType_Ready((PyTypeObject *)&Dtool_BamEnums) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BamEnums)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BamEnums);
  }
}

/**
 * Python method tables for LoaderOptions (LoaderOptions)
 */
static PyMethodDef Dtool_Methods_LoaderOptions[] = {
  {"set_flags", &Dtool_LoaderOptions_set_flags_202, METH_O, (const char *)Dtool_LoaderOptions_set_flags_202_comment},
  {"setFlags", &Dtool_LoaderOptions_set_flags_202, METH_O, (const char *)Dtool_LoaderOptions_set_flags_202_comment},
  {"get_flags", &Dtool_LoaderOptions_get_flags_203, METH_NOARGS, (const char *)Dtool_LoaderOptions_get_flags_203_comment},
  {"getFlags", &Dtool_LoaderOptions_get_flags_203, METH_NOARGS, (const char *)Dtool_LoaderOptions_get_flags_203_comment},
  {"set_texture_flags", &Dtool_LoaderOptions_set_texture_flags_205, METH_O, (const char *)Dtool_LoaderOptions_set_texture_flags_205_comment},
  {"setTextureFlags", &Dtool_LoaderOptions_set_texture_flags_205, METH_O, (const char *)Dtool_LoaderOptions_set_texture_flags_205_comment},
  {"get_texture_flags", &Dtool_LoaderOptions_get_texture_flags_206, METH_NOARGS, (const char *)Dtool_LoaderOptions_get_texture_flags_206_comment},
  {"getTextureFlags", &Dtool_LoaderOptions_get_texture_flags_206, METH_NOARGS, (const char *)Dtool_LoaderOptions_get_texture_flags_206_comment},
  {"set_texture_num_views", &Dtool_LoaderOptions_set_texture_num_views_207, METH_O, (const char *)Dtool_LoaderOptions_set_texture_num_views_207_comment},
  {"setTextureNumViews", &Dtool_LoaderOptions_set_texture_num_views_207, METH_O, (const char *)Dtool_LoaderOptions_set_texture_num_views_207_comment},
  {"get_texture_num_views", &Dtool_LoaderOptions_get_texture_num_views_208, METH_NOARGS, (const char *)Dtool_LoaderOptions_get_texture_num_views_208_comment},
  {"getTextureNumViews", &Dtool_LoaderOptions_get_texture_num_views_208, METH_NOARGS, (const char *)Dtool_LoaderOptions_get_texture_num_views_208_comment},
  {"set_auto_texture_scale", &Dtool_LoaderOptions_set_auto_texture_scale_211, METH_O, (const char *)Dtool_LoaderOptions_set_auto_texture_scale_211_comment},
  {"setAutoTextureScale", &Dtool_LoaderOptions_set_auto_texture_scale_211, METH_O, (const char *)Dtool_LoaderOptions_set_auto_texture_scale_211_comment},
  {"get_auto_texture_scale", &Dtool_LoaderOptions_get_auto_texture_scale_212, METH_NOARGS, (const char *)Dtool_LoaderOptions_get_auto_texture_scale_212_comment},
  {"getAutoTextureScale", &Dtool_LoaderOptions_get_auto_texture_scale_212, METH_NOARGS, (const char *)Dtool_LoaderOptions_get_auto_texture_scale_212_comment},
  {"output", &Dtool_LoaderOptions_output_214, METH_O, (const char *)Dtool_LoaderOptions_output_214_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     LoaderOptions
//////////////////
static PyObject *Dtool_Repr_LoaderOptions(PyObject *self) {
  LoaderOptions *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LoaderOptions, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyGetSetDef Dtool_Properties_LoaderOptions[] = {
  {(char *)"flags", &Dtool_LoaderOptions_flags_Getter, &Dtool_LoaderOptions_flags_Setter, nullptr, nullptr},
  {(char *)"texture_flags", &Dtool_LoaderOptions_texture_flags_Getter, &Dtool_LoaderOptions_texture_flags_Setter, nullptr, nullptr},
  {(char *)"texture_num_views", &Dtool_LoaderOptions_texture_num_views_Getter, &Dtool_LoaderOptions_texture_num_views_Setter, nullptr, nullptr},
  {(char *)"auto_texture_scale", &Dtool_LoaderOptions_auto_texture_scale_Getter, &Dtool_LoaderOptions_auto_texture_scale_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_LoaderOptions = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_LoaderOptions = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.LoaderOptions",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LoaderOptions,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_LoaderOptions,
    &Dtool_NumberMethods_LoaderOptions,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_LoaderOptions,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Specifies parameters that may be passed to the loader.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LoaderOptions,
    nullptr, // tp_members
    Dtool_Properties_LoaderOptions,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LoaderOptions,
    PyType_GenericAlloc,
    Dtool_new_LoaderOptions,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LoaderOptions,
  Dtool_UpcastInterface_LoaderOptions,
  Dtool_DowncastInterface_LoaderOptions,
  nullptr,
  (CoerceFunction)Dtool_Coerce_LoaderOptions,
};

static void Dtool_PyModuleClassInit_LoaderOptions(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LoaderOptions._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(37);
    Dtool_LoaderOptions._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LoaderOptions::LoaderFlags;
    PyDict_SetItemString(dict, "LF_search", Dtool_WrapValue(LoaderOptions::LF_search));
    PyDict_SetItemString(dict, "LFSearch", Dtool_WrapValue(LoaderOptions::LF_search));
    PyDict_SetItemString(dict, "LF_report_errors", Dtool_WrapValue(LoaderOptions::LF_report_errors));
    PyDict_SetItemString(dict, "LFReportErrors", Dtool_WrapValue(LoaderOptions::LF_report_errors));
    PyDict_SetItemString(dict, "LF_convert_skeleton", Dtool_WrapValue(LoaderOptions::LF_convert_skeleton));
    PyDict_SetItemString(dict, "LFConvertSkeleton", Dtool_WrapValue(LoaderOptions::LF_convert_skeleton));
    PyDict_SetItemString(dict, "LF_convert_channels", Dtool_WrapValue(LoaderOptions::LF_convert_channels));
    PyDict_SetItemString(dict, "LFConvertChannels", Dtool_WrapValue(LoaderOptions::LF_convert_channels));
    PyDict_SetItemString(dict, "LF_convert_anim", Dtool_WrapValue(LoaderOptions::LF_convert_anim));
    PyDict_SetItemString(dict, "LFConvertAnim", Dtool_WrapValue(LoaderOptions::LF_convert_anim));
    PyDict_SetItemString(dict, "LF_no_disk_cache", Dtool_WrapValue(LoaderOptions::LF_no_disk_cache));
    PyDict_SetItemString(dict, "LFNoDiskCache", Dtool_WrapValue(LoaderOptions::LF_no_disk_cache));
    PyDict_SetItemString(dict, "LF_no_ram_cache", Dtool_WrapValue(LoaderOptions::LF_no_ram_cache));
    PyDict_SetItemString(dict, "LFNoRamCache", Dtool_WrapValue(LoaderOptions::LF_no_ram_cache));
    PyDict_SetItemString(dict, "LF_no_cache", Dtool_WrapValue(LoaderOptions::LF_no_cache));
    PyDict_SetItemString(dict, "LFNoCache", Dtool_WrapValue(LoaderOptions::LF_no_cache));
    PyDict_SetItemString(dict, "LF_cache_only", Dtool_WrapValue(LoaderOptions::LF_cache_only));
    PyDict_SetItemString(dict, "LFCacheOnly", Dtool_WrapValue(LoaderOptions::LF_cache_only));
    PyDict_SetItemString(dict, "LF_allow_instance", Dtool_WrapValue(LoaderOptions::LF_allow_instance));
    PyDict_SetItemString(dict, "LFAllowInstance", Dtool_WrapValue(LoaderOptions::LF_allow_instance));
    // enum LoaderOptions::TextureFlags;
    PyDict_SetItemString(dict, "TF_preload", Dtool_WrapValue(LoaderOptions::TF_preload));
    PyDict_SetItemString(dict, "TFPreload", Dtool_WrapValue(LoaderOptions::TF_preload));
    PyDict_SetItemString(dict, "TF_preload_simple", Dtool_WrapValue(LoaderOptions::TF_preload_simple));
    PyDict_SetItemString(dict, "TFPreloadSimple", Dtool_WrapValue(LoaderOptions::TF_preload_simple));
    PyDict_SetItemString(dict, "TF_allow_1d", Dtool_WrapValue(LoaderOptions::TF_allow_1d));
    PyDict_SetItemString(dict, "TFAllow1d", Dtool_WrapValue(LoaderOptions::TF_allow_1d));
    PyDict_SetItemString(dict, "TF_generate_mipmaps", Dtool_WrapValue(LoaderOptions::TF_generate_mipmaps));
    PyDict_SetItemString(dict, "TFGenerateMipmaps", Dtool_WrapValue(LoaderOptions::TF_generate_mipmaps));
    PyDict_SetItemString(dict, "TF_multiview", Dtool_WrapValue(LoaderOptions::TF_multiview));
    PyDict_SetItemString(dict, "TFMultiview", Dtool_WrapValue(LoaderOptions::TF_multiview));
    PyDict_SetItemString(dict, "TF_integer", Dtool_WrapValue(LoaderOptions::TF_integer));
    PyDict_SetItemString(dict, "TFInteger", Dtool_WrapValue(LoaderOptions::TF_integer));
    PyDict_SetItemString(dict, "TF_float", Dtool_WrapValue(LoaderOptions::TF_float));
    PyDict_SetItemString(dict, "TFFloat", Dtool_WrapValue(LoaderOptions::TF_float));
    PyDict_SetItemString(dict, "TF_allow_compression", Dtool_WrapValue(LoaderOptions::TF_allow_compression));
    PyDict_SetItemString(dict, "TFAllowCompression", Dtool_WrapValue(LoaderOptions::TF_allow_compression));
    if (PyType_Ready((PyTypeObject *)&Dtool_LoaderOptions) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LoaderOptions)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LoaderOptions);
  }
}

/**
 * Python method tables for BamReader (BamReader)
 */
static PyMethodDef Dtool_Methods_BamReader[] = {
  {"set_source", &Dtool_BamReader_set_source_219, METH_O, (const char *)Dtool_BamReader_set_source_219_comment},
  {"setSource", &Dtool_BamReader_set_source_219, METH_O, (const char *)Dtool_BamReader_set_source_219_comment},
  {"get_source", &Dtool_BamReader_get_source_220, METH_NOARGS, (const char *)Dtool_BamReader_get_source_220_comment},
  {"getSource", &Dtool_BamReader_get_source_220, METH_NOARGS, (const char *)Dtool_BamReader_get_source_220_comment},
  {"init", &Dtool_BamReader_init_221, METH_NOARGS, (const char *)Dtool_BamReader_init_221_comment},
  {"get_filename", &Dtool_BamReader_get_filename_224, METH_NOARGS, (const char *)Dtool_BamReader_get_filename_224_comment},
  {"getFilename", &Dtool_BamReader_get_filename_224, METH_NOARGS, (const char *)Dtool_BamReader_get_filename_224_comment},
  {"get_loader_options", &Dtool_BamReader_get_loader_options_225, METH_NOARGS, (const char *)Dtool_BamReader_get_loader_options_225_comment},
  {"getLoaderOptions", &Dtool_BamReader_get_loader_options_225, METH_NOARGS, (const char *)Dtool_BamReader_get_loader_options_225_comment},
  {"set_loader_options", &Dtool_BamReader_set_loader_options_226, METH_O, (const char *)Dtool_BamReader_set_loader_options_226_comment},
  {"setLoaderOptions", &Dtool_BamReader_set_loader_options_226, METH_O, (const char *)Dtool_BamReader_set_loader_options_226_comment},
  {"read_object", &Dtool_BamReader_read_object_227, METH_NOARGS, (const char *)Dtool_BamReader_read_object_227_comment},
  {"readObject", &Dtool_BamReader_read_object_227, METH_NOARGS, (const char *)Dtool_BamReader_read_object_227_comment},
  {"is_eof", &Dtool_BamReader_is_eof_228, METH_NOARGS, (const char *)Dtool_BamReader_is_eof_228_comment},
  {"isEof", &Dtool_BamReader_is_eof_228, METH_NOARGS, (const char *)Dtool_BamReader_is_eof_228_comment},
  {"resolve", &Dtool_BamReader_resolve_229, METH_NOARGS, (const char *)Dtool_BamReader_resolve_229_comment},
  {"change_pointer", (PyCFunction) &Dtool_BamReader_change_pointer_230, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamReader_change_pointer_230_comment},
  {"changePointer", (PyCFunction) &Dtool_BamReader_change_pointer_230, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BamReader_change_pointer_230_comment},
  {"get_file_major_ver", &Dtool_BamReader_get_file_major_ver_231, METH_NOARGS, (const char *)Dtool_BamReader_get_file_major_ver_231_comment},
  {"getFileMajorVer", &Dtool_BamReader_get_file_major_ver_231, METH_NOARGS, (const char *)Dtool_BamReader_get_file_major_ver_231_comment},
  {"get_file_minor_ver", &Dtool_BamReader_get_file_minor_ver_232, METH_NOARGS, (const char *)Dtool_BamReader_get_file_minor_ver_232_comment},
  {"getFileMinorVer", &Dtool_BamReader_get_file_minor_ver_232, METH_NOARGS, (const char *)Dtool_BamReader_get_file_minor_ver_232_comment},
  {"get_file_endian", &Dtool_BamReader_get_file_endian_233, METH_NOARGS, (const char *)Dtool_BamReader_get_file_endian_233_comment},
  {"getFileEndian", &Dtool_BamReader_get_file_endian_233, METH_NOARGS, (const char *)Dtool_BamReader_get_file_endian_233_comment},
  {"get_file_stdfloat_double", &Dtool_BamReader_get_file_stdfloat_double_234, METH_NOARGS, (const char *)Dtool_BamReader_get_file_stdfloat_double_234_comment},
  {"getFileStdfloatDouble", &Dtool_BamReader_get_file_stdfloat_double_234, METH_NOARGS, (const char *)Dtool_BamReader_get_file_stdfloat_double_234_comment},
  {"get_current_major_ver", &Dtool_BamReader_get_current_major_ver_235, METH_NOARGS, (const char *)Dtool_BamReader_get_current_major_ver_235_comment},
  {"getCurrentMajorVer", &Dtool_BamReader_get_current_major_ver_235, METH_NOARGS, (const char *)Dtool_BamReader_get_current_major_ver_235_comment},
  {"get_current_minor_ver", &Dtool_BamReader_get_current_minor_ver_236, METH_NOARGS, (const char *)Dtool_BamReader_get_current_minor_ver_236_comment},
  {"getCurrentMinorVer", &Dtool_BamReader_get_current_minor_ver_236, METH_NOARGS, (const char *)Dtool_BamReader_get_current_minor_ver_236_comment},
  {"get_file_version", &Dtool_BamReader_get_file_version_237, METH_NOARGS, (const char *)Dtool_BamReader_get_file_version_237_comment},
  {"getFileVersion", &Dtool_BamReader_get_file_version_237, METH_NOARGS, (const char *)Dtool_BamReader_get_file_version_237_comment},
  {"register_factory", (PyCFunction) &Dtool_BamReader_register_factory_250, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BamReader_register_factory_250_comment},
  {"registerFactory", (PyCFunction) &Dtool_BamReader_register_factory_250, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BamReader_register_factory_250_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_BamReader[] = {
  {(char *)"source", &Dtool_BamReader_source_Getter, &Dtool_BamReader_source_Setter, nullptr, nullptr},
  {(char *)"filename", &Dtool_BamReader_filename_Getter, nullptr, nullptr, nullptr},
  {(char *)"loader_options", &Dtool_BamReader_loader_options_Getter, &Dtool_BamReader_loader_options_Setter, nullptr, nullptr},
  {(char *)"file_version", &Dtool_BamReader_file_version_Getter, nullptr, nullptr, nullptr},
  {(char *)"file_endian", &Dtool_BamReader_file_endian_Getter, nullptr, nullptr, nullptr},
  {(char *)"file_stdfloat_double", &Dtool_BamReader_file_stdfloat_double_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_BamReader = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BamReader = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BamReader = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BamReader = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BamReader = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BamReader = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BamReader",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BamReader,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BamReader,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BamReader,
    &Dtool_SequenceMethods_BamReader,
    &Dtool_MappingMethods_BamReader,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BamReader,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the fundamental interface for extracting binary objects from a Bam\n"
    " * file, as generated by a BamWriter.\n"
    " *\n"
    " * A Bam file can be thought of as a linear collection of objects.  Each\n"
    " * object is an instance of a class that inherits, directly or indirectly,\n"
    " * from TypedWritable.  The objects may include pointers to other objects\n"
    " * within the Bam file; the BamReader automatically manages these (with help\n"
    " * from code within each class) and restores the pointers correctly.\n"
    " *\n"
    " * This is the abstract interface and does not specifically deal with disk\n"
    " * files, but rather with a DatagramGenerator of some kind, which is simply a\n"
    " * linear source of Datagrams.  It is probably from a disk file, but it might\n"
    " * conceivably be streamed directly from a network or some such nonsense.\n"
    " *\n"
    " * Bam files are most often used to store scene graphs or subgraphs, and by\n"
    " * convention they are given filenames ending in the extension \".bam\" when\n"
    " * they are used for this purpose.  However, a Bam file may store any\n"
    " * arbitrary list of TypedWritable objects; in this more general usage, they\n"
    " * are given filenames ending in \".boo\" to differentiate them from the more\n"
    " * common scene graph files.\n"
    " *\n"
    " * See also BamFile, which defines a higher-level interface to read and write\n"
    " * Bam files on disk.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BamReader,
    nullptr, // tp_members
    Dtool_Properties_BamReader,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BamReader,
    PyType_GenericAlloc,
    Dtool_new_BamReader,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BamReader,
  Dtool_UpcastInterface_BamReader,
  Dtool_DowncastInterface_BamReader,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BamReader(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BamEnums(nullptr);
    Dtool_BamReader._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BamEnums);
    Dtool_BamReader._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BamReader._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BamReader) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BamReader)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BamReader);
  }
}

/**
 * Python method tables for BamWriter (BamWriter)
 */
static PyMethodDef Dtool_Methods_BamWriter[] = {
  {"set_target", &Dtool_BamWriter_set_target_254, METH_O, (const char *)Dtool_BamWriter_set_target_254_comment},
  {"setTarget", &Dtool_BamWriter_set_target_254, METH_O, (const char *)Dtool_BamWriter_set_target_254_comment},
  {"get_target", &Dtool_BamWriter_get_target_255, METH_NOARGS, (const char *)Dtool_BamWriter_get_target_255_comment},
  {"getTarget", &Dtool_BamWriter_get_target_255, METH_NOARGS, (const char *)Dtool_BamWriter_get_target_255_comment},
  {"init", &Dtool_BamWriter_init_256, METH_NOARGS, (const char *)Dtool_BamWriter_init_256_comment},
  {"get_filename", &Dtool_BamWriter_get_filename_257, METH_NOARGS, (const char *)Dtool_BamWriter_get_filename_257_comment},
  {"getFilename", &Dtool_BamWriter_get_filename_257, METH_NOARGS, (const char *)Dtool_BamWriter_get_filename_257_comment},
  {"write_object", &Dtool_BamWriter_write_object_258, METH_O, (const char *)Dtool_BamWriter_write_object_258_comment},
  {"writeObject", &Dtool_BamWriter_write_object_258, METH_O, (const char *)Dtool_BamWriter_write_object_258_comment},
  {"has_object", &Dtool_BamWriter_has_object_259, METH_O, (const char *)Dtool_BamWriter_has_object_259_comment},
  {"hasObject", &Dtool_BamWriter_has_object_259, METH_O, (const char *)Dtool_BamWriter_has_object_259_comment},
  {"flush", &Dtool_BamWriter_flush_260, METH_NOARGS, (const char *)Dtool_BamWriter_flush_260_comment},
  {"get_file_major_ver", &Dtool_BamWriter_get_file_major_ver_261, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_major_ver_261_comment},
  {"getFileMajorVer", &Dtool_BamWriter_get_file_major_ver_261, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_major_ver_261_comment},
  {"get_file_minor_ver", &Dtool_BamWriter_get_file_minor_ver_262, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_minor_ver_262_comment},
  {"getFileMinorVer", &Dtool_BamWriter_get_file_minor_ver_262, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_minor_ver_262_comment},
  {"set_file_minor_ver", &Dtool_BamWriter_set_file_minor_ver_263, METH_O, (const char *)Dtool_BamWriter_set_file_minor_ver_263_comment},
  {"setFileMinorVer", &Dtool_BamWriter_set_file_minor_ver_263, METH_O, (const char *)Dtool_BamWriter_set_file_minor_ver_263_comment},
  {"get_file_endian", &Dtool_BamWriter_get_file_endian_264, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_endian_264_comment},
  {"getFileEndian", &Dtool_BamWriter_get_file_endian_264, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_endian_264_comment},
  {"get_file_stdfloat_double", &Dtool_BamWriter_get_file_stdfloat_double_265, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_stdfloat_double_265_comment},
  {"getFileStdfloatDouble", &Dtool_BamWriter_get_file_stdfloat_double_265, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_stdfloat_double_265_comment},
  {"get_file_texture_mode", &Dtool_BamWriter_get_file_texture_mode_266, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_texture_mode_266_comment},
  {"getFileTextureMode", &Dtool_BamWriter_get_file_texture_mode_266, METH_NOARGS, (const char *)Dtool_BamWriter_get_file_texture_mode_266_comment},
  {"set_file_texture_mode", &Dtool_BamWriter_set_file_texture_mode_267, METH_O, (const char *)Dtool_BamWriter_set_file_texture_mode_267_comment},
  {"setFileTextureMode", &Dtool_BamWriter_set_file_texture_mode_267, METH_O, (const char *)Dtool_BamWriter_set_file_texture_mode_267_comment},
  {"get_root_node", &Dtool_BamWriter_get_root_node_268, METH_NOARGS, (const char *)Dtool_BamWriter_get_root_node_268_comment},
  {"getRootNode", &Dtool_BamWriter_get_root_node_268, METH_NOARGS, (const char *)Dtool_BamWriter_get_root_node_268_comment},
  {"set_root_node", &Dtool_BamWriter_set_root_node_269, METH_O, (const char *)Dtool_BamWriter_set_root_node_269_comment},
  {"setRootNode", &Dtool_BamWriter_set_root_node_269, METH_O, (const char *)Dtool_BamWriter_set_root_node_269_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_BamWriter[] = {
  {(char *)"target", &Dtool_BamWriter_target_Getter, &Dtool_BamWriter_target_Setter, nullptr, nullptr},
  {(char *)"filename", &Dtool_BamWriter_filename_Getter, nullptr, nullptr, nullptr},
  {(char *)"file_endian", &Dtool_BamWriter_file_endian_Getter, nullptr, nullptr, nullptr},
  {(char *)"file_stdfloat_double", &Dtool_BamWriter_file_stdfloat_double_Getter, nullptr, nullptr, nullptr},
  {(char *)"file_texture_mode", &Dtool_BamWriter_file_texture_mode_Getter, nullptr, nullptr, nullptr},
  {(char *)"root_node", &Dtool_BamWriter_root_node_Getter, &Dtool_BamWriter_root_node_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_BamWriter = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BamWriter = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BamWriter = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BamWriter = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BamWriter = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BamWriter = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BamWriter",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BamWriter,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BamWriter,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_BamWriter,
    &Dtool_SequenceMethods_BamWriter,
    &Dtool_MappingMethods_BamWriter,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BamWriter,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is the fundamental interface for writing binary objects to a Bam file,\n"
    " * to be extracted later by a BamReader.\n"
    " *\n"
    " * A Bam file can be thought of as a linear collection of objects.  Each\n"
    " * object is an instance of a class that inherits, directly or indirectly,\n"
    " * from TypedWritable.  The objects may include pointers to other objects; the\n"
    " * BamWriter automatically manages these (with help from code within each\n"
    " * class) and writes all referenced objects to the file in such a way that the\n"
    " * pointers may be correctly restored later.\n"
    " *\n"
    " * This is the abstract interface and does not specifically deal with disk\n"
    " * files, but rather with a DatagramSink of some kind, which simply accepts a\n"
    " * linear stream of Datagrams.  It is probably written to a disk file, but it\n"
    " * might conceivably be streamed directly to a network or some such nonsense.\n"
    " *\n"
    " * Bam files are most often used to store scene graphs or subgraphs, and by\n"
    " * convention they are given filenames ending in the extension \".bam\" when\n"
    " * they are used for this purpose.  However, a Bam file may store any\n"
    " * arbitrary list of TypedWritable objects; in this more general usage, they\n"
    " * are given filenames ending in \".boo\" to differentiate them from the more\n"
    " * common scene graph files.\n"
    " *\n"
    " * See also BamFile, which defines a higher-level interface to read and write\n"
    " * Bam files on disk.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BamWriter,
    nullptr, // tp_members
    Dtool_Properties_BamWriter,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BamWriter,
    PyType_GenericAlloc,
    Dtool_new_BamWriter,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BamWriter,
  Dtool_UpcastInterface_BamWriter,
  Dtool_DowncastInterface_BamWriter,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BamWriter(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BamEnums(nullptr);
    Dtool_BamWriter._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BamEnums);
    Dtool_BamWriter._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BamWriter._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BamWriter) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BamWriter)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BamWriter);
  }
}

/**
 * Python method tables for BitMask_uint16_t_16 (BitMask_uint16_t_16)
 */
static PyMethodDef Dtool_Methods_BitMask_uint16_t_16[] = {
  {"all_on", &Dtool_BitMask_uint16_t_16_all_on_280, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_all_on_280_comment},
  {"allOn", &Dtool_BitMask_uint16_t_16_all_on_280, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_all_on_280_comment},
  {"all_off", &Dtool_BitMask_uint16_t_16_all_off_281, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_all_off_281_comment},
  {"allOff", &Dtool_BitMask_uint16_t_16_all_off_281, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_all_off_281_comment},
  {"lower_on", &Dtool_BitMask_uint16_t_16_lower_on_282, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_lower_on_282_comment},
  {"lowerOn", &Dtool_BitMask_uint16_t_16_lower_on_282, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_lower_on_282_comment},
  {"bit", &Dtool_BitMask_uint16_t_16_bit_283, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_bit_283_comment},
  {"range", (PyCFunction) &Dtool_BitMask_uint16_t_16_range_284, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_range_284_comment},
  {"has_max_num_bits", &Dtool_BitMask_uint16_t_16_has_max_num_bits_285, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_has_max_num_bits_285_comment},
  {"hasMaxNumBits", &Dtool_BitMask_uint16_t_16_has_max_num_bits_285, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_has_max_num_bits_285_comment},
  {"get_max_num_bits", &Dtool_BitMask_uint16_t_16_get_max_num_bits_286, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_get_max_num_bits_286_comment},
  {"getMaxNumBits", &Dtool_BitMask_uint16_t_16_get_max_num_bits_286, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_get_max_num_bits_286_comment},
  {"get_num_bits", &Dtool_BitMask_uint16_t_16_get_num_bits_287, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_num_bits_287_comment},
  {"getNumBits", &Dtool_BitMask_uint16_t_16_get_num_bits_287, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_num_bits_287_comment},
  {"get_bit", &Dtool_BitMask_uint16_t_16_get_bit_288, METH_O, (const char *)Dtool_BitMask_uint16_t_16_get_bit_288_comment},
  {"getBit", &Dtool_BitMask_uint16_t_16_get_bit_288, METH_O, (const char *)Dtool_BitMask_uint16_t_16_get_bit_288_comment},
  {"set_bit", &Dtool_BitMask_uint16_t_16_set_bit_289, METH_O, (const char *)Dtool_BitMask_uint16_t_16_set_bit_289_comment},
  {"setBit", &Dtool_BitMask_uint16_t_16_set_bit_289, METH_O, (const char *)Dtool_BitMask_uint16_t_16_set_bit_289_comment},
  {"clear_bit", &Dtool_BitMask_uint16_t_16_clear_bit_290, METH_O, (const char *)Dtool_BitMask_uint16_t_16_clear_bit_290_comment},
  {"clearBit", &Dtool_BitMask_uint16_t_16_clear_bit_290, METH_O, (const char *)Dtool_BitMask_uint16_t_16_clear_bit_290_comment},
  {"set_bit_to", (PyCFunction) &Dtool_BitMask_uint16_t_16_set_bit_to_291, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_set_bit_to_291_comment},
  {"setBitTo", (PyCFunction) &Dtool_BitMask_uint16_t_16_set_bit_to_291, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_set_bit_to_291_comment},
  {"is_zero", &Dtool_BitMask_uint16_t_16_is_zero_292, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_is_zero_292_comment},
  {"isZero", &Dtool_BitMask_uint16_t_16_is_zero_292, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_is_zero_292_comment},
  {"is_all_on", &Dtool_BitMask_uint16_t_16_is_all_on_293, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_is_all_on_293_comment},
  {"isAllOn", &Dtool_BitMask_uint16_t_16_is_all_on_293, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_is_all_on_293_comment},
  {"extract", (PyCFunction) &Dtool_BitMask_uint16_t_16_extract_294, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_extract_294_comment},
  {"store", (PyCFunction) &Dtool_BitMask_uint16_t_16_store_295, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_store_295_comment},
  {"has_any_of", (PyCFunction) &Dtool_BitMask_uint16_t_16_has_any_of_296, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_has_any_of_296_comment},
  {"hasAnyOf", (PyCFunction) &Dtool_BitMask_uint16_t_16_has_any_of_296, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_has_any_of_296_comment},
  {"has_all_of", (PyCFunction) &Dtool_BitMask_uint16_t_16_has_all_of_297, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_has_all_of_297_comment},
  {"hasAllOf", (PyCFunction) &Dtool_BitMask_uint16_t_16_has_all_of_297, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_has_all_of_297_comment},
  {"set_range", (PyCFunction) &Dtool_BitMask_uint16_t_16_set_range_298, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_set_range_298_comment},
  {"setRange", (PyCFunction) &Dtool_BitMask_uint16_t_16_set_range_298, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_set_range_298_comment},
  {"clear_range", (PyCFunction) &Dtool_BitMask_uint16_t_16_clear_range_299, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_clear_range_299_comment},
  {"clearRange", (PyCFunction) &Dtool_BitMask_uint16_t_16_clear_range_299, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_clear_range_299_comment},
  {"set_range_to", (PyCFunction) &Dtool_BitMask_uint16_t_16_set_range_to_300, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_set_range_to_300_comment},
  {"setRangeTo", (PyCFunction) &Dtool_BitMask_uint16_t_16_set_range_to_300, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_set_range_to_300_comment},
  {"get_word", &Dtool_BitMask_uint16_t_16_get_word_301, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_word_301_comment},
  {"getWord", &Dtool_BitMask_uint16_t_16_get_word_301, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_word_301_comment},
  {"set_word", &Dtool_BitMask_uint16_t_16_set_word_302, METH_O, (const char *)Dtool_BitMask_uint16_t_16_set_word_302_comment},
  {"setWord", &Dtool_BitMask_uint16_t_16_set_word_302, METH_O, (const char *)Dtool_BitMask_uint16_t_16_set_word_302_comment},
  {"get_num_on_bits", &Dtool_BitMask_uint16_t_16_get_num_on_bits_303, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_num_on_bits_303_comment},
  {"getNumOnBits", &Dtool_BitMask_uint16_t_16_get_num_on_bits_303, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_num_on_bits_303_comment},
  {"get_num_off_bits", &Dtool_BitMask_uint16_t_16_get_num_off_bits_304, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_num_off_bits_304_comment},
  {"getNumOffBits", &Dtool_BitMask_uint16_t_16_get_num_off_bits_304, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_num_off_bits_304_comment},
  {"get_lowest_on_bit", &Dtool_BitMask_uint16_t_16_get_lowest_on_bit_305, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_lowest_on_bit_305_comment},
  {"getLowestOnBit", &Dtool_BitMask_uint16_t_16_get_lowest_on_bit_305, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_lowest_on_bit_305_comment},
  {"get_lowest_off_bit", &Dtool_BitMask_uint16_t_16_get_lowest_off_bit_306, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_lowest_off_bit_306_comment},
  {"getLowestOffBit", &Dtool_BitMask_uint16_t_16_get_lowest_off_bit_306, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_lowest_off_bit_306_comment},
  {"get_highest_on_bit", &Dtool_BitMask_uint16_t_16_get_highest_on_bit_307, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_highest_on_bit_307_comment},
  {"getHighestOnBit", &Dtool_BitMask_uint16_t_16_get_highest_on_bit_307, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_highest_on_bit_307_comment},
  {"get_highest_off_bit", &Dtool_BitMask_uint16_t_16_get_highest_off_bit_308, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_highest_off_bit_308_comment},
  {"getHighestOffBit", &Dtool_BitMask_uint16_t_16_get_highest_off_bit_308, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_highest_off_bit_308_comment},
  {"get_next_higher_different_bit", &Dtool_BitMask_uint16_t_16_get_next_higher_different_bit_309, METH_O, (const char *)Dtool_BitMask_uint16_t_16_get_next_higher_different_bit_309_comment},
  {"getNextHigherDifferentBit", &Dtool_BitMask_uint16_t_16_get_next_higher_different_bit_309, METH_O, (const char *)Dtool_BitMask_uint16_t_16_get_next_higher_different_bit_309_comment},
  {"invert_in_place", &Dtool_BitMask_uint16_t_16_invert_in_place_310, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_invert_in_place_310_comment},
  {"invertInPlace", &Dtool_BitMask_uint16_t_16_invert_in_place_310, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_invert_in_place_310_comment},
  {"has_bits_in_common", &Dtool_BitMask_uint16_t_16_has_bits_in_common_311, METH_O, (const char *)Dtool_BitMask_uint16_t_16_has_bits_in_common_311_comment},
  {"hasBitsInCommon", &Dtool_BitMask_uint16_t_16_has_bits_in_common_311, METH_O, (const char *)Dtool_BitMask_uint16_t_16_has_bits_in_common_311_comment},
  {"clear", &Dtool_BitMask_uint16_t_16_clear_312, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_clear_312_comment},
  {"output", &Dtool_BitMask_uint16_t_16_output_313, METH_O, (const char *)Dtool_BitMask_uint16_t_16_output_313_comment},
  {"output_binary", (PyCFunction) &Dtool_BitMask_uint16_t_16_output_binary_314, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_output_binary_314_comment},
  {"outputBinary", (PyCFunction) &Dtool_BitMask_uint16_t_16_output_binary_314, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_output_binary_314_comment},
  {"output_hex", (PyCFunction) &Dtool_BitMask_uint16_t_16_output_hex_315, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_output_hex_315_comment},
  {"outputHex", (PyCFunction) &Dtool_BitMask_uint16_t_16_output_hex_315, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_output_hex_315_comment},
  {"write", (PyCFunction) &Dtool_BitMask_uint16_t_16_write_316, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint16_t_16_write_316_comment},
  {"compare_to", &Dtool_BitMask_uint16_t_16_compare_to_320, METH_O, (const char *)Dtool_BitMask_uint16_t_16_compare_to_320_comment},
  {"compareTo", &Dtool_BitMask_uint16_t_16_compare_to_320, METH_O, (const char *)Dtool_BitMask_uint16_t_16_compare_to_320_comment},
  {"flood_down_in_place", &Dtool_BitMask_uint16_t_16_flood_down_in_place_332, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_flood_down_in_place_332_comment},
  {"floodDownInPlace", &Dtool_BitMask_uint16_t_16_flood_down_in_place_332, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_flood_down_in_place_332_comment},
  {"flood_up_in_place", &Dtool_BitMask_uint16_t_16_flood_up_in_place_333, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_flood_up_in_place_333_comment},
  {"floodUpInPlace", &Dtool_BitMask_uint16_t_16_flood_up_in_place_333, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_flood_up_in_place_333_comment},
  {"flood_bits_down", &Dtool_BitMask_uint16_t_16_flood_bits_down_334, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_flood_bits_down_334_comment},
  {"floodBitsDown", &Dtool_BitMask_uint16_t_16_flood_bits_down_334, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_flood_bits_down_334_comment},
  {"flood_bits_up", &Dtool_BitMask_uint16_t_16_flood_bits_up_335, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_flood_bits_up_335_comment},
  {"floodBitsUp", &Dtool_BitMask_uint16_t_16_flood_bits_up_335, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_flood_bits_up_335_comment},
  {"keep_next_highest_bit", &Dtool_BitMask_uint16_t_16_keep_next_highest_bit_336, METH_VARARGS, (const char *)Dtool_BitMask_uint16_t_16_keep_next_highest_bit_336_comment},
  {"keepNextHighestBit", &Dtool_BitMask_uint16_t_16_keep_next_highest_bit_336, METH_VARARGS, (const char *)Dtool_BitMask_uint16_t_16_keep_next_highest_bit_336_comment},
  {"keep_next_lowest_bit", &Dtool_BitMask_uint16_t_16_keep_next_lowest_bit_337, METH_VARARGS, (const char *)Dtool_BitMask_uint16_t_16_keep_next_lowest_bit_337_comment},
  {"keepNextLowestBit", &Dtool_BitMask_uint16_t_16_keep_next_lowest_bit_337, METH_VARARGS, (const char *)Dtool_BitMask_uint16_t_16_keep_next_lowest_bit_337_comment},
  {"get_key", &Dtool_BitMask_uint16_t_16_get_key_338, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_key_338_comment},
  {"getKey", &Dtool_BitMask_uint16_t_16_get_key_338, METH_NOARGS, (const char *)Dtool_BitMask_uint16_t_16_get_key_338_comment},
  {"get_class_type", &Dtool_BitMask_uint16_t_16_get_class_type_340, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_get_class_type_340_comment},
  {"getClassType", &Dtool_BitMask_uint16_t_16_get_class_type_340, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint16_t_16_get_class_type_340_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_and -> operator &
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_321_nb_and(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator &(BitMask< uint16_t, 16 > const &other) const
  BitMask< uint16_t, 16 > arg_local;
  BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__and__", "BitMask");
  }
  BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(((*(const BitMask< uint16_t, 16 >*)local_this).operator &)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_bool -> __nonzero__
//////////////////
static int Dtool_BitMask_uint16_t_16_nonzero_339_nb_bool(PyObject *self) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return -1;
  }

  return (int) ((*local_this).__nonzero__)();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_inplace_and -> operator &=
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_327_nb_inplace_and(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void BitMask< uint16_t, 16 >::operator &=(BitMask< uint16_t, 16 > const &other)
  BitMask< uint16_t, 16 > arg_local;
  BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__iand__", "BitMask");
    return nullptr;
  }
  ((*local_this).operator &=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_inplace_lshift -> operator <<=
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_330_nb_inplace_lshift(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void BitMask< uint16_t, 16 >::operator <<=(int shift)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return nullptr;
    }
#endif
    ((*local_this).operator <<=)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_inplace_or -> operator |=
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_328_nb_inplace_or(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void BitMask< uint16_t, 16 >::operator |=(BitMask< uint16_t, 16 > const &other)
  BitMask< uint16_t, 16 > arg_local;
  BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__ior__", "BitMask");
    return nullptr;
  }
  ((*local_this).operator |=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_inplace_rshift -> operator >>=
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_331_nb_inplace_rshift(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void BitMask< uint16_t, 16 >::operator >>=(int shift)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return nullptr;
    }
#endif
    ((*local_this).operator >>=)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_inplace_xor -> operator ^=
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_329_nb_inplace_xor(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void BitMask< uint16_t, 16 >::operator ^=(BitMask< uint16_t, 16 > const &other)
  BitMask< uint16_t, 16 > arg_local;
  BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__ixor__", "BitMask");
    return nullptr;
  }
  ((*local_this).operator ^=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_invert -> operator ~
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_324_nb_invert(PyObject *self) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator ~(void) const
  BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(((*(const BitMask< uint16_t, 16 >*)local_this).operator ~)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__invert__(BitMask self)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_lshift -> operator <<
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_325_nb_lshift(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator <<(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(((*(const BitMask< uint16_t, 16 >*)local_this).operator <<)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_or -> operator |
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_322_nb_or(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator |(BitMask< uint16_t, 16 > const &other) const
  BitMask< uint16_t, 16 > arg_local;
  BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__or__", "BitMask");
  }
  BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(((*(const BitMask< uint16_t, 16 >*)local_this).operator |)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_rshift -> operator >>
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_326_nb_rshift(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator >>(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(((*(const BitMask< uint16_t, 16 >*)local_this).operator >>)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot nb_xor -> operator ^
//////////////////
static PyObject *Dtool_BitMask_uint16_t_16_operator_323_nb_xor(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint16_t_16, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint16_t, 16 > BitMask< uint16_t, 16 >::operator ^(BitMask< uint16_t, 16 > const &other) const
  BitMask< uint16_t, 16 > arg_local;
  BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__xor__", "BitMask");
  }
  BitMask< uint16_t, 16 > *return_value = new BitMask< uint16_t, 16 >(((*(const BitMask< uint16_t, 16 >*)local_this).operator ^)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint16_t_16, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot tp_compare -> compare_to
//////////////////
static int Dtool_BitMask_uint16_t_16_compare_to_320_tp_compare(PyObject *self, PyObject *arg) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int BitMask< uint16_t, 16 >::compare_to(BitMask< uint16_t, 16 > const &other) const
  BitMask< uint16_t, 16 > arg_local;
  BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitMask.compare_to", "BitMask");
    return -1;
  }
  int return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(BitMask self, const BitMask other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint16_t_16 slot tp_hash -> get_key
//////////////////
static Py_hash_t Dtool_BitMask_uint16_t_16_get_key_338_tp_hash(PyObject *self) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) ((*local_this).get_key)();
}

//////////////////
//  A __repr__ function
//     BitMask_uint16_t_16
//////////////////
static PyObject *Dtool_Repr_BitMask_uint16_t_16(PyObject *self) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BitMask_uint16_t_16
//////////////////
static PyObject *Dtool_Str_BitMask_uint16_t_16(PyObject *self) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     BitMask_uint16_t_16
//////////////////
static PyObject *Dtool_RichCompare_BitMask_uint16_t_16(PyObject *self, PyObject *arg, int op) {
  BitMask< uint16_t, 16 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint16_t_16, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool BitMask< uint16_t, 16 >::operator ==(BitMask< uint16_t, 16 > const &other) const
      BitMask< uint16_t, 16 > arg_local;
      BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool BitMask< uint16_t, 16 >::operator !=(BitMask< uint16_t, 16 > const &other) const
      BitMask< uint16_t, 16 > arg_local;
      BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool BitMask< uint16_t, 16 >::operator <(BitMask< uint16_t, 16 > const &other) const
      BitMask< uint16_t, 16 > arg_local;
      BitMask< uint16_t, 16 > const *arg_this = Dtool_Coerce_BitMask_uint16_t_16(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const BitMask< uint16_t, 16 >*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_BitMask_uint16_t_16_compare_to_320_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_BitMask_uint16_t_16 = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_BitMask_uint16_t_16_nonzero_339_nb_bool,
  &Dtool_BitMask_uint16_t_16_operator_324_nb_invert,
  &Dtool_BitMask_uint16_t_16_operator_325_nb_lshift,
  &Dtool_BitMask_uint16_t_16_operator_326_nb_rshift,
  &Dtool_BitMask_uint16_t_16_operator_321_nb_and,
  &Dtool_BitMask_uint16_t_16_operator_323_nb_xor,
  &Dtool_BitMask_uint16_t_16_operator_322_nb_or,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  &Dtool_BitMask_uint16_t_16_operator_330_nb_inplace_lshift,
  &Dtool_BitMask_uint16_t_16_operator_331_nb_inplace_rshift,
  &Dtool_BitMask_uint16_t_16_operator_327_nb_inplace_and,
  &Dtool_BitMask_uint16_t_16_operator_329_nb_inplace_xor,
  &Dtool_BitMask_uint16_t_16_operator_328_nb_inplace_or,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_BitMask_uint16_t_16 = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BitMask_uint16_t_16",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BitMask_uint16_t_16,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_BitMask_uint16_t_16_compare_to_320_tp_compare,
#endif
    &Dtool_Repr_BitMask_uint16_t_16,
    &Dtool_NumberMethods_BitMask_uint16_t_16,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &Dtool_BitMask_uint16_t_16_get_key_338_tp_hash,
    nullptr,
    &Dtool_Str_BitMask_uint16_t_16,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_BitMask_uint16_t_16,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BitMask_uint16_t_16,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BitMask_uint16_t_16,
    PyType_GenericAlloc,
    Dtool_new_BitMask_uint16_t_16,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BitMask_uint16_t_16,
  Dtool_UpcastInterface_BitMask_uint16_t_16,
  Dtool_DowncastInterface_BitMask_uint16_t_16,
  nullptr,
  (CoerceFunction)Dtool_Coerce_BitMask_uint16_t_16,
};

static void Dtool_PyModuleClassInit_BitMask_uint16_t_16(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_BitMask_uint16_t_16._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BitMask_uint16_t_16._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BitMask_uint16_t_16) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BitMask_uint16_t_16)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BitMask_uint16_t_16);
  }
}

/**
 * Python method tables for BitMask_uint32_t_32 (BitMask_uint32_t_32)
 */
static PyMethodDef Dtool_Methods_BitMask_uint32_t_32[] = {
  {"all_on", &Dtool_BitMask_uint32_t_32_all_on_345, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_all_on_345_comment},
  {"allOn", &Dtool_BitMask_uint32_t_32_all_on_345, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_all_on_345_comment},
  {"all_off", &Dtool_BitMask_uint32_t_32_all_off_346, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_all_off_346_comment},
  {"allOff", &Dtool_BitMask_uint32_t_32_all_off_346, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_all_off_346_comment},
  {"lower_on", &Dtool_BitMask_uint32_t_32_lower_on_347, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_lower_on_347_comment},
  {"lowerOn", &Dtool_BitMask_uint32_t_32_lower_on_347, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_lower_on_347_comment},
  {"bit", &Dtool_BitMask_uint32_t_32_bit_348, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_bit_348_comment},
  {"range", (PyCFunction) &Dtool_BitMask_uint32_t_32_range_349, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_range_349_comment},
  {"has_max_num_bits", &Dtool_BitMask_uint32_t_32_has_max_num_bits_350, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_has_max_num_bits_350_comment},
  {"hasMaxNumBits", &Dtool_BitMask_uint32_t_32_has_max_num_bits_350, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_has_max_num_bits_350_comment},
  {"get_max_num_bits", &Dtool_BitMask_uint32_t_32_get_max_num_bits_351, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_get_max_num_bits_351_comment},
  {"getMaxNumBits", &Dtool_BitMask_uint32_t_32_get_max_num_bits_351, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_get_max_num_bits_351_comment},
  {"get_num_bits", &Dtool_BitMask_uint32_t_32_get_num_bits_352, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_num_bits_352_comment},
  {"getNumBits", &Dtool_BitMask_uint32_t_32_get_num_bits_352, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_num_bits_352_comment},
  {"get_bit", &Dtool_BitMask_uint32_t_32_get_bit_353, METH_O, (const char *)Dtool_BitMask_uint32_t_32_get_bit_353_comment},
  {"getBit", &Dtool_BitMask_uint32_t_32_get_bit_353, METH_O, (const char *)Dtool_BitMask_uint32_t_32_get_bit_353_comment},
  {"set_bit", &Dtool_BitMask_uint32_t_32_set_bit_354, METH_O, (const char *)Dtool_BitMask_uint32_t_32_set_bit_354_comment},
  {"setBit", &Dtool_BitMask_uint32_t_32_set_bit_354, METH_O, (const char *)Dtool_BitMask_uint32_t_32_set_bit_354_comment},
  {"clear_bit", &Dtool_BitMask_uint32_t_32_clear_bit_355, METH_O, (const char *)Dtool_BitMask_uint32_t_32_clear_bit_355_comment},
  {"clearBit", &Dtool_BitMask_uint32_t_32_clear_bit_355, METH_O, (const char *)Dtool_BitMask_uint32_t_32_clear_bit_355_comment},
  {"set_bit_to", (PyCFunction) &Dtool_BitMask_uint32_t_32_set_bit_to_356, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_set_bit_to_356_comment},
  {"setBitTo", (PyCFunction) &Dtool_BitMask_uint32_t_32_set_bit_to_356, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_set_bit_to_356_comment},
  {"is_zero", &Dtool_BitMask_uint32_t_32_is_zero_357, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_is_zero_357_comment},
  {"isZero", &Dtool_BitMask_uint32_t_32_is_zero_357, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_is_zero_357_comment},
  {"is_all_on", &Dtool_BitMask_uint32_t_32_is_all_on_358, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_is_all_on_358_comment},
  {"isAllOn", &Dtool_BitMask_uint32_t_32_is_all_on_358, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_is_all_on_358_comment},
  {"extract", (PyCFunction) &Dtool_BitMask_uint32_t_32_extract_359, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_extract_359_comment},
  {"store", (PyCFunction) &Dtool_BitMask_uint32_t_32_store_360, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_store_360_comment},
  {"has_any_of", (PyCFunction) &Dtool_BitMask_uint32_t_32_has_any_of_361, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_has_any_of_361_comment},
  {"hasAnyOf", (PyCFunction) &Dtool_BitMask_uint32_t_32_has_any_of_361, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_has_any_of_361_comment},
  {"has_all_of", (PyCFunction) &Dtool_BitMask_uint32_t_32_has_all_of_362, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_has_all_of_362_comment},
  {"hasAllOf", (PyCFunction) &Dtool_BitMask_uint32_t_32_has_all_of_362, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_has_all_of_362_comment},
  {"set_range", (PyCFunction) &Dtool_BitMask_uint32_t_32_set_range_363, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_set_range_363_comment},
  {"setRange", (PyCFunction) &Dtool_BitMask_uint32_t_32_set_range_363, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_set_range_363_comment},
  {"clear_range", (PyCFunction) &Dtool_BitMask_uint32_t_32_clear_range_364, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_clear_range_364_comment},
  {"clearRange", (PyCFunction) &Dtool_BitMask_uint32_t_32_clear_range_364, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_clear_range_364_comment},
  {"set_range_to", (PyCFunction) &Dtool_BitMask_uint32_t_32_set_range_to_365, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_set_range_to_365_comment},
  {"setRangeTo", (PyCFunction) &Dtool_BitMask_uint32_t_32_set_range_to_365, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_set_range_to_365_comment},
  {"get_word", &Dtool_BitMask_uint32_t_32_get_word_366, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_word_366_comment},
  {"getWord", &Dtool_BitMask_uint32_t_32_get_word_366, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_word_366_comment},
  {"set_word", &Dtool_BitMask_uint32_t_32_set_word_367, METH_O, (const char *)Dtool_BitMask_uint32_t_32_set_word_367_comment},
  {"setWord", &Dtool_BitMask_uint32_t_32_set_word_367, METH_O, (const char *)Dtool_BitMask_uint32_t_32_set_word_367_comment},
  {"get_num_on_bits", &Dtool_BitMask_uint32_t_32_get_num_on_bits_368, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_num_on_bits_368_comment},
  {"getNumOnBits", &Dtool_BitMask_uint32_t_32_get_num_on_bits_368, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_num_on_bits_368_comment},
  {"get_num_off_bits", &Dtool_BitMask_uint32_t_32_get_num_off_bits_369, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_num_off_bits_369_comment},
  {"getNumOffBits", &Dtool_BitMask_uint32_t_32_get_num_off_bits_369, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_num_off_bits_369_comment},
  {"get_lowest_on_bit", &Dtool_BitMask_uint32_t_32_get_lowest_on_bit_370, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_lowest_on_bit_370_comment},
  {"getLowestOnBit", &Dtool_BitMask_uint32_t_32_get_lowest_on_bit_370, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_lowest_on_bit_370_comment},
  {"get_lowest_off_bit", &Dtool_BitMask_uint32_t_32_get_lowest_off_bit_371, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_lowest_off_bit_371_comment},
  {"getLowestOffBit", &Dtool_BitMask_uint32_t_32_get_lowest_off_bit_371, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_lowest_off_bit_371_comment},
  {"get_highest_on_bit", &Dtool_BitMask_uint32_t_32_get_highest_on_bit_372, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_highest_on_bit_372_comment},
  {"getHighestOnBit", &Dtool_BitMask_uint32_t_32_get_highest_on_bit_372, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_highest_on_bit_372_comment},
  {"get_highest_off_bit", &Dtool_BitMask_uint32_t_32_get_highest_off_bit_373, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_highest_off_bit_373_comment},
  {"getHighestOffBit", &Dtool_BitMask_uint32_t_32_get_highest_off_bit_373, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_highest_off_bit_373_comment},
  {"get_next_higher_different_bit", &Dtool_BitMask_uint32_t_32_get_next_higher_different_bit_374, METH_O, (const char *)Dtool_BitMask_uint32_t_32_get_next_higher_different_bit_374_comment},
  {"getNextHigherDifferentBit", &Dtool_BitMask_uint32_t_32_get_next_higher_different_bit_374, METH_O, (const char *)Dtool_BitMask_uint32_t_32_get_next_higher_different_bit_374_comment},
  {"invert_in_place", &Dtool_BitMask_uint32_t_32_invert_in_place_375, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_invert_in_place_375_comment},
  {"invertInPlace", &Dtool_BitMask_uint32_t_32_invert_in_place_375, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_invert_in_place_375_comment},
  {"has_bits_in_common", &Dtool_BitMask_uint32_t_32_has_bits_in_common_376, METH_O, (const char *)Dtool_BitMask_uint32_t_32_has_bits_in_common_376_comment},
  {"hasBitsInCommon", &Dtool_BitMask_uint32_t_32_has_bits_in_common_376, METH_O, (const char *)Dtool_BitMask_uint32_t_32_has_bits_in_common_376_comment},
  {"clear", &Dtool_BitMask_uint32_t_32_clear_377, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_clear_377_comment},
  {"output", &Dtool_BitMask_uint32_t_32_output_378, METH_O, (const char *)Dtool_BitMask_uint32_t_32_output_378_comment},
  {"output_binary", (PyCFunction) &Dtool_BitMask_uint32_t_32_output_binary_379, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_output_binary_379_comment},
  {"outputBinary", (PyCFunction) &Dtool_BitMask_uint32_t_32_output_binary_379, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_output_binary_379_comment},
  {"output_hex", (PyCFunction) &Dtool_BitMask_uint32_t_32_output_hex_380, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_output_hex_380_comment},
  {"outputHex", (PyCFunction) &Dtool_BitMask_uint32_t_32_output_hex_380, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_output_hex_380_comment},
  {"write", (PyCFunction) &Dtool_BitMask_uint32_t_32_write_381, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint32_t_32_write_381_comment},
  {"compare_to", &Dtool_BitMask_uint32_t_32_compare_to_385, METH_O, (const char *)Dtool_BitMask_uint32_t_32_compare_to_385_comment},
  {"compareTo", &Dtool_BitMask_uint32_t_32_compare_to_385, METH_O, (const char *)Dtool_BitMask_uint32_t_32_compare_to_385_comment},
  {"flood_down_in_place", &Dtool_BitMask_uint32_t_32_flood_down_in_place_397, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_flood_down_in_place_397_comment},
  {"floodDownInPlace", &Dtool_BitMask_uint32_t_32_flood_down_in_place_397, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_flood_down_in_place_397_comment},
  {"flood_up_in_place", &Dtool_BitMask_uint32_t_32_flood_up_in_place_398, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_flood_up_in_place_398_comment},
  {"floodUpInPlace", &Dtool_BitMask_uint32_t_32_flood_up_in_place_398, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_flood_up_in_place_398_comment},
  {"flood_bits_down", &Dtool_BitMask_uint32_t_32_flood_bits_down_399, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_flood_bits_down_399_comment},
  {"floodBitsDown", &Dtool_BitMask_uint32_t_32_flood_bits_down_399, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_flood_bits_down_399_comment},
  {"flood_bits_up", &Dtool_BitMask_uint32_t_32_flood_bits_up_400, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_flood_bits_up_400_comment},
  {"floodBitsUp", &Dtool_BitMask_uint32_t_32_flood_bits_up_400, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_flood_bits_up_400_comment},
  {"keep_next_highest_bit", &Dtool_BitMask_uint32_t_32_keep_next_highest_bit_401, METH_VARARGS, (const char *)Dtool_BitMask_uint32_t_32_keep_next_highest_bit_401_comment},
  {"keepNextHighestBit", &Dtool_BitMask_uint32_t_32_keep_next_highest_bit_401, METH_VARARGS, (const char *)Dtool_BitMask_uint32_t_32_keep_next_highest_bit_401_comment},
  {"keep_next_lowest_bit", &Dtool_BitMask_uint32_t_32_keep_next_lowest_bit_402, METH_VARARGS, (const char *)Dtool_BitMask_uint32_t_32_keep_next_lowest_bit_402_comment},
  {"keepNextLowestBit", &Dtool_BitMask_uint32_t_32_keep_next_lowest_bit_402, METH_VARARGS, (const char *)Dtool_BitMask_uint32_t_32_keep_next_lowest_bit_402_comment},
  {"get_key", &Dtool_BitMask_uint32_t_32_get_key_403, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_key_403_comment},
  {"getKey", &Dtool_BitMask_uint32_t_32_get_key_403, METH_NOARGS, (const char *)Dtool_BitMask_uint32_t_32_get_key_403_comment},
  {"get_class_type", &Dtool_BitMask_uint32_t_32_get_class_type_405, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_get_class_type_405_comment},
  {"getClassType", &Dtool_BitMask_uint32_t_32_get_class_type_405, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint32_t_32_get_class_type_405_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_and -> operator &
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_386_nb_and(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator &(BitMask< uint32_t, 32 > const &other) const
  BitMask< uint32_t, 32 > arg_local;
  BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__and__", "BitMask");
  }
  BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(((*(const BitMask< uint32_t, 32 >*)local_this).operator &)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_bool -> __nonzero__
//////////////////
static int Dtool_BitMask_uint32_t_32_nonzero_404_nb_bool(PyObject *self) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return -1;
  }

  return (int) ((*local_this).__nonzero__)();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_inplace_and -> operator &=
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_392_nb_inplace_and(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void BitMask< uint32_t, 32 >::operator &=(BitMask< uint32_t, 32 > const &other)
  BitMask< uint32_t, 32 > arg_local;
  BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__iand__", "BitMask");
    return nullptr;
  }
  ((*local_this).operator &=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_inplace_lshift -> operator <<=
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_395_nb_inplace_lshift(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void BitMask< uint32_t, 32 >::operator <<=(int shift)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return nullptr;
    }
#endif
    ((*local_this).operator <<=)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_inplace_or -> operator |=
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_393_nb_inplace_or(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void BitMask< uint32_t, 32 >::operator |=(BitMask< uint32_t, 32 > const &other)
  BitMask< uint32_t, 32 > arg_local;
  BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__ior__", "BitMask");
    return nullptr;
  }
  ((*local_this).operator |=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_inplace_rshift -> operator >>=
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_396_nb_inplace_rshift(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void BitMask< uint32_t, 32 >::operator >>=(int shift)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return nullptr;
    }
#endif
    ((*local_this).operator >>=)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_inplace_xor -> operator ^=
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_394_nb_inplace_xor(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void BitMask< uint32_t, 32 >::operator ^=(BitMask< uint32_t, 32 > const &other)
  BitMask< uint32_t, 32 > arg_local;
  BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__ixor__", "BitMask");
    return nullptr;
  }
  ((*local_this).operator ^=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_invert -> operator ~
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_389_nb_invert(PyObject *self) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator ~(void) const
  BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(((*(const BitMask< uint32_t, 32 >*)local_this).operator ~)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__invert__(BitMask self)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_lshift -> operator <<
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_390_nb_lshift(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator <<(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(((*(const BitMask< uint32_t, 32 >*)local_this).operator <<)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_or -> operator |
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_387_nb_or(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator |(BitMask< uint32_t, 32 > const &other) const
  BitMask< uint32_t, 32 > arg_local;
  BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__or__", "BitMask");
  }
  BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(((*(const BitMask< uint32_t, 32 >*)local_this).operator |)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_rshift -> operator >>
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_391_nb_rshift(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator >>(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(((*(const BitMask< uint32_t, 32 >*)local_this).operator >>)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot nb_xor -> operator ^
//////////////////
static PyObject *Dtool_BitMask_uint32_t_32_operator_388_nb_xor(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint32_t_32, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint32_t, 32 > BitMask< uint32_t, 32 >::operator ^(BitMask< uint32_t, 32 > const &other) const
  BitMask< uint32_t, 32 > arg_local;
  BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__xor__", "BitMask");
  }
  BitMask< uint32_t, 32 > *return_value = new BitMask< uint32_t, 32 >(((*(const BitMask< uint32_t, 32 >*)local_this).operator ^)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint32_t_32, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot tp_compare -> compare_to
//////////////////
static int Dtool_BitMask_uint32_t_32_compare_to_385_tp_compare(PyObject *self, PyObject *arg) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int BitMask< uint32_t, 32 >::compare_to(BitMask< uint32_t, 32 > const &other) const
  BitMask< uint32_t, 32 > arg_local;
  BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitMask.compare_to", "BitMask");
    return -1;
  }
  int return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(BitMask self, const BitMask other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint32_t_32 slot tp_hash -> get_key
//////////////////
static Py_hash_t Dtool_BitMask_uint32_t_32_get_key_403_tp_hash(PyObject *self) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) ((*local_this).get_key)();
}

//////////////////
//  A __repr__ function
//     BitMask_uint32_t_32
//////////////////
static PyObject *Dtool_Repr_BitMask_uint32_t_32(PyObject *self) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BitMask_uint32_t_32
//////////////////
static PyObject *Dtool_Str_BitMask_uint32_t_32(PyObject *self) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     BitMask_uint32_t_32
//////////////////
static PyObject *Dtool_RichCompare_BitMask_uint32_t_32(PyObject *self, PyObject *arg, int op) {
  BitMask< uint32_t, 32 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint32_t_32, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool BitMask< uint32_t, 32 >::operator ==(BitMask< uint32_t, 32 > const &other) const
      BitMask< uint32_t, 32 > arg_local;
      BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool BitMask< uint32_t, 32 >::operator !=(BitMask< uint32_t, 32 > const &other) const
      BitMask< uint32_t, 32 > arg_local;
      BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool BitMask< uint32_t, 32 >::operator <(BitMask< uint32_t, 32 > const &other) const
      BitMask< uint32_t, 32 > arg_local;
      BitMask< uint32_t, 32 > const *arg_this = Dtool_Coerce_BitMask_uint32_t_32(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const BitMask< uint32_t, 32 >*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_BitMask_uint32_t_32_compare_to_385_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_BitMask_uint32_t_32 = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_BitMask_uint32_t_32_nonzero_404_nb_bool,
  &Dtool_BitMask_uint32_t_32_operator_389_nb_invert,
  &Dtool_BitMask_uint32_t_32_operator_390_nb_lshift,
  &Dtool_BitMask_uint32_t_32_operator_391_nb_rshift,
  &Dtool_BitMask_uint32_t_32_operator_386_nb_and,
  &Dtool_BitMask_uint32_t_32_operator_388_nb_xor,
  &Dtool_BitMask_uint32_t_32_operator_387_nb_or,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  &Dtool_BitMask_uint32_t_32_operator_395_nb_inplace_lshift,
  &Dtool_BitMask_uint32_t_32_operator_396_nb_inplace_rshift,
  &Dtool_BitMask_uint32_t_32_operator_392_nb_inplace_and,
  &Dtool_BitMask_uint32_t_32_operator_394_nb_inplace_xor,
  &Dtool_BitMask_uint32_t_32_operator_393_nb_inplace_or,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_BitMask_uint32_t_32 = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BitMask_uint32_t_32",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BitMask_uint32_t_32,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_BitMask_uint32_t_32_compare_to_385_tp_compare,
#endif
    &Dtool_Repr_BitMask_uint32_t_32,
    &Dtool_NumberMethods_BitMask_uint32_t_32,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &Dtool_BitMask_uint32_t_32_get_key_403_tp_hash,
    nullptr,
    &Dtool_Str_BitMask_uint32_t_32,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_BitMask_uint32_t_32,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BitMask_uint32_t_32,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BitMask_uint32_t_32,
    PyType_GenericAlloc,
    Dtool_new_BitMask_uint32_t_32,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BitMask_uint32_t_32,
  Dtool_UpcastInterface_BitMask_uint32_t_32,
  Dtool_DowncastInterface_BitMask_uint32_t_32,
  nullptr,
  (CoerceFunction)Dtool_Coerce_BitMask_uint32_t_32,
};

static void Dtool_PyModuleClassInit_BitMask_uint32_t_32(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_BitMask_uint32_t_32._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BitMask_uint32_t_32._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BitMask_uint32_t_32) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BitMask_uint32_t_32)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BitMask_uint32_t_32);
  }
}

/**
 * Python method tables for BitMask_uint64_t_64 (BitMask_uint64_t_64)
 */
static PyMethodDef Dtool_Methods_BitMask_uint64_t_64[] = {
  {"all_on", &Dtool_BitMask_uint64_t_64_all_on_410, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_all_on_410_comment},
  {"allOn", &Dtool_BitMask_uint64_t_64_all_on_410, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_all_on_410_comment},
  {"all_off", &Dtool_BitMask_uint64_t_64_all_off_411, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_all_off_411_comment},
  {"allOff", &Dtool_BitMask_uint64_t_64_all_off_411, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_all_off_411_comment},
  {"lower_on", &Dtool_BitMask_uint64_t_64_lower_on_412, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_lower_on_412_comment},
  {"lowerOn", &Dtool_BitMask_uint64_t_64_lower_on_412, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_lower_on_412_comment},
  {"bit", &Dtool_BitMask_uint64_t_64_bit_413, METH_O | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_bit_413_comment},
  {"range", (PyCFunction) &Dtool_BitMask_uint64_t_64_range_414, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_range_414_comment},
  {"has_max_num_bits", &Dtool_BitMask_uint64_t_64_has_max_num_bits_415, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_has_max_num_bits_415_comment},
  {"hasMaxNumBits", &Dtool_BitMask_uint64_t_64_has_max_num_bits_415, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_has_max_num_bits_415_comment},
  {"get_max_num_bits", &Dtool_BitMask_uint64_t_64_get_max_num_bits_416, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_get_max_num_bits_416_comment},
  {"getMaxNumBits", &Dtool_BitMask_uint64_t_64_get_max_num_bits_416, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_get_max_num_bits_416_comment},
  {"get_num_bits", &Dtool_BitMask_uint64_t_64_get_num_bits_417, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_num_bits_417_comment},
  {"getNumBits", &Dtool_BitMask_uint64_t_64_get_num_bits_417, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_num_bits_417_comment},
  {"get_bit", &Dtool_BitMask_uint64_t_64_get_bit_418, METH_O, (const char *)Dtool_BitMask_uint64_t_64_get_bit_418_comment},
  {"getBit", &Dtool_BitMask_uint64_t_64_get_bit_418, METH_O, (const char *)Dtool_BitMask_uint64_t_64_get_bit_418_comment},
  {"set_bit", &Dtool_BitMask_uint64_t_64_set_bit_419, METH_O, (const char *)Dtool_BitMask_uint64_t_64_set_bit_419_comment},
  {"setBit", &Dtool_BitMask_uint64_t_64_set_bit_419, METH_O, (const char *)Dtool_BitMask_uint64_t_64_set_bit_419_comment},
  {"clear_bit", &Dtool_BitMask_uint64_t_64_clear_bit_420, METH_O, (const char *)Dtool_BitMask_uint64_t_64_clear_bit_420_comment},
  {"clearBit", &Dtool_BitMask_uint64_t_64_clear_bit_420, METH_O, (const char *)Dtool_BitMask_uint64_t_64_clear_bit_420_comment},
  {"set_bit_to", (PyCFunction) &Dtool_BitMask_uint64_t_64_set_bit_to_421, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_set_bit_to_421_comment},
  {"setBitTo", (PyCFunction) &Dtool_BitMask_uint64_t_64_set_bit_to_421, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_set_bit_to_421_comment},
  {"is_zero", &Dtool_BitMask_uint64_t_64_is_zero_422, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_is_zero_422_comment},
  {"isZero", &Dtool_BitMask_uint64_t_64_is_zero_422, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_is_zero_422_comment},
  {"is_all_on", &Dtool_BitMask_uint64_t_64_is_all_on_423, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_is_all_on_423_comment},
  {"isAllOn", &Dtool_BitMask_uint64_t_64_is_all_on_423, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_is_all_on_423_comment},
  {"extract", (PyCFunction) &Dtool_BitMask_uint64_t_64_extract_424, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_extract_424_comment},
  {"store", (PyCFunction) &Dtool_BitMask_uint64_t_64_store_425, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_store_425_comment},
  {"has_any_of", (PyCFunction) &Dtool_BitMask_uint64_t_64_has_any_of_426, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_has_any_of_426_comment},
  {"hasAnyOf", (PyCFunction) &Dtool_BitMask_uint64_t_64_has_any_of_426, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_has_any_of_426_comment},
  {"has_all_of", (PyCFunction) &Dtool_BitMask_uint64_t_64_has_all_of_427, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_has_all_of_427_comment},
  {"hasAllOf", (PyCFunction) &Dtool_BitMask_uint64_t_64_has_all_of_427, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_has_all_of_427_comment},
  {"set_range", (PyCFunction) &Dtool_BitMask_uint64_t_64_set_range_428, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_set_range_428_comment},
  {"setRange", (PyCFunction) &Dtool_BitMask_uint64_t_64_set_range_428, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_set_range_428_comment},
  {"clear_range", (PyCFunction) &Dtool_BitMask_uint64_t_64_clear_range_429, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_clear_range_429_comment},
  {"clearRange", (PyCFunction) &Dtool_BitMask_uint64_t_64_clear_range_429, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_clear_range_429_comment},
  {"set_range_to", (PyCFunction) &Dtool_BitMask_uint64_t_64_set_range_to_430, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_set_range_to_430_comment},
  {"setRangeTo", (PyCFunction) &Dtool_BitMask_uint64_t_64_set_range_to_430, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_set_range_to_430_comment},
  {"get_word", &Dtool_BitMask_uint64_t_64_get_word_431, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_word_431_comment},
  {"getWord", &Dtool_BitMask_uint64_t_64_get_word_431, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_word_431_comment},
  {"set_word", &Dtool_BitMask_uint64_t_64_set_word_432, METH_O, (const char *)Dtool_BitMask_uint64_t_64_set_word_432_comment},
  {"setWord", &Dtool_BitMask_uint64_t_64_set_word_432, METH_O, (const char *)Dtool_BitMask_uint64_t_64_set_word_432_comment},
  {"get_num_on_bits", &Dtool_BitMask_uint64_t_64_get_num_on_bits_433, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_num_on_bits_433_comment},
  {"getNumOnBits", &Dtool_BitMask_uint64_t_64_get_num_on_bits_433, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_num_on_bits_433_comment},
  {"get_num_off_bits", &Dtool_BitMask_uint64_t_64_get_num_off_bits_434, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_num_off_bits_434_comment},
  {"getNumOffBits", &Dtool_BitMask_uint64_t_64_get_num_off_bits_434, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_num_off_bits_434_comment},
  {"get_lowest_on_bit", &Dtool_BitMask_uint64_t_64_get_lowest_on_bit_435, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_lowest_on_bit_435_comment},
  {"getLowestOnBit", &Dtool_BitMask_uint64_t_64_get_lowest_on_bit_435, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_lowest_on_bit_435_comment},
  {"get_lowest_off_bit", &Dtool_BitMask_uint64_t_64_get_lowest_off_bit_436, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_lowest_off_bit_436_comment},
  {"getLowestOffBit", &Dtool_BitMask_uint64_t_64_get_lowest_off_bit_436, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_lowest_off_bit_436_comment},
  {"get_highest_on_bit", &Dtool_BitMask_uint64_t_64_get_highest_on_bit_437, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_highest_on_bit_437_comment},
  {"getHighestOnBit", &Dtool_BitMask_uint64_t_64_get_highest_on_bit_437, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_highest_on_bit_437_comment},
  {"get_highest_off_bit", &Dtool_BitMask_uint64_t_64_get_highest_off_bit_438, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_highest_off_bit_438_comment},
  {"getHighestOffBit", &Dtool_BitMask_uint64_t_64_get_highest_off_bit_438, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_highest_off_bit_438_comment},
  {"get_next_higher_different_bit", &Dtool_BitMask_uint64_t_64_get_next_higher_different_bit_439, METH_O, (const char *)Dtool_BitMask_uint64_t_64_get_next_higher_different_bit_439_comment},
  {"getNextHigherDifferentBit", &Dtool_BitMask_uint64_t_64_get_next_higher_different_bit_439, METH_O, (const char *)Dtool_BitMask_uint64_t_64_get_next_higher_different_bit_439_comment},
  {"invert_in_place", &Dtool_BitMask_uint64_t_64_invert_in_place_440, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_invert_in_place_440_comment},
  {"invertInPlace", &Dtool_BitMask_uint64_t_64_invert_in_place_440, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_invert_in_place_440_comment},
  {"has_bits_in_common", &Dtool_BitMask_uint64_t_64_has_bits_in_common_441, METH_O, (const char *)Dtool_BitMask_uint64_t_64_has_bits_in_common_441_comment},
  {"hasBitsInCommon", &Dtool_BitMask_uint64_t_64_has_bits_in_common_441, METH_O, (const char *)Dtool_BitMask_uint64_t_64_has_bits_in_common_441_comment},
  {"clear", &Dtool_BitMask_uint64_t_64_clear_442, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_clear_442_comment},
  {"output", &Dtool_BitMask_uint64_t_64_output_443, METH_O, (const char *)Dtool_BitMask_uint64_t_64_output_443_comment},
  {"output_binary", (PyCFunction) &Dtool_BitMask_uint64_t_64_output_binary_444, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_output_binary_444_comment},
  {"outputBinary", (PyCFunction) &Dtool_BitMask_uint64_t_64_output_binary_444, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_output_binary_444_comment},
  {"output_hex", (PyCFunction) &Dtool_BitMask_uint64_t_64_output_hex_445, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_output_hex_445_comment},
  {"outputHex", (PyCFunction) &Dtool_BitMask_uint64_t_64_output_hex_445, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_output_hex_445_comment},
  {"write", (PyCFunction) &Dtool_BitMask_uint64_t_64_write_446, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitMask_uint64_t_64_write_446_comment},
  {"compare_to", &Dtool_BitMask_uint64_t_64_compare_to_450, METH_O, (const char *)Dtool_BitMask_uint64_t_64_compare_to_450_comment},
  {"compareTo", &Dtool_BitMask_uint64_t_64_compare_to_450, METH_O, (const char *)Dtool_BitMask_uint64_t_64_compare_to_450_comment},
  {"flood_down_in_place", &Dtool_BitMask_uint64_t_64_flood_down_in_place_462, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_flood_down_in_place_462_comment},
  {"floodDownInPlace", &Dtool_BitMask_uint64_t_64_flood_down_in_place_462, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_flood_down_in_place_462_comment},
  {"flood_up_in_place", &Dtool_BitMask_uint64_t_64_flood_up_in_place_463, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_flood_up_in_place_463_comment},
  {"floodUpInPlace", &Dtool_BitMask_uint64_t_64_flood_up_in_place_463, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_flood_up_in_place_463_comment},
  {"flood_bits_down", &Dtool_BitMask_uint64_t_64_flood_bits_down_464, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_flood_bits_down_464_comment},
  {"floodBitsDown", &Dtool_BitMask_uint64_t_64_flood_bits_down_464, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_flood_bits_down_464_comment},
  {"flood_bits_up", &Dtool_BitMask_uint64_t_64_flood_bits_up_465, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_flood_bits_up_465_comment},
  {"floodBitsUp", &Dtool_BitMask_uint64_t_64_flood_bits_up_465, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_flood_bits_up_465_comment},
  {"keep_next_highest_bit", &Dtool_BitMask_uint64_t_64_keep_next_highest_bit_466, METH_VARARGS, (const char *)Dtool_BitMask_uint64_t_64_keep_next_highest_bit_466_comment},
  {"keepNextHighestBit", &Dtool_BitMask_uint64_t_64_keep_next_highest_bit_466, METH_VARARGS, (const char *)Dtool_BitMask_uint64_t_64_keep_next_highest_bit_466_comment},
  {"keep_next_lowest_bit", &Dtool_BitMask_uint64_t_64_keep_next_lowest_bit_467, METH_VARARGS, (const char *)Dtool_BitMask_uint64_t_64_keep_next_lowest_bit_467_comment},
  {"keepNextLowestBit", &Dtool_BitMask_uint64_t_64_keep_next_lowest_bit_467, METH_VARARGS, (const char *)Dtool_BitMask_uint64_t_64_keep_next_lowest_bit_467_comment},
  {"get_key", &Dtool_BitMask_uint64_t_64_get_key_468, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_key_468_comment},
  {"getKey", &Dtool_BitMask_uint64_t_64_get_key_468, METH_NOARGS, (const char *)Dtool_BitMask_uint64_t_64_get_key_468_comment},
  {"get_class_type", &Dtool_BitMask_uint64_t_64_get_class_type_470, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_get_class_type_470_comment},
  {"getClassType", &Dtool_BitMask_uint64_t_64_get_class_type_470, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitMask_uint64_t_64_get_class_type_470_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_and -> operator &
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_451_nb_and(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator &(BitMask< uint64_t, 64 > const &other) const
  BitMask< uint64_t, 64 > arg_local;
  BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__and__", "BitMask");
  }
  BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(((*(const BitMask< uint64_t, 64 >*)local_this).operator &)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_bool -> __nonzero__
//////////////////
static int Dtool_BitMask_uint64_t_64_nonzero_469_nb_bool(PyObject *self) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return -1;
  }

  return (int) ((*local_this).__nonzero__)();
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_inplace_and -> operator &=
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_457_nb_inplace_and(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void BitMask< uint64_t, 64 >::operator &=(BitMask< uint64_t, 64 > const &other)
  BitMask< uint64_t, 64 > arg_local;
  BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__iand__", "BitMask");
    return nullptr;
  }
  ((*local_this).operator &=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_inplace_lshift -> operator <<=
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_460_nb_inplace_lshift(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void BitMask< uint64_t, 64 >::operator <<=(int shift)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return nullptr;
    }
#endif
    ((*local_this).operator <<=)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_inplace_or -> operator |=
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_458_nb_inplace_or(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void BitMask< uint64_t, 64 >::operator |=(BitMask< uint64_t, 64 > const &other)
  BitMask< uint64_t, 64 > arg_local;
  BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__ior__", "BitMask");
    return nullptr;
  }
  ((*local_this).operator |=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_inplace_rshift -> operator >>=
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_461_nb_inplace_rshift(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void BitMask< uint64_t, 64 >::operator >>=(int shift)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return nullptr;
    }
#endif
    ((*local_this).operator >>=)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_inplace_xor -> operator ^=
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_459_nb_inplace_xor(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void BitMask< uint64_t, 64 >::operator ^=(BitMask< uint64_t, 64 > const &other)
  BitMask< uint64_t, 64 > arg_local;
  BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__ixor__", "BitMask");
    return nullptr;
  }
  ((*local_this).operator ^=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_invert -> operator ~
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_454_nb_invert(PyObject *self) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator ~(void) const
  BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(((*(const BitMask< uint64_t, 64 >*)local_this).operator ~)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__invert__(BitMask self)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_lshift -> operator <<
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_455_nb_lshift(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator <<(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(((*(const BitMask< uint64_t, 64 >*)local_this).operator <<)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_or -> operator |
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_452_nb_or(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator |(BitMask< uint64_t, 64 > const &other) const
  BitMask< uint64_t, 64 > arg_local;
  BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__or__", "BitMask");
  }
  BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(((*(const BitMask< uint64_t, 64 >*)local_this).operator |)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_rshift -> operator >>
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_456_nb_rshift(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator >>(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(((*(const BitMask< uint64_t, 64 >*)local_this).operator >>)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot nb_xor -> operator ^
//////////////////
static PyObject *Dtool_BitMask_uint64_t_64_operator_453_nb_xor(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitMask_uint64_t_64, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitMask< uint64_t, 64 > BitMask< uint64_t, 64 >::operator ^(BitMask< uint64_t, 64 > const &other) const
  BitMask< uint64_t, 64 > arg_local;
  BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitMask.__xor__", "BitMask");
  }
  BitMask< uint64_t, 64 > *return_value = new BitMask< uint64_t, 64 >(((*(const BitMask< uint64_t, 64 >*)local_this).operator ^)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitMask_uint64_t_64, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot tp_compare -> compare_to
//////////////////
static int Dtool_BitMask_uint64_t_64_compare_to_450_tp_compare(PyObject *self, PyObject *arg) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int BitMask< uint64_t, 64 >::compare_to(BitMask< uint64_t, 64 > const &other) const
  BitMask< uint64_t, 64 > arg_local;
  BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitMask.compare_to", "BitMask");
    return -1;
  }
  int return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(BitMask self, const BitMask other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitMask_uint64_t_64 slot tp_hash -> get_key
//////////////////
static Py_hash_t Dtool_BitMask_uint64_t_64_get_key_468_tp_hash(PyObject *self) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) ((*local_this).get_key)();
}

//////////////////
//  A __repr__ function
//     BitMask_uint64_t_64
//////////////////
static PyObject *Dtool_Repr_BitMask_uint64_t_64(PyObject *self) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BitMask_uint64_t_64
//////////////////
static PyObject *Dtool_Str_BitMask_uint64_t_64(PyObject *self) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     BitMask_uint64_t_64
//////////////////
static PyObject *Dtool_RichCompare_BitMask_uint64_t_64(PyObject *self, PyObject *arg, int op) {
  BitMask< uint64_t, 64 > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitMask_uint64_t_64, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool BitMask< uint64_t, 64 >::operator ==(BitMask< uint64_t, 64 > const &other) const
      BitMask< uint64_t, 64 > arg_local;
      BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool BitMask< uint64_t, 64 >::operator !=(BitMask< uint64_t, 64 > const &other) const
      BitMask< uint64_t, 64 > arg_local;
      BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool BitMask< uint64_t, 64 >::operator <(BitMask< uint64_t, 64 > const &other) const
      BitMask< uint64_t, 64 > arg_local;
      BitMask< uint64_t, 64 > const *arg_this = Dtool_Coerce_BitMask_uint64_t_64(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const BitMask< uint64_t, 64 >*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_BitMask_uint64_t_64_compare_to_450_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_BitMask_uint64_t_64 = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_BitMask_uint64_t_64_nonzero_469_nb_bool,
  &Dtool_BitMask_uint64_t_64_operator_454_nb_invert,
  &Dtool_BitMask_uint64_t_64_operator_455_nb_lshift,
  &Dtool_BitMask_uint64_t_64_operator_456_nb_rshift,
  &Dtool_BitMask_uint64_t_64_operator_451_nb_and,
  &Dtool_BitMask_uint64_t_64_operator_453_nb_xor,
  &Dtool_BitMask_uint64_t_64_operator_452_nb_or,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  &Dtool_BitMask_uint64_t_64_operator_460_nb_inplace_lshift,
  &Dtool_BitMask_uint64_t_64_operator_461_nb_inplace_rshift,
  &Dtool_BitMask_uint64_t_64_operator_457_nb_inplace_and,
  &Dtool_BitMask_uint64_t_64_operator_459_nb_inplace_xor,
  &Dtool_BitMask_uint64_t_64_operator_458_nb_inplace_or,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_BitMask_uint64_t_64 = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BitMask_uint64_t_64",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BitMask_uint64_t_64,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_BitMask_uint64_t_64_compare_to_450_tp_compare,
#endif
    &Dtool_Repr_BitMask_uint64_t_64,
    &Dtool_NumberMethods_BitMask_uint64_t_64,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &Dtool_BitMask_uint64_t_64_get_key_468_tp_hash,
    nullptr,
    &Dtool_Str_BitMask_uint64_t_64,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_BitMask_uint64_t_64,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BitMask_uint64_t_64,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BitMask_uint64_t_64,
    PyType_GenericAlloc,
    Dtool_new_BitMask_uint64_t_64,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BitMask_uint64_t_64,
  Dtool_UpcastInterface_BitMask_uint64_t_64,
  Dtool_DowncastInterface_BitMask_uint64_t_64,
  nullptr,
  (CoerceFunction)Dtool_Coerce_BitMask_uint64_t_64,
};

static void Dtool_PyModuleClassInit_BitMask_uint64_t_64(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_BitMask_uint64_t_64._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BitMask_uint64_t_64._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BitMask_uint64_t_64) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BitMask_uint64_t_64)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BitMask_uint64_t_64);
  }
}

/**
 * Python method tables for BitArray (BitArray)
 */
static PyMethodDef Dtool_Methods_BitArray[] = {
  {"all_on", &Dtool_BitArray_all_on_477, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_all_on_477_comment},
  {"allOn", &Dtool_BitArray_all_on_477, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_all_on_477_comment},
  {"all_off", &Dtool_BitArray_all_off_478, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_all_off_478_comment},
  {"allOff", &Dtool_BitArray_all_off_478, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_all_off_478_comment},
  {"lower_on", &Dtool_BitArray_lower_on_479, METH_O | METH_STATIC, (const char *)Dtool_BitArray_lower_on_479_comment},
  {"lowerOn", &Dtool_BitArray_lower_on_479, METH_O | METH_STATIC, (const char *)Dtool_BitArray_lower_on_479_comment},
  {"bit", &Dtool_BitArray_bit_480, METH_O | METH_STATIC, (const char *)Dtool_BitArray_bit_480_comment},
  {"range", (PyCFunction) &Dtool_BitArray_range_481, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_BitArray_range_481_comment},
  {"has_max_num_bits", &Dtool_BitArray_has_max_num_bits_482, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_has_max_num_bits_482_comment},
  {"hasMaxNumBits", &Dtool_BitArray_has_max_num_bits_482, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_has_max_num_bits_482_comment},
  {"get_max_num_bits", &Dtool_BitArray_get_max_num_bits_483, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_get_max_num_bits_483_comment},
  {"getMaxNumBits", &Dtool_BitArray_get_max_num_bits_483, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_get_max_num_bits_483_comment},
  {"get_num_bits_per_word", &Dtool_BitArray_get_num_bits_per_word_484, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_get_num_bits_per_word_484_comment},
  {"getNumBitsPerWord", &Dtool_BitArray_get_num_bits_per_word_484, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_get_num_bits_per_word_484_comment},
  {"get_num_bits", &Dtool_BitArray_get_num_bits_485, METH_NOARGS, (const char *)Dtool_BitArray_get_num_bits_485_comment},
  {"getNumBits", &Dtool_BitArray_get_num_bits_485, METH_NOARGS, (const char *)Dtool_BitArray_get_num_bits_485_comment},
  {"get_bit", &Dtool_BitArray_get_bit_486, METH_O, (const char *)Dtool_BitArray_get_bit_486_comment},
  {"getBit", &Dtool_BitArray_get_bit_486, METH_O, (const char *)Dtool_BitArray_get_bit_486_comment},
  {"set_bit", &Dtool_BitArray_set_bit_487, METH_O, (const char *)Dtool_BitArray_set_bit_487_comment},
  {"setBit", &Dtool_BitArray_set_bit_487, METH_O, (const char *)Dtool_BitArray_set_bit_487_comment},
  {"clear_bit", &Dtool_BitArray_clear_bit_488, METH_O, (const char *)Dtool_BitArray_clear_bit_488_comment},
  {"clearBit", &Dtool_BitArray_clear_bit_488, METH_O, (const char *)Dtool_BitArray_clear_bit_488_comment},
  {"set_bit_to", (PyCFunction) &Dtool_BitArray_set_bit_to_489, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_set_bit_to_489_comment},
  {"setBitTo", (PyCFunction) &Dtool_BitArray_set_bit_to_489, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_set_bit_to_489_comment},
  {"get_highest_bits", &Dtool_BitArray_get_highest_bits_490, METH_NOARGS, (const char *)Dtool_BitArray_get_highest_bits_490_comment},
  {"getHighestBits", &Dtool_BitArray_get_highest_bits_490, METH_NOARGS, (const char *)Dtool_BitArray_get_highest_bits_490_comment},
  {"is_zero", &Dtool_BitArray_is_zero_491, METH_NOARGS, (const char *)Dtool_BitArray_is_zero_491_comment},
  {"isZero", &Dtool_BitArray_is_zero_491, METH_NOARGS, (const char *)Dtool_BitArray_is_zero_491_comment},
  {"is_all_on", &Dtool_BitArray_is_all_on_492, METH_NOARGS, (const char *)Dtool_BitArray_is_all_on_492_comment},
  {"isAllOn", &Dtool_BitArray_is_all_on_492, METH_NOARGS, (const char *)Dtool_BitArray_is_all_on_492_comment},
  {"extract", (PyCFunction) &Dtool_BitArray_extract_493, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_extract_493_comment},
  {"store", (PyCFunction) &Dtool_BitArray_store_494, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_store_494_comment},
  {"has_any_of", (PyCFunction) &Dtool_BitArray_has_any_of_495, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_has_any_of_495_comment},
  {"hasAnyOf", (PyCFunction) &Dtool_BitArray_has_any_of_495, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_has_any_of_495_comment},
  {"has_all_of", (PyCFunction) &Dtool_BitArray_has_all_of_496, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_has_all_of_496_comment},
  {"hasAllOf", (PyCFunction) &Dtool_BitArray_has_all_of_496, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_has_all_of_496_comment},
  {"set_range", (PyCFunction) &Dtool_BitArray_set_range_497, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_set_range_497_comment},
  {"setRange", (PyCFunction) &Dtool_BitArray_set_range_497, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_set_range_497_comment},
  {"clear_range", (PyCFunction) &Dtool_BitArray_clear_range_498, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_clear_range_498_comment},
  {"clearRange", (PyCFunction) &Dtool_BitArray_clear_range_498, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_clear_range_498_comment},
  {"set_range_to", (PyCFunction) &Dtool_BitArray_set_range_to_499, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_set_range_to_499_comment},
  {"setRangeTo", (PyCFunction) &Dtool_BitArray_set_range_to_499, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_set_range_to_499_comment},
  {"get_num_on_bits", &Dtool_BitArray_get_num_on_bits_500, METH_NOARGS, (const char *)Dtool_BitArray_get_num_on_bits_500_comment},
  {"getNumOnBits", &Dtool_BitArray_get_num_on_bits_500, METH_NOARGS, (const char *)Dtool_BitArray_get_num_on_bits_500_comment},
  {"get_num_off_bits", &Dtool_BitArray_get_num_off_bits_501, METH_NOARGS, (const char *)Dtool_BitArray_get_num_off_bits_501_comment},
  {"getNumOffBits", &Dtool_BitArray_get_num_off_bits_501, METH_NOARGS, (const char *)Dtool_BitArray_get_num_off_bits_501_comment},
  {"get_lowest_on_bit", &Dtool_BitArray_get_lowest_on_bit_502, METH_NOARGS, (const char *)Dtool_BitArray_get_lowest_on_bit_502_comment},
  {"getLowestOnBit", &Dtool_BitArray_get_lowest_on_bit_502, METH_NOARGS, (const char *)Dtool_BitArray_get_lowest_on_bit_502_comment},
  {"get_lowest_off_bit", &Dtool_BitArray_get_lowest_off_bit_503, METH_NOARGS, (const char *)Dtool_BitArray_get_lowest_off_bit_503_comment},
  {"getLowestOffBit", &Dtool_BitArray_get_lowest_off_bit_503, METH_NOARGS, (const char *)Dtool_BitArray_get_lowest_off_bit_503_comment},
  {"get_highest_on_bit", &Dtool_BitArray_get_highest_on_bit_504, METH_NOARGS, (const char *)Dtool_BitArray_get_highest_on_bit_504_comment},
  {"getHighestOnBit", &Dtool_BitArray_get_highest_on_bit_504, METH_NOARGS, (const char *)Dtool_BitArray_get_highest_on_bit_504_comment},
  {"get_highest_off_bit", &Dtool_BitArray_get_highest_off_bit_505, METH_NOARGS, (const char *)Dtool_BitArray_get_highest_off_bit_505_comment},
  {"getHighestOffBit", &Dtool_BitArray_get_highest_off_bit_505, METH_NOARGS, (const char *)Dtool_BitArray_get_highest_off_bit_505_comment},
  {"get_next_higher_different_bit", &Dtool_BitArray_get_next_higher_different_bit_506, METH_O, (const char *)Dtool_BitArray_get_next_higher_different_bit_506_comment},
  {"getNextHigherDifferentBit", &Dtool_BitArray_get_next_higher_different_bit_506, METH_O, (const char *)Dtool_BitArray_get_next_higher_different_bit_506_comment},
  {"get_num_words", &Dtool_BitArray_get_num_words_507, METH_NOARGS, (const char *)Dtool_BitArray_get_num_words_507_comment},
  {"getNumWords", &Dtool_BitArray_get_num_words_507, METH_NOARGS, (const char *)Dtool_BitArray_get_num_words_507_comment},
  {"get_word", &Dtool_BitArray_get_word_508, METH_O, (const char *)Dtool_BitArray_get_word_508_comment},
  {"getWord", &Dtool_BitArray_get_word_508, METH_O, (const char *)Dtool_BitArray_get_word_508_comment},
  {"set_word", (PyCFunction) &Dtool_BitArray_set_word_509, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_set_word_509_comment},
  {"setWord", (PyCFunction) &Dtool_BitArray_set_word_509, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_set_word_509_comment},
  {"invert_in_place", &Dtool_BitArray_invert_in_place_510, METH_NOARGS, (const char *)Dtool_BitArray_invert_in_place_510_comment},
  {"invertInPlace", &Dtool_BitArray_invert_in_place_510, METH_NOARGS, (const char *)Dtool_BitArray_invert_in_place_510_comment},
  {"has_bits_in_common", &Dtool_BitArray_has_bits_in_common_511, METH_O, (const char *)Dtool_BitArray_has_bits_in_common_511_comment},
  {"hasBitsInCommon", &Dtool_BitArray_has_bits_in_common_511, METH_O, (const char *)Dtool_BitArray_has_bits_in_common_511_comment},
  {"clear", &Dtool_BitArray_clear_512, METH_NOARGS, (const char *)Dtool_BitArray_clear_512_comment},
  {"output", &Dtool_BitArray_output_513, METH_O, (const char *)Dtool_BitArray_output_513_comment},
  {"output_binary", (PyCFunction) &Dtool_BitArray_output_binary_514, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_output_binary_514_comment},
  {"outputBinary", (PyCFunction) &Dtool_BitArray_output_binary_514, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_output_binary_514_comment},
  {"output_hex", (PyCFunction) &Dtool_BitArray_output_hex_515, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_output_hex_515_comment},
  {"outputHex", (PyCFunction) &Dtool_BitArray_output_hex_515, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_output_hex_515_comment},
  {"write", (PyCFunction) &Dtool_BitArray_write_516, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BitArray_write_516_comment},
  {"compare_to", &Dtool_BitArray_compare_to_520, METH_O, (const char *)Dtool_BitArray_compare_to_520_comment},
  {"compareTo", &Dtool_BitArray_compare_to_520, METH_O, (const char *)Dtool_BitArray_compare_to_520_comment},
  {"get_class_type", &Dtool_BitArray_get_class_type_532, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_get_class_type_532_comment},
  {"getClassType", &Dtool_BitArray_get_class_type_532, METH_NOARGS | METH_STATIC, (const char *)Dtool_BitArray_get_class_type_532_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_and -> operator &
//////////////////
static PyObject *Dtool_BitArray_operator_521_nb_and(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitArray BitArray::operator &(BitArray const &other) const
  BitArray arg_local;
  BitArray const *arg_this = Dtool_Coerce_BitArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitArray.__and__", "BitArray");
  }
  BitArray *return_value = new BitArray(((*(const BitArray*)local_this).operator &)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_inplace_and -> operator &=
//////////////////
static PyObject *Dtool_BitArray_operator_527_nb_inplace_and(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-void BitArray::operator &=(BitArray const &other)
  BitArray arg_local;
  BitArray const *arg_this = Dtool_Coerce_BitArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitArray.__iand__", "BitArray");
    return nullptr;
  }
  ((*local_this).operator &=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_inplace_lshift -> operator <<=
//////////////////
static PyObject *Dtool_BitArray_operator_530_nb_inplace_lshift(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-void BitArray::operator <<=(int shift)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return nullptr;
    }
#endif
    ((*local_this).operator <<=)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_inplace_or -> operator |=
//////////////////
static PyObject *Dtool_BitArray_operator_528_nb_inplace_or(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-void BitArray::operator |=(BitArray const &other)
  BitArray arg_local;
  BitArray const *arg_this = Dtool_Coerce_BitArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitArray.__ior__", "BitArray");
    return nullptr;
  }
  ((*local_this).operator |=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_inplace_rshift -> operator >>=
//////////////////
static PyObject *Dtool_BitArray_operator_531_nb_inplace_rshift(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-void BitArray::operator >>=(int shift)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return nullptr;
    }
#endif
    ((*local_this).operator >>=)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_inplace_xor -> operator ^=
//////////////////
static PyObject *Dtool_BitArray_operator_529_nb_inplace_xor(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-void BitArray::operator ^=(BitArray const &other)
  BitArray arg_local;
  BitArray const *arg_this = Dtool_Coerce_BitArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitArray.__ixor__", "BitArray");
    return nullptr;
  }
  ((*local_this).operator ^=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_invert -> operator ~
//////////////////
static PyObject *Dtool_BitArray_operator_524_nb_invert(PyObject *self) {
  BitArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline BitArray BitArray::operator ~(void) const
  BitArray *return_value = new BitArray(((*(const BitArray*)local_this).operator ~)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__invert__(BitArray self)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_lshift -> operator <<
//////////////////
static PyObject *Dtool_BitArray_operator_525_nb_lshift(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitArray BitArray::operator <<(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitArray *return_value = new BitArray(((*(const BitArray*)local_this).operator <<)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_or -> operator |
//////////////////
static PyObject *Dtool_BitArray_operator_522_nb_or(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitArray BitArray::operator |(BitArray const &other) const
  BitArray arg_local;
  BitArray const *arg_this = Dtool_Coerce_BitArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitArray.__or__", "BitArray");
  }
  BitArray *return_value = new BitArray(((*(const BitArray*)local_this).operator |)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_rshift -> operator >>
//////////////////
static PyObject *Dtool_BitArray_operator_526_nb_rshift(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitArray BitArray::operator >>(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    BitArray *return_value = new BitArray(((*(const BitArray*)local_this).operator >>)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot nb_xor -> operator ^
//////////////////
static PyObject *Dtool_BitArray_operator_523_nb_xor(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_BitArray, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline BitArray BitArray::operator ^(BitArray const &other) const
  BitArray arg_local;
  BitArray const *arg_this = Dtool_Coerce_BitArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "BitArray.__xor__", "BitArray");
  }
  BitArray *return_value = new BitArray(((*(const BitArray*)local_this).operator ^)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_BitArray, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// BitArray slot tp_compare -> compare_to
//////////////////
static int Dtool_BitArray_compare_to_520_tp_compare(PyObject *self, PyObject *arg) {
  BitArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return -1;
  }

  // 1-int BitArray::compare_to(BitArray const &other) const
  BitArray arg_local;
  BitArray const *arg_this = Dtool_Coerce_BitArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "BitArray.compare_to", "BitArray");
    return -1;
  }
  int return_value = ((*(const BitArray*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(BitArray self, const BitArray other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     BitArray
//////////////////
static PyObject *Dtool_Repr_BitArray(PyObject *self) {
  BitArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BitArray
//////////////////
static PyObject *Dtool_Str_BitArray(PyObject *self) {
  BitArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     BitArray
//////////////////
static PyObject *Dtool_RichCompare_BitArray(PyObject *self, PyObject *arg, int op) {
  BitArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BitArray, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool BitArray::operator ==(BitArray const &other) const
      BitArray arg_local;
      BitArray const *arg_this = Dtool_Coerce_BitArray(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const BitArray*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool BitArray::operator !=(BitArray const &other) const
      BitArray arg_local;
      BitArray const *arg_this = Dtool_Coerce_BitArray(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const BitArray*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool BitArray::operator <(BitArray const &other) const
      BitArray arg_local;
      BitArray const *arg_this = Dtool_Coerce_BitArray(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const BitArray*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_BitArray_compare_to_520_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_BitArray = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_BitArray_operator_524_nb_invert,
  &Dtool_BitArray_operator_525_nb_lshift,
  &Dtool_BitArray_operator_526_nb_rshift,
  &Dtool_BitArray_operator_521_nb_and,
  &Dtool_BitArray_operator_523_nb_xor,
  &Dtool_BitArray_operator_522_nb_or,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  &Dtool_BitArray_operator_530_nb_inplace_lshift,
  &Dtool_BitArray_operator_531_nb_inplace_rshift,
  &Dtool_BitArray_operator_527_nb_inplace_and,
  &Dtool_BitArray_operator_529_nb_inplace_xor,
  &Dtool_BitArray_operator_528_nb_inplace_or,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_BitArray = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.BitArray",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BitArray,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_BitArray_compare_to_520_tp_compare,
#endif
    &Dtool_Repr_BitArray,
    &Dtool_NumberMethods_BitArray,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_BitArray,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A dynamic array with an unlimited number of bits.\n"
    " *\n"
    " * This is similar to a BitMask, except it appears to contain an infinite\n"
    " * number of bits.  You can use it very much as you would use a BitMask.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_BitArray,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BitArray,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BitArray,
    PyType_GenericAlloc,
    Dtool_new_BitArray,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BitArray,
  Dtool_UpcastInterface_BitArray,
  Dtool_DowncastInterface_BitArray,
  nullptr,
  (CoerceFunction)Dtool_Coerce_BitArray,
};

static void Dtool_PyModuleClassInit_BitArray(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_BitArray._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BitArray._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum BitArray::;
    PyDict_SetItemString(dict, "num_bits_per_word", Dtool_WrapValue(BitArray::num_bits_per_word));
    if (PyType_Ready((PyTypeObject *)&Dtool_BitArray) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BitArray)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BitArray);
  }
}

/**
 * Python method tables for ButtonHandle (ButtonHandle)
 */
static PyMethodDef Dtool_Methods_ButtonHandle[] = {
  {"compare_to", &Dtool_ButtonHandle_compare_to_542, METH_O, (const char *)Dtool_ButtonHandle_compare_to_542_comment},
  {"compareTo", &Dtool_ButtonHandle_compare_to_542, METH_O, (const char *)Dtool_ButtonHandle_compare_to_542_comment},
  {"get_hash", &Dtool_ButtonHandle_get_hash_543, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_hash_543_comment},
  {"getHash", &Dtool_ButtonHandle_get_hash_543, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_hash_543_comment},
  {"get_name", &Dtool_ButtonHandle_get_name_544, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_name_544_comment},
  {"getName", &Dtool_ButtonHandle_get_name_544, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_name_544_comment},
  {"has_ascii_equivalent", &Dtool_ButtonHandle_has_ascii_equivalent_545, METH_NOARGS, (const char *)Dtool_ButtonHandle_has_ascii_equivalent_545_comment},
  {"hasAsciiEquivalent", &Dtool_ButtonHandle_has_ascii_equivalent_545, METH_NOARGS, (const char *)Dtool_ButtonHandle_has_ascii_equivalent_545_comment},
  {"get_ascii_equivalent", &Dtool_ButtonHandle_get_ascii_equivalent_546, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_ascii_equivalent_546_comment},
  {"getAsciiEquivalent", &Dtool_ButtonHandle_get_ascii_equivalent_546, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_ascii_equivalent_546_comment},
  {"get_alias", &Dtool_ButtonHandle_get_alias_547, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_alias_547_comment},
  {"getAlias", &Dtool_ButtonHandle_get_alias_547, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_alias_547_comment},
  {"matches", &Dtool_ButtonHandle_matches_548, METH_O, (const char *)Dtool_ButtonHandle_matches_548_comment},
  {"get_index", &Dtool_ButtonHandle_get_index_549, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_index_549_comment},
  {"getIndex", &Dtool_ButtonHandle_get_index_549, METH_NOARGS, (const char *)Dtool_ButtonHandle_get_index_549_comment},
  {"output", &Dtool_ButtonHandle_output_550, METH_O, (const char *)Dtool_ButtonHandle_output_550_comment},
  {"none", &Dtool_ButtonHandle_none_551, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonHandle_none_551_comment},
  {"get_class_type", &Dtool_ButtonHandle_get_class_type_560, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonHandle_get_class_type_560_comment},
  {"getClassType", &Dtool_ButtonHandle_get_class_type_560, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonHandle_get_class_type_560_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ButtonHandle slot nb_bool -> operator typecast bool
//////////////////
static int Dtool_ButtonHandle_operator_typecast_bool_552_nb_bool(PyObject *self) {
  ButtonHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return -1;
  }

  return (int) (bool)*local_this;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ButtonHandle slot tp_compare -> compare_to
//////////////////
static int Dtool_ButtonHandle_compare_to_542_tp_compare(PyObject *self, PyObject *arg) {
  ButtonHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int ButtonHandle::compare_to(ButtonHandle const &other) const
  ButtonHandle arg_local;
  ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "ButtonHandle.compare_to", "ButtonHandle");
    return -1;
  }
  int return_value = ((*(const ButtonHandle*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(ButtonHandle self, const ButtonHandle other)\n");
  }
  return -1;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ButtonHandle slot tp_hash -> get_hash
//////////////////
static Py_hash_t Dtool_ButtonHandle_get_hash_543_tp_hash(PyObject *self) {
  ButtonHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return -1;
  }

  return (Py_hash_t) ((*local_this).get_hash)();
}

//////////////////
//  A __repr__ function
//     ButtonHandle
//////////////////
static PyObject *Dtool_Repr_ButtonHandle(PyObject *self) {
  ButtonHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     ButtonHandle
//////////////////
static PyObject *Dtool_RichCompare_ButtonHandle(PyObject *self, PyObject *arg, int op) {
  ButtonHandle *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonHandle, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool ButtonHandle::operator ==(ButtonHandle const &other) const
      ButtonHandle arg_local;
      ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const ButtonHandle*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool ButtonHandle::operator !=(ButtonHandle const &other) const
      ButtonHandle arg_local;
      ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const ButtonHandle*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool ButtonHandle::operator <(ButtonHandle const &other) const
      ButtonHandle arg_local;
      ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const ButtonHandle*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LE:
    {
      // 1-inline bool ButtonHandle::operator <=(ButtonHandle const &other) const
      ButtonHandle arg_local;
      ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const ButtonHandle*)local_this).operator <=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_GT:
    {
      // 1-inline bool ButtonHandle::operator >(ButtonHandle const &other) const
      ButtonHandle arg_local;
      ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const ButtonHandle*)local_this).operator >)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_GE:
    {
      // 1-inline bool ButtonHandle::operator >=(ButtonHandle const &other) const
      ButtonHandle arg_local;
      ButtonHandle const *arg_this = Dtool_Coerce_ButtonHandle(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const ButtonHandle*)local_this).operator >=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_ButtonHandle_compare_to_542_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_ButtonHandle[] = {
  {(char *)"index", &Dtool_ButtonHandle_index_Getter, nullptr, nullptr, nullptr},
  {(char *)"name", &Dtool_ButtonHandle_name_Getter, nullptr, nullptr, nullptr},
  {(char *)"ascii_equivalent", &Dtool_ButtonHandle_ascii_equivalent_Getter, nullptr, nullptr, nullptr},
  {(char *)"alias", &Dtool_ButtonHandle_alias_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ButtonHandle = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_ButtonHandle_operator_typecast_bool_552_nb_bool,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ButtonHandle = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ButtonHandle",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ButtonHandle,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_ButtonHandle_compare_to_542_tp_compare,
#endif
    &Dtool_Repr_ButtonHandle,
    &Dtool_NumberMethods_ButtonHandle,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &Dtool_ButtonHandle_get_hash_543_tp_hash,
    nullptr,
    &Dtool_Repr_ButtonHandle,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A ButtonHandle represents a single button from any device, including\n"
    " * keyboard buttons and mouse buttons (but see KeyboardButton and\n"
    " * MouseButton).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_ButtonHandle,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ButtonHandle,
    nullptr, // tp_members
    Dtool_Properties_ButtonHandle,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ButtonHandle,
    PyType_GenericAlloc,
    Dtool_new_ButtonHandle,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ButtonHandle,
  Dtool_UpcastInterface_ButtonHandle,
  Dtool_DowncastInterface_ButtonHandle,
  nullptr,
  (CoerceFunction)Dtool_Coerce_ButtonHandle,
};

static void Dtool_PyModuleClassInit_ButtonHandle(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ButtonHandle._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ButtonHandle._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ButtonHandle) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ButtonHandle)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ButtonHandle);
  }
}

/**
 * Python method tables for ButtonRegistry (ButtonRegistry)
 */
static PyMethodDef Dtool_Methods_ButtonRegistry[] = {
  {"get_button", &Dtool_ButtonRegistry_get_button_563, METH_O, (const char *)Dtool_ButtonRegistry_get_button_563_comment},
  {"getButton", &Dtool_ButtonRegistry_get_button_563, METH_O, (const char *)Dtool_ButtonRegistry_get_button_563_comment},
  {"find_button", &Dtool_ButtonRegistry_find_button_564, METH_O, (const char *)Dtool_ButtonRegistry_find_button_564_comment},
  {"findButton", &Dtool_ButtonRegistry_find_button_564, METH_O, (const char *)Dtool_ButtonRegistry_find_button_564_comment},
  {"find_ascii_button", &Dtool_ButtonRegistry_find_ascii_button_565, METH_O, (const char *)Dtool_ButtonRegistry_find_ascii_button_565_comment},
  {"findAsciiButton", &Dtool_ButtonRegistry_find_ascii_button_565, METH_O, (const char *)Dtool_ButtonRegistry_find_ascii_button_565_comment},
  {"write", &Dtool_ButtonRegistry_write_566, METH_O, (const char *)Dtool_ButtonRegistry_write_566_comment},
  {"ptr", &Dtool_ButtonRegistry_ptr_567, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonRegistry_ptr_567_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __str__ function
//     ButtonRegistry
//////////////////
static PyObject *Dtool_Str_ButtonRegistry(PyObject *self) {
  ButtonRegistry *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonRegistry, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ButtonRegistry = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ButtonRegistry = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ButtonRegistry",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ButtonRegistry,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ButtonRegistry,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_ButtonRegistry,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * The ButtonRegistry class maintains all the assigned ButtonHandles in a\n"
    " * given system.  There should be only one ButtonRegistry class during the\n"
    " * lifetime of the application.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ButtonRegistry,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ButtonRegistry,
    PyType_GenericAlloc,
    Dtool_new_ButtonRegistry,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ButtonRegistry,
  Dtool_UpcastInterface_ButtonRegistry,
  Dtool_DowncastInterface_ButtonRegistry,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ButtonRegistry(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ButtonRegistry._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ButtonRegistry._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ButtonRegistry) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ButtonRegistry)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ButtonRegistry);
  }
}

/**
 * Python method tables for ButtonMap (ButtonMap)
 */
static PyMethodDef Dtool_Methods_ButtonMap[] = {
  {"get_num_buttons", &Dtool_ButtonMap_get_num_buttons_572, METH_NOARGS, (const char *)Dtool_ButtonMap_get_num_buttons_572_comment},
  {"getNumButtons", &Dtool_ButtonMap_get_num_buttons_572, METH_NOARGS, (const char *)Dtool_ButtonMap_get_num_buttons_572_comment},
  {"get_raw_button", &Dtool_ButtonMap_get_raw_button_573, METH_O, (const char *)Dtool_ButtonMap_get_raw_button_573_comment},
  {"getRawButton", &Dtool_ButtonMap_get_raw_button_573, METH_O, (const char *)Dtool_ButtonMap_get_raw_button_573_comment},
  {"get_mapped_button", &Dtool_ButtonMap_get_mapped_button_574, METH_O, (const char *)Dtool_ButtonMap_get_mapped_button_574_comment},
  {"getMappedButton", &Dtool_ButtonMap_get_mapped_button_574, METH_O, (const char *)Dtool_ButtonMap_get_mapped_button_574_comment},
  {"get_mapped_button_label", &Dtool_ButtonMap_get_mapped_button_label_575, METH_O, (const char *)Dtool_ButtonMap_get_mapped_button_label_575_comment},
  {"getMappedButtonLabel", &Dtool_ButtonMap_get_mapped_button_label_575, METH_O, (const char *)Dtool_ButtonMap_get_mapped_button_label_575_comment},
  {"output", &Dtool_ButtonMap_output_576, METH_O, (const char *)Dtool_ButtonMap_output_576_comment},
  {"write", (PyCFunction) &Dtool_ButtonMap_write_577, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ButtonMap_write_577_comment},
  {"get_class_type", &Dtool_ButtonMap_get_class_type_578, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonMap_get_class_type_578_comment},
  {"getClassType", &Dtool_ButtonMap_get_class_type_578, METH_NOARGS | METH_STATIC, (const char *)Dtool_ButtonMap_get_class_type_578_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     ButtonMap
//////////////////
static PyObject *Dtool_Repr_ButtonMap(PyObject *self) {
  ButtonMap *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonMap, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ButtonMap
//////////////////
static PyObject *Dtool_Str_ButtonMap(PyObject *self) {
  ButtonMap *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ButtonMap, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ButtonMap = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ButtonMap = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ButtonMap = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ButtonMap = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ButtonMap = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ButtonMap = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ButtonMap",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ButtonMap,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ButtonMap,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_ButtonMap,
    &Dtool_NumberMethods_ButtonMap,
    &Dtool_SequenceMethods_ButtonMap,
    &Dtool_MappingMethods_ButtonMap,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_ButtonMap,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ButtonMap,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class represents a map containing all of the buttons of a (keyboard)\n"
    " * device, though it can also be used as a generic mapping between\n"
    " * ButtonHandles.  It maps an underlying 'raw' button to a 'virtual' button,\n"
    " * which may optionally be associated with an appropriate platform-specific\n"
    " * name for the button.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ButtonMap,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ButtonMap,
    PyType_GenericAlloc,
    Dtool_new_ButtonMap,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ButtonMap,
  Dtool_UpcastInterface_ButtonMap,
  Dtool_DowncastInterface_ButtonMap,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ButtonMap(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_ButtonMap._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_ButtonMap._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ButtonMap._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ButtonMap) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ButtonMap)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ButtonMap);
  }
}

/**
 * Python method tables for CallbackObject (CallbackObject)
 */
static PyMethodDef Dtool_Methods_CallbackObject[] = {
  {"output", &Dtool_CallbackObject_output_582, METH_O, (const char *)Dtool_CallbackObject_output_582_comment},
  {"make", &Dtool_CallbackObject_make_583, METH_O | METH_STATIC, (const char *)Dtool_CallbackObject_make_583_comment},
  {"get_class_type", &Dtool_CallbackObject_get_class_type_584, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackObject_get_class_type_584_comment},
  {"getClassType", &Dtool_CallbackObject_get_class_type_584, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackObject_get_class_type_584_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     CallbackObject
//////////////////
static PyObject *Dtool_Repr_CallbackObject(PyObject *self) {
  CallbackObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CallbackObject, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_CallbackObject = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CallbackObject = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CallbackObject = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CallbackObject = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CallbackObject = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CallbackObject = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CallbackObject",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CallbackObject,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CallbackObject,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_CallbackObject,
    &Dtool_NumberMethods_CallbackObject,
    &Dtool_SequenceMethods_CallbackObject,
    &Dtool_MappingMethods_CallbackObject,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_CallbackObject,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CallbackObject,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a generic object that can be assigned to a callback at various\n"
    " * points in the rendering process.  This is actually a base class for a\n"
    " * handful of specialized callback object types.  You can also subclass it\n"
    " * yourself to make your own callback handler.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CallbackObject,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CallbackObject,
    PyType_GenericAlloc,
    Dtool_new_CallbackObject,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CallbackObject,
  Dtool_UpcastInterface_CallbackObject,
  Dtool_DowncastInterface_CallbackObject,
  (CoerceFunction)Dtool_ConstCoerce_CallbackObject,
  (CoerceFunction)Dtool_Coerce_CallbackObject,
};

static void Dtool_PyModuleClassInit_CallbackObject(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_CallbackObject._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_CallbackObject._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CallbackObject._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CallbackObject) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CallbackObject)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CallbackObject);
  }
}

/**
 * Python method tables for CachedTypedWritableReferenceCount (CachedTypedWritableReferenceCount)
 */
static PyMethodDef Dtool_Methods_CachedTypedWritableReferenceCount[] = {
  {"get_cache_ref_count", &Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_588, METH_NOARGS, (const char *)Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_588_comment},
  {"getCacheRefCount", &Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_588, METH_NOARGS, (const char *)Dtool_CachedTypedWritableReferenceCount_get_cache_ref_count_588_comment},
  {"cache_ref", &Dtool_CachedTypedWritableReferenceCount_cache_ref_589, METH_NOARGS, (const char *)Dtool_CachedTypedWritableReferenceCount_cache_ref_589_comment},
  {"cacheRef", &Dtool_CachedTypedWritableReferenceCount_cache_ref_589, METH_NOARGS, (const char *)Dtool_CachedTypedWritableReferenceCount_cache_ref_589_comment},
  {"cache_unref", &Dtool_CachedTypedWritableReferenceCount_cache_unref_590, METH_NOARGS, (const char *)Dtool_CachedTypedWritableReferenceCount_cache_unref_590_comment},
  {"cacheUnref", &Dtool_CachedTypedWritableReferenceCount_cache_unref_590, METH_NOARGS, (const char *)Dtool_CachedTypedWritableReferenceCount_cache_unref_590_comment},
  {"test_ref_count_integrity", &Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_591, METH_NOARGS, (const char *)Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_591_comment},
  {"testRefCountIntegrity", &Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_591, METH_NOARGS, (const char *)Dtool_CachedTypedWritableReferenceCount_test_ref_count_integrity_591_comment},
  {"get_class_type", &Dtool_CachedTypedWritableReferenceCount_get_class_type_593, METH_NOARGS | METH_STATIC, (const char *)Dtool_CachedTypedWritableReferenceCount_get_class_type_593_comment},
  {"getClassType", &Dtool_CachedTypedWritableReferenceCount_get_class_type_593, METH_NOARGS | METH_STATIC, (const char *)Dtool_CachedTypedWritableReferenceCount_get_class_type_593_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_CachedTypedWritableReferenceCount[] = {
  {(char *)"cache_ref_count", &Dtool_CachedTypedWritableReferenceCount_cache_ref_count_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_CachedTypedWritableReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CachedTypedWritableReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CachedTypedWritableReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CachedTypedWritableReferenceCount = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CachedTypedWritableReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CachedTypedWritableReferenceCount = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CachedTypedWritableReferenceCount",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CachedTypedWritableReferenceCount,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CachedTypedWritableReferenceCount,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CachedTypedWritableReferenceCount,
    &Dtool_SequenceMethods_CachedTypedWritableReferenceCount,
    &Dtool_MappingMethods_CachedTypedWritableReferenceCount,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CachedTypedWritableReferenceCount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a special extension to ReferenceCount that includes dual reference\n"
    " * counts: the standard reference count number, which includes all references\n"
    " * to the object, and a separate number (the cache reference count) that\n"
    " * counts the number of references to the object just within its cache alone.\n"
    " * When get_ref_count() == get_cache_ref_count(), the object is not referenced\n"
    " * outside the cache.\n"
    " *\n"
    " * The cache refs must be explicitly maintained; there is no PointerTo<> class\n"
    " * to maintain the cache reference counts automatically.  The cache reference\n"
    " * count is automatically included in the overall reference count: calling\n"
    " * cache_ref() and cache_unref() automatically calls ref() and unref().\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CachedTypedWritableReferenceCount,
    nullptr, // tp_members
    Dtool_Properties_CachedTypedWritableReferenceCount,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CachedTypedWritableReferenceCount,
    PyType_GenericAlloc,
    Dtool_new_CachedTypedWritableReferenceCount,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CachedTypedWritableReferenceCount,
  Dtool_UpcastInterface_CachedTypedWritableReferenceCount,
  Dtool_DowncastInterface_CachedTypedWritableReferenceCount,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CachedTypedWritableReferenceCount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedWritableReferenceCount(nullptr);
    Dtool_CachedTypedWritableReferenceCount._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TypedWritableReferenceCount);
    Dtool_CachedTypedWritableReferenceCount._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CachedTypedWritableReferenceCount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CachedTypedWritableReferenceCount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CachedTypedWritableReferenceCount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CachedTypedWritableReferenceCount);
  }
}

/**
 * Python method tables for CallbackData (CallbackData)
 */
static PyMethodDef Dtool_Methods_CallbackData[] = {
  {"output", &Dtool_CallbackData_output_595, METH_O, (const char *)Dtool_CallbackData_output_595_comment},
  {"upcall", &Dtool_CallbackData_upcall_596, METH_NOARGS, (const char *)Dtool_CallbackData_upcall_596_comment},
  {"get_class_type", &Dtool_CallbackData_get_class_type_597, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackData_get_class_type_597_comment},
  {"getClassType", &Dtool_CallbackData_get_class_type_597, METH_NOARGS | METH_STATIC, (const char *)Dtool_CallbackData_get_class_type_597_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     CallbackData
//////////////////
static PyObject *Dtool_Repr_CallbackData(PyObject *self) {
  CallbackData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_CallbackData, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_CallbackData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CallbackData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CallbackData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CallbackData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CallbackData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CallbackData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CallbackData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CallbackData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CallbackData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_CallbackData,
    &Dtool_NumberMethods_CallbackData,
    &Dtool_SequenceMethods_CallbackData,
    &Dtool_MappingMethods_CallbackData,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_CallbackData,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CallbackData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a generic data block that is passed along to a CallbackObject when\n"
    " * a callback is made.  It contains data specific to the particular callback\n"
    " * type in question.\n"
    " *\n"
    " * This is actually an abstract base class and contains no data.\n"
    " * Specializations of this class will contain the actual data relevant to each\n"
    " * callback type.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CallbackData,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CallbackData,
    PyType_GenericAlloc,
    Dtool_new_CallbackData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CallbackData,
  Dtool_UpcastInterface_CallbackData,
  Dtool_DowncastInterface_CallbackData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CallbackData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedObject != nullptr);
    assert(Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedObject->_Dtool_ModuleClassInit(nullptr);
    Dtool_CallbackData._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedObject);
    Dtool_CallbackData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CallbackData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CallbackData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CallbackData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CallbackData);
  }
}

/**
 * Python method tables for PythonCallbackObject (PythonCallbackObject)
 */
static PyMethodDef Dtool_Methods_PythonCallbackObject[] = {
  {"set_function", &Dtool_PythonCallbackObject_set_function_604, METH_O, (const char *)Dtool_PythonCallbackObject_set_function_604_comment},
  {"setFunction", &Dtool_PythonCallbackObject_set_function_604, METH_O, (const char *)Dtool_PythonCallbackObject_set_function_604_comment},
  {"get_function", &Dtool_PythonCallbackObject_get_function_605, METH_NOARGS, (const char *)Dtool_PythonCallbackObject_get_function_605_comment},
  {"getFunction", &Dtool_PythonCallbackObject_get_function_605, METH_NOARGS, (const char *)Dtool_PythonCallbackObject_get_function_605_comment},
  {"get_class_type", &Dtool_PythonCallbackObject_get_class_type_607, METH_NOARGS | METH_STATIC, (const char *)Dtool_PythonCallbackObject_get_class_type_607_comment},
  {"getClassType", &Dtool_PythonCallbackObject_get_class_type_607, METH_NOARGS | METH_STATIC, (const char *)Dtool_PythonCallbackObject_get_class_type_607_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_PythonCallbackObject[] = {
  {(char *)"function", &Dtool_PythonCallbackObject_function_Getter, &Dtool_PythonCallbackObject_function_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PythonCallbackObject = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PythonCallbackObject = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PythonCallbackObject = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PythonCallbackObject = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PythonCallbackObject = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PythonCallbackObject = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PythonCallbackObject",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PythonCallbackObject,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PythonCallbackObject,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PythonCallbackObject,
    &Dtool_SequenceMethods_PythonCallbackObject,
    &Dtool_MappingMethods_PythonCallbackObject,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PythonCallbackObject,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a specialization on CallbackObject to allow a callback to directly\n"
    " * call an arbitarary Python function.  Powerful!  But use with caution.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PythonCallbackObject,
    nullptr, // tp_members
    Dtool_Properties_PythonCallbackObject,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PythonCallbackObject,
    PyType_GenericAlloc,
    Dtool_new_PythonCallbackObject,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PythonCallbackObject,
  Dtool_UpcastInterface_PythonCallbackObject,
  Dtool_DowncastInterface_PythonCallbackObject,
  (CoerceFunction)Dtool_ConstCoerce_PythonCallbackObject,
  (CoerceFunction)Dtool_Coerce_PythonCallbackObject,
};

static void Dtool_PyModuleClassInit_PythonCallbackObject(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CallbackObject(nullptr);
    Dtool_PythonCallbackObject._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CallbackObject);
    Dtool_PythonCallbackObject._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PythonCallbackObject._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PythonCallbackObject) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PythonCallbackObject)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PythonCallbackObject);
  }
}

/**
 * Python method tables for TimeVal (TimeVal)
 */
static PyMethodDef Dtool_Methods_TimeVal[] = {
  {"get_sec", &Dtool_TimeVal_get_sec_610, METH_NOARGS, (const char *)Dtool_TimeVal_get_sec_610_comment},
  {"getSec", &Dtool_TimeVal_get_sec_610, METH_NOARGS, (const char *)Dtool_TimeVal_get_sec_610_comment},
  {"get_usec", &Dtool_TimeVal_get_usec_611, METH_NOARGS, (const char *)Dtool_TimeVal_get_usec_611_comment},
  {"getUsec", &Dtool_TimeVal_get_usec_611, METH_NOARGS, (const char *)Dtool_TimeVal_get_usec_611_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_TimeVal = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_TimeVal = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.TimeVal",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_TimeVal,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_TimeVal,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_TimeVal,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_TimeVal,
    PyType_GenericAlloc,
    Dtool_new_TimeVal,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_TimeVal,
  Dtool_UpcastInterface_TimeVal,
  Dtool_DowncastInterface_TimeVal,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_TimeVal(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_TimeVal._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_TimeVal._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_TimeVal) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(TimeVal)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_TimeVal);
  }
}

/**
 * Python method tables for ClockObject (ClockObject)
 */
static PyMethodDef Dtool_Methods_ClockObject[] = {
  {"set_mode", &Dtool_ClockObject_set_mode_622, METH_O, (const char *)Dtool_ClockObject_set_mode_622_comment},
  {"setMode", &Dtool_ClockObject_set_mode_622, METH_O, (const char *)Dtool_ClockObject_set_mode_622_comment},
  {"get_mode", &Dtool_ClockObject_get_mode_623, METH_NOARGS, (const char *)Dtool_ClockObject_get_mode_623_comment},
  {"getMode", &Dtool_ClockObject_get_mode_623, METH_NOARGS, (const char *)Dtool_ClockObject_get_mode_623_comment},
  {"get_frame_time", (PyCFunction) &Dtool_ClockObject_get_frame_time_625, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_frame_time_625_comment},
  {"getFrameTime", (PyCFunction) &Dtool_ClockObject_get_frame_time_625, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_frame_time_625_comment},
  {"get_real_time", &Dtool_ClockObject_get_real_time_626, METH_NOARGS, (const char *)Dtool_ClockObject_get_real_time_626_comment},
  {"getRealTime", &Dtool_ClockObject_get_real_time_626, METH_NOARGS, (const char *)Dtool_ClockObject_get_real_time_626_comment},
  {"get_long_time", &Dtool_ClockObject_get_long_time_627, METH_NOARGS, (const char *)Dtool_ClockObject_get_long_time_627_comment},
  {"getLongTime", &Dtool_ClockObject_get_long_time_627, METH_NOARGS, (const char *)Dtool_ClockObject_get_long_time_627_comment},
  {"reset", &Dtool_ClockObject_reset_628, METH_NOARGS, (const char *)Dtool_ClockObject_reset_628_comment},
  {"set_real_time", &Dtool_ClockObject_set_real_time_629, METH_O, (const char *)Dtool_ClockObject_set_real_time_629_comment},
  {"setRealTime", &Dtool_ClockObject_set_real_time_629, METH_O, (const char *)Dtool_ClockObject_set_real_time_629_comment},
  {"set_frame_time", (PyCFunction) &Dtool_ClockObject_set_frame_time_630, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_set_frame_time_630_comment},
  {"setFrameTime", (PyCFunction) &Dtool_ClockObject_set_frame_time_630, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_set_frame_time_630_comment},
  {"set_frame_count", (PyCFunction) &Dtool_ClockObject_set_frame_count_631, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_set_frame_count_631_comment},
  {"setFrameCount", (PyCFunction) &Dtool_ClockObject_set_frame_count_631, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_set_frame_count_631_comment},
  {"get_frame_count", (PyCFunction) &Dtool_ClockObject_get_frame_count_632, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_frame_count_632_comment},
  {"getFrameCount", (PyCFunction) &Dtool_ClockObject_get_frame_count_632, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_frame_count_632_comment},
  {"get_net_frame_rate", (PyCFunction) &Dtool_ClockObject_get_net_frame_rate_633, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_net_frame_rate_633_comment},
  {"getNetFrameRate", (PyCFunction) &Dtool_ClockObject_get_net_frame_rate_633, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_net_frame_rate_633_comment},
  {"get_dt", (PyCFunction) &Dtool_ClockObject_get_dt_638, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_dt_638_comment},
  {"getDt", (PyCFunction) &Dtool_ClockObject_get_dt_638, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_dt_638_comment},
  {"set_dt", &Dtool_ClockObject_set_dt_639, METH_O, (const char *)Dtool_ClockObject_set_dt_639_comment},
  {"setDt", &Dtool_ClockObject_set_dt_639, METH_O, (const char *)Dtool_ClockObject_set_dt_639_comment},
  {"set_frame_rate", &Dtool_ClockObject_set_frame_rate_640, METH_O, (const char *)Dtool_ClockObject_set_frame_rate_640_comment},
  {"setFrameRate", &Dtool_ClockObject_set_frame_rate_640, METH_O, (const char *)Dtool_ClockObject_set_frame_rate_640_comment},
  {"get_max_dt", &Dtool_ClockObject_get_max_dt_642, METH_NOARGS, (const char *)Dtool_ClockObject_get_max_dt_642_comment},
  {"getMaxDt", &Dtool_ClockObject_get_max_dt_642, METH_NOARGS, (const char *)Dtool_ClockObject_get_max_dt_642_comment},
  {"set_max_dt", &Dtool_ClockObject_set_max_dt_643, METH_O, (const char *)Dtool_ClockObject_set_max_dt_643_comment},
  {"setMaxDt", &Dtool_ClockObject_set_max_dt_643, METH_O, (const char *)Dtool_ClockObject_set_max_dt_643_comment},
  {"get_degrade_factor", &Dtool_ClockObject_get_degrade_factor_645, METH_NOARGS, (const char *)Dtool_ClockObject_get_degrade_factor_645_comment},
  {"getDegradeFactor", &Dtool_ClockObject_get_degrade_factor_645, METH_NOARGS, (const char *)Dtool_ClockObject_get_degrade_factor_645_comment},
  {"set_degrade_factor", &Dtool_ClockObject_set_degrade_factor_646, METH_O, (const char *)Dtool_ClockObject_set_degrade_factor_646_comment},
  {"setDegradeFactor", &Dtool_ClockObject_set_degrade_factor_646, METH_O, (const char *)Dtool_ClockObject_set_degrade_factor_646_comment},
  {"set_average_frame_rate_interval", &Dtool_ClockObject_set_average_frame_rate_interval_648, METH_O, (const char *)Dtool_ClockObject_set_average_frame_rate_interval_648_comment},
  {"setAverageFrameRateInterval", &Dtool_ClockObject_set_average_frame_rate_interval_648, METH_O, (const char *)Dtool_ClockObject_set_average_frame_rate_interval_648_comment},
  {"get_average_frame_rate_interval", &Dtool_ClockObject_get_average_frame_rate_interval_649, METH_NOARGS, (const char *)Dtool_ClockObject_get_average_frame_rate_interval_649_comment},
  {"getAverageFrameRateInterval", &Dtool_ClockObject_get_average_frame_rate_interval_649, METH_NOARGS, (const char *)Dtool_ClockObject_get_average_frame_rate_interval_649_comment},
  {"get_average_frame_rate", (PyCFunction) &Dtool_ClockObject_get_average_frame_rate_651, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_average_frame_rate_651_comment},
  {"getAverageFrameRate", (PyCFunction) &Dtool_ClockObject_get_average_frame_rate_651, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_average_frame_rate_651_comment},
  {"get_max_frame_duration", (PyCFunction) &Dtool_ClockObject_get_max_frame_duration_652, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_max_frame_duration_652_comment},
  {"getMaxFrameDuration", (PyCFunction) &Dtool_ClockObject_get_max_frame_duration_652, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_get_max_frame_duration_652_comment},
  {"calc_frame_rate_deviation", (PyCFunction) &Dtool_ClockObject_calc_frame_rate_deviation_653, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_calc_frame_rate_deviation_653_comment},
  {"calcFrameRateDeviation", (PyCFunction) &Dtool_ClockObject_calc_frame_rate_deviation_653, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_calc_frame_rate_deviation_653_comment},
  {"tick", (PyCFunction) &Dtool_ClockObject_tick_656, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_tick_656_comment},
  {"sync_frame_time", (PyCFunction) &Dtool_ClockObject_sync_frame_time_657, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_sync_frame_time_657_comment},
  {"syncFrameTime", (PyCFunction) &Dtool_ClockObject_sync_frame_time_657, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ClockObject_sync_frame_time_657_comment},
  {"check_errors", &Dtool_ClockObject_check_errors_658, METH_O, (const char *)Dtool_ClockObject_check_errors_658_comment},
  {"checkErrors", &Dtool_ClockObject_check_errors_658, METH_O, (const char *)Dtool_ClockObject_check_errors_658_comment},
  {"get_global_clock", &Dtool_ClockObject_get_global_clock_659, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClockObject_get_global_clock_659_comment},
  {"getGlobalClock", &Dtool_ClockObject_get_global_clock_659, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClockObject_get_global_clock_659_comment},
  {"get_class_type", &Dtool_ClockObject_get_class_type_660, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClockObject_get_class_type_660_comment},
  {"getClassType", &Dtool_ClockObject_get_class_type_660, METH_NOARGS | METH_STATIC, (const char *)Dtool_ClockObject_get_class_type_660_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ClockObject[] = {
  {(char *)"mode", &Dtool_ClockObject_mode_Getter, &Dtool_ClockObject_mode_Setter, nullptr, nullptr},
  {(char *)"frame_time", &Dtool_ClockObject_frame_time_Getter, &Dtool_ClockObject_frame_time_Setter, nullptr, nullptr},
  {(char *)"real_time", &Dtool_ClockObject_real_time_Getter, &Dtool_ClockObject_real_time_Setter, nullptr, nullptr},
  {(char *)"long_time", &Dtool_ClockObject_long_time_Getter, nullptr, nullptr, nullptr},
  {(char *)"frame_count", &Dtool_ClockObject_frame_count_Getter, &Dtool_ClockObject_frame_count_Setter, nullptr, nullptr},
  {(char *)"dt", &Dtool_ClockObject_dt_Getter, &Dtool_ClockObject_dt_Setter, nullptr, nullptr},
  {(char *)"max_dt", &Dtool_ClockObject_max_dt_Getter, &Dtool_ClockObject_max_dt_Setter, nullptr, nullptr},
  {(char *)"degrade_factor", &Dtool_ClockObject_degrade_factor_Getter, &Dtool_ClockObject_degrade_factor_Setter, nullptr, nullptr},
  {(char *)"average_frame_rate_interval", &Dtool_ClockObject_average_frame_rate_interval_Getter, &Dtool_ClockObject_average_frame_rate_interval_Setter, nullptr, nullptr},
  {(char *)"average_frame_rate", &Dtool_ClockObject_average_frame_rate_Getter, nullptr, nullptr, nullptr},
  {(char *)"max_frame_duration", &Dtool_ClockObject_max_frame_duration_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ClockObject = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ClockObject = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ClockObject = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ClockObject = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ClockObject = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ClockObject = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ClockObject",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ClockObject,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ClockObject,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ClockObject,
    &Dtool_SequenceMethods_ClockObject,
    &Dtool_MappingMethods_ClockObject,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ClockObject,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A ClockObject keeps track of elapsed real time and discrete time.  In\n"
    " * normal mode, get_frame_time() returns the time as of the last time tick()\n"
    " * was called.  This is the \"discrete\" time, and is usually used to get the\n"
    " * time as of, for instance, the beginning of the current frame.\n"
    " *\n"
    " * In other modes, as set by set_mode() or the clock-mode config variable,\n"
    " * get_frame_time() may return other values to simulate different timing\n"
    " * effects, for instance to perform non-real-time animation.  See set_mode().\n"
    " *\n"
    " * In all modes, get_real_time() always returns the elapsed real time in\n"
    " * seconds since the ClockObject was constructed, or since it was last reset.\n"
    " *\n"
    " * You can create your own ClockObject whenever you want to have your own\n"
    " * local timer.  There is also a default, global ClockObject intended to\n"
    " * represent global time for the application; this is normally set up to tick\n"
    " * every frame so that its get_frame_time() will return the time for the\n"
    " * current frame.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ClockObject,
    nullptr, // tp_members
    Dtool_Properties_ClockObject,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ClockObject,
    PyType_GenericAlloc,
    Dtool_new_ClockObject,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ClockObject,
  Dtool_UpcastInterface_ClockObject,
  Dtool_DowncastInterface_ClockObject,
  (CoerceFunction)Dtool_ConstCoerce_ClockObject,
  (CoerceFunction)Dtool_Coerce_ClockObject,
};

static void Dtool_PyModuleClassInit_ClockObject(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_ClockObject._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_ClockObject._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(17);
    Dtool_ClockObject._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum ClockObject::Mode;
    PyDict_SetItemString(dict, "M_normal", Dtool_WrapValue(ClockObject::M_normal));
    PyDict_SetItemString(dict, "MNormal", Dtool_WrapValue(ClockObject::M_normal));
    PyDict_SetItemString(dict, "M_non_real_time", Dtool_WrapValue(ClockObject::M_non_real_time));
    PyDict_SetItemString(dict, "MNonRealTime", Dtool_WrapValue(ClockObject::M_non_real_time));
    PyDict_SetItemString(dict, "M_forced", Dtool_WrapValue(ClockObject::M_forced));
    PyDict_SetItemString(dict, "MForced", Dtool_WrapValue(ClockObject::M_forced));
    PyDict_SetItemString(dict, "M_degrade", Dtool_WrapValue(ClockObject::M_degrade));
    PyDict_SetItemString(dict, "MDegrade", Dtool_WrapValue(ClockObject::M_degrade));
    PyDict_SetItemString(dict, "M_slave", Dtool_WrapValue(ClockObject::M_slave));
    PyDict_SetItemString(dict, "MSlave", Dtool_WrapValue(ClockObject::M_slave));
    PyDict_SetItemString(dict, "M_limited", Dtool_WrapValue(ClockObject::M_limited));
    PyDict_SetItemString(dict, "MLimited", Dtool_WrapValue(ClockObject::M_limited));
    PyDict_SetItemString(dict, "M_integer", Dtool_WrapValue(ClockObject::M_integer));
    PyDict_SetItemString(dict, "MInteger", Dtool_WrapValue(ClockObject::M_integer));
    PyDict_SetItemString(dict, "M_integer_limited", Dtool_WrapValue(ClockObject::M_integer_limited));
    PyDict_SetItemString(dict, "MIntegerLimited", Dtool_WrapValue(ClockObject::M_integer_limited));
    if (PyType_Ready((PyTypeObject *)&Dtool_ClockObject) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ClockObject)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ClockObject);
  }
}

/**
 * Python method tables for CopyOnWriteObject (CopyOnWriteObject)
 */
static PyMethodDef Dtool_Methods_CopyOnWriteObject[] = {
  {"cache_ref", &Dtool_CopyOnWriteObject_cache_ref_668, METH_NOARGS, (const char *)Dtool_CopyOnWriteObject_cache_ref_668_comment},
  {"cacheRef", &Dtool_CopyOnWriteObject_cache_ref_668, METH_NOARGS, (const char *)Dtool_CopyOnWriteObject_cache_ref_668_comment},
  {"cache_unref", &Dtool_CopyOnWriteObject_cache_unref_669, METH_NOARGS, (const char *)Dtool_CopyOnWriteObject_cache_unref_669_comment},
  {"cacheUnref", &Dtool_CopyOnWriteObject_cache_unref_669, METH_NOARGS, (const char *)Dtool_CopyOnWriteObject_cache_unref_669_comment},
  {"get_class_type", &Dtool_CopyOnWriteObject_get_class_type_670, METH_NOARGS | METH_STATIC, (const char *)Dtool_CopyOnWriteObject_get_class_type_670_comment},
  {"getClassType", &Dtool_CopyOnWriteObject_get_class_type_670, METH_NOARGS | METH_STATIC, (const char *)Dtool_CopyOnWriteObject_get_class_type_670_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_CopyOnWriteObject = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_CopyOnWriteObject = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_CopyOnWriteObject = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_CopyOnWriteObject = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_CopyOnWriteObject = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_CopyOnWriteObject = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.CopyOnWriteObject",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_CopyOnWriteObject,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_CopyOnWriteObject,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_CopyOnWriteObject,
    &Dtool_SequenceMethods_CopyOnWriteObject,
    &Dtool_MappingMethods_CopyOnWriteObject,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_CopyOnWriteObject,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This base class provides basic reference counting, but also can be used\n"
    " * with a CopyOnWritePointer to provide get_read_pointer() and\n"
    " * get_write_pointer().\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_CopyOnWriteObject,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_CopyOnWriteObject,
    PyType_GenericAlloc,
    Dtool_new_CopyOnWriteObject,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_CopyOnWriteObject,
  Dtool_UpcastInterface_CopyOnWriteObject,
  Dtool_DowncastInterface_CopyOnWriteObject,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_CopyOnWriteObject(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CachedTypedWritableReferenceCount(nullptr);
    Dtool_CopyOnWriteObject._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CachedTypedWritableReferenceCount);
    Dtool_CopyOnWriteObject._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_CopyOnWriteObject._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_CopyOnWriteObject) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(CopyOnWriteObject)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_CopyOnWriteObject);
  }
}

/**
 * Python method tables for DatagramBuffer (DatagramBuffer)
 */
static PyMethodDef Dtool_Methods_DatagramBuffer[] = {
  {"clear", &Dtool_DatagramBuffer_clear_678, METH_NOARGS, (const char *)Dtool_DatagramBuffer_clear_678_comment},
  {"upcast_to_DatagramSink", &Dtool_DatagramBuffer_upcast_to_DatagramSink_673, METH_NOARGS, (const char *)Dtool_DatagramBuffer_upcast_to_DatagramSink_673_comment},
  {"upcastToDatagramSink", &Dtool_DatagramBuffer_upcast_to_DatagramSink_673, METH_NOARGS, (const char *)Dtool_DatagramBuffer_upcast_to_DatagramSink_673_comment},
  {"upcast_to_DatagramGenerator", &Dtool_DatagramBuffer_upcast_to_DatagramGenerator_675, METH_NOARGS, (const char *)Dtool_DatagramBuffer_upcast_to_DatagramGenerator_675_comment},
  {"upcastToDatagramGenerator", &Dtool_DatagramBuffer_upcast_to_DatagramGenerator_675, METH_NOARGS, (const char *)Dtool_DatagramBuffer_upcast_to_DatagramGenerator_675_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_DatagramBuffer[] = {
  {(char *)"data", &Dtool_DatagramBuffer_data_Getter, &Dtool_DatagramBuffer_data_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_DatagramBuffer = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DatagramBuffer = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DatagramBuffer = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DatagramBuffer = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DatagramBuffer = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DatagramBuffer = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DatagramBuffer",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DatagramBuffer,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DatagramBuffer,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DatagramBuffer,
    &Dtool_SequenceMethods_DatagramBuffer,
    &Dtool_MappingMethods_DatagramBuffer,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DatagramBuffer,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class can be used to write a series of datagrams into a memory buffer.\n"
    " * It acts as both a datagram sink and generator; you can fill it up with\n"
    " * datagrams and then read as many datagrams from it.\n"
    " *\n"
    " * This uses the same format as DatagramInputFile and DatagramOutputFile,\n"
    " * meaning that Datagram sizes are always stored little-endian.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DatagramBuffer,
    nullptr, // tp_members
    Dtool_Properties_DatagramBuffer,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DatagramBuffer,
    PyType_GenericAlloc,
    Dtool_new_DatagramBuffer,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DatagramBuffer,
  Dtool_UpcastInterface_DatagramBuffer,
  Dtool_DowncastInterface_DatagramBuffer,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DatagramBuffer(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DatagramSink != nullptr);
    assert(Dtool_Ptr_DatagramSink->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_DatagramSink->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_DatagramGenerator != nullptr);
    assert(Dtool_Ptr_DatagramGenerator->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_DatagramGenerator->_Dtool_ModuleClassInit(nullptr);
    Dtool_DatagramBuffer._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_DatagramSink, (PyTypeObject *)Dtool_Ptr_DatagramGenerator);
    Dtool_DatagramBuffer._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DatagramBuffer._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DatagramBuffer) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DatagramBuffer)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DatagramBuffer);
  }
}

/**
 * Python method tables for DatagramInputFile (DatagramInputFile)
 */
static PyMethodDef Dtool_Methods_DatagramInputFile[] = {
  {"open", (PyCFunction) &Dtool_DatagramInputFile_open_688, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DatagramInputFile_open_688_comment},
  {"get_stream", &Dtool_DatagramInputFile_get_stream_689, METH_NOARGS, (const char *)Dtool_DatagramInputFile_get_stream_689_comment},
  {"getStream", &Dtool_DatagramInputFile_get_stream_689, METH_NOARGS, (const char *)Dtool_DatagramInputFile_get_stream_689_comment},
  {"close", &Dtool_DatagramInputFile_close_690, METH_NOARGS, (const char *)Dtool_DatagramInputFile_close_690_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_DatagramInputFile = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DatagramInputFile = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DatagramInputFile = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DatagramInputFile = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DatagramInputFile = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DatagramInputFile = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DatagramInputFile",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DatagramInputFile,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DatagramInputFile,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DatagramInputFile,
    &Dtool_SequenceMethods_DatagramInputFile,
    &Dtool_MappingMethods_DatagramInputFile,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DatagramInputFile,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class can be used to read a binary file that consists of an arbitrary\n"
    " * header followed by a number of datagrams.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DatagramInputFile,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DatagramInputFile,
    PyType_GenericAlloc,
    Dtool_new_DatagramInputFile,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DatagramInputFile,
  Dtool_UpcastInterface_DatagramInputFile,
  Dtool_DowncastInterface_DatagramInputFile,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DatagramInputFile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DatagramGenerator != nullptr);
    assert(Dtool_Ptr_DatagramGenerator->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_DatagramGenerator->_Dtool_ModuleClassInit(nullptr);
    Dtool_DatagramInputFile._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DatagramGenerator);
    Dtool_DatagramInputFile._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DatagramInputFile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DatagramInputFile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DatagramInputFile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DatagramInputFile);
  }
}

/**
 * Python method tables for DatagramOutputFile (DatagramOutputFile)
 */
static PyMethodDef Dtool_Methods_DatagramOutputFile[] = {
  {"open", (PyCFunction) &Dtool_DatagramOutputFile_open_694, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DatagramOutputFile_open_694_comment},
  {"close", &Dtool_DatagramOutputFile_close_695, METH_NOARGS, (const char *)Dtool_DatagramOutputFile_close_695_comment},
  {"write_header", &Dtool_DatagramOutputFile_write_header_696, METH_O, (const char *)Dtool_DatagramOutputFile_write_header_696_comment},
  {"writeHeader", &Dtool_DatagramOutputFile_write_header_696, METH_O, (const char *)Dtool_DatagramOutputFile_write_header_696_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_DatagramOutputFile[] = {
  {(char *)"stream", &Dtool_DatagramOutputFile_stream_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_DatagramOutputFile = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_DatagramOutputFile = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_DatagramOutputFile = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_DatagramOutputFile = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_DatagramOutputFile = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_DatagramOutputFile = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DatagramOutputFile",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DatagramOutputFile,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_DatagramOutputFile,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_DatagramOutputFile,
    &Dtool_SequenceMethods_DatagramOutputFile,
    &Dtool_MappingMethods_DatagramOutputFile,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_DatagramOutputFile,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class can be used to write a binary file that consists of an arbitrary\n"
    " * header followed by a number of datagrams.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DatagramOutputFile,
    nullptr, // tp_members
    Dtool_Properties_DatagramOutputFile,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DatagramOutputFile,
    PyType_GenericAlloc,
    Dtool_new_DatagramOutputFile,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DatagramOutputFile,
  Dtool_UpcastInterface_DatagramOutputFile,
  Dtool_DowncastInterface_DatagramOutputFile,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DatagramOutputFile(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DatagramSink != nullptr);
    assert(Dtool_Ptr_DatagramSink->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_DatagramSink->_Dtool_ModuleClassInit(nullptr);
    Dtool_DatagramOutputFile._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DatagramSink);
    Dtool_DatagramOutputFile._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DatagramOutputFile._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DatagramOutputFile) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DatagramOutputFile)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DatagramOutputFile);
  }
}

/**
 * Python method tables for DoubleBitMask_BitMaskNative (DoubleBitMask_BitMaskNative)
 */
static PyMethodDef Dtool_Methods_DoubleBitMask_BitMaskNative[] = {
  {"all_on", &Dtool_DoubleBitMask_BitMaskNative_all_on_702, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_all_on_702_comment},
  {"allOn", &Dtool_DoubleBitMask_BitMaskNative_all_on_702, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_all_on_702_comment},
  {"all_off", &Dtool_DoubleBitMask_BitMaskNative_all_off_703, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_all_off_703_comment},
  {"allOff", &Dtool_DoubleBitMask_BitMaskNative_all_off_703, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_all_off_703_comment},
  {"lower_on", &Dtool_DoubleBitMask_BitMaskNative_lower_on_704, METH_O | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_lower_on_704_comment},
  {"lowerOn", &Dtool_DoubleBitMask_BitMaskNative_lower_on_704, METH_O | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_lower_on_704_comment},
  {"bit", &Dtool_DoubleBitMask_BitMaskNative_bit_705, METH_O | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_bit_705_comment},
  {"range", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_range_706, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_range_706_comment},
  {"has_max_num_bits", &Dtool_DoubleBitMask_BitMaskNative_has_max_num_bits_707, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_has_max_num_bits_707_comment},
  {"hasMaxNumBits", &Dtool_DoubleBitMask_BitMaskNative_has_max_num_bits_707, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_has_max_num_bits_707_comment},
  {"get_max_num_bits", &Dtool_DoubleBitMask_BitMaskNative_get_max_num_bits_708, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_max_num_bits_708_comment},
  {"getMaxNumBits", &Dtool_DoubleBitMask_BitMaskNative_get_max_num_bits_708, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_max_num_bits_708_comment},
  {"get_num_bits", &Dtool_DoubleBitMask_BitMaskNative_get_num_bits_709, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_num_bits_709_comment},
  {"getNumBits", &Dtool_DoubleBitMask_BitMaskNative_get_num_bits_709, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_num_bits_709_comment},
  {"get_bit", &Dtool_DoubleBitMask_BitMaskNative_get_bit_710, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_bit_710_comment},
  {"getBit", &Dtool_DoubleBitMask_BitMaskNative_get_bit_710, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_bit_710_comment},
  {"set_bit", &Dtool_DoubleBitMask_BitMaskNative_set_bit_711, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_set_bit_711_comment},
  {"setBit", &Dtool_DoubleBitMask_BitMaskNative_set_bit_711, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_set_bit_711_comment},
  {"clear_bit", &Dtool_DoubleBitMask_BitMaskNative_clear_bit_712, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_clear_bit_712_comment},
  {"clearBit", &Dtool_DoubleBitMask_BitMaskNative_clear_bit_712, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_clear_bit_712_comment},
  {"set_bit_to", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_set_bit_to_713, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_set_bit_to_713_comment},
  {"setBitTo", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_set_bit_to_713, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_set_bit_to_713_comment},
  {"is_zero", &Dtool_DoubleBitMask_BitMaskNative_is_zero_714, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_is_zero_714_comment},
  {"isZero", &Dtool_DoubleBitMask_BitMaskNative_is_zero_714, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_is_zero_714_comment},
  {"is_all_on", &Dtool_DoubleBitMask_BitMaskNative_is_all_on_715, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_is_all_on_715_comment},
  {"isAllOn", &Dtool_DoubleBitMask_BitMaskNative_is_all_on_715, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_is_all_on_715_comment},
  {"extract", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_extract_716, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_extract_716_comment},
  {"store", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_store_717, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_store_717_comment},
  {"has_any_of", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_has_any_of_718, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_has_any_of_718_comment},
  {"hasAnyOf", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_has_any_of_718, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_has_any_of_718_comment},
  {"has_all_of", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_has_all_of_719, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_has_all_of_719_comment},
  {"hasAllOf", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_has_all_of_719, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_has_all_of_719_comment},
  {"set_range", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_set_range_720, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_set_range_720_comment},
  {"setRange", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_set_range_720, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_set_range_720_comment},
  {"clear_range", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_clear_range_721, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_clear_range_721_comment},
  {"clearRange", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_clear_range_721, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_clear_range_721_comment},
  {"set_range_to", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_set_range_to_722, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_set_range_to_722_comment},
  {"setRangeTo", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_set_range_to_722, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_set_range_to_722_comment},
  {"get_num_on_bits", &Dtool_DoubleBitMask_BitMaskNative_get_num_on_bits_723, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_num_on_bits_723_comment},
  {"getNumOnBits", &Dtool_DoubleBitMask_BitMaskNative_get_num_on_bits_723, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_num_on_bits_723_comment},
  {"get_num_off_bits", &Dtool_DoubleBitMask_BitMaskNative_get_num_off_bits_724, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_num_off_bits_724_comment},
  {"getNumOffBits", &Dtool_DoubleBitMask_BitMaskNative_get_num_off_bits_724, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_num_off_bits_724_comment},
  {"get_lowest_on_bit", &Dtool_DoubleBitMask_BitMaskNative_get_lowest_on_bit_725, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_lowest_on_bit_725_comment},
  {"getLowestOnBit", &Dtool_DoubleBitMask_BitMaskNative_get_lowest_on_bit_725, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_lowest_on_bit_725_comment},
  {"get_lowest_off_bit", &Dtool_DoubleBitMask_BitMaskNative_get_lowest_off_bit_726, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_lowest_off_bit_726_comment},
  {"getLowestOffBit", &Dtool_DoubleBitMask_BitMaskNative_get_lowest_off_bit_726, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_lowest_off_bit_726_comment},
  {"get_highest_on_bit", &Dtool_DoubleBitMask_BitMaskNative_get_highest_on_bit_727, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_highest_on_bit_727_comment},
  {"getHighestOnBit", &Dtool_DoubleBitMask_BitMaskNative_get_highest_on_bit_727, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_highest_on_bit_727_comment},
  {"get_highest_off_bit", &Dtool_DoubleBitMask_BitMaskNative_get_highest_off_bit_728, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_highest_off_bit_728_comment},
  {"getHighestOffBit", &Dtool_DoubleBitMask_BitMaskNative_get_highest_off_bit_728, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_highest_off_bit_728_comment},
  {"get_next_higher_different_bit", &Dtool_DoubleBitMask_BitMaskNative_get_next_higher_different_bit_729, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_next_higher_different_bit_729_comment},
  {"getNextHigherDifferentBit", &Dtool_DoubleBitMask_BitMaskNative_get_next_higher_different_bit_729, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_next_higher_different_bit_729_comment},
  {"invert_in_place", &Dtool_DoubleBitMask_BitMaskNative_invert_in_place_730, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_invert_in_place_730_comment},
  {"invertInPlace", &Dtool_DoubleBitMask_BitMaskNative_invert_in_place_730, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_invert_in_place_730_comment},
  {"has_bits_in_common", &Dtool_DoubleBitMask_BitMaskNative_has_bits_in_common_731, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_has_bits_in_common_731_comment},
  {"hasBitsInCommon", &Dtool_DoubleBitMask_BitMaskNative_has_bits_in_common_731, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_has_bits_in_common_731_comment},
  {"clear", &Dtool_DoubleBitMask_BitMaskNative_clear_732, METH_NOARGS, (const char *)Dtool_DoubleBitMask_BitMaskNative_clear_732_comment},
  {"output", &Dtool_DoubleBitMask_BitMaskNative_output_733, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_output_733_comment},
  {"output_binary", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_output_binary_734, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_output_binary_734_comment},
  {"outputBinary", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_output_binary_734, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_output_binary_734_comment},
  {"output_hex", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_output_hex_735, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_output_hex_735_comment},
  {"outputHex", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_output_hex_735, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_output_hex_735_comment},
  {"write", (PyCFunction) &Dtool_DoubleBitMask_BitMaskNative_write_736, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_BitMaskNative_write_736_comment},
  {"compare_to", &Dtool_DoubleBitMask_BitMaskNative_compare_to_740, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_compare_to_740_comment},
  {"compareTo", &Dtool_DoubleBitMask_BitMaskNative_compare_to_740, METH_O, (const char *)Dtool_DoubleBitMask_BitMaskNative_compare_to_740_comment},
  {"get_class_type", &Dtool_DoubleBitMask_BitMaskNative_get_class_type_752, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_class_type_752_comment},
  {"getClassType", &Dtool_DoubleBitMask_BitMaskNative_get_class_type_752, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_BitMaskNative_get_class_type_752_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_and -> operator &
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_741_nb_and(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator &(DoubleBitMask< BitMaskNative > const &other) const
  DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.__and__", true, true);
  if (arg_this != nullptr) {
    DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >(((*(const DoubleBitMask< BitMaskNative >*)local_this).operator &)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_inplace_and -> operator &=
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_747_nb_inplace_and(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::operator &=(DoubleBitMask< BitMaskNative > const &other)
  DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.__iand__", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator &=)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_inplace_lshift -> operator <<=
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_750_nb_inplace_lshift(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::operator <<=(int shift)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return nullptr;
    }
#endif
    ((*local_this).operator <<=)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_inplace_or -> operator |=
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_748_nb_inplace_or(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::operator |=(DoubleBitMask< BitMaskNative > const &other)
  DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.__ior__", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator |=)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_inplace_rshift -> operator >>=
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_751_nb_inplace_rshift(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::operator >>=(int shift)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return nullptr;
    }
#endif
    ((*local_this).operator >>=)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_inplace_xor -> operator ^=
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_749_nb_inplace_xor(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void DoubleBitMask< BitMaskNative >::operator ^=(DoubleBitMask< BitMaskNative > const &other)
  DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.__ixor__", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator ^=)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_invert -> operator ~
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_744_nb_invert(PyObject *self) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator ~(void) const
  DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >(((*(const DoubleBitMask< BitMaskNative >*)local_this).operator ~)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__invert__(DoubleBitMask self)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_lshift -> operator <<
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_745_nb_lshift(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator <<(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >(((*(const DoubleBitMask< BitMaskNative >*)local_this).operator <<)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_or -> operator |
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_742_nb_or(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator |(DoubleBitMask< BitMaskNative > const &other) const
  DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.__or__", true, true);
  if (arg_this != nullptr) {
    DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >(((*(const DoubleBitMask< BitMaskNative >*)local_this).operator |)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_rshift -> operator >>
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_746_nb_rshift(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator >>(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >(((*(const DoubleBitMask< BitMaskNative >*)local_this).operator >>)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot nb_xor -> operator ^
//////////////////
static PyObject *Dtool_DoubleBitMask_BitMaskNative_operator_743_nb_xor(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< BitMaskNative > DoubleBitMask< BitMaskNative >::operator ^(DoubleBitMask< BitMaskNative > const &other) const
  DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.__xor__", true, true);
  if (arg_this != nullptr) {
    DoubleBitMask< BitMaskNative > *return_value = new DoubleBitMask< BitMaskNative >(((*(const DoubleBitMask< BitMaskNative >*)local_this).operator ^)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_BitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_BitMaskNative slot tp_compare -> compare_to
//////////////////
static int Dtool_DoubleBitMask_BitMaskNative_compare_to_740_tp_compare(PyObject *self, PyObject *arg) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int DoubleBitMask< BitMaskNative >::compare_to(DoubleBitMask< BitMaskNative > const &other) const
  DoubleBitMask< BitMaskNative > const *arg_this = (DoubleBitMask< BitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_BitMaskNative, 1, "DoubleBitMask.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(DoubleBitMask self, const DoubleBitMask other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     DoubleBitMask_BitMaskNative
//////////////////
static PyObject *Dtool_Repr_DoubleBitMask_BitMaskNative(PyObject *self) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     DoubleBitMask_BitMaskNative
//////////////////
static PyObject *Dtool_Str_DoubleBitMask_BitMaskNative(PyObject *self) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     DoubleBitMask_BitMaskNative
//////////////////
static PyObject *Dtool_RichCompare_DoubleBitMask_BitMaskNative(PyObject *self, PyObject *arg, int op) {
  DoubleBitMask< BitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_BitMaskNative, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool DoubleBitMask< BitMaskNative >::operator ==(DoubleBitMask< BitMaskNative > const &other) const
      DoubleBitMask< BitMaskNative > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_DoubleBitMask_BitMaskNative);
      if (arg_this != nullptr) {
        bool return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool DoubleBitMask< BitMaskNative >::operator !=(DoubleBitMask< BitMaskNative > const &other) const
      DoubleBitMask< BitMaskNative > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_DoubleBitMask_BitMaskNative);
      if (arg_this != nullptr) {
        bool return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool DoubleBitMask< BitMaskNative >::operator <(DoubleBitMask< BitMaskNative > const &other) const
      DoubleBitMask< BitMaskNative > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_DoubleBitMask_BitMaskNative);
      if (arg_this != nullptr) {
        bool return_value = ((*(const DoubleBitMask< BitMaskNative >*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_DoubleBitMask_BitMaskNative_compare_to_740_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_DoubleBitMask_BitMaskNative = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_DoubleBitMask_BitMaskNative_operator_744_nb_invert,
  &Dtool_DoubleBitMask_BitMaskNative_operator_745_nb_lshift,
  &Dtool_DoubleBitMask_BitMaskNative_operator_746_nb_rshift,
  &Dtool_DoubleBitMask_BitMaskNative_operator_741_nb_and,
  &Dtool_DoubleBitMask_BitMaskNative_operator_743_nb_xor,
  &Dtool_DoubleBitMask_BitMaskNative_operator_742_nb_or,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  &Dtool_DoubleBitMask_BitMaskNative_operator_750_nb_inplace_lshift,
  &Dtool_DoubleBitMask_BitMaskNative_operator_751_nb_inplace_rshift,
  &Dtool_DoubleBitMask_BitMaskNative_operator_747_nb_inplace_and,
  &Dtool_DoubleBitMask_BitMaskNative_operator_749_nb_inplace_xor,
  &Dtool_DoubleBitMask_BitMaskNative_operator_748_nb_inplace_or,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_DoubleBitMask_BitMaskNative = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DoubleBitMask_BitMaskNative",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DoubleBitMask_BitMaskNative,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_DoubleBitMask_BitMaskNative_compare_to_740_tp_compare,
#endif
    &Dtool_Repr_DoubleBitMask_BitMaskNative,
    &Dtool_NumberMethods_DoubleBitMask_BitMaskNative,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_DoubleBitMask_BitMaskNative,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_DoubleBitMask_BitMaskNative,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DoubleBitMask_BitMaskNative,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DoubleBitMask_BitMaskNative,
    PyType_GenericAlloc,
    Dtool_new_DoubleBitMask_BitMaskNative,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DoubleBitMask_BitMaskNative,
  Dtool_UpcastInterface_DoubleBitMask_BitMaskNative,
  Dtool_DowncastInterface_DoubleBitMask_BitMaskNative,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DoubleBitMask_BitMaskNative(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DoubleBitMask_BitMaskNative._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DoubleBitMask_BitMaskNative._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DoubleBitMask_BitMaskNative) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DoubleBitMask_BitMaskNative)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DoubleBitMask_BitMaskNative);
  }
}

/**
 * Python method tables for DoubleBitMask_DoubleBitMaskNative (DoubleBitMask_DoubleBitMaskNative)
 */
static PyMethodDef Dtool_Methods_DoubleBitMask_DoubleBitMaskNative[] = {
  {"all_on", &Dtool_DoubleBitMask_DoubleBitMaskNative_all_on_757, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_all_on_757_comment},
  {"allOn", &Dtool_DoubleBitMask_DoubleBitMaskNative_all_on_757, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_all_on_757_comment},
  {"all_off", &Dtool_DoubleBitMask_DoubleBitMaskNative_all_off_758, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_all_off_758_comment},
  {"allOff", &Dtool_DoubleBitMask_DoubleBitMaskNative_all_off_758, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_all_off_758_comment},
  {"lower_on", &Dtool_DoubleBitMask_DoubleBitMaskNative_lower_on_759, METH_O | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_lower_on_759_comment},
  {"lowerOn", &Dtool_DoubleBitMask_DoubleBitMaskNative_lower_on_759, METH_O | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_lower_on_759_comment},
  {"bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_bit_760, METH_O | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_bit_760_comment},
  {"range", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_range_761, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_range_761_comment},
  {"has_max_num_bits", &Dtool_DoubleBitMask_DoubleBitMaskNative_has_max_num_bits_762, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_has_max_num_bits_762_comment},
  {"hasMaxNumBits", &Dtool_DoubleBitMask_DoubleBitMaskNative_has_max_num_bits_762, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_has_max_num_bits_762_comment},
  {"get_max_num_bits", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_max_num_bits_763, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_max_num_bits_763_comment},
  {"getMaxNumBits", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_max_num_bits_763, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_max_num_bits_763_comment},
  {"get_num_bits", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_bits_764, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_bits_764_comment},
  {"getNumBits", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_bits_764, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_bits_764_comment},
  {"get_bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_bit_765, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_bit_765_comment},
  {"getBit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_bit_765, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_bit_765_comment},
  {"set_bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_766, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_766_comment},
  {"setBit", &Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_766, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_766_comment},
  {"clear_bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_clear_bit_767, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_clear_bit_767_comment},
  {"clearBit", &Dtool_DoubleBitMask_DoubleBitMaskNative_clear_bit_767, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_clear_bit_767_comment},
  {"set_bit_to", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_to_768, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_to_768_comment},
  {"setBitTo", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_to_768, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_set_bit_to_768_comment},
  {"is_zero", &Dtool_DoubleBitMask_DoubleBitMaskNative_is_zero_769, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_is_zero_769_comment},
  {"isZero", &Dtool_DoubleBitMask_DoubleBitMaskNative_is_zero_769, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_is_zero_769_comment},
  {"is_all_on", &Dtool_DoubleBitMask_DoubleBitMaskNative_is_all_on_770, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_is_all_on_770_comment},
  {"isAllOn", &Dtool_DoubleBitMask_DoubleBitMaskNative_is_all_on_770, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_is_all_on_770_comment},
  {"extract", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_extract_771, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_extract_771_comment},
  {"store", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_store_772, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_store_772_comment},
  {"has_any_of", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_has_any_of_773, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_has_any_of_773_comment},
  {"hasAnyOf", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_has_any_of_773, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_has_any_of_773_comment},
  {"has_all_of", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_has_all_of_774, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_has_all_of_774_comment},
  {"hasAllOf", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_has_all_of_774, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_has_all_of_774_comment},
  {"set_range", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_775, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_775_comment},
  {"setRange", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_775, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_775_comment},
  {"clear_range", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_clear_range_776, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_clear_range_776_comment},
  {"clearRange", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_clear_range_776, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_clear_range_776_comment},
  {"set_range_to", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_to_777, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_to_777_comment},
  {"setRangeTo", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_to_777, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_set_range_to_777_comment},
  {"get_num_on_bits", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_on_bits_778, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_on_bits_778_comment},
  {"getNumOnBits", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_on_bits_778, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_on_bits_778_comment},
  {"get_num_off_bits", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_off_bits_779, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_off_bits_779_comment},
  {"getNumOffBits", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_off_bits_779, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_num_off_bits_779_comment},
  {"get_lowest_on_bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_on_bit_780, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_on_bit_780_comment},
  {"getLowestOnBit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_on_bit_780, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_on_bit_780_comment},
  {"get_lowest_off_bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_off_bit_781, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_off_bit_781_comment},
  {"getLowestOffBit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_off_bit_781, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_lowest_off_bit_781_comment},
  {"get_highest_on_bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_on_bit_782, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_on_bit_782_comment},
  {"getHighestOnBit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_on_bit_782, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_on_bit_782_comment},
  {"get_highest_off_bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_off_bit_783, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_off_bit_783_comment},
  {"getHighestOffBit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_off_bit_783, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_highest_off_bit_783_comment},
  {"get_next_higher_different_bit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_next_higher_different_bit_784, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_next_higher_different_bit_784_comment},
  {"getNextHigherDifferentBit", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_next_higher_different_bit_784, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_next_higher_different_bit_784_comment},
  {"invert_in_place", &Dtool_DoubleBitMask_DoubleBitMaskNative_invert_in_place_785, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_invert_in_place_785_comment},
  {"invertInPlace", &Dtool_DoubleBitMask_DoubleBitMaskNative_invert_in_place_785, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_invert_in_place_785_comment},
  {"has_bits_in_common", &Dtool_DoubleBitMask_DoubleBitMaskNative_has_bits_in_common_786, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_has_bits_in_common_786_comment},
  {"hasBitsInCommon", &Dtool_DoubleBitMask_DoubleBitMaskNative_has_bits_in_common_786, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_has_bits_in_common_786_comment},
  {"clear", &Dtool_DoubleBitMask_DoubleBitMaskNative_clear_787, METH_NOARGS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_clear_787_comment},
  {"output", &Dtool_DoubleBitMask_DoubleBitMaskNative_output_788, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_output_788_comment},
  {"output_binary", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_output_binary_789, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_output_binary_789_comment},
  {"outputBinary", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_output_binary_789, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_output_binary_789_comment},
  {"output_hex", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_output_hex_790, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_output_hex_790_comment},
  {"outputHex", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_output_hex_790, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_output_hex_790_comment},
  {"write", (PyCFunction) &Dtool_DoubleBitMask_DoubleBitMaskNative_write_791, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_write_791_comment},
  {"compare_to", &Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_795, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_795_comment},
  {"compareTo", &Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_795, METH_O, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_795_comment},
  {"get_class_type", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_class_type_807, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_class_type_807_comment},
  {"getClassType", &Dtool_DoubleBitMask_DoubleBitMaskNative_get_class_type_807, METH_NOARGS | METH_STATIC, (const char *)Dtool_DoubleBitMask_DoubleBitMaskNative_get_class_type_807_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_and -> operator &
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_796_nb_and(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator &(DoubleBitMask< DoubleBitMaskNative > const &other) const
  DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.__and__", true, true);
  if (arg_this != nullptr) {
    DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >(((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator &)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_inplace_and -> operator &=
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_802_nb_inplace_and(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::operator &=(DoubleBitMask< DoubleBitMaskNative > const &other)
  DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.__iand__", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator &=)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_inplace_lshift -> operator <<=
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_805_nb_inplace_lshift(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::operator <<=(int shift)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return nullptr;
    }
#endif
    ((*local_this).operator <<=)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_inplace_or -> operator |=
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_803_nb_inplace_or(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::operator |=(DoubleBitMask< DoubleBitMaskNative > const &other)
  DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.__ior__", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator |=)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_inplace_rshift -> operator >>=
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_806_nb_inplace_rshift(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::operator >>=(int shift)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return nullptr;
    }
#endif
    ((*local_this).operator >>=)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_inplace_xor -> operator ^=
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_804_nb_inplace_xor(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void DoubleBitMask< DoubleBitMaskNative >::operator ^=(DoubleBitMask< DoubleBitMaskNative > const &other)
  DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.__ixor__", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator ^=)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_invert -> operator ~
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_799_nb_invert(PyObject *self) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator ~(void) const
  DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >(((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator ~)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__invert__(DoubleBitMask self)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_lshift -> operator <<
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_800_nb_lshift(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator <<(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >(((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator <<)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_or -> operator |
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_797_nb_or(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator |(DoubleBitMask< DoubleBitMaskNative > const &other) const
  DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.__or__", true, true);
  if (arg_this != nullptr) {
    DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >(((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator |)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_rshift -> operator >>
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_801_nb_rshift(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator >>(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >(((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator >>)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot nb_xor -> operator ^
//////////////////
static PyObject *Dtool_DoubleBitMask_DoubleBitMaskNative_operator_798_nb_xor(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline DoubleBitMask< DoubleBitMaskNative > DoubleBitMask< DoubleBitMaskNative >::operator ^(DoubleBitMask< DoubleBitMaskNative > const &other) const
  DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.__xor__", true, true);
  if (arg_this != nullptr) {
    DoubleBitMask< DoubleBitMaskNative > *return_value = new DoubleBitMask< DoubleBitMaskNative >(((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator ^)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// DoubleBitMask_DoubleBitMaskNative slot tp_compare -> compare_to
//////////////////
static int Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_795_tp_compare(PyObject *self, PyObject *arg) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return -1;
  }

  // 1-inline int DoubleBitMask< DoubleBitMaskNative >::compare_to(DoubleBitMask< DoubleBitMaskNative > const &other) const
  DoubleBitMask< DoubleBitMaskNative > const *arg_this = (DoubleBitMask< DoubleBitMaskNative > *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative, 1, "DoubleBitMask.compare_to", true, true);
  if (arg_this != nullptr) {
    int return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return (int)(return_value > 0) - (int)(return_value < 0);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(DoubleBitMask self, const DoubleBitMask other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     DoubleBitMask_DoubleBitMaskNative
//////////////////
static PyObject *Dtool_Repr_DoubleBitMask_DoubleBitMaskNative(PyObject *self) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     DoubleBitMask_DoubleBitMaskNative
//////////////////
static PyObject *Dtool_Str_DoubleBitMask_DoubleBitMaskNative(PyObject *self) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     DoubleBitMask_DoubleBitMaskNative
//////////////////
static PyObject *Dtool_RichCompare_DoubleBitMask_DoubleBitMaskNative(PyObject *self, PyObject *arg, int op) {
  DoubleBitMask< DoubleBitMaskNative > *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_DoubleBitMask_DoubleBitMaskNative, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::operator ==(DoubleBitMask< DoubleBitMaskNative > const &other) const
      DoubleBitMask< DoubleBitMaskNative > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative);
      if (arg_this != nullptr) {
        bool return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::operator !=(DoubleBitMask< DoubleBitMaskNative > const &other) const
      DoubleBitMask< DoubleBitMaskNative > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative);
      if (arg_this != nullptr) {
        bool return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool DoubleBitMask< DoubleBitMaskNative >::operator <(DoubleBitMask< DoubleBitMaskNative > const &other) const
      DoubleBitMask< DoubleBitMaskNative > const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative);
      if (arg_this != nullptr) {
        bool return_value = ((*(const DoubleBitMask< DoubleBitMaskNative >*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_795_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_DoubleBitMask_DoubleBitMaskNative = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_799_nb_invert,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_800_nb_lshift,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_801_nb_rshift,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_796_nb_and,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_798_nb_xor,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_797_nb_or,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_805_nb_inplace_lshift,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_806_nb_inplace_rshift,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_802_nb_inplace_and,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_804_nb_inplace_xor,
  &Dtool_DoubleBitMask_DoubleBitMaskNative_operator_803_nb_inplace_or,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_DoubleBitMask_DoubleBitMaskNative = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.DoubleBitMask_DoubleBitMaskNative",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_DoubleBitMask_DoubleBitMaskNative,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_DoubleBitMask_DoubleBitMaskNative_compare_to_795_tp_compare,
#endif
    &Dtool_Repr_DoubleBitMask_DoubleBitMaskNative,
    &Dtool_NumberMethods_DoubleBitMask_DoubleBitMaskNative,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_DoubleBitMask_DoubleBitMaskNative,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_DoubleBitMask_DoubleBitMaskNative,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_DoubleBitMask_DoubleBitMaskNative,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_DoubleBitMask_DoubleBitMaskNative,
    PyType_GenericAlloc,
    Dtool_new_DoubleBitMask_DoubleBitMaskNative,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_DoubleBitMask_DoubleBitMaskNative,
  Dtool_UpcastInterface_DoubleBitMask_DoubleBitMaskNative,
  Dtool_DowncastInterface_DoubleBitMask_DoubleBitMaskNative,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_DoubleBitMask_DoubleBitMaskNative(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_DoubleBitMask_DoubleBitMaskNative._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_DoubleBitMask_DoubleBitMaskNative._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_DoubleBitMask_DoubleBitMaskNative) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(DoubleBitMask_DoubleBitMaskNative)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_DoubleBitMask_DoubleBitMaskNative);
  }
}

/**
 * Python method tables for GamepadButton (GamepadButton)
 */
static PyMethodDef Dtool_Methods_GamepadButton[] = {
  {"lstick", &Dtool_GamepadButton_lstick_812, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_lstick_812_comment},
  {"rstick", &Dtool_GamepadButton_rstick_813, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_rstick_813_comment},
  {"lshoulder", &Dtool_GamepadButton_lshoulder_814, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_lshoulder_814_comment},
  {"rshoulder", &Dtool_GamepadButton_rshoulder_815, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_rshoulder_815_comment},
  {"ltrigger", &Dtool_GamepadButton_ltrigger_816, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_ltrigger_816_comment},
  {"rtrigger", &Dtool_GamepadButton_rtrigger_817, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_rtrigger_817_comment},
  {"lgrip", &Dtool_GamepadButton_lgrip_818, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_lgrip_818_comment},
  {"rgrip", &Dtool_GamepadButton_rgrip_819, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_rgrip_819_comment},
  {"dpad_left", &Dtool_GamepadButton_dpad_left_820, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_dpad_left_820_comment},
  {"dpadLeft", &Dtool_GamepadButton_dpad_left_820, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_dpad_left_820_comment},
  {"dpad_right", &Dtool_GamepadButton_dpad_right_821, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_dpad_right_821_comment},
  {"dpadRight", &Dtool_GamepadButton_dpad_right_821, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_dpad_right_821_comment},
  {"dpad_up", &Dtool_GamepadButton_dpad_up_822, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_dpad_up_822_comment},
  {"dpadUp", &Dtool_GamepadButton_dpad_up_822, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_dpad_up_822_comment},
  {"dpad_down", &Dtool_GamepadButton_dpad_down_823, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_dpad_down_823_comment},
  {"dpadDown", &Dtool_GamepadButton_dpad_down_823, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_dpad_down_823_comment},
  {"back", &Dtool_GamepadButton_back_824, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_back_824_comment},
  {"guide", &Dtool_GamepadButton_guide_825, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_guide_825_comment},
  {"start", &Dtool_GamepadButton_start_826, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_start_826_comment},
  {"next", &Dtool_GamepadButton_next_827, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_next_827_comment},
  {"previous", &Dtool_GamepadButton_previous_828, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_previous_828_comment},
  {"face_a", &Dtool_GamepadButton_face_a_829, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_face_a_829_comment},
  {"faceA", &Dtool_GamepadButton_face_a_829, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_face_a_829_comment},
  {"face_b", &Dtool_GamepadButton_face_b_830, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_face_b_830_comment},
  {"faceB", &Dtool_GamepadButton_face_b_830, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_face_b_830_comment},
  {"face_c", &Dtool_GamepadButton_face_c_831, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_face_c_831_comment},
  {"faceC", &Dtool_GamepadButton_face_c_831, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_face_c_831_comment},
  {"face_x", &Dtool_GamepadButton_face_x_832, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_face_x_832_comment},
  {"faceX", &Dtool_GamepadButton_face_x_832, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_face_x_832_comment},
  {"face_y", &Dtool_GamepadButton_face_y_833, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_face_y_833_comment},
  {"faceY", &Dtool_GamepadButton_face_y_833, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_face_y_833_comment},
  {"face_z", &Dtool_GamepadButton_face_z_834, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_face_z_834_comment},
  {"faceZ", &Dtool_GamepadButton_face_z_834, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_face_z_834_comment},
  {"face_1", &Dtool_GamepadButton_face_1_835, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_face_1_835_comment},
  {"face1", &Dtool_GamepadButton_face_1_835, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_face_1_835_comment},
  {"face_2", &Dtool_GamepadButton_face_2_836, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_face_2_836_comment},
  {"face2", &Dtool_GamepadButton_face_2_836, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_face_2_836_comment},
  {"trigger", &Dtool_GamepadButton_trigger_837, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_trigger_837_comment},
  {"joystick", &Dtool_GamepadButton_joystick_838, METH_O | METH_STATIC, (const char *)Dtool_GamepadButton_joystick_838_comment},
  {"hat_up", &Dtool_GamepadButton_hat_up_839, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_hat_up_839_comment},
  {"hatUp", &Dtool_GamepadButton_hat_up_839, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_hat_up_839_comment},
  {"hat_down", &Dtool_GamepadButton_hat_down_840, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_hat_down_840_comment},
  {"hatDown", &Dtool_GamepadButton_hat_down_840, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_hat_down_840_comment},
  {"hat_left", &Dtool_GamepadButton_hat_left_841, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_hat_left_841_comment},
  {"hatLeft", &Dtool_GamepadButton_hat_left_841, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_hat_left_841_comment},
  {"hat_right", &Dtool_GamepadButton_hat_right_842, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_hat_right_842_comment},
  {"hatRight", &Dtool_GamepadButton_hat_right_842, METH_NOARGS | METH_STATIC, (const char *)Dtool_GamepadButton_hat_right_842_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_GamepadButton = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_GamepadButton = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.GamepadButton",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_GamepadButton,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_GamepadButton,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is just used as a convenient namespace for grouping all of these\n"
    " * handy functions that return buttons which map to gamepad buttons.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_GamepadButton,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_GamepadButton,
    PyType_GenericAlloc,
    Dtool_new_GamepadButton,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_GamepadButton,
  Dtool_UpcastInterface_GamepadButton,
  Dtool_DowncastInterface_GamepadButton,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_GamepadButton(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_GamepadButton._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_GamepadButton._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_GamepadButton) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(GamepadButton)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_GamepadButton);
  }
}

/**
 * Python method tables for KeyboardButton (KeyboardButton)
 */
static PyMethodDef Dtool_Methods_KeyboardButton[] = {
  {"ascii_key", &Dtool_KeyboardButton_ascii_key_846, METH_O | METH_STATIC, (const char *)Dtool_KeyboardButton_ascii_key_846_comment},
  {"asciiKey", &Dtool_KeyboardButton_ascii_key_846, METH_O | METH_STATIC, (const char *)Dtool_KeyboardButton_ascii_key_846_comment},
  {"space", &Dtool_KeyboardButton_space_847, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_space_847_comment},
  {"backspace", &Dtool_KeyboardButton_backspace_848, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_backspace_848_comment},
  {"tab", &Dtool_KeyboardButton_tab_849, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_tab_849_comment},
  {"enter", &Dtool_KeyboardButton_enter_850, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_enter_850_comment},
  {"escape", &Dtool_KeyboardButton_escape_851, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_escape_851_comment},
  {"f1", &Dtool_KeyboardButton_f1_852, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f1_852_comment},
  {"f2", &Dtool_KeyboardButton_f2_853, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f2_853_comment},
  {"f3", &Dtool_KeyboardButton_f3_854, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f3_854_comment},
  {"f4", &Dtool_KeyboardButton_f4_855, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f4_855_comment},
  {"f5", &Dtool_KeyboardButton_f5_856, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f5_856_comment},
  {"f6", &Dtool_KeyboardButton_f6_857, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f6_857_comment},
  {"f7", &Dtool_KeyboardButton_f7_858, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f7_858_comment},
  {"f8", &Dtool_KeyboardButton_f8_859, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f8_859_comment},
  {"f9", &Dtool_KeyboardButton_f9_860, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f9_860_comment},
  {"f10", &Dtool_KeyboardButton_f10_861, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f10_861_comment},
  {"f11", &Dtool_KeyboardButton_f11_862, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f11_862_comment},
  {"f12", &Dtool_KeyboardButton_f12_863, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f12_863_comment},
  {"f13", &Dtool_KeyboardButton_f13_864, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f13_864_comment},
  {"f14", &Dtool_KeyboardButton_f14_865, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f14_865_comment},
  {"f15", &Dtool_KeyboardButton_f15_866, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f15_866_comment},
  {"f16", &Dtool_KeyboardButton_f16_867, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_f16_867_comment},
  {"left", &Dtool_KeyboardButton_left_868, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_left_868_comment},
  {"right", &Dtool_KeyboardButton_right_869, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_right_869_comment},
  {"up", &Dtool_KeyboardButton_up_870, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_up_870_comment},
  {"down", &Dtool_KeyboardButton_down_871, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_down_871_comment},
  {"page_up", &Dtool_KeyboardButton_page_up_872, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_page_up_872_comment},
  {"pageUp", &Dtool_KeyboardButton_page_up_872, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_page_up_872_comment},
  {"page_down", &Dtool_KeyboardButton_page_down_873, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_page_down_873_comment},
  {"pageDown", &Dtool_KeyboardButton_page_down_873, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_page_down_873_comment},
  {"home", &Dtool_KeyboardButton_home_874, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_home_874_comment},
  {"end", &Dtool_KeyboardButton_end_875, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_end_875_comment},
  {"insert", &Dtool_KeyboardButton_insert_876, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_insert_876_comment},
  {"_del", &Dtool_KeyboardButton_del_877, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_del_877_comment},
  {"help", &Dtool_KeyboardButton_help_878, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_help_878_comment},
  {"menu", &Dtool_KeyboardButton_menu_879, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_menu_879_comment},
  {"shift", &Dtool_KeyboardButton_shift_880, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_shift_880_comment},
  {"control", &Dtool_KeyboardButton_control_881, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_control_881_comment},
  {"alt", &Dtool_KeyboardButton_alt_882, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_alt_882_comment},
  {"meta", &Dtool_KeyboardButton_meta_883, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_meta_883_comment},
  {"caps_lock", &Dtool_KeyboardButton_caps_lock_884, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_caps_lock_884_comment},
  {"capsLock", &Dtool_KeyboardButton_caps_lock_884, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_caps_lock_884_comment},
  {"shift_lock", &Dtool_KeyboardButton_shift_lock_885, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_shift_lock_885_comment},
  {"shiftLock", &Dtool_KeyboardButton_shift_lock_885, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_shift_lock_885_comment},
  {"num_lock", &Dtool_KeyboardButton_num_lock_886, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_num_lock_886_comment},
  {"numLock", &Dtool_KeyboardButton_num_lock_886, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_num_lock_886_comment},
  {"scroll_lock", &Dtool_KeyboardButton_scroll_lock_887, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_scroll_lock_887_comment},
  {"scrollLock", &Dtool_KeyboardButton_scroll_lock_887, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_scroll_lock_887_comment},
  {"print_screen", &Dtool_KeyboardButton_print_screen_888, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_print_screen_888_comment},
  {"printScreen", &Dtool_KeyboardButton_print_screen_888, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_print_screen_888_comment},
  {"pause", &Dtool_KeyboardButton_pause_889, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_pause_889_comment},
  {"lshift", &Dtool_KeyboardButton_lshift_890, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_lshift_890_comment},
  {"rshift", &Dtool_KeyboardButton_rshift_891, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_rshift_891_comment},
  {"lcontrol", &Dtool_KeyboardButton_lcontrol_892, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_lcontrol_892_comment},
  {"rcontrol", &Dtool_KeyboardButton_rcontrol_893, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_rcontrol_893_comment},
  {"lalt", &Dtool_KeyboardButton_lalt_894, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_lalt_894_comment},
  {"ralt", &Dtool_KeyboardButton_ralt_895, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_ralt_895_comment},
  {"lmeta", &Dtool_KeyboardButton_lmeta_896, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_lmeta_896_comment},
  {"rmeta", &Dtool_KeyboardButton_rmeta_897, METH_NOARGS | METH_STATIC, (const char *)Dtool_KeyboardButton_rmeta_897_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_KeyboardButton = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_KeyboardButton = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.KeyboardButton",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_KeyboardButton,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_KeyboardButton,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is just used as a convenient namespace for grouping all of these\n"
    " * handy functions that return buttons which map to standard keyboard keys.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_KeyboardButton,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_KeyboardButton,
    PyType_GenericAlloc,
    Dtool_new_KeyboardButton,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_KeyboardButton,
  Dtool_UpcastInterface_KeyboardButton,
  Dtool_DowncastInterface_KeyboardButton,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_KeyboardButton(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_KeyboardButton._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_KeyboardButton._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_KeyboardButton) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(KeyboardButton)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_KeyboardButton);
  }
}

/**
 * Python method tables for ModifierButtons (ModifierButtons)
 */
static PyMethodDef Dtool_Methods_ModifierButtons[] = {
  {"assign", &Dtool_ModifierButtons_operator_907, METH_O, (const char *)Dtool_ModifierButtons_operator_907_comment},
  {"set_button_list", &Dtool_ModifierButtons_set_button_list_915, METH_O, (const char *)Dtool_ModifierButtons_set_button_list_915_comment},
  {"setButtonList", &Dtool_ModifierButtons_set_button_list_915, METH_O, (const char *)Dtool_ModifierButtons_set_button_list_915_comment},
  {"matches", &Dtool_ModifierButtons_matches_916, METH_O, (const char *)Dtool_ModifierButtons_matches_916_comment},
  {"add_button", &Dtool_ModifierButtons_add_button_917, METH_O, (const char *)Dtool_ModifierButtons_add_button_917_comment},
  {"addButton", &Dtool_ModifierButtons_add_button_917, METH_O, (const char *)Dtool_ModifierButtons_add_button_917_comment},
  {"has_button", &Dtool_ModifierButtons_has_button_918, METH_O, (const char *)Dtool_ModifierButtons_has_button_918_comment},
  {"hasButton", &Dtool_ModifierButtons_has_button_918, METH_O, (const char *)Dtool_ModifierButtons_has_button_918_comment},
  {"remove_button", &Dtool_ModifierButtons_remove_button_919, METH_O, (const char *)Dtool_ModifierButtons_remove_button_919_comment},
  {"removeButton", &Dtool_ModifierButtons_remove_button_919, METH_O, (const char *)Dtool_ModifierButtons_remove_button_919_comment},
  {"get_num_buttons", &Dtool_ModifierButtons_get_num_buttons_920, METH_NOARGS, (const char *)Dtool_ModifierButtons_get_num_buttons_920_comment},
  {"getNumButtons", &Dtool_ModifierButtons_get_num_buttons_920, METH_NOARGS, (const char *)Dtool_ModifierButtons_get_num_buttons_920_comment},
  {"get_button", &Dtool_ModifierButtons_get_button_921, METH_O, (const char *)Dtool_ModifierButtons_get_button_921_comment},
  {"getButton", &Dtool_ModifierButtons_get_button_921, METH_O, (const char *)Dtool_ModifierButtons_get_button_921_comment},
  {"button_down", &Dtool_ModifierButtons_button_down_924, METH_O, (const char *)Dtool_ModifierButtons_button_down_924_comment},
  {"buttonDown", &Dtool_ModifierButtons_button_down_924, METH_O, (const char *)Dtool_ModifierButtons_button_down_924_comment},
  {"button_up", &Dtool_ModifierButtons_button_up_925, METH_O, (const char *)Dtool_ModifierButtons_button_up_925_comment},
  {"buttonUp", &Dtool_ModifierButtons_button_up_925, METH_O, (const char *)Dtool_ModifierButtons_button_up_925_comment},
  {"all_buttons_up", &Dtool_ModifierButtons_all_buttons_up_926, METH_NOARGS, (const char *)Dtool_ModifierButtons_all_buttons_up_926_comment},
  {"allButtonsUp", &Dtool_ModifierButtons_all_buttons_up_926, METH_NOARGS, (const char *)Dtool_ModifierButtons_all_buttons_up_926_comment},
  {"is_down", &Dtool_ModifierButtons_is_down_927, METH_O, (const char *)Dtool_ModifierButtons_is_down_927_comment},
  {"isDown", &Dtool_ModifierButtons_is_down_927, METH_O, (const char *)Dtool_ModifierButtons_is_down_927_comment},
  {"is_any_down", &Dtool_ModifierButtons_is_any_down_928, METH_NOARGS, (const char *)Dtool_ModifierButtons_is_any_down_928_comment},
  {"isAnyDown", &Dtool_ModifierButtons_is_any_down_928, METH_NOARGS, (const char *)Dtool_ModifierButtons_is_any_down_928_comment},
  {"get_prefix", &Dtool_ModifierButtons_get_prefix_929, METH_NOARGS, (const char *)Dtool_ModifierButtons_get_prefix_929_comment},
  {"getPrefix", &Dtool_ModifierButtons_get_prefix_929, METH_NOARGS, (const char *)Dtool_ModifierButtons_get_prefix_929_comment},
  {"output", &Dtool_ModifierButtons_output_930, METH_O, (const char *)Dtool_ModifierButtons_output_930_comment},
  {"write", &Dtool_ModifierButtons_write_931, METH_O, (const char *)Dtool_ModifierButtons_write_931_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_buttons", (PyCFunction) &MakeSeq_ModifierButtons_get_buttons, METH_NOARGS, nullptr},
  { "getButtons", (PyCFunction) &MakeSeq_ModifierButtons_get_buttons, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ModifierButtons slot nb_and -> operator &
//////////////////
static PyObject *Dtool_ModifierButtons_operator_911_nb_and(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_ModifierButtons, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline ModifierButtons ModifierButtons::operator &(ModifierButtons const &other) const
  ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "ModifierButtons.__and__", true, true);
  if (arg_this != nullptr) {
    ModifierButtons *return_value = new ModifierButtons(((*(const ModifierButtons*)local_this).operator &)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ModifierButtons, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ModifierButtons slot nb_inplace_and -> operator &=
//////////////////
static PyObject *Dtool_ModifierButtons_operator_913_nb_inplace_and(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_ModifierButtons, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-void ModifierButtons::operator &=(ModifierButtons const &other)
  ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "ModifierButtons.__iand__", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator &=)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ModifierButtons slot nb_inplace_or -> operator |=
//////////////////
static PyObject *Dtool_ModifierButtons_operator_914_nb_inplace_or(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_ModifierButtons, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-void ModifierButtons::operator |=(ModifierButtons const &other)
  ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "ModifierButtons.__ior__", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator |=)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// ModifierButtons slot nb_or -> operator |
//////////////////
static PyObject *Dtool_ModifierButtons_operator_912_nb_or(PyObject *self, PyObject *arg) {
  ModifierButtons *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_ModifierButtons, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline ModifierButtons ModifierButtons::operator |(ModifierButtons const &other) const
  ModifierButtons const *arg_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ModifierButtons, 1, "ModifierButtons.__or__", true, true);
  if (arg_this != nullptr) {
    ModifierButtons *return_value = new ModifierButtons(((*(const ModifierButtons*)local_this).operator |)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ModifierButtons, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
//  A __repr__ function
//     ModifierButtons
//////////////////
static PyObject *Dtool_Repr_ModifierButtons(PyObject *self) {
  ModifierButtons *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     ModifierButtons
//////////////////
static PyObject *Dtool_Str_ModifierButtons(PyObject *self) {
  ModifierButtons *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     ModifierButtons
//////////////////
static PyObject *Dtool_RichCompare_ModifierButtons(PyObject *self, PyObject *arg, int op) {
  ModifierButtons *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ModifierButtons, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool ModifierButtons::operator ==(ModifierButtons const &other) const
      ModifierButtons const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ModifierButtons);
      if (arg_this != nullptr) {
        bool return_value = ((*(const ModifierButtons*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool ModifierButtons::operator !=(ModifierButtons const &other) const
      ModifierButtons const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ModifierButtons);
      if (arg_this != nullptr) {
        bool return_value = ((*(const ModifierButtons*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool ModifierButtons::operator <(ModifierButtons const &other) const
      ModifierButtons const *arg_this = nullptr;
      DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_ModifierButtons);
      if (arg_this != nullptr) {
        bool return_value = ((*(const ModifierButtons*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyGetSetDef Dtool_Properties_ModifierButtons[] = {
  {(char *)"buttons", &Dtool_ModifierButtons_buttons_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ModifierButtons = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_ModifierButtons_operator_911_nb_and,
  nullptr,
  &Dtool_ModifierButtons_operator_912_nb_or,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_ModifierButtons_operator_913_nb_inplace_and,
  nullptr,
  &Dtool_ModifierButtons_operator_914_nb_inplace_or,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_ModifierButtons = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ModifierButtons",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ModifierButtons,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &DtoolInstance_ComparePointers,
#endif
    &Dtool_Repr_ModifierButtons,
    &Dtool_NumberMethods_ModifierButtons,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Str_ModifierButtons,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class monitors the state of a number of individual buttons and tracks\n"
    " * whether each button is known to be down or up.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_ModifierButtons,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ModifierButtons,
    nullptr, // tp_members
    Dtool_Properties_ModifierButtons,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ModifierButtons,
    PyType_GenericAlloc,
    Dtool_new_ModifierButtons,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ModifierButtons,
  Dtool_UpcastInterface_ModifierButtons,
  Dtool_DowncastInterface_ModifierButtons,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ModifierButtons(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_ModifierButtons._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ModifierButtons._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ModifierButtons) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ModifierButtons)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ModifierButtons);
  }
}

/**
 * Python method tables for MouseButton (MouseButton)
 */
static PyMethodDef Dtool_Methods_MouseButton[] = {
  {"button", &Dtool_MouseButton_button_933, METH_O | METH_STATIC, (const char *)Dtool_MouseButton_button_933_comment},
  {"one", &Dtool_MouseButton_one_934, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_one_934_comment},
  {"two", &Dtool_MouseButton_two_935, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_two_935_comment},
  {"three", &Dtool_MouseButton_three_936, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_three_936_comment},
  {"four", &Dtool_MouseButton_four_937, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_four_937_comment},
  {"five", &Dtool_MouseButton_five_938, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_five_938_comment},
  {"wheel_up", &Dtool_MouseButton_wheel_up_939, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_wheel_up_939_comment},
  {"wheelUp", &Dtool_MouseButton_wheel_up_939, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_wheel_up_939_comment},
  {"wheel_down", &Dtool_MouseButton_wheel_down_940, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_wheel_down_940_comment},
  {"wheelDown", &Dtool_MouseButton_wheel_down_940, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_wheel_down_940_comment},
  {"wheel_left", &Dtool_MouseButton_wheel_left_941, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_wheel_left_941_comment},
  {"wheelLeft", &Dtool_MouseButton_wheel_left_941, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_wheel_left_941_comment},
  {"wheel_right", &Dtool_MouseButton_wheel_right_942, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_wheel_right_942_comment},
  {"wheelRight", &Dtool_MouseButton_wheel_right_942, METH_NOARGS | METH_STATIC, (const char *)Dtool_MouseButton_wheel_right_942_comment},
  {"is_mouse_button", &Dtool_MouseButton_is_mouse_button_943, METH_O | METH_STATIC, (const char *)Dtool_MouseButton_is_mouse_button_943_comment},
  {"isMouseButton", &Dtool_MouseButton_is_mouse_button_943, METH_O | METH_STATIC, (const char *)Dtool_MouseButton_is_mouse_button_943_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_MouseButton = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_MouseButton = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.MouseButton",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_MouseButton,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_MouseButton,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class is just used as a convenient namespace for grouping all of these\n"
    " * handy functions that return buttons which map to standard mouse buttons.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_MouseButton,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_MouseButton,
    PyType_GenericAlloc,
    Dtool_new_MouseButton,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_MouseButton,
  Dtool_UpcastInterface_MouseButton,
  Dtool_DowncastInterface_MouseButton,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_MouseButton(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_MouseButton._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_MouseButton._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_MouseButton) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(MouseButton)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_MouseButton);
  }
}

/**
 * Python method tables for PointerData (PointerData)
 */
static PyMethodDef Dtool_Methods_PointerData[] = {
  {"get_x", &Dtool_PointerData_get_x_948, METH_NOARGS, (const char *)Dtool_PointerData_get_x_948_comment},
  {"getX", &Dtool_PointerData_get_x_948, METH_NOARGS, (const char *)Dtool_PointerData_get_x_948_comment},
  {"get_y", &Dtool_PointerData_get_y_949, METH_NOARGS, (const char *)Dtool_PointerData_get_y_949_comment},
  {"getY", &Dtool_PointerData_get_y_949, METH_NOARGS, (const char *)Dtool_PointerData_get_y_949_comment},
  {"get_in_window", &Dtool_PointerData_get_in_window_950, METH_NOARGS, (const char *)Dtool_PointerData_get_in_window_950_comment},
  {"getInWindow", &Dtool_PointerData_get_in_window_950, METH_NOARGS, (const char *)Dtool_PointerData_get_in_window_950_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_PointerData[] = {
  {(char *)"x", &Dtool_PointerData_x_Getter, nullptr, nullptr, nullptr},
  {(char *)"y", &Dtool_PointerData_y_Getter, nullptr, nullptr, nullptr},
  {(char *)"type", &Dtool_PointerData_type_Getter, nullptr, nullptr, nullptr},
  {(char *)"id", &Dtool_PointerData_id_Getter, nullptr, nullptr, nullptr},
  {(char *)"in_window", &Dtool_PointerData_in_window_Getter, nullptr, nullptr, nullptr},
  {(char *)"pressure", &Dtool_PointerData_pressure_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PointerData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_PointerData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.PointerData",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PointerData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PointerData,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Holds the data that might be generated by a 2-d pointer input device, such\n"
    " * as the mouse in the GraphicsWindow.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PointerData,
    nullptr, // tp_members
    Dtool_Properties_PointerData,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PointerData,
    PyType_GenericAlloc,
    Dtool_new_PointerData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PointerData,
  Dtool_UpcastInterface_PointerData,
  Dtool_DowncastInterface_PointerData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PointerData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PointerData._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PointerData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PointerData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PointerData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PointerData);
  }
}

/**
 * Python method tables for NodeCachedReferenceCount (NodeCachedReferenceCount)
 */
static PyMethodDef Dtool_Methods_NodeCachedReferenceCount[] = {
  {"get_node_ref_count", &Dtool_NodeCachedReferenceCount_get_node_ref_count_964, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_get_node_ref_count_964_comment},
  {"getNodeRefCount", &Dtool_NodeCachedReferenceCount_get_node_ref_count_964, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_get_node_ref_count_964_comment},
  {"node_ref", &Dtool_NodeCachedReferenceCount_node_ref_965, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_node_ref_965_comment},
  {"nodeRef", &Dtool_NodeCachedReferenceCount_node_ref_965, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_node_ref_965_comment},
  {"node_unref", &Dtool_NodeCachedReferenceCount_node_unref_966, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_node_unref_966_comment},
  {"nodeUnref", &Dtool_NodeCachedReferenceCount_node_unref_966, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_node_unref_966_comment},
  {"test_ref_count_integrity", &Dtool_NodeCachedReferenceCount_test_ref_count_integrity_967, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_test_ref_count_integrity_967_comment},
  {"testRefCountIntegrity", &Dtool_NodeCachedReferenceCount_test_ref_count_integrity_967, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_test_ref_count_integrity_967_comment},
  {"get_referenced_bits", &Dtool_NodeCachedReferenceCount_get_referenced_bits_969, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_get_referenced_bits_969_comment},
  {"getReferencedBits", &Dtool_NodeCachedReferenceCount_get_referenced_bits_969, METH_NOARGS, (const char *)Dtool_NodeCachedReferenceCount_get_referenced_bits_969_comment},
  {"get_class_type", &Dtool_NodeCachedReferenceCount_get_class_type_970, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodeCachedReferenceCount_get_class_type_970_comment},
  {"getClassType", &Dtool_NodeCachedReferenceCount_get_class_type_970, METH_NOARGS | METH_STATIC, (const char *)Dtool_NodeCachedReferenceCount_get_class_type_970_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_NodeCachedReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_NodeCachedReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_NodeCachedReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_NodeCachedReferenceCount = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_NodeCachedReferenceCount = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_NodeCachedReferenceCount = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.NodeCachedReferenceCount",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_NodeCachedReferenceCount,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_NodeCachedReferenceCount,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_NodeCachedReferenceCount,
    &Dtool_SequenceMethods_NodeCachedReferenceCount,
    &Dtool_MappingMethods_NodeCachedReferenceCount,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_NodeCachedReferenceCount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class further specializes CachedTypedWritableReferenceCount to also\n"
    " * add a node_ref_count, for the purposes of counting the number of times the\n"
    " * object is referenced by a \"node\", presumably a PandaNode.\n"
    " *\n"
    " * This essentially combines the functionality of NodeReferenceCount and\n"
    " * CachedTypedWritableReferenceCount, so that a derivative of this object\n"
    " * actually has three counters: the standard reference count, the \"cache\"\n"
    " * reference count, and the \"node\" reference count.  Rather than multiply\n"
    " * inheriting from the two reference count classes, we inherit only from\n"
    " * CachedTypedWritableReferenceCount and simply duplicate the functionality of\n"
    " * NodeReferenceCount, to avoid all of the problems associated with multiple\n"
    " * inheritance.\n"
    " *\n"
    " * The intended design is to use this as a base class for RenderState and\n"
    " * TransformState, both of which are held by PandaNodes, and also have caches\n"
    " * which are independently maintained.  By keeping track of how many nodes\n"
    " * hold a pointer to a particular object, we can classify each object into\n"
    " * node-referenced, cache-referenced, or other, which is primarily useful for\n"
    " * PStats reporting.\n"
    " *\n"
    " * As with CachedTypedWritableReferenceCount's cache_ref() and cache_unref(),\n"
    " * the new methods node_ref() and node_unref() automatically increment and\n"
    " * decrement the primary reference count as well.  In this case, however,\n"
    " * there does exist a NodePointerTo<> class to maintain the node_ref counters\n"
    " * automatically.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_NodeCachedReferenceCount,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_NodeCachedReferenceCount,
    PyType_GenericAlloc,
    Dtool_new_NodeCachedReferenceCount,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_NodeCachedReferenceCount,
  Dtool_UpcastInterface_NodeCachedReferenceCount,
  Dtool_DowncastInterface_NodeCachedReferenceCount,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_NodeCachedReferenceCount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_CachedTypedWritableReferenceCount(nullptr);
    Dtool_NodeCachedReferenceCount._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_CachedTypedWritableReferenceCount);
    Dtool_NodeCachedReferenceCount._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_NodeCachedReferenceCount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum NodeCachedReferenceCount::Referenced;
    PyDict_SetItemString(dict, "R_node", Dtool_WrapValue(NodeCachedReferenceCount::R_node));
    PyDict_SetItemString(dict, "RNode", Dtool_WrapValue(NodeCachedReferenceCount::R_node));
    PyDict_SetItemString(dict, "R_cache", Dtool_WrapValue(NodeCachedReferenceCount::R_cache));
    PyDict_SetItemString(dict, "RCache", Dtool_WrapValue(NodeCachedReferenceCount::R_cache));
    if (PyType_Ready((PyTypeObject *)&Dtool_NodeCachedReferenceCount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(NodeCachedReferenceCount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_NodeCachedReferenceCount);
  }
}

/**
 * Python method tables for SparseArray (SparseArray)
 */
static PyMethodDef Dtool_Methods_SparseArray[] = {
  {"all_on", &Dtool_SparseArray_all_on_973, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_all_on_973_comment},
  {"allOn", &Dtool_SparseArray_all_on_973, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_all_on_973_comment},
  {"all_off", &Dtool_SparseArray_all_off_974, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_all_off_974_comment},
  {"allOff", &Dtool_SparseArray_all_off_974, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_all_off_974_comment},
  {"lower_on", &Dtool_SparseArray_lower_on_975, METH_O | METH_STATIC, (const char *)Dtool_SparseArray_lower_on_975_comment},
  {"lowerOn", &Dtool_SparseArray_lower_on_975, METH_O | METH_STATIC, (const char *)Dtool_SparseArray_lower_on_975_comment},
  {"bit", &Dtool_SparseArray_bit_976, METH_O | METH_STATIC, (const char *)Dtool_SparseArray_bit_976_comment},
  {"range", (PyCFunction) &Dtool_SparseArray_range_977, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_SparseArray_range_977_comment},
  {"has_max_num_bits", &Dtool_SparseArray_has_max_num_bits_978, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_has_max_num_bits_978_comment},
  {"hasMaxNumBits", &Dtool_SparseArray_has_max_num_bits_978, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_has_max_num_bits_978_comment},
  {"get_max_num_bits", &Dtool_SparseArray_get_max_num_bits_979, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_get_max_num_bits_979_comment},
  {"getMaxNumBits", &Dtool_SparseArray_get_max_num_bits_979, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_get_max_num_bits_979_comment},
  {"get_num_bits", &Dtool_SparseArray_get_num_bits_980, METH_NOARGS, (const char *)Dtool_SparseArray_get_num_bits_980_comment},
  {"getNumBits", &Dtool_SparseArray_get_num_bits_980, METH_NOARGS, (const char *)Dtool_SparseArray_get_num_bits_980_comment},
  {"get_bit", &Dtool_SparseArray_get_bit_981, METH_O, (const char *)Dtool_SparseArray_get_bit_981_comment},
  {"getBit", &Dtool_SparseArray_get_bit_981, METH_O, (const char *)Dtool_SparseArray_get_bit_981_comment},
  {"set_bit", &Dtool_SparseArray_set_bit_982, METH_O, (const char *)Dtool_SparseArray_set_bit_982_comment},
  {"setBit", &Dtool_SparseArray_set_bit_982, METH_O, (const char *)Dtool_SparseArray_set_bit_982_comment},
  {"clear_bit", &Dtool_SparseArray_clear_bit_983, METH_O, (const char *)Dtool_SparseArray_clear_bit_983_comment},
  {"clearBit", &Dtool_SparseArray_clear_bit_983, METH_O, (const char *)Dtool_SparseArray_clear_bit_983_comment},
  {"set_bit_to", (PyCFunction) &Dtool_SparseArray_set_bit_to_984, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_set_bit_to_984_comment},
  {"setBitTo", (PyCFunction) &Dtool_SparseArray_set_bit_to_984, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_set_bit_to_984_comment},
  {"get_highest_bits", &Dtool_SparseArray_get_highest_bits_985, METH_NOARGS, (const char *)Dtool_SparseArray_get_highest_bits_985_comment},
  {"getHighestBits", &Dtool_SparseArray_get_highest_bits_985, METH_NOARGS, (const char *)Dtool_SparseArray_get_highest_bits_985_comment},
  {"is_zero", &Dtool_SparseArray_is_zero_986, METH_NOARGS, (const char *)Dtool_SparseArray_is_zero_986_comment},
  {"isZero", &Dtool_SparseArray_is_zero_986, METH_NOARGS, (const char *)Dtool_SparseArray_is_zero_986_comment},
  {"is_all_on", &Dtool_SparseArray_is_all_on_987, METH_NOARGS, (const char *)Dtool_SparseArray_is_all_on_987_comment},
  {"isAllOn", &Dtool_SparseArray_is_all_on_987, METH_NOARGS, (const char *)Dtool_SparseArray_is_all_on_987_comment},
  {"has_any_of", (PyCFunction) &Dtool_SparseArray_has_any_of_988, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_has_any_of_988_comment},
  {"hasAnyOf", (PyCFunction) &Dtool_SparseArray_has_any_of_988, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_has_any_of_988_comment},
  {"has_all_of", (PyCFunction) &Dtool_SparseArray_has_all_of_989, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_has_all_of_989_comment},
  {"hasAllOf", (PyCFunction) &Dtool_SparseArray_has_all_of_989, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_has_all_of_989_comment},
  {"set_range", (PyCFunction) &Dtool_SparseArray_set_range_990, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_set_range_990_comment},
  {"setRange", (PyCFunction) &Dtool_SparseArray_set_range_990, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_set_range_990_comment},
  {"clear_range", (PyCFunction) &Dtool_SparseArray_clear_range_991, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_clear_range_991_comment},
  {"clearRange", (PyCFunction) &Dtool_SparseArray_clear_range_991, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_clear_range_991_comment},
  {"set_range_to", (PyCFunction) &Dtool_SparseArray_set_range_to_992, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_set_range_to_992_comment},
  {"setRangeTo", (PyCFunction) &Dtool_SparseArray_set_range_to_992, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_SparseArray_set_range_to_992_comment},
  {"get_num_on_bits", &Dtool_SparseArray_get_num_on_bits_993, METH_NOARGS, (const char *)Dtool_SparseArray_get_num_on_bits_993_comment},
  {"getNumOnBits", &Dtool_SparseArray_get_num_on_bits_993, METH_NOARGS, (const char *)Dtool_SparseArray_get_num_on_bits_993_comment},
  {"get_num_off_bits", &Dtool_SparseArray_get_num_off_bits_994, METH_NOARGS, (const char *)Dtool_SparseArray_get_num_off_bits_994_comment},
  {"getNumOffBits", &Dtool_SparseArray_get_num_off_bits_994, METH_NOARGS, (const char *)Dtool_SparseArray_get_num_off_bits_994_comment},
  {"get_lowest_on_bit", &Dtool_SparseArray_get_lowest_on_bit_995, METH_NOARGS, (const char *)Dtool_SparseArray_get_lowest_on_bit_995_comment},
  {"getLowestOnBit", &Dtool_SparseArray_get_lowest_on_bit_995, METH_NOARGS, (const char *)Dtool_SparseArray_get_lowest_on_bit_995_comment},
  {"get_lowest_off_bit", &Dtool_SparseArray_get_lowest_off_bit_996, METH_NOARGS, (const char *)Dtool_SparseArray_get_lowest_off_bit_996_comment},
  {"getLowestOffBit", &Dtool_SparseArray_get_lowest_off_bit_996, METH_NOARGS, (const char *)Dtool_SparseArray_get_lowest_off_bit_996_comment},
  {"get_highest_on_bit", &Dtool_SparseArray_get_highest_on_bit_997, METH_NOARGS, (const char *)Dtool_SparseArray_get_highest_on_bit_997_comment},
  {"getHighestOnBit", &Dtool_SparseArray_get_highest_on_bit_997, METH_NOARGS, (const char *)Dtool_SparseArray_get_highest_on_bit_997_comment},
  {"get_highest_off_bit", &Dtool_SparseArray_get_highest_off_bit_998, METH_NOARGS, (const char *)Dtool_SparseArray_get_highest_off_bit_998_comment},
  {"getHighestOffBit", &Dtool_SparseArray_get_highest_off_bit_998, METH_NOARGS, (const char *)Dtool_SparseArray_get_highest_off_bit_998_comment},
  {"get_next_higher_different_bit", &Dtool_SparseArray_get_next_higher_different_bit_999, METH_O, (const char *)Dtool_SparseArray_get_next_higher_different_bit_999_comment},
  {"getNextHigherDifferentBit", &Dtool_SparseArray_get_next_higher_different_bit_999, METH_O, (const char *)Dtool_SparseArray_get_next_higher_different_bit_999_comment},
  {"invert_in_place", &Dtool_SparseArray_invert_in_place_1000, METH_NOARGS, (const char *)Dtool_SparseArray_invert_in_place_1000_comment},
  {"invertInPlace", &Dtool_SparseArray_invert_in_place_1000, METH_NOARGS, (const char *)Dtool_SparseArray_invert_in_place_1000_comment},
  {"has_bits_in_common", &Dtool_SparseArray_has_bits_in_common_1001, METH_O, (const char *)Dtool_SparseArray_has_bits_in_common_1001_comment},
  {"hasBitsInCommon", &Dtool_SparseArray_has_bits_in_common_1001, METH_O, (const char *)Dtool_SparseArray_has_bits_in_common_1001_comment},
  {"clear", &Dtool_SparseArray_clear_1002, METH_NOARGS, (const char *)Dtool_SparseArray_clear_1002_comment},
  {"output", &Dtool_SparseArray_output_1003, METH_O, (const char *)Dtool_SparseArray_output_1003_comment},
  {"compare_to", &Dtool_SparseArray_compare_to_1007, METH_O, (const char *)Dtool_SparseArray_compare_to_1007_comment},
  {"compareTo", &Dtool_SparseArray_compare_to_1007, METH_O, (const char *)Dtool_SparseArray_compare_to_1007_comment},
  {"is_inverse", &Dtool_SparseArray_is_inverse_1019, METH_NOARGS, (const char *)Dtool_SparseArray_is_inverse_1019_comment},
  {"isInverse", &Dtool_SparseArray_is_inverse_1019, METH_NOARGS, (const char *)Dtool_SparseArray_is_inverse_1019_comment},
  {"get_num_subranges", &Dtool_SparseArray_get_num_subranges_1020, METH_NOARGS, (const char *)Dtool_SparseArray_get_num_subranges_1020_comment},
  {"getNumSubranges", &Dtool_SparseArray_get_num_subranges_1020, METH_NOARGS, (const char *)Dtool_SparseArray_get_num_subranges_1020_comment},
  {"get_subrange_begin", &Dtool_SparseArray_get_subrange_begin_1021, METH_O, (const char *)Dtool_SparseArray_get_subrange_begin_1021_comment},
  {"getSubrangeBegin", &Dtool_SparseArray_get_subrange_begin_1021, METH_O, (const char *)Dtool_SparseArray_get_subrange_begin_1021_comment},
  {"get_subrange_end", &Dtool_SparseArray_get_subrange_end_1022, METH_O, (const char *)Dtool_SparseArray_get_subrange_end_1022_comment},
  {"getSubrangeEnd", &Dtool_SparseArray_get_subrange_end_1022, METH_O, (const char *)Dtool_SparseArray_get_subrange_end_1022_comment},
  {"get_class_type", &Dtool_SparseArray_get_class_type_1023, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_get_class_type_1023_comment},
  {"getClassType", &Dtool_SparseArray_get_class_type_1023, METH_NOARGS | METH_STATIC, (const char *)Dtool_SparseArray_get_class_type_1023_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_and -> operator &
//////////////////
static PyObject *Dtool_SparseArray_operator_1008_nb_and(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline SparseArray SparseArray::operator &(SparseArray const &other) const
  SparseArray arg_local;
  SparseArray const *arg_this = Dtool_Coerce_SparseArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.__and__", "SparseArray");
  }
  SparseArray *return_value = new SparseArray(((*(const SparseArray*)local_this).operator &)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_inplace_and -> operator &=
//////////////////
static PyObject *Dtool_SparseArray_operator_1014_nb_inplace_and(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-void SparseArray::operator &=(SparseArray const &other)
  SparseArray arg_local;
  SparseArray const *arg_this = Dtool_Coerce_SparseArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.__iand__", "SparseArray");
    return nullptr;
  }
  ((*local_this).operator &=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_inplace_lshift -> operator <<=
//////////////////
static PyObject *Dtool_SparseArray_operator_1017_nb_inplace_lshift(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void SparseArray::operator <<=(int shift)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return nullptr;
    }
#endif
    ((*local_this).operator <<=)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_inplace_or -> operator |=
//////////////////
static PyObject *Dtool_SparseArray_operator_1015_nb_inplace_or(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-void SparseArray::operator |=(SparseArray const &other)
  SparseArray arg_local;
  SparseArray const *arg_this = Dtool_Coerce_SparseArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.__ior__", "SparseArray");
    return nullptr;
  }
  ((*local_this).operator |=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_inplace_rshift -> operator >>=
//////////////////
static PyObject *Dtool_SparseArray_operator_1018_nb_inplace_rshift(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void SparseArray::operator >>=(int shift)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      PyErr_Format(PyExc_OverflowError,
                   "value %ld out of range for signed integer",
                   arg_val);
      return nullptr;
    }
#endif
    ((*local_this).operator >>=)((int)arg_val);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_inplace_xor -> operator ^=
//////////////////
static PyObject *Dtool_SparseArray_operator_1016_nb_inplace_xor(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-void SparseArray::operator ^=(SparseArray const &other)
  SparseArray arg_local;
  SparseArray const *arg_this = Dtool_Coerce_SparseArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.__ixor__", "SparseArray");
    return nullptr;
  }
  ((*local_this).operator ^=)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  Py_INCREF(self);
  return self;
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_invert -> operator ~
//////////////////
static PyObject *Dtool_SparseArray_operator_1011_nb_invert(PyObject *self) {
  SparseArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline SparseArray SparseArray::operator ~(void) const
  SparseArray *return_value = new SparseArray(((*(const SparseArray*)local_this).operator ~)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__invert__(SparseArray self)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_lshift -> operator <<
//////////////////
static PyObject *Dtool_SparseArray_operator_1012_nb_lshift(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline SparseArray SparseArray::operator <<(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    SparseArray *return_value = new SparseArray(((*(const SparseArray*)local_this).operator <<)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_or -> operator |
//////////////////
static PyObject *Dtool_SparseArray_operator_1009_nb_or(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline SparseArray SparseArray::operator |(SparseArray const &other) const
  SparseArray arg_local;
  SparseArray const *arg_this = Dtool_Coerce_SparseArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.__or__", "SparseArray");
  }
  SparseArray *return_value = new SparseArray(((*(const SparseArray*)local_this).operator |)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_rshift -> operator >>
//////////////////
static PyObject *Dtool_SparseArray_operator_1013_nb_rshift(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline SparseArray SparseArray::operator >>(int shift) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    SparseArray *return_value = new SparseArray(((*(const SparseArray*)local_this).operator >>)((int)arg_val));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot nb_xor -> operator ^
//////////////////
static PyObject *Dtool_SparseArray_operator_1010_nb_xor(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_SparseArray, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline SparseArray SparseArray::operator ^(SparseArray const &other) const
  SparseArray arg_local;
  SparseArray const *arg_this = Dtool_Coerce_SparseArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.__xor__", "SparseArray");
  }
  SparseArray *return_value = new SparseArray(((*(const SparseArray*)local_this).operator ^)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_SparseArray, true, false);
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// SparseArray slot tp_compare -> compare_to
//////////////////
static int Dtool_SparseArray_compare_to_1007_tp_compare(PyObject *self, PyObject *arg) {
  SparseArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return -1;
  }

  // 1-int SparseArray::compare_to(SparseArray const &other) const
  SparseArray arg_local;
  SparseArray const *arg_this = Dtool_Coerce_SparseArray(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "SparseArray.compare_to", "SparseArray");
    return -1;
  }
  int return_value = ((*(const SparseArray*)local_this).compare_to)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return (int)(return_value > 0) - (int)(return_value < 0);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "compare_to(SparseArray self, const SparseArray other)\n");
  }
  return -1;
}

//////////////////
//  A __repr__ function
//     SparseArray
//////////////////
static PyObject *Dtool_Repr_SparseArray(PyObject *self) {
  SparseArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A rich comparison function
//     SparseArray
//////////////////
static PyObject *Dtool_RichCompare_SparseArray(PyObject *self, PyObject *arg, int op) {
  SparseArray *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_SparseArray, (void **)&local_this)) {
    return nullptr;
  }

  switch (op) {
  case Py_EQ:
    {
      // 1-inline bool SparseArray::operator ==(SparseArray const &other) const
      SparseArray arg_local;
      SparseArray const *arg_this = Dtool_Coerce_SparseArray(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const SparseArray*)local_this).operator ==)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_NE:
    {
      // 1-inline bool SparseArray::operator !=(SparseArray const &other) const
      SparseArray arg_local;
      SparseArray const *arg_this = Dtool_Coerce_SparseArray(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const SparseArray*)local_this).operator !=)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  case Py_LT:
    {
      // 1-inline bool SparseArray::operator <(SparseArray const &other) const
      SparseArray arg_local;
      SparseArray const *arg_this = Dtool_Coerce_SparseArray(arg, arg_local);
      if ((arg_this != nullptr)) {
        bool return_value = ((*(const SparseArray*)local_this).operator <)(*arg_this);
#ifndef NDEBUG
        Notify *notify = Notify::ptr();
        if (UNLIKELY(notify->has_assert_failed())) {
          return Dtool_Raise_AssertionError();
        }
#endif
        return Dtool_WrapValue(return_value);
      }
      break;
    }
  }

  if (_PyErr_OCCURRED()) {
    PyErr_Clear();
  }

  // All is not lost; we still have the compare_to function to fall back onto.
  int cmpval = Dtool_SparseArray_compare_to_1007_tp_compare(self, arg);
  if (cmpval == -1 && _PyErr_OCCURRED()) {
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
      PyErr_Clear();
    } else {
      return nullptr;
    }
  }
  switch (op) {
  case Py_LT:
    return PyBool_FromLong(cmpval < 0);
  case Py_LE:
    return PyBool_FromLong(cmpval <= 0);
  case Py_EQ:
    return PyBool_FromLong(cmpval == 0);
  case Py_NE:
    return PyBool_FromLong(cmpval != 0);
  case Py_GT:
    return PyBool_FromLong(cmpval > 0);
  case Py_GE:
    return PyBool_FromLong(cmpval >= 0);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

static PyNumberMethods Dtool_NumberMethods_SparseArray = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  &Dtool_SparseArray_operator_1011_nb_invert,
  &Dtool_SparseArray_operator_1012_nb_lshift,
  &Dtool_SparseArray_operator_1013_nb_rshift,
  &Dtool_SparseArray_operator_1008_nb_and,
  &Dtool_SparseArray_operator_1010_nb_xor,
  &Dtool_SparseArray_operator_1009_nb_or,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  &Dtool_SparseArray_operator_1017_nb_inplace_lshift,
  &Dtool_SparseArray_operator_1018_nb_inplace_rshift,
  &Dtool_SparseArray_operator_1014_nb_inplace_and,
  &Dtool_SparseArray_operator_1016_nb_inplace_xor,
  &Dtool_SparseArray_operator_1015_nb_inplace_or,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_SparseArray = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.SparseArray",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_SparseArray,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    &Dtool_SparseArray_compare_to_1007_tp_compare,
#endif
    &Dtool_Repr_SparseArray,
    &Dtool_NumberMethods_SparseArray,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    &DtoolInstance_HashPointer,
    nullptr,
    &Dtool_Repr_SparseArray,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This class records a set of integers, where each integer is either present\n"
    " * or not present in the set.\n"
    " *\n"
    " * It is similar in principle and in interface to a BitArray (which can be\n"
    " * thought of as a set of integers, one integer corresponding to each\n"
    " * different bit position), but the SparseArray is implemented as a list of\n"
    " * min/max subrange lists, rather than as a bitmask.\n"
    " *\n"
    " * This makes it particularly efficient for storing sets which consist of\n"
    " * large sections of consecutively included or consecutively excluded\n"
    " * elements, with arbitrarily large integers, but particularly inefficient for\n"
    " * doing boolean operations such as & or |.\n"
    " *\n"
    " * Also, unlike BitArray, the SparseArray can store negative integers.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    &Dtool_RichCompare_SparseArray,
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_SparseArray,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_SparseArray,
    PyType_GenericAlloc,
    Dtool_new_SparseArray,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_SparseArray,
  Dtool_UpcastInterface_SparseArray,
  Dtool_DowncastInterface_SparseArray,
  nullptr,
  (CoerceFunction)Dtool_Coerce_SparseArray,
};

static void Dtool_PyModuleClassInit_SparseArray(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_SparseArray._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_SparseArray._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_SparseArray) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(SparseArray)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_SparseArray);
  }
}

/**
 * Python method tables for ParamValueBase (ParamValueBase)
 */
static PyMethodDef Dtool_Methods_ParamValueBase[] = {
  {"get_value_type", &Dtool_ParamValueBase_get_value_type_1026, METH_NOARGS, (const char *)Dtool_ParamValueBase_get_value_type_1026_comment},
  {"getValueType", &Dtool_ParamValueBase_get_value_type_1026, METH_NOARGS, (const char *)Dtool_ParamValueBase_get_value_type_1026_comment},
  {"output", &Dtool_ParamValueBase_output_1027, METH_O, (const char *)Dtool_ParamValueBase_output_1027_comment},
  {"get_class_type", &Dtool_ParamValueBase_get_class_type_1028, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValueBase_get_class_type_1028_comment},
  {"getClassType", &Dtool_ParamValueBase_get_class_type_1028, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValueBase_get_class_type_1028_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     ParamValueBase
//////////////////
static PyObject *Dtool_Repr_ParamValueBase(PyObject *self) {
  ParamValueBase *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ParamValueBase, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_ParamValueBase = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValueBase = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamValueBase = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamValueBase = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamValueBase = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamValueBase = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamValueBase",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValueBase,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamValueBase,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_ParamValueBase,
    &Dtool_NumberMethods_ParamValueBase,
    &Dtool_SequenceMethods_ParamValueBase,
    &Dtool_MappingMethods_ParamValueBase,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Repr_ParamValueBase,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamValueBase,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A non-template base class of ParamValue (below), which serves mainly to\n"
    " * define the placeholder for the virtual output function.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamValueBase,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamValueBase,
    PyType_GenericAlloc,
    Dtool_new_ParamValueBase,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValueBase,
  Dtool_UpcastInterface_ParamValueBase,
  Dtool_DowncastInterface_ParamValueBase,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ParamValueBase(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedWritableReferenceCount(nullptr);
    Dtool_ParamValueBase._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TypedWritableReferenceCount);
    Dtool_ParamValueBase._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamValueBase._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValueBase) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValueBase)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValueBase);
  }
}

/**
 * Python method tables for ParamTypedRefCount (ParamTypedRefCount)
 */
static PyMethodDef Dtool_Methods_ParamTypedRefCount[] = {
  {"get_value", &Dtool_ParamTypedRefCount_get_value_1031, METH_NOARGS, (const char *)Dtool_ParamTypedRefCount_get_value_1031_comment},
  {"getValue", &Dtool_ParamTypedRefCount_get_value_1031, METH_NOARGS, (const char *)Dtool_ParamTypedRefCount_get_value_1031_comment},
  {"get_class_type", &Dtool_ParamTypedRefCount_get_class_type_1034, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamTypedRefCount_get_class_type_1034_comment},
  {"getClassType", &Dtool_ParamTypedRefCount_get_class_type_1034, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamTypedRefCount_get_class_type_1034_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamTypedRefCount[] = {
  {(char *)"value", &Dtool_ParamTypedRefCount_value_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamTypedRefCount = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamTypedRefCount = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamTypedRefCount = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamTypedRefCount = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamTypedRefCount = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamTypedRefCount = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamTypedRefCount",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamTypedRefCount,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamTypedRefCount,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamTypedRefCount,
    &Dtool_SequenceMethods_ParamTypedRefCount,
    &Dtool_MappingMethods_ParamTypedRefCount,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamTypedRefCount,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A class object for storing specifically objects of type\n"
    " * TypedReferenceCount, which is different than TypedWritableReferenceCount.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamTypedRefCount,
    nullptr, // tp_members
    Dtool_Properties_ParamTypedRefCount,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamTypedRefCount,
    PyType_GenericAlloc,
    Dtool_new_ParamTypedRefCount,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamTypedRefCount,
  Dtool_UpcastInterface_ParamTypedRefCount,
  Dtool_DowncastInterface_ParamTypedRefCount,
  (CoerceFunction)Dtool_ConstCoerce_ParamTypedRefCount,
  (CoerceFunction)Dtool_Coerce_ParamTypedRefCount,
};

static void Dtool_PyModuleClassInit_ParamTypedRefCount(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(nullptr);
    Dtool_ParamTypedRefCount._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    Dtool_ParamTypedRefCount._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamTypedRefCount._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamTypedRefCount) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamTypedRefCount)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamTypedRefCount);
  }
}

/**
 * Python method tables for ParamValue_std_string (ParamValue_string)
 */
static PyMethodDef Dtool_Methods_ParamValue_std_string[] = {
  {"set_value", &Dtool_ParamValue_string_set_value_1037, METH_O, (const char *)Dtool_ParamValue_string_set_value_1037_comment},
  {"setValue", &Dtool_ParamValue_string_set_value_1037, METH_O, (const char *)Dtool_ParamValue_string_set_value_1037_comment},
  {"get_value", &Dtool_ParamValue_string_get_value_1038, METH_NOARGS, (const char *)Dtool_ParamValue_string_get_value_1038_comment},
  {"getValue", &Dtool_ParamValue_string_get_value_1038, METH_NOARGS, (const char *)Dtool_ParamValue_string_get_value_1038_comment},
  {"get_class_type", &Dtool_ParamValue_string_get_class_type_1042, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_string_get_class_type_1042_comment},
  {"getClassType", &Dtool_ParamValue_string_get_class_type_1042, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_string_get_class_type_1042_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamValue_std_string[] = {
  {(char *)"value", &Dtool_ParamValue_std_string_value_Getter, &Dtool_ParamValue_std_string_value_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_std_string = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_std_string = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_std_string = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_std_string = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamValue_std_string = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamValue_std_string = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamValue_string",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_std_string,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamValue_std_string,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamValue_std_string,
    &Dtool_SequenceMethods_ParamValue_std_string,
    &Dtool_MappingMethods_ParamValue_std_string,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamValue_std_string,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamValue_std_string,
    nullptr, // tp_members
    Dtool_Properties_ParamValue_std_string,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamValue_std_string,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_std_string,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_std_string,
  Dtool_UpcastInterface_ParamValue_std_string,
  Dtool_DowncastInterface_ParamValue_std_string,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_std_string,
  (CoerceFunction)Dtool_Coerce_ParamValue_std_string,
};

static void Dtool_PyModuleClassInit_ParamValue_std_string(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(nullptr);
    Dtool_ParamValue_std_string._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    Dtool_ParamValue_std_string._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_std_string._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_std_string) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_std_string)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_std_string);
  }
}

/**
 * Python method tables for ParamValue_std_wstring (ParamValue_wstring)
 */
static PyMethodDef Dtool_Methods_ParamValue_std_wstring[] = {
  {"set_value", &Dtool_ParamValue_wstring_set_value_1046, METH_O, (const char *)Dtool_ParamValue_wstring_set_value_1046_comment},
  {"setValue", &Dtool_ParamValue_wstring_set_value_1046, METH_O, (const char *)Dtool_ParamValue_wstring_set_value_1046_comment},
  {"get_value", &Dtool_ParamValue_wstring_get_value_1047, METH_NOARGS, (const char *)Dtool_ParamValue_wstring_get_value_1047_comment},
  {"getValue", &Dtool_ParamValue_wstring_get_value_1047, METH_NOARGS, (const char *)Dtool_ParamValue_wstring_get_value_1047_comment},
  {"get_class_type", &Dtool_ParamValue_wstring_get_class_type_1049, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_wstring_get_class_type_1049_comment},
  {"getClassType", &Dtool_ParamValue_wstring_get_class_type_1049, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_wstring_get_class_type_1049_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamValue_std_wstring[] = {
  {(char *)"value", &Dtool_ParamValue_std_wstring_value_Getter, &Dtool_ParamValue_std_wstring_value_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_std_wstring = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_std_wstring = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_std_wstring = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_std_wstring = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamValue_std_wstring = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamValue_std_wstring = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamValue_wstring",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_std_wstring,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamValue_std_wstring,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamValue_std_wstring,
    &Dtool_SequenceMethods_ParamValue_std_wstring,
    &Dtool_MappingMethods_ParamValue_std_wstring,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamValue_std_wstring,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamValue_std_wstring,
    nullptr, // tp_members
    Dtool_Properties_ParamValue_std_wstring,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamValue_std_wstring,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_std_wstring,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_std_wstring,
  Dtool_UpcastInterface_ParamValue_std_wstring,
  Dtool_DowncastInterface_ParamValue_std_wstring,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_std_wstring,
  (CoerceFunction)Dtool_Coerce_ParamValue_std_wstring,
};

static void Dtool_PyModuleClassInit_ParamValue_std_wstring(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(nullptr);
    Dtool_ParamValue_std_wstring._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    Dtool_ParamValue_std_wstring._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_std_wstring._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_std_wstring) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_std_wstring)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_std_wstring);
  }
}

/**
 * Python method tables for ParamValue_LVecBase2d (ParamValue_LVecBase2d)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase2d[] = {
  {"set_value", &Dtool_ParamValue_LVecBase2d_set_value_1053, METH_O, (const char *)Dtool_ParamValue_LVecBase2d_set_value_1053_comment},
  {"setValue", &Dtool_ParamValue_LVecBase2d_set_value_1053, METH_O, (const char *)Dtool_ParamValue_LVecBase2d_set_value_1053_comment},
  {"get_value", &Dtool_ParamValue_LVecBase2d_get_value_1054, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase2d_get_value_1054_comment},
  {"getValue", &Dtool_ParamValue_LVecBase2d_get_value_1054, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase2d_get_value_1054_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase2d_get_class_type_1056, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase2d_get_class_type_1056_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase2d_get_class_type_1056, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase2d_get_class_type_1056_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase2d[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase2d_value_Getter, &Dtool_ParamValue_LVecBase2d_value_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase2d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamValue_LVecBase2d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase2d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamValue_LVecBase2d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase2d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamValue_LVecBase2d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamValue_LVecBase2d,
    &Dtool_SequenceMethods_ParamValue_LVecBase2d,
    &Dtool_MappingMethods_ParamValue_LVecBase2d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamValue_LVecBase2d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamValue_LVecBase2d,
    nullptr, // tp_members
    Dtool_Properties_ParamValue_LVecBase2d,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase2d,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase2d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase2d,
  Dtool_UpcastInterface_ParamValue_LVecBase2d,
  Dtool_DowncastInterface_ParamValue_LVecBase2d,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase2d,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase2d,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase2d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(nullptr);
    Dtool_ParamValue_LVecBase2d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    Dtool_ParamValue_LVecBase2d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase2d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase2d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase2d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase2d);
  }
}

/**
 * Python method tables for ParamValue_LVecBase2f (ParamValue_LVecBase2f)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase2f[] = {
  {"set_value", &Dtool_ParamValue_LVecBase2f_set_value_1060, METH_O, (const char *)Dtool_ParamValue_LVecBase2f_set_value_1060_comment},
  {"setValue", &Dtool_ParamValue_LVecBase2f_set_value_1060, METH_O, (const char *)Dtool_ParamValue_LVecBase2f_set_value_1060_comment},
  {"get_value", &Dtool_ParamValue_LVecBase2f_get_value_1061, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase2f_get_value_1061_comment},
  {"getValue", &Dtool_ParamValue_LVecBase2f_get_value_1061, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase2f_get_value_1061_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase2f_get_class_type_1063, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase2f_get_class_type_1063_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase2f_get_class_type_1063, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase2f_get_class_type_1063_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase2f[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase2f_value_Getter, &Dtool_ParamValue_LVecBase2f_value_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase2f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamValue_LVecBase2f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase2f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamValue_LVecBase2f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase2f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamValue_LVecBase2f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamValue_LVecBase2f,
    &Dtool_SequenceMethods_ParamValue_LVecBase2f,
    &Dtool_MappingMethods_ParamValue_LVecBase2f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamValue_LVecBase2f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamValue_LVecBase2f,
    nullptr, // tp_members
    Dtool_Properties_ParamValue_LVecBase2f,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase2f,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase2f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase2f,
  Dtool_UpcastInterface_ParamValue_LVecBase2f,
  Dtool_DowncastInterface_ParamValue_LVecBase2f,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase2f,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase2f,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase2f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(nullptr);
    Dtool_ParamValue_LVecBase2f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    Dtool_ParamValue_LVecBase2f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase2f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase2f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase2f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase2f);
  }
}

/**
 * Python method tables for ParamValue_LVecBase2i (ParamValue_LVecBase2i)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase2i[] = {
  {"set_value", &Dtool_ParamValue_LVecBase2i_set_value_1067, METH_O, (const char *)Dtool_ParamValue_LVecBase2i_set_value_1067_comment},
  {"setValue", &Dtool_ParamValue_LVecBase2i_set_value_1067, METH_O, (const char *)Dtool_ParamValue_LVecBase2i_set_value_1067_comment},
  {"get_value", &Dtool_ParamValue_LVecBase2i_get_value_1068, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase2i_get_value_1068_comment},
  {"getValue", &Dtool_ParamValue_LVecBase2i_get_value_1068, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase2i_get_value_1068_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase2i_get_class_type_1070, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase2i_get_class_type_1070_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase2i_get_class_type_1070, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase2i_get_class_type_1070_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase2i[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase2i_value_Getter, &Dtool_ParamValue_LVecBase2i_value_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase2i = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamValue_LVecBase2i = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase2i = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamValue_LVecBase2i",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase2i,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamValue_LVecBase2i,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamValue_LVecBase2i,
    &Dtool_SequenceMethods_ParamValue_LVecBase2i,
    &Dtool_MappingMethods_ParamValue_LVecBase2i,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamValue_LVecBase2i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamValue_LVecBase2i,
    nullptr, // tp_members
    Dtool_Properties_ParamValue_LVecBase2i,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase2i,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase2i,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase2i,
  Dtool_UpcastInterface_ParamValue_LVecBase2i,
  Dtool_DowncastInterface_ParamValue_LVecBase2i,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase2i,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase2i,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase2i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(nullptr);
    Dtool_ParamValue_LVecBase2i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    Dtool_ParamValue_LVecBase2i._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase2i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase2i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase2i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase2i);
  }
}

/**
 * Python method tables for ParamValue_LVecBase3d (ParamValue_LVecBase3d)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase3d[] = {
  {"set_value", &Dtool_ParamValue_LVecBase3d_set_value_1074, METH_O, (const char *)Dtool_ParamValue_LVecBase3d_set_value_1074_comment},
  {"setValue", &Dtool_ParamValue_LVecBase3d_set_value_1074, METH_O, (const char *)Dtool_ParamValue_LVecBase3d_set_value_1074_comment},
  {"get_value", &Dtool_ParamValue_LVecBase3d_get_value_1075, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase3d_get_value_1075_comment},
  {"getValue", &Dtool_ParamValue_LVecBase3d_get_value_1075, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase3d_get_value_1075_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase3d_get_class_type_1077, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase3d_get_class_type_1077_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase3d_get_class_type_1077, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase3d_get_class_type_1077_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase3d[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase3d_value_Getter, &Dtool_ParamValue_LVecBase3d_value_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase3d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamValue_LVecBase3d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase3d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamValue_LVecBase3d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase3d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamValue_LVecBase3d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamValue_LVecBase3d,
    &Dtool_SequenceMethods_ParamValue_LVecBase3d,
    &Dtool_MappingMethods_ParamValue_LVecBase3d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamValue_LVecBase3d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamValue_LVecBase3d,
    nullptr, // tp_members
    Dtool_Properties_ParamValue_LVecBase3d,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase3d,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase3d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase3d,
  Dtool_UpcastInterface_ParamValue_LVecBase3d,
  Dtool_DowncastInterface_ParamValue_LVecBase3d,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase3d,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase3d,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(nullptr);
    Dtool_ParamValue_LVecBase3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    Dtool_ParamValue_LVecBase3d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase3d);
  }
}

/**
 * Python method tables for ParamValue_LVecBase3f (ParamValue_LVecBase3f)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase3f[] = {
  {"set_value", &Dtool_ParamValue_LVecBase3f_set_value_1081, METH_O, (const char *)Dtool_ParamValue_LVecBase3f_set_value_1081_comment},
  {"setValue", &Dtool_ParamValue_LVecBase3f_set_value_1081, METH_O, (const char *)Dtool_ParamValue_LVecBase3f_set_value_1081_comment},
  {"get_value", &Dtool_ParamValue_LVecBase3f_get_value_1082, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase3f_get_value_1082_comment},
  {"getValue", &Dtool_ParamValue_LVecBase3f_get_value_1082, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase3f_get_value_1082_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase3f_get_class_type_1084, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase3f_get_class_type_1084_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase3f_get_class_type_1084, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase3f_get_class_type_1084_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase3f[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase3f_value_Getter, &Dtool_ParamValue_LVecBase3f_value_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase3f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamValue_LVecBase3f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase3f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamValue_LVecBase3f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase3f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamValue_LVecBase3f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamValue_LVecBase3f,
    &Dtool_SequenceMethods_ParamValue_LVecBase3f,
    &Dtool_MappingMethods_ParamValue_LVecBase3f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamValue_LVecBase3f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamValue_LVecBase3f,
    nullptr, // tp_members
    Dtool_Properties_ParamValue_LVecBase3f,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase3f,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase3f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase3f,
  Dtool_UpcastInterface_ParamValue_LVecBase3f,
  Dtool_DowncastInterface_ParamValue_LVecBase3f,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase3f,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase3f,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(nullptr);
    Dtool_ParamValue_LVecBase3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    Dtool_ParamValue_LVecBase3f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase3f);
  }
}

/**
 * Python method tables for ParamValue_LVecBase3i (ParamValue_LVecBase3i)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase3i[] = {
  {"set_value", &Dtool_ParamValue_LVecBase3i_set_value_1088, METH_O, (const char *)Dtool_ParamValue_LVecBase3i_set_value_1088_comment},
  {"setValue", &Dtool_ParamValue_LVecBase3i_set_value_1088, METH_O, (const char *)Dtool_ParamValue_LVecBase3i_set_value_1088_comment},
  {"get_value", &Dtool_ParamValue_LVecBase3i_get_value_1089, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase3i_get_value_1089_comment},
  {"getValue", &Dtool_ParamValue_LVecBase3i_get_value_1089, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase3i_get_value_1089_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase3i_get_class_type_1091, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase3i_get_class_type_1091_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase3i_get_class_type_1091, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase3i_get_class_type_1091_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase3i[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase3i_value_Getter, &Dtool_ParamValue_LVecBase3i_value_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase3i = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamValue_LVecBase3i = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase3i = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamValue_LVecBase3i",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase3i,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamValue_LVecBase3i,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamValue_LVecBase3i,
    &Dtool_SequenceMethods_ParamValue_LVecBase3i,
    &Dtool_MappingMethods_ParamValue_LVecBase3i,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamValue_LVecBase3i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamValue_LVecBase3i,
    nullptr, // tp_members
    Dtool_Properties_ParamValue_LVecBase3i,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase3i,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase3i,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase3i,
  Dtool_UpcastInterface_ParamValue_LVecBase3i,
  Dtool_DowncastInterface_ParamValue_LVecBase3i,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase3i,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase3i,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase3i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(nullptr);
    Dtool_ParamValue_LVecBase3i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    Dtool_ParamValue_LVecBase3i._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase3i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase3i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase3i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase3i);
  }
}

/**
 * Python method tables for ParamValue_LVecBase4d (ParamValue_LVecBase4d)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase4d[] = {
  {"set_value", &Dtool_ParamValue_LVecBase4d_set_value_1095, METH_O, (const char *)Dtool_ParamValue_LVecBase4d_set_value_1095_comment},
  {"setValue", &Dtool_ParamValue_LVecBase4d_set_value_1095, METH_O, (const char *)Dtool_ParamValue_LVecBase4d_set_value_1095_comment},
  {"get_value", &Dtool_ParamValue_LVecBase4d_get_value_1096, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase4d_get_value_1096_comment},
  {"getValue", &Dtool_ParamValue_LVecBase4d_get_value_1096, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase4d_get_value_1096_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase4d_get_class_type_1098, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase4d_get_class_type_1098_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase4d_get_class_type_1098, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase4d_get_class_type_1098_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase4d[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase4d_value_Getter, &Dtool_ParamValue_LVecBase4d_value_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase4d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamValue_LVecBase4d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase4d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamValue_LVecBase4d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase4d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamValue_LVecBase4d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamValue_LVecBase4d,
    &Dtool_SequenceMethods_ParamValue_LVecBase4d,
    &Dtool_MappingMethods_ParamValue_LVecBase4d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamValue_LVecBase4d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamValue_LVecBase4d,
    nullptr, // tp_members
    Dtool_Properties_ParamValue_LVecBase4d,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase4d,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase4d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase4d,
  Dtool_UpcastInterface_ParamValue_LVecBase4d,
  Dtool_DowncastInterface_ParamValue_LVecBase4d,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase4d,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase4d,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(nullptr);
    Dtool_ParamValue_LVecBase4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    Dtool_ParamValue_LVecBase4d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase4d);
  }
}

/**
 * Python method tables for ParamValue_LVecBase4f (ParamValue_LVecBase4f)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase4f[] = {
  {"set_value", &Dtool_ParamValue_LVecBase4f_set_value_1102, METH_O, (const char *)Dtool_ParamValue_LVecBase4f_set_value_1102_comment},
  {"setValue", &Dtool_ParamValue_LVecBase4f_set_value_1102, METH_O, (const char *)Dtool_ParamValue_LVecBase4f_set_value_1102_comment},
  {"get_value", &Dtool_ParamValue_LVecBase4f_get_value_1103, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase4f_get_value_1103_comment},
  {"getValue", &Dtool_ParamValue_LVecBase4f_get_value_1103, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase4f_get_value_1103_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase4f_get_class_type_1105, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase4f_get_class_type_1105_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase4f_get_class_type_1105, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase4f_get_class_type_1105_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase4f[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase4f_value_Getter, &Dtool_ParamValue_LVecBase4f_value_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase4f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamValue_LVecBase4f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase4f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamValue_LVecBase4f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase4f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamValue_LVecBase4f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamValue_LVecBase4f,
    &Dtool_SequenceMethods_ParamValue_LVecBase4f,
    &Dtool_MappingMethods_ParamValue_LVecBase4f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamValue_LVecBase4f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamValue_LVecBase4f,
    nullptr, // tp_members
    Dtool_Properties_ParamValue_LVecBase4f,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase4f,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase4f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase4f,
  Dtool_UpcastInterface_ParamValue_LVecBase4f,
  Dtool_DowncastInterface_ParamValue_LVecBase4f,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase4f,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase4f,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(nullptr);
    Dtool_ParamValue_LVecBase4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    Dtool_ParamValue_LVecBase4f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase4f);
  }
}

/**
 * Python method tables for ParamValue_LVecBase4i (ParamValue_LVecBase4i)
 */
static PyMethodDef Dtool_Methods_ParamValue_LVecBase4i[] = {
  {"set_value", &Dtool_ParamValue_LVecBase4i_set_value_1109, METH_O, (const char *)Dtool_ParamValue_LVecBase4i_set_value_1109_comment},
  {"setValue", &Dtool_ParamValue_LVecBase4i_set_value_1109, METH_O, (const char *)Dtool_ParamValue_LVecBase4i_set_value_1109_comment},
  {"get_value", &Dtool_ParamValue_LVecBase4i_get_value_1110, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase4i_get_value_1110_comment},
  {"getValue", &Dtool_ParamValue_LVecBase4i_get_value_1110, METH_NOARGS, (const char *)Dtool_ParamValue_LVecBase4i_get_value_1110_comment},
  {"get_class_type", &Dtool_ParamValue_LVecBase4i_get_class_type_1112, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase4i_get_class_type_1112_comment},
  {"getClassType", &Dtool_ParamValue_LVecBase4i_get_class_type_1112, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LVecBase4i_get_class_type_1112_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamValue_LVecBase4i[] = {
  {(char *)"value", &Dtool_ParamValue_LVecBase4i_value_Getter, &Dtool_ParamValue_LVecBase4i_value_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LVecBase4i = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamValue_LVecBase4i = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamValue_LVecBase4i = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamValue_LVecBase4i",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LVecBase4i,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamValue_LVecBase4i,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamValue_LVecBase4i,
    &Dtool_SequenceMethods_ParamValue_LVecBase4i,
    &Dtool_MappingMethods_ParamValue_LVecBase4i,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamValue_LVecBase4i,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamValue_LVecBase4i,
    nullptr, // tp_members
    Dtool_Properties_ParamValue_LVecBase4i,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LVecBase4i,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LVecBase4i,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LVecBase4i,
  Dtool_UpcastInterface_ParamValue_LVecBase4i,
  Dtool_DowncastInterface_ParamValue_LVecBase4i,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LVecBase4i,
  (CoerceFunction)Dtool_Coerce_ParamValue_LVecBase4i,
};

static void Dtool_PyModuleClassInit_ParamValue_LVecBase4i(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(nullptr);
    Dtool_ParamValue_LVecBase4i._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    Dtool_ParamValue_LVecBase4i._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LVecBase4i._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LVecBase4i) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LVecBase4i)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LVecBase4i);
  }
}

/**
 * Python method tables for ParamValue_LMatrix3d (ParamValue_LMatrix3d)
 */
static PyMethodDef Dtool_Methods_ParamValue_LMatrix3d[] = {
  {"set_value", &Dtool_ParamValue_LMatrix3d_set_value_1116, METH_O, (const char *)Dtool_ParamValue_LMatrix3d_set_value_1116_comment},
  {"setValue", &Dtool_ParamValue_LMatrix3d_set_value_1116, METH_O, (const char *)Dtool_ParamValue_LMatrix3d_set_value_1116_comment},
  {"get_value", &Dtool_ParamValue_LMatrix3d_get_value_1117, METH_NOARGS, (const char *)Dtool_ParamValue_LMatrix3d_get_value_1117_comment},
  {"getValue", &Dtool_ParamValue_LMatrix3d_get_value_1117, METH_NOARGS, (const char *)Dtool_ParamValue_LMatrix3d_get_value_1117_comment},
  {"get_class_type", &Dtool_ParamValue_LMatrix3d_get_class_type_1119, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LMatrix3d_get_class_type_1119_comment},
  {"getClassType", &Dtool_ParamValue_LMatrix3d_get_class_type_1119, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LMatrix3d_get_class_type_1119_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamValue_LMatrix3d[] = {
  {(char *)"value", &Dtool_ParamValue_LMatrix3d_value_Getter, &Dtool_ParamValue_LMatrix3d_value_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LMatrix3d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamValue_LMatrix3d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamValue_LMatrix3d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamValue_LMatrix3d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LMatrix3d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamValue_LMatrix3d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamValue_LMatrix3d,
    &Dtool_SequenceMethods_ParamValue_LMatrix3d,
    &Dtool_MappingMethods_ParamValue_LMatrix3d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamValue_LMatrix3d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamValue_LMatrix3d,
    nullptr, // tp_members
    Dtool_Properties_ParamValue_LMatrix3d,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LMatrix3d,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LMatrix3d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LMatrix3d,
  Dtool_UpcastInterface_ParamValue_LMatrix3d,
  Dtool_DowncastInterface_ParamValue_LMatrix3d,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LMatrix3d,
  (CoerceFunction)Dtool_Coerce_ParamValue_LMatrix3d,
};

static void Dtool_PyModuleClassInit_ParamValue_LMatrix3d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(nullptr);
    Dtool_ParamValue_LMatrix3d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    Dtool_ParamValue_LMatrix3d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LMatrix3d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LMatrix3d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LMatrix3d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LMatrix3d);
  }
}

/**
 * Python method tables for ParamValue_LMatrix3f (ParamValue_LMatrix3f)
 */
static PyMethodDef Dtool_Methods_ParamValue_LMatrix3f[] = {
  {"set_value", &Dtool_ParamValue_LMatrix3f_set_value_1123, METH_O, (const char *)Dtool_ParamValue_LMatrix3f_set_value_1123_comment},
  {"setValue", &Dtool_ParamValue_LMatrix3f_set_value_1123, METH_O, (const char *)Dtool_ParamValue_LMatrix3f_set_value_1123_comment},
  {"get_value", &Dtool_ParamValue_LMatrix3f_get_value_1124, METH_NOARGS, (const char *)Dtool_ParamValue_LMatrix3f_get_value_1124_comment},
  {"getValue", &Dtool_ParamValue_LMatrix3f_get_value_1124, METH_NOARGS, (const char *)Dtool_ParamValue_LMatrix3f_get_value_1124_comment},
  {"get_class_type", &Dtool_ParamValue_LMatrix3f_get_class_type_1126, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LMatrix3f_get_class_type_1126_comment},
  {"getClassType", &Dtool_ParamValue_LMatrix3f_get_class_type_1126, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LMatrix3f_get_class_type_1126_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamValue_LMatrix3f[] = {
  {(char *)"value", &Dtool_ParamValue_LMatrix3f_value_Getter, &Dtool_ParamValue_LMatrix3f_value_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LMatrix3f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamValue_LMatrix3f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamValue_LMatrix3f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamValue_LMatrix3f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LMatrix3f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamValue_LMatrix3f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamValue_LMatrix3f,
    &Dtool_SequenceMethods_ParamValue_LMatrix3f,
    &Dtool_MappingMethods_ParamValue_LMatrix3f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamValue_LMatrix3f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamValue_LMatrix3f,
    nullptr, // tp_members
    Dtool_Properties_ParamValue_LMatrix3f,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LMatrix3f,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LMatrix3f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LMatrix3f,
  Dtool_UpcastInterface_ParamValue_LMatrix3f,
  Dtool_DowncastInterface_ParamValue_LMatrix3f,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LMatrix3f,
  (CoerceFunction)Dtool_Coerce_ParamValue_LMatrix3f,
};

static void Dtool_PyModuleClassInit_ParamValue_LMatrix3f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(nullptr);
    Dtool_ParamValue_LMatrix3f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    Dtool_ParamValue_LMatrix3f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LMatrix3f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LMatrix3f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LMatrix3f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LMatrix3f);
  }
}

/**
 * Python method tables for ParamValue_LMatrix4d (ParamValue_LMatrix4d)
 */
static PyMethodDef Dtool_Methods_ParamValue_LMatrix4d[] = {
  {"set_value", &Dtool_ParamValue_LMatrix4d_set_value_1130, METH_O, (const char *)Dtool_ParamValue_LMatrix4d_set_value_1130_comment},
  {"setValue", &Dtool_ParamValue_LMatrix4d_set_value_1130, METH_O, (const char *)Dtool_ParamValue_LMatrix4d_set_value_1130_comment},
  {"get_value", &Dtool_ParamValue_LMatrix4d_get_value_1131, METH_NOARGS, (const char *)Dtool_ParamValue_LMatrix4d_get_value_1131_comment},
  {"getValue", &Dtool_ParamValue_LMatrix4d_get_value_1131, METH_NOARGS, (const char *)Dtool_ParamValue_LMatrix4d_get_value_1131_comment},
  {"get_class_type", &Dtool_ParamValue_LMatrix4d_get_class_type_1133, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LMatrix4d_get_class_type_1133_comment},
  {"getClassType", &Dtool_ParamValue_LMatrix4d_get_class_type_1133, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LMatrix4d_get_class_type_1133_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamValue_LMatrix4d[] = {
  {(char *)"value", &Dtool_ParamValue_LMatrix4d_value_Getter, &Dtool_ParamValue_LMatrix4d_value_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LMatrix4d = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamValue_LMatrix4d = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamValue_LMatrix4d = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamValue_LMatrix4d",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LMatrix4d,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamValue_LMatrix4d,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamValue_LMatrix4d,
    &Dtool_SequenceMethods_ParamValue_LMatrix4d,
    &Dtool_MappingMethods_ParamValue_LMatrix4d,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamValue_LMatrix4d,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamValue_LMatrix4d,
    nullptr, // tp_members
    Dtool_Properties_ParamValue_LMatrix4d,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LMatrix4d,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LMatrix4d,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LMatrix4d,
  Dtool_UpcastInterface_ParamValue_LMatrix4d,
  Dtool_DowncastInterface_ParamValue_LMatrix4d,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LMatrix4d,
  (CoerceFunction)Dtool_Coerce_ParamValue_LMatrix4d,
};

static void Dtool_PyModuleClassInit_ParamValue_LMatrix4d(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(nullptr);
    Dtool_ParamValue_LMatrix4d._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    Dtool_ParamValue_LMatrix4d._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LMatrix4d._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LMatrix4d) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LMatrix4d)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LMatrix4d);
  }
}

/**
 * Python method tables for ParamValue_LMatrix4f (ParamValue_LMatrix4f)
 */
static PyMethodDef Dtool_Methods_ParamValue_LMatrix4f[] = {
  {"set_value", &Dtool_ParamValue_LMatrix4f_set_value_1137, METH_O, (const char *)Dtool_ParamValue_LMatrix4f_set_value_1137_comment},
  {"setValue", &Dtool_ParamValue_LMatrix4f_set_value_1137, METH_O, (const char *)Dtool_ParamValue_LMatrix4f_set_value_1137_comment},
  {"get_value", &Dtool_ParamValue_LMatrix4f_get_value_1138, METH_NOARGS, (const char *)Dtool_ParamValue_LMatrix4f_get_value_1138_comment},
  {"getValue", &Dtool_ParamValue_LMatrix4f_get_value_1138, METH_NOARGS, (const char *)Dtool_ParamValue_LMatrix4f_get_value_1138_comment},
  {"get_class_type", &Dtool_ParamValue_LMatrix4f_get_class_type_1140, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LMatrix4f_get_class_type_1140_comment},
  {"getClassType", &Dtool_ParamValue_LMatrix4f_get_class_type_1140, METH_NOARGS | METH_STATIC, (const char *)Dtool_ParamValue_LMatrix4f_get_class_type_1140_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ParamValue_LMatrix4f[] = {
  {(char *)"value", &Dtool_ParamValue_LMatrix4f_value_Getter, &Dtool_ParamValue_LMatrix4f_value_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ParamValue_LMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ParamValue_LMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ParamValue_LMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ParamValue_LMatrix4f = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ParamValue_LMatrix4f = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ParamValue_LMatrix4f = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.ParamValue_LMatrix4f",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ParamValue_LMatrix4f,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ParamValue_LMatrix4f,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ParamValue_LMatrix4f,
    &Dtool_SequenceMethods_ParamValue_LMatrix4f,
    &Dtool_MappingMethods_ParamValue_LMatrix4f,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ParamValue_LMatrix4f,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ParamValue_LMatrix4f,
    nullptr, // tp_members
    Dtool_Properties_ParamValue_LMatrix4f,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ParamValue_LMatrix4f,
    PyType_GenericAlloc,
    Dtool_new_ParamValue_LMatrix4f,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ParamValue_LMatrix4f,
  Dtool_UpcastInterface_ParamValue_LMatrix4f,
  Dtool_DowncastInterface_ParamValue_LMatrix4f,
  (CoerceFunction)Dtool_ConstCoerce_ParamValue_LMatrix4f,
  (CoerceFunction)Dtool_Coerce_ParamValue_LMatrix4f,
};

static void Dtool_PyModuleClassInit_ParamValue_LMatrix4f(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_ParamValueBase(nullptr);
    Dtool_ParamValue_LMatrix4f._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_ParamValueBase);
    Dtool_ParamValue_LMatrix4f._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ParamValue_LMatrix4f._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ParamValue_LMatrix4f) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ParamValue_LMatrix4f)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ParamValue_LMatrix4f);
  }
}

/**
 * Python method tables for WritableConfigurable (WritableConfigurable)
 */
static PyMethodDef Dtool_Methods_WritableConfigurable[] = {
  {"get_class_type", &Dtool_WritableConfigurable_get_class_type_1148, METH_NOARGS | METH_STATIC, (const char *)Dtool_WritableConfigurable_get_class_type_1148_comment},
  {"getClassType", &Dtool_WritableConfigurable_get_class_type_1148, METH_NOARGS | METH_STATIC, (const char *)Dtool_WritableConfigurable_get_class_type_1148_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_WritableConfigurable = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_WritableConfigurable = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_WritableConfigurable = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_WritableConfigurable = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_WritableConfigurable = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_WritableConfigurable = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.WritableConfigurable",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_WritableConfigurable,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_WritableConfigurable,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_WritableConfigurable,
    &Dtool_SequenceMethods_WritableConfigurable,
    &Dtool_MappingMethods_WritableConfigurable,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_WritableConfigurable,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defined as a fix to allow creating Configurable and Writable objects.\n"
    " * Otherwise the compiler gets confused since both TypedWritable and\n"
    " * Configurable inherit from TypedObject.\n"
    " *\n"
    " * An object that has data or parameters that are set less frequently (at\n"
    " * least occasionally) than every frame.  We can cache the configuration info\n"
    " * by by using the \"dirty\" flag.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_WritableConfigurable,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_WritableConfigurable,
    PyType_GenericAlloc,
    Dtool_new_WritableConfigurable,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_WritableConfigurable,
  Dtool_UpcastInterface_WritableConfigurable,
  Dtool_DowncastInterface_WritableConfigurable,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_WritableConfigurable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_TypedWritable(nullptr);
    Dtool_WritableConfigurable._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_TypedWritable);
    Dtool_WritableConfigurable._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_WritableConfigurable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_WritableConfigurable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(WritableConfigurable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_WritableConfigurable);
  }
}

/**
 * Python method tables for UniqueIdAllocator (UniqueIdAllocator)
 */
static PyMethodDef Dtool_Methods_UniqueIdAllocator[] = {
  {"allocate", &Dtool_UniqueIdAllocator_allocate_1153, METH_NOARGS, (const char *)Dtool_UniqueIdAllocator_allocate_1153_comment},
  {"initial_reserve_id", &Dtool_UniqueIdAllocator_initial_reserve_id_1154, METH_O, (const char *)Dtool_UniqueIdAllocator_initial_reserve_id_1154_comment},
  {"initialReserveId", &Dtool_UniqueIdAllocator_initial_reserve_id_1154, METH_O, (const char *)Dtool_UniqueIdAllocator_initial_reserve_id_1154_comment},
  {"is_allocated", &Dtool_UniqueIdAllocator_is_allocated_1155, METH_O, (const char *)Dtool_UniqueIdAllocator_is_allocated_1155_comment},
  {"isAllocated", &Dtool_UniqueIdAllocator_is_allocated_1155, METH_O, (const char *)Dtool_UniqueIdAllocator_is_allocated_1155_comment},
  {"free", &Dtool_UniqueIdAllocator_free_1156, METH_O, (const char *)Dtool_UniqueIdAllocator_free_1156_comment},
  {"fraction_used", &Dtool_UniqueIdAllocator_fraction_used_1157, METH_NOARGS, (const char *)Dtool_UniqueIdAllocator_fraction_used_1157_comment},
  {"fractionUsed", &Dtool_UniqueIdAllocator_fraction_used_1157, METH_NOARGS, (const char *)Dtool_UniqueIdAllocator_fraction_used_1157_comment},
  {"output", &Dtool_UniqueIdAllocator_output_1158, METH_O, (const char *)Dtool_UniqueIdAllocator_output_1158_comment},
  {"write", &Dtool_UniqueIdAllocator_write_1159, METH_O, (const char *)Dtool_UniqueIdAllocator_write_1159_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     UniqueIdAllocator
//////////////////
static PyObject *Dtool_Repr_UniqueIdAllocator(PyObject *self) {
  UniqueIdAllocator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UniqueIdAllocator, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     UniqueIdAllocator
//////////////////
static PyObject *Dtool_Str_UniqueIdAllocator(PyObject *self) {
  UniqueIdAllocator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_UniqueIdAllocator, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_UniqueIdAllocator = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_UniqueIdAllocator = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.core.UniqueIdAllocator",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_UniqueIdAllocator,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_UniqueIdAllocator,
    &Dtool_NumberMethods_UniqueIdAllocator,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_UniqueIdAllocator,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Manage a set of ID values from min to max inclusive.  The ID numbers that\n"
    " * are freed will be allocated (reused) in the same order.  I.e.  the oldest\n"
    " * ID numbers will be allocated.\n"
    " *\n"
    " * This implementation will use 4 bytes per id number, plus a few bytes of\n"
    " * management data.  e.g.  10,000 ID numbers will use 40KB.\n"
    " *\n"
    " * Also be advised that ID -1 and -2 are used internally by the allocator.  If\n"
    " * allocate returns IndexEnd (-1) then the allocator is out of free ID\n"
    " * numbers.\n"
    " *\n"
    " * There are other implementations that can better leverage runs of used or\n"
    " * unused IDs or use bit arrays for the IDs.  But, it takes extra work to\n"
    " * track the age of freed IDs, which is required for what we wanted.  If you\n"
    " * would like to kick around other implementation ideas, please contact\n"
    " * Schuyler.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_UniqueIdAllocator,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_UniqueIdAllocator,
    PyType_GenericAlloc,
    Dtool_new_UniqueIdAllocator,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_UniqueIdAllocator,
  Dtool_UpcastInterface_UniqueIdAllocator,
  Dtool_DowncastInterface_UniqueIdAllocator,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_UniqueIdAllocator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_UniqueIdAllocator._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_UniqueIdAllocator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_UniqueIdAllocator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(UniqueIdAllocator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_UniqueIdAllocator);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3putil_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    AnimInterface::init_type();
    TypeHandle handle = AnimInterface::get_class_type();
    Dtool_AnimInterface._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AnimInterface);
  }
  {
    TypedWritable::init_type();
    TypeHandle handle = TypedWritable::get_class_type();
    Dtool_TypedWritable._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TypedWritable);
  }
  {
    TypedWritableReferenceCount::init_type();
    TypeHandle handle = TypedWritableReferenceCount::get_class_type();
    Dtool_TypedWritableReferenceCount._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_TypedWritableReferenceCount);
  }
  {
    BamCacheRecord::init_type();
    TypeHandle handle = BamCacheRecord::get_class_type();
    Dtool_BamCacheRecord._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BamCacheRecord);
  }
  {
    TypeHandle handle = BitMask< uint16_t, 16 >::get_class_type();
    Dtool_BitMask_uint16_t_16._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BitMask_uint16_t_16);
  }
  {
    TypeHandle handle = BitMask< uint32_t, 32 >::get_class_type();
    Dtool_BitMask_uint32_t_32._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BitMask_uint32_t_32);
  }
  {
    TypeHandle handle = BitMask< uint64_t, 64 >::get_class_type();
    Dtool_BitMask_uint64_t_64._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BitMask_uint64_t_64);
  }
  {
    BitArray::init_type();
    TypeHandle handle = BitArray::get_class_type();
    Dtool_BitArray._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BitArray);
  }
  {
    ButtonHandle::init_type();
    TypeHandle handle = ButtonHandle::get_class_type();
    Dtool_ButtonHandle._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ButtonHandle);
  }
  {
    ButtonMap::init_type();
    TypeHandle handle = ButtonMap::get_class_type();
    Dtool_ButtonMap._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ButtonMap);
  }
  {
    CallbackObject::init_type();
    TypeHandle handle = CallbackObject::get_class_type();
    Dtool_CallbackObject._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CallbackObject);
  }
  {
    CachedTypedWritableReferenceCount::init_type();
    TypeHandle handle = CachedTypedWritableReferenceCount::get_class_type();
    Dtool_CachedTypedWritableReferenceCount._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CachedTypedWritableReferenceCount);
  }
  {
    CallbackData::init_type();
    TypeHandle handle = CallbackData::get_class_type();
    Dtool_CallbackData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CallbackData);
  }
  {
    PythonCallbackObject::init_type();
    TypeHandle handle = PythonCallbackObject::get_class_type();
    Dtool_PythonCallbackObject._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PythonCallbackObject);
  }
  {
    ClockObject::init_type();
    TypeHandle handle = ClockObject::get_class_type();
    Dtool_ClockObject._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ClockObject);
  }
  {
    CopyOnWriteObject::init_type();
    TypeHandle handle = CopyOnWriteObject::get_class_type();
    Dtool_CopyOnWriteObject._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_CopyOnWriteObject);
  }
  {
    DoubleBitMask< BitMaskNative >::init_type();
    TypeHandle handle = DoubleBitMask< BitMaskNative >::get_class_type();
    Dtool_DoubleBitMask_BitMaskNative._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_DoubleBitMask_BitMaskNative);
  }
  {
    DoubleBitMask< DoubleBitMaskNative >::init_type();
    TypeHandle handle = DoubleBitMask< DoubleBitMaskNative >::get_class_type();
    Dtool_DoubleBitMask_DoubleBitMaskNative._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_DoubleBitMask_DoubleBitMaskNative);
  }
  {
    NodeCachedReferenceCount::init_type();
    TypeHandle handle = NodeCachedReferenceCount::get_class_type();
    Dtool_NodeCachedReferenceCount._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_NodeCachedReferenceCount);
  }
  {
    SparseArray::init_type();
    TypeHandle handle = SparseArray::get_class_type();
    Dtool_SparseArray._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_SparseArray);
  }
  {
    ParamValueBase::init_type();
    TypeHandle handle = ParamValueBase::get_class_type();
    Dtool_ParamValueBase._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamValueBase);
  }
  {
    ParamTypedRefCount::init_type();
    TypeHandle handle = ParamTypedRefCount::get_class_type();
    Dtool_ParamTypedRefCount._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamTypedRefCount);
  }
  {
    TypeHandle handle = ParamValue< std::string >::get_class_type();
    Dtool_ParamValue_std_string._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamValue_std_string);
  }
  {
    TypeHandle handle = ParamValue< std::wstring >::get_class_type();
    Dtool_ParamValue_std_wstring._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamValue_std_wstring);
  }
  {
    TypeHandle handle = ParamValue< LVecBase2d >::get_class_type();
    Dtool_ParamValue_LVecBase2d._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamValue_LVecBase2d);
  }
  {
    TypeHandle handle = ParamValue< LVecBase2f >::get_class_type();
    Dtool_ParamValue_LVecBase2f._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamValue_LVecBase2f);
  }
  {
    TypeHandle handle = ParamValue< LVecBase2i >::get_class_type();
    Dtool_ParamValue_LVecBase2i._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamValue_LVecBase2i);
  }
  {
    TypeHandle handle = ParamValue< LVecBase3d >::get_class_type();
    Dtool_ParamValue_LVecBase3d._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamValue_LVecBase3d);
  }
  {
    TypeHandle handle = ParamValue< LVecBase3f >::get_class_type();
    Dtool_ParamValue_LVecBase3f._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamValue_LVecBase3f);
  }
  {
    TypeHandle handle = ParamValue< LVecBase3i >::get_class_type();
    Dtool_ParamValue_LVecBase3i._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamValue_LVecBase3i);
  }
  {
    TypeHandle handle = ParamValue< LVecBase4d >::get_class_type();
    Dtool_ParamValue_LVecBase4d._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamValue_LVecBase4d);
  }
  {
    TypeHandle handle = ParamValue< LVecBase4f >::get_class_type();
    Dtool_ParamValue_LVecBase4f._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamValue_LVecBase4f);
  }
  {
    TypeHandle handle = ParamValue< LVecBase4i >::get_class_type();
    Dtool_ParamValue_LVecBase4i._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamValue_LVecBase4i);
  }
  {
    TypeHandle handle = ParamValue< LMatrix3d >::get_class_type();
    Dtool_ParamValue_LMatrix3d._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamValue_LMatrix3d);
  }
  {
    TypeHandle handle = ParamValue< LMatrix3f >::get_class_type();
    Dtool_ParamValue_LMatrix3f._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamValue_LMatrix3f);
  }
  {
    TypeHandle handle = ParamValue< LMatrix4d >::get_class_type();
    Dtool_ParamValue_LMatrix4d._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamValue_LMatrix4d);
  }
  {
    TypeHandle handle = ParamValue< LMatrix4f >::get_class_type();
    Dtool_ParamValue_LMatrix4f._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ParamValue_LMatrix4f);
  }
  {
    WritableConfigurable::init_type();
    TypeHandle handle = WritableConfigurable::get_class_type();
    Dtool_WritableConfigurable._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_WritableConfigurable);
  }
}

void Dtool_libp3putil_BuildInstants(PyObject *module) {
  (void) module;
  // enum AutoTextureScale
  PyModule_AddObject(module, "ATS_none", Dtool_WrapValue(::ATS_none));
  PyModule_AddObject(module, "ATSNone", Dtool_WrapValue(::ATS_none));
  PyModule_AddObject(module, "ATS_down", Dtool_WrapValue(::ATS_down));
  PyModule_AddObject(module, "ATSDown", Dtool_WrapValue(::ATS_down));
  PyModule_AddObject(module, "ATS_up", Dtool_WrapValue(::ATS_up));
  PyModule_AddObject(module, "ATSUp", Dtool_WrapValue(::ATS_up));
  PyModule_AddObject(module, "ATS_pad", Dtool_WrapValue(::ATS_pad));
  PyModule_AddObject(module, "ATSPad", Dtool_WrapValue(::ATS_pad));
  PyModule_AddObject(module, "ATS_unspecified", Dtool_WrapValue(::ATS_unspecified));
  PyModule_AddObject(module, "ATSUnspecified", Dtool_WrapValue(::ATS_unspecified));
  // enum ColorSpace
  PyModule_AddObject(module, "CS_unspecified", Dtool_WrapValue(::CS_unspecified));
  PyModule_AddObject(module, "CSUnspecified", Dtool_WrapValue(::CS_unspecified));
  PyModule_AddObject(module, "CS_linear", Dtool_WrapValue(::CS_linear));
  PyModule_AddObject(module, "CSLinear", Dtool_WrapValue(::CS_linear));
  PyModule_AddObject(module, "CS_sRGB", Dtool_WrapValue(::CS_sRGB));
  PyModule_AddObject(module, "CSSRGB", Dtool_WrapValue(::CS_sRGB));
  PyModule_AddObject(module, "CS_scRGB", Dtool_WrapValue(::CS_scRGB));
  PyModule_AddObject(module, "CSScRGB", Dtool_WrapValue(::CS_scRGB));
  // enum class PointerType
  {
    PyObject *members = PyTuple_New(5);
    PyObject *member;
    member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("unknown"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("unknown"));
#endif
    PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)PointerType::unknown));
    PyTuple_SET_ITEM(members, 0, member);
    member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("mouse"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("mouse"));
#endif
    PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)PointerType::mouse));
    PyTuple_SET_ITEM(members, 1, member);
    member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("finger"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("finger"));
#endif
    PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)PointerType::finger));
    PyTuple_SET_ITEM(members, 2, member);
    member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("stylus"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("stylus"));
#endif
    PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)PointerType::stylus));
    PyTuple_SET_ITEM(members, 3, member);
    member = PyTuple_New(2);
#if PY_MAJOR_VERSION >= 3
      PyTuple_SET_ITEM(member, 0, PyUnicode_FromString("eraser"));
#else
      PyTuple_SET_ITEM(member, 0, PyString_FromString("eraser"));
#endif
    PyTuple_SET_ITEM(member, 1, Dtool_WrapValue((int)PointerType::eraser));
    PyTuple_SET_ITEM(members, 4, member);
    Dtool_Ptr_PointerType = Dtool_EnumType_Create("PointerType", members, "panda3d.core");
    PyModule_AddObject(module, "PointerType", (PyObject *)Dtool_Ptr_PointerType);
  }
  // ConstPointerToArray< ushort >
  Dtool_PyModuleClassInit_ConstPointerToArray_ushort(module);
  PyModule_AddObject(module, "ConstPointerToArray_ushort", (PyObject *)&Dtool_ConstPointerToArray_ushort);
  Py_INCREF(Dtool_Ptr_ConstPointerToArray_ushort);
  PyModule_AddObject(module, "ConstPointerToArrayUshort", (PyObject *)&Dtool_ConstPointerToArray_ushort);
  // PointerToArrayBase< ushort >
  Dtool_PyModuleClassInit_PointerToArrayBase_ushort(module);
  PyModule_AddObject(module, "PointerToArrayBase_ushort", (PyObject *)&Dtool_PointerToArrayBase_ushort);
  Py_INCREF(Dtool_Ptr_PointerToArrayBase_ushort);
  PyModule_AddObject(module, "PointerToArrayBaseUshort", (PyObject *)&Dtool_PointerToArrayBase_ushort);
  // PointerToBase< ReferenceCountedVector< ushort > >
  Dtool_PyModuleClassInit_PointerToBase_ReferenceCountedVector_ushort(module);
  PyModule_AddObject(module, "PointerToBase_ReferenceCountedVector_ushort", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_ushort);
  Py_INCREF(Dtool_Ptr_PointerToBase_ReferenceCountedVector_ushort);
  PyModule_AddObject(module, "PointerToBaseReferenceCountedVectorUshort", (PyObject *)&Dtool_PointerToBase_ReferenceCountedVector_ushort);
  // PointerToArray< ushort >
  Dtool_PyModuleClassInit_PointerToArray_ushort(module);
  PyModule_AddObject(module, "PointerToArray_ushort", (PyObject *)&Dtool_PointerToArray_ushort);
  Py_INCREF(Dtool_Ptr_PointerToArray_ushort);
  PyModule_AddObject(module, "PointerToArrayUshort", (PyObject *)&Dtool_PointerToArray_ushort);
  // AnimInterface
  Dtool_PyModuleClassInit_AnimInterface(module);
  PyModule_AddObject(module, "AnimInterface", (PyObject *)&Dtool_AnimInterface);
  // UpdateSeq
  Dtool_PyModuleClassInit_UpdateSeq(module);
  PyModule_AddObject(module, "UpdateSeq", (PyObject *)&Dtool_UpdateSeq);
  // TypedWritable
  Dtool_PyModuleClassInit_TypedWritable(module);
  PyModule_AddObject(module, "TypedWritable", (PyObject *)&Dtool_TypedWritable);
  // TypedWritableReferenceCount
  Dtool_PyModuleClassInit_TypedWritableReferenceCount(module);
  PyModule_AddObject(module, "TypedWritableReferenceCount", (PyObject *)&Dtool_TypedWritableReferenceCount);
  // BamCacheRecord
  Dtool_PyModuleClassInit_BamCacheRecord(module);
  PyModule_AddObject(module, "BamCacheRecord", (PyObject *)&Dtool_BamCacheRecord);
  // BamCache
  Dtool_PyModuleClassInit_BamCache(module);
  PyModule_AddObject(module, "BamCache", (PyObject *)&Dtool_BamCache);
  // BamEnums
  Dtool_PyModuleClassInit_BamEnums(module);
  PyModule_AddObject(module, "BamEnums", (PyObject *)&Dtool_BamEnums);
  // LoaderOptions
  Dtool_PyModuleClassInit_LoaderOptions(module);
  PyModule_AddObject(module, "LoaderOptions", (PyObject *)&Dtool_LoaderOptions);
  // BamReader
  Dtool_PyModuleClassInit_BamReader(module);
  PyModule_AddObject(module, "BamReader", (PyObject *)&Dtool_BamReader);
  // BamWriter
  Dtool_PyModuleClassInit_BamWriter(module);
  PyModule_AddObject(module, "BamWriter", (PyObject *)&Dtool_BamWriter);
  // BitMask< uint16_t, 16 >
  Dtool_PyModuleClassInit_BitMask_uint16_t_16(module);
  PyModule_AddObject(module, "BitMask_uint16_t_16", (PyObject *)&Dtool_BitMask_uint16_t_16);
  Py_INCREF(Dtool_Ptr_BitMask_uint16_t_16);
  PyModule_AddObject(module, "BitMaskUint16T16", (PyObject *)&Dtool_BitMask_uint16_t_16);
  // typedef BitMask< uint16_t, 16 > BitMask16
  Dtool_PyModuleClassInit_BitMask_uint16_t_16(module);
  Py_INCREF((PyObject *)&Dtool_BitMask_uint16_t_16);
  PyModule_AddObject(module, "BitMask16", (PyObject *)&Dtool_BitMask_uint16_t_16);
  // BitMask< uint32_t, 32 >
  Dtool_PyModuleClassInit_BitMask_uint32_t_32(module);
  PyModule_AddObject(module, "BitMask_uint32_t_32", (PyObject *)&Dtool_BitMask_uint32_t_32);
  Py_INCREF(Dtool_Ptr_BitMask_uint32_t_32);
  PyModule_AddObject(module, "BitMaskUint32T32", (PyObject *)&Dtool_BitMask_uint32_t_32);
  // typedef BitMask< uint32_t, 32 > BitMask32
  Dtool_PyModuleClassInit_BitMask_uint32_t_32(module);
  Py_INCREF((PyObject *)&Dtool_BitMask_uint32_t_32);
  PyModule_AddObject(module, "BitMask32", (PyObject *)&Dtool_BitMask_uint32_t_32);
  // BitMask< uint64_t, 64 >
  Dtool_PyModuleClassInit_BitMask_uint64_t_64(module);
  PyModule_AddObject(module, "BitMask_uint64_t_64", (PyObject *)&Dtool_BitMask_uint64_t_64);
  Py_INCREF(Dtool_Ptr_BitMask_uint64_t_64);
  PyModule_AddObject(module, "BitMaskUint64T64", (PyObject *)&Dtool_BitMask_uint64_t_64);
  // typedef BitMask< uint64_t, 64 > BitMask64
  Dtool_PyModuleClassInit_BitMask_uint64_t_64(module);
  Py_INCREF((PyObject *)&Dtool_BitMask_uint64_t_64);
  PyModule_AddObject(module, "BitMask64", (PyObject *)&Dtool_BitMask_uint64_t_64);
  // BitArray
  Dtool_PyModuleClassInit_BitArray(module);
  PyModule_AddObject(module, "BitArray", (PyObject *)&Dtool_BitArray);
  // ButtonHandle
  Dtool_PyModuleClassInit_ButtonHandle(module);
  PyModule_AddObject(module, "ButtonHandle", (PyObject *)&Dtool_ButtonHandle);
  // ButtonRegistry
  Dtool_PyModuleClassInit_ButtonRegistry(module);
  PyModule_AddObject(module, "ButtonRegistry", (PyObject *)&Dtool_ButtonRegistry);
  // ButtonMap
  Dtool_PyModuleClassInit_ButtonMap(module);
  PyModule_AddObject(module, "ButtonMap", (PyObject *)&Dtool_ButtonMap);
  // CallbackObject
  Dtool_PyModuleClassInit_CallbackObject(module);
  PyModule_AddObject(module, "CallbackObject", (PyObject *)&Dtool_CallbackObject);
  // CachedTypedWritableReferenceCount
  Dtool_PyModuleClassInit_CachedTypedWritableReferenceCount(module);
  PyModule_AddObject(module, "CachedTypedWritableReferenceCount", (PyObject *)&Dtool_CachedTypedWritableReferenceCount);
  // CallbackData
  Dtool_PyModuleClassInit_CallbackData(module);
  PyModule_AddObject(module, "CallbackData", (PyObject *)&Dtool_CallbackData);
  // PythonCallbackObject
  Dtool_PyModuleClassInit_PythonCallbackObject(module);
  PyModule_AddObject(module, "PythonCallbackObject", (PyObject *)&Dtool_PythonCallbackObject);
  // TimeVal
  Dtool_PyModuleClassInit_TimeVal(module);
  PyModule_AddObject(module, "TimeVal", (PyObject *)&Dtool_TimeVal);
  // ClockObject
  Dtool_PyModuleClassInit_ClockObject(module);
  PyModule_AddObject(module, "ClockObject", (PyObject *)&Dtool_ClockObject);
  // typedef BitMask< uint32_t, 32 > CollideMask
  Dtool_PyModuleClassInit_BitMask_uint32_t_32(module);
  Py_INCREF((PyObject *)&Dtool_BitMask_uint32_t_32);
  PyModule_AddObject(module, "CollideMask", (PyObject *)&Dtool_BitMask_uint32_t_32);
  // CopyOnWriteObject
  Dtool_PyModuleClassInit_CopyOnWriteObject(module);
  PyModule_AddObject(module, "CopyOnWriteObject", (PyObject *)&Dtool_CopyOnWriteObject);
  // DatagramBuffer
  Dtool_PyModuleClassInit_DatagramBuffer(module);
  PyModule_AddObject(module, "DatagramBuffer", (PyObject *)&Dtool_DatagramBuffer);
  // DatagramInputFile
  Dtool_PyModuleClassInit_DatagramInputFile(module);
  PyModule_AddObject(module, "DatagramInputFile", (PyObject *)&Dtool_DatagramInputFile);
  // DatagramOutputFile
  Dtool_PyModuleClassInit_DatagramOutputFile(module);
  PyModule_AddObject(module, "DatagramOutputFile", (PyObject *)&Dtool_DatagramOutputFile);
  // DoubleBitMask< BitMaskNative >
  Dtool_PyModuleClassInit_DoubleBitMask_BitMaskNative(module);
  PyModule_AddObject(module, "DoubleBitMask_BitMaskNative", (PyObject *)&Dtool_DoubleBitMask_BitMaskNative);
  Py_INCREF(Dtool_Ptr_DoubleBitMask_BitMaskNative);
  PyModule_AddObject(module, "DoubleBitMaskBitMaskNative", (PyObject *)&Dtool_DoubleBitMask_BitMaskNative);
  // typedef DoubleBitMask< BitMaskNative > DoubleBitMaskNative
  Dtool_PyModuleClassInit_DoubleBitMask_BitMaskNative(module);
  Py_INCREF((PyObject *)&Dtool_DoubleBitMask_BitMaskNative);
  PyModule_AddObject(module, "DoubleBitMaskNative", (PyObject *)&Dtool_DoubleBitMask_BitMaskNative);
  // DoubleBitMask< DoubleBitMaskNative >
  Dtool_PyModuleClassInit_DoubleBitMask_DoubleBitMaskNative(module);
  PyModule_AddObject(module, "DoubleBitMask_DoubleBitMaskNative", (PyObject *)&Dtool_DoubleBitMask_DoubleBitMaskNative);
  Py_INCREF(Dtool_Ptr_DoubleBitMask_DoubleBitMaskNative);
  PyModule_AddObject(module, "DoubleBitMaskDoubleBitMaskNative", (PyObject *)&Dtool_DoubleBitMask_DoubleBitMaskNative);
  // typedef DoubleBitMask< DoubleBitMaskNative > QuadBitMaskNative
  Dtool_PyModuleClassInit_DoubleBitMask_DoubleBitMaskNative(module);
  Py_INCREF((PyObject *)&Dtool_DoubleBitMask_DoubleBitMaskNative);
  PyModule_AddObject(module, "QuadBitMaskNative", (PyObject *)&Dtool_DoubleBitMask_DoubleBitMaskNative);
  // typedef BitMask< uint32_t, 32 > DrawMask
  Dtool_PyModuleClassInit_BitMask_uint32_t_32(module);
  Py_INCREF((PyObject *)&Dtool_BitMask_uint32_t_32);
  PyModule_AddObject(module, "DrawMask", (PyObject *)&Dtool_BitMask_uint32_t_32);
  // GamepadButton
  Dtool_PyModuleClassInit_GamepadButton(module);
  PyModule_AddObject(module, "GamepadButton", (PyObject *)&Dtool_GamepadButton);
  // KeyboardButton
  Dtool_PyModuleClassInit_KeyboardButton(module);
  PyModule_AddObject(module, "KeyboardButton", (PyObject *)&Dtool_KeyboardButton);
  // ModifierButtons
  Dtool_PyModuleClassInit_ModifierButtons(module);
  PyModule_AddObject(module, "ModifierButtons", (PyObject *)&Dtool_ModifierButtons);
  // MouseButton
  Dtool_PyModuleClassInit_MouseButton(module);
  PyModule_AddObject(module, "MouseButton", (PyObject *)&Dtool_MouseButton);
  // PointerData
  Dtool_PyModuleClassInit_PointerData(module);
  PyModule_AddObject(module, "PointerData", (PyObject *)&Dtool_PointerData);
  // typedef PointerData MouseData
  Dtool_PyModuleClassInit_PointerData(module);
  Py_INCREF((PyObject *)&Dtool_PointerData);
  PyModule_AddObject(module, "MouseData", (PyObject *)&Dtool_PointerData);
  // NodeCachedReferenceCount
  Dtool_PyModuleClassInit_NodeCachedReferenceCount(module);
  PyModule_AddObject(module, "NodeCachedReferenceCount", (PyObject *)&Dtool_NodeCachedReferenceCount);
  // SparseArray
  Dtool_PyModuleClassInit_SparseArray(module);
  PyModule_AddObject(module, "SparseArray", (PyObject *)&Dtool_SparseArray);
  // ParamValueBase
  Dtool_PyModuleClassInit_ParamValueBase(module);
  PyModule_AddObject(module, "ParamValueBase", (PyObject *)&Dtool_ParamValueBase);
  // ParamTypedRefCount
  Dtool_PyModuleClassInit_ParamTypedRefCount(module);
  PyModule_AddObject(module, "ParamTypedRefCount", (PyObject *)&Dtool_ParamTypedRefCount);
  // ParamValue< string >
  Dtool_PyModuleClassInit_ParamValue_std_string(module);
  PyModule_AddObject(module, "ParamValue_string", (PyObject *)&Dtool_ParamValue_std_string);
  Py_INCREF(Dtool_Ptr_ParamValue_std_string);
  PyModule_AddObject(module, "ParamValueString", (PyObject *)&Dtool_ParamValue_std_string);
  // typedef ParamValue< std::string > ParamString
  Dtool_PyModuleClassInit_ParamValue_std_string(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_std_string);
  PyModule_AddObject(module, "ParamString", (PyObject *)&Dtool_ParamValue_std_string);
  // ParamValue< wstring >
  Dtool_PyModuleClassInit_ParamValue_std_wstring(module);
  PyModule_AddObject(module, "ParamValue_wstring", (PyObject *)&Dtool_ParamValue_std_wstring);
  Py_INCREF(Dtool_Ptr_ParamValue_std_wstring);
  PyModule_AddObject(module, "ParamValueWstring", (PyObject *)&Dtool_ParamValue_std_wstring);
  // typedef ParamValue< std::wstring > ParamWstring
  Dtool_PyModuleClassInit_ParamValue_std_wstring(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_std_wstring);
  PyModule_AddObject(module, "ParamWstring", (PyObject *)&Dtool_ParamValue_std_wstring);
  // ParamValue< LVecBase2d >
  Dtool_PyModuleClassInit_ParamValue_LVecBase2d(module);
  PyModule_AddObject(module, "ParamValue_LVecBase2d", (PyObject *)&Dtool_ParamValue_LVecBase2d);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase2d);
  PyModule_AddObject(module, "ParamValueLVecBase2d", (PyObject *)&Dtool_ParamValue_LVecBase2d);
  // typedef ParamValue< LVecBase2d > ParamVecBase2d
  Dtool_PyModuleClassInit_ParamValue_LVecBase2d(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase2d);
  PyModule_AddObject(module, "ParamVecBase2d", (PyObject *)&Dtool_ParamValue_LVecBase2d);
  // ParamValue< LVecBase2f >
  Dtool_PyModuleClassInit_ParamValue_LVecBase2f(module);
  PyModule_AddObject(module, "ParamValue_LVecBase2f", (PyObject *)&Dtool_ParamValue_LVecBase2f);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase2f);
  PyModule_AddObject(module, "ParamValueLVecBase2f", (PyObject *)&Dtool_ParamValue_LVecBase2f);
  // typedef ParamValue< LVecBase2f > ParamVecBase2f
  Dtool_PyModuleClassInit_ParamValue_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase2f);
  PyModule_AddObject(module, "ParamVecBase2f", (PyObject *)&Dtool_ParamValue_LVecBase2f);
  // ParamValue< LVecBase2i >
  Dtool_PyModuleClassInit_ParamValue_LVecBase2i(module);
  PyModule_AddObject(module, "ParamValue_LVecBase2i", (PyObject *)&Dtool_ParamValue_LVecBase2i);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase2i);
  PyModule_AddObject(module, "ParamValueLVecBase2i", (PyObject *)&Dtool_ParamValue_LVecBase2i);
  // typedef ParamValue< LVecBase2i > ParamVecBase2i
  Dtool_PyModuleClassInit_ParamValue_LVecBase2i(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase2i);
  PyModule_AddObject(module, "ParamVecBase2i", (PyObject *)&Dtool_ParamValue_LVecBase2i);
  // ParamValue< LVecBase3d >
  Dtool_PyModuleClassInit_ParamValue_LVecBase3d(module);
  PyModule_AddObject(module, "ParamValue_LVecBase3d", (PyObject *)&Dtool_ParamValue_LVecBase3d);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase3d);
  PyModule_AddObject(module, "ParamValueLVecBase3d", (PyObject *)&Dtool_ParamValue_LVecBase3d);
  // typedef ParamValue< LVecBase3d > ParamVecBase3d
  Dtool_PyModuleClassInit_ParamValue_LVecBase3d(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase3d);
  PyModule_AddObject(module, "ParamVecBase3d", (PyObject *)&Dtool_ParamValue_LVecBase3d);
  // ParamValue< LVecBase3f >
  Dtool_PyModuleClassInit_ParamValue_LVecBase3f(module);
  PyModule_AddObject(module, "ParamValue_LVecBase3f", (PyObject *)&Dtool_ParamValue_LVecBase3f);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase3f);
  PyModule_AddObject(module, "ParamValueLVecBase3f", (PyObject *)&Dtool_ParamValue_LVecBase3f);
  // typedef ParamValue< LVecBase3f > ParamVecBase3f
  Dtool_PyModuleClassInit_ParamValue_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase3f);
  PyModule_AddObject(module, "ParamVecBase3f", (PyObject *)&Dtool_ParamValue_LVecBase3f);
  // ParamValue< LVecBase3i >
  Dtool_PyModuleClassInit_ParamValue_LVecBase3i(module);
  PyModule_AddObject(module, "ParamValue_LVecBase3i", (PyObject *)&Dtool_ParamValue_LVecBase3i);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase3i);
  PyModule_AddObject(module, "ParamValueLVecBase3i", (PyObject *)&Dtool_ParamValue_LVecBase3i);
  // typedef ParamValue< LVecBase3i > ParamVecBase3i
  Dtool_PyModuleClassInit_ParamValue_LVecBase3i(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase3i);
  PyModule_AddObject(module, "ParamVecBase3i", (PyObject *)&Dtool_ParamValue_LVecBase3i);
  // ParamValue< LVecBase4d >
  Dtool_PyModuleClassInit_ParamValue_LVecBase4d(module);
  PyModule_AddObject(module, "ParamValue_LVecBase4d", (PyObject *)&Dtool_ParamValue_LVecBase4d);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase4d);
  PyModule_AddObject(module, "ParamValueLVecBase4d", (PyObject *)&Dtool_ParamValue_LVecBase4d);
  // typedef ParamValue< LVecBase4d > ParamVecBase4d
  Dtool_PyModuleClassInit_ParamValue_LVecBase4d(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase4d);
  PyModule_AddObject(module, "ParamVecBase4d", (PyObject *)&Dtool_ParamValue_LVecBase4d);
  // ParamValue< LVecBase4f >
  Dtool_PyModuleClassInit_ParamValue_LVecBase4f(module);
  PyModule_AddObject(module, "ParamValue_LVecBase4f", (PyObject *)&Dtool_ParamValue_LVecBase4f);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase4f);
  PyModule_AddObject(module, "ParamValueLVecBase4f", (PyObject *)&Dtool_ParamValue_LVecBase4f);
  // typedef ParamValue< LVecBase4f > ParamVecBase4f
  Dtool_PyModuleClassInit_ParamValue_LVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase4f);
  PyModule_AddObject(module, "ParamVecBase4f", (PyObject *)&Dtool_ParamValue_LVecBase4f);
  // ParamValue< LVecBase4i >
  Dtool_PyModuleClassInit_ParamValue_LVecBase4i(module);
  PyModule_AddObject(module, "ParamValue_LVecBase4i", (PyObject *)&Dtool_ParamValue_LVecBase4i);
  Py_INCREF(Dtool_Ptr_ParamValue_LVecBase4i);
  PyModule_AddObject(module, "ParamValueLVecBase4i", (PyObject *)&Dtool_ParamValue_LVecBase4i);
  // typedef ParamValue< LVecBase4i > ParamVecBase4i
  Dtool_PyModuleClassInit_ParamValue_LVecBase4i(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase4i);
  PyModule_AddObject(module, "ParamVecBase4i", (PyObject *)&Dtool_ParamValue_LVecBase4i);
  // ParamValue< LMatrix3d >
  Dtool_PyModuleClassInit_ParamValue_LMatrix3d(module);
  PyModule_AddObject(module, "ParamValue_LMatrix3d", (PyObject *)&Dtool_ParamValue_LMatrix3d);
  Py_INCREF(Dtool_Ptr_ParamValue_LMatrix3d);
  PyModule_AddObject(module, "ParamValueLMatrix3d", (PyObject *)&Dtool_ParamValue_LMatrix3d);
  // typedef ParamValue< LMatrix3d > ParamMatrix3d
  Dtool_PyModuleClassInit_ParamValue_LMatrix3d(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LMatrix3d);
  PyModule_AddObject(module, "ParamMatrix3d", (PyObject *)&Dtool_ParamValue_LMatrix3d);
  // ParamValue< LMatrix3f >
  Dtool_PyModuleClassInit_ParamValue_LMatrix3f(module);
  PyModule_AddObject(module, "ParamValue_LMatrix3f", (PyObject *)&Dtool_ParamValue_LMatrix3f);
  Py_INCREF(Dtool_Ptr_ParamValue_LMatrix3f);
  PyModule_AddObject(module, "ParamValueLMatrix3f", (PyObject *)&Dtool_ParamValue_LMatrix3f);
  // typedef ParamValue< LMatrix3f > ParamMatrix3f
  Dtool_PyModuleClassInit_ParamValue_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LMatrix3f);
  PyModule_AddObject(module, "ParamMatrix3f", (PyObject *)&Dtool_ParamValue_LMatrix3f);
  // ParamValue< LMatrix4d >
  Dtool_PyModuleClassInit_ParamValue_LMatrix4d(module);
  PyModule_AddObject(module, "ParamValue_LMatrix4d", (PyObject *)&Dtool_ParamValue_LMatrix4d);
  Py_INCREF(Dtool_Ptr_ParamValue_LMatrix4d);
  PyModule_AddObject(module, "ParamValueLMatrix4d", (PyObject *)&Dtool_ParamValue_LMatrix4d);
  // typedef ParamValue< LMatrix4d > ParamMatrix4d
  Dtool_PyModuleClassInit_ParamValue_LMatrix4d(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LMatrix4d);
  PyModule_AddObject(module, "ParamMatrix4d", (PyObject *)&Dtool_ParamValue_LMatrix4d);
  // ParamValue< LMatrix4f >
  Dtool_PyModuleClassInit_ParamValue_LMatrix4f(module);
  PyModule_AddObject(module, "ParamValue_LMatrix4f", (PyObject *)&Dtool_ParamValue_LMatrix4f);
  Py_INCREF(Dtool_Ptr_ParamValue_LMatrix4f);
  PyModule_AddObject(module, "ParamValueLMatrix4f", (PyObject *)&Dtool_ParamValue_LMatrix4f);
  // typedef ParamValue< LMatrix4f > ParamMatrix4f
  Dtool_PyModuleClassInit_ParamValue_LMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LMatrix4f);
  PyModule_AddObject(module, "ParamMatrix4f", (PyObject *)&Dtool_ParamValue_LMatrix4f);
  // typedef ParamValue< LVecBase2f > ParamVecBase2
  Dtool_PyModuleClassInit_ParamValue_LVecBase2f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase2f);
  PyModule_AddObject(module, "ParamVecBase2", (PyObject *)&Dtool_ParamValue_LVecBase2f);
  // typedef ParamValue< LVecBase3f > ParamVecBase3
  Dtool_PyModuleClassInit_ParamValue_LVecBase3f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase3f);
  PyModule_AddObject(module, "ParamVecBase3", (PyObject *)&Dtool_ParamValue_LVecBase3f);
  // typedef ParamValue< LVecBase4f > ParamVecBase4
  Dtool_PyModuleClassInit_ParamValue_LVecBase4f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LVecBase4f);
  PyModule_AddObject(module, "ParamVecBase4", (PyObject *)&Dtool_ParamValue_LVecBase4f);
  // typedef ParamValue< LMatrix3f > ParamMatrix3
  Dtool_PyModuleClassInit_ParamValue_LMatrix3f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LMatrix3f);
  PyModule_AddObject(module, "ParamMatrix3", (PyObject *)&Dtool_ParamValue_LMatrix3f);
  // typedef ParamValue< LMatrix4f > ParamMatrix4
  Dtool_PyModuleClassInit_ParamValue_LMatrix4f(module);
  Py_INCREF((PyObject *)&Dtool_ParamValue_LMatrix4f);
  PyModule_AddObject(module, "ParamMatrix4", (PyObject *)&Dtool_ParamValue_LMatrix4f);
  // WritableConfigurable
  Dtool_PyModuleClassInit_WritableConfigurable(module);
  PyModule_AddObject(module, "WritableConfigurable", (PyObject *)&Dtool_WritableConfigurable);
  // UniqueIdAllocator
  Dtool_PyModuleClassInit_UniqueIdAllocator(module);
  PyModule_AddObject(module, "UniqueIdAllocator", (PyObject *)&Dtool_UniqueIdAllocator);
  // typedef BitMask< uint32_t, 32 > PortalMask
  Dtool_PyModuleClassInit_BitMask_uint32_t_32(module);
  Py_INCREF((PyObject *)&Dtool_BitMask_uint32_t_32);
  PyModule_AddObject(module, "PortalMask", (PyObject *)&Dtool_BitMask_uint32_t_32);
}

static PyMethodDef python_simple_funcs[] = {
  {"parse_color_space_string", &Dtool_parse_color_space_string_663, METH_O, (const char *)Dtool_parse_color_space_string_663_comment},
  {"parseColorSpaceString", &Dtool_parse_color_space_string_663, METH_O, (const char *)Dtool_parse_color_space_string_663_comment},
  {"format_color_space", &Dtool_format_color_space_664, METH_O, (const char *)Dtool_format_color_space_664_comment},
  {"formatColorSpace", &Dtool_format_color_space_664, METH_O, (const char *)Dtool_format_color_space_664_comment},
  {"get_model_path", &Dtool_get_model_path_665, METH_NOARGS, (const char *)Dtool_get_model_path_665_comment},
  {"getModelPath", &Dtool_get_model_path_665, METH_NOARGS, (const char *)Dtool_get_model_path_665_comment},
  {"get_plugin_path", &Dtool_get_plugin_path_666, METH_NOARGS, (const char *)Dtool_get_plugin_path_666_comment},
  {"getPluginPath", &Dtool_get_plugin_path_666, METH_NOARGS, (const char *)Dtool_get_plugin_path_666_comment},
  {"load_prc_file", &Dtool_load_prc_file_900, METH_O, (const char *)Dtool_load_prc_file_900_comment},
  {"loadPrcFile", &Dtool_load_prc_file_900, METH_O, (const char *)Dtool_load_prc_file_900_comment},
  {"load_prc_file_data", (PyCFunction) &Dtool_load_prc_file_data_901, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_load_prc_file_data_901_comment},
  {"loadPrcFileData", (PyCFunction) &Dtool_load_prc_file_data_901, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_load_prc_file_data_901_comment},
  {"unload_prc_file", &Dtool_unload_prc_file_902, METH_O, (const char *)Dtool_unload_prc_file_902_comment},
  {"unloadPrcFile", &Dtool_unload_prc_file_902, METH_O, (const char *)Dtool_unload_prc_file_902_comment},
  {"hash_prc_variables", &Dtool_hash_prc_variables_903, METH_O, (const char *)Dtool_hash_prc_variables_903_comment},
  {"hashPrcVariables", &Dtool_hash_prc_variables_903, METH_O, (const char *)Dtool_hash_prc_variables_903_comment},
  {"py_decode_TypedWritable_from_bam_stream", (PyCFunction) &Dtool_py_decode_TypedWritable_from_bam_stream_1160, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_py_decode_TypedWritable_from_bam_stream_1160_comment},
  {"pyDecodeTypedWritableFromBamStream", (PyCFunction) &Dtool_py_decode_TypedWritable_from_bam_stream_1160, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_py_decode_TypedWritable_from_bam_stream_1160_comment},
  {"py_decode_TypedWritable_from_bam_stream_persist", (PyCFunction) &Dtool_py_decode_TypedWritable_from_bam_stream_persist_1161, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_py_decode_TypedWritable_from_bam_stream_persist_1161_comment},
  {"pyDecodeTypedWritableFromBamStreamPersist", (PyCFunction) &Dtool_py_decode_TypedWritable_from_bam_stream_persist_1161, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_py_decode_TypedWritable_from_bam_stream_persist_1161_comment},
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3putil_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3putil_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583612577,  /* file_identifier */
  "libp3putil",  /* library_name */
  "xqRv",  /* library_hash_name */
  "panda3d.core",  /* module_name */
  "libp3putil.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  2357  /* next_index */
};

Configure(_in_configure_libp3putil);
ConfigureFn(_in_configure_libp3putil) {
  interrogate_request_module(&_in_module_def);
}

