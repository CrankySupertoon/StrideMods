/*
 * This file was generated by:
 * built/bin/interrogate -srcdir panda/src/physics -Ipanda/src/physics -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__attribute__(x)= -D_LP64 -oc built/tmp/libp3physics_igate.cxx -od built/pandac/input/libp3physics.in -fnames -string -refcount -assert -python-native -Sbuilt/include/parser-inc -Ipanda/src/physics -Sbuilt/tmp -Sbuilt/include -S/usr/include/eigen3 -module panda3d.physics -library libp3physics actorNode.h angularEulerIntegrator.h angularForce.h angularIntegrator.h angularVectorForce.h baseForce.h baseIntegrator.h config_physics.h forceNode.h linearControlForce.h linearCylinderVortexForce.h linearDistanceForce.h linearEulerIntegrator.h linearForce.h linearFrictionForce.h linearIntegrator.h linearJitterForce.h linearNoiseForce.h linearRandomForce.h linearSinkForce.h linearSourceForce.h linearUserDefinedForce.h linearVectorForce.h p3physics_composite1.cxx p3physics_composite2.cxx physical.h physicalNode.h physicsCollisionHandler.h physicsManager.h physicsObject.h physicsObjectCollection.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "actorNode.h"
#include "angularEulerIntegrator.h"
#include "angularForce.h"
#include "angularIntegrator.h"
#include "angularVectorForce.h"
#include "baseForce.h"
#include "baseIntegrator.h"
#include "configVariableInt.h"
#include "config_physics.h"
#include "forceNode.h"
#include "linearControlForce.h"
#include "linearCylinderVortexForce.h"
#include "linearDistanceForce.h"
#include "linearEulerIntegrator.h"
#include "linearForce.h"
#include "linearFrictionForce.h"
#include "linearIntegrator.h"
#include "linearJitterForce.h"
#include "linearNoiseForce.h"
#include "linearRandomForce.h"
#include "linearSinkForce.h"
#include "linearSourceForce.h"
#include "linearUserDefinedForce.h"
#include "linearVectorForce.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "physical.h"
#include "physicalNode.h"
#include "physicsCollisionHandler.h"
#include "physicsManager.h"
#include "physicsObject.h"
#include "physicsObjectCollection.h"
#include "pvector.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class PhysicsObject
 */
typedef PhysicsObject PhysicsObject_localtype;
Define_Module_ClassRef(panda3d.physics, PhysicsObject, PhysicsObject_localtype, PhysicsObject);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PhysicsObject = &Dtool_PhysicsObject;
static void Dtool_PyModuleClassInit_PhysicsObject(PyObject *module);

/**
 * Forward declarations for top-level class PhysicsObjectCollection
 */
typedef PhysicsObjectCollection PhysicsObjectCollection_localtype;
Define_Module_Class(panda3d.physics, PhysicsObjectCollection, PhysicsObjectCollection_localtype, PhysicsObjectCollection);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PhysicsObjectCollection = &Dtool_PhysicsObjectCollection;
static void Dtool_PyModuleClassInit_PhysicsObjectCollection(PyObject *module);

/**
 * Forward declarations for top-level class BaseForce
 */
typedef BaseForce BaseForce_localtype;
Define_Module_ClassRef(panda3d.physics, BaseForce, BaseForce_localtype, BaseForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BaseForce = &Dtool_BaseForce;
static void Dtool_PyModuleClassInit_BaseForce(PyObject *module);

/**
 * Forward declarations for top-level class LinearForce
 */
typedef LinearForce LinearForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearForce, LinearForce_localtype, LinearForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearForce = &Dtool_LinearForce;
static void Dtool_PyModuleClassInit_LinearForce(PyObject *module);

/**
 * Forward declarations for top-level class AngularForce
 */
typedef AngularForce AngularForce_localtype;
Define_Module_ClassRef(panda3d.physics, AngularForce, AngularForce_localtype, AngularForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AngularForce = &Dtool_AngularForce;
static void Dtool_PyModuleClassInit_AngularForce(PyObject *module);

/**
 * Forward declarations for top-level class Physical
 */
typedef Physical Physical_localtype;
Define_Module_ClassRef(panda3d.physics, Physical, Physical_localtype, Physical);
static struct Dtool_PyTypedObject *const Dtool_Ptr_Physical = &Dtool_Physical;
static void Dtool_PyModuleClassInit_Physical(PyObject *module);

/**
 * Forward declarations for top-level class PhysicalNode
 */
typedef PhysicalNode PhysicalNode_localtype;
Define_Module_ClassRef(panda3d.physics, PhysicalNode, PhysicalNode_localtype, PhysicalNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PhysicalNode = &Dtool_PhysicalNode;
static void Dtool_PyModuleClassInit_PhysicalNode(PyObject *module);

/**
 * Forward declarations for top-level class ActorNode
 */
typedef ActorNode ActorNode_localtype;
Define_Module_ClassRef(panda3d.physics, ActorNode, ActorNode_localtype, ActorNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ActorNode = &Dtool_ActorNode;
static void Dtool_PyModuleClassInit_ActorNode(PyObject *module);

/**
 * Forward declarations for top-level class BaseIntegrator
 */
typedef BaseIntegrator BaseIntegrator_localtype;
Define_Module_ClassRef(panda3d.physics, BaseIntegrator, BaseIntegrator_localtype, BaseIntegrator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_BaseIntegrator = &Dtool_BaseIntegrator;
static void Dtool_PyModuleClassInit_BaseIntegrator(PyObject *module);

/**
 * Forward declarations for top-level class AngularIntegrator
 */
typedef AngularIntegrator AngularIntegrator_localtype;
Define_Module_ClassRef(panda3d.physics, AngularIntegrator, AngularIntegrator_localtype, AngularIntegrator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AngularIntegrator = &Dtool_AngularIntegrator;
static void Dtool_PyModuleClassInit_AngularIntegrator(PyObject *module);

/**
 * Forward declarations for top-level class AngularEulerIntegrator
 */
typedef AngularEulerIntegrator AngularEulerIntegrator_localtype;
Define_Module_ClassRef(panda3d.physics, AngularEulerIntegrator, AngularEulerIntegrator_localtype, AngularEulerIntegrator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AngularEulerIntegrator = &Dtool_AngularEulerIntegrator;
static void Dtool_PyModuleClassInit_AngularEulerIntegrator(PyObject *module);

/**
 * Forward declarations for top-level class AngularVectorForce
 */
typedef AngularVectorForce AngularVectorForce_localtype;
Define_Module_ClassRef(panda3d.physics, AngularVectorForce, AngularVectorForce_localtype, AngularVectorForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_AngularVectorForce = &Dtool_AngularVectorForce;
static void Dtool_PyModuleClassInit_AngularVectorForce(PyObject *module);

/**
 * Forward declarations for top-level class ForceNode
 */
typedef ForceNode ForceNode_localtype;
Define_Module_ClassRef(panda3d.physics, ForceNode, ForceNode_localtype, ForceNode);
static struct Dtool_PyTypedObject *const Dtool_Ptr_ForceNode = &Dtool_ForceNode;
static void Dtool_PyModuleClassInit_ForceNode(PyObject *module);

/**
 * Forward declarations for top-level class LinearControlForce
 */
typedef LinearControlForce LinearControlForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearControlForce, LinearControlForce_localtype, LinearControlForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearControlForce = &Dtool_LinearControlForce;
static void Dtool_PyModuleClassInit_LinearControlForce(PyObject *module);

/**
 * Forward declarations for top-level class LinearCylinderVortexForce
 */
typedef LinearCylinderVortexForce LinearCylinderVortexForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearCylinderVortexForce, LinearCylinderVortexForce_localtype, LinearCylinderVortexForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearCylinderVortexForce = &Dtool_LinearCylinderVortexForce;
static void Dtool_PyModuleClassInit_LinearCylinderVortexForce(PyObject *module);

/**
 * Forward declarations for top-level class LinearDistanceForce
 */
typedef LinearDistanceForce LinearDistanceForce_localtype;
Define_Module_ClassRef_Private(panda3d.physics, LinearDistanceForce, LinearDistanceForce_localtype, LinearDistanceForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearDistanceForce = &Dtool_LinearDistanceForce;
static void Dtool_PyModuleClassInit_LinearDistanceForce(PyObject *module);

/**
 * Forward declarations for top-level class LinearIntegrator
 */
typedef LinearIntegrator LinearIntegrator_localtype;
Define_Module_ClassRef(panda3d.physics, LinearIntegrator, LinearIntegrator_localtype, LinearIntegrator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearIntegrator = &Dtool_LinearIntegrator;
static void Dtool_PyModuleClassInit_LinearIntegrator(PyObject *module);

/**
 * Forward declarations for top-level class LinearEulerIntegrator
 */
typedef LinearEulerIntegrator LinearEulerIntegrator_localtype;
Define_Module_ClassRef(panda3d.physics, LinearEulerIntegrator, LinearEulerIntegrator_localtype, LinearEulerIntegrator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearEulerIntegrator = &Dtool_LinearEulerIntegrator;
static void Dtool_PyModuleClassInit_LinearEulerIntegrator(PyObject *module);

/**
 * Forward declarations for top-level class LinearFrictionForce
 */
typedef LinearFrictionForce LinearFrictionForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearFrictionForce, LinearFrictionForce_localtype, LinearFrictionForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearFrictionForce = &Dtool_LinearFrictionForce;
static void Dtool_PyModuleClassInit_LinearFrictionForce(PyObject *module);

/**
 * Forward declarations for top-level class LinearRandomForce
 */
typedef LinearRandomForce LinearRandomForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearRandomForce, LinearRandomForce_localtype, LinearRandomForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearRandomForce = &Dtool_LinearRandomForce;
static void Dtool_PyModuleClassInit_LinearRandomForce(PyObject *module);

/**
 * Forward declarations for top-level class LinearJitterForce
 */
typedef LinearJitterForce LinearJitterForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearJitterForce, LinearJitterForce_localtype, LinearJitterForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearJitterForce = &Dtool_LinearJitterForce;
static void Dtool_PyModuleClassInit_LinearJitterForce(PyObject *module);

/**
 * Forward declarations for top-level class LinearNoiseForce
 */
typedef LinearNoiseForce LinearNoiseForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearNoiseForce, LinearNoiseForce_localtype, LinearNoiseForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearNoiseForce = &Dtool_LinearNoiseForce;
static void Dtool_PyModuleClassInit_LinearNoiseForce(PyObject *module);

/**
 * Forward declarations for top-level class LinearSinkForce
 */
typedef LinearSinkForce LinearSinkForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearSinkForce, LinearSinkForce_localtype, LinearSinkForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearSinkForce = &Dtool_LinearSinkForce;
static void Dtool_PyModuleClassInit_LinearSinkForce(PyObject *module);

/**
 * Forward declarations for top-level class LinearSourceForce
 */
typedef LinearSourceForce LinearSourceForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearSourceForce, LinearSourceForce_localtype, LinearSourceForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearSourceForce = &Dtool_LinearSourceForce;
static void Dtool_PyModuleClassInit_LinearSourceForce(PyObject *module);

/**
 * Forward declarations for top-level class LinearUserDefinedForce
 */
typedef LinearUserDefinedForce LinearUserDefinedForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearUserDefinedForce, LinearUserDefinedForce_localtype, LinearUserDefinedForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearUserDefinedForce = &Dtool_LinearUserDefinedForce;
static void Dtool_PyModuleClassInit_LinearUserDefinedForce(PyObject *module);

/**
 * Forward declarations for top-level class LinearVectorForce
 */
typedef LinearVectorForce LinearVectorForce_localtype;
Define_Module_ClassRef(panda3d.physics, LinearVectorForce, LinearVectorForce_localtype, LinearVectorForce);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LinearVectorForce = &Dtool_LinearVectorForce;
static void Dtool_PyModuleClassInit_LinearVectorForce(PyObject *module);

/**
 * Forward declarations for top-level class PhysicsCollisionHandler
 */
typedef PhysicsCollisionHandler PhysicsCollisionHandler_localtype;
Define_Module_ClassRef(panda3d.physics, PhysicsCollisionHandler, PhysicsCollisionHandler_localtype, PhysicsCollisionHandler);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PhysicsCollisionHandler = &Dtool_PhysicsCollisionHandler;
static void Dtool_PyModuleClassInit_PhysicsCollisionHandler(PyObject *module);

/**
 * Forward declarations for top-level class PhysicsManager
 */
typedef PhysicsManager PhysicsManager_localtype;
Define_Module_Class(panda3d.physics, PhysicsManager, PhysicsManager_localtype, PhysicsManager);
static struct Dtool_PyTypedObject *const Dtool_Ptr_PhysicsManager = &Dtool_PhysicsManager;
static void Dtool_PyModuleClassInit_PhysicsManager(PyObject *module);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"PhysicsObject", &Dtool_PhysicsObject},
  {"PhysicsObjectCollection", &Dtool_PhysicsObjectCollection},
  {"BaseForce", &Dtool_BaseForce},
  {"LinearForce", &Dtool_LinearForce},
  {"AngularForce", &Dtool_AngularForce},
  {"Physical", &Dtool_Physical},
  {"PhysicalNode", &Dtool_PhysicalNode},
  {"ActorNode", &Dtool_ActorNode},
  {"BaseIntegrator", &Dtool_BaseIntegrator},
  {"AngularIntegrator", &Dtool_AngularIntegrator},
  {"AngularEulerIntegrator", &Dtool_AngularEulerIntegrator},
  {"AngularVectorForce", &Dtool_AngularVectorForce},
  {"ForceNode", &Dtool_ForceNode},
  {"LinearControlForce", &Dtool_LinearControlForce},
  {"LinearCylinderVortexForce", &Dtool_LinearCylinderVortexForce},
  {"LinearDistanceForce", &Dtool_LinearDistanceForce},
  {"LinearIntegrator", &Dtool_LinearIntegrator},
  {"LinearEulerIntegrator", &Dtool_LinearEulerIntegrator},
  {"LinearFrictionForce", &Dtool_LinearFrictionForce},
  {"LinearRandomForce", &Dtool_LinearRandomForce},
  {"LinearJitterForce", &Dtool_LinearJitterForce},
  {"LinearNoiseForce", &Dtool_LinearNoiseForce},
  {"LinearSinkForce", &Dtool_LinearSinkForce},
  {"LinearSourceForce", &Dtool_LinearSourceForce},
  {"LinearUserDefinedForce", &Dtool_LinearUserDefinedForce},
  {"LinearVectorForce", &Dtool_LinearVectorForce},
  {"PhysicsCollisionHandler", &Dtool_PhysicsCollisionHandler},
  {"PhysicsManager", &Dtool_PhysicsManager},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"std::ostream", nullptr},
#define Dtool_Ptr_std_ostream (imports[0].type)
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[1].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[2].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[3].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[4].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[5].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[6].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[7].type)
  {"LVector3f", nullptr},
#define Dtool_Ptr_LVector3f (imports[8].type)
  {"LPoint3f", nullptr},
#define Dtool_Ptr_LPoint3f (imports[9].type)
  {"LMatrix4f", nullptr},
#define Dtool_Ptr_LMatrix4f (imports[10].type)
  {"LRotationf", nullptr},
#define Dtool_Ptr_LRotationf (imports[11].type)
  {"LOrientationf", nullptr},
#define Dtool_Ptr_LOrientationf (imports[12].type)
  {"PandaNode", nullptr},
#define Dtool_Ptr_PandaNode (imports[13].type)
  {"NodePath", nullptr},
#define Dtool_Ptr_NodePath (imports[14].type)
  {"CollisionHandler", nullptr},
#define Dtool_Ptr_CollisionHandler (imports[15].type)
  {"CollisionHandlerEvent", nullptr},
#define Dtool_Ptr_CollisionHandlerEvent (imports[16].type)
  {"CollisionHandlerPhysical", nullptr},
#define Dtool_Ptr_CollisionHandlerPhysical (imports[17].type)
  {"CollisionHandlerPusher", nullptr},
#define Dtool_Ptr_CollisionHandlerPusher (imports[18].type)
  {nullptr, nullptr},
};
#endif

// std::ostream
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_std_ostream;
static struct Dtool_PyTypedObject *const Dtool_Ptr_std_ostream = &Dtool_std_ostream;
#endif
// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// LVector3f
#ifndef LINK_ALL_STATIC
inline static LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced) {
  nassertr(Dtool_Ptr_LVector3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector3f *(*)(PyObject *, LVector3f &))Dtool_Ptr_LVector3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector3f = &Dtool_LVector3f;
extern LVector3f *Dtool_Coerce_LVector3f(PyObject *args, LVector3f &coerced);
#endif
// LPoint3f
#ifndef LINK_ALL_STATIC
inline static LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced) {
  nassertr(Dtool_Ptr_LPoint3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint3f *(*)(PyObject *, LPoint3f &))Dtool_Ptr_LPoint3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint3f = &Dtool_LPoint3f;
extern LPoint3f *Dtool_Coerce_LPoint3f(PyObject *args, LPoint3f &coerced);
#endif
// LMatrix4f
#ifndef LINK_ALL_STATIC
inline static LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced) {
  nassertr(Dtool_Ptr_LMatrix4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LMatrix4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LMatrix4f *(*)(PyObject *, LMatrix4f &))Dtool_Ptr_LMatrix4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LMatrix4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LMatrix4f = &Dtool_LMatrix4f;
extern LMatrix4f *Dtool_Coerce_LMatrix4f(PyObject *args, LMatrix4f &coerced);
#endif
// LRotationf
#ifndef LINK_ALL_STATIC
inline static LRotationf *Dtool_Coerce_LRotationf(PyObject *args, LRotationf &coerced) {
  nassertr(Dtool_Ptr_LRotationf != nullptr, nullptr);
  nassertr(Dtool_Ptr_LRotationf->_Dtool_Coerce != nullptr, nullptr);
  return ((LRotationf *(*)(PyObject *, LRotationf &))Dtool_Ptr_LRotationf->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LRotationf;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LRotationf = &Dtool_LRotationf;
extern LRotationf *Dtool_Coerce_LRotationf(PyObject *args, LRotationf &coerced);
#endif
// LOrientationf
#ifndef LINK_ALL_STATIC
inline static LOrientationf *Dtool_Coerce_LOrientationf(PyObject *args, LOrientationf &coerced) {
  nassertr(Dtool_Ptr_LOrientationf != nullptr, nullptr);
  nassertr(Dtool_Ptr_LOrientationf->_Dtool_Coerce != nullptr, nullptr);
  return ((LOrientationf *(*)(PyObject *, LOrientationf &))Dtool_Ptr_LOrientationf->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LOrientationf;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LOrientationf = &Dtool_LOrientationf;
extern LOrientationf *Dtool_Coerce_LOrientationf(PyObject *args, LOrientationf &coerced);
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// NodePath
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_NodePath;
static struct Dtool_PyTypedObject *const Dtool_Ptr_NodePath = &Dtool_NodePath;
#endif
// CollisionHandler
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CollisionHandler;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandler = &Dtool_CollisionHandler;
#endif
// CollisionHandlerEvent
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CollisionHandlerEvent;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerEvent = &Dtool_CollisionHandlerEvent;
#endif
// CollisionHandlerPhysical
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CollisionHandlerPhysical;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerPhysical = &Dtool_CollisionHandlerPhysical;
#endif
// CollisionHandlerPusher
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CollisionHandlerPusher;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CollisionHandlerPusher = &Dtool_CollisionHandlerPusher;
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class PhysicsObject
 */
/**
 * Python function wrapper for:
 * void PhysicsObject::operator =(PhysicsObject const &other)
 */
static PyObject *Dtool_PhysicsObject_operator_4(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.assign")) {
    return nullptr;
  }
  // 1-void PhysicsObject::operator =(PhysicsObject const &other)
  PhysicsObject const *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 1, "PhysicsObject.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    PhysicsObject *return_value = local_this;
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PhysicsObject, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PhysicsObject self, const PhysicsObject other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_operator_4_comment =
  "C++ Interface:\n"
  "assign(const PhysicsObject self, const PhysicsObject other)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PhysicsObject_operator_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_active(bool flag)
 */
static PyObject *Dtool_PhysicsObject_set_active_5(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_active")) {
    return nullptr;
  }
  // 1-inline void PhysicsObject::set_active(bool flag)
  ((*local_this).set_active)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active(const PhysicsObject self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_active_5_comment =
  "C++ Interface:\n"
  "set_active(const PhysicsObject self, bool flag)\n"
  "\n"
  "/**\n"
  " * Process Flag assignment\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_active_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PhysicsObject::get_active(void) const
 */
static PyObject *Dtool_PhysicsObject_get_active_6(PyObject *self, PyObject *) {
  PhysicsObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObject)) {
    return nullptr;
  }
  // 1-inline bool PhysicsObject::get_active(void) const
  bool return_value = ((*(const PhysicsObject*)local_this).get_active)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_active_6_comment =
  "C++ Interface:\n"
  "get_active(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * Process Flag Query\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_active_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_mass(PN_stdfloat )
 */
static PyObject *Dtool_PhysicsObject_set_mass_7(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_mass")) {
    return nullptr;
  }
  // 1-inline void PhysicsObject::set_mass(PN_stdfloat )
  if (PyNumber_Check(arg)) {
    ((*local_this).set_mass)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mass(const PhysicsObject self, float param0)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_mass_7_comment =
  "C++ Interface:\n"
  "set_mass(const PhysicsObject self, float param0)\n"
  "\n"
  "/**\n"
  " * Set the mass in slugs (or kilograms).\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_mass_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PhysicsObject::get_mass(void) const
 */
static PyObject *Dtool_PhysicsObject_get_mass_8(PyObject *self, PyObject *) {
  PhysicsObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObject)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PhysicsObject::get_mass(void) const
  PN_stdfloat return_value = ((*(const PhysicsObject*)local_this).get_mass)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_mass_8_comment =
  "C++ Interface:\n"
  "get_mass(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * Get the mass in slugs (or kilograms).\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_mass_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_position(LPoint3 const &pos)
 * inline void PhysicsObject::set_position(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_PhysicsObject_set_position_9(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_position")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-inline void PhysicsObject::set_position(LPoint3 const &pos)
        LPoint3f arg_local;
        LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.set_position", "LPoint3f");
        }
        ((*local_this).set_position)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void PhysicsObject::set_position(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_position", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_position)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_position() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_position(const PhysicsObject self, const LPoint3f pos)\n"
      "set_position(const PhysicsObject self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_position_9_comment =
  "C++ Interface:\n"
  "set_position(const PhysicsObject self, const LPoint3f pos)\n"
  "set_position(const PhysicsObject self, float x, float y, float z)\n"
  "\n"
  "// INLINE void set_center_of_mass(const LPoint3 &pos); use set_position.\n"
  "\n"
  "/**\n"
  " * Vector position assignment.  This is also used as the center of mass.\n"
  " */\n"
  "\n"
  "/**\n"
  " * Piecewise position assignment\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_position_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 PhysicsObject::get_position(void) const
 */
static PyObject *Dtool_PhysicsObject_get_position_10(PyObject *self, PyObject *) {
  PhysicsObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObject)) {
    return nullptr;
  }
  // 1-inline LPoint3 PhysicsObject::get_position(void) const
  LPoint3 *return_value = new LPoint3(((*(const PhysicsObject*)local_this).get_position)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_position_10_comment =
  "C++ Interface:\n"
  "get_position(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * Position Query\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_position_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::reset_position(LPoint3 const &pos)
 */
static PyObject *Dtool_PhysicsObject_reset_position_11(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.reset_position")) {
    return nullptr;
  }
  // 1-inline void PhysicsObject::reset_position(LPoint3 const &pos)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.reset_position", "LPoint3f");
  }
  ((*local_this).reset_position)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reset_position(const PhysicsObject self, const LPoint3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_reset_position_11_comment =
  "C++ Interface:\n"
  "reset_position(const PhysicsObject self, const LPoint3f pos)\n"
  "\n"
  "/**\n"
  " * use this to place an object in a completely new position, that has nothing\n"
  " * to do with its last position.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_reset_position_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_last_position(LPoint3 const &pos)
 */
static PyObject *Dtool_PhysicsObject_set_last_position_12(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_last_position")) {
    return nullptr;
  }
  // 1-inline void PhysicsObject::set_last_position(LPoint3 const &pos)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.set_last_position", "LPoint3f");
  }
  ((*local_this).set_last_position)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_last_position(const PhysicsObject self, const LPoint3f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_last_position_12_comment =
  "C++ Interface:\n"
  "set_last_position(const PhysicsObject self, const LPoint3f pos)\n"
  "\n"
  "/**\n"
  " * Last position assignment\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_last_position_12_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 PhysicsObject::get_last_position(void) const
 */
static PyObject *Dtool_PhysicsObject_get_last_position_13(PyObject *self, PyObject *) {
  PhysicsObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObject)) {
    return nullptr;
  }
  // 1-inline LPoint3 PhysicsObject::get_last_position(void) const
  LPoint3 *return_value = new LPoint3(((*(const PhysicsObject*)local_this).get_last_position)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_last_position_13_comment =
  "C++ Interface:\n"
  "get_last_position(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * Get the position of the physics object at the start of the most recent\n"
  " * do_physics.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_last_position_13_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_velocity(LVector3 const &vel)
 * inline void PhysicsObject::set_velocity(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_PhysicsObject_set_velocity_14(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_velocity")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "vel")) {
        // 1-inline void PhysicsObject::set_velocity(LVector3 const &vel)
        LVector3f arg_local;
        LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.set_velocity", "LVector3f");
        }
        ((*local_this).set_velocity)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void PhysicsObject::set_velocity(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_velocity", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_velocity)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_velocity() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_velocity(const PhysicsObject self, const LVector3f vel)\n"
      "set_velocity(const PhysicsObject self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_velocity_14_comment =
  "C++ Interface:\n"
  "set_velocity(const PhysicsObject self, const LVector3f vel)\n"
  "set_velocity(const PhysicsObject self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * Vector velocity assignment\n"
  " */\n"
  "\n"
  "/**\n"
  " * Piecewise velocity assignment\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_velocity_14_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 PhysicsObject::get_velocity(void) const
 */
static PyObject *Dtool_PhysicsObject_get_velocity_15(PyObject *self, PyObject *) {
  PhysicsObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObject)) {
    return nullptr;
  }
  // 1-inline LVector3 PhysicsObject::get_velocity(void) const
  LVector3 *return_value = new LVector3(((*(const PhysicsObject*)local_this).get_velocity)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_velocity_15_comment =
  "C++ Interface:\n"
  "get_velocity(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * Velocity Query per second\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_velocity_15_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 PhysicsObject::get_implicit_velocity(void) const
 */
static PyObject *Dtool_PhysicsObject_get_implicit_velocity_16(PyObject *self, PyObject *) {
  PhysicsObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObject)) {
    return nullptr;
  }
  // 1-inline LVector3 PhysicsObject::get_implicit_velocity(void) const
  LVector3 *return_value = new LVector3(((*(const PhysicsObject*)local_this).get_implicit_velocity)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_implicit_velocity_16_comment =
  "C++ Interface:\n"
  "get_implicit_velocity(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * Velocity Query over the last dt\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_implicit_velocity_16_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::add_torque(LRotation const &torque)
 */
static PyObject *Dtool_PhysicsObject_add_torque_17(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.add_torque")) {
    return nullptr;
  }
  // 1-inline void PhysicsObject::add_torque(LRotation const &torque)
  LRotationf arg_local;
  LRotation const *arg_this = Dtool_Coerce_LRotationf(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.add_torque", "LRotationf");
  }
  ((*local_this).add_torque)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_torque(const PhysicsObject self, const LRotationf torque)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_add_torque_17_comment =
  "C++ Interface:\n"
  "add_torque(const PhysicsObject self, const LRotationf torque)\n"
  "\n"
  "// Global instantanious forces\n"
  "\n"
  "/**\n"
  " * Adds an torque force (i.e.  an instantanious change in velocity).  This is\n"
  " * a quicker way to get the angular velocity, add a vector to it and set that\n"
  " * value to be the new angular velocity.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_add_torque_17_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::add_impulse(LVector3 const &impulse)
 */
static PyObject *Dtool_PhysicsObject_add_impulse_18(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.add_impulse")) {
    return nullptr;
  }
  // 1-inline void PhysicsObject::add_impulse(LVector3 const &impulse)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.add_impulse", "LVector3f");
  }
  ((*local_this).add_impulse)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_impulse(const PhysicsObject self, const LVector3f impulse)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_add_impulse_18_comment =
  "C++ Interface:\n"
  "add_impulse(const PhysicsObject self, const LVector3f impulse)\n"
  "\n"
  "/**\n"
  " * Adds an impulse force (i.e.  an instantanious change in velocity).  This is\n"
  " * a quicker way to get the velocity, add a vector to it and set that value to\n"
  " * be the new velocity.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_add_impulse_18_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsObject::add_impact(LPoint3 const &offset_from_center_of_mass, LVector3 const &impulse)
 */
static PyObject *Dtool_PhysicsObject_add_impact_19(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.add_impact")) {
    return nullptr;
  }
  // 1-virtual void PhysicsObject::add_impact(LPoint3 const &offset_from_center_of_mass, LVector3 const &impulse)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"offset_from_center_of_mass", "impulse", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_impact", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PhysicsObject.add_impact", "LPoint3f");
    }
    LVector3f param2_local;
    LVector3 const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PhysicsObject.add_impact", "LVector3f");
    }
    ((*local_this).add_impact)(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_impact(const PhysicsObject self, const LPoint3f offset_from_center_of_mass, const LVector3f impulse)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_add_impact_19_comment =
  "C++ Interface:\n"
  "add_impact(const PhysicsObject self, const LPoint3f offset_from_center_of_mass, const LVector3f impulse)\n"
  "\n"
  "/**\n"
  " * Adds an impulse and/or torque (i.e.  an instantanious change in velocity)\n"
  " * based on how well the offset and impulse align with the center of mass (aka\n"
  " * position). If you wanted to immitate this function you could work out the\n"
  " * impulse and torque and call add_impulse and add_torque respectively.\n"
  " * offset and force are in global (or parent) coordinates.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_add_impact_19_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::add_local_torque(LRotation const &torque)
 */
static PyObject *Dtool_PhysicsObject_add_local_torque_20(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.add_local_torque")) {
    return nullptr;
  }
  // 1-inline void PhysicsObject::add_local_torque(LRotation const &torque)
  LRotationf arg_local;
  LRotation const *arg_this = Dtool_Coerce_LRotationf(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.add_local_torque", "LRotationf");
  }
  ((*local_this).add_local_torque)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_local_torque(const PhysicsObject self, const LRotationf torque)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_add_local_torque_20_comment =
  "C++ Interface:\n"
  "add_local_torque(const PhysicsObject self, const LRotationf torque)\n"
  "\n"
  "// Local instantanious forces\n"
  "\n"
  "/**\n"
  " * Adds an torque force (i.e.  an instantanious change in velocity).  This is\n"
  " * a quicker way to get the angular velocity, add a vector to it and set that\n"
  " * value to be the new angular velocity.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_add_local_torque_20_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::add_local_impulse(LVector3 const &impulse)
 */
static PyObject *Dtool_PhysicsObject_add_local_impulse_21(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.add_local_impulse")) {
    return nullptr;
  }
  // 1-inline void PhysicsObject::add_local_impulse(LVector3 const &impulse)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.add_local_impulse", "LVector3f");
  }
  ((*local_this).add_local_impulse)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_local_impulse(const PhysicsObject self, const LVector3f impulse)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_add_local_impulse_21_comment =
  "C++ Interface:\n"
  "add_local_impulse(const PhysicsObject self, const LVector3f impulse)\n"
  "\n"
  "/**\n"
  " * Adds an impulse force (i.e.  an instantanious change in velocity).  This is\n"
  " * a quicker way to get the velocity, add a vector to it and set that value to\n"
  " * be the new velocity.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_add_local_impulse_21_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsObject::add_local_impact(LPoint3 const &offset_from_center_of_mass, LVector3 const &impulse)
 */
static PyObject *Dtool_PhysicsObject_add_local_impact_22(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.add_local_impact")) {
    return nullptr;
  }
  // 1-virtual void PhysicsObject::add_local_impact(LPoint3 const &offset_from_center_of_mass, LVector3 const &impulse)
  PyObject *param1;
  PyObject *param2;
  static const char *keyword_list[] = {"offset_from_center_of_mass", "impulse", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:add_local_impact", (char **)keyword_list, &param1, &param2)) {
    LPoint3f param1_local;
    LPoint3 const *param1_this = Dtool_Coerce_LPoint3f(param1, param1_local);
    if (!(param1_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param1, 1, "PhysicsObject.add_local_impact", "LPoint3f");
    }
    LVector3f param2_local;
    LVector3 const *param2_this = Dtool_Coerce_LVector3f(param2, param2_local);
    if (!(param2_this != nullptr)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "PhysicsObject.add_local_impact", "LVector3f");
    }
    ((*local_this).add_local_impact)(*param1_this, *param2_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_local_impact(const PhysicsObject self, const LPoint3f offset_from_center_of_mass, const LVector3f impulse)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_add_local_impact_22_comment =
  "C++ Interface:\n"
  "add_local_impact(const PhysicsObject self, const LPoint3f offset_from_center_of_mass, const LVector3f impulse)\n"
  "\n"
  "/**\n"
  " * Adds an impulse and/or torque (i.e.  an instantanious change in velocity)\n"
  " * based on how well the offset and impulse align with the center of mass (aka\n"
  " * position). If you wanted to immitate this function you could work out the\n"
  " * impulse and torque and call add_impulse and add_torque respectively.\n"
  " * offset and force are in local coordinates.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_add_local_impact_22_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_terminal_velocity(PN_stdfloat tv)
 */
static PyObject *Dtool_PhysicsObject_set_terminal_velocity_23(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_terminal_velocity")) {
    return nullptr;
  }
  // 1-inline void PhysicsObject::set_terminal_velocity(PN_stdfloat tv)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_terminal_velocity)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_terminal_velocity(const PhysicsObject self, float tv)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_terminal_velocity_23_comment =
  "C++ Interface:\n"
  "set_terminal_velocity(const PhysicsObject self, float tv)\n"
  "\n"
  "/**\n"
  " * tv assignment\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_terminal_velocity_23_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PhysicsObject::get_terminal_velocity(void) const
 */
static PyObject *Dtool_PhysicsObject_get_terminal_velocity_24(PyObject *self, PyObject *) {
  PhysicsObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObject)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PhysicsObject::get_terminal_velocity(void) const
  PN_stdfloat return_value = ((*(const PhysicsObject*)local_this).get_terminal_velocity)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_terminal_velocity_24_comment =
  "C++ Interface:\n"
  "get_terminal_velocity(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * tv query\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_terminal_velocity_24_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_oriented(bool flag)
 */
static PyObject *Dtool_PhysicsObject_set_oriented_25(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_oriented")) {
    return nullptr;
  }
  // 1-inline void PhysicsObject::set_oriented(bool flag)
  ((*local_this).set_oriented)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_oriented(const PhysicsObject self, bool flag)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_oriented_25_comment =
  "C++ Interface:\n"
  "set_oriented(const PhysicsObject self, bool flag)\n"
  "\n"
  "/**\n"
  " * Set flag to determine whether this object should do any rotation or\n"
  " * orientation calculations.  Optimization.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_oriented_25_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool PhysicsObject::get_oriented(void) const
 */
static PyObject *Dtool_PhysicsObject_get_oriented_26(PyObject *self, PyObject *) {
  PhysicsObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObject)) {
    return nullptr;
  }
  // 1-inline bool PhysicsObject::get_oriented(void) const
  bool return_value = ((*(const PhysicsObject*)local_this).get_oriented)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_oriented_26_comment =
  "C++ Interface:\n"
  "get_oriented(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * See set_oriented().\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_oriented_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_orientation(LOrientation const &orientation)
 */
static PyObject *Dtool_PhysicsObject_set_orientation_27(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_orientation")) {
    return nullptr;
  }
  // 1-inline void PhysicsObject::set_orientation(LOrientation const &orientation)
  LOrientationf arg_local;
  LOrientation const *arg_this = Dtool_Coerce_LOrientationf(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.set_orientation", "LOrientationf");
  }
  ((*local_this).set_orientation)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_orientation(const PhysicsObject self, const LOrientationf orientation)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_orientation_27_comment =
  "C++ Interface:\n"
  "set_orientation(const PhysicsObject self, const LOrientationf orientation)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_orientation_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LOrientation PhysicsObject::get_orientation(void) const
 */
static PyObject *Dtool_PhysicsObject_get_orientation_28(PyObject *self, PyObject *) {
  PhysicsObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObject)) {
    return nullptr;
  }
  // 1-inline LOrientation PhysicsObject::get_orientation(void) const
  LOrientation *return_value = new LOrientation(((*(const PhysicsObject*)local_this).get_orientation)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LOrientationf, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_orientation_28_comment =
  "C++ Interface:\n"
  "get_orientation(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * get current orientation.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_orientation_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::reset_orientation(LOrientation const &orientation)
 */
static PyObject *Dtool_PhysicsObject_reset_orientation_29(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.reset_orientation")) {
    return nullptr;
  }
  // 1-inline void PhysicsObject::reset_orientation(LOrientation const &orientation)
  LOrientationf arg_local;
  LOrientation const *arg_this = Dtool_Coerce_LOrientationf(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.reset_orientation", "LOrientationf");
  }
  ((*local_this).reset_orientation)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "reset_orientation(const PhysicsObject self, const LOrientationf orientation)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_reset_orientation_29_comment =
  "C++ Interface:\n"
  "reset_orientation(const PhysicsObject self, const LOrientationf orientation)\n"
  "\n"
  "/**\n"
  " * set the orientation while clearing the rotation velocity.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_reset_orientation_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsObject::set_rotation(LRotation const &rotation)
 */
static PyObject *Dtool_PhysicsObject_set_rotation_30(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_rotation")) {
    return nullptr;
  }
  // 1-inline void PhysicsObject::set_rotation(LRotation const &rotation)
  LRotationf arg_local;
  LRotation const *arg_this = Dtool_Coerce_LRotationf(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "PhysicsObject.set_rotation", "LRotationf");
  }
  ((*local_this).set_rotation)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rotation(const PhysicsObject self, const LRotationf rotation)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_rotation_30_comment =
  "C++ Interface:\n"
  "set_rotation(const PhysicsObject self, const LRotationf rotation)\n"
  "\n"
  "/**\n"
  " * set rotation as a quaternion delta per second.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_set_rotation_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LRotation PhysicsObject::get_rotation(void) const
 */
static PyObject *Dtool_PhysicsObject_get_rotation_31(PyObject *self, PyObject *) {
  PhysicsObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObject)) {
    return nullptr;
  }
  // 1-inline LRotation PhysicsObject::get_rotation(void) const
  LRotation *return_value = new LRotation(((*(const PhysicsObject*)local_this).get_rotation)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LRotationf, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_rotation_31_comment =
  "C++ Interface:\n"
  "get_rotation(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * get rotation per second.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_rotation_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual LMatrix4 PhysicsObject::get_inertial_tensor(void) const
 */
static PyObject *Dtool_PhysicsObject_get_inertial_tensor_32(PyObject *self, PyObject *) {
  PhysicsObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObject)) {
    return nullptr;
  }
  // 1-virtual LMatrix4 PhysicsObject::get_inertial_tensor(void) const
  LMatrix4 *return_value = new LMatrix4(((*(const PhysicsObject*)local_this).get_inertial_tensor)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_inertial_tensor_32_comment =
  "C++ Interface:\n"
  "get_inertial_tensor(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * returns a transform matrix that represents the object's willingness to be\n"
  " * forced.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_inertial_tensor_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual LMatrix4 PhysicsObject::get_lcs(void) const
 */
static PyObject *Dtool_PhysicsObject_get_lcs_33(PyObject *self, PyObject *) {
  PhysicsObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObject)) {
    return nullptr;
  }
  // 1-virtual LMatrix4 PhysicsObject::get_lcs(void) const
  LMatrix4 *return_value = new LMatrix4(((*(const PhysicsObject*)local_this).get_lcs)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LMatrix4f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_lcs_33_comment =
  "C++ Interface:\n"
  "get_lcs(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * returns a transform matrix to this object's local coordinate system.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_get_lcs_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual PhysicsObject *PhysicsObject::make_copy(void) const
 */
static PyObject *Dtool_PhysicsObject_make_copy_34(PyObject *self, PyObject *) {
  PhysicsObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObject)) {
    return nullptr;
  }
  // 1-virtual PhysicsObject *PhysicsObject::make_copy(void) const
  PhysicsObject *return_value = ((*(const PhysicsObject*)local_this).make_copy)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PhysicsObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_make_copy_34_comment =
  "C++ Interface:\n"
  "make_copy(PhysicsObject self)\n"
  "\n"
  "/**\n"
  " * dynamic copy.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_make_copy_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsObject::set_name(std::string const &name)
 */
static PyObject *Dtool_PhysicsObject_set_name_35(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.set_name")) {
    return nullptr;
  }
  // 1-void PhysicsObject::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const PhysicsObject self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_set_name_35_comment =
  "C++ Interface:\n"
  "set_name(const PhysicsObject self, str name)\n";
#else
static const char *Dtool_PhysicsObject_set_name_35_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * std::string const &PhysicsObject::get_name(void)
 */
static PyObject *Dtool_PhysicsObject_get_name_36(PyObject *self, PyObject *) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObject, (void **)&local_this, "PhysicsObject.get_name")) {
    return nullptr;
  }
  // 1-std::string const &PhysicsObject::get_name(void)
  std::string const &return_value = ((*local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_name_36_comment =
  "C++ Interface:\n"
  "get_name(const PhysicsObject self)\n";
#else
static const char *Dtool_PhysicsObject_get_name_36_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsObject::output(std::ostream &out) const
 */
static PyObject *Dtool_PhysicsObject_output_37(PyObject *self, PyObject *arg) {
  PhysicsObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObject)) {
    return nullptr;
  }
  // 1-virtual void PhysicsObject::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PhysicsObject.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PhysicsObject*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PhysicsObject self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_output_37_comment =
  "C++ Interface:\n"
  "output(PhysicsObject self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_output_37_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsObject::write(std::ostream &out, int indent = 0) const
 */
static PyObject *Dtool_PhysicsObject_write_38(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObject)) {
    return nullptr;
  }
  // 1-virtual void PhysicsObject::write(std::ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "PhysicsObject.write", false, true);
    if (param1_this != nullptr) {
      ((*(const PhysicsObject*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(PhysicsObject self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_write_38_comment =
  "C++ Interface:\n"
  "write(PhysicsObject self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_PhysicsObject_write_38_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PhysicsObject::get_class_type(void)
 */
static PyObject *Dtool_PhysicsObject_get_class_type_39(PyObject *, PyObject *) {
  // 1-static TypeHandle PhysicsObject::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PhysicsObject::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObject_get_class_type_39_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PhysicsObject_get_class_type_39_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PhysicsObject::PhysicsObject(void)
 * PhysicsObject::PhysicsObject(PhysicsObject const &copy)
 */
static int Dtool_Init_PhysicsObject(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PhysicsObject::PhysicsObject(void)
      PhysicsObject *return_value = new PhysicsObject();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicsObject, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-PhysicsObject::PhysicsObject(PhysicsObject const &copy)
        PhysicsObject const *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 0, "PhysicsObject.PhysicsObject", true, true);
        if (arg_this != nullptr) {
          PhysicsObject *return_value = new PhysicsObject(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicsObject, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PhysicsObject() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PhysicsObject()\n"
      "PhysicsObject(const PhysicsObject copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PhysicsObject(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PhysicsObject) {
    printf("PhysicsObject ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PhysicsObject *local_this = (PhysicsObject *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PhysicsObject) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PhysicsObject(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PhysicsObject) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PhysicsObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PhysicsObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (PhysicsObject*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PhysicsObjectCollection
 */
/**
 * Python function wrapper for:
 * void PhysicsObjectCollection::operator =(PhysicsObjectCollection const &copy)
 */
static PyObject *Dtool_PhysicsObjectCollection_operator_42(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObjectCollection, (void **)&local_this, "PhysicsObjectCollection.assign")) {
    return nullptr;
  }
  // 1-void PhysicsObjectCollection::operator =(PhysicsObjectCollection const &copy)
  PhysicsObjectCollection const *arg_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObjectCollection, 1, "PhysicsObjectCollection.assign", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator =)(*arg_this);
    PhysicsObjectCollection *return_value = local_this;
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PhysicsObjectCollection, false, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "assign(const PhysicsObjectCollection self, const PhysicsObjectCollection copy)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_operator_42_comment =
  "C++ Interface:\n"
  "assign(const PhysicsObjectCollection self, const PhysicsObjectCollection copy)\n";
#else
static const char *Dtool_PhysicsObjectCollection_operator_42_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsObjectCollection::add_physics_object(PointerTo< PhysicsObject > physics_object)
 */
static PyObject *Dtool_PhysicsObjectCollection_add_physics_object_44(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObjectCollection, (void **)&local_this, "PhysicsObjectCollection.add_physics_object")) {
    return nullptr;
  }
  // 1-void PhysicsObjectCollection::add_physics_object(PointerTo< PhysicsObject > physics_object)
  PhysicsObject *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 1, "PhysicsObjectCollection.add_physics_object", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_physics_object)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_physics_object(const PhysicsObjectCollection self, PhysicsObject physics_object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_add_physics_object_44_comment =
  "C++ Interface:\n"
  "add_physics_object(const PhysicsObjectCollection self, PhysicsObject physics_object)\n"
  "\n"
  "/**\n"
  " * Adds a new PhysicsObject to the collection.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_add_physics_object_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PhysicsObjectCollection::remove_physics_object(PointerTo< PhysicsObject > physics_object)
 */
static PyObject *Dtool_PhysicsObjectCollection_remove_physics_object_45(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObjectCollection, (void **)&local_this, "PhysicsObjectCollection.remove_physics_object")) {
    return nullptr;
  }
  // 1-bool PhysicsObjectCollection::remove_physics_object(PointerTo< PhysicsObject > physics_object)
  PhysicsObject *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 1, "PhysicsObjectCollection.remove_physics_object", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*local_this).remove_physics_object)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_physics_object(const PhysicsObjectCollection self, PhysicsObject physics_object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_remove_physics_object_45_comment =
  "C++ Interface:\n"
  "remove_physics_object(const PhysicsObjectCollection self, PhysicsObject physics_object)\n"
  "\n"
  "/**\n"
  " * Removes the indicated PhysicsObject from the collection.  Returns true if\n"
  " * the physics_object was removed, false if it was not a member of the\n"
  " * collection.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_remove_physics_object_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsObjectCollection::add_physics_objects_from(PhysicsObjectCollection const &other)
 */
static PyObject *Dtool_PhysicsObjectCollection_add_physics_objects_from_46(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObjectCollection, (void **)&local_this, "PhysicsObjectCollection.add_physics_objects_from")) {
    return nullptr;
  }
  // 1-void PhysicsObjectCollection::add_physics_objects_from(PhysicsObjectCollection const &other)
  PhysicsObjectCollection const *arg_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObjectCollection, 1, "PhysicsObjectCollection.add_physics_objects_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_physics_objects_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_physics_objects_from(const PhysicsObjectCollection self, const PhysicsObjectCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_add_physics_objects_from_46_comment =
  "C++ Interface:\n"
  "add_physics_objects_from(const PhysicsObjectCollection self, const PhysicsObjectCollection other)\n"
  "\n"
  "/**\n"
  " * Adds all the PhysicsObjects indicated in the other collection to this\n"
  " * collection.  The other physics_objects are simply appended to the end of\n"
  " * the physics_objects in this list; duplicates are not automatically removed.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_add_physics_objects_from_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsObjectCollection::remove_physics_objects_from(PhysicsObjectCollection const &other)
 */
static PyObject *Dtool_PhysicsObjectCollection_remove_physics_objects_from_47(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObjectCollection, (void **)&local_this, "PhysicsObjectCollection.remove_physics_objects_from")) {
    return nullptr;
  }
  // 1-void PhysicsObjectCollection::remove_physics_objects_from(PhysicsObjectCollection const &other)
  PhysicsObjectCollection const *arg_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObjectCollection, 1, "PhysicsObjectCollection.remove_physics_objects_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_physics_objects_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_physics_objects_from(const PhysicsObjectCollection self, const PhysicsObjectCollection other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_remove_physics_objects_from_47_comment =
  "C++ Interface:\n"
  "remove_physics_objects_from(const PhysicsObjectCollection self, const PhysicsObjectCollection other)\n"
  "\n"
  "/**\n"
  " * Removes from this collection all of the PhysicsObjects listed in the other\n"
  " * collection.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_remove_physics_objects_from_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsObjectCollection::remove_duplicate_physics_objects(void)
 */
static PyObject *Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_48(PyObject *self, PyObject *) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObjectCollection, (void **)&local_this, "PhysicsObjectCollection.remove_duplicate_physics_objects")) {
    return nullptr;
  }
  // 1-void PhysicsObjectCollection::remove_duplicate_physics_objects(void)
  ((*local_this).remove_duplicate_physics_objects)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_48_comment =
  "C++ Interface:\n"
  "remove_duplicate_physics_objects(const PhysicsObjectCollection self)\n"
  "\n"
  "/**\n"
  " * Removes any duplicate entries of the same PhysicsObjects on this\n"
  " * collection.  If a PhysicsObject appears multiple times, the first\n"
  " * appearance is retained; subsequent appearances are removed.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PhysicsObjectCollection::has_physics_object(PointerTo< PhysicsObject > physics_object) const
 */
static PyObject *Dtool_PhysicsObjectCollection_has_physics_object_49(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObjectCollection)) {
    return nullptr;
  }
  // 1-bool PhysicsObjectCollection::has_physics_object(PointerTo< PhysicsObject > physics_object) const
  PhysicsObject *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 1, "PhysicsObjectCollection.has_physics_object", false, true);
  if (arg_this != nullptr) {
    bool return_value = ((*(const PhysicsObjectCollection*)local_this).has_physics_object)(arg_this);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_physics_object(PhysicsObjectCollection self, PhysicsObject physics_object)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_has_physics_object_49_comment =
  "C++ Interface:\n"
  "has_physics_object(PhysicsObjectCollection self, PhysicsObject physics_object)\n"
  "\n"
  "/**\n"
  " * Returns true if the indicated PhysicsObject appears in this collection,\n"
  " * false otherwise.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_has_physics_object_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsObjectCollection::clear(void)
 */
static PyObject *Dtool_PhysicsObjectCollection_clear_50(PyObject *self, PyObject *) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsObjectCollection, (void **)&local_this, "PhysicsObjectCollection.clear")) {
    return nullptr;
  }
  // 1-void PhysicsObjectCollection::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_clear_50_comment =
  "C++ Interface:\n"
  "clear(const PhysicsObjectCollection self)\n"
  "\n"
  "/**\n"
  " * Removes all PhysicsObjects from the collection.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_clear_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool PhysicsObjectCollection::is_empty(void) const
 */
static PyObject *Dtool_PhysicsObjectCollection_is_empty_51(PyObject *self, PyObject *) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObjectCollection)) {
    return nullptr;
  }
  // 1-bool PhysicsObjectCollection::is_empty(void) const
  bool return_value = ((*(const PhysicsObjectCollection*)local_this).is_empty)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_is_empty_51_comment =
  "C++ Interface:\n"
  "is_empty(PhysicsObjectCollection self)\n"
  "\n"
  "/**\n"
  " * Returns true if there are no PhysicsObjects in the collection, false\n"
  " * otherwise.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_is_empty_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int PhysicsObjectCollection::get_num_physics_objects(void) const
 */
static PyObject *Dtool_PhysicsObjectCollection_get_num_physics_objects_52(PyObject *self, PyObject *) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObjectCollection)) {
    return nullptr;
  }
  // 1-int PhysicsObjectCollection::get_num_physics_objects(void) const
  int return_value = ((*(const PhysicsObjectCollection*)local_this).get_num_physics_objects)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_get_num_physics_objects_52_comment =
  "C++ Interface:\n"
  "get_num_physics_objects(PhysicsObjectCollection self)\n"
  "\n"
  "/**\n"
  " * Returns the number of PhysicsObjects in the collection.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_get_num_physics_objects_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< PhysicsObject > PhysicsObjectCollection::get_physics_object(int index) const
 */
static PyObject *Dtool_PhysicsObjectCollection_get_physics_object_53(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObjectCollection)) {
    return nullptr;
  }
  // 1-PointerTo< PhysicsObject > PhysicsObjectCollection::get_physics_object(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< PhysicsObject > return_value = ((*(const PhysicsObjectCollection*)local_this).get_physics_object)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    PhysicsObject *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PhysicsObject, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_physics_object(PhysicsObjectCollection self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_get_physics_object_53_comment =
  "C++ Interface:\n"
  "get_physics_object(PhysicsObjectCollection self, int index)\n"
  "\n"
  "/**\n"
  " * Returns the nth PhysicsObject in the collection.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_get_physics_object_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsObjectCollection::output(std::ostream &out) const
 */
static PyObject *Dtool_PhysicsObjectCollection_output_59(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObjectCollection)) {
    return nullptr;
  }
  // 1-void PhysicsObjectCollection::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PhysicsObjectCollection.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PhysicsObjectCollection*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PhysicsObjectCollection self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_output_59_comment =
  "C++ Interface:\n"
  "output(PhysicsObjectCollection self, ostream out)\n"
  "\n"
  "/**\n"
  " * Writes a brief one-line description of the PhysicsObjectCollection to the\n"
  " * indicated output stream.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_output_59_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsObjectCollection::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_PhysicsObjectCollection_write_60(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsObjectCollection)) {
    return nullptr;
  }
  // 1-void PhysicsObjectCollection::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "PhysicsObjectCollection.write", false, true);
    if (param1_this != nullptr) {
      ((*(const PhysicsObjectCollection*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(PhysicsObjectCollection self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsObjectCollection_write_60_comment =
  "C++ Interface:\n"
  "write(PhysicsObjectCollection self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Writes a complete multi-line description of the PhysicsObjectCollection to\n"
  " * the indicated output stream.\n"
  " */";
#else
static const char *Dtool_PhysicsObjectCollection_write_60_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PhysicsObjectCollection::PhysicsObjectCollection(void)
 * PhysicsObjectCollection::PhysicsObjectCollection(PhysicsObjectCollection const &copy)
 */
static int Dtool_Init_PhysicsObjectCollection(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-PhysicsObjectCollection::PhysicsObjectCollection(void)
      PhysicsObjectCollection *return_value = new PhysicsObjectCollection();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicsObjectCollection, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-PhysicsObjectCollection::PhysicsObjectCollection(PhysicsObjectCollection const &copy)
        PhysicsObjectCollection const *arg_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObjectCollection, 0, "PhysicsObjectCollection.PhysicsObjectCollection", true, true);
        if (arg_this != nullptr) {
          PhysicsObjectCollection *return_value = new PhysicsObjectCollection(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicsObjectCollection, true, false);
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PhysicsObjectCollection() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PhysicsObjectCollection()\n"
      "PhysicsObjectCollection(const PhysicsObjectCollection copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PhysicsObjectCollection_get_physics_objects(PyObject *self, PyObject *) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObjectCollection, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_physics_objects)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PhysicsObjectCollection_get_physics_object_53(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PhysicsObjectCollection(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PhysicsObjectCollection) {
    printf("PhysicsObjectCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PhysicsObjectCollection *local_this = (PhysicsObjectCollection *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PhysicsObjectCollection) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PhysicsObjectCollection(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PhysicsObjectCollection) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BaseForce
 */
/**
 * Python function wrapper for:
 * inline bool BaseForce::get_active(void) const
 */
static PyObject *Dtool_BaseForce_get_active_62(PyObject *self, PyObject *) {
  BaseForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BaseForce)) {
    return nullptr;
  }
  // 1-inline bool BaseForce::get_active(void) const
  bool return_value = ((*(const BaseForce*)local_this).get_active)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BaseForce_get_active_62_comment =
  "C++ Interface:\n"
  "get_active(BaseForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_BaseForce_get_active_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void BaseForce::set_active(bool active)
 */
static PyObject *Dtool_BaseForce_set_active_63(PyObject *self, PyObject *arg) {
  BaseForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_BaseForce, (void **)&local_this, "BaseForce.set_active")) {
    return nullptr;
  }
  // 1-inline void BaseForce::set_active(bool active)
  ((*local_this).set_active)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_active(const BaseForce self, bool active)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BaseForce_set_active_63_comment =
  "C++ Interface:\n"
  "set_active(const BaseForce self, bool active)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_BaseForce_set_active_63_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual bool BaseForce::is_linear(void) const = 0
 */
static PyObject *Dtool_BaseForce_is_linear_64(PyObject *self, PyObject *) {
  BaseForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BaseForce)) {
    return nullptr;
  }
  // 1-virtual bool BaseForce::is_linear(void) const = 0
  bool return_value = ((*(const BaseForce*)local_this).is_linear)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_BaseForce_is_linear_64_comment =
  "C++ Interface:\n"
  "is_linear(BaseForce self)\n";
#else
static const char *Dtool_BaseForce_is_linear_64_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ForceNode *BaseForce::get_force_node(void) const
 */
static PyObject *Dtool_BaseForce_get_force_node_65(PyObject *self, PyObject *) {
  BaseForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BaseForce)) {
    return nullptr;
  }
  // 1-inline ForceNode *BaseForce::get_force_node(void) const
  ForceNode *return_value = ((*(const BaseForce*)local_this).get_force_node)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_ForceNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_BaseForce_get_force_node_65_comment =
  "C++ Interface:\n"
  "get_force_node(BaseForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_BaseForce_get_force_node_65_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath BaseForce::get_force_node_path(void) const
 */
static PyObject *Dtool_BaseForce_get_force_node_path_66(PyObject *self, PyObject *) {
  BaseForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BaseForce)) {
    return nullptr;
  }
  // 1-inline NodePath BaseForce::get_force_node_path(void) const
  NodePath *return_value = new NodePath(((*(const BaseForce*)local_this).get_force_node_path)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BaseForce_get_force_node_path_66_comment =
  "C++ Interface:\n"
  "get_force_node_path(BaseForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_BaseForce_get_force_node_path_66_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void BaseForce::output(std::ostream &out) const
 */
static PyObject *Dtool_BaseForce_output_67(PyObject *self, PyObject *arg) {
  BaseForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BaseForce)) {
    return nullptr;
  }
  // 1-virtual void BaseForce::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "BaseForce.output", false, true);
  if (arg_this != nullptr) {
    ((*(const BaseForce*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BaseForce self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BaseForce_output_67_comment =
  "C++ Interface:\n"
  "output(BaseForce self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseForce_output_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void BaseForce::write(std::ostream &out, int indent_level = 0) const
 */
static PyObject *Dtool_BaseForce_write_68(PyObject *self, PyObject *args, PyObject *kwds) {
  BaseForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BaseForce)) {
    return nullptr;
  }
  // 1-virtual void BaseForce::write(std::ostream &out, int indent_level = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent_level", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BaseForce.write", false, true);
    if (param1_this != nullptr) {
      ((*(const BaseForce*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BaseForce self, ostream out, int indent_level)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BaseForce_write_68_comment =
  "C++ Interface:\n"
  "write(BaseForce self, ostream out, int indent_level)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseForce_write_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle BaseForce::get_class_type(void)
 */
static PyObject *Dtool_BaseForce_get_class_type_69(PyObject *, PyObject *) {
  // 1-static TypeHandle BaseForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((BaseForce::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_BaseForce_get_class_type_69_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_BaseForce_get_class_type_69_comment = nullptr;
#endif

static int Dtool_Init_BaseForce(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_BaseForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BaseForce) {
    printf("BaseForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BaseForce *local_this = (BaseForce *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BaseForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BaseForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BaseForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (BaseForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (BaseForce*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LinearForce
 */
/**
 * Python function wrapper for:
 * inline void LinearForce::set_amplitude(PN_stdfloat const a)
 */
static PyObject *Dtool_LinearForce_set_amplitude_71(PyObject *self, PyObject *arg) {
  LinearForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearForce, (void **)&local_this, "LinearForce.set_amplitude")) {
    return nullptr;
  }
  // 1-inline void LinearForce::set_amplitude(PN_stdfloat const a)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_amplitude)((PN_stdfloat const)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_amplitude(const LinearForce self, float a)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_set_amplitude_71_comment =
  "C++ Interface:\n"
  "set_amplitude(const LinearForce self, float a)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearForce_set_amplitude_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LinearForce::set_mass_dependent(bool m)
 */
static PyObject *Dtool_LinearForce_set_mass_dependent_72(PyObject *self, PyObject *arg) {
  LinearForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearForce, (void **)&local_this, "LinearForce.set_mass_dependent")) {
    return nullptr;
  }
  // 1-inline void LinearForce::set_mass_dependent(bool m)
  ((*local_this).set_mass_dependent)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_mass_dependent(const LinearForce self, bool m)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_set_mass_dependent_72_comment =
  "C++ Interface:\n"
  "set_mass_dependent(const LinearForce self, bool m)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearForce_set_mass_dependent_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LinearForce::get_amplitude(void) const
 */
static PyObject *Dtool_LinearForce_get_amplitude_73(PyObject *self, PyObject *) {
  LinearForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LinearForce)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat LinearForce::get_amplitude(void) const
  PN_stdfloat return_value = ((*(const LinearForce*)local_this).get_amplitude)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_get_amplitude_73_comment =
  "C++ Interface:\n"
  "get_amplitude(LinearForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearForce_get_amplitude_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LinearForce::get_mass_dependent(void) const
 */
static PyObject *Dtool_LinearForce_get_mass_dependent_74(PyObject *self, PyObject *) {
  LinearForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LinearForce)) {
    return nullptr;
  }
  // 1-inline bool LinearForce::get_mass_dependent(void) const
  bool return_value = ((*(const LinearForce*)local_this).get_mass_dependent)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_get_mass_dependent_74_comment =
  "C++ Interface:\n"
  "get_mass_dependent(LinearForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearForce_get_mass_dependent_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LinearForce::set_vector_masks(bool x, bool y, bool z)
 */
static PyObject *Dtool_LinearForce_set_vector_masks_75(PyObject *self, PyObject *args, PyObject *kwds) {
  LinearForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearForce, (void **)&local_this, "LinearForce.set_vector_masks")) {
    return nullptr;
  }
  // 1-inline void LinearForce::set_vector_masks(bool x, bool y, bool z)
  PyObject *param1;
  PyObject *param2;
  PyObject *param3;
  static const char *keyword_list[] = {"x", "y", "z", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OOO:set_vector_masks", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_vector_masks)((PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0), (PyObject_IsTrue(param3) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vector_masks(const LinearForce self, bool x, bool y, bool z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_set_vector_masks_75_comment =
  "C++ Interface:\n"
  "set_vector_masks(const LinearForce self, bool x, bool y, bool z)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearForce_set_vector_masks_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 LinearForce::get_vector_masks(void)
 */
static PyObject *Dtool_LinearForce_get_vector_masks_76(PyObject *self, PyObject *) {
  LinearForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearForce, (void **)&local_this, "LinearForce.get_vector_masks")) {
    return nullptr;
  }
  // 1-inline LVector3 LinearForce::get_vector_masks(void)
  LVector3 *return_value = new LVector3(((*local_this).get_vector_masks)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_get_vector_masks_76_comment =
  "C++ Interface:\n"
  "get_vector_masks(const LinearForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearForce_get_vector_masks_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector3 LinearForce::get_vector(PhysicsObject const *po)
 */
static PyObject *Dtool_LinearForce_get_vector_77(PyObject *self, PyObject *arg) {
  LinearForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearForce, (void **)&local_this, "LinearForce.get_vector")) {
    return nullptr;
  }
  // 1-LVector3 LinearForce::get_vector(PhysicsObject const *po)
  PhysicsObject const *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 1, "LinearForce.get_vector", true, true);
  if (arg_this != nullptr) {
    LVector3 *return_value = new LVector3(((*local_this).get_vector)(arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_vector(const LinearForce self, const PhysicsObject po)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_get_vector_77_comment =
  "C++ Interface:\n"
  "get_vector(const LinearForce self, const PhysicsObject po)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearForce_get_vector_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual LinearForce *LinearForce::make_copy(void) = 0
 */
static PyObject *Dtool_LinearForce_make_copy_78(PyObject *self, PyObject *) {
  LinearForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearForce, (void **)&local_this, "LinearForce.make_copy")) {
    return nullptr;
  }
  // 1-virtual LinearForce *LinearForce::make_copy(void) = 0
  LinearForce *return_value = ((*local_this).make_copy)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_LinearForce, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_make_copy_78_comment =
  "C++ Interface:\n"
  "make_copy(const LinearForce self)\n";
#else
static const char *Dtool_LinearForce_make_copy_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LinearForce::get_class_type(void)
 */
static PyObject *Dtool_LinearForce_get_class_type_79(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LinearForce::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearForce_get_class_type_79_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearForce_get_class_type_79_comment = nullptr;
#endif

static int Dtool_Init_LinearForce(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LinearForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LinearForce) {
    printf("LinearForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LinearForce *local_this = (LinearForce *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LinearForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LinearForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearForce*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AngularForce
 */
/**
 * Python function wrapper for:
 * virtual AngularForce *AngularForce::make_copy(void) const = 0
 */
static PyObject *Dtool_AngularForce_make_copy_81(PyObject *self, PyObject *) {
  AngularForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AngularForce)) {
    return nullptr;
  }
  // 1-virtual AngularForce *AngularForce::make_copy(void) const = 0
  AngularForce *return_value = ((*(const AngularForce*)local_this).make_copy)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_AngularForce, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_AngularForce_make_copy_81_comment =
  "C++ Interface:\n"
  "make_copy(AngularForce self)\n";
#else
static const char *Dtool_AngularForce_make_copy_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LRotation AngularForce::get_quat(PhysicsObject const *po)
 */
static PyObject *Dtool_AngularForce_get_quat_82(PyObject *self, PyObject *arg) {
  AngularForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AngularForce, (void **)&local_this, "AngularForce.get_quat")) {
    return nullptr;
  }
  // 1-LRotation AngularForce::get_quat(PhysicsObject const *po)
  PhysicsObject const *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 1, "AngularForce.get_quat", true, true);
  if (arg_this != nullptr) {
    LRotation *return_value = new LRotation(((*local_this).get_quat)(arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LRotationf, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_quat(const AngularForce self, const PhysicsObject po)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AngularForce_get_quat_82_comment =
  "C++ Interface:\n"
  "get_quat(const AngularForce self, const PhysicsObject po)\n"
  "\n"
  "/**\n"
  " * access query\n"
  " */";
#else
static const char *Dtool_AngularForce_get_quat_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AngularForce::get_class_type(void)
 */
static PyObject *Dtool_AngularForce_get_class_type_83(PyObject *, PyObject *) {
  // 1-static TypeHandle AngularForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AngularForce::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AngularForce_get_class_type_83_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AngularForce_get_class_type_83_comment = nullptr;
#endif

static int Dtool_Init_AngularForce(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AngularForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AngularForce) {
    printf("AngularForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AngularForce *local_this = (AngularForce *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AngularForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AngularForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AngularForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (AngularForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AngularForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AngularForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AngularForce*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class Physical
 */
/**
 * Python function wrapper for:
 * inline PhysicsManager *Physical::get_physics_manager(void) const
 */
static PyObject *Dtool_Physical_get_physics_manager_86(PyObject *self, PyObject *) {
  Physical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Physical)) {
    return nullptr;
  }
  // 1-inline PhysicsManager *Physical::get_physics_manager(void) const
  PhysicsManager *return_value = ((*(const Physical*)local_this).get_physics_manager)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PhysicsManager, false, false);
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_physics_manager_86_comment =
  "C++ Interface:\n"
  "get_physics_manager(Physical self)\n"
  "\n"
  "// helpers\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_physics_manager_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PhysicalNode *Physical::get_physical_node(void) const
 */
static PyObject *Dtool_Physical_get_physical_node_87(PyObject *self, PyObject *) {
  Physical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Physical)) {
    return nullptr;
  }
  // 1-inline PhysicalNode *Physical::get_physical_node(void) const
  PhysicalNode *return_value = ((*(const Physical*)local_this).get_physical_node)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PhysicalNode, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_physical_node_87_comment =
  "C++ Interface:\n"
  "get_physical_node(Physical self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_physical_node_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline NodePath Physical::get_physical_node_path(void) const
 */
static PyObject *Dtool_Physical_get_physical_node_path_88(PyObject *self, PyObject *) {
  Physical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Physical)) {
    return nullptr;
  }
  // 1-inline NodePath Physical::get_physical_node_path(void) const
  NodePath *return_value = new NodePath(((*(const Physical*)local_this).get_physical_node_path)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_NodePath, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_physical_node_path_88_comment =
  "C++ Interface:\n"
  "get_physical_node_path(Physical self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_physical_node_path_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PhysicsObject *Physical::get_phys_body(void) const
 */
static PyObject *Dtool_Physical_get_phys_body_89(PyObject *self, PyObject *) {
  Physical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Physical)) {
    return nullptr;
  }
  // 1-inline PhysicsObject *Physical::get_phys_body(void) const
  PhysicsObject *return_value = ((*(const Physical*)local_this).get_phys_body)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PhysicsObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_phys_body_89_comment =
  "C++ Interface:\n"
  "get_phys_body(Physical self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_phys_body_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::clear_linear_forces(void)
 */
static PyObject *Dtool_Physical_clear_linear_forces_90(PyObject *self, PyObject *) {
  Physical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.clear_linear_forces")) {
    return nullptr;
  }
  // 1-inline void Physical::clear_linear_forces(void)
  ((*local_this).clear_linear_forces)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Physical_clear_linear_forces_90_comment =
  "C++ Interface:\n"
  "clear_linear_forces(const Physical self)\n"
  "\n"
  "/**\n"
  " * Erases the linear force list\n"
  " */";
#else
static const char *Dtool_Physical_clear_linear_forces_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::clear_angular_forces(void)
 */
static PyObject *Dtool_Physical_clear_angular_forces_91(PyObject *self, PyObject *) {
  Physical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.clear_angular_forces")) {
    return nullptr;
  }
  // 1-inline void Physical::clear_angular_forces(void)
  ((*local_this).clear_angular_forces)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Physical_clear_angular_forces_91_comment =
  "C++ Interface:\n"
  "clear_angular_forces(const Physical self)\n"
  "\n"
  "/**\n"
  " * Erases the angular force list\n"
  " */";
#else
static const char *Dtool_Physical_clear_angular_forces_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::clear_physics_objects(void)
 */
static PyObject *Dtool_Physical_clear_physics_objects_92(PyObject *self, PyObject *) {
  Physical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.clear_physics_objects")) {
    return nullptr;
  }
  // 1-inline void Physical::clear_physics_objects(void)
  ((*local_this).clear_physics_objects)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_Physical_clear_physics_objects_92_comment =
  "C++ Interface:\n"
  "clear_physics_objects(const Physical self)\n"
  "\n"
  "/**\n"
  " * Erases the object list\n"
  " */";
#else
static const char *Dtool_Physical_clear_physics_objects_92_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::add_linear_force(LinearForce *f)
 */
static PyObject *Dtool_Physical_add_linear_force_93(PyObject *self, PyObject *arg) {
  Physical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.add_linear_force")) {
    return nullptr;
  }
  // 1-inline void Physical::add_linear_force(LinearForce *f)
  LinearForce *arg_this = (LinearForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LinearForce, 1, "Physical.add_linear_force", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_linear_force)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_linear_force(const Physical self, LinearForce f)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Physical_add_linear_force_93_comment =
  "C++ Interface:\n"
  "add_linear_force(const Physical self, LinearForce f)\n"
  "\n"
  "/**\n"
  " * Adds a linear force to the force list\n"
  " */";
#else
static const char *Dtool_Physical_add_linear_force_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::add_angular_force(AngularForce *f)
 */
static PyObject *Dtool_Physical_add_angular_force_94(PyObject *self, PyObject *arg) {
  Physical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.add_angular_force")) {
    return nullptr;
  }
  // 1-inline void Physical::add_angular_force(AngularForce *f)
  AngularForce *arg_this = (AngularForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AngularForce, 1, "Physical.add_angular_force", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_angular_force)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_angular_force(const Physical self, AngularForce f)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Physical_add_angular_force_94_comment =
  "C++ Interface:\n"
  "add_angular_force(const Physical self, AngularForce f)\n"
  "\n"
  "/**\n"
  " * Adds an angular force to the force list\n"
  " */";
#else
static const char *Dtool_Physical_add_angular_force_94_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::add_physics_object(PhysicsObject *po)
 */
static PyObject *Dtool_Physical_add_physics_object_95(PyObject *self, PyObject *arg) {
  Physical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.add_physics_object")) {
    return nullptr;
  }
  // 1-inline void Physical::add_physics_object(PhysicsObject *po)
  PhysicsObject *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 1, "Physical.add_physics_object", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_physics_object)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_physics_object(const Physical self, PhysicsObject po)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Physical_add_physics_object_95_comment =
  "C++ Interface:\n"
  "add_physics_object(const Physical self, PhysicsObject po)\n"
  "\n"
  "/**\n"
  " * Adds an object to the physics object vector\n"
  " */";
#else
static const char *Dtool_Physical_add_physics_object_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::remove_linear_force(LinearForce *f)
 */
static PyObject *Dtool_Physical_remove_linear_force_96(PyObject *self, PyObject *arg) {
  Physical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.remove_linear_force")) {
    return nullptr;
  }
  // 1-inline void Physical::remove_linear_force(LinearForce *f)
  LinearForce *arg_this = (LinearForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LinearForce, 1, "Physical.remove_linear_force", false, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_linear_force)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_linear_force(const Physical self, LinearForce f)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Physical_remove_linear_force_96_comment =
  "C++ Interface:\n"
  "remove_linear_force(const Physical self, LinearForce f)\n"
  "\n"
  "/**\n"
  " * removes a linear force from the force list\n"
  " */";
#else
static const char *Dtool_Physical_remove_linear_force_96_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::remove_angular_force(AngularForce *f)
 */
static PyObject *Dtool_Physical_remove_angular_force_97(PyObject *self, PyObject *arg) {
  Physical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.remove_angular_force")) {
    return nullptr;
  }
  // 1-inline void Physical::remove_angular_force(AngularForce *f)
  AngularForce *arg_this = (AngularForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AngularForce, 1, "Physical.remove_angular_force", false, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_angular_force)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_angular_force(const Physical self, AngularForce f)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Physical_remove_angular_force_97_comment =
  "C++ Interface:\n"
  "remove_angular_force(const Physical self, AngularForce f)\n"
  "\n"
  "/**\n"
  " * removes an angular force from the force list\n"
  " */";
#else
static const char *Dtool_Physical_remove_angular_force_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Physical::get_num_linear_forces(void) const
 */
static PyObject *Dtool_Physical_get_num_linear_forces_98(PyObject *self, PyObject *) {
  Physical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Physical)) {
    return nullptr;
  }
  // 1-inline int Physical::get_num_linear_forces(void) const
  int return_value = ((*(const Physical*)local_this).get_num_linear_forces)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_num_linear_forces_98_comment =
  "C++ Interface:\n"
  "get_num_linear_forces(Physical self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_num_linear_forces_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< LinearForce > Physical::get_linear_force(int index) const
 */
static PyObject *Dtool_Physical_get_linear_force_99(PyObject *self, PyObject *arg) {
  Physical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Physical)) {
    return nullptr;
  }
  // 1-inline PointerTo< LinearForce > Physical::get_linear_force(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< LinearForce > return_value = ((*(const Physical*)local_this).get_linear_force)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    LinearForce *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_LinearForce, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_linear_force(Physical self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_linear_force_99_comment =
  "C++ Interface:\n"
  "get_linear_force(Physical self, int index)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_linear_force_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int Physical::get_num_angular_forces(void) const
 */
static PyObject *Dtool_Physical_get_num_angular_forces_101(PyObject *self, PyObject *) {
  Physical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Physical)) {
    return nullptr;
  }
  // 1-inline int Physical::get_num_angular_forces(void) const
  int return_value = ((*(const Physical*)local_this).get_num_angular_forces)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_num_angular_forces_101_comment =
  "C++ Interface:\n"
  "get_num_angular_forces(Physical self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_num_angular_forces_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< AngularForce > Physical::get_angular_force(int index) const
 */
static PyObject *Dtool_Physical_get_angular_force_102(PyObject *self, PyObject *arg) {
  Physical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Physical)) {
    return nullptr;
  }
  // 1-inline PointerTo< AngularForce > Physical::get_angular_force(int index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    PointerTo< AngularForce > return_value = ((*(const Physical*)local_this).get_angular_force)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    AngularForce *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_AngularForce, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_angular_force(Physical self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_angular_force_102_comment =
  "C++ Interface:\n"
  "get_angular_force(Physical self, int index)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_angular_force_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void Physical::set_viscosity(PN_stdfloat viscosity)
 */
static PyObject *Dtool_Physical_set_viscosity_104(PyObject *self, PyObject *arg) {
  Physical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_Physical, (void **)&local_this, "Physical.set_viscosity")) {
    return nullptr;
  }
  // 1-inline void Physical::set_viscosity(PN_stdfloat viscosity)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_viscosity)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_viscosity(const Physical self, float viscosity)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Physical_set_viscosity_104_comment =
  "C++ Interface:\n"
  "set_viscosity(const Physical self, float viscosity)\n"
  "\n"
  "/**\n"
  " * Set the local viscosity.\n"
  " */";
#else
static const char *Dtool_Physical_set_viscosity_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat Physical::get_viscosity(void) const
 */
static PyObject *Dtool_Physical_get_viscosity_105(PyObject *self, PyObject *) {
  Physical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Physical)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat Physical::get_viscosity(void) const
  PN_stdfloat return_value = ((*(const Physical*)local_this).get_viscosity)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_viscosity_105_comment =
  "C++ Interface:\n"
  "get_viscosity(Physical self)\n"
  "\n"
  "/**\n"
  " * Get the local viscosity.\n"
  " */";
#else
static const char *Dtool_Physical_get_viscosity_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PhysicsObjectCollection const Physical::get_objects(void) const
 */
static PyObject *Dtool_Physical_get_objects_106(PyObject *self, PyObject *) {
  Physical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Physical)) {
    return nullptr;
  }
  // 1-PhysicsObjectCollection const Physical::get_objects(void) const
  PhysicsObjectCollection const *return_value = new PhysicsObjectCollection const(((*(const Physical*)local_this).get_objects)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PhysicsObjectCollection, true, true);
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_objects_106_comment =
  "C++ Interface:\n"
  "get_objects(Physical self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_Physical_get_objects_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void Physical::output(std::ostream &out = ::std::cout) const
 */
static PyObject *Dtool_Physical_output_107(PyObject *self, PyObject *args, PyObject *kwds) {
  Physical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Physical)) {
    return nullptr;
  }
  // 1-virtual void Physical::output(std::ostream &out = ::std::cout) const
  PyObject *param1 = nullptr;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "out")) {
    std::ostream *param1_this;
    if (param1 == nullptr) {
      param1_this = &(std::cout);
    } else {
      param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "Physical.output", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*(const Physical*)local_this).output)(*param1_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(Physical self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Physical_output_107_comment =
  "C++ Interface:\n"
  "output(Physical self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_Physical_output_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void Physical::write_physics_objects(std::ostream &out = ::std::cout, int indent = 0) const
 */
static PyObject *Dtool_Physical_write_physics_objects_108(PyObject *self, PyObject *args, PyObject *kwds) {
  Physical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Physical)) {
    return nullptr;
  }
  // 1-virtual void Physical::write_physics_objects(std::ostream &out = ::std::cout, int indent = 0) const
  PyObject *param1 = nullptr;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|Oi:write_physics_objects", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this;
    if (param1 == nullptr) {
      param1_this = &(std::cout);
    } else {
      param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "Physical.write_physics_objects", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*(const Physical*)local_this).write_physics_objects)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_physics_objects(Physical self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Physical_write_physics_objects_108_comment =
  "C++ Interface:\n"
  "write_physics_objects(Physical self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_Physical_write_physics_objects_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void Physical::write_linear_forces(std::ostream &out = ::std::cout, int indent = 0) const
 */
static PyObject *Dtool_Physical_write_linear_forces_109(PyObject *self, PyObject *args, PyObject *kwds) {
  Physical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Physical)) {
    return nullptr;
  }
  // 1-virtual void Physical::write_linear_forces(std::ostream &out = ::std::cout, int indent = 0) const
  PyObject *param1 = nullptr;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|Oi:write_linear_forces", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this;
    if (param1 == nullptr) {
      param1_this = &(std::cout);
    } else {
      param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "Physical.write_linear_forces", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*(const Physical*)local_this).write_linear_forces)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_linear_forces(Physical self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Physical_write_linear_forces_109_comment =
  "C++ Interface:\n"
  "write_linear_forces(Physical self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_Physical_write_linear_forces_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void Physical::write_angular_forces(std::ostream &out = ::std::cout, int indent = 0) const
 */
static PyObject *Dtool_Physical_write_angular_forces_110(PyObject *self, PyObject *args, PyObject *kwds) {
  Physical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Physical)) {
    return nullptr;
  }
  // 1-virtual void Physical::write_angular_forces(std::ostream &out = ::std::cout, int indent = 0) const
  PyObject *param1 = nullptr;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|Oi:write_angular_forces", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this;
    if (param1 == nullptr) {
      param1_this = &(std::cout);
    } else {
      param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "Physical.write_angular_forces", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*(const Physical*)local_this).write_angular_forces)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_angular_forces(Physical self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Physical_write_angular_forces_110_comment =
  "C++ Interface:\n"
  "write_angular_forces(Physical self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_Physical_write_angular_forces_110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void Physical::write(std::ostream &out = ::std::cout, int indent = 0) const
 */
static PyObject *Dtool_Physical_write_111(PyObject *self, PyObject *args, PyObject *kwds) {
  Physical *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_Physical)) {
    return nullptr;
  }
  // 1-virtual void Physical::write(std::ostream &out = ::std::cout, int indent = 0) const
  PyObject *param1 = nullptr;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|Oi:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this;
    if (param1 == nullptr) {
      param1_this = &(std::cout);
    } else {
      param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "Physical.write", false, true);
    }
    if ((param1 == nullptr || param1_this != nullptr)) {
      ((*(const Physical*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(Physical self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_Physical_write_111_comment =
  "C++ Interface:\n"
  "write(Physical self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_Physical_write_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle Physical::get_class_type(void)
 */
static PyObject *Dtool_Physical_get_class_type_112(PyObject *, PyObject *) {
  // 1-static TypeHandle Physical::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((Physical::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_Physical_get_class_type_112_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_Physical_get_class_type_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Physical::Physical(Physical const &copy)
 * explicit Physical::Physical(int total_objects = 1, bool pre_alloc = false)
 */
static int Dtool_Init_Physical(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-explicit Physical::Physical(int total_objects, bool pre_alloc)
      Physical *return_value = new Physical();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Physical, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 explicit Physical::Physical(int total_objects, bool pre_alloc = false)
        int param0;
        PyObject *param1 = Py_False;
        static const char *keyword_list[] = {"total_objects", "pre_alloc", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "i|O:Physical", (char **)keyword_list, &param0, &param1)) {
          Physical *return_value = new Physical((int)param0, (PyObject_IsTrue(param1) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Physical, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 Physical::Physical(Physical const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          Physical const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_Physical);
          if (param0_this != nullptr) {
            Physical *return_value = new Physical(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_Physical, true, false);
          }
        }
      }

      // No coercion possible: explicit Physical::Physical(int total_objects, bool pre_alloc = false)
      // No coercion possible: Physical::Physical(Physical const &copy)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "Physical() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "Physical()\n"
      "Physical(int total_objects, bool pre_alloc)\n"
      "Physical(const Physical copy)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_Physical_get_linear_forces(PyObject *self, PyObject *) {
  Physical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_linear_forces)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_Physical_get_linear_force_99(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_Physical_get_angular_forces(PyObject *self, PyObject *) {
  Physical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_angular_forces)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_Physical_get_angular_force_102(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_Physical(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_Physical) {
    printf("Physical ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  Physical *local_this = (Physical *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_Physical) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_Physical(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_Physical) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (Physical*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (Physical*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (Physical*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PhysicalNode
 */
/**
 * Python function wrapper for:
 * inline void PhysicalNode::clear(void)
 */
static PyObject *Dtool_PhysicalNode_clear_116(PyObject *self, PyObject *) {
  PhysicalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicalNode, (void **)&local_this, "PhysicalNode.clear")) {
    return nullptr;
  }
  // 1-inline void PhysicalNode::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_clear_116_comment =
  "C++ Interface:\n"
  "clear(const PhysicalNode self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PhysicalNode_clear_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Physical *PhysicalNode::get_physical(std::size_t index) const
 */
static PyObject *Dtool_PhysicalNode_get_physical_117(PyObject *self, PyObject *arg) {
  PhysicalNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicalNode)) {
    return nullptr;
  }
  // 1-inline Physical *PhysicalNode::get_physical(std::size_t index) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    Physical *return_value = ((*(const PhysicalNode*)local_this).get_physical)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Physical, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_physical(PhysicalNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_get_physical_117_comment =
  "C++ Interface:\n"
  "get_physical(PhysicalNode self, int index)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PhysicalNode_get_physical_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t PhysicalNode::get_num_physicals(void) const
 */
static PyObject *Dtool_PhysicalNode_get_num_physicals_118(PyObject *self, PyObject *) {
  PhysicalNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicalNode)) {
    return nullptr;
  }
  // 1-inline std::size_t PhysicalNode::get_num_physicals(void) const
  std::size_t return_value = ((*(const PhysicalNode*)local_this).get_num_physicals)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_get_num_physicals_118_comment =
  "C++ Interface:\n"
  "get_num_physicals(PhysicalNode self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PhysicalNode_get_num_physicals_118_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicalNode::add_physical(Physical *physical)
 */
static PyObject *Dtool_PhysicalNode_add_physical_120(PyObject *self, PyObject *arg) {
  PhysicalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicalNode, (void **)&local_this, "PhysicalNode.add_physical")) {
    return nullptr;
  }
  // 1-inline void PhysicalNode::add_physical(Physical *physical)
  Physical *arg_this = (Physical *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Physical, 1, "PhysicalNode.add_physical", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_physical)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_physical(const PhysicalNode self, Physical physical)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_add_physical_120_comment =
  "C++ Interface:\n"
  "add_physical(const PhysicalNode self, Physical physical)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_PhysicalNode_add_physical_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicalNode::add_physicals_from(PhysicalNode const &other)
 */
static PyObject *Dtool_PhysicalNode_add_physicals_from_121(PyObject *self, PyObject *arg) {
  PhysicalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicalNode, (void **)&local_this, "PhysicalNode.add_physicals_from")) {
    return nullptr;
  }
  // 1-void PhysicalNode::add_physicals_from(PhysicalNode const &other)
  PhysicalNode const *arg_this = (PhysicalNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicalNode, 1, "PhysicalNode.add_physicals_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_physicals_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_physicals_from(const PhysicalNode self, const PhysicalNode other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_add_physicals_from_121_comment =
  "C++ Interface:\n"
  "add_physicals_from(const PhysicalNode self, const PhysicalNode other)\n"
  "\n"
  "/**\n"
  " * append operation\n"
  " */";
#else
static const char *Dtool_PhysicalNode_add_physicals_from_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicalNode::set_physical(std::size_t index, Physical *physical)
 */
static PyObject *Dtool_PhysicalNode_set_physical_122(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicalNode, (void **)&local_this, "PhysicalNode.set_physical")) {
    return nullptr;
  }
  // 1-void PhysicalNode::set_physical(std::size_t index, Physical *physical)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "physical", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_physical", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    Physical *param2_this = (Physical *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Physical, 2, "PhysicalNode.set_physical", false, true);
    if (param2_this != nullptr) {
      ((*local_this).set_physical)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_physical(const PhysicalNode self, int index, Physical physical)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_set_physical_122_comment =
  "C++ Interface:\n"
  "set_physical(const PhysicalNode self, int index, Physical physical)\n"
  "\n"
  "/**\n"
  " * replace operation\n"
  " */";
#else
static const char *Dtool_PhysicalNode_set_physical_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicalNode::insert_physical(std::size_t index, Physical *physical)
 */
static PyObject *Dtool_PhysicalNode_insert_physical_123(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicalNode, (void **)&local_this, "PhysicalNode.insert_physical")) {
    return nullptr;
  }
  // 1-void PhysicalNode::insert_physical(std::size_t index, Physical *physical)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "physical", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:insert_physical", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    Physical *param2_this = (Physical *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Physical, 2, "PhysicalNode.insert_physical", false, true);
    if (param2_this != nullptr) {
      ((*local_this).insert_physical)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "insert_physical(const PhysicalNode self, int index, Physical physical)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_insert_physical_123_comment =
  "C++ Interface:\n"
  "insert_physical(const PhysicalNode self, int index, Physical physical)\n"
  "\n"
  "/**\n"
  " * insert operation\n"
  " */";
#else
static const char *Dtool_PhysicalNode_insert_physical_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicalNode::remove_physical(Physical *physical)
 * void PhysicalNode::remove_physical(std::size_t index)
 */
static PyObject *Dtool_PhysicalNode_remove_physical_124(PyObject *self, PyObject *arg) {
  PhysicalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicalNode, (void **)&local_this, "PhysicalNode.remove_physical")) {
    return nullptr;
  }
  {
    // -2 void PhysicalNode::remove_physical(Physical *physical)
    Physical *arg_this = (Physical *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Physical, 1, "PhysicalNode.remove_physical", false, false);
    if (arg_this != nullptr) {
      ((*local_this).remove_physical)(arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void PhysicalNode::remove_physical(std::size_t index)
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return nullptr;
      }
#endif
      ((*local_this).remove_physical)(arg_val);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void PhysicalNode::remove_physical(Physical *physical)
  // No coercion possible: void PhysicalNode::remove_physical(std::size_t index)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_physical(const PhysicalNode self, Physical physical)\n"
      "remove_physical(const PhysicalNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_remove_physical_124_comment =
  "C++ Interface:\n"
  "remove_physical(const PhysicalNode self, Physical physical)\n"
  "remove_physical(const PhysicalNode self, int index)\n"
  "\n"
  "/**\n"
  " * remove operation\n"
  " */\n"
  "\n"
  "/**\n"
  " * remove operation\n"
  " */";
#else
static const char *Dtool_PhysicalNode_remove_physical_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PhysicalNode::get_class_type(void)
 */
static PyObject *Dtool_PhysicalNode_get_class_type_127(PyObject *, PyObject *) {
  // 1-static TypeHandle PhysicalNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PhysicalNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicalNode_get_class_type_127_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PhysicalNode_get_class_type_127_comment = nullptr;
#endif

/**
 * sequence length function for property PhysicalNode::physicals
 */
static Py_ssize_t Dtool_PhysicalNode_physicals_Len(PyObject *self) {
  PhysicalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicalNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_physicals)();
}

/**
 * sequence getter for property PhysicalNode::physicals
 */
static PyObject *Dtool_PhysicalNode_physicals_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  PhysicalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicalNode, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_physicals)()) {
    PyErr_SetString(PyExc_IndexError, "PhysicalNode.physicals[] index out of range");
    return nullptr;
  }
  // 1-inline Physical *PhysicalNode::get_physical(std::size_t index) const
  Physical *return_value = ((*(const PhysicalNode*)local_this).get_physical)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Physical, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_physical(PhysicalNode self, index)\n");
  }
}

static int Dtool_PhysicalNode_physicals_Sequence_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  PhysicalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicalNode, (void **)&local_this, "PhysicalNode.physicals")) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_physicals)()) {
    PyErr_SetString(PyExc_IndexError, "PhysicalNode.physicals[] index out of range");
    return -1;
  }
  if (arg == nullptr) {
    local_this->remove_physical(index);
    return 0;
  }
  // 1-void PhysicalNode::set_physical(std::size_t index, Physical *physical)
  Physical *arg_this = (Physical *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Physical, 2, "PhysicalNode.set_physical", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_physical)(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_physical(const PhysicalNode self, index, Physical physical)\n");
  }
  return -1;
}

static PyObject *Dtool_PhysicalNode_physicals_Sequence_insert(PyObject *self, size_t index, PyObject *arg) {
  PhysicalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicalNode, (void **)&local_this, "PhysicalNode.physicals")) {
    return nullptr;
  }

  // 1-void PhysicalNode::insert_physical(std::size_t index, Physical *physical)
  Physical *arg_this = (Physical *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Physical, 2, "PhysicalNode.insert_physical", false, true);
  if (arg_this != nullptr) {
    ((*local_this).insert_physical)(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "insert_physical(const PhysicalNode self, index, Physical physical)\n");
  }
  return nullptr;
}

static PyObject *Dtool_PhysicalNode_physicals_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MutableSequenceWrapper *wrap = Dtool_NewMutableSequenceWrapper(self, "PhysicalNode.physicals");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_PhysicalNode_physicals_Len;
    wrap->_getitem_func = &Dtool_PhysicalNode_physicals_Sequence_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_PhysicalNode_physicals_Sequence_Setitem;
      wrap->_insert_func = &Dtool_PhysicalNode_physicals_Sequence_insert;
    }
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * explicit PhysicalNode::PhysicalNode(std::string const &name)
 */
static int Dtool_Init_PhysicalNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PhysicalNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit PhysicalNode::PhysicalNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      PhysicalNode *return_value = new PhysicalNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicalNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PhysicalNode(str name)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_PhysicalNode_get_physicals(PyObject *self, PyObject *) {
  PhysicalNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicalNode, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_physicals)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_PhysicalNode_get_physical_117(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_PhysicalNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PhysicalNode) {
    printf("PhysicalNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PhysicalNode *local_this = (PhysicalNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PhysicalNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PhysicalNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PhysicalNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (PhysicalNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (PhysicalNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PhysicalNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PhysicalNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (PhysicalNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (PhysicalNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ActorNode
 */
/**
 * Python function wrapper for:
 * PhysicsObject *ActorNode::get_physics_object(void)
 */
static PyObject *Dtool_ActorNode_get_physics_object_130(PyObject *self, PyObject *) {
  ActorNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ActorNode, (void **)&local_this, "ActorNode.get_physics_object")) {
    return nullptr;
  }
  // 1-PhysicsObject *ActorNode::get_physics_object(void)
  PhysicsObject *return_value = ((*local_this).get_physics_object)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_PhysicsObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_ActorNode_get_physics_object_130_comment =
  "C++ Interface:\n"
  "get_physics_object(const ActorNode self)\n";
#else
static const char *Dtool_ActorNode_get_physics_object_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ActorNode::set_contact_vector(LVector3 const &contact_vector)
 */
static PyObject *Dtool_ActorNode_set_contact_vector_131(PyObject *self, PyObject *arg) {
  ActorNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ActorNode, (void **)&local_this, "ActorNode.set_contact_vector")) {
    return nullptr;
  }
  // 1-void ActorNode::set_contact_vector(LVector3 const &contact_vector)
  LVector3f arg_local;
  LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "ActorNode.set_contact_vector", "LVector3f");
  }
  ((*local_this).set_contact_vector)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_contact_vector(const ActorNode self, const LVector3f contact_vector)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ActorNode_set_contact_vector_131_comment =
  "C++ Interface:\n"
  "set_contact_vector(const ActorNode self, const LVector3f contact_vector)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ActorNode_set_contact_vector_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LVector3 const &ActorNode::get_contact_vector(void) const
 */
static PyObject *Dtool_ActorNode_get_contact_vector_132(PyObject *self, PyObject *) {
  ActorNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ActorNode)) {
    return nullptr;
  }
  // 1-LVector3 const &ActorNode::get_contact_vector(void) const
  LVector3 const *return_value = &(((*(const ActorNode*)local_this).get_contact_vector)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_ActorNode_get_contact_vector_132_comment =
  "C++ Interface:\n"
  "get_contact_vector(ActorNode self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_ActorNode_get_contact_vector_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ActorNode::update_transform(void)
 */
static PyObject *Dtool_ActorNode_update_transform_133(PyObject *self, PyObject *) {
  ActorNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ActorNode, (void **)&local_this, "ActorNode.update_transform")) {
    return nullptr;
  }
  // 1-void ActorNode::update_transform(void)
  ((*local_this).update_transform)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ActorNode_update_transform_133_comment =
  "C++ Interface:\n"
  "update_transform(const ActorNode self)\n"
  "\n"
  "// update the parent scene graph node with PhysicsObject information i.e.\n"
  "// copy from PhysicsObject to PandaNode\n"
  "\n"
  "/**\n"
  " * this sets the transform generated by the contained Physical, moving the\n"
  " * node and subsequent geometry.  i.e.  copy from PhysicsObject to PandaNode\n"
  " */";
#else
static const char *Dtool_ActorNode_update_transform_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ActorNode::set_transform_limit(PN_stdfloat limit)
 */
static PyObject *Dtool_ActorNode_set_transform_limit_134(PyObject *self, PyObject *arg) {
  ActorNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ActorNode, (void **)&local_this, "ActorNode.set_transform_limit")) {
    return nullptr;
  }
  // 1-void ActorNode::set_transform_limit(PN_stdfloat limit)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_transform_limit)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_transform_limit(const ActorNode self, float limit)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ActorNode_set_transform_limit_134_comment =
  "C++ Interface:\n"
  "set_transform_limit(const ActorNode self, float limit)\n";
#else
static const char *Dtool_ActorNode_set_transform_limit_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ActorNode::get_class_type(void)
 */
static PyObject *Dtool_ActorNode_get_class_type_135(PyObject *, PyObject *) {
  // 1-static TypeHandle ActorNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ActorNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ActorNode_get_class_type_135_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ActorNode_get_class_type_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ActorNode::ActorNode(ActorNode const &copy)
 * explicit ActorNode::ActorNode(std::string const &name = "")
 */
static int Dtool_Init_ActorNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-explicit ActorNode::ActorNode(std::string const &name)
      ActorNode *return_value = new ActorNode();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ActorNode, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 ActorNode::ActorNode(ActorNode const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          ActorNode const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_ActorNode);
          if (param0_this != nullptr) {
            ActorNode *return_value = new ActorNode(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ActorNode, true, false);
          }
        }
      }

      {
        // -2 explicit ActorNode::ActorNode(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:ActorNode", (char **)keyword_list, &param0_str, &param0_len)) {
          ActorNode *return_value = new ActorNode(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ActorNode, true, false);
        }
        PyErr_Clear();
      }

      // No coercion possible: ActorNode::ActorNode(ActorNode const &copy)
      // No coercion possible: explicit ActorNode::ActorNode(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "ActorNode() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ActorNode()\n"
      "ActorNode(const ActorNode copy)\n"
      "ActorNode(str name)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_ActorNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ActorNode) {
    printf("ActorNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ActorNode *local_this = (ActorNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ActorNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(PhysicalNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(PhysicalNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PhysicalNode) {
    return (PhysicalNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(PhysicalNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PhysicalNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(PhysicalNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(PhysicalNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ActorNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ActorNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ActorNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (ActorNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PhysicalNode) {
    PhysicalNode* other_this = (PhysicalNode*)from_this;
    return (ActorNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ActorNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ActorNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ActorNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ActorNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class BaseIntegrator
 */
/**
 * Python function wrapper for:
 * virtual void BaseIntegrator::output(std::ostream &out) const
 */
static PyObject *Dtool_BaseIntegrator_output_138(PyObject *self, PyObject *arg) {
  BaseIntegrator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BaseIntegrator)) {
    return nullptr;
  }
  // 1-virtual void BaseIntegrator::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "BaseIntegrator.output", false, true);
  if (arg_this != nullptr) {
    ((*(const BaseIntegrator*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(BaseIntegrator self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BaseIntegrator_output_138_comment =
  "C++ Interface:\n"
  "output(BaseIntegrator self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseIntegrator_output_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void BaseIntegrator::write_precomputed_linear_matrices(std::ostream &out, int indent = 0) const
 */
static PyObject *Dtool_BaseIntegrator_write_precomputed_linear_matrices_139(PyObject *self, PyObject *args, PyObject *kwds) {
  BaseIntegrator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BaseIntegrator)) {
    return nullptr;
  }
  // 1-virtual void BaseIntegrator::write_precomputed_linear_matrices(std::ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write_precomputed_linear_matrices", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BaseIntegrator.write_precomputed_linear_matrices", false, true);
    if (param1_this != nullptr) {
      ((*(const BaseIntegrator*)local_this).write_precomputed_linear_matrices)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_precomputed_linear_matrices(BaseIntegrator self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BaseIntegrator_write_precomputed_linear_matrices_139_comment =
  "C++ Interface:\n"
  "write_precomputed_linear_matrices(BaseIntegrator self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseIntegrator_write_precomputed_linear_matrices_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void BaseIntegrator::write_precomputed_angular_matrices(std::ostream &out, int indent = 0) const
 */
static PyObject *Dtool_BaseIntegrator_write_precomputed_angular_matrices_140(PyObject *self, PyObject *args, PyObject *kwds) {
  BaseIntegrator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BaseIntegrator)) {
    return nullptr;
  }
  // 1-virtual void BaseIntegrator::write_precomputed_angular_matrices(std::ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write_precomputed_angular_matrices", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BaseIntegrator.write_precomputed_angular_matrices", false, true);
    if (param1_this != nullptr) {
      ((*(const BaseIntegrator*)local_this).write_precomputed_angular_matrices)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_precomputed_angular_matrices(BaseIntegrator self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BaseIntegrator_write_precomputed_angular_matrices_140_comment =
  "C++ Interface:\n"
  "write_precomputed_angular_matrices(BaseIntegrator self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseIntegrator_write_precomputed_angular_matrices_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void BaseIntegrator::write(std::ostream &out, int indent = 0) const
 */
static PyObject *Dtool_BaseIntegrator_write_141(PyObject *self, PyObject *args, PyObject *kwds) {
  BaseIntegrator *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_BaseIntegrator)) {
    return nullptr;
  }
  // 1-virtual void BaseIntegrator::write(std::ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "BaseIntegrator.write", false, true);
    if (param1_this != nullptr) {
      ((*(const BaseIntegrator*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(BaseIntegrator self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_BaseIntegrator_write_141_comment =
  "C++ Interface:\n"
  "write(BaseIntegrator self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_BaseIntegrator_write_141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BaseIntegrator::BaseIntegrator(BaseIntegrator const &) = default
 */
static int Dtool_Init_BaseIntegrator(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("BaseIntegrator() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline BaseIntegrator::BaseIntegrator(BaseIntegrator const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    BaseIntegrator const *param0_this = (BaseIntegrator *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_BaseIntegrator, 0, "BaseIntegrator.BaseIntegrator", true, true);
    if (param0_this != nullptr) {
      BaseIntegrator *return_value = new BaseIntegrator(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_BaseIntegrator, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "BaseIntegrator(const BaseIntegrator param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_BaseIntegrator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_BaseIntegrator) {
    printf("BaseIntegrator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  BaseIntegrator *local_this = (BaseIntegrator *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_BaseIntegrator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_BaseIntegrator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_BaseIntegrator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (BaseIntegrator*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AngularIntegrator
 */
static int Dtool_Init_AngularIntegrator(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_AngularIntegrator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AngularIntegrator) {
    printf("AngularIntegrator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AngularIntegrator *local_this = (AngularIntegrator *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AngularIntegrator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseIntegrator) {
    return (BaseIntegrator *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseIntegrator *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AngularIntegrator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AngularIntegrator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseIntegrator) {
    BaseIntegrator* other_this = (BaseIntegrator*)from_this;
    return (AngularIntegrator*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AngularIntegrator*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AngularEulerIntegrator
 */
/**
 * Python function wrapper for:
 * AngularEulerIntegrator::AngularEulerIntegrator(void)
 */
static int Dtool_Init_AngularEulerIntegrator(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("AngularEulerIntegrator() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "AngularEulerIntegrator() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-AngularEulerIntegrator::AngularEulerIntegrator(void)
  AngularEulerIntegrator *return_value = new AngularEulerIntegrator();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AngularEulerIntegrator, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AngularEulerIntegrator()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AngularEulerIntegrator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AngularEulerIntegrator) {
    printf("AngularEulerIntegrator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AngularEulerIntegrator *local_this = (AngularEulerIntegrator *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AngularEulerIntegrator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AngularIntegrator) {
    return (AngularIntegrator *) local_this;
  }
  if (requested_type == Dtool_Ptr_BaseIntegrator) {
    return (BaseIntegrator *)(AngularIntegrator *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseIntegrator *)(AngularIntegrator *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AngularEulerIntegrator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AngularEulerIntegrator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AngularIntegrator) {
    AngularIntegrator* other_this = (AngularIntegrator*)from_this;
    return (AngularEulerIntegrator*)other_this;
  }
  if (from_type == Dtool_Ptr_BaseIntegrator) {
    BaseIntegrator* other_this = (BaseIntegrator*)from_this;
    return (AngularEulerIntegrator*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AngularEulerIntegrator*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class AngularVectorForce
 */
/**
 * Python function wrapper for:
 * inline void AngularVectorForce::set_quat(LRotation const &quat)
 */
static PyObject *Dtool_AngularVectorForce_set_quat_148(PyObject *self, PyObject *arg) {
  AngularVectorForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AngularVectorForce, (void **)&local_this, "AngularVectorForce.set_quat")) {
    return nullptr;
  }
  // 1-inline void AngularVectorForce::set_quat(LRotation const &quat)
  LRotationf arg_local;
  LRotation const *arg_this = Dtool_Coerce_LRotationf(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "AngularVectorForce.set_quat", "LRotationf");
  }
  ((*local_this).set_quat)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_quat(const AngularVectorForce self, const LRotationf quat)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AngularVectorForce_set_quat_148_comment =
  "C++ Interface:\n"
  "set_quat(const AngularVectorForce self, const LRotationf quat)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_AngularVectorForce_set_quat_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void AngularVectorForce::set_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
 */
static PyObject *Dtool_AngularVectorForce_set_hpr_149(PyObject *self, PyObject *args, PyObject *kwds) {
  AngularVectorForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_AngularVectorForce, (void **)&local_this, "AngularVectorForce.set_hpr")) {
    return nullptr;
  }
  // 1-inline void AngularVectorForce::set_hpr(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
  float param1;
  float param2;
  float param3;
  static const char *keyword_list[] = {"h", "p", "r", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_hpr", (char **)keyword_list, &param1, &param2, &param3)) {
    ((*local_this).set_hpr)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_hpr(const AngularVectorForce self, float h, float p, float r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_AngularVectorForce_set_hpr_149_comment =
  "C++ Interface:\n"
  "set_hpr(const AngularVectorForce self, float h, float p, float r)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_AngularVectorForce_set_hpr_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LRotation AngularVectorForce::get_local_quat(void) const
 */
static PyObject *Dtool_AngularVectorForce_get_local_quat_150(PyObject *self, PyObject *) {
  AngularVectorForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_AngularVectorForce)) {
    return nullptr;
  }
  // 1-inline LRotation AngularVectorForce::get_local_quat(void) const
  LRotation *return_value = new LRotation(((*(const AngularVectorForce*)local_this).get_local_quat)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LRotationf, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AngularVectorForce_get_local_quat_150_comment =
  "C++ Interface:\n"
  "get_local_quat(AngularVectorForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_AngularVectorForce_get_local_quat_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle AngularVectorForce::get_class_type(void)
 */
static PyObject *Dtool_AngularVectorForce_get_class_type_151(PyObject *, PyObject *) {
  // 1-static TypeHandle AngularVectorForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((AngularVectorForce::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_AngularVectorForce_get_class_type_151_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_AngularVectorForce_get_class_type_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * AngularVectorForce::AngularVectorForce(AngularVectorForce const &copy)
 * explicit AngularVectorForce::AngularVectorForce(LRotation const &quat)
 * explicit AngularVectorForce::AngularVectorForce(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
 */
static int Dtool_Init_AngularVectorForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 AngularVectorForce::AngularVectorForce(AngularVectorForce const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          AngularVectorForce const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_AngularVectorForce);
          if (param0_this != nullptr) {
            AngularVectorForce *return_value = new AngularVectorForce(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AngularVectorForce, true, false);
          }
        }
      }

      // No coercion possible: AngularVectorForce::AngularVectorForce(AngularVectorForce const &copy)
      {
        // -2 explicit AngularVectorForce::AngularVectorForce(LRotation const &quat)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "quat")) {
          LRotationf param0_local;
          LRotation const *param0_this = Dtool_Coerce_LRotationf(param0, param0_local);
          if ((param0_this != nullptr)) {
            AngularVectorForce *return_value = new AngularVectorForce(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AngularVectorForce, true, false);
          }
        }
      }

    }
    break;
  case 3:
    {
      // 1-explicit AngularVectorForce::AngularVectorForce(PN_stdfloat h, PN_stdfloat p, PN_stdfloat r)
      float param0;
      float param1;
      float param2;
      static const char *keyword_list[] = {"h", "p", "r", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:AngularVectorForce", (char **)keyword_list, &param0, &param1, &param2)) {
        AngularVectorForce *return_value = new AngularVectorForce((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_AngularVectorForce, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "AngularVectorForce() takes 1 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "AngularVectorForce(const AngularVectorForce copy)\n"
      "AngularVectorForce(float h, float p, float r)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_AngularVectorForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_AngularVectorForce) {
    printf("AngularVectorForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  AngularVectorForce *local_this = (AngularVectorForce *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_AngularVectorForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_AngularForce) {
    return (AngularForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(AngularForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(AngularForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(AngularForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(AngularForce *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_AngularVectorForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_AngularVectorForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_AngularForce) {
    AngularForce* other_this = (AngularForce*)from_this;
    return (AngularVectorForce*)other_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (AngularVectorForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (AngularVectorForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (AngularVectorForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (AngularVectorForce*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class ForceNode
 */
/**
 * Python function wrapper for:
 * inline void ForceNode::clear(void)
 */
static PyObject *Dtool_ForceNode_clear_154(PyObject *self, PyObject *) {
  ForceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ForceNode, (void **)&local_this, "ForceNode.clear")) {
    return nullptr;
  }
  // 1-inline void ForceNode::clear(void)
  ((*local_this).clear)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_clear_154_comment =
  "C++ Interface:\n"
  "clear(const ForceNode self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ForceNode_clear_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline BaseForce *ForceNode::get_force(std::size_t index) const
 */
static PyObject *Dtool_ForceNode_get_force_155(PyObject *self, PyObject *arg) {
  ForceNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ForceNode)) {
    return nullptr;
  }
  // 1-inline BaseForce *ForceNode::get_force(std::size_t index) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    BaseForce *return_value = ((*(const ForceNode*)local_this).get_force)(arg_val);
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BaseForce, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_force(ForceNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_get_force_155_comment =
  "C++ Interface:\n"
  "get_force(ForceNode self, int index)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ForceNode_get_force_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t ForceNode::get_num_forces(void) const
 */
static PyObject *Dtool_ForceNode_get_num_forces_156(PyObject *self, PyObject *) {
  ForceNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ForceNode)) {
    return nullptr;
  }
  // 1-inline std::size_t ForceNode::get_num_forces(void) const
  std::size_t return_value = ((*(const ForceNode*)local_this).get_num_forces)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_get_num_forces_156_comment =
  "C++ Interface:\n"
  "get_num_forces(ForceNode self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ForceNode_get_num_forces_156_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void ForceNode::add_force(BaseForce *force)
 */
static PyObject *Dtool_ForceNode_add_force_158(PyObject *self, PyObject *arg) {
  ForceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ForceNode, (void **)&local_this, "ForceNode.add_force")) {
    return nullptr;
  }
  // 1-inline void ForceNode::add_force(BaseForce *force)
  BaseForce *arg_this = (BaseForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BaseForce, 1, "ForceNode.add_force", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_force)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_force(const ForceNode self, BaseForce force)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_add_force_158_comment =
  "C++ Interface:\n"
  "add_force(const ForceNode self, BaseForce force)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_ForceNode_add_force_158_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ForceNode::add_forces_from(ForceNode const &other)
 */
static PyObject *Dtool_ForceNode_add_forces_from_159(PyObject *self, PyObject *arg) {
  ForceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ForceNode, (void **)&local_this, "ForceNode.add_forces_from")) {
    return nullptr;
  }
  // 1-void ForceNode::add_forces_from(ForceNode const &other)
  ForceNode const *arg_this = (ForceNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_ForceNode, 1, "ForceNode.add_forces_from", true, true);
  if (arg_this != nullptr) {
    ((*local_this).add_forces_from)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_forces_from(const ForceNode self, const ForceNode other)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_add_forces_from_159_comment =
  "C++ Interface:\n"
  "add_forces_from(const ForceNode self, const ForceNode other)\n"
  "\n"
  "/**\n"
  " * append operation\n"
  " */";
#else
static const char *Dtool_ForceNode_add_forces_from_159_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ForceNode::set_force(std::size_t index, BaseForce *force)
 */
static PyObject *Dtool_ForceNode_set_force_160(PyObject *self, PyObject *args, PyObject *kwds) {
  ForceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ForceNode, (void **)&local_this, "ForceNode.set_force")) {
    return nullptr;
  }
  // 1-void ForceNode::set_force(std::size_t index, BaseForce *force)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "force", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:set_force", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    BaseForce *param2_this = (BaseForce *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_BaseForce, 2, "ForceNode.set_force", false, true);
    if (param2_this != nullptr) {
      ((*local_this).set_force)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_force(const ForceNode self, int index, BaseForce force)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_set_force_160_comment =
  "C++ Interface:\n"
  "set_force(const ForceNode self, int index, BaseForce force)\n"
  "\n"
  "/**\n"
  " * replace operation\n"
  " */";
#else
static const char *Dtool_ForceNode_set_force_160_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ForceNode::insert_force(std::size_t index, BaseForce *force)
 */
static PyObject *Dtool_ForceNode_insert_force_161(PyObject *self, PyObject *args, PyObject *kwds) {
  ForceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ForceNode, (void **)&local_this, "ForceNode.insert_force")) {
    return nullptr;
  }
  // 1-void ForceNode::insert_force(std::size_t index, BaseForce *force)
  Py_ssize_t param1;
  PyObject *param2;
  static const char *keyword_list[] = {"index", "force", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nO:insert_force", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
    BaseForce *param2_this = (BaseForce *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_BaseForce, 2, "ForceNode.insert_force", false, true);
    if (param2_this != nullptr) {
      ((*local_this).insert_force)((std::size_t)param1, param2_this);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "insert_force(const ForceNode self, int index, BaseForce force)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_insert_force_161_comment =
  "C++ Interface:\n"
  "insert_force(const ForceNode self, int index, BaseForce force)\n"
  "\n"
  "/**\n"
  " * insert operation\n"
  " */";
#else
static const char *Dtool_ForceNode_insert_force_161_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void ForceNode::remove_force(BaseForce *force)
 * void ForceNode::remove_force(std::size_t index)
 */
static PyObject *Dtool_ForceNode_remove_force_162(PyObject *self, PyObject *arg) {
  ForceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ForceNode, (void **)&local_this, "ForceNode.remove_force")) {
    return nullptr;
  }
  {
    // -2 void ForceNode::remove_force(BaseForce *force)
    BaseForce *arg_this = (BaseForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BaseForce, 1, "ForceNode.remove_force", false, false);
    if (arg_this != nullptr) {
      ((*local_this).remove_force)(arg_this);
      return Dtool_Return_None();
    }
  }

  {
    // -2 void ForceNode::remove_force(std::size_t index)
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return nullptr;
      }
#endif
      ((*local_this).remove_force)(arg_val);
      return Dtool_Return_None();
    }
  }

  // No coercion possible: void ForceNode::remove_force(BaseForce *force)
  // No coercion possible: void ForceNode::remove_force(std::size_t index)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_force(const ForceNode self, BaseForce force)\n"
      "remove_force(const ForceNode self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_remove_force_162_comment =
  "C++ Interface:\n"
  "remove_force(const ForceNode self, BaseForce force)\n"
  "remove_force(const ForceNode self, int index)\n"
  "\n"
  "/**\n"
  " * remove operation\n"
  " */\n"
  "\n"
  "/**\n"
  " * remove operation\n"
  " */";
#else
static const char *Dtool_ForceNode_remove_force_162_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void ForceNode::write_forces(std::ostream &out, int indent = 0) const
 */
static PyObject *Dtool_ForceNode_write_forces_165(PyObject *self, PyObject *args, PyObject *kwds) {
  ForceNode *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_ForceNode)) {
    return nullptr;
  }
  // 1-virtual void ForceNode::write_forces(std::ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write_forces", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "ForceNode.write_forces", false, true);
    if (param1_this != nullptr) {
      ((*(const ForceNode*)local_this).write_forces)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_forces(ForceNode self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_write_forces_165_comment =
  "C++ Interface:\n"
  "write_forces(ForceNode self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_ForceNode_write_forces_165_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle ForceNode::get_class_type(void)
 */
static PyObject *Dtool_ForceNode_get_class_type_166(PyObject *, PyObject *) {
  // 1-static TypeHandle ForceNode::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((ForceNode::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_ForceNode_get_class_type_166_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_ForceNode_get_class_type_166_comment = nullptr;
#endif

/**
 * sequence length function for property ForceNode::forces
 */
static Py_ssize_t Dtool_ForceNode_forces_Len(PyObject *self) {
  ForceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ForceNode, (void **)&local_this)) {
    return -1;
  }
  return (Py_ssize_t)((*local_this).get_num_forces)();
}

/**
 * sequence getter for property ForceNode::forces
 */
static PyObject *Dtool_ForceNode_forces_Sequence_Getitem(PyObject *self, Py_ssize_t index) {
  ForceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ForceNode, (void **)&local_this)) {
    return nullptr;
  }
  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_forces)()) {
    PyErr_SetString(PyExc_IndexError, "ForceNode.forces[] index out of range");
    return nullptr;
  }
  // 1-inline BaseForce *ForceNode::get_force(std::size_t index) const
  BaseForce *return_value = ((*(const ForceNode*)local_this).get_force)(index);
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_BaseForce, true, false, return_value->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_force(ForceNode self, index)\n");
  }
}

static int Dtool_ForceNode_forces_Sequence_Setitem(PyObject *self, Py_ssize_t index, PyObject *arg) {
  ForceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ForceNode, (void **)&local_this, "ForceNode.forces")) {
    return -1;
  }

  if (index < 0 || index >= (Py_ssize_t)((*local_this).get_num_forces)()) {
    PyErr_SetString(PyExc_IndexError, "ForceNode.forces[] index out of range");
    return -1;
  }
  if (arg == nullptr) {
    local_this->remove_force(index);
    return 0;
  }
  // 1-void ForceNode::set_force(std::size_t index, BaseForce *force)
  BaseForce *arg_this = (BaseForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BaseForce, 2, "ForceNode.set_force", false, true);
  if (arg_this != nullptr) {
    ((*local_this).set_force)(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_force(const ForceNode self, index, BaseForce force)\n");
  }
  return -1;
}

static PyObject *Dtool_ForceNode_forces_Sequence_insert(PyObject *self, size_t index, PyObject *arg) {
  ForceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_ForceNode, (void **)&local_this, "ForceNode.forces")) {
    return nullptr;
  }

  // 1-void ForceNode::insert_force(std::size_t index, BaseForce *force)
  BaseForce *arg_this = (BaseForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_BaseForce, 2, "ForceNode.insert_force", false, true);
  if (arg_this != nullptr) {
    ((*local_this).insert_force)(index, arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(Py_None);
    return Py_None;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "insert_force(const ForceNode self, index, BaseForce force)\n");
  }
  return nullptr;
}

static PyObject *Dtool_ForceNode_forces_Getter(PyObject *self, void *) {
  nassertr(self != nullptr, nullptr);
  Dtool_MutableSequenceWrapper *wrap = Dtool_NewMutableSequenceWrapper(self, "ForceNode.forces");
  if (wrap != nullptr) {
    wrap->_len_func = &Dtool_ForceNode_forces_Len;
    wrap->_getitem_func = &Dtool_ForceNode_forces_Sequence_Getitem;
    if (!DtoolInstance_IS_CONST(self)) {
      wrap->_setitem_func = &Dtool_ForceNode_forces_Sequence_Setitem;
      wrap->_insert_func = &Dtool_ForceNode_forces_Sequence_insert;
    }
  }
  return (PyObject *)wrap;
}

/**
 * Python function wrapper for:
 * explicit ForceNode::ForceNode(std::string const &name)
 */
static int Dtool_Init_ForceNode(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "ForceNode() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "name")) {
    // 1-explicit ForceNode::ForceNode(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      ForceNode *return_value = new ForceNode(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_ForceNode, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "ForceNode(str name)\n");
  }
  return -1;
}

/*
 * Python make_seq wrapper
 */
static PyObject *MakeSeq_ForceNode_get_forces(PyObject *self, PyObject *) {
  ForceNode *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_ForceNode, (void **)&local_this)) {
    return nullptr;
  }
  Py_ssize_t count = (Py_ssize_t)((*local_this).get_num_forces)();
  PyObject *tuple = PyTuple_New(count);

  for (Py_ssize_t i = 0; i < count; ++i) {
    PyObject *index = Dtool_WrapValue(i);
    PyObject *value = Dtool_ForceNode_get_force_155(self, index);
    PyTuple_SET_ITEM(tuple, i, value);
    Py_DECREF(index);
  }

  if (Dtool_CheckErrorOccurred()) {
    Py_DECREF(tuple);
    return nullptr;
  }
  return tuple;
}

static void *Dtool_UpcastInterface_ForceNode(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_ForceNode) {
    printf("ForceNode ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  ForceNode *local_this = (ForceNode *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_ForceNode) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_ForceNode(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_ForceNode) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (ForceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (ForceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (ForceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (ForceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (ForceNode*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (ForceNode*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LinearControlForce
 */
/**
 * Python function wrapper for:
 * inline void LinearControlForce::clear_physics_object(void)
 */
static PyObject *Dtool_LinearControlForce_clear_physics_object_169(PyObject *self, PyObject *) {
  LinearControlForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearControlForce, (void **)&local_this, "LinearControlForce.clear_physics_object")) {
    return nullptr;
  }
  // 1-inline void LinearControlForce::clear_physics_object(void)
  ((*local_this).clear_physics_object)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LinearControlForce_clear_physics_object_169_comment =
  "C++ Interface:\n"
  "clear_physics_object(const LinearControlForce self)\n"
  "\n"
  "/**\n"
  " * encapsulating wrapper\n"
  " */";
#else
static const char *Dtool_LinearControlForce_clear_physics_object_169_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LinearControlForce::set_physics_object(PhysicsObject const *po)
 */
static PyObject *Dtool_LinearControlForce_set_physics_object_170(PyObject *self, PyObject *arg) {
  LinearControlForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearControlForce, (void **)&local_this, "LinearControlForce.set_physics_object")) {
    return nullptr;
  }
  // 1-inline void LinearControlForce::set_physics_object(PhysicsObject const *po)
  PhysicsObject const *arg_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObject, 1, "LinearControlForce.set_physics_object", true, true);
  if (arg_this != nullptr) {
    ((*local_this).set_physics_object)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_physics_object(const LinearControlForce self, const PhysicsObject po)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LinearControlForce_set_physics_object_170_comment =
  "C++ Interface:\n"
  "set_physics_object(const LinearControlForce self, const PhysicsObject po)\n"
  "\n"
  "/**\n"
  " * encapsulating wrapper\n"
  " */";
#else
static const char *Dtool_LinearControlForce_set_physics_object_170_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline ConstPointerTo< PhysicsObject > LinearControlForce::get_physics_object(void) const
 */
static PyObject *Dtool_LinearControlForce_get_physics_object_171(PyObject *self, PyObject *) {
  LinearControlForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LinearControlForce)) {
    return nullptr;
  }
  // 1-inline ConstPointerTo< PhysicsObject > LinearControlForce::get_physics_object(void) const
  ConstPointerTo< PhysicsObject > return_value = ((*(const LinearControlForce*)local_this).get_physics_object)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  PhysicsObject const *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PhysicsObject, true, true, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LinearControlForce_get_physics_object_171_comment =
  "C++ Interface:\n"
  "get_physics_object(LinearControlForce self)\n"
  "\n"
  "/**\n"
  " * piecewise encapsulating wrapper\n"
  " */";
#else
static const char *Dtool_LinearControlForce_get_physics_object_171_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LinearControlForce::set_vector(LVector3 const &v)
 * inline void LinearControlForce::set_vector(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_LinearControlForce_set_vector_172(PyObject *self, PyObject *args, PyObject *kwds) {
  LinearControlForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearControlForce, (void **)&local_this, "LinearControlForce.set_vector")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "v")) {
        // 1-inline void LinearControlForce::set_vector(LVector3 const &v)
        LVector3f arg_local;
        LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "LinearControlForce.set_vector", "LVector3f");
        }
        ((*local_this).set_vector)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void LinearControlForce::set_vector(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_vector", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_vector)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_vector() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vector(const LinearControlForce self, const LVector3f v)\n"
      "set_vector(const LinearControlForce self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LinearControlForce_set_vector_172_comment =
  "C++ Interface:\n"
  "set_vector(const LinearControlForce self, const LVector3f v)\n"
  "set_vector(const LinearControlForce self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * encapsulating wrapper\n"
  " */\n"
  "\n"
  "/**\n"
  " * piecewise encapsulating wrapper\n"
  " */";
#else
static const char *Dtool_LinearControlForce_set_vector_172_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 LinearControlForce::get_local_vector(void) const
 */
static PyObject *Dtool_LinearControlForce_get_local_vector_173(PyObject *self, PyObject *) {
  LinearControlForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LinearControlForce)) {
    return nullptr;
  }
  // 1-inline LVector3 LinearControlForce::get_local_vector(void) const
  LVector3 *return_value = new LVector3(((*(const LinearControlForce*)local_this).get_local_vector)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearControlForce_get_local_vector_173_comment =
  "C++ Interface:\n"
  "get_local_vector(LinearControlForce self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LinearControlForce_get_local_vector_173_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LinearControlForce::get_class_type(void)
 */
static PyObject *Dtool_LinearControlForce_get_class_type_174(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearControlForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LinearControlForce::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearControlForce_get_class_type_174_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearControlForce_get_class_type_174_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LinearControlForce::LinearControlForce(LinearControlForce const &copy)
 * explicit LinearControlForce::LinearControlForce(PhysicsObject const *po = 0, PN_stdfloat a = 1.0, bool mass = false)
 */
static int Dtool_Init_LinearControlForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-explicit LinearControlForce::LinearControlForce(PhysicsObject const *po, PN_stdfloat a, bool mass)
      LinearControlForce *return_value = new LinearControlForce();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearControlForce, true, false);
    }
    break;
  case 1:
  case 2:
  case 3:
    {
      {
        // -2 explicit LinearControlForce::LinearControlForce(PhysicsObject const *po, PN_stdfloat a = 1.0, bool mass = false)
        PyObject *param0;
        float param1 = 1.0;
        PyObject *param2 = Py_False;
        static const char *keyword_list[] = {"po", "a", "mass", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|fO:LinearControlForce", (char **)keyword_list, &param0, &param1, &param2)) {
          PhysicsObject const *param0_this = nullptr;
          if (param0 != Py_None) {
            param0_this = nullptr;
            DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_PhysicsObject);
          }
          if ((param0 == Py_None || param0_this != nullptr)) {
            LinearControlForce *return_value = new LinearControlForce(param0_this, (PN_stdfloat)param1, (PyObject_IsTrue(param2) != 0));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearControlForce, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LinearControlForce::LinearControlForce(LinearControlForce const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          LinearControlForce const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LinearControlForce);
          if (param0_this != nullptr) {
            LinearControlForce *return_value = new LinearControlForce(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearControlForce, true, false);
          }
        }
      }

      // No coercion possible: explicit LinearControlForce::LinearControlForce(PhysicsObject const *po, PN_stdfloat a = 1.0, bool mass = false)
      // No coercion possible: LinearControlForce::LinearControlForce(LinearControlForce const &copy)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LinearControlForce() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearControlForce()\n"
      "LinearControlForce(const PhysicsObject po, float a, bool mass)\n"
      "LinearControlForce(const LinearControlForce copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LinearControlForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LinearControlForce) {
    printf("LinearControlForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LinearControlForce *local_this = (LinearControlForce *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LinearControlForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LinearControlForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LinearControlForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearControlForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearControlForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearControlForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearControlForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearControlForce*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LinearCylinderVortexForce
 */
/**
 * Python function wrapper for:
 * inline void LinearCylinderVortexForce::set_coef(PN_stdfloat coef)
 */
static PyObject *Dtool_LinearCylinderVortexForce_set_coef_177(PyObject *self, PyObject *arg) {
  LinearCylinderVortexForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearCylinderVortexForce, (void **)&local_this, "LinearCylinderVortexForce.set_coef")) {
    return nullptr;
  }
  // 1-inline void LinearCylinderVortexForce::set_coef(PN_stdfloat coef)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_coef)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_coef(const LinearCylinderVortexForce self, float coef)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LinearCylinderVortexForce_set_coef_177_comment =
  "C++ Interface:\n"
  "set_coef(const LinearCylinderVortexForce self, float coef)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearCylinderVortexForce_set_coef_177_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LinearCylinderVortexForce::get_coef(void) const
 */
static PyObject *Dtool_LinearCylinderVortexForce_get_coef_178(PyObject *self, PyObject *) {
  LinearCylinderVortexForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LinearCylinderVortexForce)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat LinearCylinderVortexForce::get_coef(void) const
  PN_stdfloat return_value = ((*(const LinearCylinderVortexForce*)local_this).get_coef)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearCylinderVortexForce_get_coef_178_comment =
  "C++ Interface:\n"
  "get_coef(LinearCylinderVortexForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearCylinderVortexForce_get_coef_178_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LinearCylinderVortexForce::set_radius(PN_stdfloat radius)
 */
static PyObject *Dtool_LinearCylinderVortexForce_set_radius_179(PyObject *self, PyObject *arg) {
  LinearCylinderVortexForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearCylinderVortexForce, (void **)&local_this, "LinearCylinderVortexForce.set_radius")) {
    return nullptr;
  }
  // 1-inline void LinearCylinderVortexForce::set_radius(PN_stdfloat radius)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_radius)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const LinearCylinderVortexForce self, float radius)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LinearCylinderVortexForce_set_radius_179_comment =
  "C++ Interface:\n"
  "set_radius(const LinearCylinderVortexForce self, float radius)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearCylinderVortexForce_set_radius_179_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LinearCylinderVortexForce::get_radius(void) const
 */
static PyObject *Dtool_LinearCylinderVortexForce_get_radius_180(PyObject *self, PyObject *) {
  LinearCylinderVortexForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LinearCylinderVortexForce)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat LinearCylinderVortexForce::get_radius(void) const
  PN_stdfloat return_value = ((*(const LinearCylinderVortexForce*)local_this).get_radius)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearCylinderVortexForce_get_radius_180_comment =
  "C++ Interface:\n"
  "get_radius(LinearCylinderVortexForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearCylinderVortexForce_get_radius_180_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LinearCylinderVortexForce::set_length(PN_stdfloat length)
 */
static PyObject *Dtool_LinearCylinderVortexForce_set_length_181(PyObject *self, PyObject *arg) {
  LinearCylinderVortexForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearCylinderVortexForce, (void **)&local_this, "LinearCylinderVortexForce.set_length")) {
    return nullptr;
  }
  // 1-inline void LinearCylinderVortexForce::set_length(PN_stdfloat length)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_length)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_length(const LinearCylinderVortexForce self, float length)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LinearCylinderVortexForce_set_length_181_comment =
  "C++ Interface:\n"
  "set_length(const LinearCylinderVortexForce self, float length)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearCylinderVortexForce_set_length_181_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LinearCylinderVortexForce::get_length(void) const
 */
static PyObject *Dtool_LinearCylinderVortexForce_get_length_182(PyObject *self, PyObject *) {
  LinearCylinderVortexForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LinearCylinderVortexForce)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat LinearCylinderVortexForce::get_length(void) const
  PN_stdfloat return_value = ((*(const LinearCylinderVortexForce*)local_this).get_length)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearCylinderVortexForce_get_length_182_comment =
  "C++ Interface:\n"
  "get_length(LinearCylinderVortexForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearCylinderVortexForce_get_length_182_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LinearCylinderVortexForce::get_class_type(void)
 */
static PyObject *Dtool_LinearCylinderVortexForce_get_class_type_183(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearCylinderVortexForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LinearCylinderVortexForce::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearCylinderVortexForce_get_class_type_183_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearCylinderVortexForce_get_class_type_183_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LinearCylinderVortexForce::LinearCylinderVortexForce(LinearCylinderVortexForce const &copy)
 * explicit LinearCylinderVortexForce::LinearCylinderVortexForce(PN_stdfloat radius = 1.0, PN_stdfloat length = 0.0, PN_stdfloat coef = 1.0, PN_stdfloat a = 1.0, bool md = false)
 */
static int Dtool_Init_LinearCylinderVortexForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-explicit LinearCylinderVortexForce::LinearCylinderVortexForce(PN_stdfloat radius, PN_stdfloat length, PN_stdfloat coef, PN_stdfloat a, bool md)
      LinearCylinderVortexForce *return_value = new LinearCylinderVortexForce();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearCylinderVortexForce, true, false);
    }
    break;
  case 1:
  case 2:
  case 3:
  case 4:
  case 5:
    {
      {
        // -2 explicit LinearCylinderVortexForce::LinearCylinderVortexForce(PN_stdfloat radius, PN_stdfloat length = 0.0, PN_stdfloat coef = 1.0, PN_stdfloat a = 1.0, bool md = false)
        float param0;
        float param1 = 0.0;
        float param2 = 1.0;
        float param3 = 1.0;
        PyObject *param4 = Py_False;
        static const char *keyword_list[] = {"radius", "length", "coef", "a", "md", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f|fffO:LinearCylinderVortexForce", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LinearCylinderVortexForce *return_value = new LinearCylinderVortexForce((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PyObject_IsTrue(param4) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearCylinderVortexForce, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 LinearCylinderVortexForce::LinearCylinderVortexForce(LinearCylinderVortexForce const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          LinearCylinderVortexForce const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LinearCylinderVortexForce);
          if (param0_this != nullptr) {
            LinearCylinderVortexForce *return_value = new LinearCylinderVortexForce(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearCylinderVortexForce, true, false);
          }
        }
      }

      // No coercion possible: explicit LinearCylinderVortexForce::LinearCylinderVortexForce(PN_stdfloat radius, PN_stdfloat length = 0.0, PN_stdfloat coef = 1.0, PN_stdfloat a = 1.0, bool md = false)
      // No coercion possible: LinearCylinderVortexForce::LinearCylinderVortexForce(LinearCylinderVortexForce const &copy)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LinearCylinderVortexForce() takes 0, 1, 2, 3, 4 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearCylinderVortexForce()\n"
      "LinearCylinderVortexForce(float radius, float length, float coef, float a, bool md)\n"
      "LinearCylinderVortexForce(const LinearCylinderVortexForce copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LinearCylinderVortexForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LinearCylinderVortexForce) {
    printf("LinearCylinderVortexForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LinearCylinderVortexForce *local_this = (LinearCylinderVortexForce *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LinearCylinderVortexForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LinearCylinderVortexForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LinearCylinderVortexForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearCylinderVortexForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearCylinderVortexForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearCylinderVortexForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearCylinderVortexForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearCylinderVortexForce*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LinearDistanceForce
 */
/**
 * Python function wrapper for:
 * inline void LinearDistanceForce::set_radius(PN_stdfloat r)
 */
static PyObject *Dtool_LinearDistanceForce_set_radius_186(PyObject *self, PyObject *arg) {
  LinearDistanceForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearDistanceForce, (void **)&local_this, "LinearDistanceForce.set_radius")) {
    return nullptr;
  }
  // 1-inline void LinearDistanceForce::set_radius(PN_stdfloat r)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_radius)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_radius(const LinearDistanceForce self, float r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LinearDistanceForce_set_radius_186_comment =
  "C++ Interface:\n"
  "set_radius(const LinearDistanceForce self, float r)\n"
  "\n"
  "/**\n"
  " * set the radius\n"
  " */";
#else
static const char *Dtool_LinearDistanceForce_set_radius_186_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LinearDistanceForce::set_falloff_type(LinearDistanceForce::FalloffType ft)
 */
static PyObject *Dtool_LinearDistanceForce_set_falloff_type_187(PyObject *self, PyObject *arg) {
  LinearDistanceForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearDistanceForce, (void **)&local_this, "LinearDistanceForce.set_falloff_type")) {
    return nullptr;
  }
  // 1-inline void LinearDistanceForce::set_falloff_type(LinearDistanceForce::FalloffType ft)
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    ((*local_this).set_falloff_type)((LinearDistanceForce::FalloffType)arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_falloff_type(const LinearDistanceForce self, int ft)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LinearDistanceForce_set_falloff_type_187_comment =
  "C++ Interface:\n"
  "set_falloff_type(const LinearDistanceForce self, int ft)\n"
  "\n"
  "/**\n"
  " * falloff_type encapsulating wrap\n"
  " */";
#else
static const char *Dtool_LinearDistanceForce_set_falloff_type_187_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LinearDistanceForce::set_force_center(LPoint3 const &p)
 */
static PyObject *Dtool_LinearDistanceForce_set_force_center_188(PyObject *self, PyObject *arg) {
  LinearDistanceForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearDistanceForce, (void **)&local_this, "LinearDistanceForce.set_force_center")) {
    return nullptr;
  }
  // 1-inline void LinearDistanceForce::set_force_center(LPoint3 const &p)
  LPoint3f arg_local;
  LPoint3 const *arg_this = Dtool_Coerce_LPoint3f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LinearDistanceForce.set_force_center", "LPoint3f");
  }
  ((*local_this).set_force_center)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_force_center(const LinearDistanceForce self, const LPoint3f p)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LinearDistanceForce_set_force_center_188_comment =
  "C++ Interface:\n"
  "set_force_center(const LinearDistanceForce self, const LPoint3f p)\n"
  "\n"
  "/**\n"
  " * set the force center\n"
  " */";
#else
static const char *Dtool_LinearDistanceForce_set_force_center_188_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LinearDistanceForce::get_radius(void) const
 */
static PyObject *Dtool_LinearDistanceForce_get_radius_189(PyObject *self, PyObject *) {
  LinearDistanceForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LinearDistanceForce)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat LinearDistanceForce::get_radius(void) const
  PN_stdfloat return_value = ((*(const LinearDistanceForce*)local_this).get_radius)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearDistanceForce_get_radius_189_comment =
  "C++ Interface:\n"
  "get_radius(LinearDistanceForce self)\n"
  "\n"
  "/**\n"
  " * radius query\n"
  " */";
#else
static const char *Dtool_LinearDistanceForce_get_radius_189_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LinearDistanceForce::FalloffType LinearDistanceForce::get_falloff_type(void) const
 */
static PyObject *Dtool_LinearDistanceForce_get_falloff_type_190(PyObject *self, PyObject *) {
  LinearDistanceForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LinearDistanceForce)) {
    return nullptr;
  }
  // 1-inline LinearDistanceForce::FalloffType LinearDistanceForce::get_falloff_type(void) const
  LinearDistanceForce::FalloffType return_value = ((*(const LinearDistanceForce*)local_this).get_falloff_type)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearDistanceForce_get_falloff_type_190_comment =
  "C++ Interface:\n"
  "get_falloff_type(LinearDistanceForce self)\n"
  "\n"
  "/**\n"
  " * falloff_type query\n"
  " */";
#else
static const char *Dtool_LinearDistanceForce_get_falloff_type_190_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint3 LinearDistanceForce::get_force_center(void) const
 */
static PyObject *Dtool_LinearDistanceForce_get_force_center_191(PyObject *self, PyObject *) {
  LinearDistanceForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LinearDistanceForce)) {
    return nullptr;
  }
  // 1-inline LPoint3 LinearDistanceForce::get_force_center(void) const
  LPoint3 *return_value = new LPoint3(((*(const LinearDistanceForce*)local_this).get_force_center)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearDistanceForce_get_force_center_191_comment =
  "C++ Interface:\n"
  "get_force_center(LinearDistanceForce self)\n"
  "\n"
  "/**\n"
  " * force_center query\n"
  " */";
#else
static const char *Dtool_LinearDistanceForce_get_force_center_191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LinearDistanceForce::get_scalar_term(void) const
 */
static PyObject *Dtool_LinearDistanceForce_get_scalar_term_192(PyObject *self, PyObject *) {
  LinearDistanceForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LinearDistanceForce)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat LinearDistanceForce::get_scalar_term(void) const
  PN_stdfloat return_value = ((*(const LinearDistanceForce*)local_this).get_scalar_term)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearDistanceForce_get_scalar_term_192_comment =
  "C++ Interface:\n"
  "get_scalar_term(LinearDistanceForce self)\n"
  "\n"
  "/**\n"
  " * calculate the term based on falloff\n"
  " */";
#else
static const char *Dtool_LinearDistanceForce_get_scalar_term_192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LinearDistanceForce::get_class_type(void)
 */
static PyObject *Dtool_LinearDistanceForce_get_class_type_193(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearDistanceForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LinearDistanceForce::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearDistanceForce_get_class_type_193_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearDistanceForce_get_class_type_193_comment = nullptr;
#endif

static int Dtool_Init_LinearDistanceForce(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LinearDistanceForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LinearDistanceForce) {
    printf("LinearDistanceForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LinearDistanceForce *local_this = (LinearDistanceForce *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LinearDistanceForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LinearDistanceForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LinearDistanceForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearDistanceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearDistanceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearDistanceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearDistanceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearDistanceForce*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LinearIntegrator
 */
static int Dtool_Init_LinearIntegrator(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LinearIntegrator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LinearIntegrator) {
    printf("LinearIntegrator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LinearIntegrator *local_this = (LinearIntegrator *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LinearIntegrator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseIntegrator) {
    return (BaseIntegrator *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseIntegrator *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LinearIntegrator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LinearIntegrator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseIntegrator) {
    BaseIntegrator* other_this = (BaseIntegrator*)from_this;
    return (LinearIntegrator*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearIntegrator*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LinearEulerIntegrator
 */
/**
 * Python function wrapper for:
 * LinearEulerIntegrator::LinearEulerIntegrator(void)
 */
static int Dtool_Init_LinearEulerIntegrator(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("LinearEulerIntegrator() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "LinearEulerIntegrator() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-LinearEulerIntegrator::LinearEulerIntegrator(void)
  LinearEulerIntegrator *return_value = new LinearEulerIntegrator();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearEulerIntegrator, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearEulerIntegrator()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LinearEulerIntegrator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LinearEulerIntegrator) {
    printf("LinearEulerIntegrator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LinearEulerIntegrator *local_this = (LinearEulerIntegrator *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LinearEulerIntegrator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseIntegrator) {
    return (BaseIntegrator *)(LinearIntegrator *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearIntegrator) {
    return (LinearIntegrator *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(BaseIntegrator *)(LinearIntegrator *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LinearEulerIntegrator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LinearEulerIntegrator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseIntegrator) {
    BaseIntegrator* other_this = (BaseIntegrator*)from_this;
    return (LinearEulerIntegrator*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearIntegrator) {
    LinearIntegrator* other_this = (LinearIntegrator*)from_this;
    return (LinearEulerIntegrator*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearEulerIntegrator*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LinearFrictionForce
 */
/**
 * Python function wrapper for:
 * inline void LinearFrictionForce::set_coef(PN_stdfloat coef)
 */
static PyObject *Dtool_LinearFrictionForce_set_coef_199(PyObject *self, PyObject *arg) {
  LinearFrictionForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearFrictionForce, (void **)&local_this, "LinearFrictionForce.set_coef")) {
    return nullptr;
  }
  // 1-inline void LinearFrictionForce::set_coef(PN_stdfloat coef)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_coef)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_coef(const LinearFrictionForce self, float coef)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LinearFrictionForce_set_coef_199_comment =
  "C++ Interface:\n"
  "set_coef(const LinearFrictionForce self, float coef)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearFrictionForce_set_coef_199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat LinearFrictionForce::get_coef(void) const
 */
static PyObject *Dtool_LinearFrictionForce_get_coef_200(PyObject *self, PyObject *) {
  LinearFrictionForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LinearFrictionForce)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat LinearFrictionForce::get_coef(void) const
  PN_stdfloat return_value = ((*(const LinearFrictionForce*)local_this).get_coef)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LinearFrictionForce_get_coef_200_comment =
  "C++ Interface:\n"
  "get_coef(LinearFrictionForce self)\n"
  "\n"
  "/**\n"
  "\n"
  " */";
#else
static const char *Dtool_LinearFrictionForce_get_coef_200_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LinearFrictionForce::get_class_type(void)
 */
static PyObject *Dtool_LinearFrictionForce_get_class_type_201(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearFrictionForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LinearFrictionForce::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearFrictionForce_get_class_type_201_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearFrictionForce_get_class_type_201_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LinearFrictionForce::LinearFrictionForce(LinearFrictionForce const &copy)
 * explicit LinearFrictionForce::LinearFrictionForce(PN_stdfloat coef = 1.0, PN_stdfloat a = 1.0, bool m = false)
 */
static int Dtool_Init_LinearFrictionForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-explicit LinearFrictionForce::LinearFrictionForce(PN_stdfloat coef, PN_stdfloat a, bool m)
      LinearFrictionForce *return_value = new LinearFrictionForce();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearFrictionForce, true, false);
    }
    break;
  case 1:
  case 2:
  case 3:
    {
      {
        // -2 explicit LinearFrictionForce::LinearFrictionForce(PN_stdfloat coef, PN_stdfloat a = 1.0, bool m = false)
        float param0;
        float param1 = 1.0;
        PyObject *param2 = Py_False;
        static const char *keyword_list[] = {"coef", "a", "m", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f|fO:LinearFrictionForce", (char **)keyword_list, &param0, &param1, &param2)) {
          LinearFrictionForce *return_value = new LinearFrictionForce((PN_stdfloat)param0, (PN_stdfloat)param1, (PyObject_IsTrue(param2) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearFrictionForce, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 LinearFrictionForce::LinearFrictionForce(LinearFrictionForce const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          LinearFrictionForce const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LinearFrictionForce);
          if (param0_this != nullptr) {
            LinearFrictionForce *return_value = new LinearFrictionForce(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearFrictionForce, true, false);
          }
        }
      }

      // No coercion possible: explicit LinearFrictionForce::LinearFrictionForce(PN_stdfloat coef, PN_stdfloat a = 1.0, bool m = false)
      // No coercion possible: LinearFrictionForce::LinearFrictionForce(LinearFrictionForce const &copy)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LinearFrictionForce() takes 0, 1, 2 or 3 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearFrictionForce()\n"
      "LinearFrictionForce(float coef, float a, bool m)\n"
      "LinearFrictionForce(const LinearFrictionForce copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LinearFrictionForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LinearFrictionForce) {
    printf("LinearFrictionForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LinearFrictionForce *local_this = (LinearFrictionForce *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LinearFrictionForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LinearFrictionForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LinearFrictionForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearFrictionForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearFrictionForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearFrictionForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearFrictionForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearFrictionForce*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LinearRandomForce
 */
/**
 * Python function wrapper for:
 * static TypeHandle LinearRandomForce::get_class_type(void)
 */
static PyObject *Dtool_LinearRandomForce_get_class_type_203(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearRandomForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LinearRandomForce::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearRandomForce_get_class_type_203_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearRandomForce_get_class_type_203_comment = nullptr;
#endif

static int Dtool_Init_LinearRandomForce(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LinearRandomForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LinearRandomForce) {
    printf("LinearRandomForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LinearRandomForce *local_this = (LinearRandomForce *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LinearRandomForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LinearRandomForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LinearRandomForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearRandomForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearRandomForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearRandomForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearRandomForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearRandomForce*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LinearJitterForce
 */
/**
 * Python function wrapper for:
 * static TypeHandle LinearJitterForce::get_class_type(void)
 */
static PyObject *Dtool_LinearJitterForce_get_class_type_206(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearJitterForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LinearJitterForce::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearJitterForce_get_class_type_206_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearJitterForce_get_class_type_206_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LinearJitterForce::LinearJitterForce(LinearJitterForce const &copy)
 * explicit LinearJitterForce::LinearJitterForce(PN_stdfloat a = 1.0, bool m = false)
 */
static int Dtool_Init_LinearJitterForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-explicit LinearJitterForce::LinearJitterForce(PN_stdfloat a, bool m)
      LinearJitterForce *return_value = new LinearJitterForce();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearJitterForce, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 explicit LinearJitterForce::LinearJitterForce(PN_stdfloat a, bool m = false)
        float param0;
        PyObject *param1 = Py_False;
        static const char *keyword_list[] = {"a", "m", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f|O:LinearJitterForce", (char **)keyword_list, &param0, &param1)) {
          LinearJitterForce *return_value = new LinearJitterForce((PN_stdfloat)param0, (PyObject_IsTrue(param1) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearJitterForce, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 LinearJitterForce::LinearJitterForce(LinearJitterForce const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          LinearJitterForce const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LinearJitterForce);
          if (param0_this != nullptr) {
            LinearJitterForce *return_value = new LinearJitterForce(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearJitterForce, true, false);
          }
        }
      }

      // No coercion possible: explicit LinearJitterForce::LinearJitterForce(PN_stdfloat a, bool m = false)
      // No coercion possible: LinearJitterForce::LinearJitterForce(LinearJitterForce const &copy)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LinearJitterForce() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearJitterForce()\n"
      "LinearJitterForce(float a, bool m)\n"
      "LinearJitterForce(const LinearJitterForce copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LinearJitterForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LinearJitterForce) {
    printf("LinearJitterForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LinearJitterForce *local_this = (LinearJitterForce *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LinearJitterForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *)(LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *)(LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearRandomForce) {
    return (LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearRandomForce *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LinearJitterForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LinearJitterForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearJitterForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearJitterForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearRandomForce) {
    LinearRandomForce* other_this = (LinearRandomForce*)from_this;
    return (LinearJitterForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearJitterForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearJitterForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearJitterForce*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LinearNoiseForce
 */
/**
 * Python function wrapper for:
 * static TypeHandle LinearNoiseForce::get_class_type(void)
 */
static PyObject *Dtool_LinearNoiseForce_get_class_type_209(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearNoiseForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LinearNoiseForce::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearNoiseForce_get_class_type_209_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearNoiseForce_get_class_type_209_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LinearNoiseForce::LinearNoiseForce(LinearNoiseForce const &copy)
 * explicit LinearNoiseForce::LinearNoiseForce(PN_stdfloat a = 1.0, bool m = false)
 */
static int Dtool_Init_LinearNoiseForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-explicit LinearNoiseForce::LinearNoiseForce(PN_stdfloat a, bool m)
      LinearNoiseForce *return_value = new LinearNoiseForce();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearNoiseForce, true, false);
    }
    break;
  case 1:
  case 2:
    {
      {
        // -2 explicit LinearNoiseForce::LinearNoiseForce(PN_stdfloat a, bool m = false)
        float param0;
        PyObject *param1 = Py_False;
        static const char *keyword_list[] = {"a", "m", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f|O:LinearNoiseForce", (char **)keyword_list, &param0, &param1)) {
          LinearNoiseForce *return_value = new LinearNoiseForce((PN_stdfloat)param0, (PyObject_IsTrue(param1) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearNoiseForce, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 LinearNoiseForce::LinearNoiseForce(LinearNoiseForce const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          LinearNoiseForce const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LinearNoiseForce);
          if (param0_this != nullptr) {
            LinearNoiseForce *return_value = new LinearNoiseForce(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearNoiseForce, true, false);
          }
        }
      }

      // No coercion possible: explicit LinearNoiseForce::LinearNoiseForce(PN_stdfloat a, bool m = false)
      // No coercion possible: LinearNoiseForce::LinearNoiseForce(LinearNoiseForce const &copy)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LinearNoiseForce() takes 0, 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearNoiseForce()\n"
      "LinearNoiseForce(float a, bool m)\n"
      "LinearNoiseForce(const LinearNoiseForce copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LinearNoiseForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LinearNoiseForce) {
    printf("LinearNoiseForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LinearNoiseForce *local_this = (LinearNoiseForce *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LinearNoiseForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *)(LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *)(LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearRandomForce) {
    return (LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearRandomForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearRandomForce *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LinearNoiseForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LinearNoiseForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearNoiseForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearNoiseForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearRandomForce) {
    LinearRandomForce* other_this = (LinearRandomForce*)from_this;
    return (LinearNoiseForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearNoiseForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearNoiseForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearNoiseForce*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LinearSinkForce
 */
/**
 * Python function wrapper for:
 * static TypeHandle LinearSinkForce::get_class_type(void)
 */
static PyObject *Dtool_LinearSinkForce_get_class_type_212(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearSinkForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LinearSinkForce::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearSinkForce_get_class_type_212_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearSinkForce_get_class_type_212_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LinearSinkForce::LinearSinkForce(void)
 * explicit LinearSinkForce::LinearSinkForce(LPoint3 const &p, LinearDistanceForce::FalloffType f, PN_stdfloat r, PN_stdfloat a = 1.0, bool m = true)
 * LinearSinkForce::LinearSinkForce(LinearSinkForce const &copy)
 */
static int Dtool_Init_LinearSinkForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LinearSinkForce::LinearSinkForce(void)
      LinearSinkForce *return_value = new LinearSinkForce();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearSinkForce, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-LinearSinkForce::LinearSinkForce(LinearSinkForce const &copy)
        LinearSinkForce const *arg_this = (LinearSinkForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LinearSinkForce, 0, "LinearSinkForce.LinearSinkForce", true, true);
        if (arg_this != nullptr) {
          LinearSinkForce *return_value = new LinearSinkForce(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearSinkForce, true, false);
        }
      }
    }
    break;
  case 3:
  case 4:
  case 5:
    {
      // 1-explicit LinearSinkForce::LinearSinkForce(LPoint3 const &p, LinearDistanceForce::FalloffType f, PN_stdfloat r, PN_stdfloat a = 1.0, bool m = true)
      PyObject *param0;
      int param1;
      float param2;
      float param3 = 1.0;
      PyObject *param4 = Py_True;
      static const char *keyword_list[] = {"p", "f", "r", "a", "m", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oif|fO:LinearSinkForce", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LinearSinkForce.LinearSinkForce", "LPoint3f");
          return -1;
        }
        LinearSinkForce *return_value = new LinearSinkForce(*param0_this, (LinearDistanceForce::FalloffType)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PyObject_IsTrue(param4) != 0));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearSinkForce, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LinearSinkForce() takes 0, 1, 3, 4 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearSinkForce()\n"
      "LinearSinkForce(const LinearSinkForce copy)\n"
      "LinearSinkForce(const LPoint3f p, int f, float r, float a, bool m)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LinearSinkForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LinearSinkForce) {
    printf("LinearSinkForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LinearSinkForce *local_this = (LinearSinkForce *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LinearSinkForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *)(LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearDistanceForce) {
    return (LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *)(LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearDistanceForce *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LinearSinkForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LinearSinkForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearSinkForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearDistanceForce) {
    LinearDistanceForce* other_this = (LinearDistanceForce*)from_this;
    return (LinearSinkForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearSinkForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearSinkForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearSinkForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearSinkForce*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LinearSourceForce
 */
/**
 * Python function wrapper for:
 * static TypeHandle LinearSourceForce::get_class_type(void)
 */
static PyObject *Dtool_LinearSourceForce_get_class_type_215(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearSourceForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LinearSourceForce::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearSourceForce_get_class_type_215_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearSourceForce_get_class_type_215_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LinearSourceForce::LinearSourceForce(void)
 * explicit LinearSourceForce::LinearSourceForce(LPoint3 const &p, LinearDistanceForce::FalloffType f, PN_stdfloat r, PN_stdfloat a = 1.0, bool mass = true)
 * LinearSourceForce::LinearSourceForce(LinearSourceForce const &copy)
 */
static int Dtool_Init_LinearSourceForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LinearSourceForce::LinearSourceForce(void)
      LinearSourceForce *return_value = new LinearSourceForce();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearSourceForce, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
        // 1-LinearSourceForce::LinearSourceForce(LinearSourceForce const &copy)
        LinearSourceForce const *arg_this = (LinearSourceForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LinearSourceForce, 0, "LinearSourceForce.LinearSourceForce", true, true);
        if (arg_this != nullptr) {
          LinearSourceForce *return_value = new LinearSourceForce(*arg_this);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearSourceForce, true, false);
        }
      }
    }
    break;
  case 3:
  case 4:
  case 5:
    {
      // 1-explicit LinearSourceForce::LinearSourceForce(LPoint3 const &p, LinearDistanceForce::FalloffType f, PN_stdfloat r, PN_stdfloat a = 1.0, bool mass = true)
      PyObject *param0;
      int param1;
      float param2;
      float param3 = 1.0;
      PyObject *param4 = Py_True;
      static const char *keyword_list[] = {"p", "f", "r", "a", "mass", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "Oif|fO:LinearSourceForce", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
        LPoint3f param0_local;
        LPoint3 const *param0_this = Dtool_Coerce_LPoint3f(param0, param0_local);
        if (!(param0_this != nullptr)) {
          Dtool_Raise_ArgTypeError(param0, 0, "LinearSourceForce.LinearSourceForce", "LPoint3f");
          return -1;
        }
        LinearSourceForce *return_value = new LinearSourceForce(*param0_this, (LinearDistanceForce::FalloffType)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PyObject_IsTrue(param4) != 0));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearSourceForce, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LinearSourceForce() takes 0, 1, 3, 4 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearSourceForce()\n"
      "LinearSourceForce(const LinearSourceForce copy)\n"
      "LinearSourceForce(const LPoint3f p, int f, float r, float a, bool mass)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LinearSourceForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LinearSourceForce) {
    printf("LinearSourceForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LinearSourceForce *local_this = (LinearSourceForce *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LinearSourceForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *)(LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearDistanceForce) {
    return (LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *)(LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearDistanceForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *)(LinearDistanceForce *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LinearSourceForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LinearSourceForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearSourceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearDistanceForce) {
    LinearDistanceForce* other_this = (LinearDistanceForce*)from_this;
    return (LinearSourceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearSourceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearSourceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearSourceForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearSourceForce*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LinearUserDefinedForce
 */
/**
 * Python function wrapper for:
 * static TypeHandle LinearUserDefinedForce::get_class_type(void)
 */
static PyObject *Dtool_LinearUserDefinedForce_get_class_type_219(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearUserDefinedForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LinearUserDefinedForce::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearUserDefinedForce_get_class_type_219_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearUserDefinedForce_get_class_type_219_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LinearUserDefinedForce::LinearUserDefinedForce(LinearUserDefinedForce const &copy)
 */
static int Dtool_Init_LinearUserDefinedForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "LinearUserDefinedForce() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  PyObject *arg;
  if (Dtool_ExtractArg(&arg, args, kwds, "copy")) {
    // 1-LinearUserDefinedForce::LinearUserDefinedForce(LinearUserDefinedForce const &copy)
    LinearUserDefinedForce const *arg_this = (LinearUserDefinedForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LinearUserDefinedForce, 0, "LinearUserDefinedForce.LinearUserDefinedForce", true, true);
    if (arg_this != nullptr) {
      LinearUserDefinedForce *return_value = new LinearUserDefinedForce(*arg_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearUserDefinedForce, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearUserDefinedForce(const LinearUserDefinedForce copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LinearUserDefinedForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LinearUserDefinedForce) {
    printf("LinearUserDefinedForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LinearUserDefinedForce *local_this = (LinearUserDefinedForce *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LinearUserDefinedForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LinearUserDefinedForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LinearUserDefinedForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearUserDefinedForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearUserDefinedForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearUserDefinedForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearUserDefinedForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearUserDefinedForce*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LinearVectorForce
 */
/**
 * Python function wrapper for:
 * inline void LinearVectorForce::set_vector(LVector3 const &v)
 * inline void LinearVectorForce::set_vector(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
 */
static PyObject *Dtool_LinearVectorForce_set_vector_222(PyObject *self, PyObject *args, PyObject *kwds) {
  LinearVectorForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LinearVectorForce, (void **)&local_this, "LinearVectorForce.set_vector")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "v")) {
        // 1-inline void LinearVectorForce::set_vector(LVector3 const &v)
        LVector3f arg_local;
        LVector3 const *arg_this = Dtool_Coerce_LVector3f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "LinearVectorForce.set_vector", "LVector3f");
        }
        ((*local_this).set_vector)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 3:
    {
      // 1-inline void LinearVectorForce::set_vector(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z)
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "z", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff:set_vector", (char **)keyword_list, &param1, &param2, &param3)) {
        ((*local_this).set_vector)((PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_vector() takes 2 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_vector(const LinearVectorForce self, const LVector3f v)\n"
      "set_vector(const LinearVectorForce self, float x, float y, float z)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LinearVectorForce_set_vector_222_comment =
  "C++ Interface:\n"
  "set_vector(const LinearVectorForce self, const LVector3f v)\n"
  "set_vector(const LinearVectorForce self, float x, float y, float z)\n"
  "\n"
  "/**\n"
  " * encapsulating wrapper\n"
  " */\n"
  "\n"
  "/**\n"
  " * piecewise encapsulating wrapper\n"
  " */";
#else
static const char *Dtool_LinearVectorForce_set_vector_222_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector3 LinearVectorForce::get_local_vector(void) const
 */
static PyObject *Dtool_LinearVectorForce_get_local_vector_223(PyObject *self, PyObject *) {
  LinearVectorForce *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LinearVectorForce)) {
    return nullptr;
  }
  // 1-inline LVector3 LinearVectorForce::get_local_vector(void) const
  LVector3 *return_value = new LVector3(((*(const LinearVectorForce*)local_this).get_local_vector)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector3f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearVectorForce_get_local_vector_223_comment =
  "C++ Interface:\n"
  "get_local_vector(LinearVectorForce self)\n"
  "\n"
  "/**\n"
  " *\n"
  " */";
#else
static const char *Dtool_LinearVectorForce_get_local_vector_223_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LinearVectorForce::get_class_type(void)
 */
static PyObject *Dtool_LinearVectorForce_get_class_type_224(PyObject *, PyObject *) {
  // 1-static TypeHandle LinearVectorForce::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LinearVectorForce::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LinearVectorForce_get_class_type_224_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LinearVectorForce_get_class_type_224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * explicit LinearVectorForce::LinearVectorForce(LVector3 const &vec, PN_stdfloat a = 1.0, bool mass = false)
 * LinearVectorForce::LinearVectorForce(LinearVectorForce const &copy)
 * explicit LinearVectorForce::LinearVectorForce(PN_stdfloat x = 0.0, PN_stdfloat y = 0.0, PN_stdfloat z = 0.0, PN_stdfloat a = 1.0, bool mass = false)
 */
static int Dtool_Init_LinearVectorForce(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-explicit LinearVectorForce::LinearVectorForce(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z, PN_stdfloat a, bool mass)
      LinearVectorForce *return_value = new LinearVectorForce();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearVectorForce, true, false);
    }
    break;
  case 1:
  case 2:
  case 3:
  case 4:
  case 5:
    {
      {
        // -2 explicit LinearVectorForce::LinearVectorForce(PN_stdfloat x, PN_stdfloat y = 0.0, PN_stdfloat z = 0.0, PN_stdfloat a = 1.0, bool mass = false)
        float param0;
        float param1 = 0.0;
        float param2 = 0.0;
        float param3 = 1.0;
        PyObject *param4 = Py_False;
        static const char *keyword_list[] = {"x", "y", "z", "a", "mass", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f|fffO:LinearVectorForce", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          LinearVectorForce *return_value = new LinearVectorForce((PN_stdfloat)param0, (PN_stdfloat)param1, (PN_stdfloat)param2, (PN_stdfloat)param3, (PyObject_IsTrue(param4) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearVectorForce, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 explicit LinearVectorForce::LinearVectorForce(LVector3 const &vec, PN_stdfloat a = 1.0, bool mass = false)
        PyObject *param0;
        float param1 = 1.0;
        PyObject *param2 = Py_False;
        static const char *keyword_list[] = {"vec", "a", "mass", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|fO:LinearVectorForce", (char **)keyword_list, &param0, &param1, &param2)) {
          LVector3 const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LVector3f);
          if (param0_this != nullptr) {
            LinearVectorForce *return_value = new LinearVectorForce(*param0_this, (PN_stdfloat)param1, (PyObject_IsTrue(param2) != 0));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearVectorForce, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LinearVectorForce::LinearVectorForce(LinearVectorForce const &copy)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "copy")) {
          LinearVectorForce const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LinearVectorForce);
          if (param0_this != nullptr) {
            LinearVectorForce *return_value = new LinearVectorForce(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearVectorForce, true, false);
          }
        }
      }

      // No coercion possible: explicit LinearVectorForce::LinearVectorForce(PN_stdfloat x, PN_stdfloat y = 0.0, PN_stdfloat z = 0.0, PN_stdfloat a = 1.0, bool mass = false)
      {
        // -2 explicit LinearVectorForce::LinearVectorForce(LVector3 const &vec, PN_stdfloat a = 1.0, bool mass = false)
        PyObject *param0;
        float param1 = 1.0;
        PyObject *param2 = Py_False;
        static const char *keyword_list[] = {"vec", "a", "mass", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|fO:LinearVectorForce", (char **)keyword_list, &param0, &param1, &param2)) {
          LVector3f param0_local;
          LVector3 const *param0_this = Dtool_Coerce_LVector3f(param0, param0_local);
          if ((param0_this != nullptr)) {
            LinearVectorForce *return_value = new LinearVectorForce(*param0_this, (PN_stdfloat)param1, (PyObject_IsTrue(param2) != 0));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LinearVectorForce, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: LinearVectorForce::LinearVectorForce(LinearVectorForce const &copy)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LinearVectorForce() takes 0, 1, 2, 3, 4 or 5 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LinearVectorForce()\n"
      "LinearVectorForce(float x, float y, float z, float a, bool mass)\n"
      "LinearVectorForce(const LVector3f vec, float a, bool mass)\n"
      "LinearVectorForce(const LinearVectorForce copy)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LinearVectorForce(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LinearVectorForce) {
    printf("LinearVectorForce ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LinearVectorForce *local_this = (LinearVectorForce *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LinearVectorForce) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_BaseForce) {
    return (BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_LinearForce) {
    return (LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(BaseForce *)(LinearForce *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LinearVectorForce(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LinearVectorForce) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_BaseForce) {
    BaseForce* other_this = (BaseForce*)from_this;
    return (LinearVectorForce*)other_this;
  }
  if (from_type == Dtool_Ptr_LinearForce) {
    LinearForce* other_this = (LinearForce*)from_this;
    return (LinearVectorForce*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LinearVectorForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LinearVectorForce*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LinearVectorForce*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PhysicsCollisionHandler
 */
/**
 * Python function wrapper for:
 * inline void PhysicsCollisionHandler::set_almost_stationary_speed(PN_stdfloat speed)
 */
static PyObject *Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_228(PyObject *self, PyObject *arg) {
  PhysicsCollisionHandler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCollisionHandler, (void **)&local_this, "PhysicsCollisionHandler.set_almost_stationary_speed")) {
    return nullptr;
  }
  // 1-inline void PhysicsCollisionHandler::set_almost_stationary_speed(PN_stdfloat speed)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_almost_stationary_speed)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_almost_stationary_speed(const PhysicsCollisionHandler self, float speed)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_228_comment =
  "C++ Interface:\n"
  "set_almost_stationary_speed(const PhysicsCollisionHandler self, float speed)\n"
  "\n"
  "// These setters and getter are a bit of a hack:";
#else
static const char *Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_228_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PhysicsCollisionHandler::get_almost_stationary_speed(void)
 */
static PyObject *Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_229(PyObject *self, PyObject *) {
  PhysicsCollisionHandler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCollisionHandler, (void **)&local_this, "PhysicsCollisionHandler.get_almost_stationary_speed")) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PhysicsCollisionHandler::get_almost_stationary_speed(void)
  PN_stdfloat return_value = ((*local_this).get_almost_stationary_speed)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_229_comment =
  "C++ Interface:\n"
  "get_almost_stationary_speed(const PhysicsCollisionHandler self)\n";
#else
static const char *Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_229_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsCollisionHandler::set_static_friction_coef(PN_stdfloat coef)
 */
static PyObject *Dtool_PhysicsCollisionHandler_set_static_friction_coef_230(PyObject *self, PyObject *arg) {
  PhysicsCollisionHandler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCollisionHandler, (void **)&local_this, "PhysicsCollisionHandler.set_static_friction_coef")) {
    return nullptr;
  }
  // 1-inline void PhysicsCollisionHandler::set_static_friction_coef(PN_stdfloat coef)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_static_friction_coef)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_static_friction_coef(const PhysicsCollisionHandler self, float coef)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCollisionHandler_set_static_friction_coef_230_comment =
  "C++ Interface:\n"
  "set_static_friction_coef(const PhysicsCollisionHandler self, float coef)\n";
#else
static const char *Dtool_PhysicsCollisionHandler_set_static_friction_coef_230_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PhysicsCollisionHandler::get_static_friction_coef(void)
 */
static PyObject *Dtool_PhysicsCollisionHandler_get_static_friction_coef_231(PyObject *self, PyObject *) {
  PhysicsCollisionHandler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCollisionHandler, (void **)&local_this, "PhysicsCollisionHandler.get_static_friction_coef")) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PhysicsCollisionHandler::get_static_friction_coef(void)
  PN_stdfloat return_value = ((*local_this).get_static_friction_coef)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCollisionHandler_get_static_friction_coef_231_comment =
  "C++ Interface:\n"
  "get_static_friction_coef(const PhysicsCollisionHandler self)\n";
#else
static const char *Dtool_PhysicsCollisionHandler_get_static_friction_coef_231_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsCollisionHandler::set_dynamic_friction_coef(PN_stdfloat coef)
 */
static PyObject *Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_232(PyObject *self, PyObject *arg) {
  PhysicsCollisionHandler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCollisionHandler, (void **)&local_this, "PhysicsCollisionHandler.set_dynamic_friction_coef")) {
    return nullptr;
  }
  // 1-inline void PhysicsCollisionHandler::set_dynamic_friction_coef(PN_stdfloat coef)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_dynamic_friction_coef)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_dynamic_friction_coef(const PhysicsCollisionHandler self, float coef)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_232_comment =
  "C++ Interface:\n"
  "set_dynamic_friction_coef(const PhysicsCollisionHandler self, float coef)\n";
#else
static const char *Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PhysicsCollisionHandler::get_dynamic_friction_coef(void)
 */
static PyObject *Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_233(PyObject *self, PyObject *) {
  PhysicsCollisionHandler *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsCollisionHandler, (void **)&local_this, "PhysicsCollisionHandler.get_dynamic_friction_coef")) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PhysicsCollisionHandler::get_dynamic_friction_coef(void)
  PN_stdfloat return_value = ((*local_this).get_dynamic_friction_coef)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_233_comment =
  "C++ Interface:\n"
  "get_dynamic_friction_coef(const PhysicsCollisionHandler self)\n";
#else
static const char *Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_233_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle PhysicsCollisionHandler::get_class_type(void)
 */
static PyObject *Dtool_PhysicsCollisionHandler_get_class_type_234(PyObject *, PyObject *) {
  // 1-static TypeHandle PhysicsCollisionHandler::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((PhysicsCollisionHandler::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsCollisionHandler_get_class_type_234_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_PhysicsCollisionHandler_get_class_type_234_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PhysicsCollisionHandler::PhysicsCollisionHandler(void)
 */
static int Dtool_Init_PhysicsCollisionHandler(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("PhysicsCollisionHandler() takes no keyword arguments");
    return -1;
#endif
  }
  if (!Dtool_CheckNoArgs(args)) {
    const int parameter_count = (int)PyTuple_GET_SIZE(args);
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no arguments");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "PhysicsCollisionHandler() takes no arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  // 1-PhysicsCollisionHandler::PhysicsCollisionHandler(void)
  PhysicsCollisionHandler *return_value = new PhysicsCollisionHandler();
  if (return_value == nullptr) {
    PyErr_NoMemory();
    return -1;
  }
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return -1;
  }
  return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicsCollisionHandler, true, false);
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PhysicsCollisionHandler()\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PhysicsCollisionHandler(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PhysicsCollisionHandler) {
    printf("PhysicsCollisionHandler ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PhysicsCollisionHandler *local_this = (PhysicsCollisionHandler *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PhysicsCollisionHandler) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandler) {
    return (CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerEvent) {
    return (CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerPhysical) {
    return (CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_CollisionHandlerPusher) {
    return (CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(CollisionHandler *)(CollisionHandlerEvent *)(CollisionHandlerPhysical *)(CollisionHandlerPusher *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PhysicsCollisionHandler(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PhysicsCollisionHandler) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandler) {
    CollisionHandler* other_this = (CollisionHandler*)from_this;
    return (PhysicsCollisionHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerEvent) {
    CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
    return (PhysicsCollisionHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPhysical) {
    CollisionHandlerPhysical* other_this = (CollisionHandlerPhysical*)from_this;
    return (PhysicsCollisionHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_CollisionHandlerPusher) {
    CollisionHandlerPusher* other_this = (CollisionHandlerPusher*)from_this;
    return (PhysicsCollisionHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (PhysicsCollisionHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (PhysicsCollisionHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (PhysicsCollisionHandler*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class PhysicsManager
 */
/**
 * Python function wrapper for:
 * inline void PhysicsManager::attach_linear_integrator(LinearIntegrator *i)
 */
static PyObject *Dtool_PhysicsManager_attach_linear_integrator_238(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.attach_linear_integrator")) {
    return nullptr;
  }
  // 1-inline void PhysicsManager::attach_linear_integrator(LinearIntegrator *i)
  LinearIntegrator *arg_this = (LinearIntegrator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LinearIntegrator, 1, "PhysicsManager.attach_linear_integrator", false, true);
  if (arg_this != nullptr) {
    ((*local_this).attach_linear_integrator)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_linear_integrator(const PhysicsManager self, LinearIntegrator i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_attach_linear_integrator_238_comment =
  "C++ Interface:\n"
  "attach_linear_integrator(const PhysicsManager self, LinearIntegrator i)\n"
  "\n"
  "/**\n"
  " * Hooks a linear integrator into the manager\n"
  " */";
#else
static const char *Dtool_PhysicsManager_attach_linear_integrator_238_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::attach_angular_integrator(AngularIntegrator *i)
 */
static PyObject *Dtool_PhysicsManager_attach_angular_integrator_239(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.attach_angular_integrator")) {
    return nullptr;
  }
  // 1-inline void PhysicsManager::attach_angular_integrator(AngularIntegrator *i)
  AngularIntegrator *arg_this = (AngularIntegrator *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AngularIntegrator, 1, "PhysicsManager.attach_angular_integrator", false, true);
  if (arg_this != nullptr) {
    ((*local_this).attach_angular_integrator)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_angular_integrator(const PhysicsManager self, AngularIntegrator i)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_attach_angular_integrator_239_comment =
  "C++ Interface:\n"
  "attach_angular_integrator(const PhysicsManager self, AngularIntegrator i)\n"
  "\n"
  "/**\n"
  " * Hooks an angular integrator into the manager\n"
  " */";
#else
static const char *Dtool_PhysicsManager_attach_angular_integrator_239_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::attach_physical(Physical *p)
 */
static PyObject *Dtool_PhysicsManager_attach_physical_240(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.attach_physical")) {
    return nullptr;
  }
  // 1-inline void PhysicsManager::attach_physical(Physical *p)
  Physical *arg_this = (Physical *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Physical, 1, "PhysicsManager.attach_physical", false, true);
  if (arg_this != nullptr) {
    ((*local_this).attach_physical)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_physical(const PhysicsManager self, Physical p)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_attach_physical_240_comment =
  "C++ Interface:\n"
  "attach_physical(const PhysicsManager self, Physical p)\n"
  "\n"
  "/**\n"
  " * Registers a Physical class with the manager\n"
  " */";
#else
static const char *Dtool_PhysicsManager_attach_physical_240_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::attach_physicalnode(PhysicalNode *p)
 */
static PyObject *Dtool_PhysicsManager_attach_physicalnode_241(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.attach_physicalnode")) {
    return nullptr;
  }
  // 1-inline void PhysicsManager::attach_physicalnode(PhysicalNode *p)
  PhysicalNode *arg_this = (PhysicalNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicalNode, 1, "PhysicsManager.attach_physicalnode", false, true);
  if (arg_this != nullptr) {
    ((*local_this).attach_physicalnode)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_physicalnode(const PhysicsManager self, PhysicalNode p)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_attach_physicalnode_241_comment =
  "C++ Interface:\n"
  "attach_physicalnode(const PhysicsManager self, PhysicalNode p)\n"
  "\n"
  "// use attach_physical_node instead.\n"
  "\n"
  "/**\n"
  " * Please call attach_physical_node instead.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_attach_physicalnode_241_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::attach_physical_node(PhysicalNode *p)
 */
static PyObject *Dtool_PhysicsManager_attach_physical_node_242(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.attach_physical_node")) {
    return nullptr;
  }
  // 1-inline void PhysicsManager::attach_physical_node(PhysicalNode *p)
  PhysicalNode *arg_this = (PhysicalNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicalNode, 1, "PhysicsManager.attach_physical_node", false, true);
  if (arg_this != nullptr) {
    ((*local_this).attach_physical_node)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "attach_physical_node(const PhysicsManager self, PhysicalNode p)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_attach_physical_node_242_comment =
  "C++ Interface:\n"
  "attach_physical_node(const PhysicsManager self, PhysicalNode p)\n"
  "\n"
  "// use attach_physical_node instead.\n"
  "\n"
  "/**\n"
  " * Registers a physicalnode with the manager\n"
  " */";
#else
static const char *Dtool_PhysicsManager_attach_physical_node_242_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::add_linear_force(LinearForce *f)
 */
static PyObject *Dtool_PhysicsManager_add_linear_force_243(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.add_linear_force")) {
    return nullptr;
  }
  // 1-inline void PhysicsManager::add_linear_force(LinearForce *f)
  LinearForce *arg_this = (LinearForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LinearForce, 1, "PhysicsManager.add_linear_force", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_linear_force)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_linear_force(const PhysicsManager self, LinearForce f)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_add_linear_force_243_comment =
  "C++ Interface:\n"
  "add_linear_force(const PhysicsManager self, LinearForce f)\n"
  "\n"
  "/**\n"
  " * Adds a global linear force to the physics manager\n"
  " */";
#else
static const char *Dtool_PhysicsManager_add_linear_force_243_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::add_angular_force(AngularForce *f)
 */
static PyObject *Dtool_PhysicsManager_add_angular_force_244(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.add_angular_force")) {
    return nullptr;
  }
  // 1-inline void PhysicsManager::add_angular_force(AngularForce *f)
  AngularForce *arg_this = (AngularForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AngularForce, 1, "PhysicsManager.add_angular_force", false, true);
  if (arg_this != nullptr) {
    ((*local_this).add_angular_force)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_angular_force(const PhysicsManager self, AngularForce f)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_add_angular_force_244_comment =
  "C++ Interface:\n"
  "add_angular_force(const PhysicsManager self, AngularForce f)\n"
  "\n"
  "/**\n"
  " * Adds a global angular force to the physics manager\n"
  " */";
#else
static const char *Dtool_PhysicsManager_add_angular_force_244_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::clear_linear_forces(void)
 */
static PyObject *Dtool_PhysicsManager_clear_linear_forces_245(PyObject *self, PyObject *) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.clear_linear_forces")) {
    return nullptr;
  }
  // 1-inline void PhysicsManager::clear_linear_forces(void)
  ((*local_this).clear_linear_forces)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_clear_linear_forces_245_comment =
  "C++ Interface:\n"
  "clear_linear_forces(const PhysicsManager self)\n"
  "\n"
  "/**\n"
  " * Resets the physics manager force vector\n"
  " */";
#else
static const char *Dtool_PhysicsManager_clear_linear_forces_245_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::clear_angular_forces(void)
 */
static PyObject *Dtool_PhysicsManager_clear_angular_forces_246(PyObject *self, PyObject *) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.clear_angular_forces")) {
    return nullptr;
  }
  // 1-inline void PhysicsManager::clear_angular_forces(void)
  ((*local_this).clear_angular_forces)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_clear_angular_forces_246_comment =
  "C++ Interface:\n"
  "clear_angular_forces(const PhysicsManager self)\n"
  "\n"
  "/**\n"
  " * Resets the physics manager force vector\n"
  " */";
#else
static const char *Dtool_PhysicsManager_clear_angular_forces_246_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::clear_physicals(void)
 */
static PyObject *Dtool_PhysicsManager_clear_physicals_247(PyObject *self, PyObject *) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.clear_physicals")) {
    return nullptr;
  }
  // 1-inline void PhysicsManager::clear_physicals(void)
  ((*local_this).clear_physicals)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_clear_physicals_247_comment =
  "C++ Interface:\n"
  "clear_physicals(const PhysicsManager self)\n"
  "\n"
  "/**\n"
  " * Resets the physics manager objects vector\n"
  " */";
#else
static const char *Dtool_PhysicsManager_clear_physicals_247_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void PhysicsManager::set_viscosity(PN_stdfloat viscosity)
 */
static PyObject *Dtool_PhysicsManager_set_viscosity_248(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.set_viscosity")) {
    return nullptr;
  }
  // 1-inline void PhysicsManager::set_viscosity(PN_stdfloat viscosity)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_viscosity)((PN_stdfloat)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_viscosity(const PhysicsManager self, float viscosity)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_set_viscosity_248_comment =
  "C++ Interface:\n"
  "set_viscosity(const PhysicsManager self, float viscosity)\n"
  "\n"
  "/**\n"
  " * Set the global viscosity.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_set_viscosity_248_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PN_stdfloat PhysicsManager::get_viscosity(void) const
 */
static PyObject *Dtool_PhysicsManager_get_viscosity_249(PyObject *self, PyObject *) {
  PhysicsManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsManager)) {
    return nullptr;
  }
  // 1-inline PN_stdfloat PhysicsManager::get_viscosity(void) const
  PN_stdfloat return_value = ((*(const PhysicsManager*)local_this).get_viscosity)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_get_viscosity_249_comment =
  "C++ Interface:\n"
  "get_viscosity(PhysicsManager self)\n"
  "\n"
  "/**\n"
  " * Get the global viscosity.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_get_viscosity_249_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsManager::remove_physical(Physical *p)
 */
static PyObject *Dtool_PhysicsManager_remove_physical_250(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.remove_physical")) {
    return nullptr;
  }
  // 1-void PhysicsManager::remove_physical(Physical *p)
  Physical *arg_this = (Physical *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_Physical, 1, "PhysicsManager.remove_physical", false, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_physical)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_physical(const PhysicsManager self, Physical p)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_remove_physical_250_comment =
  "C++ Interface:\n"
  "remove_physical(const PhysicsManager self, Physical p)\n"
  "\n"
  "/**\n"
  " * takes a physical out of the object list\n"
  " */";
#else
static const char *Dtool_PhysicsManager_remove_physical_250_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsManager::remove_physical_node(PhysicalNode *p)
 */
static PyObject *Dtool_PhysicsManager_remove_physical_node_251(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.remove_physical_node")) {
    return nullptr;
  }
  // 1-void PhysicsManager::remove_physical_node(PhysicalNode *p)
  PhysicalNode *arg_this = (PhysicalNode *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicalNode, 1, "PhysicsManager.remove_physical_node", false, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_physical_node)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_physical_node(const PhysicsManager self, PhysicalNode p)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_remove_physical_node_251_comment =
  "C++ Interface:\n"
  "remove_physical_node(const PhysicsManager self, PhysicalNode p)\n"
  "\n"
  "/**\n"
  " * Removes a physicalnode from the manager\n"
  " */";
#else
static const char *Dtool_PhysicsManager_remove_physical_node_251_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsManager::remove_linear_force(LinearForce *f)
 */
static PyObject *Dtool_PhysicsManager_remove_linear_force_252(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.remove_linear_force")) {
    return nullptr;
  }
  // 1-void PhysicsManager::remove_linear_force(LinearForce *f)
  LinearForce *arg_this = (LinearForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LinearForce, 1, "PhysicsManager.remove_linear_force", false, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_linear_force)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_linear_force(const PhysicsManager self, LinearForce f)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_remove_linear_force_252_comment =
  "C++ Interface:\n"
  "remove_linear_force(const PhysicsManager self, LinearForce f)\n"
  "\n"
  "/**\n"
  " * takes a linear force out of the physics list\n"
  " */";
#else
static const char *Dtool_PhysicsManager_remove_linear_force_252_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsManager::remove_angular_force(AngularForce *f)
 */
static PyObject *Dtool_PhysicsManager_remove_angular_force_253(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.remove_angular_force")) {
    return nullptr;
  }
  // 1-void PhysicsManager::remove_angular_force(AngularForce *f)
  AngularForce *arg_this = (AngularForce *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_AngularForce, 1, "PhysicsManager.remove_angular_force", false, true);
  if (arg_this != nullptr) {
    ((*local_this).remove_angular_force)(arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_angular_force(const PhysicsManager self, AngularForce f)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_remove_angular_force_253_comment =
  "C++ Interface:\n"
  "remove_angular_force(const PhysicsManager self, AngularForce f)\n"
  "\n"
  "/**\n"
  " * takes an angular force out of the physics list\n"
  " */";
#else
static const char *Dtool_PhysicsManager_remove_angular_force_253_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsManager::do_physics(PN_stdfloat dt)
 * void PhysicsManager::do_physics(PN_stdfloat dt, Physical *p)
 */
static PyObject *Dtool_PhysicsManager_do_physics_254(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.do_physics")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "dt")) {
        // 1-void PhysicsManager::do_physics(PN_stdfloat dt)
        if (PyNumber_Check(arg)) {
          ((*local_this).do_physics)((PN_stdfloat)PyFloat_AsDouble(arg));
          return Dtool_Return_None();
        }
      }
    }
    break;
  case 2:
    {
      // 1-void PhysicsManager::do_physics(PN_stdfloat dt, Physical *p)
      float param1;
      PyObject *param2;
      static const char *keyword_list[] = {"dt", "p", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fO:do_physics", (char **)keyword_list, &param1, &param2)) {
        Physical *param2_this = (Physical *)DTOOL_Call_GetPointerThisClass(param2, Dtool_Ptr_Physical, 2, "PhysicsManager.do_physics", false, true);
        if (param2_this != nullptr) {
          ((*local_this).do_physics)((PN_stdfloat)param1, param2_this);
          return Dtool_Return_None();
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "do_physics() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "do_physics(const PhysicsManager self, float dt)\n"
      "do_physics(const PhysicsManager self, float dt, Physical p)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_do_physics_254_comment =
  "C++ Interface:\n"
  "do_physics(const PhysicsManager self, float dt)\n"
  "do_physics(const PhysicsManager self, float dt, Physical p)\n"
  "\n"
  "/**\n"
  " * This is the main high-level API call.  Performs integration on every\n"
  " * attached Physical.\n"
  " */\n"
  "\n"
  "/**\n"
  " * This is the main high-level API call.  Performs integration on a single\n"
  " * physical.  Make sure its associated forces are active.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_do_physics_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void PhysicsManager::init_random_seed(void)
 */
static PyObject *Dtool_PhysicsManager_init_random_seed_255(PyObject *self, PyObject *) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_PhysicsManager, (void **)&local_this, "PhysicsManager.init_random_seed")) {
    return nullptr;
  }
  // 1-void PhysicsManager::init_random_seed(void)
  ((*local_this).init_random_seed)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_init_random_seed_255_comment =
  "C++ Interface:\n"
  "init_random_seed(const PhysicsManager self)\n"
  "\n"
  "/**\n"
  " * One-time config function, sets up the random seed used by the physics and\n"
  " * particle systems.  For synchronizing across distributed computers\n"
  " */";
#else
static const char *Dtool_PhysicsManager_init_random_seed_255_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsManager::output(std::ostream &out) const
 */
static PyObject *Dtool_PhysicsManager_output_256(PyObject *self, PyObject *arg) {
  PhysicsManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsManager)) {
    return nullptr;
  }
  // 1-virtual void PhysicsManager::output(std::ostream &out) const
  std::ostream *arg_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_std_ostream, 1, "PhysicsManager.output", false, true);
  if (arg_this != nullptr) {
    ((*(const PhysicsManager*)local_this).output)(*arg_this);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "output(PhysicsManager self, ostream out)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_output_256_comment =
  "C++ Interface:\n"
  "output(PhysicsManager self, ostream out)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_output_256_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsManager::write_physicals(std::ostream &out, int indent = 0) const
 */
static PyObject *Dtool_PhysicsManager_write_physicals_257(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsManager)) {
    return nullptr;
  }
  // 1-virtual void PhysicsManager::write_physicals(std::ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write_physicals", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "PhysicsManager.write_physicals", false, true);
    if (param1_this != nullptr) {
      ((*(const PhysicsManager*)local_this).write_physicals)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_physicals(PhysicsManager self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_write_physicals_257_comment =
  "C++ Interface:\n"
  "write_physicals(PhysicsManager self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_write_physicals_257_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsManager::write_linear_forces(std::ostream &out, int indent = 0) const
 */
static PyObject *Dtool_PhysicsManager_write_linear_forces_258(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsManager)) {
    return nullptr;
  }
  // 1-virtual void PhysicsManager::write_linear_forces(std::ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write_linear_forces", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "PhysicsManager.write_linear_forces", false, true);
    if (param1_this != nullptr) {
      ((*(const PhysicsManager*)local_this).write_linear_forces)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_linear_forces(PhysicsManager self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_write_linear_forces_258_comment =
  "C++ Interface:\n"
  "write_linear_forces(PhysicsManager self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_write_linear_forces_258_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsManager::write_angular_forces(std::ostream &out, int indent = 0) const
 */
static PyObject *Dtool_PhysicsManager_write_angular_forces_259(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsManager)) {
    return nullptr;
  }
  // 1-virtual void PhysicsManager::write_angular_forces(std::ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write_angular_forces", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "PhysicsManager.write_angular_forces", false, true);
    if (param1_this != nullptr) {
      ((*(const PhysicsManager*)local_this).write_angular_forces)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write_angular_forces(PhysicsManager self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_write_angular_forces_259_comment =
  "C++ Interface:\n"
  "write_angular_forces(PhysicsManager self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_write_angular_forces_259_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsManager::write(std::ostream &out, int indent = 0) const
 */
static PyObject *Dtool_PhysicsManager_write_260(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsManager)) {
    return nullptr;
  }
  // 1-virtual void PhysicsManager::write(std::ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:write", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "PhysicsManager.write", false, true);
    if (param1_this != nullptr) {
      ((*(const PhysicsManager*)local_this).write)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "write(PhysicsManager self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_write_260_comment =
  "C++ Interface:\n"
  "write(PhysicsManager self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_write_260_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void PhysicsManager::debug_output(std::ostream &out, int indent = 0) const
 */
static PyObject *Dtool_PhysicsManager_debug_output_261(PyObject *self, PyObject *args, PyObject *kwds) {
  PhysicsManager *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_PhysicsManager)) {
    return nullptr;
  }
  // 1-virtual void PhysicsManager::debug_output(std::ostream &out, int indent = 0) const
  PyObject *param1;
  int param2 = 0;
  static const char *keyword_list[] = {"out", "indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|i:debug_output", (char **)keyword_list, &param1, &param2)) {
    std::ostream *param1_this = (std::ostream *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_std_ostream, 1, "PhysicsManager.debug_output", false, true);
    if (param1_this != nullptr) {
      ((*(const PhysicsManager*)local_this).debug_output)(*param1_this, (int)param2);
      return Dtool_Return_None();
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "debug_output(PhysicsManager self, ostream out, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_PhysicsManager_debug_output_261_comment =
  "C++ Interface:\n"
  "debug_output(PhysicsManager self, ostream out, int indent)\n"
  "\n"
  "/**\n"
  " * Write a string representation of this instance to <out>.\n"
  " */";
#else
static const char *Dtool_PhysicsManager_debug_output_261_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PhysicsManager::PhysicsManager(void)
 * inline PhysicsManager::PhysicsManager(PhysicsManager const &) = default
 */
static int Dtool_Init_PhysicsManager(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("PhysicsManager() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-PhysicsManager::PhysicsManager(void)
      PhysicsManager *return_value = new PhysicsManager();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicsManager, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline PhysicsManager::PhysicsManager(PhysicsManager const &) = default
      PhysicsManager const *arg_this = (PhysicsManager *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsManager, 0, "PhysicsManager.PhysicsManager", true, true);
      if (arg_this != nullptr) {
        PhysicsManager *return_value = new PhysicsManager(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_PhysicsManager, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "PhysicsManager() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "PhysicsManager()\n"
      "PhysicsManager(const PhysicsManager param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_PhysicsManager(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_PhysicsManager) {
    printf("PhysicsManager ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  PhysicsManager *local_this = (PhysicsManager *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_PhysicsManager) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_PhysicsManager(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_PhysicsManager) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python method tables for PhysicsObject (PhysicsObject)
 */
static PyMethodDef Dtool_Methods_PhysicsObject[] = {
  {"assign", &Dtool_PhysicsObject_operator_4, METH_O, (const char *)Dtool_PhysicsObject_operator_4_comment},
  {"set_active", &Dtool_PhysicsObject_set_active_5, METH_O, (const char *)Dtool_PhysicsObject_set_active_5_comment},
  {"setActive", &Dtool_PhysicsObject_set_active_5, METH_O, (const char *)Dtool_PhysicsObject_set_active_5_comment},
  {"get_active", &Dtool_PhysicsObject_get_active_6, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_active_6_comment},
  {"getActive", &Dtool_PhysicsObject_get_active_6, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_active_6_comment},
  {"set_mass", &Dtool_PhysicsObject_set_mass_7, METH_O, (const char *)Dtool_PhysicsObject_set_mass_7_comment},
  {"setMass", &Dtool_PhysicsObject_set_mass_7, METH_O, (const char *)Dtool_PhysicsObject_set_mass_7_comment},
  {"get_mass", &Dtool_PhysicsObject_get_mass_8, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_mass_8_comment},
  {"getMass", &Dtool_PhysicsObject_get_mass_8, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_mass_8_comment},
  {"set_position", (PyCFunction) &Dtool_PhysicsObject_set_position_9, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_set_position_9_comment},
  {"setPosition", (PyCFunction) &Dtool_PhysicsObject_set_position_9, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_set_position_9_comment},
  {"get_position", &Dtool_PhysicsObject_get_position_10, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_position_10_comment},
  {"getPosition", &Dtool_PhysicsObject_get_position_10, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_position_10_comment},
  {"reset_position", &Dtool_PhysicsObject_reset_position_11, METH_O, (const char *)Dtool_PhysicsObject_reset_position_11_comment},
  {"resetPosition", &Dtool_PhysicsObject_reset_position_11, METH_O, (const char *)Dtool_PhysicsObject_reset_position_11_comment},
  {"set_last_position", &Dtool_PhysicsObject_set_last_position_12, METH_O, (const char *)Dtool_PhysicsObject_set_last_position_12_comment},
  {"setLastPosition", &Dtool_PhysicsObject_set_last_position_12, METH_O, (const char *)Dtool_PhysicsObject_set_last_position_12_comment},
  {"get_last_position", &Dtool_PhysicsObject_get_last_position_13, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_last_position_13_comment},
  {"getLastPosition", &Dtool_PhysicsObject_get_last_position_13, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_last_position_13_comment},
  {"set_velocity", (PyCFunction) &Dtool_PhysicsObject_set_velocity_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_set_velocity_14_comment},
  {"setVelocity", (PyCFunction) &Dtool_PhysicsObject_set_velocity_14, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_set_velocity_14_comment},
  {"get_velocity", &Dtool_PhysicsObject_get_velocity_15, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_velocity_15_comment},
  {"getVelocity", &Dtool_PhysicsObject_get_velocity_15, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_velocity_15_comment},
  {"get_implicit_velocity", &Dtool_PhysicsObject_get_implicit_velocity_16, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_implicit_velocity_16_comment},
  {"getImplicitVelocity", &Dtool_PhysicsObject_get_implicit_velocity_16, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_implicit_velocity_16_comment},
  {"add_torque", &Dtool_PhysicsObject_add_torque_17, METH_O, (const char *)Dtool_PhysicsObject_add_torque_17_comment},
  {"addTorque", &Dtool_PhysicsObject_add_torque_17, METH_O, (const char *)Dtool_PhysicsObject_add_torque_17_comment},
  {"add_impulse", &Dtool_PhysicsObject_add_impulse_18, METH_O, (const char *)Dtool_PhysicsObject_add_impulse_18_comment},
  {"addImpulse", &Dtool_PhysicsObject_add_impulse_18, METH_O, (const char *)Dtool_PhysicsObject_add_impulse_18_comment},
  {"add_impact", (PyCFunction) &Dtool_PhysicsObject_add_impact_19, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_add_impact_19_comment},
  {"addImpact", (PyCFunction) &Dtool_PhysicsObject_add_impact_19, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_add_impact_19_comment},
  {"add_local_torque", &Dtool_PhysicsObject_add_local_torque_20, METH_O, (const char *)Dtool_PhysicsObject_add_local_torque_20_comment},
  {"addLocalTorque", &Dtool_PhysicsObject_add_local_torque_20, METH_O, (const char *)Dtool_PhysicsObject_add_local_torque_20_comment},
  {"add_local_impulse", &Dtool_PhysicsObject_add_local_impulse_21, METH_O, (const char *)Dtool_PhysicsObject_add_local_impulse_21_comment},
  {"addLocalImpulse", &Dtool_PhysicsObject_add_local_impulse_21, METH_O, (const char *)Dtool_PhysicsObject_add_local_impulse_21_comment},
  {"add_local_impact", (PyCFunction) &Dtool_PhysicsObject_add_local_impact_22, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_add_local_impact_22_comment},
  {"addLocalImpact", (PyCFunction) &Dtool_PhysicsObject_add_local_impact_22, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_add_local_impact_22_comment},
  {"set_terminal_velocity", &Dtool_PhysicsObject_set_terminal_velocity_23, METH_O, (const char *)Dtool_PhysicsObject_set_terminal_velocity_23_comment},
  {"setTerminalVelocity", &Dtool_PhysicsObject_set_terminal_velocity_23, METH_O, (const char *)Dtool_PhysicsObject_set_terminal_velocity_23_comment},
  {"get_terminal_velocity", &Dtool_PhysicsObject_get_terminal_velocity_24, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_terminal_velocity_24_comment},
  {"getTerminalVelocity", &Dtool_PhysicsObject_get_terminal_velocity_24, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_terminal_velocity_24_comment},
  {"set_oriented", &Dtool_PhysicsObject_set_oriented_25, METH_O, (const char *)Dtool_PhysicsObject_set_oriented_25_comment},
  {"setOriented", &Dtool_PhysicsObject_set_oriented_25, METH_O, (const char *)Dtool_PhysicsObject_set_oriented_25_comment},
  {"get_oriented", &Dtool_PhysicsObject_get_oriented_26, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_oriented_26_comment},
  {"getOriented", &Dtool_PhysicsObject_get_oriented_26, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_oriented_26_comment},
  {"set_orientation", &Dtool_PhysicsObject_set_orientation_27, METH_O, (const char *)Dtool_PhysicsObject_set_orientation_27_comment},
  {"setOrientation", &Dtool_PhysicsObject_set_orientation_27, METH_O, (const char *)Dtool_PhysicsObject_set_orientation_27_comment},
  {"get_orientation", &Dtool_PhysicsObject_get_orientation_28, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_orientation_28_comment},
  {"getOrientation", &Dtool_PhysicsObject_get_orientation_28, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_orientation_28_comment},
  {"reset_orientation", &Dtool_PhysicsObject_reset_orientation_29, METH_O, (const char *)Dtool_PhysicsObject_reset_orientation_29_comment},
  {"resetOrientation", &Dtool_PhysicsObject_reset_orientation_29, METH_O, (const char *)Dtool_PhysicsObject_reset_orientation_29_comment},
  {"set_rotation", &Dtool_PhysicsObject_set_rotation_30, METH_O, (const char *)Dtool_PhysicsObject_set_rotation_30_comment},
  {"setRotation", &Dtool_PhysicsObject_set_rotation_30, METH_O, (const char *)Dtool_PhysicsObject_set_rotation_30_comment},
  {"get_rotation", &Dtool_PhysicsObject_get_rotation_31, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_rotation_31_comment},
  {"getRotation", &Dtool_PhysicsObject_get_rotation_31, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_rotation_31_comment},
  {"get_inertial_tensor", &Dtool_PhysicsObject_get_inertial_tensor_32, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_inertial_tensor_32_comment},
  {"getInertialTensor", &Dtool_PhysicsObject_get_inertial_tensor_32, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_inertial_tensor_32_comment},
  {"get_lcs", &Dtool_PhysicsObject_get_lcs_33, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_lcs_33_comment},
  {"getLcs", &Dtool_PhysicsObject_get_lcs_33, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_lcs_33_comment},
  {"make_copy", &Dtool_PhysicsObject_make_copy_34, METH_NOARGS, (const char *)Dtool_PhysicsObject_make_copy_34_comment},
  {"makeCopy", &Dtool_PhysicsObject_make_copy_34, METH_NOARGS, (const char *)Dtool_PhysicsObject_make_copy_34_comment},
  {"set_name", &Dtool_PhysicsObject_set_name_35, METH_O, (const char *)Dtool_PhysicsObject_set_name_35_comment},
  {"setName", &Dtool_PhysicsObject_set_name_35, METH_O, (const char *)Dtool_PhysicsObject_set_name_35_comment},
  {"get_name", &Dtool_PhysicsObject_get_name_36, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_name_36_comment},
  {"getName", &Dtool_PhysicsObject_get_name_36, METH_NOARGS, (const char *)Dtool_PhysicsObject_get_name_36_comment},
  {"output", &Dtool_PhysicsObject_output_37, METH_O, (const char *)Dtool_PhysicsObject_output_37_comment},
  {"write", (PyCFunction) &Dtool_PhysicsObject_write_38, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObject_write_38_comment},
  {"get_class_type", &Dtool_PhysicsObject_get_class_type_39, METH_NOARGS | METH_STATIC, (const char *)Dtool_PhysicsObject_get_class_type_39_comment},
  {"getClassType", &Dtool_PhysicsObject_get_class_type_39, METH_NOARGS | METH_STATIC, (const char *)Dtool_PhysicsObject_get_class_type_39_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PhysicsObject
//////////////////
static PyObject *Dtool_Repr_PhysicsObject(PyObject *self) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     PhysicsObject
//////////////////
static PyObject *Dtool_Str_PhysicsObject(PyObject *self) {
  PhysicsObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObject, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PhysicsObject = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PhysicsObject = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PhysicsObject = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PhysicsObject = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PhysicsObject = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PhysicsObject = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.PhysicsObject",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PhysicsObject,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PhysicsObject,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PhysicsObject,
    &Dtool_NumberMethods_PhysicsObject,
    &Dtool_SequenceMethods_PhysicsObject,
    &Dtool_MappingMethods_PhysicsObject,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_PhysicsObject,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PhysicsObject,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A body on which physics will be applied.  If you're looking to add physical\n"
    " * motion to your class, do NOT derive from this.  Derive from Physical\n"
    " * instead.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PhysicsObject,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PhysicsObject,
    PyType_GenericAlloc,
    Dtool_new_PhysicsObject,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PhysicsObject,
  Dtool_UpcastInterface_PhysicsObject,
  Dtool_DowncastInterface_PhysicsObject,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PhysicsObject(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_PhysicsObject._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_PhysicsObject._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PhysicsObject._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PhysicsObject) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PhysicsObject)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PhysicsObject);
  }
}

/**
 * Python method tables for PhysicsObjectCollection (PhysicsObjectCollection)
 */
static PyMethodDef Dtool_Methods_PhysicsObjectCollection[] = {
  {"assign", &Dtool_PhysicsObjectCollection_operator_42, METH_O, (const char *)Dtool_PhysicsObjectCollection_operator_42_comment},
  {"add_physics_object", &Dtool_PhysicsObjectCollection_add_physics_object_44, METH_O, (const char *)Dtool_PhysicsObjectCollection_add_physics_object_44_comment},
  {"addPhysicsObject", &Dtool_PhysicsObjectCollection_add_physics_object_44, METH_O, (const char *)Dtool_PhysicsObjectCollection_add_physics_object_44_comment},
  {"remove_physics_object", &Dtool_PhysicsObjectCollection_remove_physics_object_45, METH_O, (const char *)Dtool_PhysicsObjectCollection_remove_physics_object_45_comment},
  {"removePhysicsObject", &Dtool_PhysicsObjectCollection_remove_physics_object_45, METH_O, (const char *)Dtool_PhysicsObjectCollection_remove_physics_object_45_comment},
  {"add_physics_objects_from", &Dtool_PhysicsObjectCollection_add_physics_objects_from_46, METH_O, (const char *)Dtool_PhysicsObjectCollection_add_physics_objects_from_46_comment},
  {"addPhysicsObjectsFrom", &Dtool_PhysicsObjectCollection_add_physics_objects_from_46, METH_O, (const char *)Dtool_PhysicsObjectCollection_add_physics_objects_from_46_comment},
  {"remove_physics_objects_from", &Dtool_PhysicsObjectCollection_remove_physics_objects_from_47, METH_O, (const char *)Dtool_PhysicsObjectCollection_remove_physics_objects_from_47_comment},
  {"removePhysicsObjectsFrom", &Dtool_PhysicsObjectCollection_remove_physics_objects_from_47, METH_O, (const char *)Dtool_PhysicsObjectCollection_remove_physics_objects_from_47_comment},
  {"remove_duplicate_physics_objects", &Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_48, METH_NOARGS, (const char *)Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_48_comment},
  {"removeDuplicatePhysicsObjects", &Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_48, METH_NOARGS, (const char *)Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_48_comment},
  {"has_physics_object", &Dtool_PhysicsObjectCollection_has_physics_object_49, METH_O, (const char *)Dtool_PhysicsObjectCollection_has_physics_object_49_comment},
  {"hasPhysicsObject", &Dtool_PhysicsObjectCollection_has_physics_object_49, METH_O, (const char *)Dtool_PhysicsObjectCollection_has_physics_object_49_comment},
  {"clear", &Dtool_PhysicsObjectCollection_clear_50, METH_NOARGS, (const char *)Dtool_PhysicsObjectCollection_clear_50_comment},
  {"is_empty", &Dtool_PhysicsObjectCollection_is_empty_51, METH_NOARGS, (const char *)Dtool_PhysicsObjectCollection_is_empty_51_comment},
  {"isEmpty", &Dtool_PhysicsObjectCollection_is_empty_51, METH_NOARGS, (const char *)Dtool_PhysicsObjectCollection_is_empty_51_comment},
  {"get_num_physics_objects", &Dtool_PhysicsObjectCollection_get_num_physics_objects_52, METH_NOARGS, (const char *)Dtool_PhysicsObjectCollection_get_num_physics_objects_52_comment},
  {"getNumPhysicsObjects", &Dtool_PhysicsObjectCollection_get_num_physics_objects_52, METH_NOARGS, (const char *)Dtool_PhysicsObjectCollection_get_num_physics_objects_52_comment},
  {"get_physics_object", &Dtool_PhysicsObjectCollection_get_physics_object_53, METH_O, (const char *)Dtool_PhysicsObjectCollection_get_physics_object_53_comment},
  {"getPhysicsObject", &Dtool_PhysicsObjectCollection_get_physics_object_53, METH_O, (const char *)Dtool_PhysicsObjectCollection_get_physics_object_53_comment},
  {"output", &Dtool_PhysicsObjectCollection_output_59, METH_O, (const char *)Dtool_PhysicsObjectCollection_output_59_comment},
  {"write", (PyCFunction) &Dtool_PhysicsObjectCollection_write_60, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsObjectCollection_write_60_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_physics_objects", (PyCFunction) &MakeSeq_PhysicsObjectCollection_get_physics_objects, METH_NOARGS, nullptr},
  { "getPhysicsObjects", (PyCFunction) &MakeSeq_PhysicsObjectCollection_get_physics_objects, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PhysicsObjectCollection slot nb_add -> operator +
//////////////////
static PyObject *Dtool_PhysicsObjectCollection_operator_58_nb_add(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PhysicsObjectCollection, (void **)&local_this);
  if (local_this == nullptr) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline PhysicsObjectCollection PhysicsObjectCollection::operator +(PhysicsObjectCollection const &other) const
  PhysicsObjectCollection const *arg_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObjectCollection, 1, "PhysicsObjectCollection.__add__", true, true);
  if (arg_this != nullptr) {
    PhysicsObjectCollection *return_value = new PhysicsObjectCollection(((*(const PhysicsObjectCollection*)local_this).operator +)(*arg_this));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      delete return_value;
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_PhysicsObjectCollection, true, false);
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PhysicsObjectCollection slot nb_inplace_add -> operator +=
//////////////////
static PyObject *Dtool_PhysicsObjectCollection_operator_57_nb_inplace_add(PyObject *self, PyObject *arg) {
  PhysicsObjectCollection *local_this = nullptr;
  DTOOL_Call_ExtractThisPointerForType(self, &Dtool_PhysicsObjectCollection, (void **)&local_this);
  if (local_this == nullptr || DtoolInstance_IS_CONST(self)) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  // 1-inline void PhysicsObjectCollection::operator +=(PhysicsObjectCollection const &other)
  PhysicsObjectCollection const *arg_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_PhysicsObjectCollection, 1, "PhysicsObjectCollection.__iadd__", true, true);
  if (arg_this != nullptr) {
    ((*local_this).operator +=)(*arg_this);
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      return Dtool_Raise_AssertionError();
    }
#endif
    Py_INCREF(self);
    return self;
  }
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PhysicsObjectCollection slot sq_item -> operator []
//////////////////
static PyObject *Dtool_PhysicsObjectCollection_operator_55_sq_item(PyObject *self, Py_ssize_t index) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObjectCollection, (void **)&local_this)) {
    return nullptr;
  }

  if (index < 0 || index >= (Py_ssize_t) local_this->size()) {
    PyErr_SetString(PyExc_IndexError, "PhysicsObjectCollection index out of range");
    return nullptr;
  }
  // 1-PointerTo< PhysicsObject > PhysicsObjectCollection::operator [](int index) const
  PointerTo< PhysicsObject > return_value = ((*(const PhysicsObjectCollection*)local_this).operator [])(index);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  PhysicsObject *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_PhysicsObject, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__getitem__(PhysicsObjectCollection self, index)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// PhysicsObjectCollection slot sq_length -> size
//////////////////
static Py_ssize_t Dtool_PhysicsObjectCollection_size_56_sq_length(PyObject *self) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObjectCollection, (void **)&local_this)) {
    return -1;
  }

  return (Py_ssize_t) local_this->size();
}

//////////////////
//  A __repr__ function
//     PhysicsObjectCollection
//////////////////
static PyObject *Dtool_Repr_PhysicsObjectCollection(PyObject *self) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObjectCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     PhysicsObjectCollection
//////////////////
static PyObject *Dtool_Str_PhysicsObjectCollection(PyObject *self) {
  PhysicsObjectCollection *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsObjectCollection, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PhysicsObjectCollection = {
  &Dtool_PhysicsObjectCollection_operator_58_nb_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  &Dtool_PhysicsObjectCollection_operator_57_nb_inplace_add,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PhysicsObjectCollection = {
  &Dtool_PhysicsObjectCollection_size_56_sq_length,
  nullptr,
  nullptr,
  &Dtool_PhysicsObjectCollection_operator_55_sq_item,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

struct Dtool_PyTypedObject Dtool_PhysicsObjectCollection = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.PhysicsObjectCollection",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PhysicsObjectCollection,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PhysicsObjectCollection,
    &Dtool_NumberMethods_PhysicsObjectCollection,
    &Dtool_SequenceMethods_PhysicsObjectCollection,
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_PhysicsObjectCollection,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * This is a set of zero or more PhysicsObjects.  It's handy for returning\n"
    " * from functions that need to return multiple PhysicsObjects.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PhysicsObjectCollection,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PhysicsObjectCollection,
    PyType_GenericAlloc,
    Dtool_new_PhysicsObjectCollection,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PhysicsObjectCollection,
  Dtool_UpcastInterface_PhysicsObjectCollection,
  Dtool_DowncastInterface_PhysicsObjectCollection,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PhysicsObjectCollection(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PhysicsObjectCollection._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PhysicsObjectCollection._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PhysicsObjectCollection) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PhysicsObjectCollection)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PhysicsObjectCollection);
  }
}

/**
 * Python method tables for BaseForce (BaseForce)
 */
static PyMethodDef Dtool_Methods_BaseForce[] = {
  {"get_active", &Dtool_BaseForce_get_active_62, METH_NOARGS, (const char *)Dtool_BaseForce_get_active_62_comment},
  {"getActive", &Dtool_BaseForce_get_active_62, METH_NOARGS, (const char *)Dtool_BaseForce_get_active_62_comment},
  {"set_active", &Dtool_BaseForce_set_active_63, METH_O, (const char *)Dtool_BaseForce_set_active_63_comment},
  {"setActive", &Dtool_BaseForce_set_active_63, METH_O, (const char *)Dtool_BaseForce_set_active_63_comment},
  {"is_linear", &Dtool_BaseForce_is_linear_64, METH_NOARGS, (const char *)Dtool_BaseForce_is_linear_64_comment},
  {"isLinear", &Dtool_BaseForce_is_linear_64, METH_NOARGS, (const char *)Dtool_BaseForce_is_linear_64_comment},
  {"get_force_node", &Dtool_BaseForce_get_force_node_65, METH_NOARGS, (const char *)Dtool_BaseForce_get_force_node_65_comment},
  {"getForceNode", &Dtool_BaseForce_get_force_node_65, METH_NOARGS, (const char *)Dtool_BaseForce_get_force_node_65_comment},
  {"get_force_node_path", &Dtool_BaseForce_get_force_node_path_66, METH_NOARGS, (const char *)Dtool_BaseForce_get_force_node_path_66_comment},
  {"getForceNodePath", &Dtool_BaseForce_get_force_node_path_66, METH_NOARGS, (const char *)Dtool_BaseForce_get_force_node_path_66_comment},
  {"output", &Dtool_BaseForce_output_67, METH_O, (const char *)Dtool_BaseForce_output_67_comment},
  {"write", (PyCFunction) &Dtool_BaseForce_write_68, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseForce_write_68_comment},
  {"get_class_type", &Dtool_BaseForce_get_class_type_69, METH_NOARGS | METH_STATIC, (const char *)Dtool_BaseForce_get_class_type_69_comment},
  {"getClassType", &Dtool_BaseForce_get_class_type_69, METH_NOARGS | METH_STATIC, (const char *)Dtool_BaseForce_get_class_type_69_comment},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     BaseForce
//////////////////
static PyObject *Dtool_Repr_BaseForce(PyObject *self) {
  BaseForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseForce, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BaseForce
//////////////////
static PyObject *Dtool_Str_BaseForce(PyObject *self) {
  BaseForce *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseForce, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_BaseForce = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BaseForce = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BaseForce = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BaseForce = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BaseForce = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BaseForce = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.BaseForce",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BaseForce,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BaseForce,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_BaseForce,
    &Dtool_NumberMethods_BaseForce,
    &Dtool_SequenceMethods_BaseForce,
    &Dtool_MappingMethods_BaseForce,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_BaseForce,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BaseForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * pure virtual base class for all forces that could POSSIBLY exist.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BaseForce,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BaseForce,
    PyType_GenericAlloc,
    Dtool_new_BaseForce,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BaseForce,
  Dtool_UpcastInterface_BaseForce,
  Dtool_DowncastInterface_BaseForce,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BaseForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_BaseForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_BaseForce._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BaseForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BaseForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BaseForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BaseForce);
  }
}

/**
 * Python method tables for LinearForce (LinearForce)
 */
static PyMethodDef Dtool_Methods_LinearForce[] = {
  {"set_amplitude", &Dtool_LinearForce_set_amplitude_71, METH_O, (const char *)Dtool_LinearForce_set_amplitude_71_comment},
  {"setAmplitude", &Dtool_LinearForce_set_amplitude_71, METH_O, (const char *)Dtool_LinearForce_set_amplitude_71_comment},
  {"set_mass_dependent", &Dtool_LinearForce_set_mass_dependent_72, METH_O, (const char *)Dtool_LinearForce_set_mass_dependent_72_comment},
  {"setMassDependent", &Dtool_LinearForce_set_mass_dependent_72, METH_O, (const char *)Dtool_LinearForce_set_mass_dependent_72_comment},
  {"get_amplitude", &Dtool_LinearForce_get_amplitude_73, METH_NOARGS, (const char *)Dtool_LinearForce_get_amplitude_73_comment},
  {"getAmplitude", &Dtool_LinearForce_get_amplitude_73, METH_NOARGS, (const char *)Dtool_LinearForce_get_amplitude_73_comment},
  {"get_mass_dependent", &Dtool_LinearForce_get_mass_dependent_74, METH_NOARGS, (const char *)Dtool_LinearForce_get_mass_dependent_74_comment},
  {"getMassDependent", &Dtool_LinearForce_get_mass_dependent_74, METH_NOARGS, (const char *)Dtool_LinearForce_get_mass_dependent_74_comment},
  {"set_vector_masks", (PyCFunction) &Dtool_LinearForce_set_vector_masks_75, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LinearForce_set_vector_masks_75_comment},
  {"setVectorMasks", (PyCFunction) &Dtool_LinearForce_set_vector_masks_75, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LinearForce_set_vector_masks_75_comment},
  {"get_vector_masks", &Dtool_LinearForce_get_vector_masks_76, METH_NOARGS, (const char *)Dtool_LinearForce_get_vector_masks_76_comment},
  {"getVectorMasks", &Dtool_LinearForce_get_vector_masks_76, METH_NOARGS, (const char *)Dtool_LinearForce_get_vector_masks_76_comment},
  {"get_vector", &Dtool_LinearForce_get_vector_77, METH_O, (const char *)Dtool_LinearForce_get_vector_77_comment},
  {"getVector", &Dtool_LinearForce_get_vector_77, METH_O, (const char *)Dtool_LinearForce_get_vector_77_comment},
  {"make_copy", &Dtool_LinearForce_make_copy_78, METH_NOARGS, (const char *)Dtool_LinearForce_make_copy_78_comment},
  {"makeCopy", &Dtool_LinearForce_make_copy_78, METH_NOARGS, (const char *)Dtool_LinearForce_make_copy_78_comment},
  {"get_class_type", &Dtool_LinearForce_get_class_type_79, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearForce_get_class_type_79_comment},
  {"getClassType", &Dtool_LinearForce_get_class_type_79, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearForce_get_class_type_79_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LinearForce = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearForce = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LinearForce = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LinearForce = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LinearForce = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LinearForce = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.LinearForce",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearForce,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LinearForce,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LinearForce,
    &Dtool_SequenceMethods_LinearForce,
    &Dtool_MappingMethods_LinearForce,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LinearForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A force that acts on a PhysicsObject by way of an Integrator.  This is a\n"
    " * pure virtual base class.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LinearForce,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LinearForce,
    PyType_GenericAlloc,
    Dtool_new_LinearForce,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearForce,
  Dtool_UpcastInterface_LinearForce,
  Dtool_DowncastInterface_LinearForce,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LinearForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseForce(nullptr);
    Dtool_LinearForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseForce);
    Dtool_LinearForce._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LinearForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearForce);
  }
}

/**
 * Python method tables for AngularForce (AngularForce)
 */
static PyMethodDef Dtool_Methods_AngularForce[] = {
  {"make_copy", &Dtool_AngularForce_make_copy_81, METH_NOARGS, (const char *)Dtool_AngularForce_make_copy_81_comment},
  {"makeCopy", &Dtool_AngularForce_make_copy_81, METH_NOARGS, (const char *)Dtool_AngularForce_make_copy_81_comment},
  {"get_quat", &Dtool_AngularForce_get_quat_82, METH_O, (const char *)Dtool_AngularForce_get_quat_82_comment},
  {"getQuat", &Dtool_AngularForce_get_quat_82, METH_O, (const char *)Dtool_AngularForce_get_quat_82_comment},
  {"get_class_type", &Dtool_AngularForce_get_class_type_83, METH_NOARGS | METH_STATIC, (const char *)Dtool_AngularForce_get_class_type_83_comment},
  {"getClassType", &Dtool_AngularForce_get_class_type_83, METH_NOARGS | METH_STATIC, (const char *)Dtool_AngularForce_get_class_type_83_comment},
  {"__copy__", &copy_from_make_copy, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AngularForce = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AngularForce = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AngularForce = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AngularForce = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AngularForce = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AngularForce = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.AngularForce",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AngularForce,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AngularForce,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AngularForce,
    &Dtool_SequenceMethods_AngularForce,
    &Dtool_MappingMethods_AngularForce,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AngularForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * pure virtual parent of all quat-based forces.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AngularForce,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AngularForce,
    PyType_GenericAlloc,
    Dtool_new_AngularForce,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AngularForce,
  Dtool_UpcastInterface_AngularForce,
  Dtool_DowncastInterface_AngularForce,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AngularForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseForce(nullptr);
    Dtool_AngularForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseForce);
    Dtool_AngularForce._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AngularForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AngularForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AngularForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AngularForce);
  }
}

/**
 * Python method tables for Physical (Physical)
 */
static PyMethodDef Dtool_Methods_Physical[] = {
  {"get_physics_manager", &Dtool_Physical_get_physics_manager_86, METH_NOARGS, (const char *)Dtool_Physical_get_physics_manager_86_comment},
  {"getPhysicsManager", &Dtool_Physical_get_physics_manager_86, METH_NOARGS, (const char *)Dtool_Physical_get_physics_manager_86_comment},
  {"get_physical_node", &Dtool_Physical_get_physical_node_87, METH_NOARGS, (const char *)Dtool_Physical_get_physical_node_87_comment},
  {"getPhysicalNode", &Dtool_Physical_get_physical_node_87, METH_NOARGS, (const char *)Dtool_Physical_get_physical_node_87_comment},
  {"get_physical_node_path", &Dtool_Physical_get_physical_node_path_88, METH_NOARGS, (const char *)Dtool_Physical_get_physical_node_path_88_comment},
  {"getPhysicalNodePath", &Dtool_Physical_get_physical_node_path_88, METH_NOARGS, (const char *)Dtool_Physical_get_physical_node_path_88_comment},
  {"get_phys_body", &Dtool_Physical_get_phys_body_89, METH_NOARGS, (const char *)Dtool_Physical_get_phys_body_89_comment},
  {"getPhysBody", &Dtool_Physical_get_phys_body_89, METH_NOARGS, (const char *)Dtool_Physical_get_phys_body_89_comment},
  {"clear_linear_forces", &Dtool_Physical_clear_linear_forces_90, METH_NOARGS, (const char *)Dtool_Physical_clear_linear_forces_90_comment},
  {"clearLinearForces", &Dtool_Physical_clear_linear_forces_90, METH_NOARGS, (const char *)Dtool_Physical_clear_linear_forces_90_comment},
  {"clear_angular_forces", &Dtool_Physical_clear_angular_forces_91, METH_NOARGS, (const char *)Dtool_Physical_clear_angular_forces_91_comment},
  {"clearAngularForces", &Dtool_Physical_clear_angular_forces_91, METH_NOARGS, (const char *)Dtool_Physical_clear_angular_forces_91_comment},
  {"clear_physics_objects", &Dtool_Physical_clear_physics_objects_92, METH_NOARGS, (const char *)Dtool_Physical_clear_physics_objects_92_comment},
  {"clearPhysicsObjects", &Dtool_Physical_clear_physics_objects_92, METH_NOARGS, (const char *)Dtool_Physical_clear_physics_objects_92_comment},
  {"add_linear_force", &Dtool_Physical_add_linear_force_93, METH_O, (const char *)Dtool_Physical_add_linear_force_93_comment},
  {"addLinearForce", &Dtool_Physical_add_linear_force_93, METH_O, (const char *)Dtool_Physical_add_linear_force_93_comment},
  {"add_angular_force", &Dtool_Physical_add_angular_force_94, METH_O, (const char *)Dtool_Physical_add_angular_force_94_comment},
  {"addAngularForce", &Dtool_Physical_add_angular_force_94, METH_O, (const char *)Dtool_Physical_add_angular_force_94_comment},
  {"add_physics_object", &Dtool_Physical_add_physics_object_95, METH_O, (const char *)Dtool_Physical_add_physics_object_95_comment},
  {"addPhysicsObject", &Dtool_Physical_add_physics_object_95, METH_O, (const char *)Dtool_Physical_add_physics_object_95_comment},
  {"remove_linear_force", &Dtool_Physical_remove_linear_force_96, METH_O, (const char *)Dtool_Physical_remove_linear_force_96_comment},
  {"removeLinearForce", &Dtool_Physical_remove_linear_force_96, METH_O, (const char *)Dtool_Physical_remove_linear_force_96_comment},
  {"remove_angular_force", &Dtool_Physical_remove_angular_force_97, METH_O, (const char *)Dtool_Physical_remove_angular_force_97_comment},
  {"removeAngularForce", &Dtool_Physical_remove_angular_force_97, METH_O, (const char *)Dtool_Physical_remove_angular_force_97_comment},
  {"get_num_linear_forces", &Dtool_Physical_get_num_linear_forces_98, METH_NOARGS, (const char *)Dtool_Physical_get_num_linear_forces_98_comment},
  {"getNumLinearForces", &Dtool_Physical_get_num_linear_forces_98, METH_NOARGS, (const char *)Dtool_Physical_get_num_linear_forces_98_comment},
  {"get_linear_force", &Dtool_Physical_get_linear_force_99, METH_O, (const char *)Dtool_Physical_get_linear_force_99_comment},
  {"getLinearForce", &Dtool_Physical_get_linear_force_99, METH_O, (const char *)Dtool_Physical_get_linear_force_99_comment},
  {"get_num_angular_forces", &Dtool_Physical_get_num_angular_forces_101, METH_NOARGS, (const char *)Dtool_Physical_get_num_angular_forces_101_comment},
  {"getNumAngularForces", &Dtool_Physical_get_num_angular_forces_101, METH_NOARGS, (const char *)Dtool_Physical_get_num_angular_forces_101_comment},
  {"get_angular_force", &Dtool_Physical_get_angular_force_102, METH_O, (const char *)Dtool_Physical_get_angular_force_102_comment},
  {"getAngularForce", &Dtool_Physical_get_angular_force_102, METH_O, (const char *)Dtool_Physical_get_angular_force_102_comment},
  {"set_viscosity", &Dtool_Physical_set_viscosity_104, METH_O, (const char *)Dtool_Physical_set_viscosity_104_comment},
  {"setViscosity", &Dtool_Physical_set_viscosity_104, METH_O, (const char *)Dtool_Physical_set_viscosity_104_comment},
  {"get_viscosity", &Dtool_Physical_get_viscosity_105, METH_NOARGS, (const char *)Dtool_Physical_get_viscosity_105_comment},
  {"getViscosity", &Dtool_Physical_get_viscosity_105, METH_NOARGS, (const char *)Dtool_Physical_get_viscosity_105_comment},
  {"get_objects", &Dtool_Physical_get_objects_106, METH_NOARGS, (const char *)Dtool_Physical_get_objects_106_comment},
  {"getObjects", &Dtool_Physical_get_objects_106, METH_NOARGS, (const char *)Dtool_Physical_get_objects_106_comment},
  {"output", (PyCFunction) &Dtool_Physical_output_107, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Physical_output_107_comment},
  {"write_physics_objects", (PyCFunction) &Dtool_Physical_write_physics_objects_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Physical_write_physics_objects_108_comment},
  {"writePhysicsObjects", (PyCFunction) &Dtool_Physical_write_physics_objects_108, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Physical_write_physics_objects_108_comment},
  {"write_linear_forces", (PyCFunction) &Dtool_Physical_write_linear_forces_109, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Physical_write_linear_forces_109_comment},
  {"writeLinearForces", (PyCFunction) &Dtool_Physical_write_linear_forces_109, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Physical_write_linear_forces_109_comment},
  {"write_angular_forces", (PyCFunction) &Dtool_Physical_write_angular_forces_110, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Physical_write_angular_forces_110_comment},
  {"writeAngularForces", (PyCFunction) &Dtool_Physical_write_angular_forces_110, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Physical_write_angular_forces_110_comment},
  {"write", (PyCFunction) &Dtool_Physical_write_111, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_Physical_write_111_comment},
  {"get_class_type", &Dtool_Physical_get_class_type_112, METH_NOARGS | METH_STATIC, (const char *)Dtool_Physical_get_class_type_112_comment},
  {"getClassType", &Dtool_Physical_get_class_type_112, METH_NOARGS | METH_STATIC, (const char *)Dtool_Physical_get_class_type_112_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {"get_linear_forces", (PyCFunction) &MakeSeq_Physical_get_linear_forces, METH_NOARGS, nullptr},
  { "getLinearForces", (PyCFunction) &MakeSeq_Physical_get_linear_forces, METH_NOARGS, nullptr},
  {"get_angular_forces", (PyCFunction) &MakeSeq_Physical_get_angular_forces, METH_NOARGS, nullptr},
  { "getAngularForces", (PyCFunction) &MakeSeq_Physical_get_angular_forces, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     Physical
//////////////////
static PyObject *Dtool_Repr_Physical(PyObject *self) {
  Physical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     Physical
//////////////////
static PyObject *Dtool_Str_Physical(PyObject *self) {
  Physical *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_Physical, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_Physical = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_Physical = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_Physical = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_Physical = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_Physical = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_Physical = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.Physical",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_Physical,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_Physical,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_Physical,
    &Dtool_NumberMethods_Physical,
    &Dtool_SequenceMethods_Physical,
    &Dtool_MappingMethods_Physical,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_Physical,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_Physical,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a set of physically modeled attributes.  If you want physics\n"
    " * applied to your class, derive it from this.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_Physical,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_Physical,
    PyType_GenericAlloc,
    Dtool_new_Physical,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_Physical,
  Dtool_UpcastInterface_Physical,
  Dtool_DowncastInterface_Physical,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_Physical(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_Physical._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount);
    Dtool_Physical._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_Physical._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_Physical) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(Physical)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_Physical);
  }
}

/**
 * Python method tables for PhysicalNode (PhysicalNode)
 */
static PyMethodDef Dtool_Methods_PhysicalNode[] = {
  {"clear", &Dtool_PhysicalNode_clear_116, METH_NOARGS, (const char *)Dtool_PhysicalNode_clear_116_comment},
  {"get_physical", &Dtool_PhysicalNode_get_physical_117, METH_O, (const char *)Dtool_PhysicalNode_get_physical_117_comment},
  {"getPhysical", &Dtool_PhysicalNode_get_physical_117, METH_O, (const char *)Dtool_PhysicalNode_get_physical_117_comment},
  {"get_num_physicals", &Dtool_PhysicalNode_get_num_physicals_118, METH_NOARGS, (const char *)Dtool_PhysicalNode_get_num_physicals_118_comment},
  {"getNumPhysicals", &Dtool_PhysicalNode_get_num_physicals_118, METH_NOARGS, (const char *)Dtool_PhysicalNode_get_num_physicals_118_comment},
  {"add_physical", &Dtool_PhysicalNode_add_physical_120, METH_O, (const char *)Dtool_PhysicalNode_add_physical_120_comment},
  {"addPhysical", &Dtool_PhysicalNode_add_physical_120, METH_O, (const char *)Dtool_PhysicalNode_add_physical_120_comment},
  {"add_physicals_from", &Dtool_PhysicalNode_add_physicals_from_121, METH_O, (const char *)Dtool_PhysicalNode_add_physicals_from_121_comment},
  {"addPhysicalsFrom", &Dtool_PhysicalNode_add_physicals_from_121, METH_O, (const char *)Dtool_PhysicalNode_add_physicals_from_121_comment},
  {"set_physical", (PyCFunction) &Dtool_PhysicalNode_set_physical_122, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicalNode_set_physical_122_comment},
  {"setPhysical", (PyCFunction) &Dtool_PhysicalNode_set_physical_122, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicalNode_set_physical_122_comment},
  {"insert_physical", (PyCFunction) &Dtool_PhysicalNode_insert_physical_123, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicalNode_insert_physical_123_comment},
  {"insertPhysical", (PyCFunction) &Dtool_PhysicalNode_insert_physical_123, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicalNode_insert_physical_123_comment},
  {"remove_physical", &Dtool_PhysicalNode_remove_physical_124, METH_O, (const char *)Dtool_PhysicalNode_remove_physical_124_comment},
  {"removePhysical", &Dtool_PhysicalNode_remove_physical_124, METH_O, (const char *)Dtool_PhysicalNode_remove_physical_124_comment},
  {"get_class_type", &Dtool_PhysicalNode_get_class_type_127, METH_NOARGS | METH_STATIC, (const char *)Dtool_PhysicalNode_get_class_type_127_comment},
  {"getClassType", &Dtool_PhysicalNode_get_class_type_127, METH_NOARGS | METH_STATIC, (const char *)Dtool_PhysicalNode_get_class_type_127_comment},
  {"get_physicals", (PyCFunction) &MakeSeq_PhysicalNode_get_physicals, METH_NOARGS, nullptr},
  { "getPhysicals", (PyCFunction) &MakeSeq_PhysicalNode_get_physicals, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_PhysicalNode[] = {
  {(char *)"physicals", &Dtool_PhysicalNode_physicals_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_PhysicalNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PhysicalNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PhysicalNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PhysicalNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PhysicalNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PhysicalNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.PhysicalNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PhysicalNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PhysicalNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PhysicalNode,
    &Dtool_SequenceMethods_PhysicalNode,
    &Dtool_MappingMethods_PhysicalNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PhysicalNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Graph node that encapsulated a series of physical objects\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PhysicalNode,
    nullptr, // tp_members
    Dtool_Properties_PhysicalNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PhysicalNode,
    PyType_GenericAlloc,
    Dtool_new_PhysicalNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PhysicalNode,
  Dtool_UpcastInterface_PhysicalNode,
  Dtool_DowncastInterface_PhysicalNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PhysicalNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_PhysicalNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    Dtool_PhysicalNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PhysicalNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PhysicalNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PhysicalNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PhysicalNode);
  }
}

/**
 * Python method tables for ActorNode (ActorNode)
 */
static PyMethodDef Dtool_Methods_ActorNode[] = {
  {"get_physics_object", &Dtool_ActorNode_get_physics_object_130, METH_NOARGS, (const char *)Dtool_ActorNode_get_physics_object_130_comment},
  {"getPhysicsObject", &Dtool_ActorNode_get_physics_object_130, METH_NOARGS, (const char *)Dtool_ActorNode_get_physics_object_130_comment},
  {"set_contact_vector", &Dtool_ActorNode_set_contact_vector_131, METH_O, (const char *)Dtool_ActorNode_set_contact_vector_131_comment},
  {"setContactVector", &Dtool_ActorNode_set_contact_vector_131, METH_O, (const char *)Dtool_ActorNode_set_contact_vector_131_comment},
  {"get_contact_vector", &Dtool_ActorNode_get_contact_vector_132, METH_NOARGS, (const char *)Dtool_ActorNode_get_contact_vector_132_comment},
  {"getContactVector", &Dtool_ActorNode_get_contact_vector_132, METH_NOARGS, (const char *)Dtool_ActorNode_get_contact_vector_132_comment},
  {"update_transform", &Dtool_ActorNode_update_transform_133, METH_NOARGS, (const char *)Dtool_ActorNode_update_transform_133_comment},
  {"updateTransform", &Dtool_ActorNode_update_transform_133, METH_NOARGS, (const char *)Dtool_ActorNode_update_transform_133_comment},
  {"set_transform_limit", &Dtool_ActorNode_set_transform_limit_134, METH_O, (const char *)Dtool_ActorNode_set_transform_limit_134_comment},
  {"setTransformLimit", &Dtool_ActorNode_set_transform_limit_134, METH_O, (const char *)Dtool_ActorNode_set_transform_limit_134_comment},
  {"get_class_type", &Dtool_ActorNode_get_class_type_135, METH_NOARGS | METH_STATIC, (const char *)Dtool_ActorNode_get_class_type_135_comment},
  {"getClassType", &Dtool_ActorNode_get_class_type_135, METH_NOARGS | METH_STATIC, (const char *)Dtool_ActorNode_get_class_type_135_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_ActorNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ActorNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ActorNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ActorNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ActorNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ActorNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.ActorNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ActorNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ActorNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ActorNode,
    &Dtool_SequenceMethods_ActorNode,
    &Dtool_MappingMethods_ActorNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ActorNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Like a physical node, but with a little more.  The actornode assumes\n"
    " * responsibility for its own transform, and changes in its own PhysicsObject\n"
    " * will be reflected as transforms.  This relation goes both ways; changes in\n"
    " * the transform will update the object's position (shoves).\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ActorNode,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ActorNode,
    PyType_GenericAlloc,
    Dtool_new_ActorNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ActorNode,
  Dtool_UpcastInterface_ActorNode,
  Dtool_DowncastInterface_ActorNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ActorNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_PhysicalNode(nullptr);
    Dtool_ActorNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_PhysicalNode);
    Dtool_ActorNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ActorNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ActorNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ActorNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ActorNode);
  }
}

/**
 * Python method tables for BaseIntegrator (BaseIntegrator)
 */
static PyMethodDef Dtool_Methods_BaseIntegrator[] = {
  {"output", &Dtool_BaseIntegrator_output_138, METH_O, (const char *)Dtool_BaseIntegrator_output_138_comment},
  {"write_precomputed_linear_matrices", (PyCFunction) &Dtool_BaseIntegrator_write_precomputed_linear_matrices_139, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseIntegrator_write_precomputed_linear_matrices_139_comment},
  {"writePrecomputedLinearMatrices", (PyCFunction) &Dtool_BaseIntegrator_write_precomputed_linear_matrices_139, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseIntegrator_write_precomputed_linear_matrices_139_comment},
  {"write_precomputed_angular_matrices", (PyCFunction) &Dtool_BaseIntegrator_write_precomputed_angular_matrices_140, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseIntegrator_write_precomputed_angular_matrices_140_comment},
  {"writePrecomputedAngularMatrices", (PyCFunction) &Dtool_BaseIntegrator_write_precomputed_angular_matrices_140, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseIntegrator_write_precomputed_angular_matrices_140_comment},
  {"write", (PyCFunction) &Dtool_BaseIntegrator_write_141, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_BaseIntegrator_write_141_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     BaseIntegrator
//////////////////
static PyObject *Dtool_Repr_BaseIntegrator(PyObject *self) {
  BaseIntegrator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseIntegrator, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     BaseIntegrator
//////////////////
static PyObject *Dtool_Str_BaseIntegrator(PyObject *self) {
  BaseIntegrator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_BaseIntegrator, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_BaseIntegrator = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_BaseIntegrator = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_BaseIntegrator = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_BaseIntegrator = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_BaseIntegrator = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_BaseIntegrator = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.BaseIntegrator",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_BaseIntegrator,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_BaseIntegrator,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_BaseIntegrator,
    &Dtool_NumberMethods_BaseIntegrator,
    &Dtool_SequenceMethods_BaseIntegrator,
    &Dtool_MappingMethods_BaseIntegrator,
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_BaseIntegrator,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_BaseIntegrator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * pure virtual integrator class that holds cached matrix information that\n"
    " * really should be common to any possible child implementation.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_BaseIntegrator,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_BaseIntegrator,
    PyType_GenericAlloc,
    Dtool_new_BaseIntegrator,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_BaseIntegrator,
  Dtool_UpcastInterface_BaseIntegrator,
  Dtool_DowncastInterface_BaseIntegrator,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_BaseIntegrator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_BaseIntegrator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    Dtool_BaseIntegrator._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_BaseIntegrator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_BaseIntegrator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(BaseIntegrator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_BaseIntegrator);
  }
}

/**
 * Python method tables for AngularIntegrator (AngularIntegrator)
 */
static PyMethodDef Dtool_Methods_AngularIntegrator[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AngularIntegrator = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AngularIntegrator = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AngularIntegrator = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AngularIntegrator = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AngularIntegrator = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AngularIntegrator = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.AngularIntegrator",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AngularIntegrator,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AngularIntegrator,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AngularIntegrator,
    &Dtool_SequenceMethods_AngularIntegrator,
    &Dtool_MappingMethods_AngularIntegrator,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AngularIntegrator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Pure virtual base class for physical modeling.  Takes physically modelable\n"
    " * objects and applies forces to them.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AngularIntegrator,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AngularIntegrator,
    PyType_GenericAlloc,
    Dtool_new_AngularIntegrator,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AngularIntegrator,
  Dtool_UpcastInterface_AngularIntegrator,
  Dtool_DowncastInterface_AngularIntegrator,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AngularIntegrator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseIntegrator(nullptr);
    Dtool_AngularIntegrator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseIntegrator);
    Dtool_AngularIntegrator._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AngularIntegrator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AngularIntegrator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AngularIntegrator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AngularIntegrator);
  }
}

/**
 * Python method tables for AngularEulerIntegrator (AngularEulerIntegrator)
 */
static PyMethodDef Dtool_Methods_AngularEulerIntegrator[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AngularEulerIntegrator = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AngularEulerIntegrator = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AngularEulerIntegrator = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AngularEulerIntegrator = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AngularEulerIntegrator = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AngularEulerIntegrator = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.AngularEulerIntegrator",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AngularEulerIntegrator,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AngularEulerIntegrator,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AngularEulerIntegrator,
    &Dtool_SequenceMethods_AngularEulerIntegrator,
    &Dtool_MappingMethods_AngularEulerIntegrator,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AngularEulerIntegrator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Performs Euler integration on a vector of physically modelable objects\n"
    " * given a quantum dt.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AngularEulerIntegrator,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AngularEulerIntegrator,
    PyType_GenericAlloc,
    Dtool_new_AngularEulerIntegrator,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AngularEulerIntegrator,
  Dtool_UpcastInterface_AngularEulerIntegrator,
  Dtool_DowncastInterface_AngularEulerIntegrator,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AngularEulerIntegrator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AngularIntegrator(nullptr);
    Dtool_AngularEulerIntegrator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AngularIntegrator);
    Dtool_AngularEulerIntegrator._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AngularEulerIntegrator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AngularEulerIntegrator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AngularEulerIntegrator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AngularEulerIntegrator);
  }
}

/**
 * Python method tables for AngularVectorForce (AngularVectorForce)
 */
static PyMethodDef Dtool_Methods_AngularVectorForce[] = {
  {"set_quat", &Dtool_AngularVectorForce_set_quat_148, METH_O, (const char *)Dtool_AngularVectorForce_set_quat_148_comment},
  {"setQuat", &Dtool_AngularVectorForce_set_quat_148, METH_O, (const char *)Dtool_AngularVectorForce_set_quat_148_comment},
  {"set_hpr", (PyCFunction) &Dtool_AngularVectorForce_set_hpr_149, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AngularVectorForce_set_hpr_149_comment},
  {"setHpr", (PyCFunction) &Dtool_AngularVectorForce_set_hpr_149, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_AngularVectorForce_set_hpr_149_comment},
  {"get_local_quat", &Dtool_AngularVectorForce_get_local_quat_150, METH_NOARGS, (const char *)Dtool_AngularVectorForce_get_local_quat_150_comment},
  {"getLocalQuat", &Dtool_AngularVectorForce_get_local_quat_150, METH_NOARGS, (const char *)Dtool_AngularVectorForce_get_local_quat_150_comment},
  {"get_class_type", &Dtool_AngularVectorForce_get_class_type_151, METH_NOARGS | METH_STATIC, (const char *)Dtool_AngularVectorForce_get_class_type_151_comment},
  {"getClassType", &Dtool_AngularVectorForce_get_class_type_151, METH_NOARGS | METH_STATIC, (const char *)Dtool_AngularVectorForce_get_class_type_151_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_AngularVectorForce = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_AngularVectorForce = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_AngularVectorForce = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_AngularVectorForce = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_AngularVectorForce = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_AngularVectorForce = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.AngularVectorForce",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_AngularVectorForce,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_AngularVectorForce,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_AngularVectorForce,
    &Dtool_SequenceMethods_AngularVectorForce,
    &Dtool_MappingMethods_AngularVectorForce,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_AngularVectorForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * a simple directed torque force, the angular equivalent of simple vector\n"
    " * force.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_AngularVectorForce,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_AngularVectorForce,
    PyType_GenericAlloc,
    Dtool_new_AngularVectorForce,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_AngularVectorForce,
  Dtool_UpcastInterface_AngularVectorForce,
  Dtool_DowncastInterface_AngularVectorForce,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_AngularVectorForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_AngularForce(nullptr);
    Dtool_AngularVectorForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_AngularForce);
    Dtool_AngularVectorForce._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_AngularVectorForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_AngularVectorForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(AngularVectorForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_AngularVectorForce);
  }
}

/**
 * Python method tables for ForceNode (ForceNode)
 */
static PyMethodDef Dtool_Methods_ForceNode[] = {
  {"clear", &Dtool_ForceNode_clear_154, METH_NOARGS, (const char *)Dtool_ForceNode_clear_154_comment},
  {"get_force", &Dtool_ForceNode_get_force_155, METH_O, (const char *)Dtool_ForceNode_get_force_155_comment},
  {"getForce", &Dtool_ForceNode_get_force_155, METH_O, (const char *)Dtool_ForceNode_get_force_155_comment},
  {"get_num_forces", &Dtool_ForceNode_get_num_forces_156, METH_NOARGS, (const char *)Dtool_ForceNode_get_num_forces_156_comment},
  {"getNumForces", &Dtool_ForceNode_get_num_forces_156, METH_NOARGS, (const char *)Dtool_ForceNode_get_num_forces_156_comment},
  {"add_force", &Dtool_ForceNode_add_force_158, METH_O, (const char *)Dtool_ForceNode_add_force_158_comment},
  {"addForce", &Dtool_ForceNode_add_force_158, METH_O, (const char *)Dtool_ForceNode_add_force_158_comment},
  {"add_forces_from", &Dtool_ForceNode_add_forces_from_159, METH_O, (const char *)Dtool_ForceNode_add_forces_from_159_comment},
  {"addForcesFrom", &Dtool_ForceNode_add_forces_from_159, METH_O, (const char *)Dtool_ForceNode_add_forces_from_159_comment},
  {"set_force", (PyCFunction) &Dtool_ForceNode_set_force_160, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ForceNode_set_force_160_comment},
  {"setForce", (PyCFunction) &Dtool_ForceNode_set_force_160, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ForceNode_set_force_160_comment},
  {"insert_force", (PyCFunction) &Dtool_ForceNode_insert_force_161, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ForceNode_insert_force_161_comment},
  {"insertForce", (PyCFunction) &Dtool_ForceNode_insert_force_161, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ForceNode_insert_force_161_comment},
  {"remove_force", &Dtool_ForceNode_remove_force_162, METH_O, (const char *)Dtool_ForceNode_remove_force_162_comment},
  {"removeForce", &Dtool_ForceNode_remove_force_162, METH_O, (const char *)Dtool_ForceNode_remove_force_162_comment},
  {"write_forces", (PyCFunction) &Dtool_ForceNode_write_forces_165, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ForceNode_write_forces_165_comment},
  {"writeForces", (PyCFunction) &Dtool_ForceNode_write_forces_165, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_ForceNode_write_forces_165_comment},
  {"get_class_type", &Dtool_ForceNode_get_class_type_166, METH_NOARGS | METH_STATIC, (const char *)Dtool_ForceNode_get_class_type_166_comment},
  {"getClassType", &Dtool_ForceNode_get_class_type_166, METH_NOARGS | METH_STATIC, (const char *)Dtool_ForceNode_get_class_type_166_comment},
  {"get_forces", (PyCFunction) &MakeSeq_ForceNode_get_forces, METH_NOARGS, nullptr},
  { "getForces", (PyCFunction) &MakeSeq_ForceNode_get_forces, METH_NOARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_ForceNode[] = {
  {(char *)"forces", &Dtool_ForceNode_forces_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_ForceNode = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_ForceNode = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_ForceNode = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_ForceNode = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_ForceNode = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_ForceNode = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.ForceNode",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_ForceNode,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_ForceNode,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_ForceNode,
    &Dtool_SequenceMethods_ForceNode,
    &Dtool_MappingMethods_ForceNode,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_ForceNode,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A force that lives in the scene graph and is therefore subject to local\n"
    " * coordinate systems.  An example of this would be simulating gravity in a\n"
    " * rotating space station.  or something.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_ForceNode,
    nullptr, // tp_members
    Dtool_Properties_ForceNode,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_ForceNode,
    PyType_GenericAlloc,
    Dtool_new_ForceNode,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_ForceNode,
  Dtool_UpcastInterface_ForceNode,
  Dtool_DowncastInterface_ForceNode,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_ForceNode(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_PandaNode != nullptr);
    assert(Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_PandaNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_ForceNode._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_PandaNode);
    Dtool_ForceNode._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_ForceNode._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_ForceNode) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(ForceNode)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_ForceNode);
  }
}

/**
 * Python method tables for LinearControlForce (LinearControlForce)
 */
static PyMethodDef Dtool_Methods_LinearControlForce[] = {
  {"clear_physics_object", &Dtool_LinearControlForce_clear_physics_object_169, METH_NOARGS, (const char *)Dtool_LinearControlForce_clear_physics_object_169_comment},
  {"clearPhysicsObject", &Dtool_LinearControlForce_clear_physics_object_169, METH_NOARGS, (const char *)Dtool_LinearControlForce_clear_physics_object_169_comment},
  {"set_physics_object", &Dtool_LinearControlForce_set_physics_object_170, METH_O, (const char *)Dtool_LinearControlForce_set_physics_object_170_comment},
  {"setPhysicsObject", &Dtool_LinearControlForce_set_physics_object_170, METH_O, (const char *)Dtool_LinearControlForce_set_physics_object_170_comment},
  {"get_physics_object", &Dtool_LinearControlForce_get_physics_object_171, METH_NOARGS, (const char *)Dtool_LinearControlForce_get_physics_object_171_comment},
  {"getPhysicsObject", &Dtool_LinearControlForce_get_physics_object_171, METH_NOARGS, (const char *)Dtool_LinearControlForce_get_physics_object_171_comment},
  {"set_vector", (PyCFunction) &Dtool_LinearControlForce_set_vector_172, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LinearControlForce_set_vector_172_comment},
  {"setVector", (PyCFunction) &Dtool_LinearControlForce_set_vector_172, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LinearControlForce_set_vector_172_comment},
  {"get_local_vector", &Dtool_LinearControlForce_get_local_vector_173, METH_NOARGS, (const char *)Dtool_LinearControlForce_get_local_vector_173_comment},
  {"getLocalVector", &Dtool_LinearControlForce_get_local_vector_173, METH_NOARGS, (const char *)Dtool_LinearControlForce_get_local_vector_173_comment},
  {"get_class_type", &Dtool_LinearControlForce_get_class_type_174, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearControlForce_get_class_type_174_comment},
  {"getClassType", &Dtool_LinearControlForce_get_class_type_174, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearControlForce_get_class_type_174_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LinearControlForce = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearControlForce = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LinearControlForce = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LinearControlForce = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LinearControlForce = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LinearControlForce = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.LinearControlForce",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearControlForce,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LinearControlForce,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LinearControlForce,
    &Dtool_SequenceMethods_LinearControlForce,
    &Dtool_MappingMethods_LinearControlForce,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LinearControlForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Simple directed vector force.  This force is different from the others in\n"
    " * that it can be global and still only affect a single object.  That might\n"
    " * not make sense for a physics simulation, but it's very handy for a game.\n"
    " * I.e.  this is the force applied by user on the selected object.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LinearControlForce,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LinearControlForce,
    PyType_GenericAlloc,
    Dtool_new_LinearControlForce,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearControlForce,
  Dtool_UpcastInterface_LinearControlForce,
  Dtool_DowncastInterface_LinearControlForce,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LinearControlForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearForce(nullptr);
    Dtool_LinearControlForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearForce);
    Dtool_LinearControlForce._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LinearControlForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearControlForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearControlForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearControlForce);
  }
}

/**
 * Python method tables for LinearCylinderVortexForce (LinearCylinderVortexForce)
 */
static PyMethodDef Dtool_Methods_LinearCylinderVortexForce[] = {
  {"set_coef", &Dtool_LinearCylinderVortexForce_set_coef_177, METH_O, (const char *)Dtool_LinearCylinderVortexForce_set_coef_177_comment},
  {"setCoef", &Dtool_LinearCylinderVortexForce_set_coef_177, METH_O, (const char *)Dtool_LinearCylinderVortexForce_set_coef_177_comment},
  {"get_coef", &Dtool_LinearCylinderVortexForce_get_coef_178, METH_NOARGS, (const char *)Dtool_LinearCylinderVortexForce_get_coef_178_comment},
  {"getCoef", &Dtool_LinearCylinderVortexForce_get_coef_178, METH_NOARGS, (const char *)Dtool_LinearCylinderVortexForce_get_coef_178_comment},
  {"set_radius", &Dtool_LinearCylinderVortexForce_set_radius_179, METH_O, (const char *)Dtool_LinearCylinderVortexForce_set_radius_179_comment},
  {"setRadius", &Dtool_LinearCylinderVortexForce_set_radius_179, METH_O, (const char *)Dtool_LinearCylinderVortexForce_set_radius_179_comment},
  {"get_radius", &Dtool_LinearCylinderVortexForce_get_radius_180, METH_NOARGS, (const char *)Dtool_LinearCylinderVortexForce_get_radius_180_comment},
  {"getRadius", &Dtool_LinearCylinderVortexForce_get_radius_180, METH_NOARGS, (const char *)Dtool_LinearCylinderVortexForce_get_radius_180_comment},
  {"set_length", &Dtool_LinearCylinderVortexForce_set_length_181, METH_O, (const char *)Dtool_LinearCylinderVortexForce_set_length_181_comment},
  {"setLength", &Dtool_LinearCylinderVortexForce_set_length_181, METH_O, (const char *)Dtool_LinearCylinderVortexForce_set_length_181_comment},
  {"get_length", &Dtool_LinearCylinderVortexForce_get_length_182, METH_NOARGS, (const char *)Dtool_LinearCylinderVortexForce_get_length_182_comment},
  {"getLength", &Dtool_LinearCylinderVortexForce_get_length_182, METH_NOARGS, (const char *)Dtool_LinearCylinderVortexForce_get_length_182_comment},
  {"get_class_type", &Dtool_LinearCylinderVortexForce_get_class_type_183, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearCylinderVortexForce_get_class_type_183_comment},
  {"getClassType", &Dtool_LinearCylinderVortexForce_get_class_type_183, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearCylinderVortexForce_get_class_type_183_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LinearCylinderVortexForce = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearCylinderVortexForce = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LinearCylinderVortexForce = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LinearCylinderVortexForce = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LinearCylinderVortexForce = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LinearCylinderVortexForce = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.LinearCylinderVortexForce",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearCylinderVortexForce,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LinearCylinderVortexForce,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LinearCylinderVortexForce,
    &Dtool_SequenceMethods_LinearCylinderVortexForce,
    &Dtool_MappingMethods_LinearCylinderVortexForce,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LinearCylinderVortexForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Defines a cylinder inside of which all forces are tangential to the theta\n"
    " * of the particle wrt the z-axis in local coord.  space.  This happens by\n"
    " * assigning the force a node by which the cylinder is transformed.  Be\n"
    " * warned- this will suck anything that it can reach directly into orbit and\n"
    " * will NOT let go.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LinearCylinderVortexForce,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LinearCylinderVortexForce,
    PyType_GenericAlloc,
    Dtool_new_LinearCylinderVortexForce,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearCylinderVortexForce,
  Dtool_UpcastInterface_LinearCylinderVortexForce,
  Dtool_DowncastInterface_LinearCylinderVortexForce,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LinearCylinderVortexForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearForce(nullptr);
    Dtool_LinearCylinderVortexForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearForce);
    Dtool_LinearCylinderVortexForce._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LinearCylinderVortexForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearCylinderVortexForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearCylinderVortexForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearCylinderVortexForce);
  }
}

/**
 * Python method tables for LinearDistanceForce (LinearDistanceForce)
 */
static PyMethodDef Dtool_Methods_LinearDistanceForce[] = {
  {"set_radius", &Dtool_LinearDistanceForce_set_radius_186, METH_O, (const char *)Dtool_LinearDistanceForce_set_radius_186_comment},
  {"setRadius", &Dtool_LinearDistanceForce_set_radius_186, METH_O, (const char *)Dtool_LinearDistanceForce_set_radius_186_comment},
  {"set_falloff_type", &Dtool_LinearDistanceForce_set_falloff_type_187, METH_O, (const char *)Dtool_LinearDistanceForce_set_falloff_type_187_comment},
  {"setFalloffType", &Dtool_LinearDistanceForce_set_falloff_type_187, METH_O, (const char *)Dtool_LinearDistanceForce_set_falloff_type_187_comment},
  {"set_force_center", &Dtool_LinearDistanceForce_set_force_center_188, METH_O, (const char *)Dtool_LinearDistanceForce_set_force_center_188_comment},
  {"setForceCenter", &Dtool_LinearDistanceForce_set_force_center_188, METH_O, (const char *)Dtool_LinearDistanceForce_set_force_center_188_comment},
  {"get_radius", &Dtool_LinearDistanceForce_get_radius_189, METH_NOARGS, (const char *)Dtool_LinearDistanceForce_get_radius_189_comment},
  {"getRadius", &Dtool_LinearDistanceForce_get_radius_189, METH_NOARGS, (const char *)Dtool_LinearDistanceForce_get_radius_189_comment},
  {"get_falloff_type", &Dtool_LinearDistanceForce_get_falloff_type_190, METH_NOARGS, (const char *)Dtool_LinearDistanceForce_get_falloff_type_190_comment},
  {"getFalloffType", &Dtool_LinearDistanceForce_get_falloff_type_190, METH_NOARGS, (const char *)Dtool_LinearDistanceForce_get_falloff_type_190_comment},
  {"get_force_center", &Dtool_LinearDistanceForce_get_force_center_191, METH_NOARGS, (const char *)Dtool_LinearDistanceForce_get_force_center_191_comment},
  {"getForceCenter", &Dtool_LinearDistanceForce_get_force_center_191, METH_NOARGS, (const char *)Dtool_LinearDistanceForce_get_force_center_191_comment},
  {"get_scalar_term", &Dtool_LinearDistanceForce_get_scalar_term_192, METH_NOARGS, (const char *)Dtool_LinearDistanceForce_get_scalar_term_192_comment},
  {"getScalarTerm", &Dtool_LinearDistanceForce_get_scalar_term_192, METH_NOARGS, (const char *)Dtool_LinearDistanceForce_get_scalar_term_192_comment},
  {"get_class_type", &Dtool_LinearDistanceForce_get_class_type_193, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearDistanceForce_get_class_type_193_comment},
  {"getClassType", &Dtool_LinearDistanceForce_get_class_type_193, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearDistanceForce_get_class_type_193_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LinearDistanceForce = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearDistanceForce = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LinearDistanceForce = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LinearDistanceForce = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LinearDistanceForce = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LinearDistanceForce = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.LinearDistanceForce",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearDistanceForce,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LinearDistanceForce,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LinearDistanceForce,
    &Dtool_SequenceMethods_LinearDistanceForce,
    &Dtool_MappingMethods_LinearDistanceForce,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LinearDistanceForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Pure virtual class for sinks and sources\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LinearDistanceForce,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LinearDistanceForce,
    PyType_GenericAlloc,
    Dtool_new_LinearDistanceForce,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearDistanceForce,
  Dtool_UpcastInterface_LinearDistanceForce,
  Dtool_DowncastInterface_LinearDistanceForce,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LinearDistanceForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearForce(nullptr);
    Dtool_LinearDistanceForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearForce);
    Dtool_LinearDistanceForce._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_LinearDistanceForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LinearDistanceForce::FalloffType;
    PyDict_SetItemString(dict, "FT_ONE_OVER_R", Dtool_WrapValue(LinearDistanceForce::FT_ONE_OVER_R));
    PyDict_SetItemString(dict, "FTONEOVERR", Dtool_WrapValue(LinearDistanceForce::FT_ONE_OVER_R));
    PyDict_SetItemString(dict, "FT_ONE_OVER_R_SQUARED", Dtool_WrapValue(LinearDistanceForce::FT_ONE_OVER_R_SQUARED));
    PyDict_SetItemString(dict, "FTONEOVERRSQUARED", Dtool_WrapValue(LinearDistanceForce::FT_ONE_OVER_R_SQUARED));
    PyDict_SetItemString(dict, "FT_ONE_OVER_R_CUBED", Dtool_WrapValue(LinearDistanceForce::FT_ONE_OVER_R_CUBED));
    PyDict_SetItemString(dict, "FTONEOVERRCUBED", Dtool_WrapValue(LinearDistanceForce::FT_ONE_OVER_R_CUBED));
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearDistanceForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearDistanceForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearDistanceForce);
  }
}

/**
 * Python method tables for LinearIntegrator (LinearIntegrator)
 */
static PyMethodDef Dtool_Methods_LinearIntegrator[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LinearIntegrator = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearIntegrator = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LinearIntegrator = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LinearIntegrator = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LinearIntegrator = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LinearIntegrator = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.LinearIntegrator",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearIntegrator,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LinearIntegrator,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LinearIntegrator,
    &Dtool_SequenceMethods_LinearIntegrator,
    &Dtool_MappingMethods_LinearIntegrator,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LinearIntegrator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Pure virtual base class for physical modeling.  Takes physically modelable\n"
    " * objects and applies forces to them.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LinearIntegrator,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LinearIntegrator,
    PyType_GenericAlloc,
    Dtool_new_LinearIntegrator,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearIntegrator,
  Dtool_UpcastInterface_LinearIntegrator,
  Dtool_DowncastInterface_LinearIntegrator,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LinearIntegrator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_BaseIntegrator(nullptr);
    Dtool_LinearIntegrator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_BaseIntegrator);
    Dtool_LinearIntegrator._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LinearIntegrator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearIntegrator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearIntegrator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearIntegrator);
  }
}

/**
 * Python method tables for LinearEulerIntegrator (LinearEulerIntegrator)
 */
static PyMethodDef Dtool_Methods_LinearEulerIntegrator[] = {
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LinearEulerIntegrator = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearEulerIntegrator = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LinearEulerIntegrator = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LinearEulerIntegrator = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LinearEulerIntegrator = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LinearEulerIntegrator = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.LinearEulerIntegrator",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearEulerIntegrator,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LinearEulerIntegrator,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LinearEulerIntegrator,
    &Dtool_SequenceMethods_LinearEulerIntegrator,
    &Dtool_MappingMethods_LinearEulerIntegrator,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LinearEulerIntegrator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Performs Euler integration on a vector of physically modelable objects\n"
    " * given a quantum dt.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LinearEulerIntegrator,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LinearEulerIntegrator,
    PyType_GenericAlloc,
    Dtool_new_LinearEulerIntegrator,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearEulerIntegrator,
  Dtool_UpcastInterface_LinearEulerIntegrator,
  Dtool_DowncastInterface_LinearEulerIntegrator,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LinearEulerIntegrator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearIntegrator(nullptr);
    Dtool_LinearEulerIntegrator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearIntegrator);
    Dtool_LinearEulerIntegrator._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LinearEulerIntegrator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearEulerIntegrator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearEulerIntegrator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearEulerIntegrator);
  }
}

/**
 * Python method tables for LinearFrictionForce (LinearFrictionForce)
 */
static PyMethodDef Dtool_Methods_LinearFrictionForce[] = {
  {"set_coef", &Dtool_LinearFrictionForce_set_coef_199, METH_O, (const char *)Dtool_LinearFrictionForce_set_coef_199_comment},
  {"setCoef", &Dtool_LinearFrictionForce_set_coef_199, METH_O, (const char *)Dtool_LinearFrictionForce_set_coef_199_comment},
  {"get_coef", &Dtool_LinearFrictionForce_get_coef_200, METH_NOARGS, (const char *)Dtool_LinearFrictionForce_get_coef_200_comment},
  {"getCoef", &Dtool_LinearFrictionForce_get_coef_200, METH_NOARGS, (const char *)Dtool_LinearFrictionForce_get_coef_200_comment},
  {"get_class_type", &Dtool_LinearFrictionForce_get_class_type_201, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearFrictionForce_get_class_type_201_comment},
  {"getClassType", &Dtool_LinearFrictionForce_get_class_type_201, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearFrictionForce_get_class_type_201_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LinearFrictionForce = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearFrictionForce = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LinearFrictionForce = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LinearFrictionForce = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LinearFrictionForce = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LinearFrictionForce = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.LinearFrictionForce",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearFrictionForce,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LinearFrictionForce,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LinearFrictionForce,
    &Dtool_SequenceMethods_LinearFrictionForce,
    &Dtool_MappingMethods_LinearFrictionForce,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LinearFrictionForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Friction-based drag force\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LinearFrictionForce,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LinearFrictionForce,
    PyType_GenericAlloc,
    Dtool_new_LinearFrictionForce,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearFrictionForce,
  Dtool_UpcastInterface_LinearFrictionForce,
  Dtool_DowncastInterface_LinearFrictionForce,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LinearFrictionForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearForce(nullptr);
    Dtool_LinearFrictionForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearForce);
    Dtool_LinearFrictionForce._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LinearFrictionForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearFrictionForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearFrictionForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearFrictionForce);
  }
}

/**
 * Python method tables for LinearRandomForce (LinearRandomForce)
 */
static PyMethodDef Dtool_Methods_LinearRandomForce[] = {
  {"get_class_type", &Dtool_LinearRandomForce_get_class_type_203, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearRandomForce_get_class_type_203_comment},
  {"getClassType", &Dtool_LinearRandomForce_get_class_type_203, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearRandomForce_get_class_type_203_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LinearRandomForce = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearRandomForce = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LinearRandomForce = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LinearRandomForce = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LinearRandomForce = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LinearRandomForce = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.LinearRandomForce",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearRandomForce,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LinearRandomForce,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LinearRandomForce,
    &Dtool_SequenceMethods_LinearRandomForce,
    &Dtool_MappingMethods_LinearRandomForce,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LinearRandomForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Pure virtual, parent to noiseForce and jitterForce\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LinearRandomForce,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LinearRandomForce,
    PyType_GenericAlloc,
    Dtool_new_LinearRandomForce,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearRandomForce,
  Dtool_UpcastInterface_LinearRandomForce,
  Dtool_DowncastInterface_LinearRandomForce,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LinearRandomForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearForce(nullptr);
    Dtool_LinearRandomForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearForce);
    Dtool_LinearRandomForce._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LinearRandomForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearRandomForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearRandomForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearRandomForce);
  }
}

/**
 * Python method tables for LinearJitterForce (LinearJitterForce)
 */
static PyMethodDef Dtool_Methods_LinearJitterForce[] = {
  {"get_class_type", &Dtool_LinearJitterForce_get_class_type_206, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearJitterForce_get_class_type_206_comment},
  {"getClassType", &Dtool_LinearJitterForce_get_class_type_206, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearJitterForce_get_class_type_206_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LinearJitterForce = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearJitterForce = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LinearJitterForce = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LinearJitterForce = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LinearJitterForce = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LinearJitterForce = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.LinearJitterForce",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearJitterForce,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LinearJitterForce,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LinearJitterForce,
    &Dtool_SequenceMethods_LinearJitterForce,
    &Dtool_MappingMethods_LinearJitterForce,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LinearJitterForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Completely random noise force vector.  Not repeatable, reliable, or\n"
    " * predictable.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LinearJitterForce,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LinearJitterForce,
    PyType_GenericAlloc,
    Dtool_new_LinearJitterForce,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearJitterForce,
  Dtool_UpcastInterface_LinearJitterForce,
  Dtool_DowncastInterface_LinearJitterForce,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LinearJitterForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearRandomForce(nullptr);
    Dtool_LinearJitterForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearRandomForce);
    Dtool_LinearJitterForce._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LinearJitterForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearJitterForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearJitterForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearJitterForce);
  }
}

/**
 * Python method tables for LinearNoiseForce (LinearNoiseForce)
 */
static PyMethodDef Dtool_Methods_LinearNoiseForce[] = {
  {"get_class_type", &Dtool_LinearNoiseForce_get_class_type_209, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearNoiseForce_get_class_type_209_comment},
  {"getClassType", &Dtool_LinearNoiseForce_get_class_type_209, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearNoiseForce_get_class_type_209_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LinearNoiseForce = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearNoiseForce = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LinearNoiseForce = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LinearNoiseForce = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LinearNoiseForce = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LinearNoiseForce = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.LinearNoiseForce",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearNoiseForce,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LinearNoiseForce,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LinearNoiseForce,
    &Dtool_SequenceMethods_LinearNoiseForce,
    &Dtool_MappingMethods_LinearNoiseForce,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LinearNoiseForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Repeating noise force vector.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LinearNoiseForce,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LinearNoiseForce,
    PyType_GenericAlloc,
    Dtool_new_LinearNoiseForce,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearNoiseForce,
  Dtool_UpcastInterface_LinearNoiseForce,
  Dtool_DowncastInterface_LinearNoiseForce,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LinearNoiseForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearRandomForce(nullptr);
    Dtool_LinearNoiseForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearRandomForce);
    Dtool_LinearNoiseForce._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LinearNoiseForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearNoiseForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearNoiseForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearNoiseForce);
  }
}

/**
 * Python method tables for LinearSinkForce (LinearSinkForce)
 */
static PyMethodDef Dtool_Methods_LinearSinkForce[] = {
  {"get_class_type", &Dtool_LinearSinkForce_get_class_type_212, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearSinkForce_get_class_type_212_comment},
  {"getClassType", &Dtool_LinearSinkForce_get_class_type_212, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearSinkForce_get_class_type_212_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LinearSinkForce = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearSinkForce = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LinearSinkForce = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LinearSinkForce = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LinearSinkForce = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LinearSinkForce = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.LinearSinkForce",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearSinkForce,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LinearSinkForce,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LinearSinkForce,
    &Dtool_SequenceMethods_LinearSinkForce,
    &Dtool_MappingMethods_LinearSinkForce,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LinearSinkForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Attractor force.  Think black hole.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LinearSinkForce,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LinearSinkForce,
    PyType_GenericAlloc,
    Dtool_new_LinearSinkForce,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearSinkForce,
  Dtool_UpcastInterface_LinearSinkForce,
  Dtool_DowncastInterface_LinearSinkForce,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LinearSinkForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearDistanceForce(nullptr);
    Dtool_LinearSinkForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearDistanceForce);
    Dtool_LinearSinkForce._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LinearSinkForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearSinkForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearSinkForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearSinkForce);
  }
}

/**
 * Python method tables for LinearSourceForce (LinearSourceForce)
 */
static PyMethodDef Dtool_Methods_LinearSourceForce[] = {
  {"get_class_type", &Dtool_LinearSourceForce_get_class_type_215, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearSourceForce_get_class_type_215_comment},
  {"getClassType", &Dtool_LinearSourceForce_get_class_type_215, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearSourceForce_get_class_type_215_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LinearSourceForce = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearSourceForce = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LinearSourceForce = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LinearSourceForce = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LinearSourceForce = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LinearSourceForce = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.LinearSourceForce",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearSourceForce,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LinearSourceForce,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LinearSourceForce,
    &Dtool_SequenceMethods_LinearSourceForce,
    &Dtool_MappingMethods_LinearSourceForce,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LinearSourceForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Repellant force.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LinearSourceForce,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LinearSourceForce,
    PyType_GenericAlloc,
    Dtool_new_LinearSourceForce,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearSourceForce,
  Dtool_UpcastInterface_LinearSourceForce,
  Dtool_DowncastInterface_LinearSourceForce,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LinearSourceForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearDistanceForce(nullptr);
    Dtool_LinearSourceForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearDistanceForce);
    Dtool_LinearSourceForce._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LinearSourceForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearSourceForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearSourceForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearSourceForce);
  }
}

/**
 * Python method tables for LinearUserDefinedForce (LinearUserDefinedForce)
 */
static PyMethodDef Dtool_Methods_LinearUserDefinedForce[] = {
  {"get_class_type", &Dtool_LinearUserDefinedForce_get_class_type_219, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearUserDefinedForce_get_class_type_219_comment},
  {"getClassType", &Dtool_LinearUserDefinedForce_get_class_type_219, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearUserDefinedForce_get_class_type_219_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LinearUserDefinedForce = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearUserDefinedForce = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LinearUserDefinedForce = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LinearUserDefinedForce = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LinearUserDefinedForce = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LinearUserDefinedForce = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.LinearUserDefinedForce",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearUserDefinedForce,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LinearUserDefinedForce,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LinearUserDefinedForce,
    &Dtool_SequenceMethods_LinearUserDefinedForce,
    &Dtool_MappingMethods_LinearUserDefinedForce,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LinearUserDefinedForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A programmable force that takes an evaluator function.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LinearUserDefinedForce,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LinearUserDefinedForce,
    PyType_GenericAlloc,
    Dtool_new_LinearUserDefinedForce,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearUserDefinedForce,
  Dtool_UpcastInterface_LinearUserDefinedForce,
  Dtool_DowncastInterface_LinearUserDefinedForce,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LinearUserDefinedForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearForce(nullptr);
    Dtool_LinearUserDefinedForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearForce);
    Dtool_LinearUserDefinedForce._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LinearUserDefinedForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearUserDefinedForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearUserDefinedForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearUserDefinedForce);
  }
}

/**
 * Python method tables for LinearVectorForce (LinearVectorForce)
 */
static PyMethodDef Dtool_Methods_LinearVectorForce[] = {
  {"set_vector", (PyCFunction) &Dtool_LinearVectorForce_set_vector_222, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LinearVectorForce_set_vector_222_comment},
  {"setVector", (PyCFunction) &Dtool_LinearVectorForce_set_vector_222, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LinearVectorForce_set_vector_222_comment},
  {"get_local_vector", &Dtool_LinearVectorForce_get_local_vector_223, METH_NOARGS, (const char *)Dtool_LinearVectorForce_get_local_vector_223_comment},
  {"getLocalVector", &Dtool_LinearVectorForce_get_local_vector_223, METH_NOARGS, (const char *)Dtool_LinearVectorForce_get_local_vector_223_comment},
  {"get_class_type", &Dtool_LinearVectorForce_get_class_type_224, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearVectorForce_get_class_type_224_comment},
  {"getClassType", &Dtool_LinearVectorForce_get_class_type_224, METH_NOARGS | METH_STATIC, (const char *)Dtool_LinearVectorForce_get_class_type_224_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LinearVectorForce = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LinearVectorForce = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LinearVectorForce = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LinearVectorForce = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LinearVectorForce = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LinearVectorForce = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.LinearVectorForce",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_LinearVectorForce,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LinearVectorForce,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LinearVectorForce,
    &Dtool_SequenceMethods_LinearVectorForce,
    &Dtool_MappingMethods_LinearVectorForce,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LinearVectorForce,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Simple directed vector force.  Suitable for gravity, non-turbulent wind,\n"
    " * etc...\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LinearVectorForce,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LinearVectorForce,
    PyType_GenericAlloc,
    Dtool_new_LinearVectorForce,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LinearVectorForce,
  Dtool_UpcastInterface_LinearVectorForce,
  Dtool_DowncastInterface_LinearVectorForce,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LinearVectorForce(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LinearForce(nullptr);
    Dtool_LinearVectorForce._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LinearForce);
    Dtool_LinearVectorForce._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LinearVectorForce._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LinearVectorForce) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LinearVectorForce)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LinearVectorForce);
  }
}

/**
 * Python method tables for PhysicsCollisionHandler (PhysicsCollisionHandler)
 */
static PyMethodDef Dtool_Methods_PhysicsCollisionHandler[] = {
  {"set_almost_stationary_speed", &Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_228, METH_O, (const char *)Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_228_comment},
  {"setAlmostStationarySpeed", &Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_228, METH_O, (const char *)Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_228_comment},
  {"get_almost_stationary_speed", &Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_229, METH_NOARGS, (const char *)Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_229_comment},
  {"getAlmostStationarySpeed", &Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_229, METH_NOARGS, (const char *)Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_229_comment},
  {"set_static_friction_coef", &Dtool_PhysicsCollisionHandler_set_static_friction_coef_230, METH_O, (const char *)Dtool_PhysicsCollisionHandler_set_static_friction_coef_230_comment},
  {"setStaticFrictionCoef", &Dtool_PhysicsCollisionHandler_set_static_friction_coef_230, METH_O, (const char *)Dtool_PhysicsCollisionHandler_set_static_friction_coef_230_comment},
  {"get_static_friction_coef", &Dtool_PhysicsCollisionHandler_get_static_friction_coef_231, METH_NOARGS, (const char *)Dtool_PhysicsCollisionHandler_get_static_friction_coef_231_comment},
  {"getStaticFrictionCoef", &Dtool_PhysicsCollisionHandler_get_static_friction_coef_231, METH_NOARGS, (const char *)Dtool_PhysicsCollisionHandler_get_static_friction_coef_231_comment},
  {"set_dynamic_friction_coef", &Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_232, METH_O, (const char *)Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_232_comment},
  {"setDynamicFrictionCoef", &Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_232, METH_O, (const char *)Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_232_comment},
  {"get_dynamic_friction_coef", &Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_233, METH_NOARGS, (const char *)Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_233_comment},
  {"getDynamicFrictionCoef", &Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_233, METH_NOARGS, (const char *)Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_233_comment},
  {"get_class_type", &Dtool_PhysicsCollisionHandler_get_class_type_234, METH_NOARGS | METH_STATIC, (const char *)Dtool_PhysicsCollisionHandler_get_class_type_234_comment},
  {"getClassType", &Dtool_PhysicsCollisionHandler_get_class_type_234, METH_NOARGS | METH_STATIC, (const char *)Dtool_PhysicsCollisionHandler_get_class_type_234_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_PhysicsCollisionHandler = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_PhysicsCollisionHandler = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_PhysicsCollisionHandler = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_PhysicsCollisionHandler = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_PhysicsCollisionHandler = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_PhysicsCollisionHandler = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.PhysicsCollisionHandler",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PhysicsCollisionHandler,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_PhysicsCollisionHandler,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_PhysicsCollisionHandler,
    &Dtool_SequenceMethods_PhysicsCollisionHandler,
    &Dtool_MappingMethods_PhysicsCollisionHandler,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_PhysicsCollisionHandler,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * A specialized kind of CollisionHandler that simply pushes back on things\n"
    " * that attempt to move into solid walls.  This also puts forces onto the\n"
    " * physics objects\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PhysicsCollisionHandler,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PhysicsCollisionHandler,
    PyType_GenericAlloc,
    Dtool_new_PhysicsCollisionHandler,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PhysicsCollisionHandler,
  Dtool_UpcastInterface_PhysicsCollisionHandler,
  Dtool_DowncastInterface_PhysicsCollisionHandler,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PhysicsCollisionHandler(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CollisionHandlerPusher != nullptr);
    assert(Dtool_Ptr_CollisionHandlerPusher->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_CollisionHandlerPusher->_Dtool_ModuleClassInit(nullptr);
    Dtool_PhysicsCollisionHandler._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_CollisionHandlerPusher);
    Dtool_PhysicsCollisionHandler._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PhysicsCollisionHandler._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PhysicsCollisionHandler) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PhysicsCollisionHandler)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PhysicsCollisionHandler);
  }
}

/**
 * Python method tables for PhysicsManager (PhysicsManager)
 */
static PyMethodDef Dtool_Methods_PhysicsManager[] = {
  {"attach_linear_integrator", &Dtool_PhysicsManager_attach_linear_integrator_238, METH_O, (const char *)Dtool_PhysicsManager_attach_linear_integrator_238_comment},
  {"attachLinearIntegrator", &Dtool_PhysicsManager_attach_linear_integrator_238, METH_O, (const char *)Dtool_PhysicsManager_attach_linear_integrator_238_comment},
  {"attach_angular_integrator", &Dtool_PhysicsManager_attach_angular_integrator_239, METH_O, (const char *)Dtool_PhysicsManager_attach_angular_integrator_239_comment},
  {"attachAngularIntegrator", &Dtool_PhysicsManager_attach_angular_integrator_239, METH_O, (const char *)Dtool_PhysicsManager_attach_angular_integrator_239_comment},
  {"attach_physical", &Dtool_PhysicsManager_attach_physical_240, METH_O, (const char *)Dtool_PhysicsManager_attach_physical_240_comment},
  {"attachPhysical", &Dtool_PhysicsManager_attach_physical_240, METH_O, (const char *)Dtool_PhysicsManager_attach_physical_240_comment},
  {"attach_physicalnode", &Dtool_PhysicsManager_attach_physicalnode_241, METH_O, (const char *)Dtool_PhysicsManager_attach_physicalnode_241_comment},
  {"attachPhysicalnode", &Dtool_PhysicsManager_attach_physicalnode_241, METH_O, (const char *)Dtool_PhysicsManager_attach_physicalnode_241_comment},
  {"attach_physical_node", &Dtool_PhysicsManager_attach_physical_node_242, METH_O, (const char *)Dtool_PhysicsManager_attach_physical_node_242_comment},
  {"attachPhysicalNode", &Dtool_PhysicsManager_attach_physical_node_242, METH_O, (const char *)Dtool_PhysicsManager_attach_physical_node_242_comment},
  {"add_linear_force", &Dtool_PhysicsManager_add_linear_force_243, METH_O, (const char *)Dtool_PhysicsManager_add_linear_force_243_comment},
  {"addLinearForce", &Dtool_PhysicsManager_add_linear_force_243, METH_O, (const char *)Dtool_PhysicsManager_add_linear_force_243_comment},
  {"add_angular_force", &Dtool_PhysicsManager_add_angular_force_244, METH_O, (const char *)Dtool_PhysicsManager_add_angular_force_244_comment},
  {"addAngularForce", &Dtool_PhysicsManager_add_angular_force_244, METH_O, (const char *)Dtool_PhysicsManager_add_angular_force_244_comment},
  {"clear_linear_forces", &Dtool_PhysicsManager_clear_linear_forces_245, METH_NOARGS, (const char *)Dtool_PhysicsManager_clear_linear_forces_245_comment},
  {"clearLinearForces", &Dtool_PhysicsManager_clear_linear_forces_245, METH_NOARGS, (const char *)Dtool_PhysicsManager_clear_linear_forces_245_comment},
  {"clear_angular_forces", &Dtool_PhysicsManager_clear_angular_forces_246, METH_NOARGS, (const char *)Dtool_PhysicsManager_clear_angular_forces_246_comment},
  {"clearAngularForces", &Dtool_PhysicsManager_clear_angular_forces_246, METH_NOARGS, (const char *)Dtool_PhysicsManager_clear_angular_forces_246_comment},
  {"clear_physicals", &Dtool_PhysicsManager_clear_physicals_247, METH_NOARGS, (const char *)Dtool_PhysicsManager_clear_physicals_247_comment},
  {"clearPhysicals", &Dtool_PhysicsManager_clear_physicals_247, METH_NOARGS, (const char *)Dtool_PhysicsManager_clear_physicals_247_comment},
  {"set_viscosity", &Dtool_PhysicsManager_set_viscosity_248, METH_O, (const char *)Dtool_PhysicsManager_set_viscosity_248_comment},
  {"setViscosity", &Dtool_PhysicsManager_set_viscosity_248, METH_O, (const char *)Dtool_PhysicsManager_set_viscosity_248_comment},
  {"get_viscosity", &Dtool_PhysicsManager_get_viscosity_249, METH_NOARGS, (const char *)Dtool_PhysicsManager_get_viscosity_249_comment},
  {"getViscosity", &Dtool_PhysicsManager_get_viscosity_249, METH_NOARGS, (const char *)Dtool_PhysicsManager_get_viscosity_249_comment},
  {"remove_physical", &Dtool_PhysicsManager_remove_physical_250, METH_O, (const char *)Dtool_PhysicsManager_remove_physical_250_comment},
  {"removePhysical", &Dtool_PhysicsManager_remove_physical_250, METH_O, (const char *)Dtool_PhysicsManager_remove_physical_250_comment},
  {"remove_physical_node", &Dtool_PhysicsManager_remove_physical_node_251, METH_O, (const char *)Dtool_PhysicsManager_remove_physical_node_251_comment},
  {"removePhysicalNode", &Dtool_PhysicsManager_remove_physical_node_251, METH_O, (const char *)Dtool_PhysicsManager_remove_physical_node_251_comment},
  {"remove_linear_force", &Dtool_PhysicsManager_remove_linear_force_252, METH_O, (const char *)Dtool_PhysicsManager_remove_linear_force_252_comment},
  {"removeLinearForce", &Dtool_PhysicsManager_remove_linear_force_252, METH_O, (const char *)Dtool_PhysicsManager_remove_linear_force_252_comment},
  {"remove_angular_force", &Dtool_PhysicsManager_remove_angular_force_253, METH_O, (const char *)Dtool_PhysicsManager_remove_angular_force_253_comment},
  {"removeAngularForce", &Dtool_PhysicsManager_remove_angular_force_253, METH_O, (const char *)Dtool_PhysicsManager_remove_angular_force_253_comment},
  {"do_physics", (PyCFunction) &Dtool_PhysicsManager_do_physics_254, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_do_physics_254_comment},
  {"doPhysics", (PyCFunction) &Dtool_PhysicsManager_do_physics_254, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_do_physics_254_comment},
  {"init_random_seed", &Dtool_PhysicsManager_init_random_seed_255, METH_NOARGS, (const char *)Dtool_PhysicsManager_init_random_seed_255_comment},
  {"initRandomSeed", &Dtool_PhysicsManager_init_random_seed_255, METH_NOARGS, (const char *)Dtool_PhysicsManager_init_random_seed_255_comment},
  {"output", &Dtool_PhysicsManager_output_256, METH_O, (const char *)Dtool_PhysicsManager_output_256_comment},
  {"write_physicals", (PyCFunction) &Dtool_PhysicsManager_write_physicals_257, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_write_physicals_257_comment},
  {"writePhysicals", (PyCFunction) &Dtool_PhysicsManager_write_physicals_257, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_write_physicals_257_comment},
  {"write_linear_forces", (PyCFunction) &Dtool_PhysicsManager_write_linear_forces_258, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_write_linear_forces_258_comment},
  {"writeLinearForces", (PyCFunction) &Dtool_PhysicsManager_write_linear_forces_258, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_write_linear_forces_258_comment},
  {"write_angular_forces", (PyCFunction) &Dtool_PhysicsManager_write_angular_forces_259, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_write_angular_forces_259_comment},
  {"writeAngularForces", (PyCFunction) &Dtool_PhysicsManager_write_angular_forces_259, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_write_angular_forces_259_comment},
  {"write", (PyCFunction) &Dtool_PhysicsManager_write_260, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_write_260_comment},
  {"debug_output", (PyCFunction) &Dtool_PhysicsManager_debug_output_261, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_debug_output_261_comment},
  {"debugOutput", (PyCFunction) &Dtool_PhysicsManager_debug_output_261, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_PhysicsManager_debug_output_261_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
//  A __repr__ function
//     PhysicsManager
//////////////////
static PyObject *Dtool_Repr_PhysicsManager(PyObject *self) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsManager, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->output(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

//////////////////
//  A __str__ function
//     PhysicsManager
//////////////////
static PyObject *Dtool_Str_PhysicsManager(PyObject *self) {
  PhysicsManager *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_PhysicsManager, (void **)&local_this)) {
    return nullptr;
  }

  std::ostringstream os;
  local_this->write(os);
  std::string ss = os.str();
  return Dtool_WrapValue(ss);
}

static PyNumberMethods Dtool_NumberMethods_PhysicsManager = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_PhysicsManager = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "panda3d.physics.PhysicsManager",
    0, // tp_basicsize
    0, // tp_itemsize
    &Dtool_FreeInstance_PhysicsManager,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    &Dtool_Repr_PhysicsManager,
    &Dtool_NumberMethods_PhysicsManager,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    &Dtool_Str_PhysicsManager,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * Physics don't get much higher-level than this.  Attach as many Physicals\n"
    " * (particle systems, etc..) as you want, pick an integrator and go.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_PhysicsManager,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_PhysicsManager,
    PyType_GenericAlloc,
    Dtool_new_PhysicsManager,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_PhysicsManager,
  Dtool_UpcastInterface_PhysicsManager,
  Dtool_DowncastInterface_PhysicsManager,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_PhysicsManager(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PhysicsManager._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_PhysicsManager._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_PhysicsManager) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(PhysicsManager)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_PhysicsManager);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_libp3physics_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    PhysicsObject::init_type();
    TypeHandle handle = PhysicsObject::get_class_type();
    Dtool_PhysicsObject._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PhysicsObject);
  }
  {
    BaseForce::init_type();
    TypeHandle handle = BaseForce::get_class_type();
    Dtool_BaseForce._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_BaseForce);
  }
  {
    LinearForce::init_type();
    TypeHandle handle = LinearForce::get_class_type();
    Dtool_LinearForce._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LinearForce);
  }
  {
    AngularForce::init_type();
    TypeHandle handle = AngularForce::get_class_type();
    Dtool_AngularForce._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AngularForce);
  }
  {
    Physical::init_type();
    TypeHandle handle = Physical::get_class_type();
    Dtool_Physical._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_Physical);
  }
  {
    PhysicalNode::init_type();
    TypeHandle handle = PhysicalNode::get_class_type();
    Dtool_PhysicalNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PhysicalNode);
  }
  {
    ActorNode::init_type();
    TypeHandle handle = ActorNode::get_class_type();
    Dtool_ActorNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ActorNode);
  }
  {
    AngularVectorForce::init_type();
    TypeHandle handle = AngularVectorForce::get_class_type();
    Dtool_AngularVectorForce._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_AngularVectorForce);
  }
  {
    ForceNode::init_type();
    TypeHandle handle = ForceNode::get_class_type();
    Dtool_ForceNode._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_ForceNode);
  }
  {
    LinearControlForce::init_type();
    TypeHandle handle = LinearControlForce::get_class_type();
    Dtool_LinearControlForce._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LinearControlForce);
  }
  {
    LinearCylinderVortexForce::init_type();
    TypeHandle handle = LinearCylinderVortexForce::get_class_type();
    Dtool_LinearCylinderVortexForce._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LinearCylinderVortexForce);
  }
  {
    LinearDistanceForce::init_type();
    TypeHandle handle = LinearDistanceForce::get_class_type();
    Dtool_LinearDistanceForce._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LinearDistanceForce);
  }
  {
    LinearFrictionForce::init_type();
    TypeHandle handle = LinearFrictionForce::get_class_type();
    Dtool_LinearFrictionForce._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LinearFrictionForce);
  }
  {
    LinearRandomForce::init_type();
    TypeHandle handle = LinearRandomForce::get_class_type();
    Dtool_LinearRandomForce._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LinearRandomForce);
  }
  {
    LinearJitterForce::init_type();
    TypeHandle handle = LinearJitterForce::get_class_type();
    Dtool_LinearJitterForce._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LinearJitterForce);
  }
  {
    LinearNoiseForce::init_type();
    TypeHandle handle = LinearNoiseForce::get_class_type();
    Dtool_LinearNoiseForce._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LinearNoiseForce);
  }
  {
    LinearSinkForce::init_type();
    TypeHandle handle = LinearSinkForce::get_class_type();
    Dtool_LinearSinkForce._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LinearSinkForce);
  }
  {
    LinearSourceForce::init_type();
    TypeHandle handle = LinearSourceForce::get_class_type();
    Dtool_LinearSourceForce._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LinearSourceForce);
  }
  {
    LinearUserDefinedForce::init_type();
    TypeHandle handle = LinearUserDefinedForce::get_class_type();
    Dtool_LinearUserDefinedForce._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LinearUserDefinedForce);
  }
  {
    LinearVectorForce::init_type();
    TypeHandle handle = LinearVectorForce::get_class_type();
    Dtool_LinearVectorForce._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LinearVectorForce);
  }
  {
    PhysicsCollisionHandler::init_type();
    TypeHandle handle = PhysicsCollisionHandler::get_class_type();
    Dtool_PhysicsCollisionHandler._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_PhysicsCollisionHandler);
  }
}

void Dtool_libp3physics_BuildInstants(PyObject *module) {
  (void) module;
  // PhysicsObject
  Dtool_PyModuleClassInit_PhysicsObject(module);
  PyModule_AddObject(module, "PhysicsObject", (PyObject *)&Dtool_PhysicsObject);
  // PhysicsObjectCollection
  Dtool_PyModuleClassInit_PhysicsObjectCollection(module);
  PyModule_AddObject(module, "PhysicsObjectCollection", (PyObject *)&Dtool_PhysicsObjectCollection);
  // BaseForce
  Dtool_PyModuleClassInit_BaseForce(module);
  PyModule_AddObject(module, "BaseForce", (PyObject *)&Dtool_BaseForce);
  // LinearForce
  Dtool_PyModuleClassInit_LinearForce(module);
  PyModule_AddObject(module, "LinearForce", (PyObject *)&Dtool_LinearForce);
  // AngularForce
  Dtool_PyModuleClassInit_AngularForce(module);
  PyModule_AddObject(module, "AngularForce", (PyObject *)&Dtool_AngularForce);
  // Physical
  Dtool_PyModuleClassInit_Physical(module);
  PyModule_AddObject(module, "Physical", (PyObject *)&Dtool_Physical);
  // PhysicalNode
  Dtool_PyModuleClassInit_PhysicalNode(module);
  PyModule_AddObject(module, "PhysicalNode", (PyObject *)&Dtool_PhysicalNode);
  // ActorNode
  Dtool_PyModuleClassInit_ActorNode(module);
  PyModule_AddObject(module, "ActorNode", (PyObject *)&Dtool_ActorNode);
  // BaseIntegrator
  Dtool_PyModuleClassInit_BaseIntegrator(module);
  PyModule_AddObject(module, "BaseIntegrator", (PyObject *)&Dtool_BaseIntegrator);
  // AngularIntegrator
  Dtool_PyModuleClassInit_AngularIntegrator(module);
  PyModule_AddObject(module, "AngularIntegrator", (PyObject *)&Dtool_AngularIntegrator);
  // AngularEulerIntegrator
  Dtool_PyModuleClassInit_AngularEulerIntegrator(module);
  PyModule_AddObject(module, "AngularEulerIntegrator", (PyObject *)&Dtool_AngularEulerIntegrator);
  // AngularVectorForce
  Dtool_PyModuleClassInit_AngularVectorForce(module);
  PyModule_AddObject(module, "AngularVectorForce", (PyObject *)&Dtool_AngularVectorForce);
  // ForceNode
  Dtool_PyModuleClassInit_ForceNode(module);
  PyModule_AddObject(module, "ForceNode", (PyObject *)&Dtool_ForceNode);
  // LinearControlForce
  Dtool_PyModuleClassInit_LinearControlForce(module);
  PyModule_AddObject(module, "LinearControlForce", (PyObject *)&Dtool_LinearControlForce);
  // LinearCylinderVortexForce
  Dtool_PyModuleClassInit_LinearCylinderVortexForce(module);
  PyModule_AddObject(module, "LinearCylinderVortexForce", (PyObject *)&Dtool_LinearCylinderVortexForce);
  // LinearDistanceForce
  Dtool_PyModuleClassInit_LinearDistanceForce(module);
  PyModule_AddObject(module, "LinearDistanceForce", (PyObject *)&Dtool_LinearDistanceForce);
  // LinearIntegrator
  Dtool_PyModuleClassInit_LinearIntegrator(module);
  PyModule_AddObject(module, "LinearIntegrator", (PyObject *)&Dtool_LinearIntegrator);
  // LinearEulerIntegrator
  Dtool_PyModuleClassInit_LinearEulerIntegrator(module);
  PyModule_AddObject(module, "LinearEulerIntegrator", (PyObject *)&Dtool_LinearEulerIntegrator);
  // LinearFrictionForce
  Dtool_PyModuleClassInit_LinearFrictionForce(module);
  PyModule_AddObject(module, "LinearFrictionForce", (PyObject *)&Dtool_LinearFrictionForce);
  // LinearRandomForce
  Dtool_PyModuleClassInit_LinearRandomForce(module);
  PyModule_AddObject(module, "LinearRandomForce", (PyObject *)&Dtool_LinearRandomForce);
  // LinearJitterForce
  Dtool_PyModuleClassInit_LinearJitterForce(module);
  PyModule_AddObject(module, "LinearJitterForce", (PyObject *)&Dtool_LinearJitterForce);
  // LinearNoiseForce
  Dtool_PyModuleClassInit_LinearNoiseForce(module);
  PyModule_AddObject(module, "LinearNoiseForce", (PyObject *)&Dtool_LinearNoiseForce);
  // LinearSinkForce
  Dtool_PyModuleClassInit_LinearSinkForce(module);
  PyModule_AddObject(module, "LinearSinkForce", (PyObject *)&Dtool_LinearSinkForce);
  // LinearSourceForce
  Dtool_PyModuleClassInit_LinearSourceForce(module);
  PyModule_AddObject(module, "LinearSourceForce", (PyObject *)&Dtool_LinearSourceForce);
  // LinearUserDefinedForce
  Dtool_PyModuleClassInit_LinearUserDefinedForce(module);
  PyModule_AddObject(module, "LinearUserDefinedForce", (PyObject *)&Dtool_LinearUserDefinedForce);
  // LinearVectorForce
  Dtool_PyModuleClassInit_LinearVectorForce(module);
  PyModule_AddObject(module, "LinearVectorForce", (PyObject *)&Dtool_LinearVectorForce);
  // PhysicsCollisionHandler
  Dtool_PyModuleClassInit_PhysicsCollisionHandler(module);
  PyModule_AddObject(module, "PhysicsCollisionHandler", (PyObject *)&Dtool_PhysicsCollisionHandler);
  // PhysicsManager
  Dtool_PyModuleClassInit_PhysicsManager(module);
  PyModule_AddObject(module, "PhysicsManager", (PyObject *)&Dtool_PhysicsManager);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef libp3physics_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef libp3physics_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1583614389,  /* file_identifier */
  "libp3physics",  /* library_name */
  "1Scs",  /* library_hash_name */
  "panda3d.physics",  /* module_name */
  "libp3physics.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  610  /* next_index */
};

Configure(_in_configure_libp3physics);
ConfigureFn(_in_configure_libp3physics) {
  interrogate_request_module(&_in_module_def);
}

